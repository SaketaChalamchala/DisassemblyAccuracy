.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 0CC3E45BF4C442CAE8D4726924CC42BB
.rdata:00000000 ; Input CRC32 : 22A57408
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\RunDlg.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR fullCurrentPath
.rdata:00000000 _fullCurrentPath:                       ; DATA XREF: whichVar(wchar_t *)+7o
.rdata:00000000                 unicode 0, <FULL_CURRENT_PATH>,0
.rdata:00000024 ; const WCHAR currentDirectory
.rdata:00000024 _currentDirectory:                      ; DATA XREF: whichVar(wchar_t *)+29o
.rdata:00000024                                         ; .rdata:$SG169297o
.rdata:00000024                 unicode 0, <CURRENT_DIRECTORY>,0
.rdata:00000048 ; const WCHAR onlyFileName
.rdata:00000048 _onlyFileName:                          ; DATA XREF: whichVar(wchar_t *)+4Bo
.rdata:00000048                 unicode 0, <FILE_NAME>,0
.rdata:0000005C ; const WCHAR fileNamePart
.rdata:0000005C _fileNamePart:                          ; DATA XREF: whichVar(wchar_t *)+6Do
.rdata:0000005C                 unicode 0, <NAME_PART>,0
.rdata:00000070 ; const WCHAR fileExtPart
.rdata:00000070 _fileExtPart:                           ; DATA XREF: whichVar(wchar_t *)+8Fo
.rdata:00000070                 unicode 0, <EXT_PART>,0
.rdata:00000082                 align 4
.rdata:00000084 ; const WCHAR currentWord
.rdata:00000084 _currentWord:                           ; DATA XREF: whichVar(wchar_t *)+ABo
.rdata:00000084                 unicode 0, <CURRENT_WORD>,0
.rdata:0000009E                 align 10h
.rdata:000000A0 ; const WCHAR nppDir
.rdata:000000A0 _nppDir:                                ; DATA XREF: whichVar(wchar_t *)+C7o
.rdata:000000A0                 unicode 0, <NPP_DIRECTORY>,0
.rdata:000000BC ; const WCHAR currentLine
.rdata:000000BC _currentLine:                           ; DATA XREF: whichVar(wchar_t *)+E3o
.rdata:000000BC                 unicode 0, <CURRENT_LINE>,0
.rdata:000000D6                 align 4
.rdata:000000D8 ; const WCHAR currentColumn
.rdata:000000D8 _currentColumn:                         ; DATA XREF: whichVar(wchar_t *)+FFo
.rdata:000000D8                 unicode 0, <CURRENT_COLUMN>,0
.rdata:000000F6                 align 4
.rdata:000000F8 ; const WCHAR _SG169259
.rdata:000000F8 $SG169259:                              ; DATA XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+261o
.rdata:000000F8                 unicode 0, <%d>,0
.rdata:000000FE                 align 10h
.rdata:00000100 ; const WCHAR _SG169297
.rdata:00000100 $SG169297       dd offset _currentDirectory+0Ah
.rdata:00000100                                         ; DATA XREF: Command::run(HWND__ *)+192o
.rdata:00000100                                         ; "NT_DIRECTORY"
.rdata:00000104 ; const WCHAR _SG169298
.rdata:00000104 $SG169298:                              ; DATA XREF: Command::run(HWND__ *)+1A5o
.rdata:00000104                 unicode 0, <open>,0
.rdata:0000010E                 align 10h
.rdata:00000110 ; wchar_t _SG169361
.rdata:00000110 $SG169361       dw 0                    ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+342o
.rdata:00000112                 db    0
.rdata:00000113                 db    0
.rdata:00000114 $SG169366:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+402o
.rdata:00000114                 unicode 0, <.bat>,0
.rdata:0000011E                 align 10h
.rdata:00000120 ; wchar_t _SG169362
.rdata:00000120 $SG169362:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+35Do
.rdata:00000120                 unicode 0, <Modify Shortcut/Delete Command...>,0
.rdata:00000164 $SG169367:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+407o
.rdata:00000164                 unicode 0, <.cmd>,0
.rdata:0000016E                 align 10h
.rdata:00000170 $SG169368:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+40Co
.rdata:00000170                 unicode 0, <.com>,0
.rdata:0000017A                 align 4
.rdata:0000017C ; wchar_t _SG169369
.rdata:0000017C $SG169369:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+411o
.rdata:0000017C                 unicode 0, <.exe>,0
.rdata:00000186                 align 4
.rdata:00000188 ; wchar_t _SG169370
.rdata:00000188 $SG169370:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+416o
.rdata:00000188                 unicode 0, <Executable file : >,0
.rdata:000001AE                 align 10h
.rdata:000001B0 ; wchar_t _SG169371
.rdata:000001B0 $SG169371:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+42Co
.rdata:000001B0                 unicode 0, <.*>,0
.rdata:000001B6                 align 4
.rdata:000001B8 ; wchar_t _SG169372
.rdata:000001B8 $SG169372:                              ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+431o
.rdata:000001B8                 unicode 0, <All files : >,0
.rdata:000001D2                 align 4
.rdata:000001D4 ; wchar_t _SG169431
.rdata:000001D4 $SG169431       dd offset _fullCurrentPath+22h
.rdata:000001D4                                         ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+492o
.rdata:000001D4                                         ; ""
.rdata:000001D8 ; wchar_t _SG169432
.rdata:000001D8 $SG169432       dd offset _fullCurrentPath+22h
.rdata:000001D8                                         ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+49Eo
.rdata:000001D8                                         ; ""
.rdata:000001DC $SG144045       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:000001E7                 align 4
.rdata:000001E8 $SG144046       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000C14o
.rdata:000001F4 $SG144047       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000C18o
.rdata:00000200 $SG144048       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:00000C1Co
.rdata:0000020C $SG144049       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000C20o
.rdata:00000218 $SG144050       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000C24o
.rdata:00000224 $SG144051       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000C28o
.rdata:00000230 $SG144052       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:00000C2Co
.rdata:0000023C $SG144053       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000C30o
.rdata:00000248 $SG144054       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000C34o
.rdata:00000254 $SG144055       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000C38o
.rdata:00000260 $SG144056       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:00000C3Co
.rdata:0000026C $SG144057       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000C40o
.rdata:00000278 $SG144058       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000C44o
.rdata:00000284 $SG144059       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000C48o
.rdata:00000290 $SG144060       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:00000C4Co
.rdata:0000029C $SG144061       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000C50o
.rdata:000002A8 $SG144062       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000C54o
.rdata:000002B4 $SG144063       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000C58o
.rdata:000002C0 $SG144064       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:00000C5Co
.rdata:000002CC $SG144065       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000C60o
.rdata:000002D8 $SG144066       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000C64o
.rdata:000002E4 $SG144067       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000C68o
.rdata:000002F0 $SG144068       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:00000C6Co
.rdata:000002FC $SG144069       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000C70o
.rdata:00000308 $SG144070       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000C74o
.rdata:00000314 $SG144071       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000C78o
.rdata:00000320 $SG144072       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:00000C7Co
.rdata:0000032C $SG144073       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000C80o
.rdata:00000338 $SG144074       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000C84o
.rdata:00000344 $SG144075       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000C88o
.rdata:00000350 $SG144076       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:00000C8Co
.rdata:0000035C $SG144077       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000C90o
.rdata:00000368 $SG144078       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000C94o
.rdata:00000374 $SG144079       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000C98o
.rdata:00000380 $SG144080       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:00000C9Co
.rdata:0000038C $SG144081       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000CA0o
.rdata:00000398 $SG144082       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000CA4o
.rdata:000003A4 $SG144083       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000CA8o
.rdata:000003B0 $SG144084       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:00000CACo
.rdata:000003BC $SG144085       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:00000CB0o
.rdata:000003C8 $SG144086       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:00000CB4o
.rdata:000003D4 $SG144087       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:00000CB8o
.rdata:000003E0 $SG144088       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:00000CBCo
.rdata:000003EC $SG144089       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:00000CC0o
.rdata:000003F8 $SG144090       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:00000CC4o
.rdata:00000404 $SG144091       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:00000CC8o
.rdata:00000410 $SG144092       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:00000CCCo
.rdata:0000041C $SG144093       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:00000CD0o
.rdata:00000428 $SG144094       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:00000CD4o
.rdata:00000434 $SG144095       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:00000CD8o
.rdata:00000440 $SG144096       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:00000CDCo
.rdata:0000044C $SG144097       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:00000CE0o
.rdata:00000458 $SG144098       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:00000CE4o
.rdata:00000464 $SG144099       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:00000CE8o
.rdata:00000470 $SG144100       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:00000CECo
.rdata:0000047C $SG144101       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:00000CF0o
.rdata:00000488 $SG144102       db '    .+      ',0     ; DATA XREF: .data:00000CF4o
.rdata:00000495                 align 4
.rdata:00000498 $SG144103       db '    @#$     ',0     ; DATA XREF: .data:00000CF8o
.rdata:000004A5                 align 4
.rdata:000004A8 $SG144104       db '    %&*=    ',0     ; DATA XREF: .data:00000CFCo
.rdata:000004B5                 align 4
.rdata:000004B8 $SG144105       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:00000D00o
.rdata:000004C5                 align 4
.rdata:000004C8 $SG144106       db '    )!~{]^  ',0     ; DATA XREF: .data:00000D04o
.rdata:000004D5                 align 4
.rdata:000004D8 $SG144107       db '    /(_:<[} ',0     ; DATA XREF: .data:00000D08o
.rdata:000004E5                 align 4
.rdata:000004E8 $SG144108       db '    |123456 ',0     ; DATA XREF: .data:00000D0Co
.rdata:000004F5                 align 4
.rdata:000004F8 $SG144109       db '    7890abc ',0     ; DATA XREF: .data:00000D10o
.rdata:00000505                 align 4
.rdata:00000508 $SG144110       db '    defgh   ',0     ; DATA XREF: .data:00000D14o
.rdata:00000515                 align 4
.rdata:00000518 $SG144111       db '    ijkl    ',0     ; DATA XREF: .data:00000D18o
.rdata:00000525                 align 4
.rdata:00000528 $SG144112       db '    mno     ',0     ; DATA XREF: .data:00000D1Co
.rdata:00000535                 align 4
.rdata:00000538 $SG144113       db '    pq      ',0     ; DATA XREF: .data:00000D20o
.rdata:00000545                 align 4
.rdata:00000548 $SG144115       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:00000553                 align 4
.rdata:00000554 $SG144116       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000D2Co
.rdata:00000560 $SG144117       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000D30o
.rdata:0000056C $SG144118       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000D34o
.rdata:00000578 $SG144119       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000D38o
.rdata:00000584 $SG144120       db '#',9,'c #6397E1',0  ; DATA XREF: .data:00000D3Co
.rdata:00000590 $SG144121       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000D40o
.rdata:0000059C $SG144122       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000D44o
.rdata:000005A8 $SG144123       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000D48o
.rdata:000005B4 $SG144124       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:00000D4Co
.rdata:000005C0 $SG144125       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000D50o
.rdata:000005CC $SG144126       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000D54o
.rdata:000005D8 $SG144127       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000D58o
.rdata:000005E4 $SG144128       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:00000D5Co
.rdata:000005F0 $SG144129       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000D60o
.rdata:000005FC $SG144130       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000D64o
.rdata:00000608 $SG144131       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000D68o
.rdata:00000614 $SG144132       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:00000D6Co
.rdata:00000620 $SG144133       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000D70o
.rdata:0000062C $SG144134       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000D74o
.rdata:00000638 $SG144135       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000D78o
.rdata:00000644 $SG144136       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:00000D7Co
.rdata:00000650 $SG144137       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000D80o
.rdata:0000065C $SG144138       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000D84o
.rdata:00000668 $SG144139       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000D88o
.rdata:00000674 $SG144140       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:00000D8Co
.rdata:00000680 $SG144141       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000D90o
.rdata:0000068C $SG144142       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000D94o
.rdata:00000698 $SG144143       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000D98o
.rdata:000006A4 $SG144144       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:00000D9Co
.rdata:000006B0 $SG144145       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000DA0o
.rdata:000006BC $SG144146       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000DA4o
.rdata:000006C8 $SG144147       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000DA8o
.rdata:000006D4 $SG144148       db '4',9,'c #195CC6',0  ; DATA XREF: .data:00000DACo
.rdata:000006E0 $SG144149       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:00000DB0o
.rdata:000006EC $SG144150       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:00000DB4o
.rdata:000006F8 $SG144151       db '7',9,'c #4885D6',0  ; DATA XREF: .data:00000DB8o
.rdata:00000704 $SG144152       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:00000DBCo
.rdata:00000710 $SG144153       db '9',9,'c #6698DB',0  ; DATA XREF: .data:00000DC0o
.rdata:0000071C $SG144154       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:00000DC4o
.rdata:00000728 $SG144155       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:00000DC8o
.rdata:00000734 $SG144156       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:00000DCCo
.rdata:00000740 $SG144157       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:00000DD0o
.rdata:0000074C $SG144158       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:00000DD4o
.rdata:00000758 $SG144159       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:00000DD8o
.rdata:00000764 $SG144160       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:00000DDCo
.rdata:00000770 $SG144161       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:00000DE0o
.rdata:0000077C $SG144162       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:00000DE4o
.rdata:00000788 $SG144163       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:00000DE8o
.rdata:00000794 $SG144164       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:00000DECo
.rdata:000007A0 $SG144165       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:00000DF0o
.rdata:000007AC $SG144166       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:00000DF4o
.rdata:000007B8 $SG144167       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:00000DF8o
.rdata:000007C4 $SG144168       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:00000DFCo
.rdata:000007D0 $SG144169       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:00000E00o
.rdata:000007DC $SG144170       db '         .+ ',0     ; DATA XREF: .data:00000E04o
.rdata:000007E9                 align 4
.rdata:000007EC $SG144171       db '        @#$ ',0     ; DATA XREF: .data:00000E08o
.rdata:000007F9                 align 4
.rdata:000007FC $SG144172       db '       %&*= L',0    ; DATA XREF: .data:00000E0Co
.rdata:0000080A                 align 4
.rdata:0000080C $SG144173       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000E10o
.rdata:00000819                 align 4
.rdata:0000081C $SG144174       db '     )!>~{] ',0     ; DATA XREF: .data:00000E14o
.rdata:00000829                 align 4
.rdata:0000082C $SG144175       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000E18o
.rdata:00000839                 align 4
.rdata:0000083C $SG144176       db '    (}|1234 ',0     ; DATA XREF: .data:00000E1Co
.rdata:00000849                 align 4
.rdata:0000084C $SG144177       db '    567890a ',0     ; DATA XREF: .data:00000E20o
.rdata:00000859                 align 4
.rdata:0000085C $SG144178       db '      bcdef ',0     ; DATA XREF: .data:00000E24o
.rdata:00000869                 align 4
.rdata:0000086C $SG144179       db '       ghij ',0     ; DATA XREF: .data:00000E28o
.rdata:00000879                 align 4
.rdata:0000087C $SG144180       db '        klm ',0     ; DATA XREF: .data:00000E2Co
.rdata:00000889                 align 4
.rdata:0000088C $SG144181       db '         no ',0     ; DATA XREF: .data:00000E30o
.rdata:00000899                 align 4
.rdata:0000089C $SG144183       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:000008A7                 align 4
.rdata:000008A8 $SG144184       db ' ',9,'c None',0     ; DATA XREF: .data:00000E3Co
.rdata:000008B1                 align 4
.rdata:000008B4 $SG144185       db '.',9,'c #545254',0  ; DATA XREF: .data:00000E40o
.rdata:000008C0 $SG144186       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000E44o
.rdata:000008CC $SG144187       db '@',9,'c #646464',0  ; DATA XREF: .data:00000E48o
.rdata:000008D8 $SG144188       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:00000E4Co
.rdata:000008E4 $SG144189       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000E50o
.rdata:000008F0 $SG144190       db '%',9,'c #747284',0  ; DATA XREF: .data:00000E54o
.rdata:000008FC $SG144191       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000E58o
.rdata:00000908 $SG144192       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:00000E5Co
.rdata:00000914 $SG144193       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000E60o
.rdata:00000920 $SG144194       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000E64o
.rdata:0000092C $SG144195       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000E68o
.rdata:00000938 $SG144196       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:00000E6Co
.rdata:00000944 $SG144197       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000E70o
.rdata:00000950 $SG144198       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000E74o
.rdata:0000095C $SG144199       db ')',9,'c #282668',0  ; DATA XREF: .data:00000E78o
.rdata:00000968 $SG144200       db '!',9,'c #24367C',0  ; DATA XREF: .data:00000E7Co
.rdata:00000974 $SG144201       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000E80o
.rdata:00000980 $SG144202       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000E84o
.rdata:0000098C $SG144203       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000E88o
.rdata:00000998 $SG144204       db '^',9,'c #142E7C',0  ; DATA XREF: .data:00000E8Co
.rdata:000009A4 $SG144205       db '/',9,'c #143789',0  ; DATA XREF: .data:00000E90o
.rdata:000009B0 $SG144206       db '(',9,'c #204990',0  ; DATA XREF: .data:00000E94o
.rdata:000009BC $SG144207       db '_',9,'c #174091',0  ; DATA XREF: .data:00000E98o
.rdata:000009C8 $SG144208       db ':',9,'c #0C0630',0  ; DATA XREF: .data:00000E9Co
.rdata:000009D4 $SG144209       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000EA0o
.rdata:000009E0 $SG144210       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000EA4o
.rdata:000009EC $SG144211       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000EA8o
.rdata:000009F8 $SG144212       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:00000EACo
.rdata:00000A04 $SG144213       db '1',9,'c #141244',0  ; DATA XREF: .data:00000EB0o
.rdata:00000A10 $SG144214       db '2',9,'c #24428C',0  ; DATA XREF: .data:00000EB4o
.rdata:00000A1C $SG144215       db '3',9,'c #3462B9',0  ; DATA XREF: .data:00000EB8o
.rdata:00000A28 $SG144216       db '4',9,'c #4470C4',0  ; DATA XREF: .data:00000EBCo
.rdata:00000A34 $SG144217       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:00000EC0o
.rdata:00000A40 $SG144218       db '6',9,'c #4472CC',0  ; DATA XREF: .data:00000EC4o
.rdata:00000A4C $SG144219       db '7',9,'c #24224C',0  ; DATA XREF: .data:00000EC8o
.rdata:00000A58 $SG144220       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:00000ECCo
.rdata:00000A64 $SG144221       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:00000ED0o
.rdata:00000A70 $SG144222       db '0',9,'c #5482DF',0  ; DATA XREF: .data:00000ED4o
.rdata:00000A7C $SG144223       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:00000ED8o
.rdata:00000A88 $SG144224       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:00000EDCo
.rdata:00000A94 $SG144225       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:00000EE0o
.rdata:00000AA0 $SG144226       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:00000EE4o
.rdata:00000AAC $SG144227       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:00000EE8o
.rdata:00000AB8 $SG144228       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:00000EECo
.rdata:00000AC4 $SG144229       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:00000EF0o
.rdata:00000AD0 $SG144230       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:00000EF4o
.rdata:00000ADC $SG144231       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:00000EF8o
.rdata:00000AE8 $SG144232       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:00000EFCo
.rdata:00000AF4 $SG144233       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:00000F00o
.rdata:00000B00 $SG144234       db 'l',9,'c #243250',0  ; DATA XREF: .data:00000F04o
.rdata:00000B0C $SG144235       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:00000F08o
.rdata:00000B18 $SG144236       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:00000F0Co
.rdata:00000B24 $SG144237       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000F10o
.rdata:00000B30 $SG144238       db '     .+.     ',0    ; DATA XREF: .data:00000F14o
.rdata:00000B3E                 align 10h
.rdata:00000B40 $SG144239       db '   @##$##@   ',0    ; DATA XREF: .data:00000F18o
.rdata:00000B4E                 align 10h
.rdata:00000B50 $SG144240       db '  @%&***&%@  ',0    ; DATA XREF: .data:00000F1Co
.rdata:00000B5E                 align 10h
.rdata:00000B60 $SG144241       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000F20o
.rdata:00000B6E                 align 10h
.rdata:00000B70 $SG144242       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000B70                                         ; DATA XREF: .data:00000F24o
.rdata:00000B7E                 align 10h
.rdata:00000B80 $SG144243       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000F28o
.rdata:00000B8E                 align 10h
.rdata:00000B90 $SG144244       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:00000F2Co
.rdata:00000B9E                 align 10h
.rdata:00000BA0 $SG144245       db '12[3455563[21',0    ; DATA XREF: .data:00000F30o
.rdata:00000BAE                 align 10h
.rdata:00000BB0 $SG144246       db '7_365899063_7',0    ; DATA XREF: .data:00000F34o
.rdata:00000BBE                 align 10h
.rdata:00000BC0 $SG144247       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000F38o
.rdata:00000BCE                 align 10h
.rdata:00000BD0 $SG144248       db ' d}8efgfb83d ',0    ; DATA XREF: .data:00000F3Co
.rdata:00000BDE                 align 10h
.rdata:00000BE0 $SG144249       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000F40o
.rdata:00000BEE                 align 10h
.rdata:00000BF0 $SG144250       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000F44o
.rdata:00000BFE                 align 10h
.rdata:00000C00 $SG144251       db '     o@o     ',0    ; DATA XREF: .data:00000F48o
.rdata:00000C0E                 align 10h
.rdata:00000C0E _rdata          ends
.rdata:00000C0E
.data:00000C10 ; ===========================================================================
.data:00000C10
.data:00000C10 ; Segment type: Pure data
.data:00000C10 ; Segment permissions: Read/Write
.data:00000C10 ; Segment alignment 'qword' can not be represented in assembly
.data:00000C10 _data           segment para public 'DATA' use32
.data:00000C10                 assume cs:_data
.data:00000C10                 ;org 0C10h
.data:00000C10 _acTop_xpm      dd offset $SG144045     ; "12 12 56 1"
.data:00000C14                 dd offset $SG144046     ; " \tc #FFFFFF"
.data:00000C18                 dd offset $SG144047     ; ".\tc #8AB2E9"
.data:00000C1C                 dd offset $SG144048     ; "+\tc #CCDCF6"
.data:00000C20                 dd offset $SG144049     ; "@\tc #80ABEA"
.data:00000C24                 dd offset $SG144050     ; "#\tc #7DA9E8"
.data:00000C28                 dd offset $SG144051     ; "$\tc #C7DAF3"
.data:00000C2C                 dd offset $SG144052     ; "%\tc #79A7E6"
.data:00000C30                 dd offset $SG144053     ; "&\tc #ADC8EF"
.data:00000C34                 dd offset $SG144054     ; "*\tc #87B0E8"
.data:00000C38                 dd offset $SG144055     ; "=\tc #BBD2F0"
.data:00000C3C                 dd offset $SG144056     ; "-\tc #6EA0E2"
.data:00000C40                 dd offset $SG144057     ; ";\tc #A8C7EE"
.data:00000C44                 dd offset $SG144058     ; ">\tc #A3C2ED"
.data:00000C48                 dd offset $SG144059     ; ",\tc #75A4E3"
.data:00000C4C                 dd offset $SG144060     ; "'\tc #A7C4EB"
.data:00000C50                 dd offset $SG144061     ; ")\tc #6297E1"
.data:00000C54                 dd offset $SG144062     ; "!\tc #A1C1EC"
.data:00000C58                 dd offset $SG144063     ; "~\tc #92B7E8"
.data:00000C5C                 dd offset $SG144064     ; "{\tc #99BBE9"
.data:00000C60                 dd offset $SG144065     ; "]\tc #6197DD"
.data:00000C64                 dd offset $SG144066     ; "^\tc #96B9E6"
.data:00000C68                 dd offset $SG144067     ; "/\tc #538EDB"
.data:00000C6C                 dd offset $SG144068     ; "(\tc #99BBEA"
.data:00000C70                 dd offset $SG144069     ; "_\tc #80AAE3"
.data:00000C74                 dd offset $SG144070     ; ":\tc #81ABE3"
.data:00000C78                 dd offset $SG144071     ; "<\tc #8AB1E4"
.data:00000C7C                 dd offset $SG144072     ; "[\tc #4B88D6"
.data:00000C80                 dd offset $SG144073     ; "}\tc #4882D1"
.data:00000C84                 dd offset $SG144074     ; "|\tc #4384D6"
.data:00000C88                 dd offset $SG144075     ; "1\tc #90B5E7"
.data:00000C8C                 dd offset $SG144076     ; "2\tc #74A3E0"
.data:00000C90                 dd offset $SG144077     ; "3\tc #77A4E0"
.data:00000C94                 dd offset $SG144078     ; "4\tc #81ABE2"
.data:00000C98                 dd offset $SG144079     ; "5\tc #437FD3"
.data:00000C9C                 dd offset $SG144080     ; "6\tc #7FA2DF"
.data:00000CA0                 dd offset $SG144081     ; "7\tc #3577D2"
.data:00000CA4                 dd offset $SG144082     ; "8\tc #87AFE4"
.data:00000CA8                 dd offset $SG144083     ; "9\tc #72A1DF"
.data:00000CAC                 dd offset $SG144084     ; "0\tc #7CA9E1"
.data:00000CB0                 dd offset $SG144085     ; "a\tc #3F7AD0"
.data:00000CB4                 dd offset $SG144086     ; "b\tc #85A4DE"
.data:00000CB8                 dd offset $SG144087     ; "c\tc #FBFCFE"
.data:00000CBC                 dd offset $SG144088     ; "d\tc #236ECD"
.data:00000CC0                 dd offset $SG144089     ; "e\tc #7EA8E1"
.data:00000CC4                 dd offset $SG144090     ; "f\tc #79A6E0"
.data:00000CC8                 dd offset $SG144091     ; "g\tc #3D77D0"
.data:00000CCC                 dd offset $SG144092     ; "h\tc #87A4DC"
.data:00000CD0                 dd offset $SG144093     ; "i\tc #1A62C9"
.data:00000CD4                 dd offset $SG144094     ; "j\tc #75A3DF"
.data:00000CD8                 dd offset $SG144095     ; "k\tc #3C74CF"
.data:00000CDC                 dd offset $SG144096     ; "l\tc #8DA6DE"
.data:00000CE0                 dd offset $SG144097     ; "m\tc #1859C4"
.data:00000CE4                 dd offset $SG144098     ; "n\tc #3B71CC"
.data:00000CE8                 dd offset $SG144099     ; "o\tc #8EA5DD"
.data:00000CEC                 dd offset $SG144100     ; "p\tc #164EC0"
.data:00000CF0                 dd offset $SG144101     ; "q\tc #92A7DD"
.data:00000CF4                 dd offset $SG144102     ; "    .+      "
.data:00000CF8                 dd offset $SG144103     ; "    @#$     "
.data:00000CFC                 dd offset $SG144104     ; "    %&*=    "
.data:00000D00                 dd offset $SG144105     ; "    -;>,'   "
.data:00000D04                 dd offset $SG144106     ; "    )!~{]^  "
.data:00000D08                 dd offset $SG144107     ; "    /(_:<[} "
.data:00000D0C                 dd offset $SG144108     ; "    |123456 "
.data:00000D10                 dd offset $SG144109     ; "    7890abc "
.data:00000D14                 dd offset $SG144110     ; "    defgh   "
.data:00000D18                 dd offset $SG144111     ; "    ijkl    "
.data:00000D1C                 dd offset $SG144112     ; "    mno     "
.data:00000D20                 dd offset $SG144113     ; "    pq      "
.data:00000D24                 align 8
.data:00000D28 _acBottom_xpm   dd offset $SG144115     ; "12 12 54 1"
.data:00000D2C                 dd offset $SG144116     ; " \tc #FFFFFF"
.data:00000D30                 dd offset $SG144117     ; ".\tc #C4D7F3"
.data:00000D34                 dd offset $SG144118     ; "+\tc #72A1E3"
.data:00000D38                 dd offset $SG144119     ; "@\tc #C1D6F2"
.data:00000D3C                 dd offset $SG144120     ; "#\tc #6397E1"
.data:00000D40                 dd offset $SG144121     ; "$\tc #5990DD"
.data:00000D44                 dd offset $SG144122     ; "%\tc #BBD2F0"
.data:00000D48                 dd offset $SG144123     ; "&\tc #7AA6E5"
.data:00000D4C                 dd offset $SG144124     ; "*\tc #9ABDEA"
.data:00000D50                 dd offset $SG144125     ; "=\tc #4A87D9"
.data:00000D54                 dd offset $SG144126     ; "-\tc #B1CAEE"
.data:00000D58                 dd offset $SG144127     ; ";\tc #75A4E3"
.data:00000D5C                 dd offset $SG144128     ; ">\tc #99BBE9"
.data:00000D60                 dd offset $SG144129     ; ",\tc #95B9E8"
.data:00000D64                 dd offset $SG144130     ; "'\tc #3A7CD4"
.data:00000D68                 dd offset $SG144131     ; ")\tc #A9C6EC"
.data:00000D6C                 dd offset $SG144132     ; "!\tc #71A0E0"
.data:00000D70                 dd offset $SG144133     ; "~\tc #86AFE5"
.data:00000D74                 dd offset $SG144134     ; "{\tc #8DB2E6"
.data:00000D78                 dd offset $SG144135     ; "]\tc #2A72CF"
.data:00000D7C                 dd offset $SG144136     ; "^\tc #73A0E0"
.data:00000D80                 dd offset $SG144137     ; "/\tc #6B9DE0"
.data:00000D84                 dd offset $SG144138     ; "(\tc #95B8E8"
.data:00000D88                 dd offset $SG144139     ; "_\tc #81ABE3"
.data:00000D8C                 dd offset $SG144140     ; ":\tc #72A1DF"
.data:00000D90                 dd offset $SG144141     ; "<\tc #83ADE3"
.data:00000D94                 dd offset $SG144142     ; "[\tc #1B65C9"
.data:00000D98                 dd offset $SG144143     ; "}\tc #5F95DC"
.data:00000D9C                 dd offset $SG144144     ; "|\tc #8BB3E5"
.data:00000DA0                 dd offset $SG144145     ; "1\tc #77A4E0"
.data:00000DA4                 dd offset $SG144146     ; "2\tc #679ADC"
.data:00000DA8                 dd offset $SG144147     ; "3\tc #7AA6E1"
.data:00000DAC                 dd offset $SG144148     ; "4\tc #195CC6"
.data:00000DB0                 dd offset $SG144149     ; "5\tc #FCFDFE"
.data:00000DB4                 dd offset $SG144150     ; "6\tc #8DB2E4"
.data:00000DB8                 dd offset $SG144151     ; "7\tc #4885D6"
.data:00000DBC                 dd offset $SG144152     ; "8\tc #7CA9E1"
.data:00000DC0                 dd offset $SG144153     ; "9\tc #6698DB"
.data:00000DC4                 dd offset $SG144154     ; "0\tc #71A1DE"
.data:00000DC8                 dd offset $SG144155     ; "a\tc #1752C0"
.data:00000DCC                 dd offset $SG144156     ; "b\tc #88ABE0"
.data:00000DD0                 dd offset $SG144157     ; "c\tc #3D77D0"
.data:00000DD4                 dd offset $SG144158     ; "d\tc #6E9FDD"
.data:00000DD8                 dd offset $SG144159     ; "e\tc #699BDC"
.data:00000DDC                 dd offset $SG144160     ; "f\tc #1547BD"
.data:00000DE0                 dd offset $SG144161     ; "g\tc #8DA6DE"
.data:00000DE4                 dd offset $SG144162     ; "h\tc #376BC9"
.data:00000DE8                 dd offset $SG144163     ; "i\tc #6295DA"
.data:00000DEC                 dd offset $SG144164     ; "j\tc #1440B9"
.data:00000DF0                 dd offset $SG144165     ; "k\tc #8DA0DB"
.data:00000DF4                 dd offset $SG144166     ; "l\tc #315FC4"
.data:00000DF8                 dd offset $SG144167     ; "m\tc #1339B7"
.data:00000DFC                 dd offset $SG144168     ; "n\tc #909FDA"
.data:00000E00                 dd offset $SG144169     ; "o\tc #1233B4"
.data:00000E04                 dd offset $SG144170     ; "         .+ "
.data:00000E08                 dd offset $SG144171     ; "        @#$ "
.data:00000E0C                 dd offset $SG144172     ; "       %&*= L"
.data:00000E10                 dd offset $SG144173     ; "      -;>,' "
.data:00000E14                 dd offset $SG144174     ; "     )!>~{] "
.data:00000E18                 dd offset $SG144175     ; "    ^/(_:<[ "
.data:00000E1C                 dd offset $SG144176     ; "    (}|1234 "
.data:00000E20                 dd offset $SG144177     ; "    567890a "
.data:00000E24                 dd offset $SG144178     ; "      bcdef "
.data:00000E28                 dd offset $SG144179     ; "       ghij "
.data:00000E2C                 dd offset $SG144180     ; "        klm "
.data:00000E30                 dd offset $SG144181     ; "         no "
.data:00000E34                 align 8
.data:00000E38 _bookmark_xpm   dd offset $SG144183     ; "13 14 54 1"
.data:00000E3C                 dd offset $SG144184     ; " \tc None"
.data:00000E40                 dd offset $SG144185     ; ".\tc #545254"
.data:00000E44                 dd offset $SG144186     ; "+\tc #3C3E3C"
.data:00000E48                 dd offset $SG144187     ; "@\tc #646464"
.data:00000E4C                 dd offset $SG144188     ; "#\tc #A4A4A4"
.data:00000E50                 dd offset $SG144189     ; "$\tc #B7B8B7"
.data:00000E54                 dd offset $SG144190     ; "%\tc #747284"
.data:00000E58                 dd offset $SG144191     ; "&\tc #B4B2C4"
.data:00000E5C                 dd offset $SG144192     ; "*\tc #DCD7E4"
.data:00000E60                 dd offset $SG144193     ; "=\tc #1C1A1C"
.data:00000E64                 dd offset $SG144194     ; "-\tc #403E58"
.data:00000E68                 dd offset $SG144195     ; ";\tc #5C5A8C"
.data:00000E6C                 dd offset $SG144196     ; ">\tc #7C7EAC"
.data:00000E70                 dd offset $SG144197     ; ",\tc #7C8EBC"
.data:00000E74                 dd offset $SG144198     ; "'\tc #242644"
.data:00000E78                 dd offset $SG144199     ; ")\tc #282668"
.data:00000E7C                 dd offset $SG144200     ; "!\tc #24367C"
.data:00000E80                 dd offset $SG144201     ; "~\tc #244A84"
.data:00000E84                 dd offset $SG144202     ; "{\tc #2C5098"
.data:00000E88                 dd offset $SG144203     ; "]\tc #14162C"
.data:00000E8C                 dd offset $SG144204     ; "^\tc #142E7C"
.data:00000E90                 dd offset $SG144205     ; "/\tc #143789"
.data:00000E94                 dd offset $SG144206     ; "(\tc #204990"
.data:00000E98                 dd offset $SG144207     ; "_\tc #174091"
.data:00000E9C                 dd offset $SG144208     ; ":\tc #0C0630"
.data:00000EA0                 dd offset $SG144209     ; "<\tc #24327C"
.data:00000EA4                 dd offset $SG144210     ; "[\tc #2450A0"
.data:00000EA8                 dd offset $SG144211     ; "}\tc #345DB4"
.data:00000EAC                 dd offset $SG144212     ; "|\tc #3C68B8"
.data:00000EB0                 dd offset $SG144213     ; "1\tc #141244"
.data:00000EB4                 dd offset $SG144214     ; "2\tc #24428C"
.data:00000EB8                 dd offset $SG144215     ; "3\tc #3462B9"
.data:00000EBC                 dd offset $SG144216     ; "4\tc #4470C4"
.data:00000EC0                 dd offset $SG144217     ; "5\tc #4C7FD6"
.data:00000EC4                 dd offset $SG144218     ; "6\tc #4472CC"
.data:00000EC8                 dd offset $SG144219     ; "7\tc #24224C"
.data:00000ECC                 dd offset $SG144220     ; "8\tc #5C8DEC"
.data:00000ED0                 dd offset $SG144221     ; "9\tc #5C94F6"
.data:00000ED4                 dd offset $SG144222     ; "0\tc #5482DF"
.data:00000ED8                 dd offset $SG144223     ; "a\tc #619DF7"
.data:00000EDC                 dd offset $SG144224     ; "b\tc #6CA6FC"
.data:00000EE0                 dd offset $SG144225     ; "c\tc #64A2FC"
.data:00000EE4                 dd offset $SG144226     ; "d\tc #1C2E5C"
.data:00000EE8                 dd offset $SG144227     ; "e\tc #6CA2FC"
.data:00000EEC                 dd offset $SG144228     ; "f\tc #74B2FC"
.data:00000EF0                 dd offset $SG144229     ; "g\tc #7CB8FC"
.data:00000EF4                 dd offset $SG144230     ; "h\tc #1C3264"
.data:00000EF8                 dd offset $SG144231     ; "i\tc #346AD4"
.data:00000EFC                 dd offset $SG144232     ; "j\tc #7CBEFC"
.data:00000F00                 dd offset $SG144233     ; "k\tc #3C72DC"
.data:00000F04                 dd offset $SG144234     ; "l\tc #243250"
.data:00000F08                 dd offset $SG144235     ; "m\tc #346AB4"
.data:00000F0C                 dd offset $SG144236     ; "n\tc #3C82DC"
.data:00000F10                 dd offset $SG144237     ; "o\tc #6C6A6C"
.data:00000F14                 dd offset $SG144238     ; "     .+.     "
.data:00000F18                 dd offset $SG144239     ; "   @##$##@   "
.data:00000F1C                 dd offset $SG144240     ; "  @%&***&%@  "
.data:00000F20                 dd offset $SG144241     ; " =-;>,,,>;-= "
.data:00000F24                 dd offset $SG144242     ; " ')!~{{{~!)' "
.data:00000F28                 dd offset $SG144243     ; "])^/({{{(_^)]"
.data:00000F2C                 dd offset $SG144244     ; ":<_[}|||}[_<:"
.data:00000F30                 dd offset $SG144245     ; "12[3455563[21"
.data:00000F34                 dd offset $SG144246     ; "7_365899063_7"
.data:00000F38                 dd offset $SG144247     ; " /|09abc904/ "
.data:00000F3C                 dd offset $SG144248     ; " d}8efgfb83d "
.data:00000F40                 dd offset $SG144249     ; "  hiafjgakh  "
.data:00000F44                 dd offset $SG144250     ; "   l~mnm~l   "
.data:00000F48                 dd offset $SG144251     ; "     o@o     "
.data:00000F48 _data           ends
.data:00000F48
.text$mn:00000F4C ; ===========================================================================
.text$mn:00000F4C
.text$mn:00000F4C ; Segment type: Pure code
.text$mn:00000F4C ; Segment permissions: Read/Execute
.text$mn:00000F4C _text$mn        segment para public 'CODE' use32
.text$mn:00000F4C                 assume cs:_text$mn
.text$mn:00000F4C                 ;org 0F4Ch
.text$mn:00000F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F4C
.text$mn:00000F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00000F4C
.text$mn:00000F4C ; Attributes: bp-based frame
.text$mn:00000F4C
.text$mn:00000F4C ; int __cdecl whichVar(LPCWSTR lpString2)
.text$mn:00000F4C                 public ?whichVar@@YAHPA_W@Z
.text$mn:00000F4C ?whichVar@@YAHPA_W@Z proc near          ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+1BEp
.text$mn:00000F4C
.text$mn:00000F4C lpString2       = dword ptr  8
.text$mn:00000F4C
.text$mn:00000F4C                 push    ebp
.text$mn:00000F4D                 mov     ebp, esp
.text$mn:00000F4F                 mov     eax, [ebp+lpString2]
.text$mn:00000F52                 push    eax             ; lpString2
.text$mn:00000F53                 push    offset _fullCurrentPath ; "FULL_CURRENT_PATH"
.text$mn:00000F58                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00000F5E                 test    eax, eax
.text$mn:00000F60                 jnz     short loc_F71
.text$mn:00000F62                 mov     eax, 1
.text$mn:00000F67                 jmp     loc_1063
.text$mn:00000F6C ; ---------------------------------------------------------------------------
.text$mn:00000F6C                 jmp     loc_1061
.text$mn:00000F71 ; ---------------------------------------------------------------------------
.text$mn:00000F71
.text$mn:00000F71 loc_F71:                                ; CODE XREF: whichVar(wchar_t *)+14j
.text$mn:00000F71                 mov     ecx, [ebp+lpString2]
.text$mn:00000F74                 push    ecx             ; lpString2
.text$mn:00000F75                 push    offset _currentDirectory ; "CURRENT_DIRECTORY"
.text$mn:00000F7A                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00000F80                 test    eax, eax
.text$mn:00000F82                 jnz     short loc_F93
.text$mn:00000F84                 mov     eax, 2
.text$mn:00000F89                 jmp     loc_1063
.text$mn:00000F8E ; ---------------------------------------------------------------------------
.text$mn:00000F8E                 jmp     loc_1061
.text$mn:00000F93 ; ---------------------------------------------------------------------------
.text$mn:00000F93
.text$mn:00000F93 loc_F93:                                ; CODE XREF: whichVar(wchar_t *)+36j
.text$mn:00000F93                 mov     edx, [ebp+lpString2]
.text$mn:00000F96                 push    edx             ; lpString2
.text$mn:00000F97                 push    offset _onlyFileName ; "FILE_NAME"
.text$mn:00000F9C                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00000FA2                 test    eax, eax
.text$mn:00000FA4                 jnz     short loc_FB5
.text$mn:00000FA6                 mov     eax, 3
.text$mn:00000FAB                 jmp     loc_1063
.text$mn:00000FB0 ; ---------------------------------------------------------------------------
.text$mn:00000FB0                 jmp     loc_1061
.text$mn:00000FB5 ; ---------------------------------------------------------------------------
.text$mn:00000FB5
.text$mn:00000FB5 loc_FB5:                                ; CODE XREF: whichVar(wchar_t *)+58j
.text$mn:00000FB5                 mov     eax, [ebp+lpString2]
.text$mn:00000FB8                 push    eax             ; lpString2
.text$mn:00000FB9                 push    offset _fileNamePart ; "NAME_PART"
.text$mn:00000FBE                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00000FC4                 test    eax, eax
.text$mn:00000FC6                 jnz     short loc_FD7
.text$mn:00000FC8                 mov     eax, 4
.text$mn:00000FCD                 jmp     loc_1063
.text$mn:00000FD2 ; ---------------------------------------------------------------------------
.text$mn:00000FD2                 jmp     loc_1061
.text$mn:00000FD7 ; ---------------------------------------------------------------------------
.text$mn:00000FD7
.text$mn:00000FD7 loc_FD7:                                ; CODE XREF: whichVar(wchar_t *)+7Aj
.text$mn:00000FD7                 mov     ecx, [ebp+lpString2]
.text$mn:00000FDA                 push    ecx             ; lpString2
.text$mn:00000FDB                 push    offset _fileExtPart ; "EXT_PART"
.text$mn:00000FE0                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00000FE6                 test    eax, eax
.text$mn:00000FE8                 jnz     short loc_FF3
.text$mn:00000FEA                 mov     eax, 5
.text$mn:00000FEF                 jmp     short loc_1063
.text$mn:00000FF1 ; ---------------------------------------------------------------------------
.text$mn:00000FF1                 jmp     short loc_1061
.text$mn:00000FF3 ; ---------------------------------------------------------------------------
.text$mn:00000FF3
.text$mn:00000FF3 loc_FF3:                                ; CODE XREF: whichVar(wchar_t *)+9Cj
.text$mn:00000FF3                 mov     edx, [ebp+lpString2]
.text$mn:00000FF6                 push    edx             ; lpString2
.text$mn:00000FF7                 push    offset _currentWord ; "CURRENT_WORD"
.text$mn:00000FFC                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00001002                 test    eax, eax
.text$mn:00001004                 jnz     short loc_100F
.text$mn:00001006                 mov     eax, 6
.text$mn:0000100B                 jmp     short loc_1063
.text$mn:0000100D ; ---------------------------------------------------------------------------
.text$mn:0000100D                 jmp     short loc_1061
.text$mn:0000100F ; ---------------------------------------------------------------------------
.text$mn:0000100F
.text$mn:0000100F loc_100F:                               ; CODE XREF: whichVar(wchar_t *)+B8j
.text$mn:0000100F                 mov     eax, [ebp+lpString2]
.text$mn:00001012                 push    eax             ; lpString2
.text$mn:00001013                 push    offset _nppDir  ; "NPP_DIRECTORY"
.text$mn:00001018                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:0000101E                 test    eax, eax
.text$mn:00001020                 jnz     short loc_102B
.text$mn:00001022                 mov     eax, 7
.text$mn:00001027                 jmp     short loc_1063
.text$mn:00001029 ; ---------------------------------------------------------------------------
.text$mn:00001029                 jmp     short loc_1061
.text$mn:0000102B ; ---------------------------------------------------------------------------
.text$mn:0000102B
.text$mn:0000102B loc_102B:                               ; CODE XREF: whichVar(wchar_t *)+D4j
.text$mn:0000102B                 mov     ecx, [ebp+lpString2]
.text$mn:0000102E                 push    ecx             ; lpString2
.text$mn:0000102F                 push    offset _currentLine ; "CURRENT_LINE"
.text$mn:00001034                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:0000103A                 test    eax, eax
.text$mn:0000103C                 jnz     short loc_1047
.text$mn:0000103E                 mov     eax, 8
.text$mn:00001043                 jmp     short loc_1063
.text$mn:00001045 ; ---------------------------------------------------------------------------
.text$mn:00001045                 jmp     short loc_1061
.text$mn:00001047 ; ---------------------------------------------------------------------------
.text$mn:00001047
.text$mn:00001047 loc_1047:                               ; CODE XREF: whichVar(wchar_t *)+F0j
.text$mn:00001047                 mov     edx, [ebp+lpString2]
.text$mn:0000104A                 push    edx             ; lpString2
.text$mn:0000104B                 push    offset _currentColumn ; "CURRENT_COLUMN"
.text$mn:00001050                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:00001056                 test    eax, eax
.text$mn:00001058                 jnz     short loc_1061
.text$mn:0000105A                 mov     eax, 9
.text$mn:0000105F                 jmp     short loc_1063
.text$mn:00001061 ; ---------------------------------------------------------------------------
.text$mn:00001061
.text$mn:00001061 loc_1061:                               ; CODE XREF: whichVar(wchar_t *)+20j
.text$mn:00001061                                         ; whichVar(wchar_t *)+42j ...
.text$mn:00001061                 xor     eax, eax
.text$mn:00001063
.text$mn:00001063 loc_1063:                               ; CODE XREF: whichVar(wchar_t *)+1Bj
.text$mn:00001063                                         ; whichVar(wchar_t *)+3Dj ...
.text$mn:00001063                 pop     ebp
.text$mn:00001064                 retn
.text$mn:00001064 ?whichVar@@YAHPA_W@Z endp
.text$mn:00001064
.text$mn:00001064 ; ---------------------------------------------------------------------------
.text$mn:00001065                 db 7 dup(0CCh)
.text$mn:0000106C
.text$mn:0000106C ; =============== S U B R O U T I N E =======================================
.text$mn:0000106C
.text$mn:0000106C ; Attributes: bp-based frame
.text$mn:0000106C
.text$mn:0000106C ; void __cdecl expandNppEnvironmentStrs(LPCWSTR lpString, wchar_t *, unsigned int, HWND hWnd)
.text$mn:0000106C                 public ?expandNppEnvironmentStrs@@YAXPB_WPA_WIPAUHWND__@@@Z
.text$mn:0000106C ?expandNppEnvironmentStrs@@YAXPB_WPA_WIPAUHWND__@@@Z proc near
.text$mn:0000106C                                         ; CODE XREF: Command::run(HWND__ *)+169p
.text$mn:0000106C                                         ; Command::run(HWND__ *)+188p
.text$mn:0000106C
.text$mn:0000106C var_1240        = dword ptr -1240h
.text$mn:0000106C var_123C        = dword ptr -123Ch
.text$mn:0000106C var_1238        = dword ptr -1238h
.text$mn:0000106C var_1234        = dword ptr -1234h
.text$mn:0000106C var_1230        = dword ptr -1230h
.text$mn:0000106C var_122C        = dword ptr -122Ch
.text$mn:0000106C var_1228        = dword ptr -1228h
.text$mn:0000106C var_1224        = dword ptr -1224h
.text$mn:0000106C var_1220        = dword ptr -1220h
.text$mn:0000106C var_121C        = dword ptr -121Ch
.text$mn:0000106C var_1218        = dword ptr -1218h
.text$mn:0000106C var_1214        = dword ptr -1214h
.text$mn:0000106C var_1210        = dword ptr -1210h
.text$mn:0000106C String          = word ptr -120Ch
.text$mn:0000106C String2         = word ptr -20Ch
.text$mn:0000106C var_4           = dword ptr -4
.text$mn:0000106C lpString        = dword ptr  8
.text$mn:0000106C arg_4           = dword ptr  0Ch
.text$mn:0000106C arg_8           = dword ptr  10h
.text$mn:0000106C hWnd            = dword ptr  14h
.text$mn:0000106C
.text$mn:0000106C                 push    ebp
.text$mn:0000106D                 mov     ebp, esp
.text$mn:0000106F                 mov     eax, 1240h
.text$mn:00001074                 call    __chkstk
.text$mn:00001079                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000107E                 xor     eax, ebp
.text$mn:00001080                 mov     [ebp+var_4], eax
.text$mn:00001083                 push    esi
.text$mn:00001084                 mov     [ebp+var_1214], 0
.text$mn:0000108E                 mov     [ebp+var_1210], 0
.text$mn:00001098                 mov     eax, [ebp+lpString]
.text$mn:0000109B                 push    eax             ; lpString
.text$mn:0000109C                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000010A2                 mov     [ebp+var_1240], eax
.text$mn:000010A8                 jmp     short loc_10B9
.text$mn:000010AA ; ---------------------------------------------------------------------------
.text$mn:000010AA
.text$mn:000010AA loc_10AA:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_1409j
.text$mn:000010AA                 mov     ecx, [ebp+var_1210]
.text$mn:000010B0                 add     ecx, 1
.text$mn:000010B3                 mov     [ebp+var_1210], ecx
.text$mn:000010B9
.text$mn:000010B9 loc_10B9:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+3Cj
.text$mn:000010B9                 mov     edx, [ebp+var_1210]
.text$mn:000010BF                 cmp     edx, [ebp+var_1240]
.text$mn:000010C5                 jnb     loc_140E
.text$mn:000010CB                 mov     [ebp+var_121C], 0FFFFFFFFh
.text$mn:000010D5                 mov     [ebp+var_122C], 0FFFFFFFFh
.text$mn:000010DF                 mov     eax, [ebp+var_1210]
.text$mn:000010E5                 mov     ecx, [ebp+lpString]
.text$mn:000010E8                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:000010EC                 cmp     edx, 24h ; '$'
.text$mn:000010EF                 jnz     loc_1177
.text$mn:000010F5                 mov     eax, [ebp+var_1210]
.text$mn:000010FB                 mov     ecx, [ebp+lpString]
.text$mn:000010FE                 movzx   edx, word ptr [ecx+eax*2+2]
.text$mn:00001103                 cmp     edx, 28h ; '('
.text$mn:00001106                 jnz     short loc_1177
.text$mn:00001108                 mov     eax, [ebp+var_1210]
.text$mn:0000110E                 add     eax, 2
.text$mn:00001111                 mov     [ebp+var_1210], eax
.text$mn:00001117                 mov     ecx, [ebp+var_1210]
.text$mn:0000111D                 mov     [ebp+var_121C], ecx
.text$mn:00001123                 mov     edx, [ebp+lpString]
.text$mn:00001126                 push    edx             ; lpString
.text$mn:00001127                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:0000112D                 mov     [ebp+var_123C], eax
.text$mn:00001133                 jmp     short loc_1144
.text$mn:00001135 ; ---------------------------------------------------------------------------
.text$mn:00001135
.text$mn:00001135 loc_1135:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_1175j
.text$mn:00001135                 mov     eax, [ebp+var_1210]
.text$mn:0000113B                 add     eax, 1
.text$mn:0000113E                 mov     [ebp+var_1210], eax
.text$mn:00001144
.text$mn:00001144 loc_1144:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+C7j
.text$mn:00001144                 mov     ecx, [ebp+var_1210]
.text$mn:0000114A                 cmp     ecx, [ebp+var_123C]
.text$mn:00001150                 jnb     short loc_1177
.text$mn:00001152                 mov     edx, [ebp+var_1210]
.text$mn:00001158                 mov     eax, [ebp+lpString]
.text$mn:0000115B                 movzx   ecx, word ptr [eax+edx*2]
.text$mn:0000115F                 cmp     ecx, 29h ; ')'
.text$mn:00001162                 jnz     short loc_1175
.text$mn:00001164                 mov     edx, [ebp+var_1210]
.text$mn:0000116A                 sub     edx, 1
.text$mn:0000116D                 mov     [ebp+var_122C], edx
.text$mn:00001173                 jmp     short loc_1177
.text$mn:00001175 ; ---------------------------------------------------------------------------
.text$mn:00001175
.text$mn:00001175 loc_1175:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+F6j
.text$mn:00001175                 jmp     short loc_1135
.text$mn:00001177 ; ---------------------------------------------------------------------------
.text$mn:00001177
.text$mn:00001177 loc_1177:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+83j
.text$mn:00001177                                         ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+9Aj ...
.text$mn:00001177                 cmp     [ebp+var_121C], 0FFFFFFFFh
.text$mn:0000117E                 jz      loc_13CE
.text$mn:00001184                 cmp     [ebp+var_122C], 0FFFFFFFFh
.text$mn:0000118B                 jz      loc_1382
.text$mn:00001191                 mov     [ebp+var_1224], 0
.text$mn:0000119B                 mov     eax, [ebp+var_121C]
.text$mn:000011A1                 mov     [ebp+var_1220], eax
.text$mn:000011A7                 jmp     short loc_11B8
.text$mn:000011A9 ; ---------------------------------------------------------------------------
.text$mn:000011A9
.text$mn:000011A9 loc_11A9:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+184j
.text$mn:000011A9                 mov     ecx, [ebp+var_1220]
.text$mn:000011AF                 add     ecx, 1
.text$mn:000011B2                 mov     [ebp+var_1220], ecx
.text$mn:000011B8
.text$mn:000011B8 loc_11B8:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+13Bj
.text$mn:000011B8                 mov     edx, [ebp+var_1220]
.text$mn:000011BE                 cmp     edx, [ebp+var_122C]
.text$mn:000011C4                 jg      short loc_11F2
.text$mn:000011C6                 mov     eax, [ebp+var_1224]
.text$mn:000011CC                 mov     ecx, [ebp+var_1220]
.text$mn:000011D2                 mov     edx, [ebp+lpString]
.text$mn:000011D5                 mov     cx, [edx+ecx*2]
.text$mn:000011D9                 mov     [ebp+eax*2+String2], cx
.text$mn:000011E1                 mov     edx, [ebp+var_1224]
.text$mn:000011E7                 add     edx, 1
.text$mn:000011EA                 mov     [ebp+var_1224], edx
.text$mn:000011F0                 jmp     short loc_11A9
.text$mn:000011F2 ; ---------------------------------------------------------------------------
.text$mn:000011F2
.text$mn:000011F2 loc_11F2:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+158j
.text$mn:000011F2                 mov     eax, [ebp+var_1224]
.text$mn:000011F8                 shl     eax, 1
.text$mn:000011FA                 mov     [ebp+var_1230], eax
.text$mn:00001200                 cmp     [ebp+var_1230], 208h
.text$mn:0000120A                 jnb     short loc_120E
.text$mn:0000120C                 jmp     short loc_1213
.text$mn:0000120E ; ---------------------------------------------------------------------------
.text$mn:0000120E
.text$mn:0000120E loc_120E:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+19Ej
.text$mn:0000120E                 call    ___report_rangecheckfailure
.text$mn:00001213
.text$mn:00001213 loc_1213:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+1A0j
.text$mn:00001213                 xor     ecx, ecx
.text$mn:00001215                 mov     edx, [ebp+var_1230]
.text$mn:0000121B                 mov     [ebp+edx+String2], cx
.text$mn:00001223                 lea     eax, [ebp+String2]
.text$mn:00001229                 push    eax             ; lpString2
.text$mn:0000122A                 call    ?whichVar@@YAHPA_W@Z ; whichVar(wchar_t *)
.text$mn:0000122F                 add     esp, 4
.text$mn:00001232                 mov     [ebp+var_1218], eax
.text$mn:00001238                 cmp     [ebp+var_1218], 0
.text$mn:0000123F                 jnz     short loc_1293
.text$mn:00001241                 mov     ecx, [ebp+var_121C]
.text$mn:00001247                 sub     ecx, 2
.text$mn:0000124A                 mov     [ebp+var_1210], ecx
.text$mn:00001250                 mov     edx, [ebp+arg_8]
.text$mn:00001253                 sub     edx, 1
.text$mn:00001256                 cmp     [ebp+var_1214], edx
.text$mn:0000125C                 jnb     short loc_1289
.text$mn:0000125E                 mov     eax, [ebp+var_1214]
.text$mn:00001264                 mov     ecx, [ebp+arg_4]
.text$mn:00001267                 mov     edx, [ebp+var_1210]
.text$mn:0000126D                 mov     esi, [ebp+lpString]
.text$mn:00001270                 mov     dx, [esi+edx*2]
.text$mn:00001274                 mov     [ecx+eax*2], dx
.text$mn:00001278                 mov     eax, [ebp+var_1214]
.text$mn:0000127E                 add     eax, 1
.text$mn:00001281                 mov     [ebp+var_1214], eax
.text$mn:00001287                 jmp     short loc_128E
.text$mn:00001289 ; ---------------------------------------------------------------------------
.text$mn:00001289
.text$mn:00001289 loc_1289:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+1F0j
.text$mn:00001289                 jmp     loc_140E
.text$mn:0000128E ; ---------------------------------------------------------------------------
.text$mn:0000128E
.text$mn:0000128E loc_128E:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+21Bj
.text$mn:0000128E                 jmp     loc_1380
.text$mn:00001293 ; ---------------------------------------------------------------------------
.text$mn:00001293
.text$mn:00001293 loc_1293:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+1D3j
.text$mn:00001293                 cmp     [ebp+var_1218], 8
.text$mn:0000129A                 jz      short loc_12A5
.text$mn:0000129C                 cmp     [ebp+var_1218], 9
.text$mn:000012A3                 jnz     short loc_12E4
.text$mn:000012A5
.text$mn:000012A5 loc_12A5:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+22Ej
.text$mn:000012A5                 push    0               ; lParam
.text$mn:000012A7                 push    0               ; wParam
.text$mn:000012A9                 mov     ecx, [ebp+var_1218]
.text$mn:000012AF                 add     ecx, 0FB8h
.text$mn:000012B5                 push    ecx             ; Msg
.text$mn:000012B6                 mov     edx, [ebp+hWnd]
.text$mn:000012B9                 push    edx             ; hWnd
.text$mn:000012BA                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000012C0                 mov     [ebp+var_1238], eax
.text$mn:000012C6                 mov     eax, [ebp+var_1238]
.text$mn:000012CC                 push    eax
.text$mn:000012CD                 push    offset $SG169259 ; "%d"
.text$mn:000012D2                 lea     ecx, [ebp+String]
.text$mn:000012D8                 push    ecx             ; LPWSTR
.text$mn:000012D9                 call    dword ptr ds:__imp__wsprintfW
.text$mn:000012DF                 add     esp, 0Ch
.text$mn:000012E2                 jmp     short loc_1306
.text$mn:000012E4 ; ---------------------------------------------------------------------------
.text$mn:000012E4
.text$mn:000012E4 loc_12E4:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+237j
.text$mn:000012E4                 lea     edx, [ebp+String]
.text$mn:000012EA                 push    edx             ; lParam
.text$mn:000012EB                 push    800h            ; wParam
.text$mn:000012F0                 mov     eax, [ebp+var_1218]
.text$mn:000012F6                 add     eax, 0FB8h
.text$mn:000012FB                 push    eax             ; Msg
.text$mn:000012FC                 mov     ecx, [ebp+hWnd]
.text$mn:000012FF                 push    ecx             ; hWnd
.text$mn:00001300                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001306
.text$mn:00001306 loc_1306:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+276j
.text$mn:00001306                 mov     [ebp+var_1228], 0
.text$mn:00001310                 lea     edx, [ebp+String]
.text$mn:00001316                 push    edx             ; lpString
.text$mn:00001317                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:0000131D                 mov     [ebp+var_1234], eax
.text$mn:00001323                 jmp     short loc_1334
.text$mn:00001325 ; ---------------------------------------------------------------------------
.text$mn:00001325
.text$mn:00001325 loc_1325:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_137Ej
.text$mn:00001325                 mov     eax, [ebp+var_1228]
.text$mn:0000132B                 add     eax, 1
.text$mn:0000132E                 mov     [ebp+var_1228], eax
.text$mn:00001334
.text$mn:00001334 loc_1334:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+2B7j
.text$mn:00001334                 mov     ecx, [ebp+var_1228]
.text$mn:0000133A                 cmp     ecx, [ebp+var_1234]
.text$mn:00001340                 jnb     short loc_1380
.text$mn:00001342                 mov     edx, [ebp+arg_8]
.text$mn:00001345                 sub     edx, 1
.text$mn:00001348                 cmp     [ebp+var_1214], edx
.text$mn:0000134E                 jnb     short loc_137C
.text$mn:00001350                 mov     eax, [ebp+var_1214]
.text$mn:00001356                 mov     ecx, [ebp+arg_4]
.text$mn:00001359                 mov     edx, [ebp+var_1228]
.text$mn:0000135F                 mov     dx, [ebp+edx*2+String]
.text$mn:00001367                 mov     [ecx+eax*2], dx
.text$mn:0000136B                 mov     eax, [ebp+var_1214]
.text$mn:00001371                 add     eax, 1
.text$mn:00001374                 mov     [ebp+var_1214], eax
.text$mn:0000137A                 jmp     short loc_137E
.text$mn:0000137C ; ---------------------------------------------------------------------------
.text$mn:0000137C
.text$mn:0000137C loc_137C:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+2E2j
.text$mn:0000137C                 jmp     short loc_1380
.text$mn:0000137E ; ---------------------------------------------------------------------------
.text$mn:0000137E
.text$mn:0000137E loc_137E:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+30Ej
.text$mn:0000137E                 jmp     short loc_1325
.text$mn:00001380 ; ---------------------------------------------------------------------------
.text$mn:00001380
.text$mn:00001380 loc_1380:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_128Ej
.text$mn:00001380                                         ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+2D4j ...
.text$mn:00001380                 jmp     short loc_13CC
.text$mn:00001382 ; ---------------------------------------------------------------------------
.text$mn:00001382
.text$mn:00001382 loc_1382:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+11Fj
.text$mn:00001382                 mov     ecx, [ebp+var_121C]
.text$mn:00001388
.text$mn:00001388 ; const WCHAR TemplateName
.text$mn:00001388 TemplateName:                           ; DATA XREF: Shortcut::doDialog(void)+17o
.text$mn:00001388                 sub     ecx, 2
.text$mn:0000138B                 mov     [ebp+var_1210], ecx
.text$mn:00001391                 mov     edx, [ebp+arg_8]
.text$mn:00001394                 sub     edx, 1
.text$mn:00001397                 cmp     [ebp+var_1214], edx
.text$mn:0000139D                 jnb     short loc_13CA
.text$mn:0000139F                 mov     eax, [ebp+var_1214]
.text$mn:000013A5                 mov     ecx, [ebp+arg_4]
.text$mn:000013A8                 mov     edx, [ebp+var_1210]
.text$mn:000013AE                 mov     esi, [ebp+lpString]
.text$mn:000013B1                 mov     dx, [esi+edx*2]
.text$mn:000013B5                 mov     [ecx+eax*2], dx
.text$mn:000013B9                 mov     eax, [ebp+var_1214]
.text$mn:000013BF                 add     eax, 1
.text$mn:000013C2                 mov     [ebp+var_1214], eax
.text$mn:000013C8                 jmp     short loc_13CC
.text$mn:000013CA ; ---------------------------------------------------------------------------
.text$mn:000013CA
.text$mn:000013CA loc_13CA:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+331j
.text$mn:000013CA                 jmp     short loc_140E
.text$mn:000013CC ; ---------------------------------------------------------------------------
.text$mn:000013CC
.text$mn:000013CC loc_13CC:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_1380j
.text$mn:000013CC                                         ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+35Cj
.text$mn:000013CC                 jmp     short loc_1409
.text$mn:000013CE ; ---------------------------------------------------------------------------
.text$mn:000013CE
.text$mn:000013CE loc_13CE:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+112j
.text$mn:000013CE                 mov     ecx, [ebp+arg_8]
.text$mn:000013D1                 sub     ecx, 1
.text$mn:000013D4                 cmp     [ebp+var_1214], ecx
.text$mn:000013DA                 jnb     short loc_1407
.text$mn:000013DC                 mov     edx, [ebp+var_1214]
.text$mn:000013E2                 mov     eax, [ebp+arg_4]
.text$mn:000013E5                 mov     ecx, [ebp+var_1210]
.text$mn:000013EB                 mov     esi, [ebp+lpString]
.text$mn:000013EE                 mov     cx, [esi+ecx*2]
.text$mn:000013F2                 mov     [eax+edx*2], cx
.text$mn:000013F6                 mov     edx, [ebp+var_1214]
.text$mn:000013FC                 add     edx, 1
.text$mn:000013FF                 mov     [ebp+var_1214], edx
.text$mn:00001405                 jmp     short loc_1409
.text$mn:00001407 ; ---------------------------------------------------------------------------
.text$mn:00001407
.text$mn:00001407 loc_1407:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+36Ej
.text$mn:00001407                 jmp     short loc_140E
.text$mn:00001409 ; ---------------------------------------------------------------------------
.text$mn:00001409
.text$mn:00001409 loc_1409:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_13CCj
.text$mn:00001409                                         ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+399j
.text$mn:00001409                 jmp     loc_10AA
.text$mn:0000140E ; ---------------------------------------------------------------------------
.text$mn:0000140E
.text$mn:0000140E loc_140E:                               ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+59j
.text$mn:0000140E                                         ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_1289j ...
.text$mn:0000140E                 xor     eax, eax
.text$mn:00001410                 mov     ecx, [ebp+var_1214]
.text$mn:00001416                 mov     edx, [ebp+arg_4]
.text$mn:00001419                 mov     [edx+ecx*2], ax
.text$mn:0000141D                 pop     esi
.text$mn:0000141E                 mov     ecx, [ebp+var_4]
.text$mn:00001421                 xor     ecx, ebp
.text$mn:00001423                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001428                 mov     esp, ebp
.text$mn:0000142A                 pop     ebp
.text$mn:0000142B                 retn
.text$mn:0000142B ?expandNppEnvironmentStrs@@YAXPB_WPA_WIPAUHWND__@@@Z endp
.text$mn:0000142B
.text$mn:0000142C
.text$mn:0000142C ; =============== S U B R O U T I N E =======================================
.text$mn:0000142C
.text$mn:0000142C ; Attributes: bp-based frame
.text$mn:0000142C
.text$mn:0000142C ; HINSTANCE __thiscall Command::run(Command *this, HWND)
.text$mn:0000142C                 public ?run@Command@@QAEPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000142C ?run@Command@@QAEPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:0000142C                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+F0p
.text$mn:0000142C
.text$mn:0000142C var_2060        = dword ptr -2060h
.text$mn:0000142C var_205C        = dword ptr -205Ch
.text$mn:0000142C var_2058        = dword ptr -2058h
.text$mn:0000142C var_2054        = dword ptr -2054h
.text$mn:0000142C var_2050        = dword ptr -2050h
.text$mn:0000142C var_204C        = dword ptr -204Ch
.text$mn:0000142C var_2048        = dword ptr -2048h
.text$mn:0000142C Parameters      = word ptr -2044h
.text$mn:0000142C File            = word ptr -0C34h
.text$mn:0000142C String1         = word ptr -0A2Ch
.text$mn:0000142C String2         = word ptr -61Ch
.text$mn:0000142C Src             = word ptr -414h
.text$mn:0000142C Dst             = word ptr -20Ch
.text$mn:0000142C var_4           = dword ptr -4
.text$mn:0000142C hwnd            = dword ptr  8
.text$mn:0000142C
.text$mn:0000142C                 push    ebp
.text$mn:0000142D                 mov     ebp, esp
.text$mn:0000142F                 mov     eax, 2060h
.text$mn:00001434                 call    __chkstk
.text$mn:00001439                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000143E                 xor     eax, ebp
.text$mn:00001440                 mov     [ebp+var_4], eax
.text$mn:00001443                 mov     [ebp+var_2054], ecx
.text$mn:00001449                 mov     [ebp+var_2060], 208h
.text$mn:00001453                 mov     [ebp+var_205C], 0A08h
.text$mn:0000145D                 mov     ecx, [ebp+var_2054]
.text$mn:00001463                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001468                 push    eax             ; wchar_t *
.text$mn:00001469                 lea     eax, [ebp+String2]
.text$mn:0000146F                 push    eax             ; LPCWSTR
.text$mn:00001470                 lea     ecx, [ebp+Src]
.text$mn:00001476                 push    ecx             ; wchar_t *
.text$mn:00001477                 mov     ecx, [ebp+var_2054] ; this
.text$mn:0000147D                 call    ?extractArgs@Command@@AAEXPA_W0PB_W@Z ; Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)
.text$mn:00001482                 push    104h            ; nSize
.text$mn:00001487                 lea     edx, [ebp+Dst]
.text$mn:0000148D                 push    edx             ; lpDst
.text$mn:0000148E                 lea     eax, [ebp+Src]
.text$mn:00001494                 push    eax             ; lpSrc
.text$mn:00001495                 call    dword ptr ds:__imp__ExpandEnvironmentStringsW@12 ; ExpandEnvironmentStringsW(x,x,x)
.text$mn:0000149B                 mov     [ebp+var_2048], eax
.text$mn:000014A1                 cmp     [ebp+var_2048], 0
.text$mn:000014A8                 jnz     short loc_14C0
.text$mn:000014AA                 lea     ecx, [ebp+Src]
.text$mn:000014B0                 push    ecx             ; lpString2
.text$mn:000014B1                 lea     edx, [ebp+Dst]
.text$mn:000014B7                 push    edx             ; lpString1
.text$mn:000014B8                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:000014BE                 jmp     short loc_1500
.text$mn:000014C0 ; ---------------------------------------------------------------------------
.text$mn:000014C0
.text$mn:000014C0 loc_14C0:                               ; CODE XREF: Command::run(HWND__ *)+7Cj
.text$mn:000014C0                 cmp     [ebp+var_2048], 104h
.text$mn:000014CA                 jl      short loc_1500
.text$mn:000014CC                 mov     eax, 2
.text$mn:000014D1                 imul    ecx, eax, 103h
.text$mn:000014D7                 mov     [ebp+var_2050], ecx
.text$mn:000014DD                 cmp     [ebp+var_2050], 208h
.text$mn:000014E7                 jnb     short loc_14EB
.text$mn:000014E9                 jmp     short loc_14F0
.text$mn:000014EB ; ---------------------------------------------------------------------------
.text$mn:000014EB
.text$mn:000014EB loc_14EB:                               ; CODE XREF: Command::run(HWND__ *)+BBj
.text$mn:000014EB                 call    ___report_rangecheckfailure
.text$mn:000014F0
.text$mn:000014F0 loc_14F0:                               ; CODE XREF: Command::run(HWND__ *)+BDj
.text$mn:000014F0                 xor     edx, edx
.text$mn:000014F2                 mov     eax, [ebp+var_2050]
.text$mn:000014F8                 mov     [ebp+eax+Dst], dx
.text$mn:00001500
.text$mn:00001500 loc_1500:                               ; CODE XREF: Command::run(HWND__ *)+92j
.text$mn:00001500                                         ; Command::run(HWND__ *)+9Ej
.text$mn:00001500                 push    208h            ; nSize
.text$mn:00001505                 lea     ecx, [ebp+String1]
.text$mn:0000150B                 push    ecx             ; lpDst
.text$mn:0000150C                 lea     edx, [ebp+String2]
.text$mn:00001512                 push    edx             ; lpSrc
.text$mn:00001513                 call    dword ptr ds:__imp__ExpandEnvironmentStringsW@12 ; ExpandEnvironmentStringsW(x,x,x)
.text$mn:00001519                 mov     [ebp+var_2048], eax
.text$mn:0000151F                 cmp     [ebp+var_2048], 0
.text$mn:00001526                 jnz     short loc_153E
.text$mn:00001528                 lea     eax, [ebp+String2]
.text$mn:0000152E                 push    eax             ; lpString2
.text$mn:0000152F                 lea     ecx, [ebp+String1]
.text$mn:00001535                 push    ecx             ; lpString1
.text$mn:00001536                 call    dword ptr ds:__imp__lstrcpyW@8 ; lstrcpyW(x,x)
.text$mn:0000153C                 jmp     short loc_157E
.text$mn:0000153E ; ---------------------------------------------------------------------------
.text$mn:0000153E
.text$mn:0000153E loc_153E:                               ; CODE XREF: Command::run(HWND__ *)+FAj
.text$mn:0000153E                 cmp     [ebp+var_2048], 208h
.text$mn:00001548                 jl      short loc_157E
.text$mn:0000154A                 mov     edx, 2
.text$mn:0000154F                 imul    eax, edx, 207h
.text$mn:00001555                 mov     [ebp+var_204C], eax
.text$mn:0000155B                 cmp     [ebp+var_204C], 410h
.text$mn:00001565                 jnb     short loc_1569
.text$mn:00001567                 jmp     short loc_156E
.text$mn:00001569 ; ---------------------------------------------------------------------------
.text$mn:00001569
.text$mn:00001569 loc_1569:                               ; CODE XREF: Command::run(HWND__ *)+139j
.text$mn:00001569                 call    ___report_rangecheckfailure
.text$mn:0000156E
.text$mn:0000156E loc_156E:                               ; CODE XREF: Command::run(HWND__ *)+13Bj
.text$mn:0000156E                 xor     ecx, ecx
.text$mn:00001570                 mov     edx, [ebp+var_204C]
.text$mn:00001576                 mov     [ebp+edx+String1], cx
.text$mn:0000157E
.text$mn:0000157E loc_157E:                               ; CODE XREF: Command::run(HWND__ *)+110j
.text$mn:0000157E                                         ; Command::run(HWND__ *)+11Cj
.text$mn:0000157E                 mov     eax, [ebp+hwnd]
.text$mn:00001581                 push    eax             ; hWnd
.text$mn:00001582                 push    104h            ; unsigned int
.text$mn:00001587                 lea     ecx, [ebp+File]
.text$mn:0000158D                 push    ecx             ; wchar_t *
.text$mn:0000158E                 lea     edx, [ebp+Dst]
.text$mn:00001594                 push    edx             ; lpString
.text$mn:00001595                 call    ?expandNppEnvironmentStrs@@YAXPB_WPA_WIPAUHWND__@@@Z ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)
.text$mn:0000159A                 add     esp, 10h
.text$mn:0000159D                 mov     eax, [ebp+hwnd]
.text$mn:000015A0                 push    eax             ; hWnd
.text$mn:000015A1                 push    0A08h           ; unsigned int
.text$mn:000015A6                 lea     ecx, [ebp+Parameters]
.text$mn:000015AC                 push    ecx             ; wchar_t *
.text$mn:000015AD                 lea     edx, [ebp+String1]
.text$mn:000015B3                 push    edx             ; lpString
.text$mn:000015B4                 call    ?expandNppEnvironmentStrs@@YAXPB_WPA_WIPAUHWND__@@@Z ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)
.text$mn:000015B9                 add     esp, 10h
.text$mn:000015BC                 push    5               ; nShowCmd
.text$mn:000015BE                 push    offset $SG169297 ; lpDirectory
.text$mn:000015C3                 lea     eax, [ebp+Parameters]
.text$mn:000015C9                 push    eax             ; lpParameters
.text$mn:000015CA                 lea     ecx, [ebp+File]
.text$mn:000015D0                 push    ecx             ; lpFile
.text$mn:000015D1                 push    offset $SG169298 ; "open"
.text$mn:000015D6                 mov     edx, [ebp+hwnd]
.text$mn:000015D9                 push    edx             ; hwnd
.text$mn:000015DA                 call    dword ptr ds:__imp__ShellExecuteW@24 ; ShellExecuteW(x,x,x,x,x,x)
.text$mn:000015E0                 mov     [ebp+var_2058], eax
.text$mn:000015E6                 mov     eax, [ebp+var_2058]
.text$mn:000015EC                 mov     ecx, [ebp+var_4]
.text$mn:000015EF                 xor     ecx, ebp
.text$mn:000015F1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000015F6                 mov     esp, ebp
.text$mn:000015F8                 pop     ebp
.text$mn:000015F9                 retn    4
.text$mn:000015F9 ?run@Command@@QAEPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:000015F9
.text$mn:000015FC
.text$mn:000015FC ; =============== S U B R O U T I N E =======================================
.text$mn:000015FC
.text$mn:000015FC ; Attributes: bp-based frame
.text$mn:000015FC
.text$mn:000015FC ; void __thiscall Command::extractArgs(Command *this, wchar_t *, LPCWSTR, const wchar_t *)
.text$mn:000015FC                 public ?extractArgs@Command@@AAEXPA_W0PB_W@Z
.text$mn:000015FC ?extractArgs@Command@@AAEXPA_W0PB_W@Z proc near
.text$mn:000015FC                                         ; CODE XREF: Command::run(HWND__ *)+51p
.text$mn:000015FC
.text$mn:000015FC var_24          = dword ptr -24h
.text$mn:000015FC var_20          = dword ptr -20h
.text$mn:000015FC var_1C          = dword ptr -1Ch
.text$mn:000015FC var_18          = dword ptr -18h
.text$mn:000015FC var_14          = dword ptr -14h
.text$mn:000015FC var_10          = dword ptr -10h
.text$mn:000015FC var_C           = dword ptr -0Ch
.text$mn:000015FC var_8           = dword ptr -8
.text$mn:000015FC var_1           = byte ptr -1
.text$mn:000015FC arg_0           = dword ptr  8
.text$mn:000015FC arg_4           = dword ptr  0Ch
.text$mn:000015FC lpString        = dword ptr  10h
.text$mn:000015FC
.text$mn:000015FC                 push    ebp
.text$mn:000015FD                 mov     ebp, esp
.text$mn:000015FF                 sub     esp, 24h
.text$mn:00001602                 push    esi
.text$mn:00001603                 mov     [ebp+var_24], ecx
.text$mn:00001606                 mov     [ebp+var_8], 0
.text$mn:0000160D                 mov     [ebp+var_1], 0
.text$mn:00001611                 mov     eax, [ebp+lpString]
.text$mn:00001614                 push    eax             ; lpString
.text$mn:00001615                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:0000161B                 mov     [ebp+var_18], eax
.text$mn:0000161E                 jmp     short loc_1629
.text$mn:00001620 ; ---------------------------------------------------------------------------
.text$mn:00001620
.text$mn:00001620 loc_1620:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+8Fj
.text$mn:00001620                 mov     ecx, [ebp+var_8]
.text$mn:00001623                 add     ecx, 1
.text$mn:00001626                 mov     [ebp+var_8], ecx
.text$mn:00001629
.text$mn:00001629 loc_1629:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+22j
.text$mn:00001629                 mov     edx, [ebp+var_8]
.text$mn:0000162C                 cmp     edx, [ebp+var_18]
.text$mn:0000162F                 jnb     short loc_168D
.text$mn:00001631                 mov     eax, [ebp+var_8]
.text$mn:00001634                 mov     ecx, [ebp+lpString]
.text$mn:00001637                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:0000163B                 cmp     edx, 20h ; ' '
.text$mn:0000163E                 jnz     short loc_164A
.text$mn:00001640                 movzx   eax, [ebp+var_1]
.text$mn:00001644                 test    eax, eax
.text$mn:00001646                 jnz     short loc_164A
.text$mn:00001648                 jmp     short loc_168D
.text$mn:0000164A ; ---------------------------------------------------------------------------
.text$mn:0000164A
.text$mn:0000164A loc_164A:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+42j
.text$mn:0000164A                                         ; Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+4Aj
.text$mn:0000164A                 mov     ecx, [ebp+var_8]
.text$mn:0000164D                 mov     edx, [ebp+lpString]
.text$mn:00001650                 movzx   eax, word ptr [edx+ecx*2]
.text$mn:00001654                 cmp     eax, 22h ; '"'
.text$mn:00001657                 jnz     short loc_1677
.text$mn:00001659                 movzx   ecx, [ebp+var_1]
.text$mn:0000165D                 test    ecx, ecx
.text$mn:0000165F                 jnz     short loc_166A
.text$mn:00001661                 mov     [ebp+var_14], 1
.text$mn:00001668                 jmp     short loc_1671
.text$mn:0000166A ; ---------------------------------------------------------------------------
.text$mn:0000166A
.text$mn:0000166A loc_166A:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+63j
.text$mn:0000166A                 mov     [ebp+var_14], 0
.text$mn:00001671
.text$mn:00001671 loc_1671:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+6Cj
.text$mn:00001671                 mov     dl, byte ptr [ebp+var_14]
.text$mn:00001674                 mov     [ebp+var_1], dl
.text$mn:00001677
.text$mn:00001677 loc_1677:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+5Bj
.text$mn:00001677                 mov     eax, [ebp+var_8]
.text$mn:0000167A                 mov     ecx, [ebp+arg_0]
.text$mn:0000167D                 mov     edx, [ebp+var_8]
.text$mn:00001680                 mov     esi, [ebp+lpString]
.text$mn:00001683                 mov     dx, [esi+edx*2]
.text$mn:00001687                 mov     [ecx+eax*2], dx
.text$mn:0000168B                 jmp     short loc_1620
.text$mn:0000168D ; ---------------------------------------------------------------------------
.text$mn:0000168D
.text$mn:0000168D loc_168D:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+33j
.text$mn:0000168D                                         ; Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+4Cj
.text$mn:0000168D                 xor     eax, eax
.text$mn:0000168F                 mov     ecx, [ebp+var_8]
.text$mn:00001692                 mov     edx, [ebp+arg_0]
.text$mn:00001695                 mov     [edx+ecx*2], ax
.text$mn:00001699                 mov     eax, [ebp+lpString]
.text$mn:0000169C                 push    eax             ; lpString
.text$mn:0000169D                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000016A3                 cmp     [ebp+var_8], eax
.text$mn:000016A6                 jnb     loc_1789
.text$mn:000016AC                 mov     ecx, [ebp+lpString]
.text$mn:000016AF                 push    ecx             ; lpString
.text$mn:000016B0                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000016B6                 mov     [ebp+var_1C], eax
.text$mn:000016B9                 jmp     short loc_16C4
.text$mn:000016BB ; ---------------------------------------------------------------------------
.text$mn:000016BB
.text$mn:000016BB loc_16BB:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+DFj
.text$mn:000016BB                 mov     edx, [ebp+var_8]
.text$mn:000016BE                 add     edx, 1
.text$mn:000016C1                 mov     [ebp+var_8], edx
.text$mn:000016C4
.text$mn:000016C4 loc_16C4:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+BDj
.text$mn:000016C4                 mov     eax, [ebp+var_8]
.text$mn:000016C7                 cmp     eax, [ebp+var_1C]
.text$mn:000016CA                 jnb     short loc_16DD
.text$mn:000016CC                 mov     ecx, [ebp+var_8]
.text$mn:000016CF                 mov     edx, [ebp+lpString]
.text$mn:000016D2                 movzx   eax, word ptr [edx+ecx*2]
.text$mn:000016D6                 cmp     eax, 20h ; ' '
.text$mn:000016D9                 jnz     short loc_16DD
.text$mn:000016DB                 jmp     short loc_16BB
.text$mn:000016DD ; ---------------------------------------------------------------------------
.text$mn:000016DD
.text$mn:000016DD loc_16DD:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+CEj
.text$mn:000016DD                                         ; Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+DDj
.text$mn:000016DD                 mov     ecx, [ebp+lpString]
.text$mn:000016E0                 push    ecx             ; lpString
.text$mn:000016E1                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000016E7                 cmp     [ebp+var_8], eax
.text$mn:000016EA                 jnb     short loc_1732
.text$mn:000016EC                 mov     [ebp+var_10], 0
.text$mn:000016F3                 mov     edx, [ebp+lpString]
.text$mn:000016F6                 push    edx             ; lpString
.text$mn:000016F7                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000016FD                 mov     [ebp+var_20], eax
.text$mn:00001700                 jmp     short loc_1714
.text$mn:00001702 ; ---------------------------------------------------------------------------
.text$mn:00001702
.text$mn:00001702 loc_1702:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+134j
.text$mn:00001702                 mov     eax, [ebp+var_8]
.text$mn:00001705                 add     eax, 1
.text$mn:00001708                 mov     [ebp+var_8], eax
.text$mn:0000170B                 mov     ecx, [ebp+var_10]
.text$mn:0000170E                 add     ecx, 1
.text$mn:00001711                 mov     [ebp+var_10], ecx
.text$mn:00001714
.text$mn:00001714 loc_1714:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+104j
.text$mn:00001714                 mov     edx, [ebp+var_8]
.text$mn:00001717                 cmp     edx, [ebp+var_20]
.text$mn:0000171A                 ja      short loc_1732
.text$mn:0000171C                 mov     eax, [ebp+var_10]
.text$mn:0000171F                 mov     ecx, [ebp+arg_4]
.text$mn:00001722                 mov     edx, [ebp+var_8]
.text$mn:00001725                 mov     esi, [ebp+lpString]
.text$mn:00001728                 mov     dx, [esi+edx*2]
.text$mn:0000172C                 mov     [ecx+eax*2], dx
.text$mn:00001730                 jmp     short loc_1702
.text$mn:00001732 ; ---------------------------------------------------------------------------
.text$mn:00001732
.text$mn:00001732 loc_1732:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+EEj
.text$mn:00001732                                         ; Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+11Ej
.text$mn:00001732                 mov     eax, [ebp+arg_4]
.text$mn:00001735                 push    eax             ; lpString
.text$mn:00001736                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:0000173C                 mov     [ebp+var_C], eax
.text$mn:0000173F                 mov     ecx, [ebp+var_C]
.text$mn:00001742                 mov     edx, [ebp+arg_4]
.text$mn:00001745                 movzx   eax, word ptr [edx+ecx*2-2]
.text$mn:0000174A                 cmp     eax, 20h ; ' '
.text$mn:0000174D                 jnz     short loc_1787
.text$mn:0000174F                 mov     ecx, [ebp+var_C]
.text$mn:00001752                 sub     ecx, 2
.text$mn:00001755                 mov     [ebp+var_C], ecx
.text$mn:00001758                 jmp     short loc_1763
.text$mn:0000175A ; ---------------------------------------------------------------------------
.text$mn:0000175A
.text$mn:0000175A loc_175A:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+17Cj
.text$mn:0000175A                 mov     edx, [ebp+var_C]
.text$mn:0000175D                 sub     edx, 1
.text$mn:00001760                 mov     [ebp+var_C], edx
.text$mn:00001763
.text$mn:00001763 loc_1763:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+15Cj
.text$mn:00001763                 cmp     [ebp+var_C], 0
.text$mn:00001767                 jle     short loc_177A
.text$mn:00001769                 mov     eax, [ebp+var_C]
.text$mn:0000176C                 mov     ecx, [ebp+arg_4]
.text$mn:0000176F                 movzx   edx, word ptr [ecx+eax*2]
.text$mn:00001773                 cmp     edx, 20h ; ' '
.text$mn:00001776                 jnz     short loc_177A
.text$mn:00001778                 jmp     short loc_175A
.text$mn:0000177A ; ---------------------------------------------------------------------------
.text$mn:0000177A
.text$mn:0000177A loc_177A:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+16Bj
.text$mn:0000177A                                         ; Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+17Aj
.text$mn:0000177A                 xor     eax, eax
.text$mn:0000177C                 mov     ecx, [ebp+var_C]
.text$mn:0000177F                 mov     edx, [ebp+arg_4]
.text$mn:00001782                 mov     [edx+ecx*2+2], ax
.text$mn:00001787
.text$mn:00001787 loc_1787:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+151j
.text$mn:00001787                 jmp     short loc_179A
.text$mn:00001789 ; ---------------------------------------------------------------------------
.text$mn:00001789
.text$mn:00001789 loc_1789:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *)+AAj
.text$mn:00001789                 mov     eax, 2
.text$mn:0000178E                 imul    ecx, eax, 0
.text$mn:00001791                 xor     edx, edx
.text$mn:00001793                 mov     eax, [ebp+arg_4]
.text$mn:00001796                 mov     [eax+ecx], dx
.text$mn:0000179A
.text$mn:0000179A loc_179A:                               ; CODE XREF: Command::extractArgs(wchar_t *,wchar_t *,wchar_t const *):loc_1787j
.text$mn:0000179A                 pop     esi
.text$mn:0000179B                 mov     esp, ebp
.text$mn:0000179D                 pop     ebp
.text$mn:0000179E                 retn    0Ch
.text$mn:0000179E ?extractArgs@Command@@AAEXPA_W0PB_W@Z endp
.text$mn:0000179E
.text$mn:0000179E ; ---------------------------------------------------------------------------
.text$mn:000017A1                 db 0Bh dup(0CCh)
.text$mn:000017AC
.text$mn:000017AC ; =============== S U B R O U T I N E =======================================
.text$mn:000017AC
.text$mn:000017AC ; Attributes: bp-based frame
.text$mn:000017AC
.text$mn:000017AC ; void __thiscall RunDlg::doDialog(RunDlg *this, bool)
.text$mn:000017AC                 public ?doDialog@RunDlg@@QAEX_N@Z
.text$mn:000017AC ?doDialog@RunDlg@@QAEX_N@Z proc near
.text$mn:000017AC
.text$mn:000017AC var_4           = dword ptr -4
.text$mn:000017AC arg_0           = byte ptr  8
.text$mn:000017AC
.text$mn:000017AC                 push    ebp
.text$mn:000017AD                 mov     ebp, esp
.text$mn:000017AF                 push    ecx
.text$mn:000017B0                 mov     [ebp+var_4], ecx
.text$mn:000017B3                 mov     eax, [ebp+var_4]
.text$mn:000017B6                 mov     edx, [eax]
.text$mn:000017B8                 mov     ecx, [ebp+var_4]
.text$mn:000017BB                 mov     eax, [edx+34h]
.text$mn:000017BE                 call    eax
.text$mn:000017C0                 movzx   ecx, al
.text$mn:000017C3                 test    ecx, ecx
.text$mn:000017C5                 jnz     short loc_17E0
.text$mn:000017C7                 push    1
.text$mn:000017C9                 movzx   edx, [ebp+arg_0]
.text$mn:000017CD                 push    edx
.text$mn:000017CE                 push    76Ch
.text$mn:000017D3                 mov     eax, [ebp+var_4]
.text$mn:000017D6                 mov     edx, [eax]
.text$mn:000017D8                 mov     ecx, [ebp+var_4]
.text$mn:000017DB                 mov     eax, [edx+30h]
.text$mn:000017DE                 call    eax
.text$mn:000017E0
.text$mn:000017E0 loc_17E0:                               ; CODE XREF: RunDlg::doDialog(bool)+19j
.text$mn:000017E0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000017E3                 call    ?goToCenter@StaticDialog@@QAEXXZ ; StaticDialog::goToCenter(void)
.text$mn:000017E8                 push    76Eh            ; nIDDlgItem
.text$mn:000017ED                 mov     ecx, [ebp+var_4]
.text$mn:000017F0                 mov     edx, [ecx+0Ch]
.text$mn:000017F3                 push    edx             ; hDlg
.text$mn:000017F4                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:000017FA                 push    eax             ; hWnd
.text$mn:000017FB                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:00001801                 mov     esp, ebp
.text$mn:00001803                 pop     ebp
.text$mn:00001804                 retn    4
.text$mn:00001804 ?doDialog@RunDlg@@QAEX_N@Z endp
.text$mn:00001804
.text$mn:00001804 ; ---------------------------------------------------------------------------
.text$mn:00001807                 db 5 dup(0CCh)
.text$mn:0000180C
.text$mn:0000180C ; =============== S U B R O U T I N E =======================================
.text$mn:0000180C
.text$mn:0000180C ; Attributes: bp-based frame
.text$mn:0000180C
.text$mn:0000180C ; int __stdcall RunDlg::run_dlgProc(RunDlg *this, unsigned int, unsigned int, __int32)
.text$mn:0000180C                 public ?run_dlgProc@RunDlg@@MAGHIIJ@Z
.text$mn:0000180C ?run_dlgProc@RunDlg@@MAGHIIJ@Z proc near
.text$mn:0000180C
.text$mn:0000180C var_1708        = dword ptr -1708h
.text$mn:0000180C var_1704        = dword ptr -1704h
.text$mn:0000180C var_1700        = dword ptr -1700h
.text$mn:0000180C var_16FC        = dword ptr -16FCh
.text$mn:0000180C var_16F8        = dword ptr -16F8h
.text$mn:0000180C var_16F4        = dword ptr -16F4h
.text$mn:0000180C var_16F0        = dword ptr -16F0h
.text$mn:0000180C var_16EC        = dword ptr -16ECh
.text$mn:0000180C var_16E8        = dword ptr -16E8h
.text$mn:0000180C var_16E4        = dword ptr -16E4h
.text$mn:0000180C var_16E0        = dword ptr -16E0h
.text$mn:0000180C var_16DC        = dword ptr -16DCh
.text$mn:0000180C var_16D8        = dword ptr -16D8h
.text$mn:0000180C var_16D4        = dword ptr -16D4h
.text$mn:0000180C var_16D0        = dword ptr -16D0h
.text$mn:0000180C var_16CC        = dword ptr -16CCh
.text$mn:0000180C uIDNewItem      = dword ptr -16C8h
.text$mn:0000180C var_16C4        = dword ptr -16C4h
.text$mn:0000180C hMenu           = dword ptr -16C0h
.text$mn:0000180C Str             = dword ptr -16BCh
.text$mn:0000180C var_16B8        = dword ptr -16B8h
.text$mn:0000180C var_16B4        = dword ptr -16B4h
.text$mn:0000180C var_16B0        = byte ptr -16B0h
.text$mn:0000180C var_5F4         = byte ptr -5F4h
.text$mn:0000180C var_4AC         = dword ptr -4ACh
.text$mn:0000180C var_490         = dword ptr -490h
.text$mn:0000180C var_474         = byte ptr -474h
.text$mn:0000180C var_458         = dword ptr -458h
.text$mn:0000180C var_43C         = dword ptr -43Ch
.text$mn:0000180C String          = word ptr -420h
.text$mn:0000180C var_218         = word ptr -218h
.text$mn:0000180C var_10          = dword ptr -10h
.text$mn:0000180C var_C           = dword ptr -0Ch
.text$mn:0000180C var_4           = dword ptr -4
.text$mn:0000180C this            = dword ptr  8
.text$mn:0000180C arg_4           = dword ptr  0Ch
.text$mn:0000180C arg_8           = dword ptr  10h
.text$mn:0000180C
.text$mn:0000180C                 push    ebp
.text$mn:0000180D                 mov     ebp, esp
.text$mn:0000180F                 push    0FFFFFFFFh
.text$mn:00001811                 push    offset __ehhandler$?run_dlgProc@RunDlg@@MAGHIIJ@Z
.text$mn:00001816                 mov     eax, large fs:0
.text$mn:0000181C                 push    eax
.text$mn:0000181D                 mov     eax, 16FCh
.text$mn:00001822                 call    __chkstk
.text$mn:00001827                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000182C                 xor     eax, ebp
.text$mn:0000182E                 mov     [ebp+var_10], eax
.text$mn:00001831                 push    eax
.text$mn:00001832                 lea     eax, [ebp+var_C]
.text$mn:00001835                 mov     large fs:0, eax
.text$mn:0000183B                 mov     eax, [ebp+arg_4]
.text$mn:0000183E                 mov     [ebp+var_16EC], eax
.text$mn:00001844                 cmp     [ebp+var_16EC], 111h
.text$mn:0000184E                 jz      short loc_1855
.text$mn:00001850                 jmp     loc_1D88
.text$mn:00001855 ; ---------------------------------------------------------------------------
.text$mn:00001855
.text$mn:00001855 loc_1855:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+42j
.text$mn:00001855                 mov     ecx, [ebp+arg_8]
.text$mn:00001858                 mov     [ebp+var_16B8], ecx
.text$mn:0000185E                 cmp     [ebp+var_16B8], 76Dh
.text$mn:00001868                 ja      short loc_1891
.text$mn:0000186A                 cmp     [ebp+var_16B8], 76Dh
.text$mn:00001874                 jz      loc_1BEC
.text$mn:0000187A                 cmp     [ebp+var_16B8], 1
.text$mn:00001881                 jz      short loc_18BF
.text$mn:00001883                 cmp     [ebp+var_16B8], 2
.text$mn:0000188A                 jz      short loc_18A6
.text$mn:0000188C                 jmp     loc_1D88
.text$mn:00001891 ; ---------------------------------------------------------------------------
.text$mn:00001891
.text$mn:00001891 loc_1891:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+5Cj
.text$mn:00001891                 cmp     [ebp+var_16B8], 770h
.text$mn:0000189B                 jz      loc_1953
.text$mn:000018A1                 jmp     loc_1D88
.text$mn:000018A6 ; ---------------------------------------------------------------------------
.text$mn:000018A6
.text$mn:000018A6 loc_18A6:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+7Ej
.text$mn:000018A6                 push    0
.text$mn:000018A8                 mov     edx, [ebp+this]
.text$mn:000018AB                 mov     eax, [edx]
.text$mn:000018AD                 mov     ecx, [ebp+this]
.text$mn:000018B0                 mov     edx, [eax+0Ch]
.text$mn:000018B3                 call    edx
.text$mn:000018B5                 mov     eax, 1
.text$mn:000018BA                 jmp     loc_1D8A
.text$mn:000018BF ; ---------------------------------------------------------------------------
.text$mn:000018BF
.text$mn:000018BF loc_18BF:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+75j
.text$mn:000018BF                 push    104h            ; cchMax
.text$mn:000018C4                 lea     eax, [ebp+String]
.text$mn:000018CA                 push    eax             ; lpString
.text$mn:000018CB                 push    76Eh            ; nIDDlgItem
.text$mn:000018D0                 mov     ecx, [ebp+this]
.text$mn:000018D3                 mov     edx, [ecx+0Ch]
.text$mn:000018D6                 push    edx             ; hDlg
.text$mn:000018D7                 call    dword ptr ds:__imp__GetDlgItemTextW@16 ; GetDlgItemTextW(x,x,x,x)
.text$mn:000018DD                 lea     eax, [ebp+String]
.text$mn:000018E3                 push    eax             ; Str
.text$mn:000018E4                 mov     ecx, [ebp+this]
.text$mn:000018E7                 add     ecx, 20h ; ' '
.text$mn:000018EA                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:000018EF                 mov     ecx, [ebp+this]
.text$mn:000018F2                 mov     edx, [ecx+8]
.text$mn:000018F5                 push    edx             ; HWND
.text$mn:000018F6                 mov     ecx, [ebp+this]
.text$mn:000018F9                 add     ecx, 20h ; ' '  ; this
.text$mn:000018FC                 call    ?run@Command@@QAEPAUHINSTANCE__@@PAUHWND__@@@Z ; Command::run(HWND__ *)
.text$mn:00001901                 mov     [ebp+var_16E4], eax
.text$mn:00001907                 cmp     [ebp+var_16E4], 20h ; ' '
.text$mn:0000190E                 jle     short loc_1935
.text$mn:00001910                 mov     ecx, [ebp+this]
.text$mn:00001913                 add     ecx, 20h ; ' '
.text$mn:00001916                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000191B                 push    eax             ; wchar_t *
.text$mn:0000191C                 mov     ecx, [ebp+this] ; this
.text$mn:0000191F                 call    ?addTextToCombo@RunDlg@@ABEXPB_W@Z ; RunDlg::addTextToCombo(wchar_t const *)
.text$mn:00001924                 push    0
.text$mn:00001926                 mov     eax, [ebp+this]
.text$mn:00001929                 mov     edx, [eax]
.text$mn:0000192B                 mov     ecx, [ebp+this]
.text$mn:0000192E                 mov     eax, [edx+0Ch]
.text$mn:00001931                 call    eax
.text$mn:00001933                 jmp     short loc_1949
.text$mn:00001935 ; ---------------------------------------------------------------------------
.text$mn:00001935
.text$mn:00001935 loc_1935:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+102j
.text$mn:00001935                 mov     ecx, [ebp+this]
.text$mn:00001938                 add     ecx, 20h ; ' '
.text$mn:0000193B                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001940                 push    eax             ; wchar_t *
.text$mn:00001941                 mov     ecx, [ebp+this] ; this
.text$mn:00001944                 call    ?removeTextFromCombo@RunDlg@@ABEXPB_W@Z ; RunDlg::removeTextFromCombo(wchar_t const *)
.text$mn:00001949
.text$mn:00001949 loc_1949:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+127j
.text$mn:00001949                 mov     eax, 1
.text$mn:0000194E                 jmp     loc_1D8A
.text$mn:00001953 ; ---------------------------------------------------------------------------
.text$mn:00001953
.text$mn:00001953 loc_1953:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+8Fj
.text$mn:00001953                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001958                 mov     ecx, eax
.text$mn:0000195A                 call    ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ ; NppParameters::getUserCommandList(void)
.text$mn:0000195F                 mov     [ebp+var_16C4], eax
.text$mn:00001965                 mov     ecx, [ebp+var_16C4]
.text$mn:0000196B                 call    ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::size(void)
.text$mn:00001970                 mov     [ebp+var_16B4], eax
.text$mn:00001976                 mov     ecx, [ebp+var_16B4]
.text$mn:0000197C                 add     ecx, 5208h
.text$mn:00001982                 mov     [ebp+uIDNewItem], ecx
.text$mn:00001988                 push    104h            ; cchMax
.text$mn:0000198D                 lea     edx, [ebp+var_218]
.text$mn:00001993                 push    edx             ; lpString
.text$mn:00001994                 push    76Eh            ; int
.text$mn:00001999                 mov     eax, [ebp+this]
.text$mn:0000199C                 mov     ecx, [eax+0Ch]
.text$mn:0000199F                 push    ecx             ; int
.text$mn:000019A0                 call    dword ptr ds:__imp__GetDlgItemTextW@16 ; GetDlgItemTextW(x,x,x,x)
.text$mn:000019A6                 mov     edx, [ebp+uIDNewItem]
.text$mn:000019AC                 push    edx             ; int
.text$mn:000019AD                 lea     eax, [ebp+var_218]
.text$mn:000019B3                 push    eax             ; Str
.text$mn:000019B4                 sub     esp, 128h
.text$mn:000019BA                 mov     ecx, esp
.text$mn:000019BC                 mov     [ebp+var_16FC], esp
.text$mn:000019C2                 call    ??0Shortcut@@QAE@XZ ; Shortcut::Shortcut(void)
.text$mn:000019C7                 mov     [ebp+var_16D0], eax
.text$mn:000019CD                 mov     ecx, [ebp+var_16D0]
.text$mn:000019D3                 mov     [ebp+var_1708], ecx
.text$mn:000019D9                 mov     [ebp+var_4], 0
.text$mn:000019E0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019E7                 lea     ecx, [ebp+var_5F4]
.text$mn:000019ED                 call    ??0UserCommand@@QAE@VShortcut@@PB_WH@Z ; UserCommand::UserCommand(Shortcut,wchar_t const *,int)
.text$mn:000019F2                 mov     [ebp+var_1704], eax
.text$mn:000019F8                 mov     [ebp+var_4], 1
.text$mn:000019FF                 mov     edx, [ebp+this]
.text$mn:00001A02                 mov     eax, [edx+0Ch]
.text$mn:00001A05                 push    eax             ; HWND
.text$mn:00001A06                 mov     ecx, [ebp+this]
.text$mn:00001A09                 mov     edx, [ecx+4]
.text$mn:00001A0C                 push    edx             ; HINSTANCE
.text$mn:00001A0D                 lea     ecx, [ebp+var_5F4] ; this
.text$mn:00001A13                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:00001A18                 lea     ecx, [ebp+var_5F4] ; this
.text$mn:00001A1E                 call    ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.text$mn:00001A23                 cmp     eax, 0FFFFFFFFh
.text$mn:00001A26                 jz      loc_1BC5
.text$mn:00001A2C                 push    8               ; nPos
.text$mn:00001A2E                 push    0               ; lParam
.text$mn:00001A30                 push    0               ; wParam
.text$mn:00001A32                 push    40Eh            ; Msg
.text$mn:00001A37                 mov     eax, [ebp+this]
.text$mn:00001A3A                 mov     ecx, [eax+8]
.text$mn:00001A3D                 push    ecx             ; hWnd
.text$mn:00001A3E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001A44                 push    eax             ; hMenu
.text$mn:00001A45                 call    dword ptr ds:__imp__GetSubMenu@8 ; GetSubMenu(x,x)
.text$mn:00001A4B                 mov     [ebp+hMenu], eax
.text$mn:00001A51                 mov     [ebp+var_1700], 2
.text$mn:00001A5B                 cmp     [ebp+var_16B4], 0
.text$mn:00001A62                 jnz     short loc_1A7C
.text$mn:00001A64                 push    0               ; lpNewItem
.text$mn:00001A66                 push    0FFFFFFFFh      ; uIDNewItem
.text$mn:00001A68                 push    400h            ; uFlags
.text$mn:00001A6D                 push    1               ; uPosition
.text$mn:00001A6F                 mov     edx, [ebp+hMenu]
.text$mn:00001A75                 push    edx             ; hMenu
.text$mn:00001A76                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00001A7C
.text$mn:00001A7C loc_1A7C:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+256j
.text$mn:00001A7C                 lea     eax, [ebp+var_5F4]
.text$mn:00001A82                 push    eax
.text$mn:00001A83                 mov     ecx, [ebp+var_16C4]
.text$mn:00001A89                 call    ?push_back@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEXABVUserCommand@@@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)
.text$mn:00001A8E                 lea     ecx, [ebp+var_474]
.text$mn:00001A94                 push    ecx
.text$mn:00001A95                 lea     ecx, [ebp+var_5F4]
.text$mn:00001A9B                 call    ?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toMenuItemString(void)
.text$mn:00001AA0                 mov     [ebp+var_16D8], eax
.text$mn:00001AA6                 mov     edx, [ebp+var_16D8]
.text$mn:00001AAC                 mov     [ebp+var_16DC], edx
.text$mn:00001AB2                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001AB6                 mov     ecx, [ebp+var_16DC]
.text$mn:00001ABC                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001AC1                 push    eax             ; lpNewItem
.text$mn:00001AC2                 mov     eax, [ebp+uIDNewItem]
.text$mn:00001AC8                 push    eax             ; uIDNewItem
.text$mn:00001AC9                 push    400h            ; uFlags
.text$mn:00001ACE                 mov     ecx, [ebp+var_16B4]
.text$mn:00001AD4                 add     ecx, 2
.text$mn:00001AD7                 push    ecx             ; uPosition
.text$mn:00001AD8                 mov     edx, [ebp+hMenu]
.text$mn:00001ADE                 push    edx             ; hMenu
.text$mn:00001ADF                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00001AE5                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001AE9                 lea     ecx, [ebp+var_474]
.text$mn:00001AEF                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001AF4                 cmp     [ebp+var_16B4], 0
.text$mn:00001AFB                 jnz     loc_1BB2
.text$mn:00001B01                 push    0               ; lpNewItem
.text$mn:00001B03                 push    0FFFFFFFFh      ; uIDNewItem
.text$mn:00001B05                 push    400h            ; uFlags
.text$mn:00001B0A                 mov     eax, [ebp+var_16B4]
.text$mn:00001B10                 add     eax, 3
.text$mn:00001B13                 push    eax             ; uPosition
.text$mn:00001B14                 mov     ecx, [ebp+hMenu]
.text$mn:00001B1A                 push    ecx             ; hMenu
.text$mn:00001B1B                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00001B21                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001B26                 mov     ecx, eax        ; this
.text$mn:00001B28                 call    ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ ; NppParameters::getNativeLangSpeaker(void)
.text$mn:00001B2D                 mov     [ebp+var_16E0], eax
.text$mn:00001B33                 push    0BB90h
.text$mn:00001B38                 lea     edx, [ebp+var_43C]
.text$mn:00001B3E                 push    edx
.text$mn:00001B3F                 mov     ecx, [ebp+var_16E0]
.text$mn:00001B45                 call    ?getNativeLangMenuString@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z ; NativeLangSpeaker::getNativeLangMenuString(int)
.text$mn:00001B4A                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001B4E                 push    offset $SG169361 ; Str
.text$mn:00001B53                 lea     eax, [ebp+var_43C]
.text$mn:00001B59                 push    eax             ; int
.text$mn:00001B5A                 call    ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z ; std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)
.text$mn:00001B5F                 add     esp, 8
.text$mn:00001B62                 movzx   ecx, al
.text$mn:00001B65                 test    ecx, ecx
.text$mn:00001B67                 jz      short loc_1B79
.text$mn:00001B69                 push    offset $SG169362 ; "Modify Shortcut/Delete Command..."
.text$mn:00001B6E                 lea     ecx, [ebp+var_43C]
.text$mn:00001B74                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)
.text$mn:00001B79
.text$mn:00001B79 loc_1B79:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+35Bj
.text$mn:00001B79                 lea     ecx, [ebp+var_43C]
.text$mn:00001B7F                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001B84                 push    eax             ; lpNewItem
.text$mn:00001B85                 push    0BB91h          ; uIDNewItem
.text$mn:00001B8A                 push    0               ; uFlags
.text$mn:00001B8C                 mov     edx, [ebp+var_16B4]
.text$mn:00001B92                 add     edx, 4
.text$mn:00001B95                 push    edx             ; uPosition
.text$mn:00001B96                 mov     eax, [ebp+hMenu]
.text$mn:00001B9C                 push    eax             ; hMenu
.text$mn:00001B9D                 call    dword ptr ds:__imp__InsertMenuW@20 ; InsertMenuW(x,x,x,x,x)
.text$mn:00001BA3                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001BA7                 lea     ecx, [ebp+var_43C]
.text$mn:00001BAD                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001BB2
.text$mn:00001BB2 loc_1BB2:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+2EFj
.text$mn:00001BB2                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001BB7                 mov     ecx, eax        ; this
.text$mn:00001BB9                 call    ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ ; NppParameters::getAccelerator(void)
.text$mn:00001BBE                 mov     ecx, eax        ; this
.text$mn:00001BC0                 call    ?updateShortcuts@Accelerator@@QAEXXZ ; Accelerator::updateShortcuts(void)
.text$mn:00001BC5
.text$mn:00001BC5 loc_1BC5:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+21Aj
.text$mn:00001BC5                 mov     [ebp+var_16E8], 1
.text$mn:00001BCF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BD6                 lea     ecx, [ebp+var_5F4] ; this
.text$mn:00001BDC                 call    ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$mn:00001BE1                 mov     eax, [ebp+var_16E8]
.text$mn:00001BE7                 jmp     loc_1D8A
.text$mn:00001BEC ; ---------------------------------------------------------------------------
.text$mn:00001BEC
.text$mn:00001BEC loc_1BEC:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+68j
.text$mn:00001BEC                 mov     ecx, [ebp+this]
.text$mn:00001BEF                 mov     edx, [ecx+4]
.text$mn:00001BF2                 push    edx             ; HINSTANCE
.text$mn:00001BF3                 mov     eax, [ebp+this]
.text$mn:00001BF6                 mov     ecx, [eax+0Ch]
.text$mn:00001BF9                 push    ecx             ; HWND
.text$mn:00001BFA                 lea     ecx, [ebp+var_16B0] ; this
.text$mn:00001C00                 call    ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z ; FileDialog::FileDialog(HWND__ *,HINSTANCE__ *)
.text$mn:00001C05                 mov     [ebp+var_4], 4
.text$mn:00001C0C                 push    0
.text$mn:00001C0E                 push    offset $SG169366 ; ".bat"
.text$mn:00001C13                 push    offset $SG169367 ; ".cmd"
.text$mn:00001C18                 push    offset $SG169368 ; ".com"
.text$mn:00001C1D                 push    offset $SG169369 ; ".exe"
.text$mn:00001C22                 push    offset $SG169370 ; "Executable file : "
.text$mn:00001C27                 lea     edx, [ebp+var_16B0]
.text$mn:00001C2D                 push    edx             ; this
.text$mn:00001C2E                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00001C33                 add     esp, 1Ch
.text$mn:00001C36                 push    0
.text$mn:00001C38                 push    offset $SG169371 ; ".*"
.text$mn:00001C3D                 push    offset $SG169372 ; "All files : "
.text$mn:00001C42                 lea     eax, [ebp+var_16B0]
.text$mn:00001C48                 push    eax             ; this
.text$mn:00001C49                 call    ?setExtFilter@FileDialog@@QAAXPB_W0ZZ ; FileDialog::setExtFilter(wchar_t const *,wchar_t const *,...)
.text$mn:00001C4E                 add     esp, 10h
.text$mn:00001C51                 lea     ecx, [ebp+var_16B0] ; this
.text$mn:00001C57                 call    ?doOpenSingleFileDlg@FileDialog@@QAEPA_WXZ ; FileDialog::doOpenSingleFileDlg(void)
.text$mn:00001C5C                 mov     [ebp+Str], eax
.text$mn:00001C62                 cmp     [ebp+Str], 0
.text$mn:00001C69                 jz      loc_1D64
.text$mn:00001C6F                 push    20h ; ' '       ; Ch
.text$mn:00001C71                 mov     ecx, [ebp+Str]
.text$mn:00001C77                 push    ecx             ; Str
.text$mn:00001C78                 call    _wcschr
.text$mn:00001C7D                 add     esp, 8
.text$mn:00001C80                 test    eax, eax
.text$mn:00001C82                 jz      loc_1D55
.text$mn:00001C88                 mov     edx, [ebp+Str]
.text$mn:00001C8E                 push    edx             ; Str
.text$mn:00001C8F                 lea     ecx, [ebp+var_458]
.text$mn:00001C95                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00001C9A                 mov     byte ptr [ebp+var_4], 5
.text$mn:00001C9E                 push    offset $SG169431 ; Str
.text$mn:00001CA3                 lea     eax, [ebp+var_458]
.text$mn:00001CA9                 push    eax             ; int
.text$mn:00001CAA                 push    offset $SG169432 ; Str
.text$mn:00001CAF                 lea     ecx, [ebp+var_4AC]
.text$mn:00001CB5                 push    ecx             ; int
.text$mn:00001CB6                 call    ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00001CBB                 add     esp, 0Ch
.text$mn:00001CBE                 mov     [ebp+var_16F0], eax
.text$mn:00001CC4                 mov     edx, [ebp+var_16F0]
.text$mn:00001CCA                 mov     [ebp+var_16F8], edx
.text$mn:00001CD0                 mov     byte ptr [ebp+var_4], 6
.text$mn:00001CD4                 mov     eax, [ebp+var_16F8]
.text$mn:00001CDA                 push    eax             ; int
.text$mn:00001CDB                 lea     ecx, [ebp+var_490]
.text$mn:00001CE1                 push    ecx             ; int
.text$mn:00001CE2                 call    ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)
.text$mn:00001CE7                 add     esp, 0Ch
.text$mn:00001CEA                 mov     [ebp+var_16CC], eax
.text$mn:00001CF0                 mov     edx, [ebp+var_16CC]
.text$mn:00001CF6                 mov     [ebp+var_16D4], edx
.text$mn:00001CFC                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001D00                 mov     eax, [ebp+var_16D4]
.text$mn:00001D06                 push    eax
.text$mn:00001D07                 lea     ecx, [ebp+var_458]
.text$mn:00001D0D                 call    ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001D12                 mov     byte ptr [ebp+var_4], 6
.text$mn:00001D16                 lea     ecx, [ebp+var_490]
.text$mn:00001D1C                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001D21                 mov     byte ptr [ebp+var_4], 5
.text$mn:00001D25                 lea     ecx, [ebp+var_4AC]
.text$mn:00001D2B                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001D30                 lea     ecx, [ebp+var_458]
.text$mn:00001D36                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00001D3B                 push    eax             ; wchar_t *
.text$mn:00001D3C                 mov     ecx, [ebp+this] ; this
.text$mn:00001D3F                 call    ?addTextToCombo@RunDlg@@ABEXPB_W@Z ; RunDlg::addTextToCombo(wchar_t const *)
.text$mn:00001D44                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001D48                 lea     ecx, [ebp+var_458]
.text$mn:00001D4E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00001D53                 jmp     short loc_1D64
.text$mn:00001D55 ; ---------------------------------------------------------------------------
.text$mn:00001D55
.text$mn:00001D55 loc_1D55:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+476j
.text$mn:00001D55                 mov     ecx, [ebp+Str]
.text$mn:00001D5B                 push    ecx             ; wchar_t *
.text$mn:00001D5C                 mov     ecx, [ebp+this] ; this
.text$mn:00001D5F                 call    ?addTextToCombo@RunDlg@@ABEXPB_W@Z ; RunDlg::addTextToCombo(wchar_t const *)
.text$mn:00001D64
.text$mn:00001D64 loc_1D64:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+45Dj
.text$mn:00001D64                                         ; RunDlg::run_dlgProc(uint,uint,long)+547j
.text$mn:00001D64                 mov     [ebp+var_16F4], 1
.text$mn:00001D6E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D75                 lea     ecx, [ebp+var_16B0] ; this
.text$mn:00001D7B                 call    ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$mn:00001D80                 mov     eax, [ebp+var_16F4]
.text$mn:00001D86                 jmp     short loc_1D8A
.text$mn:00001D88 ; ---------------------------------------------------------------------------
.text$mn:00001D88
.text$mn:00001D88 loc_1D88:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+44j
.text$mn:00001D88                                         ; RunDlg::run_dlgProc(uint,uint,long)+80j ...
.text$mn:00001D88                 xor     eax, eax
.text$mn:00001D8A
.text$mn:00001D8A loc_1D8A:                               ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+AEj
.text$mn:00001D8A                                         ; RunDlg::run_dlgProc(uint,uint,long)+142j ...
.text$mn:00001D8A                 mov     ecx, [ebp+var_C]
.text$mn:00001D8D                 mov     large fs:0, ecx
.text$mn:00001D94                 pop     ecx
.text$mn:00001D95                 mov     ecx, [ebp+var_10]
.text$mn:00001D98                 xor     ecx, ebp
.text$mn:00001D9A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001D9F                 mov     esp, ebp
.text$mn:00001DA1                 pop     ebp
.text$mn:00001DA2                 retn    10h
.text$mn:00001DA2 ?run_dlgProc@RunDlg@@MAGHIIJ@Z endp
.text$mn:00001DA2
.text$mn:00001DA2 ; ---------------------------------------------------------------------------
.text$mn:00001DA5                 db 7 dup(0CCh)
.text$mn:00001DAC
.text$mn:00001DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DAC
.text$mn:00001DAC ; Attributes: bp-based frame
.text$mn:00001DAC
.text$mn:00001DAC ; void __thiscall RunDlg::addTextToCombo(RunDlg *this, const wchar_t *)
.text$mn:00001DAC                 public ?addTextToCombo@RunDlg@@ABEXPB_W@Z
.text$mn:00001DAC ?addTextToCombo@RunDlg@@ABEXPB_W@Z proc near
.text$mn:00001DAC                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+113p
.text$mn:00001DAC                                         ; RunDlg::run_dlgProc(uint,uint,long)+533p ...
.text$mn:00001DAC
.text$mn:00001DAC var_C           = dword ptr -0Ch
.text$mn:00001DAC hWnd            = dword ptr -8
.text$mn:00001DAC wParam          = dword ptr -4
.text$mn:00001DAC lParam          = dword ptr  8
.text$mn:00001DAC
.text$mn:00001DAC                 push    ebp
.text$mn:00001DAD                 mov     ebp, esp
.text$mn:00001DAF                 sub     esp, 0Ch
.text$mn:00001DB2                 mov     [ebp+var_C], ecx
.text$mn:00001DB5                 push    76Eh            ; nIDDlgItem
.text$mn:00001DBA                 mov     eax, [ebp+var_C]
.text$mn:00001DBD                 mov     ecx, [eax+0Ch]
.text$mn:00001DC0                 push    ecx             ; hDlg
.text$mn:00001DC1                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001DC7                 mov     [ebp+hWnd], eax
.text$mn:00001DCA                 mov     edx, [ebp+lParam]
.text$mn:00001DCD                 push    edx             ; lParam
.text$mn:00001DCE                 push    0FFFFFFFFh      ; wParam
.text$mn:00001DD0                 push    158h            ; Msg
.text$mn:00001DD5                 mov     eax, [ebp+hWnd]
.text$mn:00001DD8                 push    eax             ; hWnd
.text$mn:00001DD9                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001DDF                 mov     [ebp+wParam], eax
.text$mn:00001DE2                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:00001DE6                 jnz     short loc_1E00
.text$mn:00001DE8                 mov     ecx, [ebp+lParam]
.text$mn:00001DEB                 push    ecx             ; lParam
.text$mn:00001DEC                 push    0               ; wParam
.text$mn:00001DEE                 push    143h            ; Msg
.text$mn:00001DF3                 mov     edx, [ebp+hWnd]
.text$mn:00001DF6                 push    edx             ; hWnd
.text$mn:00001DF7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001DFD                 mov     [ebp+wParam], eax
.text$mn:00001E00
.text$mn:00001E00 loc_1E00:                               ; CODE XREF: RunDlg::addTextToCombo(wchar_t const *)+3Aj
.text$mn:00001E00                 push    0               ; lParam
.text$mn:00001E02                 mov     eax, [ebp+wParam]
.text$mn:00001E05                 push    eax             ; wParam
.text$mn:00001E06                 push    14Eh            ; Msg
.text$mn:00001E0B                 mov     ecx, [ebp+hWnd]
.text$mn:00001E0E                 push    ecx             ; hWnd
.text$mn:00001E0F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001E15                 mov     esp, ebp
.text$mn:00001E17                 pop     ebp
.text$mn:00001E18                 retn    4
.text$mn:00001E18 ?addTextToCombo@RunDlg@@ABEXPB_W@Z endp
.text$mn:00001E18
.text$mn:00001E18 ; ---------------------------------------------------------------------------
.text$mn:00001E1B                 align 4
.text$mn:00001E1C
.text$mn:00001E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E1C
.text$mn:00001E1C ; Attributes: bp-based frame
.text$mn:00001E1C
.text$mn:00001E1C ; void __thiscall RunDlg::removeTextFromCombo(RunDlg *this, const wchar_t *)
.text$mn:00001E1C                 public ?removeTextFromCombo@RunDlg@@ABEXPB_W@Z
.text$mn:00001E1C ?removeTextFromCombo@RunDlg@@ABEXPB_W@Z proc near
.text$mn:00001E1C                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+138p
.text$mn:00001E1C
.text$mn:00001E1C var_C           = dword ptr -0Ch
.text$mn:00001E1C hWnd            = dword ptr -8
.text$mn:00001E1C wParam          = dword ptr -4
.text$mn:00001E1C lParam          = dword ptr  8
.text$mn:00001E1C
.text$mn:00001E1C                 push    ebp
.text$mn:00001E1D                 mov     ebp, esp
.text$mn:00001E1F                 sub     esp, 0Ch
.text$mn:00001E22                 mov     [ebp+var_C], ecx
.text$mn:00001E25                 push    76Eh            ; nIDDlgItem
.text$mn:00001E2A                 mov     eax, [ebp+var_C]
.text$mn:00001E2D                 mov     ecx, [eax+0Ch]
.text$mn:00001E30                 push    ecx             ; hDlg
.text$mn:00001E31                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001E37                 mov     [ebp+hWnd], eax
.text$mn:00001E3A                 mov     edx, [ebp+lParam]
.text$mn:00001E3D                 push    edx             ; lParam
.text$mn:00001E3E                 push    0FFFFFFFFh      ; wParam
.text$mn:00001E40                 push    158h            ; Msg
.text$mn:00001E45                 mov     eax, [ebp+hWnd]
.text$mn:00001E48                 push    eax             ; hWnd
.text$mn:00001E49                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001E4F                 mov     [ebp+wParam], eax
.text$mn:00001E52                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:00001E56                 jnz     short loc_1E5A
.text$mn:00001E58                 jmp     short loc_1E6F
.text$mn:00001E5A ; ---------------------------------------------------------------------------
.text$mn:00001E5A
.text$mn:00001E5A loc_1E5A:                               ; CODE XREF: RunDlg::removeTextFromCombo(wchar_t const *)+3Aj
.text$mn:00001E5A                 push    0               ; lParam
.text$mn:00001E5C                 mov     ecx, [ebp+wParam]
.text$mn:00001E5F                 push    ecx             ; wParam
.text$mn:00001E60                 push    144h            ; Msg
.text$mn:00001E65                 mov     edx, [ebp+hWnd]
.text$mn:00001E68                 push    edx             ; hWnd
.text$mn:00001E69                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001E6F
.text$mn:00001E6F loc_1E6F:                               ; CODE XREF: RunDlg::removeTextFromCombo(wchar_t const *)+3Cj
.text$mn:00001E6F                 mov     esp, ebp
.text$mn:00001E71                 pop     ebp
.text$mn:00001E72                 retn    4
.text$mn:00001E72 ?removeTextFromCombo@RunDlg@@ABEXPB_W@Z endp
.text$mn:00001E72
.text$mn:00001E72 ; ---------------------------------------------------------------------------
.text$mn:00001E75                 align 4
.text$mn:00001E75 _text$mn        ends
.text$mn:00001E75
.text$x:00001E78 ; ===========================================================================
.text$x:00001E78
.text$x:00001E78 ; Segment type: Pure code
.text$x:00001E78 ; Segment permissions: Read/Execute
.text$x:00001E78 _text$x         segment para public 'CODE' use32
.text$x:00001E78                 assume cs:_text$x
.text$x:00001E78                 ;org 1E78h
.text$x:00001E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001E78
.text$x:00001E78 ; =============== S U B R O U T I N E =======================================
.text$x:00001E78
.text$x:00001E78
.text$x:00001E78 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$0 proc near
.text$x:00001E78                                         ; DATA XREF: .xdata$x:000087BCo
.text$x:00001E78                 mov     ecx, [ebp-16FCh] ; this
.text$x:00001E7E                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00001E7E __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$0 endp
.text$x:00001E7E
.text$x:00001E83
.text$x:00001E83 ; =============== S U B R O U T I N E =======================================
.text$x:00001E83
.text$x:00001E83
.text$x:00001E83 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$1 proc near
.text$x:00001E83                                         ; DATA XREF: .xdata$x:000087C4o
.text$x:00001E83                 lea     ecx, [ebp-5F4h] ; this
.text$x:00001E89                 jmp     ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$x:00001E89 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$1 endp
.text$x:00001E89
.text$x:00001E8E
.text$x:00001E8E ; =============== S U B R O U T I N E =======================================
.text$x:00001E8E
.text$x:00001E8E
.text$x:00001E8E __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$2 proc near
.text$x:00001E8E                                         ; DATA XREF: .xdata$x:000087CCo
.text$x:00001E8E                 lea     ecx, [ebp-474h]
.text$x:00001E94                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001E94 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$2 endp
.text$x:00001E94
.text$x:00001E99
.text$x:00001E99 ; =============== S U B R O U T I N E =======================================
.text$x:00001E99
.text$x:00001E99
.text$x:00001E99 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$3 proc near
.text$x:00001E99                                         ; DATA XREF: .xdata$x:000087D4o
.text$x:00001E99                 lea     ecx, [ebp-43Ch]
.text$x:00001E9F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001E9F __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$3 endp
.text$x:00001E9F
.text$x:00001EA4
.text$x:00001EA4 ; =============== S U B R O U T I N E =======================================
.text$x:00001EA4
.text$x:00001EA4
.text$x:00001EA4 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$4 proc near
.text$x:00001EA4                                         ; DATA XREF: .xdata$x:000087DCo
.text$x:00001EA4                 lea     ecx, [ebp-16B0h] ; this
.text$x:00001EAA                 jmp     ??1FileDialog@@QAE@XZ ; FileDialog::~FileDialog(void)
.text$x:00001EAA __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$4 endp
.text$x:00001EAA
.text$x:00001EAF
.text$x:00001EAF ; =============== S U B R O U T I N E =======================================
.text$x:00001EAF
.text$x:00001EAF
.text$x:00001EAF __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$5 proc near
.text$x:00001EAF                                         ; DATA XREF: .xdata$x:000087E4o
.text$x:00001EAF                 lea     ecx, [ebp-458h]
.text$x:00001EB5                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001EB5 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$5 endp
.text$x:00001EB5
.text$x:00001EBA
.text$x:00001EBA ; =============== S U B R O U T I N E =======================================
.text$x:00001EBA
.text$x:00001EBA
.text$x:00001EBA __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$6 proc near
.text$x:00001EBA                                         ; DATA XREF: .xdata$x:000087ECo
.text$x:00001EBA                 lea     ecx, [ebp-4ACh]
.text$x:00001EC0                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001EC0 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$6 endp
.text$x:00001EC0
.text$x:00001EC5
.text$x:00001EC5 ; =============== S U B R O U T I N E =======================================
.text$x:00001EC5
.text$x:00001EC5
.text$x:00001EC5 __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$7 proc near
.text$x:00001EC5                                         ; DATA XREF: .xdata$x:000087F4o
.text$x:00001EC5                 lea     ecx, [ebp-490h]
.text$x:00001ECB                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00001ECB __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$7 endp
.text$x:00001ECB
.text$x:00001ED0
.text$x:00001ED0 ; =============== S U B R O U T I N E =======================================
.text$x:00001ED0
.text$x:00001ED0
.text$x:00001ED0 __ehhandler$?run_dlgProc@RunDlg@@MAGHIIJ@Z proc near
.text$x:00001ED0                                         ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+5o
.text$x:00001ED0
.text$x:00001ED0 arg_4           = dword ptr  8
.text$x:00001ED0
.text$x:00001ED0                 mov     edx, [esp+arg_4]
.text$x:00001ED4                 lea     eax, [edx+0Ch]
.text$x:00001ED7                 mov     ecx, [edx-1700h]
.text$x:00001EDD                 xor     ecx, eax
.text$x:00001EDF                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001EE4                 mov     ecx, [edx-4]
.text$x:00001EE7                 xor     ecx, eax
.text$x:00001EE9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001EEE                 mov     eax, offset __ehfuncinfo$?run_dlgProc@RunDlg@@MAGHIIJ@Z
.text$x:00001EF3                 jmp     ___CxxFrameHandler3
.text$x:00001EF3 __ehhandler$?run_dlgProc@RunDlg@@MAGHIIJ@Z endp
.text$x:00001EF3
.text$x:00001EF3 _text$x         ends
.text$x:00001EF3
.text$mn:00001EF8 ; ===========================================================================
.text$mn:00001EF8
.text$mn:00001EF8 ; Segment type: Pure code
.text$mn:00001EF8 ; Segment permissions: Read/Execute
.text$mn:00001EF8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EF8                 assume cs:_text$mn
.text$mn:00001EF8                 ;org 1EF8h
.text$mn:00001EF8 ; COMDAT (pick any)
.text$mn:00001EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EF8
.text$mn:00001EF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EF8
.text$mn:00001EF8 ; Attributes: bp-based frame
.text$mn:00001EF8
.text$mn:00001EF8 ; bool __cdecl std::operator==<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00001EF8                 public ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00001EF8 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00001EF8                                         ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Cp
.text$mn:00001EF8
.text$mn:00001EF8 var_2           = byte ptr -2
.text$mn:00001EF8 var_1           = byte ptr -1
.text$mn:00001EF8 arg_0           = dword ptr  8
.text$mn:00001EF8 arg_4           = dword ptr  0Ch
.text$mn:00001EF8
.text$mn:00001EF8                 push    ebp
.text$mn:00001EF9                 mov     ebp, esp
.text$mn:00001EFB                 push    ecx
.text$mn:00001EFC                 mov     eax, [ebp+arg_4]
.text$mn:00001EFF                 push    eax
.text$mn:00001F00                 lea     ecx, [ebp+var_1]
.text$mn:00001F03                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00001F08                 push    eax
.text$mn:00001F09                 mov     ecx, [ebp+arg_0]
.text$mn:00001F0C                 push    ecx
.text$mn:00001F0D                 lea     ecx, [ebp+var_2]
.text$mn:00001F10                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00001F15                 push    eax
.text$mn:00001F16                 call    ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z ; std::operator==<wchar_t,wchar_t>(std::allocator<wchar_t> const &,std::allocator<wchar_t> const &)
.text$mn:00001F1B                 add     esp, 8
.text$mn:00001F1E                 mov     esp, ebp
.text$mn:00001F20                 pop     ebp
.text$mn:00001F21                 retn
.text$mn:00001F21 ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00001F21
.text$mn:00001F21 ; ---------------------------------------------------------------------------
.text$mn:00001F22                 align 4
.text$mn:00001F22 _text$mn        ends
.text$mn:00001F22
.text$mn:00001F24 ; ===========================================================================
.text$mn:00001F24
.text$mn:00001F24 ; Segment type: Pure code
.text$mn:00001F24 ; Segment permissions: Read/Execute
.text$mn:00001F24 _text$mn        segment para public 'CODE' use32
.text$mn:00001F24                 assume cs:_text$mn
.text$mn:00001F24                 ;org 1F24h
.text$mn:00001F24 ; COMDAT (pick any)
.text$mn:00001F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F24
.text$mn:00001F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F24
.text$mn:00001F24 ; Attributes: bp-based frame
.text$mn:00001F24
.text$mn:00001F24 ; int __cdecl std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str)
.text$mn:00001F24                 public ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z
.text$mn:00001F24 ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z proc near
.text$mn:00001F24                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+34Ep
.text$mn:00001F24
.text$mn:00001F24 var_4           = dword ptr -4
.text$mn:00001F24 arg_0           = dword ptr  8
.text$mn:00001F24 Str             = dword ptr  0Ch
.text$mn:00001F24
.text$mn:00001F24                 push    ebp
.text$mn:00001F25                 mov     ebp, esp
.text$mn:00001F27                 push    ecx
.text$mn:00001F28                 mov     eax, [ebp+Str]
.text$mn:00001F2B                 push    eax             ; Str
.text$mn:00001F2C                 mov     ecx, [ebp+arg_0]
.text$mn:00001F2F                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)
.text$mn:00001F34                 test    eax, eax
.text$mn:00001F36                 jnz     short loc_1F41
.text$mn:00001F38                 mov     [ebp+var_4], 1
.text$mn:00001F3F                 jmp     short loc_1F48
.text$mn:00001F41 ; ---------------------------------------------------------------------------
.text$mn:00001F41
.text$mn:00001F41 loc_1F41:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+12j
.text$mn:00001F41                 mov     [ebp+var_4], 0
.text$mn:00001F48
.text$mn:00001F48 loc_1F48:                               ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+1Bj
.text$mn:00001F48                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001F4B                 mov     esp, ebp
.text$mn:00001F4D                 pop     ebp
.text$mn:00001F4E                 retn
.text$mn:00001F4E ??$?8_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA_NABV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_W@Z endp
.text$mn:00001F4E
.text$mn:00001F4E ; ---------------------------------------------------------------------------
.text$mn:00001F4F                 align 10h
.text$mn:00001F4F _text$mn        ends
.text$mn:00001F4F
.text$mn:00001F50 ; ===========================================================================
.text$mn:00001F50
.text$mn:00001F50 ; Segment type: Pure code
.text$mn:00001F50 ; Segment permissions: Read/Execute
.text$mn:00001F50 _text$mn        segment para public 'CODE' use32
.text$mn:00001F50                 assume cs:_text$mn
.text$mn:00001F50                 ;org 1F50h
.text$mn:00001F50 ; COMDAT (pick any)
.text$mn:00001F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F50
.text$mn:00001F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F50
.text$mn:00001F50 ; Attributes: bp-based frame
.text$mn:00001F50
.text$mn:00001F50 ; bool __cdecl std::operator==<wchar_t, wchar_t>(class std::allocator<wchar_t> const &, class std::allocator<wchar_t> const &)
.text$mn:00001F50                 public ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z
.text$mn:00001F50 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z proc near
.text$mn:00001F50                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+1Ep
.text$mn:00001F50                 push    ebp
.text$mn:00001F51                 mov     ebp, esp
.text$mn:00001F53                 mov     al, 1
.text$mn:00001F55                 pop     ebp
.text$mn:00001F56                 retn
.text$mn:00001F56 ??$?8_W_W@std@@YA_NABV?$allocator@_W@0@0@Z endp
.text$mn:00001F56
.text$mn:00001F56 ; ---------------------------------------------------------------------------
.text$mn:00001F57                 align 4
.text$mn:00001F57 _text$mn        ends
.text$mn:00001F57
.text$mn:00001F58 ; ===========================================================================
.text$mn:00001F58
.text$mn:00001F58 ; Segment type: Pure code
.text$mn:00001F58 ; Segment permissions: Read/Execute
.text$mn:00001F58 _text$mn        segment para public 'CODE' use32
.text$mn:00001F58                 assume cs:_text$mn
.text$mn:00001F58                 ;org 1F58h
.text$mn:00001F58 ; COMDAT (pick any)
.text$mn:00001F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F58
.text$mn:00001F58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F58
.text$mn:00001F58 ; Attributes: bp-based frame
.text$mn:00001F58
.text$mn:00001F58 ; bool __cdecl std::operator!=<class std::allocator<wchar_t>, class std::allocator<wchar_t>>(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &, struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00001F58                 public ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z
.text$mn:00001F58 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z proc near
.text$mn:00001F58                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+73p
.text$mn:00001F58
.text$mn:00001F58 var_4           = dword ptr -4
.text$mn:00001F58 arg_0           = dword ptr  8
.text$mn:00001F58 arg_4           = dword ptr  0Ch
.text$mn:00001F58
.text$mn:00001F58                 push    ebp
.text$mn:00001F59                 mov     ebp, esp
.text$mn:00001F5B                 push    ecx
.text$mn:00001F5C                 mov     eax, [ebp+arg_4]
.text$mn:00001F5F                 push    eax
.text$mn:00001F60                 mov     ecx, [ebp+arg_0]
.text$mn:00001F63                 push    ecx
.text$mn:00001F64                 call    ??$?8V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00001F69                 add     esp, 8
.text$mn:00001F6C                 movzx   edx, al
.text$mn:00001F6F                 test    edx, edx
.text$mn:00001F71                 jnz     short loc_1F7C
.text$mn:00001F73                 mov     [ebp+var_4], 1
.text$mn:00001F7A                 jmp     short loc_1F83
.text$mn:00001F7C ; ---------------------------------------------------------------------------
.text$mn:00001F7C
.text$mn:00001F7C loc_1F7C:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+19j
.text$mn:00001F7C                 mov     [ebp+var_4], 0
.text$mn:00001F83
.text$mn:00001F83 loc_1F83:                               ; CODE XREF: std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+22j
.text$mn:00001F83                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001F86                 mov     esp, ebp
.text$mn:00001F88                 pop     ebp
.text$mn:00001F89                 retn
.text$mn:00001F89 ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z endp
.text$mn:00001F89
.text$mn:00001F89 ; ---------------------------------------------------------------------------
.text$mn:00001F8A                 align 4
.text$mn:00001F8A _text$mn        ends
.text$mn:00001F8A
.text$mn:00001F8C ; ===========================================================================
.text$mn:00001F8C
.text$mn:00001F8C ; Segment type: Pure code
.text$mn:00001F8C ; Segment permissions: Read/Execute
.text$mn:00001F8C _text$mn        segment para public 'CODE' use32
.text$mn:00001F8C                 assume cs:_text$mn
.text$mn:00001F8C                 ;org 1F8Ch
.text$mn:00001F8C ; COMDAT (pick any)
.text$mn:00001F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F8C
.text$mn:00001F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F8C
.text$mn:00001F8C ; Attributes: bp-based frame
.text$mn:00001F8C
.text$mn:00001F8C ; int __cdecl std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, int, wchar_t *Str)
.text$mn:00001F8C                 public ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.text$mn:00001F8C ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z proc near
.text$mn:00001F8C                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+4D6p
.text$mn:00001F8C
.text$mn:00001F8C var_10          = dword ptr -10h
.text$mn:00001F8C var_C           = dword ptr -0Ch
.text$mn:00001F8C var_4           = dword ptr -4
.text$mn:00001F8C arg_0           = dword ptr  8
.text$mn:00001F8C arg_4           = dword ptr  0Ch
.text$mn:00001F8C Str             = dword ptr  10h
.text$mn:00001F8C
.text$mn:00001F8C                 push    ebp
.text$mn:00001F8D                 mov     ebp, esp
.text$mn:00001F8F                 push    0FFFFFFFFh
.text$mn:00001F91                 push    offset __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.text$mn:00001F96                 mov     eax, large fs:0
.text$mn:00001F9C                 push    eax
.text$mn:00001F9D                 push    ecx
.text$mn:00001F9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001FA3                 xor     eax, ebp
.text$mn:00001FA5                 push    eax
.text$mn:00001FA6                 lea     eax, [ebp+var_C]
.text$mn:00001FA9                 mov     large fs:0, eax
.text$mn:00001FAF                 mov     [ebp+var_10], 0
.text$mn:00001FB6                 mov     eax, [ebp+Str]
.text$mn:00001FB9                 push    eax             ; Str
.text$mn:00001FBA                 mov     ecx, [ebp+arg_4]
.text$mn:00001FBD                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00001FC2                 push    eax
.text$mn:00001FC3                 call    ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::move<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00001FC8                 add     esp, 4
.text$mn:00001FCB                 push    eax
.text$mn:00001FCC                 mov     ecx, [ebp+arg_0]
.text$mn:00001FCF                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00001FD4                 mov     [ebp+var_4], 0
.text$mn:00001FDB                 mov     ecx, [ebp+var_10]
.text$mn:00001FDE                 or      ecx, 1
.text$mn:00001FE1                 mov     [ebp+var_10], ecx
.text$mn:00001FE4                 mov     eax, [ebp+arg_0]
.text$mn:00001FE7                 mov     ecx, [ebp+var_C]
.text$mn:00001FEA                 mov     large fs:0, ecx
.text$mn:00001FF1                 pop     ecx
.text$mn:00001FF2                 mov     esp, ebp
.text$mn:00001FF4                 pop     ebp
.text$mn:00001FF5                 retn
.text$mn:00001FF5 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z endp
.text$mn:00001FF5
.text$mn:00001FF5 ; ---------------------------------------------------------------------------
.text$mn:00001FF6                 align 4
.text$mn:00001FF6 _text$mn        ends
.text$mn:00001FF6
.text$x:00001FF8 ; ===========================================================================
.text$x:00001FF8
.text$x:00001FF8 ; Segment type: Pure code
.text$x:00001FF8 ; Segment permissions: Read/Execute
.text$x:00001FF8 _text$x         segment para public 'CODE' use32
.text$x:00001FF8                 assume cs:_text$x
.text$x:00001FF8                 ;org 1FF8h
.text$x:00001FF8 ; COMDAT (pick associative to section at 1F8C)
.text$x:00001FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001FF8
.text$x:00001FF8 ; =============== S U B R O U T I N E =======================================
.text$x:00001FF8
.text$x:00001FF8
.text$x:00001FF8 __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0 proc near
.text$x:00001FF8                                         ; DATA XREF: .xdata$x:00008AD8o
.text$x:00001FF8                 mov     eax, [ebp-10h]
.text$x:00001FFB                 and     eax, 1
.text$x:00001FFE                 jz      $LN4_1
.text$x:00002004                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002008                 mov     ecx, [ebp+8]
.text$x:0000200B                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002010 ; ---------------------------------------------------------------------------
.text$x:00002010
.text$x:00002010 $LN4_1:                                 ; CODE XREF: __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0+6j
.text$x:00002010                 retn
.text$x:00002010 __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0 endp
.text$x:00002010
.text$x:00002011
.text$x:00002011 ; =============== S U B R O U T I N E =======================================
.text$x:00002011
.text$x:00002011
.text$x:00002011 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z proc near
.text$x:00002011                                         ; DATA XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)+5o
.text$x:00002011
.text$x:00002011 arg_4           = dword ptr  8
.text$x:00002011
.text$x:00002011                 mov     edx, [esp+arg_4]
.text$x:00002015                 lea     eax, [edx+0Ch]
.text$x:00002018                 mov     ecx, [edx-8]
.text$x:0000201B                 xor     ecx, eax
.text$x:0000201D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002022                 mov     eax, offset __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.text$x:00002027                 jmp     ___CxxFrameHandler3
.text$x:00002027 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z endp
.text$x:00002027
.text$x:00002027 _text$x         ends
.text$x:00002027
.text$mn:0000202C ; ===========================================================================
.text$mn:0000202C
.text$mn:0000202C ; Segment type: Pure code
.text$mn:0000202C ; Segment permissions: Read/Execute
.text$mn:0000202C _text$mn        segment para public 'CODE' use32
.text$mn:0000202C                 assume cs:_text$mn
.text$mn:0000202C                 ;org 202Ch
.text$mn:0000202C ; COMDAT (pick any)
.text$mn:0000202C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000202C
.text$mn:0000202C ; =============== S U B R O U T I N E =======================================
.text$mn:0000202C
.text$mn:0000202C ; Attributes: bp-based frame
.text$mn:0000202C
.text$mn:0000202C ; int __cdecl std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(int, wchar_t *Str, int)
.text$mn:0000202C                 public ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
.text$mn:0000202C ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z proc near
.text$mn:0000202C                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+4AAp
.text$mn:0000202C
.text$mn:0000202C var_30          = dword ptr -30h
.text$mn:0000202C var_2C          = byte ptr -2Ch
.text$mn:0000202C var_10          = dword ptr -10h
.text$mn:0000202C var_C           = dword ptr -0Ch
.text$mn:0000202C var_4           = dword ptr -4
.text$mn:0000202C arg_0           = dword ptr  8
.text$mn:0000202C Str             = dword ptr  0Ch
.text$mn:0000202C arg_8           = dword ptr  10h
.text$mn:0000202C
.text$mn:0000202C                 push    ebp
.text$mn:0000202D                 mov     ebp, esp
.text$mn:0000202F                 push    0FFFFFFFFh
.text$mn:00002031                 push    offset __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
.text$mn:00002036                 mov     eax, large fs:0
.text$mn:0000203C                 push    eax
.text$mn:0000203D                 sub     esp, 24h
.text$mn:00002040                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002045                 xor     eax, ebp
.text$mn:00002047                 mov     [ebp+var_10], eax
.text$mn:0000204A                 push    esi
.text$mn:0000204B                 push    eax
.text$mn:0000204C                 lea     eax, [ebp+var_C]
.text$mn:0000204F                 mov     large fs:0, eax
.text$mn:00002055                 mov     [ebp+var_30], 0
.text$mn:0000205C                 lea     ecx, [ebp+var_2C]
.text$mn:0000205F                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00002064                 mov     [ebp+var_4], 1
.text$mn:0000206B                 mov     eax, [ebp+Str]
.text$mn:0000206E                 push    eax             ; Str
.text$mn:0000206F                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00002074                 add     esp, 4
.text$mn:00002077                 mov     esi, eax
.text$mn:00002079                 mov     ecx, [ebp+arg_8]
.text$mn:0000207C                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00002081                 add     esi, eax
.text$mn:00002083                 push    esi
.text$mn:00002084                 lea     ecx, [ebp+var_2C]
.text$mn:00002087                 call    ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::reserve(uint)
.text$mn:0000208C                 mov     ecx, [ebp+Str]
.text$mn:0000208F                 push    ecx             ; Str
.text$mn:00002090                 lea     ecx, [ebp+var_2C]
.text$mn:00002093                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00002098                 mov     edx, [ebp+arg_8]
.text$mn:0000209B                 push    edx
.text$mn:0000209C                 lea     ecx, [ebp+var_2C]
.text$mn:0000209F                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:000020A4                 lea     eax, [ebp+var_2C]
.text$mn:000020A7                 push    eax
.text$mn:000020A8                 mov     ecx, [ebp+arg_0]
.text$mn:000020AB                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000020B0                 mov     ecx, [ebp+var_30]
.text$mn:000020B3                 or      ecx, 1
.text$mn:000020B6                 mov     [ebp+var_30], ecx
.text$mn:000020B9                 mov     byte ptr [ebp+var_4], 0
.text$mn:000020BD                 lea     ecx, [ebp+var_2C]
.text$mn:000020C0                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000020C5                 mov     eax, [ebp+arg_0]
.text$mn:000020C8                 mov     ecx, [ebp+var_C]
.text$mn:000020CB                 mov     large fs:0, ecx
.text$mn:000020D2                 pop     ecx
.text$mn:000020D3                 pop     esi
.text$mn:000020D4                 mov     ecx, [ebp+var_10]
.text$mn:000020D7                 xor     ecx, ebp
.text$mn:000020D9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000020DE                 mov     esp, ebp
.text$mn:000020E0                 pop     ebp
.text$mn:000020E1                 retn
.text$mn:000020E1 ??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z endp
.text$mn:000020E1
.text$mn:000020E1 ; ---------------------------------------------------------------------------
.text$mn:000020E2                 align 4
.text$mn:000020E2 _text$mn        ends
.text$mn:000020E2
.text$x:000020E4 ; ===========================================================================
.text$x:000020E4
.text$x:000020E4 ; Segment type: Pure code
.text$x:000020E4 ; Segment permissions: Read/Execute
.text$x:000020E4 _text$x         segment para public 'CODE' use32
.text$x:000020E4                 assume cs:_text$x
.text$x:000020E4                 ;org 20E4h
.text$x:000020E4 ; COMDAT (pick associative to section at 202C)
.text$x:000020E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000020E4
.text$x:000020E4 ; =============== S U B R O U T I N E =======================================
.text$x:000020E4
.text$x:000020E4
.text$x:000020E4 __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0 proc near
.text$x:000020E4                                         ; DATA XREF: .xdata$x:00008AACo
.text$x:000020E4                 lea     ecx, [ebp-2Ch]
.text$x:000020E7                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000020E7 __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0 endp
.text$x:000020E7
.text$x:000020EC
.text$x:000020EC ; =============== S U B R O U T I N E =======================================
.text$x:000020EC
.text$x:000020EC
.text$x:000020EC __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$1 proc near
.text$x:000020EC                                         ; DATA XREF: .xdata$x:00008AA4o
.text$x:000020EC                 mov     eax, [ebp-30h]
.text$x:000020EF                 and     eax, 1
.text$x:000020F2                 jz      $LN5
.text$x:000020F8                 and     dword ptr [ebp-30h], 0FFFFFFFEh
.text$x:000020FC                 mov     ecx, [ebp+8]
.text$x:000020FF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00002104 ; ---------------------------------------------------------------------------
.text$x:00002104
.text$x:00002104 $LN5:                                   ; CODE XREF: __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$1+6j
.text$x:00002104                 retn
.text$x:00002104 __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$1 endp
.text$x:00002104
.text$x:00002105
.text$x:00002105 ; =============== S U B R O U T I N E =======================================
.text$x:00002105
.text$x:00002105
.text$x:00002105 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z proc near
.text$x:00002105                                         ; DATA XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:00002105
.text$x:00002105 arg_4           = dword ptr  8
.text$x:00002105
.text$x:00002105                 mov     edx, [esp+arg_4]
.text$x:00002109                 lea     eax, [edx+0Ch]
.text$x:0000210C                 mov     ecx, [edx-2Ch]
.text$x:0000210F                 xor     ecx, eax
.text$x:00002111                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002116                 mov     ecx, [edx-4]
.text$x:00002119                 xor     ecx, eax
.text$x:0000211B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002120                 mov     eax, offset __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
.text$x:00002125                 jmp     ___CxxFrameHandler3
.text$x:00002125 __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z endp
.text$x:00002125
.text$x:00002125 ; ---------------------------------------------------------------------------
.text$x:0000212A                 align 4
.text$x:0000212A _text$x         ends
.text$x:0000212A
.text$mn:0000212C ; ===========================================================================
.text$mn:0000212C
.text$mn:0000212C ; Segment type: Pure code
.text$mn:0000212C ; Segment permissions: Read/Execute
.text$mn:0000212C _text$mn        segment para public 'CODE' use32
.text$mn:0000212C                 assume cs:_text$mn
.text$mn:0000212C                 ;org 212Ch
.text$mn:0000212C ; COMDAT (pick any)
.text$mn:0000212C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000212C
.text$mn:0000212C ; =============== S U B R O U T I N E =======================================
.text$mn:0000212C
.text$mn:0000212C ; Attributes: bp-based frame
.text$mn:0000212C
.text$mn:0000212C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:0000212C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:0000212C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:0000212C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:0000212C
.text$mn:0000212C var_4           = dword ptr -4
.text$mn:0000212C arg_0           = dword ptr  8
.text$mn:0000212C
.text$mn:0000212C                 push    ebp
.text$mn:0000212D                 mov     ebp, esp
.text$mn:0000212F                 push    ecx
.text$mn:00002130                 mov     [ebp+var_4], 0
.text$mn:00002137                 cmp     [ebp+arg_0], 0
.text$mn:0000213B                 jnz     short loc_213F
.text$mn:0000213D                 jmp     short loc_215F
.text$mn:0000213F ; ---------------------------------------------------------------------------
.text$mn:0000213F
.text$mn:0000213F loc_213F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:0000213F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00002143                 ja      short loc_215A
.text$mn:00002145                 mov     eax, [ebp+arg_0]
.text$mn:00002148                 push    eax             ; unsigned int
.text$mn:00002149                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:0000214E                 add     esp, 4
.text$mn:00002151                 mov     [ebp+var_4], eax
.text$mn:00002154                 cmp     [ebp+var_4], 0
.text$mn:00002158                 jnz     short loc_215F
.text$mn:0000215A
.text$mn:0000215A loc_215A:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:0000215A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:0000215F
.text$mn:0000215F loc_215F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:0000215F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:0000215F                 mov     eax, [ebp+var_4]
.text$mn:00002162                 mov     esp, ebp
.text$mn:00002164                 pop     ebp
.text$mn:00002165                 retn
.text$mn:00002165 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00002165
.text$mn:00002165 ; ---------------------------------------------------------------------------
.text$mn:00002166                 align 4
.text$mn:00002166 _text$mn        ends
.text$mn:00002166
.text$mn:00002168 ; ===========================================================================
.text$mn:00002168
.text$mn:00002168 ; Segment type: Pure code
.text$mn:00002168 ; Segment permissions: Read/Execute
.text$mn:00002168 _text$mn        segment para public 'CODE' use32
.text$mn:00002168                 assume cs:_text$mn
.text$mn:00002168                 ;org 2168h
.text$mn:00002168 ; COMDAT (pick any)
.text$mn:00002168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002168
.text$mn:00002168 ; =============== S U B R O U T I N E =======================================
.text$mn:00002168
.text$mn:00002168 ; Attributes: bp-based frame
.text$mn:00002168
.text$mn:00002168 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00002168                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00002168 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00002168                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00002168
.text$mn:00002168 var_4           = dword ptr -4
.text$mn:00002168 arg_0           = dword ptr  8
.text$mn:00002168
.text$mn:00002168                 push    ebp
.text$mn:00002169                 mov     ebp, esp
.text$mn:0000216B                 push    ecx
.text$mn:0000216C                 mov     [ebp+var_4], 0
.text$mn:00002173                 cmp     [ebp+arg_0], 0
.text$mn:00002177                 jnz     short loc_217B
.text$mn:00002179                 jmp     short loc_21A1
.text$mn:0000217B ; ---------------------------------------------------------------------------
.text$mn:0000217B
.text$mn:0000217B loc_217B:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000217B                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00002182                 ja      short loc_219C
.text$mn:00002184                 mov     eax, [ebp+arg_0]
.text$mn:00002187                 shl     eax, 3
.text$mn:0000218A                 push    eax             ; unsigned int
.text$mn:0000218B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002190                 add     esp, 4
.text$mn:00002193                 mov     [ebp+var_4], eax
.text$mn:00002196                 cmp     [ebp+var_4], 0
.text$mn:0000219A                 jnz     short loc_21A1
.text$mn:0000219C
.text$mn:0000219C loc_219C:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:0000219C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000021A1
.text$mn:000021A1 loc_21A1:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:000021A1                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:000021A1                 mov     eax, [ebp+var_4]
.text$mn:000021A4                 mov     esp, ebp
.text$mn:000021A6                 pop     ebp
.text$mn:000021A7                 retn
.text$mn:000021A7 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:000021A7
.text$mn:000021A7 _text$mn        ends
.text$mn:000021A7
.text$mn:000021A8 ; ===========================================================================
.text$mn:000021A8
.text$mn:000021A8 ; Segment type: Pure code
.text$mn:000021A8 ; Segment permissions: Read/Execute
.text$mn:000021A8 _text$mn        segment para public 'CODE' use32
.text$mn:000021A8                 assume cs:_text$mn
.text$mn:000021A8                 ;org 21A8h
.text$mn:000021A8 ; COMDAT (pick any)
.text$mn:000021A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021A8
.text$mn:000021A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000021A8
.text$mn:000021A8 ; Attributes: bp-based frame
.text$mn:000021A8
.text$mn:000021A8 ; class UserCommand * __cdecl std::_Allocate<class UserCommand>(unsigned int, class UserCommand *)
.text$mn:000021A8                 public ??$_Allocate@VUserCommand@@@std@@YAPAVUserCommand@@IPAV1@@Z
.text$mn:000021A8 ??$_Allocate@VUserCommand@@@std@@YAPAVUserCommand@@IPAV1@@Z proc near
.text$mn:000021A8                                         ; CODE XREF: std::allocator<UserCommand>::allocate(uint)+Dp
.text$mn:000021A8
.text$mn:000021A8 var_4           = dword ptr -4
.text$mn:000021A8 arg_0           = dword ptr  8
.text$mn:000021A8
.text$mn:000021A8                 push    ebp
.text$mn:000021A9                 mov     ebp, esp
.text$mn:000021AB                 push    ecx
.text$mn:000021AC                 mov     [ebp+var_4], 0
.text$mn:000021B3                 cmp     [ebp+arg_0], 0
.text$mn:000021B7                 jnz     short loc_21BB
.text$mn:000021B9                 jmp     short loc_21E2
.text$mn:000021BB ; ---------------------------------------------------------------------------
.text$mn:000021BB
.text$mn:000021BB loc_21BB:                               ; CODE XREF: std::_Allocate<UserCommand>(uint,UserCommand *)+Fj
.text$mn:000021BB                 cmp     [ebp+arg_0], 0C7CE0Ch
.text$mn:000021C2                 ja      short loc_21DD
.text$mn:000021C4                 imul    eax, [ebp+arg_0], 148h
.text$mn:000021CB                 push    eax             ; unsigned int
.text$mn:000021CC                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000021D1                 add     esp, 4
.text$mn:000021D4                 mov     [ebp+var_4], eax
.text$mn:000021D7                 cmp     [ebp+var_4], 0
.text$mn:000021DB                 jnz     short loc_21E2
.text$mn:000021DD
.text$mn:000021DD loc_21DD:                               ; CODE XREF: std::_Allocate<UserCommand>(uint,UserCommand *)+1Aj
.text$mn:000021DD                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000021E2
.text$mn:000021E2 loc_21E2:                               ; CODE XREF: std::_Allocate<UserCommand>(uint,UserCommand *)+11j
.text$mn:000021E2                                         ; std::_Allocate<UserCommand>(uint,UserCommand *)+33j
.text$mn:000021E2                 mov     eax, [ebp+var_4]
.text$mn:000021E5                 mov     esp, ebp
.text$mn:000021E7                 pop     ebp
.text$mn:000021E8                 retn
.text$mn:000021E8 ??$_Allocate@VUserCommand@@@std@@YAPAVUserCommand@@IPAV1@@Z endp
.text$mn:000021E8
.text$mn:000021E8 ; ---------------------------------------------------------------------------
.text$mn:000021E9                 align 4
.text$mn:000021E9 _text$mn        ends
.text$mn:000021E9
.text$mn:000021EC ; ===========================================================================
.text$mn:000021EC
.text$mn:000021EC ; Segment type: Pure code
.text$mn:000021EC ; Segment permissions: Read/Execute
.text$mn:000021EC _text$mn        segment para public 'CODE' use32
.text$mn:000021EC                 assume cs:_text$mn
.text$mn:000021EC                 ;org 21ECh
.text$mn:000021EC ; COMDAT (pick any)
.text$mn:000021EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021EC
.text$mn:000021EC ; =============== S U B R O U T I N E =======================================
.text$mn:000021EC
.text$mn:000021EC ; Attributes: bp-based frame
.text$mn:000021EC
.text$mn:000021EC ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:000021EC                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:000021EC ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:000021EC                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:000021EC
.text$mn:000021EC var_4           = dword ptr -4
.text$mn:000021EC arg_0           = dword ptr  8
.text$mn:000021EC
.text$mn:000021EC                 push    ebp
.text$mn:000021ED                 mov     ebp, esp
.text$mn:000021EF                 push    ecx
.text$mn:000021F0                 mov     [ebp+var_4], 0
.text$mn:000021F7                 cmp     [ebp+arg_0], 0
.text$mn:000021FB                 jnz     short loc_21FF
.text$mn:000021FD                 jmp     short loc_2224
.text$mn:000021FF ; ---------------------------------------------------------------------------
.text$mn:000021FF
.text$mn:000021FF loc_21FF:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:000021FF                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00002206                 ja      short loc_221F
.text$mn:00002208                 mov     eax, [ebp+arg_0]
.text$mn:0000220B                 shl     eax, 1
.text$mn:0000220D                 push    eax             ; unsigned int
.text$mn:0000220E                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00002213                 add     esp, 4
.text$mn:00002216                 mov     [ebp+var_4], eax
.text$mn:00002219                 cmp     [ebp+var_4], 0
.text$mn:0000221D                 jnz     short loc_2224
.text$mn:0000221F
.text$mn:0000221F loc_221F:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:0000221F                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00002224
.text$mn:00002224 loc_2224:                               ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00002224                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00002224                 mov     eax, [ebp+var_4]
.text$mn:00002227                 mov     esp, ebp
.text$mn:00002229                 pop     ebp
.text$mn:0000222A                 retn
.text$mn:0000222A ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:0000222A
.text$mn:0000222A ; ---------------------------------------------------------------------------
.text$mn:0000222B                 align 4
.text$mn:0000222B _text$mn        ends
.text$mn:0000222B
.text$mn:0000222C ; ===========================================================================
.text$mn:0000222C
.text$mn:0000222C ; Segment type: Pure code
.text$mn:0000222C ; Segment permissions: Read/Execute
.text$mn:0000222C _text$mn        segment para public 'CODE' use32
.text$mn:0000222C                 assume cs:_text$mn
.text$mn:0000222C                 ;org 222Ch
.text$mn:0000222C ; COMDAT (pick any)
.text$mn:0000222C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000222C
.text$mn:0000222C ; =============== S U B R O U T I N E =======================================
.text$mn:0000222C
.text$mn:0000222C ; Attributes: bp-based frame
.text$mn:0000222C
.text$mn:0000222C ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:0000222C                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:0000222C ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:0000222C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:0000222C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:0000222C
.text$mn:0000222C arg_0           = dword ptr  8
.text$mn:0000222C arg_4           = dword ptr  0Ch
.text$mn:0000222C arg_8           = dword ptr  10h
.text$mn:0000222C
.text$mn:0000222C                 push    ebp
.text$mn:0000222D                 mov     ebp, esp
.text$mn:0000222F                 cmp     [ebp+arg_0], 0
.text$mn:00002233                 jnz     short loc_224A
.text$mn:00002235                 mov     eax, [ebp+arg_8]
.text$mn:00002238                 push    eax             ; unsigned int
.text$mn:00002239                 mov     ecx, [ebp+arg_4]
.text$mn:0000223C                 push    ecx             ; wchar_t *
.text$mn:0000223D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002242                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002247                 add     esp, 0Ch
.text$mn:0000224A
.text$mn:0000224A loc_224A:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:0000224A                 pop     ebp
.text$mn:0000224B                 retn
.text$mn:0000224B ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:0000224B
.text$mn:0000224B _text$mn        ends
.text$mn:0000224B
.text$mn:0000224C ; ===========================================================================
.text$mn:0000224C
.text$mn:0000224C ; Segment type: Pure code
.text$mn:0000224C ; Segment permissions: Read/Execute
.text$mn:0000224C _text$mn        segment para public 'CODE' use32
.text$mn:0000224C                 assume cs:_text$mn
.text$mn:0000224C                 ;org 224Ch
.text$mn:0000224C ; COMDAT (pick any)
.text$mn:0000224C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000224C
.text$mn:0000224C ; =============== S U B R O U T I N E =======================================
.text$mn:0000224C
.text$mn:0000224C ; Attributes: bp-based frame
.text$mn:0000224C
.text$mn:0000224C ; int __cdecl std::_Debug_pointer<UserCommand>(int, wchar_t *, unsigned int)
.text$mn:0000224C                 public ??$_Debug_pointer@VUserCommand@@@std@@YAXPAVUserCommand@@PB_WI@Z
.text$mn:0000224C ??$_Debug_pointer@VUserCommand@@@std@@YAXPAVUserCommand@@PB_WI@Z proc near
.text$mn:0000224C                                         ; CODE XREF: std::_Debug_range2<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:0000224C                                         ; std::_Debug_range2<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:0000224C
.text$mn:0000224C arg_0           = dword ptr  8
.text$mn:0000224C arg_4           = dword ptr  0Ch
.text$mn:0000224C arg_8           = dword ptr  10h
.text$mn:0000224C
.text$mn:0000224C                 push    ebp
.text$mn:0000224D                 mov     ebp, esp
.text$mn:0000224F                 cmp     [ebp+arg_0], 0
.text$mn:00002253                 jnz     short loc_226A
.text$mn:00002255                 mov     eax, [ebp+arg_8]
.text$mn:00002258                 push    eax             ; unsigned int
.text$mn:00002259                 mov     ecx, [ebp+arg_4]
.text$mn:0000225C                 push    ecx             ; wchar_t *
.text$mn:0000225D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002262                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002267                 add     esp, 0Ch
.text$mn:0000226A
.text$mn:0000226A loc_226A:                               ; CODE XREF: std::_Debug_pointer<UserCommand>(UserCommand *,wchar_t const *,uint)+7j
.text$mn:0000226A                 pop     ebp
.text$mn:0000226B                 retn
.text$mn:0000226B ??$_Debug_pointer@VUserCommand@@@std@@YAXPAVUserCommand@@PB_WI@Z endp
.text$mn:0000226B
.text$mn:0000226B _text$mn        ends
.text$mn:0000226B
.text$mn:0000226C ; ===========================================================================
.text$mn:0000226C
.text$mn:0000226C ; Segment type: Pure code
.text$mn:0000226C ; Segment permissions: Read/Execute
.text$mn:0000226C _text$mn        segment para public 'CODE' use32
.text$mn:0000226C                 assume cs:_text$mn
.text$mn:0000226C                 ;org 226Ch
.text$mn:0000226C ; COMDAT (pick any)
.text$mn:0000226C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000226C
.text$mn:0000226C ; =============== S U B R O U T I N E =======================================
.text$mn:0000226C
.text$mn:0000226C ; Attributes: bp-based frame
.text$mn:0000226C
.text$mn:0000226C ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:0000226C                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:0000226C ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:0000226C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+15p
.text$mn:0000226C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+1Dp ...
.text$mn:0000226C
.text$mn:0000226C arg_0           = dword ptr  8
.text$mn:0000226C arg_4           = dword ptr  0Ch
.text$mn:0000226C arg_8           = dword ptr  10h
.text$mn:0000226C
.text$mn:0000226C                 push    ebp
.text$mn:0000226D                 mov     ebp, esp
.text$mn:0000226F                 cmp     [ebp+arg_0], 0
.text$mn:00002273                 jnz     short loc_228A
.text$mn:00002275                 mov     eax, [ebp+arg_8]
.text$mn:00002278                 push    eax             ; unsigned int
.text$mn:00002279                 mov     ecx, [ebp+arg_4]
.text$mn:0000227C                 push    ecx             ; wchar_t *
.text$mn:0000227D                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002282                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002287                 add     esp, 0Ch
.text$mn:0000228A
.text$mn:0000228A loc_228A:                               ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:0000228A                 pop     ebp
.text$mn:0000228B                 retn
.text$mn:0000228B ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:0000228B
.text$mn:0000228B _text$mn        ends
.text$mn:0000228B
.text$mn:0000228C ; ===========================================================================
.text$mn:0000228C
.text$mn:0000228C ; Segment type: Pure code
.text$mn:0000228C ; Segment permissions: Read/Execute
.text$mn:0000228C _text$mn        segment para public 'CODE' use32
.text$mn:0000228C                 assume cs:_text$mn
.text$mn:0000228C                 ;org 228Ch
.text$mn:0000228C ; COMDAT (pick any)
.text$mn:0000228C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000228C
.text$mn:0000228C ; =============== S U B R O U T I N E =======================================
.text$mn:0000228C
.text$mn:0000228C ; Attributes: bp-based frame
.text$mn:0000228C
.text$mn:0000228C ; int __cdecl std::_Debug_range2<UserCommand *>(int, int, wchar_t *, unsigned int)
.text$mn:0000228C                 public ??$_Debug_range2@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000228C ??$_Debug_range2@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:0000228C                                         ; CODE XREF: std::_Debug_range<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint)+2Ap
.text$mn:0000228C
.text$mn:0000228C arg_0           = dword ptr  8
.text$mn:0000228C arg_4           = dword ptr  0Ch
.text$mn:0000228C arg_8           = dword ptr  10h
.text$mn:0000228C arg_C           = dword ptr  14h
.text$mn:0000228C
.text$mn:0000228C                 push    ebp
.text$mn:0000228D                 mov     ebp, esp
.text$mn:0000228F                 mov     eax, [ebp+arg_0]
.text$mn:00002292                 cmp     eax, [ebp+arg_4]
.text$mn:00002295                 jz      short loc_22DC
.text$mn:00002297                 mov     ecx, [ebp+arg_C]
.text$mn:0000229A                 push    ecx             ; unsigned int
.text$mn:0000229B                 mov     edx, [ebp+arg_8]
.text$mn:0000229E                 push    edx             ; wchar_t *
.text$mn:0000229F                 mov     eax, [ebp+arg_0]
.text$mn:000022A2                 push    eax             ; int
.text$mn:000022A3                 call    ??$_Debug_pointer@VUserCommand@@@std@@YAXPAVUserCommand@@PB_WI@Z ; std::_Debug_pointer<UserCommand>(UserCommand *,wchar_t const *,uint)
.text$mn:000022A8                 add     esp, 0Ch
.text$mn:000022AB                 mov     ecx, [ebp+arg_C]
.text$mn:000022AE                 push    ecx             ; unsigned int
.text$mn:000022AF                 mov     edx, [ebp+arg_8]
.text$mn:000022B2                 push    edx             ; wchar_t *
.text$mn:000022B3                 mov     eax, [ebp+arg_4]
.text$mn:000022B6                 push    eax             ; int
.text$mn:000022B7                 call    ??$_Debug_pointer@VUserCommand@@@std@@YAXPAVUserCommand@@PB_WI@Z ; std::_Debug_pointer<UserCommand>(UserCommand *,wchar_t const *,uint)
.text$mn:000022BC                 add     esp, 0Ch
.text$mn:000022BF                 mov     ecx, [ebp+arg_4]
.text$mn:000022C2                 cmp     ecx, [ebp+arg_0]
.text$mn:000022C5                 jnb     short loc_22DC
.text$mn:000022C7                 mov     edx, [ebp+arg_C]
.text$mn:000022CA                 push    edx             ; unsigned int
.text$mn:000022CB                 mov     eax, [ebp+arg_8]
.text$mn:000022CE                 push    eax             ; wchar_t *
.text$mn:000022CF                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000022D4                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000022D9                 add     esp, 0Ch
.text$mn:000022DC
.text$mn:000022DC loc_22DC:                               ; CODE XREF: std::_Debug_range2<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000022DC                                         ; std::_Debug_range2<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000022DC                 pop     ebp
.text$mn:000022DD                 retn
.text$mn:000022DD ??$_Debug_range2@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000022DD
.text$mn:000022DD ; ---------------------------------------------------------------------------
.text$mn:000022DE                 align 10h
.text$mn:000022DE _text$mn        ends
.text$mn:000022DE
.text$mn:000022E0 ; ===========================================================================
.text$mn:000022E0
.text$mn:000022E0 ; Segment type: Pure code
.text$mn:000022E0 ; Segment permissions: Read/Execute
.text$mn:000022E0 _text$mn        segment para public 'CODE' use32
.text$mn:000022E0                 assume cs:_text$mn
.text$mn:000022E0                 ;org 22E0h
.text$mn:000022E0 ; COMDAT (pick any)
.text$mn:000022E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022E0
.text$mn:000022E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022E0
.text$mn:000022E0 ; Attributes: bp-based frame
.text$mn:000022E0
.text$mn:000022E0 ; int __cdecl std::_Debug_range<UserCommand *>(int, int, wchar_t *, unsigned int)
.text$mn:000022E0                 public ??$_Debug_range@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WI@Z
.text$mn:000022E0 ??$_Debug_range@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WI@Z proc near
.text$mn:000022E0                                         ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:000022E0
.text$mn:000022E0 var_1           = byte ptr -1
.text$mn:000022E0 arg_0           = dword ptr  8
.text$mn:000022E0 arg_4           = dword ptr  0Ch
.text$mn:000022E0 arg_8           = dword ptr  10h
.text$mn:000022E0 arg_C           = dword ptr  14h
.text$mn:000022E0
.text$mn:000022E0                 push    ebp
.text$mn:000022E1                 mov     ebp, esp
.text$mn:000022E3                 push    ecx
.text$mn:000022E4                 lea     eax, [ebp+arg_0]
.text$mn:000022E7                 push    eax
.text$mn:000022E8                 lea     ecx, [ebp+var_1]
.text$mn:000022EB                 push    ecx
.text$mn:000022EC                 call    ??$_Iter_cat@PAVUserCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVUserCommand@@@Z ; std::_Iter_cat<UserCommand *>(UserCommand * const &)
.text$mn:000022F1                 add     esp, 8
.text$mn:000022F4                 mov     dl, [eax]
.text$mn:000022F6                 movzx   eax, dl
.text$mn:000022F9                 push    eax
.text$mn:000022FA                 mov     ecx, [ebp+arg_C]
.text$mn:000022FD                 push    ecx             ; unsigned int
.text$mn:000022FE                 mov     edx, [ebp+arg_8]
.text$mn:00002301                 push    edx             ; wchar_t *
.text$mn:00002302                 mov     eax, [ebp+arg_4]
.text$mn:00002305                 push    eax             ; int
.text$mn:00002306                 mov     ecx, [ebp+arg_0]
.text$mn:00002309                 push    ecx             ; int
.text$mn:0000230A                 call    ??$_Debug_range2@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000230F                 add     esp, 14h
.text$mn:00002312                 mov     esp, ebp
.text$mn:00002314                 pop     ebp
.text$mn:00002315                 retn
.text$mn:00002315 ??$_Debug_range@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WI@Z endp
.text$mn:00002315
.text$mn:00002315 ; ---------------------------------------------------------------------------
.text$mn:00002316                 align 4
.text$mn:00002316 _text$mn        ends
.text$mn:00002316
.text$mn:00002318 ; ===========================================================================
.text$mn:00002318
.text$mn:00002318 ; Segment type: Pure code
.text$mn:00002318 ; Segment permissions: Read/Execute
.text$mn:00002318 _text$mn        segment para public 'CODE' use32
.text$mn:00002318                 assume cs:_text$mn
.text$mn:00002318                 ;org 2318h
.text$mn:00002318 ; COMDAT (pick any)
.text$mn:00002318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002318
.text$mn:00002318 ; =============== S U B R O U T I N E =======================================
.text$mn:00002318
.text$mn:00002318 ; Attributes: bp-based frame
.text$mn:00002318
.text$mn:00002318 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class UserCommand>>>(class UserCommand *, class UserCommand *, struct std::_Wrap_alloc<class std::allocator<class UserCommand>> &)
.text$mn:00002318                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z
.text$mn:00002318 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z proc near
.text$mn:00002318                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Destroy(UserCommand *,UserCommand *)+21p
.text$mn:00002318
.text$mn:00002318 var_1           = byte ptr -1
.text$mn:00002318 arg_0           = dword ptr  8
.text$mn:00002318 arg_4           = dword ptr  0Ch
.text$mn:00002318 arg_8           = dword ptr  10h
.text$mn:00002318
.text$mn:00002318                 push    ebp
.text$mn:00002319                 mov     ebp, esp
.text$mn:0000231B                 push    ecx
.text$mn:0000231C                 mov     eax, [ebp+arg_4]
.text$mn:0000231F                 push    eax
.text$mn:00002320                 mov     ecx, [ebp+arg_0]
.text$mn:00002323                 push    ecx
.text$mn:00002324                 call    ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z ; std::_Ptr_cat<UserCommand,UserCommand>(UserCommand *,UserCommand *)
.text$mn:00002329                 add     esp, 8
.text$mn:0000232C                 mov     [ebp+var_1], al
.text$mn:0000232F                 movzx   edx, [ebp+var_1]
.text$mn:00002333                 push    edx
.text$mn:00002334                 mov     eax, [ebp+arg_8]
.text$mn:00002337                 push    eax
.text$mn:00002338                 mov     ecx, [ebp+arg_4]
.text$mn:0000233B                 push    ecx
.text$mn:0000233C                 mov     edx, [ebp+arg_0]
.text$mn:0000233F                 push    edx
.text$mn:00002340                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002345                 add     esp, 10h
.text$mn:00002348                 mov     esp, ebp
.text$mn:0000234A                 pop     ebp
.text$mn:0000234B                 retn
.text$mn:0000234B ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z endp
.text$mn:0000234B
.text$mn:0000234B _text$mn        ends
.text$mn:0000234B
.text$mn:0000234C ; ===========================================================================
.text$mn:0000234C
.text$mn:0000234C ; Segment type: Pure code
.text$mn:0000234C ; Segment permissions: Read/Execute
.text$mn:0000234C _text$mn        segment para public 'CODE' use32
.text$mn:0000234C                 assume cs:_text$mn
.text$mn:0000234C                 ;org 234Ch
.text$mn:0000234C ; COMDAT (pick any)
.text$mn:0000234C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000234C
.text$mn:0000234C ; =============== S U B R O U T I N E =======================================
.text$mn:0000234C
.text$mn:0000234C ; Attributes: bp-based frame
.text$mn:0000234C
.text$mn:0000234C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class UserCommand>>>(class UserCommand *, class UserCommand *, struct std::_Wrap_alloc<class std::allocator<class UserCommand>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000234C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000234C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:0000234C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+28p
.text$mn:0000234C
.text$mn:0000234C arg_0           = dword ptr  8
.text$mn:0000234C arg_4           = dword ptr  0Ch
.text$mn:0000234C arg_8           = dword ptr  10h
.text$mn:0000234C
.text$mn:0000234C                 push    ebp
.text$mn:0000234D                 mov     ebp, esp
.text$mn:0000234F                 jmp     short loc_235C
.text$mn:00002351 ; ---------------------------------------------------------------------------
.text$mn:00002351
.text$mn:00002351 loc_2351:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+24j
.text$mn:00002351                 mov     eax, [ebp+arg_0]
.text$mn:00002354                 add     eax, 148h
.text$mn:00002359                 mov     [ebp+arg_0], eax
.text$mn:0000235C
.text$mn:0000235C loc_235C:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000235C                 mov     ecx, [ebp+arg_0]
.text$mn:0000235F                 cmp     ecx, [ebp+arg_4]
.text$mn:00002362                 jz      short loc_2372
.text$mn:00002364                 mov     edx, [ebp+arg_0]
.text$mn:00002367                 push    edx
.text$mn:00002368                 mov     ecx, [ebp+arg_8]
.text$mn:0000236B                 call    ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::destroy<UserCommand>(UserCommand *)
.text$mn:00002370                 jmp     short loc_2351
.text$mn:00002372 ; ---------------------------------------------------------------------------
.text$mn:00002372
.text$mn:00002372 loc_2372:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+16j
.text$mn:00002372                 pop     ebp
.text$mn:00002373                 retn
.text$mn:00002373 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002373
.text$mn:00002373 _text$mn        ends
.text$mn:00002373
.text$mn:00002374 ; ===========================================================================
.text$mn:00002374
.text$mn:00002374 ; Segment type: Pure code
.text$mn:00002374 ; Segment permissions: Read/Execute
.text$mn:00002374 _text$mn        segment para public 'CODE' use32
.text$mn:00002374                 assume cs:_text$mn
.text$mn:00002374                 ;org 2374h
.text$mn:00002374 ; COMDAT (pick any)
.text$mn:00002374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002374
.text$mn:00002374 ; =============== S U B R O U T I N E =======================================
.text$mn:00002374
.text$mn:00002374 ; Attributes: bp-based frame
.text$mn:00002374
.text$mn:00002374 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class UserCommand *>(class UserCommand * const &)
.text$mn:00002374                 public ??$_Iter_cat@PAVUserCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVUserCommand@@@Z
.text$mn:00002374 ??$_Iter_cat@PAVUserCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVUserCommand@@@Z proc near
.text$mn:00002374                                         ; CODE XREF: std::_Debug_range<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint)+Cp
.text$mn:00002374
.text$mn:00002374 var_1           = byte ptr -1
.text$mn:00002374 arg_0           = dword ptr  8
.text$mn:00002374
.text$mn:00002374                 push    ebp
.text$mn:00002375                 mov     ebp, esp
.text$mn:00002377                 push    ecx
.text$mn:00002378                 mov     eax, [ebp+arg_0]
.text$mn:0000237B                 mov     cl, [ebp+var_1]
.text$mn:0000237E                 mov     [eax], cl
.text$mn:00002380                 mov     eax, [ebp+arg_0]
.text$mn:00002383                 mov     esp, ebp
.text$mn:00002385                 pop     ebp
.text$mn:00002386                 retn
.text$mn:00002386 ??$_Iter_cat@PAVUserCommand@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVUserCommand@@@Z endp
.text$mn:00002386
.text$mn:00002386 ; ---------------------------------------------------------------------------
.text$mn:00002387                 align 4
.text$mn:00002387 _text$mn        ends
.text$mn:00002387
.text$mn:00002388 ; ===========================================================================
.text$mn:00002388
.text$mn:00002388 ; Segment type: Pure code
.text$mn:00002388 ; Segment permissions: Read/Execute
.text$mn:00002388 _text$mn        segment para public 'CODE' use32
.text$mn:00002388                 assume cs:_text$mn
.text$mn:00002388                 ;org 2388h
.text$mn:00002388 ; COMDAT (pick any)
.text$mn:00002388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002388
.text$mn:00002388 ; =============== S U B R O U T I N E =======================================
.text$mn:00002388
.text$mn:00002388 ; Attributes: bp-based frame
.text$mn:00002388
.text$mn:00002388 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class UserCommand, class UserCommand>(class UserCommand *, class UserCommand *)
.text$mn:00002388                 public ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z
.text$mn:00002388 ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z proc near
.text$mn:00002388                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+Cp
.text$mn:00002388                                         ; std::_Uninit_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+Cp
.text$mn:00002388
.text$mn:00002388 var_1           = byte ptr -1
.text$mn:00002388
.text$mn:00002388                 push    ebp
.text$mn:00002389                 mov     ebp, esp
.text$mn:0000238B                 push    ecx
.text$mn:0000238C                 mov     al, [ebp+var_1]
.text$mn:0000238F                 mov     esp, ebp
.text$mn:00002391                 pop     ebp
.text$mn:00002392                 retn
.text$mn:00002392 ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z endp
.text$mn:00002392
.text$mn:00002392 ; ---------------------------------------------------------------------------
.text$mn:00002393                 align 4
.text$mn:00002393 _text$mn        ends
.text$mn:00002393
.text$mn:00002394 ; ===========================================================================
.text$mn:00002394
.text$mn:00002394 ; Segment type: Pure code
.text$mn:00002394 ; Segment permissions: Read/Execute
.text$mn:00002394 _text$mn        segment para public 'CODE' use32
.text$mn:00002394                 assume cs:_text$mn
.text$mn:00002394                 ;org 2394h
.text$mn:00002394 ; COMDAT (pick any)
.text$mn:00002394                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002394
.text$mn:00002394 ; =============== S U B R O U T I N E =======================================
.text$mn:00002394
.text$mn:00002394 ; Attributes: bp-based frame
.text$mn:00002394
.text$mn:00002394 ; class UserCommand * & __cdecl std::_Rechecked<class UserCommand *, class UserCommand *>(class UserCommand * &, class UserCommand *)
.text$mn:00002394                 public ??$_Rechecked@PAVUserCommand@@PAV1@@std@@YAAAPAVUserCommand@@AAPAV1@PAV1@@Z
.text$mn:00002394 ??$_Rechecked@PAVUserCommand@@PAV1@@std@@YAAAPAVUserCommand@@AAPAV1@PAV1@@Z proc near
.text$mn:00002394                                         ; CODE XREF: std::_Uninitialized_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+3Bp
.text$mn:00002394
.text$mn:00002394 arg_0           = dword ptr  8
.text$mn:00002394 arg_4           = dword ptr  0Ch
.text$mn:00002394
.text$mn:00002394                 push    ebp
.text$mn:00002395                 mov     ebp, esp
.text$mn:00002397                 mov     eax, [ebp+arg_0]
.text$mn:0000239A                 mov     ecx, [ebp+arg_4]
.text$mn:0000239D                 mov     [eax], ecx
.text$mn:0000239F                 mov     eax, [ebp+arg_0]
.text$mn:000023A2                 pop     ebp
.text$mn:000023A3                 retn
.text$mn:000023A3 ??$_Rechecked@PAVUserCommand@@PAV1@@std@@YAAAPAVUserCommand@@AAPAV1@PAV1@@Z endp
.text$mn:000023A3
.text$mn:000023A3 _text$mn        ends
.text$mn:000023A3
.text$mn:000023A4 ; ===========================================================================
.text$mn:000023A4
.text$mn:000023A4 ; Segment type: Pure code
.text$mn:000023A4 ; Segment permissions: Read/Execute
.text$mn:000023A4 _text$mn        segment para public 'CODE' use32
.text$mn:000023A4                 assume cs:_text$mn
.text$mn:000023A4                 ;org 23A4h
.text$mn:000023A4 ; COMDAT (pick any)
.text$mn:000023A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023A4
.text$mn:000023A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000023A4
.text$mn:000023A4 ; Attributes: bp-based frame
.text$mn:000023A4
.text$mn:000023A4 ; protected: class UserCommand * __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Umove<class UserCommand *>(class UserCommand *, class UserCommand *, class UserCommand *)
.text$mn:000023A4                 public ??$_Umove@PAVUserCommand@@@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEPAVUserCommand@@PAV2@00@Z
.text$mn:000023A4 ??$_Umove@PAVUserCommand@@@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEPAVUserCommand@@PAV2@00@Z proc near
.text$mn:000023A4                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+65p
.text$mn:000023A4
.text$mn:000023A4 var_8           = dword ptr -8
.text$mn:000023A4 var_1           = byte ptr -1
.text$mn:000023A4 arg_0           = dword ptr  8
.text$mn:000023A4 arg_4           = dword ptr  0Ch
.text$mn:000023A4 arg_8           = dword ptr  10h
.text$mn:000023A4
.text$mn:000023A4                 push    ebp
.text$mn:000023A5                 mov     ebp, esp
.text$mn:000023A7                 sub     esp, 8
.text$mn:000023AA                 mov     [ebp+var_8], ecx
.text$mn:000023AD                 lea     eax, [ebp+var_1]
.text$mn:000023B0                 push    eax
.text$mn:000023B1                 mov     ecx, [ebp+var_8]
.text$mn:000023B4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:000023B9                 lea     ecx, [ebp+var_1]
.text$mn:000023BC                 push    ecx
.text$mn:000023BD                 mov     edx, [ebp+arg_8]
.text$mn:000023C0                 push    edx
.text$mn:000023C1                 mov     eax, [ebp+arg_4]
.text$mn:000023C4                 push    eax
.text$mn:000023C5                 mov     ecx, [ebp+arg_0]
.text$mn:000023C8                 push    ecx
.text$mn:000023C9                 call    ??$_Uninitialized_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z ; std::_Uninitialized_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)
.text$mn:000023CE                 add     esp, 10h
.text$mn:000023D1                 mov     esp, ebp
.text$mn:000023D3                 pop     ebp
.text$mn:000023D4                 retn    0Ch
.text$mn:000023D4 ??$_Umove@PAVUserCommand@@@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEPAVUserCommand@@PAV2@00@Z endp
.text$mn:000023D4
.text$mn:000023D4 ; ---------------------------------------------------------------------------
.text$mn:000023D7                 align 4
.text$mn:000023D7 _text$mn        ends
.text$mn:000023D7
.text$mn:000023D8 ; ===========================================================================
.text$mn:000023D8
.text$mn:000023D8 ; Segment type: Pure code
.text$mn:000023D8 ; Segment permissions: Read/Execute
.text$mn:000023D8 _text$mn        segment para public 'CODE' use32
.text$mn:000023D8                 assume cs:_text$mn
.text$mn:000023D8                 ;org 23D8h
.text$mn:000023D8 ; COMDAT (pick any)
.text$mn:000023D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023D8
.text$mn:000023D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D8
.text$mn:000023D8 ; Attributes: bp-based frame
.text$mn:000023D8
.text$mn:000023D8 ; class UserCommand * __cdecl std::_Unchecked<class UserCommand *>(class UserCommand *)
.text$mn:000023D8                 public ??$_Unchecked@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z
.text$mn:000023D8 ??$_Unchecked@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z proc near
.text$mn:000023D8                                         ; CODE XREF: std::_Uninitialized_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+Bp
.text$mn:000023D8                                         ; std::_Uninitialized_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+18p ...
.text$mn:000023D8
.text$mn:000023D8 arg_0           = dword ptr  8
.text$mn:000023D8
.text$mn:000023D8                 push    ebp
.text$mn:000023D9                 mov     ebp, esp
.text$mn:000023DB                 mov     eax, [ebp+arg_0]
.text$mn:000023DE                 pop     ebp
.text$mn:000023DF                 retn
.text$mn:000023DF ??$_Unchecked@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z endp
.text$mn:000023DF
.text$mn:000023DF _text$mn        ends
.text$mn:000023DF
.text$mn:000023E0 ; ===========================================================================
.text$mn:000023E0
.text$mn:000023E0 ; Segment type: Pure code
.text$mn:000023E0 ; Segment permissions: Read/Execute
.text$mn:000023E0 _text$mn        segment para public 'CODE' use32
.text$mn:000023E0                 assume cs:_text$mn
.text$mn:000023E0                 ;org 23E0h
.text$mn:000023E0 ; COMDAT (pick any)
.text$mn:000023E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023E0
.text$mn:000023E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023E0
.text$mn:000023E0 ; Attributes: bp-based frame
.text$mn:000023E0
.text$mn:000023E0 ; int __cdecl std::_Uninit_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(int, int, void *, int)
.text$mn:000023E0                 public ??$_Uninit_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z
.text$mn:000023E0 ??$_Uninit_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z proc near
.text$mn:000023E0                                         ; CODE XREF: std::_Uninitialized_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+2Ep
.text$mn:000023E0
.text$mn:000023E0 var_1           = byte ptr -1
.text$mn:000023E0 arg_0           = dword ptr  8
.text$mn:000023E0 arg_4           = dword ptr  0Ch
.text$mn:000023E0 arg_8           = dword ptr  10h
.text$mn:000023E0 arg_C           = dword ptr  14h
.text$mn:000023E0
.text$mn:000023E0                 push    ebp
.text$mn:000023E1                 mov     ebp, esp
.text$mn:000023E3                 push    ecx
.text$mn:000023E4                 mov     eax, [ebp+arg_8]
.text$mn:000023E7                 push    eax
.text$mn:000023E8                 mov     ecx, [ebp+arg_0]
.text$mn:000023EB                 push    ecx
.text$mn:000023EC                 call    ??$_Ptr_cat@VUserCommand@@V1@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAVUserCommand@@0@Z ; std::_Ptr_cat<UserCommand,UserCommand>(UserCommand *,UserCommand *)
.text$mn:000023F1                 add     esp, 8
.text$mn:000023F4                 mov     [ebp+var_1], al
.text$mn:000023F7                 movzx   edx, [ebp+var_1]
.text$mn:000023FB                 push    edx
.text$mn:000023FC                 mov     eax, [ebp+arg_0]
.text$mn:000023FF                 push    eax
.text$mn:00002400                 call    ??$_Val_type@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z ; std::_Val_type<UserCommand *>(UserCommand *)
.text$mn:00002405                 add     esp, 4
.text$mn:00002408                 push    eax
.text$mn:00002409                 mov     ecx, [ebp+arg_C]
.text$mn:0000240C                 push    ecx             ; int
.text$mn:0000240D                 mov     edx, [ebp+arg_8]
.text$mn:00002410                 push    edx             ; void *
.text$mn:00002411                 mov     eax, [ebp+arg_4]
.text$mn:00002414                 push    eax             ; int
.text$mn:00002415                 mov     ecx, [ebp+arg_0]
.text$mn:00002418                 push    ecx             ; int
.text$mn:00002419                 call    ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000241E                 add     esp, 18h
.text$mn:00002421                 mov     esp, ebp
.text$mn:00002423                 pop     ebp
.text$mn:00002424                 retn
.text$mn:00002424 ??$_Uninit_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z endp
.text$mn:00002424
.text$mn:00002424 ; ---------------------------------------------------------------------------
.text$mn:00002425                 align 4
.text$mn:00002425 _text$mn        ends
.text$mn:00002425
.text$mn:00002428 ; ===========================================================================
.text$mn:00002428
.text$mn:00002428 ; Segment type: Pure code
.text$mn:00002428 ; Segment permissions: Read/Execute
.text$mn:00002428 _text$mn        segment para public 'CODE' use32
.text$mn:00002428                 assume cs:_text$mn
.text$mn:00002428                 ;org 2428h
.text$mn:00002428 ; COMDAT (pick any)
.text$mn:00002428                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002428
.text$mn:00002428 ; =============== S U B R O U T I N E =======================================
.text$mn:00002428
.text$mn:00002428 ; Attributes: bp-based frame
.text$mn:00002428
.text$mn:00002428 ; int __cdecl std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(int, int, void *, int)
.text$mn:00002428                 public ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002428 ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002428                                         ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+39p
.text$mn:00002428
.text$mn:00002428 var_14          = dword ptr -14h
.text$mn:00002428 var_10          = dword ptr -10h
.text$mn:00002428 var_C           = dword ptr -0Ch
.text$mn:00002428 var_4           = dword ptr -4
.text$mn:00002428 arg_0           = dword ptr  8
.text$mn:00002428 arg_4           = dword ptr  0Ch
.text$mn:00002428 arg_8           = dword ptr  10h
.text$mn:00002428 arg_C           = dword ptr  14h
.text$mn:00002428
.text$mn:00002428 ; FUNCTION CHUNK AT .text$mn:000024F7 SIZE 00000009 BYTES
.text$mn:00002428 ; FUNCTION CHUNK AT .text$mn:00002507 SIZE 00000015 BYTES
.text$mn:00002428
.text$mn:00002428                 push    ebp
.text$mn:00002429                 mov     ebp, esp
.text$mn:0000242B                 push    0FFFFFFFFh
.text$mn:0000242D                 push    offset __ehhandler$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002432                 mov     eax, large fs:0
.text$mn:00002438                 push    eax
.text$mn:00002439                 push    ecx
.text$mn:0000243A                 push    ecx
.text$mn:0000243B                 push    ebx
.text$mn:0000243C                 push    esi
.text$mn:0000243D                 push    edi
.text$mn:0000243E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002443                 xor     eax, ebp
.text$mn:00002445                 push    eax
.text$mn:00002446                 lea     eax, [ebp+var_C]
.text$mn:00002449                 mov     large fs:0, eax
.text$mn:0000244F                 mov     [ebp+var_10], esp
.text$mn:00002452                 push    1B6h            ; unsigned int
.text$mn:00002457                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000245C                 mov     eax, [ebp+arg_4]
.text$mn:0000245F                 push    eax             ; int
.text$mn:00002460                 mov     ecx, [ebp+arg_0]
.text$mn:00002463                 push    ecx             ; int
.text$mn:00002464                 call    ??$_Debug_range@PAVUserCommand@@@std@@YAXPAVUserCommand@@0PB_WI@Z ; std::_Debug_range<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint)
.text$mn:00002469                 add     esp, 10h
.text$mn:0000246C                 push    1B7h            ; unsigned int
.text$mn:00002471                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002476                 mov     edx, [ebp+arg_8]
.text$mn:00002479                 push    edx             ; int
.text$mn:0000247A                 call    ??$_Debug_pointer@VUserCommand@@@std@@YAXPAVUserCommand@@PB_WI@Z ; std::_Debug_pointer<UserCommand>(UserCommand *,wchar_t const *,uint)
.text$mn:0000247F                 add     esp, 0Ch
.text$mn:00002482                 mov     eax, [ebp+arg_8]
.text$mn:00002485                 mov     [ebp+var_14], eax
.text$mn:00002488                 mov     [ebp+var_4], 0
.text$mn:0000248F                 jmp     short loc_24A9
.text$mn:00002491 ; ---------------------------------------------------------------------------
.text$mn:00002491
.text$mn:00002491 loc_2491:                               ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+99j
.text$mn:00002491                 mov     ecx, [ebp+arg_8]
.text$mn:00002494                 add     ecx, 148h
.text$mn:0000249A                 mov     [ebp+arg_8], ecx
.text$mn:0000249D                 mov     edx, [ebp+arg_0]
.text$mn:000024A0                 add     edx, 148h
.text$mn:000024A6                 mov     [ebp+arg_0], edx
.text$mn:000024A9
.text$mn:000024A9 loc_24A9:                               ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:000024A9                 mov     eax, [ebp+arg_0]
.text$mn:000024AC                 cmp     eax, [ebp+arg_4]
.text$mn:000024AF                 jz      short loc_24C3
.text$mn:000024B1                 mov     ecx, [ebp+arg_0]
.text$mn:000024B4                 push    ecx             ; int
.text$mn:000024B5                 mov     edx, [ebp+arg_8]
.text$mn:000024B8                 push    edx             ; void *
.text$mn:000024B9                 mov     ecx, [ebp+arg_C]
.text$mn:000024BC                 call    ??$construct@VUserCommand@@V1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)
.text$mn:000024C1                 jmp     short loc_2491
.text$mn:000024C3 ; ---------------------------------------------------------------------------
.text$mn:000024C3
.text$mn:000024C3 loc_24C3:                               ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+87j
.text$mn:000024C3                 jmp     short loc_24F7
.text$mn:000024C3 ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000024C3
.text$mn:000024C5
.text$mn:000024C5 ; =============== S U B R O U T I N E =======================================
.text$mn:000024C5
.text$mn:000024C5 ; Attributes: noreturn
.text$mn:000024C5
.text$mn:000024C5 __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:000024C5                                         ; DATA XREF: .xdata$x:00008DE8o
.text$mn:000024C5                 jmp     short loc_24D2
.text$mn:000024C7 ; ---------------------------------------------------------------------------
.text$mn:000024C7
.text$mn:000024C7 loc_24C7:                               ; CODE XREF: __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+21j
.text$mn:000024C7                 mov     eax, [ebp-14h]
.text$mn:000024CA                 add     eax, 148h
.text$mn:000024CF                 mov     [ebp-14h], eax
.text$mn:000024D2
.text$mn:000024D2 loc_24D2:                               ; CODE XREF: __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:000024D2                 mov     ecx, [ebp-14h]
.text$mn:000024D5                 cmp     ecx, [ebp+10h]
.text$mn:000024D8                 jz      short loc_24E8
.text$mn:000024DA                 mov     edx, [ebp-14h]
.text$mn:000024DD                 push    edx
.text$mn:000024DE                 mov     ecx, [ebp+14h]
.text$mn:000024E1                 call    ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::destroy<UserCommand>(UserCommand *)
.text$mn:000024E6                 jmp     short loc_24C7
.text$mn:000024E8 ; ---------------------------------------------------------------------------
.text$mn:000024E8
.text$mn:000024E8 loc_24E8:                               ; CODE XREF: __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+13j
.text$mn:000024E8                 push    0
.text$mn:000024EA                 push    0
.text$mn:000024EC                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000024EC __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000024EC
.text$mn:000024F1 ; ---------------------------------------------------------------------------
.text$mn:000024F1                 mov     eax, offset $LN13
.text$mn:000024F6                 retn
.text$mn:000024F7 ; ---------------------------------------------------------------------------
.text$mn:000024F7 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000024F7
.text$mn:000024F7 loc_24F7:                               ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag):loc_24C3j
.text$mn:000024F7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000024FE                 jmp     short loc_2507
.text$mn:000024FE ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002500
.text$mn:00002500 ; =============== S U B R O U T I N E =======================================
.text$mn:00002500
.text$mn:00002500
.text$mn:00002500 $LN13           proc near               ; DATA XREF: .text$mn:000024F1o
.text$mn:00002500                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00002500 $LN13           endp ; sp-analysis failed
.text$mn:00002500
.text$mn:00002507 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002507
.text$mn:00002507 loc_2507:                               ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+D6j
.text$mn:00002507                 mov     eax, [ebp+arg_8]
.text$mn:0000250A                 mov     ecx, [ebp+var_C]
.text$mn:0000250D                 mov     large fs:0, ecx
.text$mn:00002514                 pop     ecx
.text$mn:00002515                 pop     edi
.text$mn:00002516                 pop     esi
.text$mn:00002517                 pop     ebx
.text$mn:00002518                 mov     esp, ebp
.text$mn:0000251A                 pop     ebp
.text$mn:0000251B                 retn
.text$mn:0000251B ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000251B _text$mn        ends
.text$mn:0000251B
.text$x:0000251C ; ===========================================================================
.text$x:0000251C
.text$x:0000251C ; Segment type: Pure code
.text$x:0000251C ; Segment permissions: Read/Execute
.text$x:0000251C _text$x         segment para public 'CODE' use32
.text$x:0000251C                 assume cs:_text$x
.text$x:0000251C                 ;org 251Ch
.text$x:0000251C ; COMDAT (pick associative to section at 2428)
.text$x:0000251C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000251C
.text$x:0000251C ; =============== S U B R O U T I N E =======================================
.text$x:0000251C
.text$x:0000251C
.text$x:0000251C __ehhandler$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:0000251C                                         ; DATA XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:0000251C
.text$x:0000251C arg_4           = dword ptr  8
.text$x:0000251C
.text$x:0000251C                 mov     edx, [esp+arg_4]
.text$x:00002520                 lea     eax, [edx+0Ch]
.text$x:00002523                 mov     ecx, [edx-18h]
.text$x:00002526                 xor     ecx, eax
.text$x:00002528                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000252D                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:00002532                 jmp     ___CxxFrameHandler3
.text$x:00002532 __ehhandler$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:00002532
.text$x:00002532 ; ---------------------------------------------------------------------------
.text$x:00002537                 align 4
.text$x:00002537 _text$x         ends
.text$x:00002537
.text$mn:00002538 ; ===========================================================================
.text$mn:00002538
.text$mn:00002538 ; Segment type: Pure code
.text$mn:00002538 ; Segment permissions: Read/Execute
.text$mn:00002538 _text$mn        segment para public 'CODE' use32
.text$mn:00002538                 assume cs:_text$mn
.text$mn:00002538                 ;org 2538h
.text$mn:00002538 ; COMDAT (pick any)
.text$mn:00002538                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002538
.text$mn:00002538 ; =============== S U B R O U T I N E =======================================
.text$mn:00002538
.text$mn:00002538 ; Attributes: bp-based frame
.text$mn:00002538
.text$mn:00002538 ; class UserCommand * __cdecl std::_Uninitialized_move<class UserCommand *, class UserCommand *, struct std::_Wrap_alloc<class std::allocator<class UserCommand>>>(class UserCommand *, class UserCommand *, class UserCommand *, struct std::_Wrap_alloc<class std::allocator<class UserCommand>> &)
.text$mn:00002538                 public ??$_Uninitialized_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z
.text$mn:00002538 ??$_Uninitialized_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z proc near
.text$mn:00002538                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Umove<UserCommand *>(UserCommand *,UserCommand *,UserCommand *)+25p
.text$mn:00002538
.text$mn:00002538 arg_0           = dword ptr  8
.text$mn:00002538 arg_4           = dword ptr  0Ch
.text$mn:00002538 arg_8           = dword ptr  10h
.text$mn:00002538 arg_C           = dword ptr  14h
.text$mn:00002538
.text$mn:00002538                 push    ebp
.text$mn:00002539                 mov     ebp, esp
.text$mn:0000253B                 mov     eax, [ebp+arg_C]
.text$mn:0000253E                 push    eax             ; int
.text$mn:0000253F                 mov     ecx, [ebp+arg_8]
.text$mn:00002542                 push    ecx
.text$mn:00002543                 call    ??$_Unchecked@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z ; std::_Unchecked<UserCommand *>(UserCommand *)
.text$mn:00002548                 add     esp, 4
.text$mn:0000254B                 push    eax             ; void *
.text$mn:0000254C                 mov     edx, [ebp+arg_4]
.text$mn:0000254F                 push    edx
.text$mn:00002550                 call    ??$_Unchecked@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z ; std::_Unchecked<UserCommand *>(UserCommand *)
.text$mn:00002555                 add     esp, 4
.text$mn:00002558                 push    eax             ; int
.text$mn:00002559                 mov     eax, [ebp+arg_0]
.text$mn:0000255C                 push    eax
.text$mn:0000255D                 call    ??$_Unchecked@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z ; std::_Unchecked<UserCommand *>(UserCommand *)
.text$mn:00002562                 add     esp, 4
.text$mn:00002565                 push    eax             ; int
.text$mn:00002566                 call    ??$_Uninit_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z ; std::_Uninit_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)
.text$mn:0000256B                 add     esp, 10h
.text$mn:0000256E                 push    eax
.text$mn:0000256F                 lea     ecx, [ebp+arg_8]
.text$mn:00002572                 push    ecx
.text$mn:00002573                 call    ??$_Rechecked@PAVUserCommand@@PAV1@@std@@YAAAPAVUserCommand@@AAPAV1@PAV1@@Z ; std::_Rechecked<UserCommand *,UserCommand *>(UserCommand * &,UserCommand *)
.text$mn:00002578                 add     esp, 8
.text$mn:0000257B                 mov     eax, [eax]
.text$mn:0000257D                 pop     ebp
.text$mn:0000257E                 retn
.text$mn:0000257E ??$_Uninitialized_move@PAVUserCommand@@PAV1@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z endp
.text$mn:0000257E
.text$mn:0000257E ; ---------------------------------------------------------------------------
.text$mn:0000257F                 align 10h
.text$mn:0000257F _text$mn        ends
.text$mn:0000257F
.text$mn:00002580 ; ===========================================================================
.text$mn:00002580
.text$mn:00002580 ; Segment type: Pure code
.text$mn:00002580 ; Segment permissions: Read/Execute
.text$mn:00002580 _text$mn        segment para public 'CODE' use32
.text$mn:00002580                 assume cs:_text$mn
.text$mn:00002580                 ;org 2580h
.text$mn:00002580 ; COMDAT (pick any)
.text$mn:00002580                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002580
.text$mn:00002580 ; =============== S U B R O U T I N E =======================================
.text$mn:00002580
.text$mn:00002580 ; Attributes: bp-based frame
.text$mn:00002580
.text$mn:00002580 ; class UserCommand * __cdecl std::_Val_type<class UserCommand *>(class UserCommand *)
.text$mn:00002580                 public ??$_Val_type@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z
.text$mn:00002580 ??$_Val_type@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z proc near
.text$mn:00002580                                         ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)+20p
.text$mn:00002580                 push    ebp
.text$mn:00002581                 mov     ebp, esp
.text$mn:00002583                 xor     eax, eax
.text$mn:00002585                 pop     ebp
.text$mn:00002586                 retn
.text$mn:00002586 ??$_Val_type@PAVUserCommand@@@std@@YAPAVUserCommand@@PAV1@@Z endp
.text$mn:00002586
.text$mn:00002586 ; ---------------------------------------------------------------------------
.text$mn:00002587                 align 4
.text$mn:00002587 _text$mn        ends
.text$mn:00002587
.text$mn:00002588 ; ===========================================================================
.text$mn:00002588
.text$mn:00002588 ; Segment type: Pure code
.text$mn:00002588 ; Segment permissions: Read/Execute
.text$mn:00002588 _text$mn        segment para public 'CODE' use32
.text$mn:00002588                 assume cs:_text$mn
.text$mn:00002588                 ;org 2588h
.text$mn:00002588 ; COMDAT (pick any)
.text$mn:00002588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002588
.text$mn:00002588 ; =============== S U B R O U T I N E =======================================
.text$mn:00002588
.text$mn:00002588 ; Attributes: bp-based frame
.text$mn:00002588
.text$mn:00002588 ; class UserCommand const * __cdecl std::addressof<class UserCommand const>(class UserCommand const &)
.text$mn:00002588                 public ??$addressof@$$CBVUserCommand@@@std@@YAPBVUserCommand@@ABV1@@Z
.text$mn:00002588 ??$addressof@$$CBVUserCommand@@@std@@YAPBVUserCommand@@ABV1@@Z proc near
.text$mn:00002588                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+Dp
.text$mn:00002588                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+2Dp
.text$mn:00002588
.text$mn:00002588 arg_0           = dword ptr  8
.text$mn:00002588
.text$mn:00002588                 push    ebp
.text$mn:00002589                 mov     ebp, esp
.text$mn:0000258B                 mov     eax, [ebp+arg_0]
.text$mn:0000258E                 pop     ebp
.text$mn:0000258F                 retn
.text$mn:0000258F ??$addressof@$$CBVUserCommand@@@std@@YAPBVUserCommand@@ABV1@@Z endp
.text$mn:0000258F
.text$mn:0000258F _text$mn        ends
.text$mn:0000258F
.text$mn:00002590 ; ===========================================================================
.text$mn:00002590
.text$mn:00002590 ; Segment type: Pure code
.text$mn:00002590 ; Segment permissions: Read/Execute
.text$mn:00002590 _text$mn        segment para public 'CODE' use32
.text$mn:00002590                 assume cs:_text$mn
.text$mn:00002590                 ;org 2590h
.text$mn:00002590 ; COMDAT (pick any)
.text$mn:00002590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002590
.text$mn:00002590 ; =============== S U B R O U T I N E =======================================
.text$mn:00002590
.text$mn:00002590 ; Attributes: bp-based frame
.text$mn:00002590
.text$mn:00002590 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00002590                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00002590 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00002590                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00002590                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00002590
.text$mn:00002590 arg_0           = dword ptr  8
.text$mn:00002590
.text$mn:00002590                 push    ebp
.text$mn:00002591                 mov     ebp, esp
.text$mn:00002593                 mov     eax, [ebp+arg_0]
.text$mn:00002596                 pop     ebp
.text$mn:00002597                 retn
.text$mn:00002597 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00002597
.text$mn:00002597 _text$mn        ends
.text$mn:00002597
.text$mn:00002598 ; ===========================================================================
.text$mn:00002598
.text$mn:00002598 ; Segment type: Pure code
.text$mn:00002598 ; Segment permissions: Read/Execute
.text$mn:00002598 _text$mn        segment para public 'CODE' use32
.text$mn:00002598                 assume cs:_text$mn
.text$mn:00002598                 ;org 2598h
.text$mn:00002598 ; COMDAT (pick any)
.text$mn:00002598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002598
.text$mn:00002598 ; =============== S U B R O U T I N E =======================================
.text$mn:00002598
.text$mn:00002598 ; Attributes: bp-based frame
.text$mn:00002598
.text$mn:00002598 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00002598                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00002598 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00002598                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00002598                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00002598
.text$mn:00002598 arg_0           = dword ptr  8
.text$mn:00002598
.text$mn:00002598                 push    ebp
.text$mn:00002599                 mov     ebp, esp
.text$mn:0000259B                 mov     eax, [ebp+arg_0]
.text$mn:0000259E                 pop     ebp
.text$mn:0000259F                 retn
.text$mn:0000259F ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:0000259F
.text$mn:0000259F _text$mn        ends
.text$mn:0000259F
.text$mn:000025A0 ; ===========================================================================
.text$mn:000025A0
.text$mn:000025A0 ; Segment type: Pure code
.text$mn:000025A0 ; Segment permissions: Read/Execute
.text$mn:000025A0 _text$mn        segment para public 'CODE' use32
.text$mn:000025A0                 assume cs:_text$mn
.text$mn:000025A0                 ;org 25A0h
.text$mn:000025A0 ; COMDAT (pick any)
.text$mn:000025A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025A0
.text$mn:000025A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A0
.text$mn:000025A0 ; Attributes: bp-based frame
.text$mn:000025A0
.text$mn:000025A0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign<class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>>(class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:000025A0                 public ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:000025A0 ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$mn:000025A0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+CBp
.text$mn:000025A0
.text$mn:000025A0 var_70          = byte ptr -70h
.text$mn:000025A0 var_64          = byte ptr -64h
.text$mn:000025A0 var_58          = dword ptr -58h
.text$mn:000025A0 var_54          = dword ptr -54h
.text$mn:000025A0 var_50          = dword ptr -50h
.text$mn:000025A0 var_4C          = dword ptr -4Ch
.text$mn:000025A0 var_48          = dword ptr -48h
.text$mn:000025A0 var_44          = dword ptr -44h
.text$mn:000025A0 var_40          = dword ptr -40h
.text$mn:000025A0 var_3C          = dword ptr -3Ch
.text$mn:000025A0 var_38          = dword ptr -38h
.text$mn:000025A0 var_34          = dword ptr -34h
.text$mn:000025A0 var_30          = dword ptr -30h
.text$mn:000025A0 var_2C          = dword ptr -2Ch
.text$mn:000025A0 var_28          = dword ptr -28h
.text$mn:000025A0 var_24          = dword ptr -24h
.text$mn:000025A0 var_20          = dword ptr -20h
.text$mn:000025A0 var_1C          = dword ptr -1Ch
.text$mn:000025A0 var_18          = dword ptr -18h
.text$mn:000025A0 var_14          = dword ptr -14h
.text$mn:000025A0 var_10          = dword ptr -10h
.text$mn:000025A0 var_C           = dword ptr -0Ch
.text$mn:000025A0 var_4           = dword ptr -4
.text$mn:000025A0 arg_0           = byte ptr  8
.text$mn:000025A0 arg_C           = byte ptr  14h
.text$mn:000025A0
.text$mn:000025A0                 push    ebp
.text$mn:000025A1                 mov     ebp, esp
.text$mn:000025A3                 push    0FFFFFFFFh
.text$mn:000025A5                 push    offset __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$mn:000025AA                 mov     eax, large fs:0
.text$mn:000025B0                 push    eax
.text$mn:000025B1                 sub     esp, 64h
.text$mn:000025B4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000025B9                 xor     eax, ebp
.text$mn:000025BB                 push    eax
.text$mn:000025BC                 lea     eax, [ebp+var_C]
.text$mn:000025BF                 mov     large fs:0, eax
.text$mn:000025C5                 mov     [ebp+var_10], ecx
.text$mn:000025C8                 mov     [ebp+var_4], 1
.text$mn:000025CF                 sub     esp, 0Ch
.text$mn:000025D2                 mov     ecx, esp
.text$mn:000025D4                 mov     [ebp+var_3C], esp
.text$mn:000025D7                 lea     eax, [ebp+arg_C]
.text$mn:000025DA                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000025DB                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000025E0                 mov     [ebp+var_14], eax
.text$mn:000025E3                 mov     ecx, [ebp+var_14]
.text$mn:000025E6                 mov     [ebp+var_40], ecx
.text$mn:000025E9                 mov     byte ptr [ebp+var_4], 2
.text$mn:000025ED                 sub     esp, 0Ch
.text$mn:000025F0                 mov     ecx, esp
.text$mn:000025F2                 mov     [ebp+var_44], esp
.text$mn:000025F5                 lea     edx, [ebp+arg_0]
.text$mn:000025F8                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000025F9                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000025FE                 mov     [ebp+var_18], eax
.text$mn:00002601                 mov     eax, [ebp+var_18]
.text$mn:00002604                 mov     [ebp+var_48], eax
.text$mn:00002607                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000260B                 lea     ecx, [ebp+var_70]
.text$mn:0000260E                 push    ecx
.text$mn:0000260F                 mov     ecx, [ebp+var_10]
.text$mn:00002612                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:00002617                 mov     [ebp+var_1C], eax
.text$mn:0000261A                 mov     edx, [ebp+var_1C]
.text$mn:0000261D                 mov     [ebp+var_20], edx
.text$mn:00002620                 mov     byte ptr [ebp+var_4], 4
.text$mn:00002624                 sub     esp, 0Ch
.text$mn:00002627                 mov     ecx, esp
.text$mn:00002629                 mov     [ebp+var_4C], esp
.text$mn:0000262C                 mov     eax, [ebp+var_20]
.text$mn:0000262F                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002630                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00002635                 mov     [ebp+var_24], eax
.text$mn:00002638                 mov     ecx, [ebp+var_24]
.text$mn:0000263B                 mov     [ebp+var_50], ecx
.text$mn:0000263E                 mov     byte ptr [ebp+var_4], 5
.text$mn:00002642                 lea     edx, [ebp+var_64]
.text$mn:00002645                 push    edx
.text$mn:00002646                 mov     ecx, [ebp+var_10]
.text$mn:00002649                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:0000264E                 mov     [ebp+var_28], eax
.text$mn:00002651                 mov     eax, [ebp+var_28]
.text$mn:00002654                 mov     [ebp+var_2C], eax
.text$mn:00002657                 mov     byte ptr [ebp+var_4], 6
.text$mn:0000265B                 sub     esp, 0Ch
.text$mn:0000265E                 mov     ecx, esp
.text$mn:00002660                 mov     [ebp+var_54], esp
.text$mn:00002663                 mov     edx, [ebp+var_2C]
.text$mn:00002666                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00002667                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:0000266C                 mov     [ebp+var_30], eax
.text$mn:0000266F                 mov     eax, [ebp+var_30]
.text$mn:00002672                 mov     [ebp+var_58], eax
.text$mn:00002675                 mov     byte ptr [ebp+var_4], 7
.text$mn:00002679                 mov     byte ptr [ebp+var_4], 9
.text$mn:0000267D                 mov     ecx, [ebp+var_10]
.text$mn:00002680                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00002685                 mov     [ebp+var_34], eax
.text$mn:00002688                 mov     ecx, [ebp+var_34]
.text$mn:0000268B                 mov     [ebp+var_38], ecx
.text$mn:0000268E                 mov     byte ptr [ebp+var_4], 8
.text$mn:00002692                 lea     ecx, [ebp+var_64]
.text$mn:00002695                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:0000269A                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000269E                 lea     ecx, [ebp+var_70]
.text$mn:000026A1                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000026A6                 mov     byte ptr [ebp+var_4], 0
.text$mn:000026AA                 lea     ecx, [ebp+arg_0]
.text$mn:000026AD                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000026B2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000026B9                 lea     ecx, [ebp+arg_C]
.text$mn:000026BC                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000026C1                 mov     eax, [ebp+var_38]
.text$mn:000026C4                 mov     ecx, [ebp+var_C]
.text$mn:000026C7                 mov     large fs:0, ecx
.text$mn:000026CE                 pop     ecx
.text$mn:000026CF                 mov     esp, ebp
.text$mn:000026D1                 pop     ebp
.text$mn:000026D2                 retn    18h
.text$mn:000026D2 ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$mn:000026D2
.text$mn:000026D2 ; ---------------------------------------------------------------------------
.text$mn:000026D5                 align 4
.text$mn:000026D5 _text$mn        ends
.text$mn:000026D5
.text$x:000026D8 ; ===========================================================================
.text$x:000026D8
.text$x:000026D8 ; Segment type: Pure code
.text$x:000026D8 ; Segment permissions: Read/Execute
.text$x:000026D8 _text$x         segment para public 'CODE' use32
.text$x:000026D8                 assume cs:_text$x
.text$x:000026D8                 ;org 26D8h
.text$x:000026D8 ; COMDAT (pick associative to section at 25A0)
.text$x:000026D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026D8
.text$x:000026D8 ; =============== S U B R O U T I N E =======================================
.text$x:000026D8
.text$x:000026D8
.text$x:000026D8 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 proc near
.text$x:000026D8                                         ; DATA XREF: .xdata$x:00008CE0o
.text$x:000026D8                 lea     ecx, [ebp+14h]
.text$x:000026DB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026DB __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0 endp
.text$x:000026DB
.text$x:000026E0
.text$x:000026E0 ; =============== S U B R O U T I N E =======================================
.text$x:000026E0
.text$x:000026E0
.text$x:000026E0 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 proc near
.text$x:000026E0                                         ; DATA XREF: .xdata$x:00008CE8o
.text$x:000026E0                 lea     ecx, [ebp+8]
.text$x:000026E3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026E3 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1 endp
.text$x:000026E3
.text$x:000026E8
.text$x:000026E8 ; =============== S U B R O U T I N E =======================================
.text$x:000026E8
.text$x:000026E8
.text$x:000026E8 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 proc near
.text$x:000026E8                                         ; DATA XREF: .xdata$x:00008CF0o
.text$x:000026E8                 mov     ecx, [ebp-3Ch]
.text$x:000026EB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026EB __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2 endp
.text$x:000026EB
.text$x:000026F0
.text$x:000026F0 ; =============== S U B R O U T I N E =======================================
.text$x:000026F0
.text$x:000026F0
.text$x:000026F0 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 proc near
.text$x:000026F0                                         ; DATA XREF: .xdata$x:00008CF8o
.text$x:000026F0                 mov     ecx, [ebp-44h]
.text$x:000026F3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026F3 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3 endp
.text$x:000026F3
.text$x:000026F8
.text$x:000026F8 ; =============== S U B R O U T I N E =======================================
.text$x:000026F8
.text$x:000026F8
.text$x:000026F8 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 proc near
.text$x:000026F8                                         ; DATA XREF: .xdata$x:00008D00o
.text$x:000026F8                                         ; .xdata$x:00008D20o
.text$x:000026F8                 lea     ecx, [ebp-70h]
.text$x:000026FB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000026FB __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4 endp
.text$x:000026FB
.text$x:00002700
.text$x:00002700 ; =============== S U B R O U T I N E =======================================
.text$x:00002700
.text$x:00002700
.text$x:00002700 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5 proc near
.text$x:00002700                                         ; DATA XREF: .xdata$x:00008D08o
.text$x:00002700                 mov     ecx, [ebp-4Ch]
.text$x:00002703                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002703 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5 endp
.text$x:00002703
.text$x:00002708
.text$x:00002708 ; =============== S U B R O U T I N E =======================================
.text$x:00002708
.text$x:00002708
.text$x:00002708 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6 proc near
.text$x:00002708                                         ; DATA XREF: .xdata$x:00008D10o
.text$x:00002708                                         ; .xdata$x:00008D28o
.text$x:00002708                 lea     ecx, [ebp-64h]
.text$x:0000270B                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000270B __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6 endp
.text$x:0000270B
.text$x:00002710
.text$x:00002710 ; =============== S U B R O U T I N E =======================================
.text$x:00002710
.text$x:00002710
.text$x:00002710 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7 proc near
.text$x:00002710                                         ; DATA XREF: .xdata$x:00008D18o
.text$x:00002710                 mov     ecx, [ebp-54h]
.text$x:00002713                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00002713 __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7 endp
.text$x:00002713
.text$x:00002718
.text$x:00002718 ; =============== S U B R O U T I N E =======================================
.text$x:00002718
.text$x:00002718
.text$x:00002718 __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z proc near
.text$x:00002718                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00002718
.text$x:00002718 arg_4           = dword ptr  8
.text$x:00002718
.text$x:00002718                 mov     edx, [esp+arg_4]
.text$x:0000271C                 lea     eax, [edx+0Ch]
.text$x:0000271F                 mov     ecx, [edx-68h]
.text$x:00002722                 xor     ecx, eax
.text$x:00002724                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002729                 mov     eax, offset __ehfuncinfo$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.text$x:0000272E                 jmp     ___CxxFrameHandler3
.text$x:0000272E __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z endp
.text$x:0000272E
.text$x:0000272E ; ---------------------------------------------------------------------------
.text$x:00002733                 align 4
.text$x:00002733 _text$x         ends
.text$x:00002733
.text$mn:00002734 ; ===========================================================================
.text$mn:00002734
.text$mn:00002734 ; Segment type: Pure code
.text$mn:00002734 ; Segment permissions: Read/Execute
.text$mn:00002734 _text$mn        segment para public 'CODE' use32
.text$mn:00002734                 assume cs:_text$mn
.text$mn:00002734                 ;org 2734h
.text$mn:00002734 ; COMDAT (pick any)
.text$mn:00002734                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002734
.text$mn:00002734 ; =============== S U B R O U T I N E =======================================
.text$mn:00002734
.text$mn:00002734 ; Attributes: bp-based frame
.text$mn:00002734
.text$mn:00002734 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00002734                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00002734 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002734                                         ; CODE XREF: $LN19+4Bp
.text$mn:00002734
.text$mn:00002734 var_4           = dword ptr -4
.text$mn:00002734 arg_0           = dword ptr  8
.text$mn:00002734 arg_4           = dword ptr  0Ch
.text$mn:00002734
.text$mn:00002734                 push    ebp
.text$mn:00002735                 mov     ebp, esp
.text$mn:00002737                 push    ecx
.text$mn:00002738                 mov     [ebp+var_4], ecx
.text$mn:0000273B                 mov     eax, [ebp+arg_4]
.text$mn:0000273E                 push    eax
.text$mn:0000273F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002744                 add     esp, 4
.text$mn:00002747                 push    eax             ; int
.text$mn:00002748                 mov     ecx, [ebp+arg_0]
.text$mn:0000274B                 push    ecx             ; void *
.text$mn:0000274C                 mov     edx, [ebp+var_4]
.text$mn:0000274F                 push    edx             ; int
.text$mn:00002750                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00002755                 add     esp, 0Ch
.text$mn:00002758                 mov     esp, ebp
.text$mn:0000275A                 pop     ebp
.text$mn:0000275B                 retn    8
.text$mn:0000275B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000275B
.text$mn:0000275B ; ---------------------------------------------------------------------------
.text$mn:0000275E                 align 10h
.text$mn:0000275E _text$mn        ends
.text$mn:0000275E
.text$mn:00002760 ; ===========================================================================
.text$mn:00002760
.text$mn:00002760 ; Segment type: Pure code
.text$mn:00002760 ; Segment permissions: Read/Execute
.text$mn:00002760 _text$mn        segment para public 'CODE' use32
.text$mn:00002760                 assume cs:_text$mn
.text$mn:00002760                 ;org 2760h
.text$mn:00002760 ; COMDAT (pick any)
.text$mn:00002760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002760
.text$mn:00002760 ; =============== S U B R O U T I N E =======================================
.text$mn:00002760
.text$mn:00002760 ; Attributes: bp-based frame
.text$mn:00002760
.text$mn:00002760 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00002760                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002760 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002760                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00002760
.text$mn:00002760 var_1C          = dword ptr -1Ch
.text$mn:00002760 var_18          = dword ptr -18h
.text$mn:00002760 var_14          = dword ptr -14h
.text$mn:00002760 var_10          = dword ptr -10h
.text$mn:00002760 var_C           = dword ptr -0Ch
.text$mn:00002760 var_4           = dword ptr -4
.text$mn:00002760 arg_0           = dword ptr  8
.text$mn:00002760 arg_4           = dword ptr  0Ch
.text$mn:00002760
.text$mn:00002760                 push    ebp
.text$mn:00002761                 mov     ebp, esp
.text$mn:00002763                 push    0FFFFFFFFh
.text$mn:00002765                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000276A                 mov     eax, large fs:0
.text$mn:00002770                 push    eax
.text$mn:00002771                 sub     esp, 10h
.text$mn:00002774                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002779                 xor     eax, ebp
.text$mn:0000277B                 push    eax
.text$mn:0000277C                 lea     eax, [ebp+var_C]
.text$mn:0000277F                 mov     large fs:0, eax
.text$mn:00002785                 mov     [ebp+var_18], ecx
.text$mn:00002788                 mov     eax, [ebp+arg_0]
.text$mn:0000278B                 push    eax             ; void *
.text$mn:0000278C                 push    4               ; unsigned int
.text$mn:0000278E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002793                 add     esp, 8
.text$mn:00002796                 mov     [ebp+var_10], eax
.text$mn:00002799                 mov     [ebp+var_4], 0
.text$mn:000027A0                 cmp     [ebp+var_10], 0
.text$mn:000027A4                 jz      short loc_27C1
.text$mn:000027A6                 mov     ecx, [ebp+arg_4]
.text$mn:000027A9                 push    ecx
.text$mn:000027AA                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000027AF                 add     esp, 4
.text$mn:000027B2                 mov     edx, [ebp+var_10]
.text$mn:000027B5                 mov     eax, [eax]
.text$mn:000027B7                 mov     [edx], eax
.text$mn:000027B9                 mov     ecx, [ebp+var_10]
.text$mn:000027BC                 mov     [ebp+var_14], ecx
.text$mn:000027BF                 jmp     short loc_27C8
.text$mn:000027C1 ; ---------------------------------------------------------------------------
.text$mn:000027C1
.text$mn:000027C1 loc_27C1:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:000027C1                 mov     [ebp+var_14], 0
.text$mn:000027C8
.text$mn:000027C8 loc_27C8:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:000027C8                 mov     edx, [ebp+var_14]
.text$mn:000027CB                 mov     [ebp+var_1C], edx
.text$mn:000027CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000027D5                 mov     ecx, [ebp+var_C]
.text$mn:000027D8                 mov     large fs:0, ecx
.text$mn:000027DF                 pop     ecx
.text$mn:000027E0                 mov     esp, ebp
.text$mn:000027E2                 pop     ebp
.text$mn:000027E3                 retn    8
.text$mn:000027E3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000027E3
.text$mn:000027E3 ; ---------------------------------------------------------------------------
.text$mn:000027E6                 align 4
.text$mn:000027E6 _text$mn        ends
.text$mn:000027E6
.text$x:000027E8 ; ===========================================================================
.text$x:000027E8
.text$x:000027E8 ; Segment type: Pure code
.text$x:000027E8 ; Segment permissions: Read/Execute
.text$x:000027E8 _text$x         segment para public 'CODE' use32
.text$x:000027E8                 assume cs:_text$x
.text$x:000027E8                 ;org 27E8h
.text$x:000027E8 ; COMDAT (pick associative to section at 2760)
.text$x:000027E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000027E8
.text$x:000027E8 ; =============== S U B R O U T I N E =======================================
.text$x:000027E8
.text$x:000027E8
.text$x:000027E8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000027E8                                         ; DATA XREF: .xdata$x:00008D88o
.text$x:000027E8                 mov     eax, [ebp+8]
.text$x:000027EB                 push    eax
.text$x:000027EC                 mov     eax, [ebp-10h]
.text$x:000027EF                 push    eax             ; void *
.text$x:000027F0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000027F5                 add     esp, 8
.text$x:000027F8                 retn
.text$x:000027F8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000027F8
.text$x:000027F9
.text$x:000027F9 ; =============== S U B R O U T I N E =======================================
.text$x:000027F9
.text$x:000027F9
.text$x:000027F9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000027F9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000027F9
.text$x:000027F9 arg_4           = dword ptr  8
.text$x:000027F9
.text$x:000027F9                 mov     edx, [esp+arg_4]
.text$x:000027FD                 lea     eax, [edx+0Ch]
.text$x:00002800                 mov     ecx, [edx-14h]
.text$x:00002803                 xor     ecx, eax
.text$x:00002805                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000280A                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:0000280F                 jmp     ___CxxFrameHandler3
.text$x:0000280F __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:0000280F
.text$x:0000280F _text$x         ends
.text$x:0000280F
.text$mn:00002814 ; ===========================================================================
.text$mn:00002814
.text$mn:00002814 ; Segment type: Pure code
.text$mn:00002814 ; Segment permissions: Read/Execute
.text$mn:00002814 _text$mn        segment para public 'CODE' use32
.text$mn:00002814                 assume cs:_text$mn
.text$mn:00002814                 ;org 2814h
.text$mn:00002814 ; COMDAT (pick any)
.text$mn:00002814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002814
.text$mn:00002814 ; =============== S U B R O U T I N E =======================================
.text$mn:00002814
.text$mn:00002814 ; Attributes: bp-based frame
.text$mn:00002814
.text$mn:00002814 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00002814                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00002814 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00002814                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00002814
.text$mn:00002814 arg_0           = dword ptr  8
.text$mn:00002814 arg_4           = dword ptr  0Ch
.text$mn:00002814 arg_8           = dword ptr  10h
.text$mn:00002814
.text$mn:00002814                 push    ebp
.text$mn:00002815                 mov     ebp, esp
.text$mn:00002817                 mov     eax, [ebp+arg_8]
.text$mn:0000281A                 push    eax
.text$mn:0000281B                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002820                 add     esp, 4
.text$mn:00002823                 push    eax             ; int
.text$mn:00002824                 mov     ecx, [ebp+arg_4]
.text$mn:00002827                 push    ecx             ; void *
.text$mn:00002828                 mov     ecx, [ebp+arg_0]
.text$mn:0000282B                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002830                 pop     ebp
.text$mn:00002831                 retn
.text$mn:00002831 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00002831
.text$mn:00002831 ; ---------------------------------------------------------------------------
.text$mn:00002832                 align 4
.text$mn:00002832 _text$mn        ends
.text$mn:00002832
.text$mn:00002834 ; ===========================================================================
.text$mn:00002834
.text$mn:00002834 ; Segment type: Pure code
.text$mn:00002834 ; Segment permissions: Read/Execute
.text$mn:00002834 _text$mn        segment para public 'CODE' use32
.text$mn:00002834                 assume cs:_text$mn
.text$mn:00002834                 ;org 2834h
.text$mn:00002834 ; COMDAT (pick any)
.text$mn:00002834                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002834
.text$mn:00002834 ; =============== S U B R O U T I N E =======================================
.text$mn:00002834
.text$mn:00002834 ; Attributes: bp-based frame
.text$mn:00002834
.text$mn:00002834 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00002834                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00002834 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00002834                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+50p
.text$mn:00002834                                         ; $LN19_0+4Bp
.text$mn:00002834
.text$mn:00002834 var_4           = dword ptr -4
.text$mn:00002834 arg_0           = dword ptr  8
.text$mn:00002834 arg_4           = dword ptr  0Ch
.text$mn:00002834
.text$mn:00002834                 push    ebp
.text$mn:00002835                 mov     ebp, esp
.text$mn:00002837                 push    ecx
.text$mn:00002838                 mov     [ebp+var_4], ecx
.text$mn:0000283B                 mov     eax, [ebp+arg_4]
.text$mn:0000283E                 push    eax
.text$mn:0000283F                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00002844                 add     esp, 4
.text$mn:00002847                 push    eax             ; int
.text$mn:00002848                 mov     ecx, [ebp+arg_0]
.text$mn:0000284B                 push    ecx             ; void *
.text$mn:0000284C                 mov     edx, [ebp+var_4]
.text$mn:0000284F                 push    edx             ; int
.text$mn:00002850                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00002855                 add     esp, 0Ch
.text$mn:00002858                 mov     esp, ebp
.text$mn:0000285A                 pop     ebp
.text$mn:0000285B                 retn    8
.text$mn:0000285B ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:0000285B
.text$mn:0000285B ; ---------------------------------------------------------------------------
.text$mn:0000285E                 align 10h
.text$mn:0000285E _text$mn        ends
.text$mn:0000285E
.text$mn:00002860 ; ===========================================================================
.text$mn:00002860
.text$mn:00002860 ; Segment type: Pure code
.text$mn:00002860 ; Segment permissions: Read/Execute
.text$mn:00002860 _text$mn        segment para public 'CODE' use32
.text$mn:00002860                 assume cs:_text$mn
.text$mn:00002860                 ;org 2860h
.text$mn:00002860 ; COMDAT (pick any)
.text$mn:00002860                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002860
.text$mn:00002860 ; =============== S U B R O U T I N E =======================================
.text$mn:00002860
.text$mn:00002860 ; Attributes: bp-based frame
.text$mn:00002860
.text$mn:00002860 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00002860                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00002860 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00002860                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00002860
.text$mn:00002860 var_1C          = dword ptr -1Ch
.text$mn:00002860 var_18          = dword ptr -18h
.text$mn:00002860 var_14          = dword ptr -14h
.text$mn:00002860 var_10          = dword ptr -10h
.text$mn:00002860 var_C           = dword ptr -0Ch
.text$mn:00002860 var_4           = dword ptr -4
.text$mn:00002860 arg_0           = dword ptr  8
.text$mn:00002860 arg_4           = dword ptr  0Ch
.text$mn:00002860
.text$mn:00002860                 push    ebp
.text$mn:00002861                 mov     ebp, esp
.text$mn:00002863                 push    0FFFFFFFFh
.text$mn:00002865                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000286A                 mov     eax, large fs:0
.text$mn:00002870                 push    eax
.text$mn:00002871                 sub     esp, 10h
.text$mn:00002874                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002879                 xor     eax, ebp
.text$mn:0000287B                 push    eax
.text$mn:0000287C                 lea     eax, [ebp+var_C]
.text$mn:0000287F                 mov     large fs:0, eax
.text$mn:00002885                 mov     [ebp+var_18], ecx
.text$mn:00002888                 mov     eax, [ebp+arg_0]
.text$mn:0000288B                 push    eax             ; void *
.text$mn:0000288C                 push    4               ; unsigned int
.text$mn:0000288E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002893                 add     esp, 8
.text$mn:00002896                 mov     [ebp+var_10], eax
.text$mn:00002899                 mov     [ebp+var_4], 0
.text$mn:000028A0                 cmp     [ebp+var_10], 0
.text$mn:000028A4                 jz      short loc_28C1
.text$mn:000028A6                 mov     ecx, [ebp+arg_4]
.text$mn:000028A9                 push    ecx
.text$mn:000028AA                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000028AF                 add     esp, 4
.text$mn:000028B2                 mov     edx, [ebp+var_10]
.text$mn:000028B5                 mov     eax, [eax]
.text$mn:000028B7                 mov     [edx], eax
.text$mn:000028B9                 mov     ecx, [ebp+var_10]
.text$mn:000028BC                 mov     [ebp+var_14], ecx
.text$mn:000028BF                 jmp     short loc_28C8
.text$mn:000028C1 ; ---------------------------------------------------------------------------
.text$mn:000028C1
.text$mn:000028C1 loc_28C1:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:000028C1                 mov     [ebp+var_14], 0
.text$mn:000028C8
.text$mn:000028C8 loc_28C8:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:000028C8                 mov     edx, [ebp+var_14]
.text$mn:000028CB                 mov     [ebp+var_1C], edx
.text$mn:000028CE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028D5                 mov     ecx, [ebp+var_C]
.text$mn:000028D8                 mov     large fs:0, ecx
.text$mn:000028DF                 pop     ecx
.text$mn:000028E0                 mov     esp, ebp
.text$mn:000028E2                 pop     ebp
.text$mn:000028E3                 retn    8
.text$mn:000028E3 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000028E3
.text$mn:000028E3 ; ---------------------------------------------------------------------------
.text$mn:000028E6                 align 4
.text$mn:000028E6 _text$mn        ends
.text$mn:000028E6
.text$x:000028E8 ; ===========================================================================
.text$x:000028E8
.text$x:000028E8 ; Segment type: Pure code
.text$x:000028E8 ; Segment permissions: Read/Execute
.text$x:000028E8 _text$x         segment para public 'CODE' use32
.text$x:000028E8                 assume cs:_text$x
.text$x:000028E8                 ;org 28E8h
.text$x:000028E8 ; COMDAT (pick associative to section at 2860)
.text$x:000028E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028E8
.text$x:000028E8 ; =============== S U B R O U T I N E =======================================
.text$x:000028E8
.text$x:000028E8
.text$x:000028E8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000028E8                                         ; DATA XREF: .xdata$x:00008DB4o
.text$x:000028E8                 mov     eax, [ebp+8]
.text$x:000028EB                 push    eax
.text$x:000028EC                 mov     eax, [ebp-10h]
.text$x:000028EF                 push    eax             ; void *
.text$x:000028F0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000028F5                 add     esp, 8
.text$x:000028F8                 retn
.text$x:000028F8 __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:000028F8
.text$x:000028F9
.text$x:000028F9 ; =============== S U B R O U T I N E =======================================
.text$x:000028F9
.text$x:000028F9
.text$x:000028F9 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:000028F9                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:000028F9
.text$x:000028F9 arg_4           = dword ptr  8
.text$x:000028F9
.text$x:000028F9                 mov     edx, [esp+arg_4]
.text$x:000028FD                 lea     eax, [edx+0Ch]
.text$x:00002900                 mov     ecx, [edx-14h]
.text$x:00002903                 xor     ecx, eax
.text$x:00002905                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000290A                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:0000290F                 jmp     ___CxxFrameHandler3
.text$x:0000290F __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:0000290F
.text$x:0000290F _text$x         ends
.text$x:0000290F
.text$mn:00002914 ; ===========================================================================
.text$mn:00002914
.text$mn:00002914 ; Segment type: Pure code
.text$mn:00002914 ; Segment permissions: Read/Execute
.text$mn:00002914 _text$mn        segment para public 'CODE' use32
.text$mn:00002914                 assume cs:_text$mn
.text$mn:00002914                 ;org 2914h
.text$mn:00002914 ; COMDAT (pick any)
.text$mn:00002914                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002914
.text$mn:00002914 ; =============== S U B R O U T I N E =======================================
.text$mn:00002914
.text$mn:00002914 ; Attributes: bp-based frame
.text$mn:00002914
.text$mn:00002914 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00002914                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00002914 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00002914                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00002914
.text$mn:00002914 arg_0           = dword ptr  8
.text$mn:00002914 arg_4           = dword ptr  0Ch
.text$mn:00002914 arg_8           = dword ptr  10h
.text$mn:00002914
.text$mn:00002914                 push    ebp
.text$mn:00002915                 mov     ebp, esp
.text$mn:00002917                 mov     eax, [ebp+arg_8]
.text$mn:0000291A                 push    eax
.text$mn:0000291B                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00002920                 add     esp, 4
.text$mn:00002923                 push    eax             ; int
.text$mn:00002924                 mov     ecx, [ebp+arg_4]
.text$mn:00002927                 push    ecx             ; void *
.text$mn:00002928                 mov     ecx, [ebp+arg_0]
.text$mn:0000292B                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00002930                 pop     ebp
.text$mn:00002931                 retn
.text$mn:00002931 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00002931
.text$mn:00002931 ; ---------------------------------------------------------------------------
.text$mn:00002932                 align 4
.text$mn:00002932 _text$mn        ends
.text$mn:00002932
.text$mn:00002934 ; ===========================================================================
.text$mn:00002934
.text$mn:00002934 ; Segment type: Pure code
.text$mn:00002934 ; Segment permissions: Read/Execute
.text$mn:00002934 _text$mn        segment para public 'CODE' use32
.text$mn:00002934                 assume cs:_text$mn
.text$mn:00002934                 ;org 2934h
.text$mn:00002934 ; COMDAT (pick any)
.text$mn:00002934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002934
.text$mn:00002934 ; =============== S U B R O U T I N E =======================================
.text$mn:00002934
.text$mn:00002934 ; Attributes: bp-based frame
.text$mn:00002934
.text$mn:00002934 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00002934                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002934 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00002934                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00002934                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:00002934
.text$mn:00002934 var_1C          = dword ptr -1Ch
.text$mn:00002934 var_18          = dword ptr -18h
.text$mn:00002934 var_14          = dword ptr -14h
.text$mn:00002934 var_10          = dword ptr -10h
.text$mn:00002934 var_C           = dword ptr -0Ch
.text$mn:00002934 var_4           = dword ptr -4
.text$mn:00002934 arg_0           = dword ptr  8
.text$mn:00002934 arg_4           = dword ptr  0Ch
.text$mn:00002934
.text$mn:00002934                 push    ebp
.text$mn:00002935                 mov     ebp, esp
.text$mn:00002937                 push    0FFFFFFFFh
.text$mn:00002939                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000293E                 mov     eax, large fs:0
.text$mn:00002944                 push    eax
.text$mn:00002945                 sub     esp, 10h
.text$mn:00002948                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000294D                 xor     eax, ebp
.text$mn:0000294F                 push    eax
.text$mn:00002950                 lea     eax, [ebp+var_C]
.text$mn:00002953                 mov     large fs:0, eax
.text$mn:00002959                 mov     [ebp+var_18], ecx
.text$mn:0000295C                 mov     eax, [ebp+arg_0]
.text$mn:0000295F                 push    eax             ; void *
.text$mn:00002960                 push    8               ; unsigned int
.text$mn:00002962                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002967                 add     esp, 8
.text$mn:0000296A                 mov     [ebp+var_10], eax
.text$mn:0000296D                 mov     [ebp+var_4], 0
.text$mn:00002974                 cmp     [ebp+var_10], 0
.text$mn:00002978                 jz      short loc_299B
.text$mn:0000297A                 mov     ecx, [ebp+arg_4]
.text$mn:0000297D                 push    ecx
.text$mn:0000297E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00002983                 add     esp, 4
.text$mn:00002986                 mov     edx, [eax]
.text$mn:00002988                 mov     eax, [eax+4]
.text$mn:0000298B                 mov     ecx, [ebp+var_10]
.text$mn:0000298E                 mov     [ecx], edx
.text$mn:00002990                 mov     [ecx+4], eax
.text$mn:00002993                 mov     edx, [ebp+var_10]
.text$mn:00002996                 mov     [ebp+var_14], edx
.text$mn:00002999                 jmp     short loc_29A2
.text$mn:0000299B ; ---------------------------------------------------------------------------
.text$mn:0000299B
.text$mn:0000299B loc_299B:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000299B                 mov     [ebp+var_14], 0
.text$mn:000029A2
.text$mn:000029A2 loc_29A2:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000029A2                 mov     eax, [ebp+var_14]
.text$mn:000029A5                 mov     [ebp+var_1C], eax
.text$mn:000029A8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000029AF                 mov     ecx, [ebp+var_C]
.text$mn:000029B2                 mov     large fs:0, ecx
.text$mn:000029B9                 pop     ecx
.text$mn:000029BA                 mov     esp, ebp
.text$mn:000029BC                 pop     ebp
.text$mn:000029BD                 retn    8
.text$mn:000029BD ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000029BD
.text$mn:000029BD _text$mn        ends
.text$mn:000029BD
.text$x:000029C0 ; ===========================================================================
.text$x:000029C0
.text$x:000029C0 ; Segment type: Pure code
.text$x:000029C0 ; Segment permissions: Read/Execute
.text$x:000029C0 _text$x         segment para public 'CODE' use32
.text$x:000029C0                 assume cs:_text$x
.text$x:000029C0                 ;org 29C0h
.text$x:000029C0 ; COMDAT (pick associative to section at 2934)
.text$x:000029C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000029C0
.text$x:000029C0 ; =============== S U B R O U T I N E =======================================
.text$x:000029C0
.text$x:000029C0
.text$x:000029C0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000029C0                                         ; DATA XREF: .xdata$x:00008D30o
.text$x:000029C0                 mov     eax, [ebp+8]
.text$x:000029C3                 push    eax
.text$x:000029C4                 mov     eax, [ebp-10h]
.text$x:000029C7                 push    eax             ; void *
.text$x:000029C8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000029CD                 add     esp, 8
.text$x:000029D0                 retn
.text$x:000029D0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000029D0
.text$x:000029D1
.text$x:000029D1 ; =============== S U B R O U T I N E =======================================
.text$x:000029D1
.text$x:000029D1
.text$x:000029D1 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000029D1                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000029D1
.text$x:000029D1 arg_4           = dword ptr  8
.text$x:000029D1
.text$x:000029D1                 mov     edx, [esp+arg_4]
.text$x:000029D5                 lea     eax, [edx+0Ch]
.text$x:000029D8                 mov     ecx, [edx-14h]
.text$x:000029DB                 xor     ecx, eax
.text$x:000029DD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029E2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000029E7                 jmp     ___CxxFrameHandler3
.text$x:000029E7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000029E7
.text$x:000029E7 _text$x         ends
.text$x:000029E7
.text$mn:000029EC ; ===========================================================================
.text$mn:000029EC
.text$mn:000029EC ; Segment type: Pure code
.text$mn:000029EC ; Segment permissions: Read/Execute
.text$mn:000029EC _text$mn        segment para public 'CODE' use32
.text$mn:000029EC                 assume cs:_text$mn
.text$mn:000029EC                 ;org 29ECh
.text$mn:000029EC ; COMDAT (pick any)
.text$mn:000029EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029EC
.text$mn:000029EC ; =============== S U B R O U T I N E =======================================
.text$mn:000029EC
.text$mn:000029EC ; Attributes: bp-based frame
.text$mn:000029EC
.text$mn:000029EC ; int __stdcall std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand &>(void *, int)
.text$mn:000029EC                 public ??$construct@VUserCommand@@AAV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@AAV2@@Z
.text$mn:000029EC ??$construct@VUserCommand@@AAV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@AAV2@@Z proc near
.text$mn:000029EC                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+97p
.text$mn:000029EC
.text$mn:000029EC var_4           = dword ptr -4
.text$mn:000029EC arg_0           = dword ptr  8
.text$mn:000029EC arg_4           = dword ptr  0Ch
.text$mn:000029EC
.text$mn:000029EC                 push    ebp
.text$mn:000029ED                 mov     ebp, esp
.text$mn:000029EF                 push    ecx
.text$mn:000029F0                 mov     [ebp+var_4], ecx
.text$mn:000029F3                 mov     eax, [ebp+arg_4]
.text$mn:000029F6                 push    eax
.text$mn:000029F7                 call    ??$forward@AAVUserCommand@@@std@@YAAAVUserCommand@@AAV1@@Z ; std::forward<UserCommand &>(UserCommand &)
.text$mn:000029FC                 add     esp, 4
.text$mn:000029FF                 push    eax             ; int
.text$mn:00002A00                 mov     ecx, [ebp+arg_0]
.text$mn:00002A03                 push    ecx             ; void *
.text$mn:00002A04                 mov     edx, [ebp+var_4]
.text$mn:00002A07                 push    edx             ; int
.text$mn:00002A08                 call    ??$construct@VUserCommand@@AAV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@AAV3@@Z ; std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand &>(std::allocator<UserCommand> &,UserCommand *,UserCommand &)
.text$mn:00002A0D                 add     esp, 0Ch
.text$mn:00002A10                 mov     esp, ebp
.text$mn:00002A12                 pop     ebp
.text$mn:00002A13                 retn    8
.text$mn:00002A13 ??$construct@VUserCommand@@AAV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@AAV2@@Z endp
.text$mn:00002A13
.text$mn:00002A13 ; ---------------------------------------------------------------------------
.text$mn:00002A16                 align 4
.text$mn:00002A16 _text$mn        ends
.text$mn:00002A16
.text$mn:00002A18 ; ===========================================================================
.text$mn:00002A18
.text$mn:00002A18 ; Segment type: Pure code
.text$mn:00002A18 ; Segment permissions: Read/Execute
.text$mn:00002A18 _text$mn        segment para public 'CODE' use32
.text$mn:00002A18                 assume cs:_text$mn
.text$mn:00002A18                 ;org 2A18h
.text$mn:00002A18 ; COMDAT (pick any)
.text$mn:00002A18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A18
.text$mn:00002A18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A18
.text$mn:00002A18 ; Attributes: bp-based frame
.text$mn:00002A18
.text$mn:00002A18 ; int __stdcall std::allocator<UserCommand>::construct<UserCommand,UserCommand &>(void *, int)
.text$mn:00002A18                 public ??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z
.text$mn:00002A18 ??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z proc near
.text$mn:00002A18                                         ; CODE XREF: std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand &>(std::allocator<UserCommand> &,UserCommand *,UserCommand &)+17p
.text$mn:00002A18
.text$mn:00002A18 var_1C          = dword ptr -1Ch
.text$mn:00002A18 var_18          = dword ptr -18h
.text$mn:00002A18 var_14          = dword ptr -14h
.text$mn:00002A18 var_10          = dword ptr -10h
.text$mn:00002A18 var_C           = dword ptr -0Ch
.text$mn:00002A18 var_4           = dword ptr -4
.text$mn:00002A18 arg_0           = dword ptr  8
.text$mn:00002A18 arg_4           = dword ptr  0Ch
.text$mn:00002A18
.text$mn:00002A18                 push    ebp
.text$mn:00002A19                 mov     ebp, esp
.text$mn:00002A1B                 push    0FFFFFFFFh
.text$mn:00002A1D                 push    offset __ehhandler$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z
.text$mn:00002A22                 mov     eax, large fs:0
.text$mn:00002A28                 push    eax
.text$mn:00002A29                 sub     esp, 10h
.text$mn:00002A2C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A31                 xor     eax, ebp
.text$mn:00002A33                 push    eax
.text$mn:00002A34                 lea     eax, [ebp+var_C]
.text$mn:00002A37                 mov     large fs:0, eax
.text$mn:00002A3D                 mov     [ebp+var_18], ecx
.text$mn:00002A40                 mov     eax, [ebp+arg_0]
.text$mn:00002A43                 push    eax             ; void *
.text$mn:00002A44                 push    148h            ; unsigned int
.text$mn:00002A49                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002A4E                 add     esp, 8
.text$mn:00002A51                 mov     [ebp+var_10], eax
.text$mn:00002A54                 mov     [ebp+var_4], 0
.text$mn:00002A5B                 cmp     [ebp+var_10], 0
.text$mn:00002A5F                 jz      short loc_2A7B
.text$mn:00002A61                 mov     ecx, [ebp+arg_4]
.text$mn:00002A64                 push    ecx
.text$mn:00002A65                 call    ??$forward@AAVUserCommand@@@std@@YAAAVUserCommand@@AAV1@@Z ; std::forward<UserCommand &>(UserCommand &)
.text$mn:00002A6A                 add     esp, 4
.text$mn:00002A6D                 push    eax             ; struct CommandShortcut *
.text$mn:00002A6E                 mov     ecx, [ebp+var_10]
.text$mn:00002A71                 call    ??0UserCommand@@QAE@ABV0@@Z ; UserCommand::UserCommand(UserCommand const &)
.text$mn:00002A76                 mov     [ebp+var_14], eax
.text$mn:00002A79                 jmp     short loc_2A82
.text$mn:00002A7B ; ---------------------------------------------------------------------------
.text$mn:00002A7B
.text$mn:00002A7B loc_2A7B:                               ; CODE XREF: std::allocator<UserCommand>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)+47j
.text$mn:00002A7B                 mov     [ebp+var_14], 0
.text$mn:00002A82
.text$mn:00002A82 loc_2A82:                               ; CODE XREF: std::allocator<UserCommand>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)+61j
.text$mn:00002A82                 mov     edx, [ebp+var_14]
.text$mn:00002A85                 mov     [ebp+var_1C], edx
.text$mn:00002A88                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A8F                 mov     ecx, [ebp+var_C]
.text$mn:00002A92                 mov     large fs:0, ecx
.text$mn:00002A99                 pop     ecx
.text$mn:00002A9A                 mov     esp, ebp
.text$mn:00002A9C                 pop     ebp
.text$mn:00002A9D                 retn    8
.text$mn:00002A9D ??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z endp
.text$mn:00002A9D
.text$mn:00002A9D _text$mn        ends
.text$mn:00002A9D
.text$x:00002AA0 ; ===========================================================================
.text$x:00002AA0
.text$x:00002AA0 ; Segment type: Pure code
.text$x:00002AA0 ; Segment permissions: Read/Execute
.text$x:00002AA0 _text$x         segment para public 'CODE' use32
.text$x:00002AA0                 assume cs:_text$x
.text$x:00002AA0                 ;org 2AA0h
.text$x:00002AA0 ; COMDAT (pick associative to section at 2A18)
.text$x:00002AA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002AA0
.text$x:00002AA0 ; =============== S U B R O U T I N E =======================================
.text$x:00002AA0
.text$x:00002AA0
.text$x:00002AA0 __unwindfunclet$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z$0 proc near
.text$x:00002AA0                                         ; DATA XREF: .xdata$x:00008D5Co
.text$x:00002AA0                 mov     eax, [ebp+8]
.text$x:00002AA3                 push    eax
.text$x:00002AA4                 mov     eax, [ebp-10h]
.text$x:00002AA7                 push    eax             ; void *
.text$x:00002AA8                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002AAD                 add     esp, 8
.text$x:00002AB0                 retn
.text$x:00002AB0 __unwindfunclet$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z$0 endp
.text$x:00002AB0
.text$x:00002AB1
.text$x:00002AB1 ; =============== S U B R O U T I N E =======================================
.text$x:00002AB1
.text$x:00002AB1
.text$x:00002AB1 __ehhandler$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z proc near
.text$x:00002AB1                                         ; DATA XREF: std::allocator<UserCommand>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)+5o
.text$x:00002AB1
.text$x:00002AB1 arg_4           = dword ptr  8
.text$x:00002AB1
.text$x:00002AB1                 mov     edx, [esp+arg_4]
.text$x:00002AB5                 lea     eax, [edx+0Ch]
.text$x:00002AB8                 mov     ecx, [edx-14h]
.text$x:00002ABB                 xor     ecx, eax
.text$x:00002ABD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AC2                 mov     eax, offset __ehfuncinfo$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z
.text$x:00002AC7                 jmp     ___CxxFrameHandler3
.text$x:00002AC7 __ehhandler$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z endp
.text$x:00002AC7
.text$x:00002AC7 _text$x         ends
.text$x:00002AC7
.text$mn:00002ACC ; ===========================================================================
.text$mn:00002ACC
.text$mn:00002ACC ; Segment type: Pure code
.text$mn:00002ACC ; Segment permissions: Read/Execute
.text$mn:00002ACC _text$mn        segment para public 'CODE' use32
.text$mn:00002ACC                 assume cs:_text$mn
.text$mn:00002ACC                 ;org 2ACCh
.text$mn:00002ACC ; COMDAT (pick any)
.text$mn:00002ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002ACC
.text$mn:00002ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00002ACC
.text$mn:00002ACC ; Attributes: bp-based frame
.text$mn:00002ACC
.text$mn:00002ACC ; int __cdecl std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand &>(int, void *, int)
.text$mn:00002ACC                 public ??$construct@VUserCommand@@AAV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@AAV3@@Z
.text$mn:00002ACC ??$construct@VUserCommand@@AAV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@AAV3@@Z proc near
.text$mn:00002ACC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)+1Cp
.text$mn:00002ACC
.text$mn:00002ACC arg_0           = dword ptr  8
.text$mn:00002ACC arg_4           = dword ptr  0Ch
.text$mn:00002ACC arg_8           = dword ptr  10h
.text$mn:00002ACC
.text$mn:00002ACC                 push    ebp
.text$mn:00002ACD                 mov     ebp, esp
.text$mn:00002ACF                 mov     eax, [ebp+arg_8]
.text$mn:00002AD2                 push    eax
.text$mn:00002AD3                 call    ??$forward@AAVUserCommand@@@std@@YAAAVUserCommand@@AAV1@@Z ; std::forward<UserCommand &>(UserCommand &)
.text$mn:00002AD8                 add     esp, 4
.text$mn:00002ADB                 push    eax             ; int
.text$mn:00002ADC                 mov     ecx, [ebp+arg_4]
.text$mn:00002ADF                 push    ecx             ; void *
.text$mn:00002AE0                 mov     ecx, [ebp+arg_0]
.text$mn:00002AE3                 call    ??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z ; std::allocator<UserCommand>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)
.text$mn:00002AE8                 pop     ebp
.text$mn:00002AE9                 retn
.text$mn:00002AE9 ??$construct@VUserCommand@@AAV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@AAV3@@Z endp
.text$mn:00002AE9
.text$mn:00002AE9 ; ---------------------------------------------------------------------------
.text$mn:00002AEA                 align 4
.text$mn:00002AEA _text$mn        ends
.text$mn:00002AEA
.text$mn:00002AEC ; ===========================================================================
.text$mn:00002AEC
.text$mn:00002AEC ; Segment type: Pure code
.text$mn:00002AEC ; Segment permissions: Read/Execute
.text$mn:00002AEC _text$mn        segment para public 'CODE' use32
.text$mn:00002AEC                 assume cs:_text$mn
.text$mn:00002AEC                 ;org 2AECh
.text$mn:00002AEC ; COMDAT (pick any)
.text$mn:00002AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AEC
.text$mn:00002AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002AEC
.text$mn:00002AEC ; Attributes: bp-based frame
.text$mn:00002AEC
.text$mn:00002AEC ; int __stdcall std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(void *, int)
.text$mn:00002AEC                 public ??$construct@VUserCommand@@ABV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@ABV2@@Z
.text$mn:00002AEC ??$construct@VUserCommand@@ABV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@ABV2@@Z proc near
.text$mn:00002AEC                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+F6p
.text$mn:00002AEC
.text$mn:00002AEC var_4           = dword ptr -4
.text$mn:00002AEC arg_0           = dword ptr  8
.text$mn:00002AEC arg_4           = dword ptr  0Ch
.text$mn:00002AEC
.text$mn:00002AEC                 push    ebp
.text$mn:00002AED                 mov     ebp, esp
.text$mn:00002AEF                 push    ecx
.text$mn:00002AF0                 mov     [ebp+var_4], ecx
.text$mn:00002AF3                 mov     eax, [ebp+arg_4]
.text$mn:00002AF6                 push    eax
.text$mn:00002AF7                 call    ??$forward@ABVUserCommand@@@std@@YAABVUserCommand@@ABV1@@Z ; std::forward<UserCommand const &>(UserCommand const &)
.text$mn:00002AFC                 add     esp, 4
.text$mn:00002AFF                 push    eax             ; int
.text$mn:00002B00                 mov     ecx, [ebp+arg_0]
.text$mn:00002B03                 push    ecx             ; void *
.text$mn:00002B04                 mov     edx, [ebp+var_4]
.text$mn:00002B07                 push    edx             ; int
.text$mn:00002B08                 call    ??$construct@VUserCommand@@ABV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@ABV3@@Z ; std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(std::allocator<UserCommand> &,UserCommand *,UserCommand const &)
.text$mn:00002B0D                 add     esp, 0Ch
.text$mn:00002B10                 mov     esp, ebp
.text$mn:00002B12                 pop     ebp
.text$mn:00002B13                 retn    8
.text$mn:00002B13 ??$construct@VUserCommand@@ABV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@ABV2@@Z endp
.text$mn:00002B13
.text$mn:00002B13 ; ---------------------------------------------------------------------------
.text$mn:00002B16                 align 4
.text$mn:00002B16 _text$mn        ends
.text$mn:00002B16
.text$mn:00002B18 ; ===========================================================================
.text$mn:00002B18
.text$mn:00002B18 ; Segment type: Pure code
.text$mn:00002B18 ; Segment permissions: Read/Execute
.text$mn:00002B18 _text$mn        segment para public 'CODE' use32
.text$mn:00002B18                 assume cs:_text$mn
.text$mn:00002B18                 ;org 2B18h
.text$mn:00002B18 ; COMDAT (pick any)
.text$mn:00002B18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B18
.text$mn:00002B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B18
.text$mn:00002B18 ; Attributes: bp-based frame
.text$mn:00002B18
.text$mn:00002B18 ; int __cdecl std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(int, void *, int)
.text$mn:00002B18                 public ??$construct@VUserCommand@@ABV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@ABV3@@Z
.text$mn:00002B18 ??$construct@VUserCommand@@ABV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@ABV3@@Z proc near
.text$mn:00002B18                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(UserCommand *,UserCommand const &)+1Cp
.text$mn:00002B18
.text$mn:00002B18 arg_0           = dword ptr  8
.text$mn:00002B18 arg_4           = dword ptr  0Ch
.text$mn:00002B18 arg_8           = dword ptr  10h
.text$mn:00002B18
.text$mn:00002B18                 push    ebp
.text$mn:00002B19                 mov     ebp, esp
.text$mn:00002B1B                 mov     eax, [ebp+arg_8]
.text$mn:00002B1E                 push    eax
.text$mn:00002B1F                 call    ??$forward@ABVUserCommand@@@std@@YAABVUserCommand@@ABV1@@Z ; std::forward<UserCommand const &>(UserCommand const &)
.text$mn:00002B24                 add     esp, 4
.text$mn:00002B27                 push    eax             ; struct CommandShortcut *
.text$mn:00002B28                 mov     ecx, [ebp+arg_4]
.text$mn:00002B2B                 push    ecx             ; void *
.text$mn:00002B2C                 mov     ecx, [ebp+arg_0]
.text$mn:00002B2F                 call    ?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z ; std::allocator<UserCommand>::construct(UserCommand *,UserCommand const &)
.text$mn:00002B34                 pop     ebp
.text$mn:00002B35                 retn
.text$mn:00002B35 ??$construct@VUserCommand@@ABV1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@ABV3@@Z endp
.text$mn:00002B35
.text$mn:00002B35 ; ---------------------------------------------------------------------------
.text$mn:00002B36                 align 4
.text$mn:00002B36 _text$mn        ends
.text$mn:00002B36
.text$mn:00002B38 ; ===========================================================================
.text$mn:00002B38
.text$mn:00002B38 ; Segment type: Pure code
.text$mn:00002B38 ; Segment permissions: Read/Execute
.text$mn:00002B38 _text$mn        segment para public 'CODE' use32
.text$mn:00002B38                 assume cs:_text$mn
.text$mn:00002B38                 ;org 2B38h
.text$mn:00002B38 ; COMDAT (pick any)
.text$mn:00002B38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B38
.text$mn:00002B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B38
.text$mn:00002B38 ; Attributes: bp-based frame
.text$mn:00002B38
.text$mn:00002B38 ; int __stdcall std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand>(void *, int)
.text$mn:00002B38                 public ??$construct@VUserCommand@@V1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z
.text$mn:00002B38 ??$construct@VUserCommand@@V1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z proc near
.text$mn:00002B38                                         ; CODE XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+94p
.text$mn:00002B38
.text$mn:00002B38 var_4           = dword ptr -4
.text$mn:00002B38 arg_0           = dword ptr  8
.text$mn:00002B38 arg_4           = dword ptr  0Ch
.text$mn:00002B38
.text$mn:00002B38                 push    ebp
.text$mn:00002B39                 mov     ebp, esp
.text$mn:00002B3B                 push    ecx
.text$mn:00002B3C                 mov     [ebp+var_4], ecx
.text$mn:00002B3F                 mov     eax, [ebp+arg_4]
.text$mn:00002B42                 push    eax
.text$mn:00002B43                 call    ??$forward@VUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z ; std::forward<UserCommand>(UserCommand &)
.text$mn:00002B48                 add     esp, 4
.text$mn:00002B4B                 push    eax             ; int
.text$mn:00002B4C                 mov     ecx, [ebp+arg_0]
.text$mn:00002B4F                 push    ecx             ; void *
.text$mn:00002B50                 mov     edx, [ebp+var_4]
.text$mn:00002B53                 push    edx             ; int
.text$mn:00002B54                 call    ??$construct@VUserCommand@@V1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@$$QAV3@@Z ; std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand>(std::allocator<UserCommand> &,UserCommand *,UserCommand &&)
.text$mn:00002B59                 add     esp, 0Ch
.text$mn:00002B5C                 mov     esp, ebp
.text$mn:00002B5E                 pop     ebp
.text$mn:00002B5F                 retn    8
.text$mn:00002B5F ??$construct@VUserCommand@@V1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z endp
.text$mn:00002B5F
.text$mn:00002B5F ; ---------------------------------------------------------------------------
.text$mn:00002B62                 align 4
.text$mn:00002B62 _text$mn        ends
.text$mn:00002B62
.text$mn:00002B64 ; ===========================================================================
.text$mn:00002B64
.text$mn:00002B64 ; Segment type: Pure code
.text$mn:00002B64 ; Segment permissions: Read/Execute
.text$mn:00002B64 _text$mn        segment para public 'CODE' use32
.text$mn:00002B64                 assume cs:_text$mn
.text$mn:00002B64                 ;org 2B64h
.text$mn:00002B64 ; COMDAT (pick any)
.text$mn:00002B64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B64
.text$mn:00002B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B64
.text$mn:00002B64 ; Attributes: bp-based frame
.text$mn:00002B64
.text$mn:00002B64 ; int __stdcall std::allocator<UserCommand>::construct<UserCommand,UserCommand>(void *, int)
.text$mn:00002B64                 public ??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z
.text$mn:00002B64 ??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z proc near
.text$mn:00002B64                                         ; CODE XREF: std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand>(std::allocator<UserCommand> &,UserCommand *,UserCommand &&)+17p
.text$mn:00002B64
.text$mn:00002B64 var_1C          = dword ptr -1Ch
.text$mn:00002B64 var_18          = dword ptr -18h
.text$mn:00002B64 var_14          = dword ptr -14h
.text$mn:00002B64 var_10          = dword ptr -10h
.text$mn:00002B64 var_C           = dword ptr -0Ch
.text$mn:00002B64 var_4           = dword ptr -4
.text$mn:00002B64 arg_0           = dword ptr  8
.text$mn:00002B64 arg_4           = dword ptr  0Ch
.text$mn:00002B64
.text$mn:00002B64                 push    ebp
.text$mn:00002B65                 mov     ebp, esp
.text$mn:00002B67                 push    0FFFFFFFFh
.text$mn:00002B69                 push    offset __ehhandler$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z
.text$mn:00002B6E                 mov     eax, large fs:0
.text$mn:00002B74                 push    eax
.text$mn:00002B75                 sub     esp, 10h
.text$mn:00002B78                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B7D                 xor     eax, ebp
.text$mn:00002B7F                 push    eax
.text$mn:00002B80                 lea     eax, [ebp+var_C]
.text$mn:00002B83                 mov     large fs:0, eax
.text$mn:00002B89                 mov     [ebp+var_18], ecx
.text$mn:00002B8C                 mov     eax, [ebp+arg_0]
.text$mn:00002B8F                 push    eax             ; void *
.text$mn:00002B90                 push    148h            ; unsigned int
.text$mn:00002B95                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002B9A                 add     esp, 8
.text$mn:00002B9D                 mov     [ebp+var_10], eax
.text$mn:00002BA0                 mov     [ebp+var_4], 0
.text$mn:00002BA7                 cmp     [ebp+var_10], 0
.text$mn:00002BAB                 jz      short loc_2BC7
.text$mn:00002BAD                 mov     ecx, [ebp+arg_4]
.text$mn:00002BB0                 push    ecx
.text$mn:00002BB1                 call    ??$forward@VUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z ; std::forward<UserCommand>(UserCommand &)
.text$mn:00002BB6                 add     esp, 4
.text$mn:00002BB9                 push    eax             ; struct CommandShortcut *
.text$mn:00002BBA                 mov     ecx, [ebp+var_10]
.text$mn:00002BBD                 call    ??0UserCommand@@QAE@ABV0@@Z ; UserCommand::UserCommand(UserCommand const &)
.text$mn:00002BC2                 mov     [ebp+var_14], eax
.text$mn:00002BC5                 jmp     short loc_2BCE
.text$mn:00002BC7 ; ---------------------------------------------------------------------------
.text$mn:00002BC7
.text$mn:00002BC7 loc_2BC7:                               ; CODE XREF: std::allocator<UserCommand>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)+47j
.text$mn:00002BC7                 mov     [ebp+var_14], 0
.text$mn:00002BCE
.text$mn:00002BCE loc_2BCE:                               ; CODE XREF: std::allocator<UserCommand>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)+61j
.text$mn:00002BCE                 mov     edx, [ebp+var_14]
.text$mn:00002BD1                 mov     [ebp+var_1C], edx
.text$mn:00002BD4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BDB                 mov     ecx, [ebp+var_C]
.text$mn:00002BDE                 mov     large fs:0, ecx
.text$mn:00002BE5                 pop     ecx
.text$mn:00002BE6                 mov     esp, ebp
.text$mn:00002BE8                 pop     ebp
.text$mn:00002BE9                 retn    8
.text$mn:00002BE9 ??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z endp
.text$mn:00002BE9
.text$mn:00002BE9 _text$mn        ends
.text$mn:00002BE9
.text$x:00002BEC ; ===========================================================================
.text$x:00002BEC
.text$x:00002BEC ; Segment type: Pure code
.text$x:00002BEC ; Segment permissions: Read/Execute
.text$x:00002BEC _text$x         segment para public 'CODE' use32
.text$x:00002BEC                 assume cs:_text$x
.text$x:00002BEC                 ;org 2BECh
.text$x:00002BEC ; COMDAT (pick associative to section at 2B64)
.text$x:00002BEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BEC
.text$x:00002BEC ; =============== S U B R O U T I N E =======================================
.text$x:00002BEC
.text$x:00002BEC
.text$x:00002BEC __unwindfunclet$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z$0 proc near
.text$x:00002BEC                                         ; DATA XREF: .xdata$x:00008E38o
.text$x:00002BEC                 mov     eax, [ebp+8]
.text$x:00002BEF                 push    eax
.text$x:00002BF0                 mov     eax, [ebp-10h]
.text$x:00002BF3                 push    eax             ; void *
.text$x:00002BF4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00002BF9                 add     esp, 8
.text$x:00002BFC                 retn
.text$x:00002BFC __unwindfunclet$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z$0 endp
.text$x:00002BFC
.text$x:00002BFD
.text$x:00002BFD ; =============== S U B R O U T I N E =======================================
.text$x:00002BFD
.text$x:00002BFD
.text$x:00002BFD __ehhandler$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z proc near
.text$x:00002BFD                                         ; DATA XREF: std::allocator<UserCommand>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)+5o
.text$x:00002BFD
.text$x:00002BFD arg_4           = dword ptr  8
.text$x:00002BFD
.text$x:00002BFD                 mov     edx, [esp+arg_4]
.text$x:00002C01                 lea     eax, [edx+0Ch]
.text$x:00002C04                 mov     ecx, [edx-14h]
.text$x:00002C07                 xor     ecx, eax
.text$x:00002C09                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C0E                 mov     eax, offset __ehfuncinfo$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z
.text$x:00002C13                 jmp     ___CxxFrameHandler3
.text$x:00002C13 __ehhandler$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z endp
.text$x:00002C13
.text$x:00002C13 _text$x         ends
.text$x:00002C13
.text$mn:00002C18 ; ===========================================================================
.text$mn:00002C18
.text$mn:00002C18 ; Segment type: Pure code
.text$mn:00002C18 ; Segment permissions: Read/Execute
.text$mn:00002C18 _text$mn        segment para public 'CODE' use32
.text$mn:00002C18                 assume cs:_text$mn
.text$mn:00002C18                 ;org 2C18h
.text$mn:00002C18 ; COMDAT (pick any)
.text$mn:00002C18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C18
.text$mn:00002C18 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C18
.text$mn:00002C18 ; Attributes: bp-based frame
.text$mn:00002C18
.text$mn:00002C18 ; int __cdecl std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand>(int, void *, int)
.text$mn:00002C18                 public ??$construct@VUserCommand@@V1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@$$QAV3@@Z
.text$mn:00002C18 ??$construct@VUserCommand@@V1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@$$QAV3@@Z proc near
.text$mn:00002C18                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)+1Cp
.text$mn:00002C18
.text$mn:00002C18 arg_0           = dword ptr  8
.text$mn:00002C18 arg_4           = dword ptr  0Ch
.text$mn:00002C18 arg_8           = dword ptr  10h
.text$mn:00002C18
.text$mn:00002C18                 push    ebp
.text$mn:00002C19                 mov     ebp, esp
.text$mn:00002C1B                 mov     eax, [ebp+arg_8]
.text$mn:00002C1E                 push    eax
.text$mn:00002C1F                 call    ??$forward@VUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z ; std::forward<UserCommand>(UserCommand &)
.text$mn:00002C24                 add     esp, 4
.text$mn:00002C27                 push    eax             ; int
.text$mn:00002C28                 mov     ecx, [ebp+arg_4]
.text$mn:00002C2B                 push    ecx             ; void *
.text$mn:00002C2C                 mov     ecx, [ebp+arg_0]
.text$mn:00002C2F                 call    ??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z ; std::allocator<UserCommand>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)
.text$mn:00002C34                 pop     ebp
.text$mn:00002C35                 retn
.text$mn:00002C35 ??$construct@VUserCommand@@V1@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@$$QAV3@@Z endp
.text$mn:00002C35
.text$mn:00002C35 ; ---------------------------------------------------------------------------
.text$mn:00002C36                 align 4
.text$mn:00002C36 _text$mn        ends
.text$mn:00002C36
.text$mn:00002C38 ; ===========================================================================
.text$mn:00002C38
.text$mn:00002C38 ; Segment type: Pure code
.text$mn:00002C38 ; Segment permissions: Read/Execute
.text$mn:00002C38 _text$mn        segment para public 'CODE' use32
.text$mn:00002C38                 assume cs:_text$mn
.text$mn:00002C38                 ;org 2C38h
.text$mn:00002C38 ; COMDAT (pick any)
.text$mn:00002C38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C38
.text$mn:00002C38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C38
.text$mn:00002C38 ; Attributes: bp-based frame
.text$mn:00002C38
.text$mn:00002C38 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002C38                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00002C38 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00002C38                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00002C38
.text$mn:00002C38 var_4           = dword ptr -4
.text$mn:00002C38 arg_0           = dword ptr  8
.text$mn:00002C38
.text$mn:00002C38                 push    ebp
.text$mn:00002C39                 mov     ebp, esp
.text$mn:00002C3B                 push    ecx
.text$mn:00002C3C                 mov     [ebp+var_4], ecx
.text$mn:00002C3F                 mov     eax, [ebp+arg_0]
.text$mn:00002C42                 push    eax
.text$mn:00002C43                 mov     ecx, [ebp+var_4]
.text$mn:00002C46                 push    ecx
.text$mn:00002C47                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00002C4C                 add     esp, 8
.text$mn:00002C4F                 mov     esp, ebp
.text$mn:00002C51                 pop     ebp
.text$mn:00002C52                 retn    4
.text$mn:00002C52 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00002C52
.text$mn:00002C52 ; ---------------------------------------------------------------------------
.text$mn:00002C55                 align 4
.text$mn:00002C55 _text$mn        ends
.text$mn:00002C55
.text$mn:00002C58 ; ===========================================================================
.text$mn:00002C58
.text$mn:00002C58 ; Segment type: Pure code
.text$mn:00002C58 ; Segment permissions: Read/Execute
.text$mn:00002C58 _text$mn        segment para public 'CODE' use32
.text$mn:00002C58                 assume cs:_text$mn
.text$mn:00002C58                 ;org 2C58h
.text$mn:00002C58 ; COMDAT (pick any)
.text$mn:00002C58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C58
.text$mn:00002C58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C58
.text$mn:00002C58 ; Attributes: bp-based frame
.text$mn:00002C58
.text$mn:00002C58 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002C58                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00002C58 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00002C58                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00002C58
.text$mn:00002C58 var_4           = dword ptr -4
.text$mn:00002C58
.text$mn:00002C58                 push    ebp
.text$mn:00002C59                 mov     ebp, esp
.text$mn:00002C5B                 push    ecx
.text$mn:00002C5C                 mov     [ebp+var_4], ecx
.text$mn:00002C5F                 mov     esp, ebp
.text$mn:00002C61                 pop     ebp
.text$mn:00002C62                 retn    4
.text$mn:00002C62 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00002C62
.text$mn:00002C62 ; ---------------------------------------------------------------------------
.text$mn:00002C65                 align 4
.text$mn:00002C65 _text$mn        ends
.text$mn:00002C65
.text$mn:00002C68 ; ===========================================================================
.text$mn:00002C68
.text$mn:00002C68 ; Segment type: Pure code
.text$mn:00002C68 ; Segment permissions: Read/Execute
.text$mn:00002C68 _text$mn        segment para public 'CODE' use32
.text$mn:00002C68                 assume cs:_text$mn
.text$mn:00002C68                 ;org 2C68h
.text$mn:00002C68 ; COMDAT (pick any)
.text$mn:00002C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C68
.text$mn:00002C68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C68
.text$mn:00002C68 ; Attributes: bp-based frame
.text$mn:00002C68
.text$mn:00002C68 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00002C68                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00002C68 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00002C68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00002C68
.text$mn:00002C68 arg_0           = dword ptr  8
.text$mn:00002C68 arg_4           = dword ptr  0Ch
.text$mn:00002C68
.text$mn:00002C68                 push    ebp
.text$mn:00002C69                 mov     ebp, esp
.text$mn:00002C6B                 mov     eax, [ebp+arg_4]
.text$mn:00002C6E                 push    eax
.text$mn:00002C6F                 mov     ecx, [ebp+arg_0]
.text$mn:00002C72                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002C77                 pop     ebp
.text$mn:00002C78                 retn
.text$mn:00002C78 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00002C78
.text$mn:00002C78 ; ---------------------------------------------------------------------------
.text$mn:00002C79                 align 4
.text$mn:00002C79 _text$mn        ends
.text$mn:00002C79
.text$mn:00002C7C ; ===========================================================================
.text$mn:00002C7C
.text$mn:00002C7C ; Segment type: Pure code
.text$mn:00002C7C ; Segment permissions: Read/Execute
.text$mn:00002C7C _text$mn        segment para public 'CODE' use32
.text$mn:00002C7C                 assume cs:_text$mn
.text$mn:00002C7C                 ;org 2C7Ch
.text$mn:00002C7C ; COMDAT (pick any)
.text$mn:00002C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C7C
.text$mn:00002C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C7C
.text$mn:00002C7C ; Attributes: bp-based frame
.text$mn:00002C7C
.text$mn:00002C7C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002C7C                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00002C7C ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00002C7C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00002C7C
.text$mn:00002C7C var_4           = dword ptr -4
.text$mn:00002C7C arg_0           = dword ptr  8
.text$mn:00002C7C
.text$mn:00002C7C                 push    ebp
.text$mn:00002C7D                 mov     ebp, esp
.text$mn:00002C7F                 push    ecx
.text$mn:00002C80                 mov     [ebp+var_4], ecx
.text$mn:00002C83                 mov     eax, [ebp+arg_0]
.text$mn:00002C86                 push    eax
.text$mn:00002C87                 mov     ecx, [ebp+var_4]
.text$mn:00002C8A                 push    ecx
.text$mn:00002C8B                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00002C90                 add     esp, 8
.text$mn:00002C93                 mov     esp, ebp
.text$mn:00002C95                 pop     ebp
.text$mn:00002C96                 retn    4
.text$mn:00002C96 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:00002C96
.text$mn:00002C96 ; ---------------------------------------------------------------------------
.text$mn:00002C99                 align 4
.text$mn:00002C99 _text$mn        ends
.text$mn:00002C99
.text$mn:00002C9C ; ===========================================================================
.text$mn:00002C9C
.text$mn:00002C9C ; Segment type: Pure code
.text$mn:00002C9C ; Segment permissions: Read/Execute
.text$mn:00002C9C _text$mn        segment para public 'CODE' use32
.text$mn:00002C9C                 assume cs:_text$mn
.text$mn:00002C9C                 ;org 2C9Ch
.text$mn:00002C9C ; COMDAT (pick any)
.text$mn:00002C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C9C
.text$mn:00002C9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C9C
.text$mn:00002C9C ; Attributes: bp-based frame
.text$mn:00002C9C
.text$mn:00002C9C ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002C9C                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00002C9C ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00002C9C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00002C9C
.text$mn:00002C9C var_4           = dword ptr -4
.text$mn:00002C9C
.text$mn:00002C9C                 push    ebp
.text$mn:00002C9D                 mov     ebp, esp
.text$mn:00002C9F                 push    ecx
.text$mn:00002CA0                 mov     [ebp+var_4], ecx
.text$mn:00002CA3                 mov     esp, ebp
.text$mn:00002CA5                 pop     ebp
.text$mn:00002CA6                 retn    4
.text$mn:00002CA6 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:00002CA6
.text$mn:00002CA6 ; ---------------------------------------------------------------------------
.text$mn:00002CA9                 align 4
.text$mn:00002CA9 _text$mn        ends
.text$mn:00002CA9
.text$mn:00002CAC ; ===========================================================================
.text$mn:00002CAC
.text$mn:00002CAC ; Segment type: Pure code
.text$mn:00002CAC ; Segment permissions: Read/Execute
.text$mn:00002CAC _text$mn        segment para public 'CODE' use32
.text$mn:00002CAC                 assume cs:_text$mn
.text$mn:00002CAC                 ;org 2CACh
.text$mn:00002CAC ; COMDAT (pick any)
.text$mn:00002CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CAC
.text$mn:00002CAC ; =============== S U B R O U T I N E =======================================
.text$mn:00002CAC
.text$mn:00002CAC ; Attributes: bp-based frame
.text$mn:00002CAC
.text$mn:00002CAC ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00002CAC                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00002CAC ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00002CAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00002CAC
.text$mn:00002CAC arg_0           = dword ptr  8
.text$mn:00002CAC arg_4           = dword ptr  0Ch
.text$mn:00002CAC
.text$mn:00002CAC                 push    ebp
.text$mn:00002CAD                 mov     ebp, esp
.text$mn:00002CAF                 mov     eax, [ebp+arg_4]
.text$mn:00002CB2                 push    eax
.text$mn:00002CB3                 mov     ecx, [ebp+arg_0]
.text$mn:00002CB6                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00002CBB                 pop     ebp
.text$mn:00002CBC                 retn
.text$mn:00002CBC ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00002CBC
.text$mn:00002CBC ; ---------------------------------------------------------------------------
.text$mn:00002CBD                 align 10h
.text$mn:00002CBD _text$mn        ends
.text$mn:00002CBD
.text$mn:00002CC0 ; ===========================================================================
.text$mn:00002CC0
.text$mn:00002CC0 ; Segment type: Pure code
.text$mn:00002CC0 ; Segment permissions: Read/Execute
.text$mn:00002CC0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CC0                 assume cs:_text$mn
.text$mn:00002CC0                 ;org 2CC0h
.text$mn:00002CC0 ; COMDAT (pick any)
.text$mn:00002CC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CC0
.text$mn:00002CC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CC0
.text$mn:00002CC0 ; Attributes: bp-based frame
.text$mn:00002CC0
.text$mn:00002CC0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00002CC0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00002CC0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00002CC0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00002CC0                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:00002CC0
.text$mn:00002CC0 var_4           = dword ptr -4
.text$mn:00002CC0
.text$mn:00002CC0                 push    ebp
.text$mn:00002CC1                 mov     ebp, esp
.text$mn:00002CC3                 push    ecx
.text$mn:00002CC4                 mov     [ebp+var_4], ecx
.text$mn:00002CC7                 mov     esp, ebp
.text$mn:00002CC9                 pop     ebp
.text$mn:00002CCA                 retn    4
.text$mn:00002CCA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002CCA
.text$mn:00002CCA ; ---------------------------------------------------------------------------
.text$mn:00002CCD                 align 10h
.text$mn:00002CCD _text$mn        ends
.text$mn:00002CCD
.text$mn:00002CD0 ; ===========================================================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Segment type: Pure code
.text$mn:00002CD0 ; Segment permissions: Read/Execute
.text$mn:00002CD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CD0                 assume cs:_text$mn
.text$mn:00002CD0                 ;org 2CD0h
.text$mn:00002CD0 ; COMDAT (pick any)
.text$mn:00002CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CD0
.text$mn:00002CD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CD0
.text$mn:00002CD0 ; Attributes: bp-based frame
.text$mn:00002CD0
.text$mn:00002CD0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class UserCommand>>::destroy<class UserCommand>(class UserCommand *)
.text$mn:00002CD0                 public ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z
.text$mn:00002CD0 ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z proc near
.text$mn:00002CD0                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,std::_Nonscalar_ptr_iterator_tag)+1Fp
.text$mn:00002CD0                                         ; __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Cp
.text$mn:00002CD0
.text$mn:00002CD0 var_4           = dword ptr -4
.text$mn:00002CD0 arg_0           = dword ptr  8
.text$mn:00002CD0
.text$mn:00002CD0                 push    ebp
.text$mn:00002CD1                 mov     ebp, esp
.text$mn:00002CD3                 push    ecx
.text$mn:00002CD4                 mov     [ebp+var_4], ecx
.text$mn:00002CD7                 mov     eax, [ebp+arg_0]
.text$mn:00002CDA                 push    eax
.text$mn:00002CDB                 mov     ecx, [ebp+var_4]
.text$mn:00002CDE                 push    ecx
.text$mn:00002CDF                 call    ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z ; std::allocator_traits<std::allocator<UserCommand>>::destroy<UserCommand>(std::allocator<UserCommand> &,UserCommand *)
.text$mn:00002CE4                 add     esp, 8
.text$mn:00002CE7                 mov     esp, ebp
.text$mn:00002CE9                 pop     ebp
.text$mn:00002CEA                 retn    4
.text$mn:00002CEA ??$destroy@VUserCommand@@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@@Z endp
.text$mn:00002CEA
.text$mn:00002CEA ; ---------------------------------------------------------------------------
.text$mn:00002CED                 align 10h
.text$mn:00002CED _text$mn        ends
.text$mn:00002CED
.text$mn:00002CF0 ; ===========================================================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Segment type: Pure code
.text$mn:00002CF0 ; Segment permissions: Read/Execute
.text$mn:00002CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002CF0                 assume cs:_text$mn
.text$mn:00002CF0                 ;org 2CF0h
.text$mn:00002CF0 ; COMDAT (pick any)
.text$mn:00002CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CF0
.text$mn:00002CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CF0
.text$mn:00002CF0 ; Attributes: bp-based frame
.text$mn:00002CF0
.text$mn:00002CF0 ; public: void __thiscall std::allocator<class UserCommand>::destroy<class UserCommand>(class UserCommand *)
.text$mn:00002CF0                 public ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z
.text$mn:00002CF0 ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z proc near
.text$mn:00002CF0                                         ; CODE XREF: std::allocator_traits<std::allocator<UserCommand>>::destroy<UserCommand>(std::allocator<UserCommand> &,UserCommand *)+Ap
.text$mn:00002CF0
.text$mn:00002CF0 var_4           = dword ptr -4
.text$mn:00002CF0 arg_0           = dword ptr  8
.text$mn:00002CF0
.text$mn:00002CF0                 push    ebp
.text$mn:00002CF1                 mov     ebp, esp
.text$mn:00002CF3                 push    ecx
.text$mn:00002CF4                 mov     [ebp+var_4], ecx
.text$mn:00002CF7                 push    0
.text$mn:00002CF9                 mov     eax, [ebp+arg_0]
.text$mn:00002CFC                 mov     edx, [eax]
.text$mn:00002CFE                 mov     ecx, [ebp+arg_0]
.text$mn:00002D01                 mov     eax, [edx]
.text$mn:00002D03                 call    eax
.text$mn:00002D05                 mov     esp, ebp
.text$mn:00002D07                 pop     ebp
.text$mn:00002D08                 retn    4
.text$mn:00002D08 ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z endp
.text$mn:00002D08
.text$mn:00002D08 ; ---------------------------------------------------------------------------
.text$mn:00002D0B                 align 4
.text$mn:00002D0B _text$mn        ends
.text$mn:00002D0B
.text$mn:00002D0C ; ===========================================================================
.text$mn:00002D0C
.text$mn:00002D0C ; Segment type: Pure code
.text$mn:00002D0C ; Segment permissions: Read/Execute
.text$mn:00002D0C _text$mn        segment para public 'CODE' use32
.text$mn:00002D0C                 assume cs:_text$mn
.text$mn:00002D0C                 ;org 2D0Ch
.text$mn:00002D0C ; COMDAT (pick any)
.text$mn:00002D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D0C
.text$mn:00002D0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D0C
.text$mn:00002D0C ; Attributes: bp-based frame
.text$mn:00002D0C
.text$mn:00002D0C ; public: static void __cdecl std::allocator_traits<class std::allocator<class UserCommand>>::destroy<class UserCommand>(class std::allocator<class UserCommand> &, class UserCommand *)
.text$mn:00002D0C                 public ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z
.text$mn:00002D0C ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z proc near
.text$mn:00002D0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::destroy<UserCommand>(UserCommand *)+Fp
.text$mn:00002D0C
.text$mn:00002D0C arg_0           = dword ptr  8
.text$mn:00002D0C arg_4           = dword ptr  0Ch
.text$mn:00002D0C
.text$mn:00002D0C                 push    ebp
.text$mn:00002D0D                 mov     ebp, esp
.text$mn:00002D0F                 mov     eax, [ebp+arg_4]
.text$mn:00002D12                 push    eax
.text$mn:00002D13                 mov     ecx, [ebp+arg_0]
.text$mn:00002D16                 call    ??$destroy@VUserCommand@@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@@Z ; std::allocator<UserCommand>::destroy<UserCommand>(UserCommand *)
.text$mn:00002D1B                 pop     ebp
.text$mn:00002D1C                 retn
.text$mn:00002D1C ??$destroy@VUserCommand@@@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAXAAV?$allocator@VUserCommand@@@1@PAVUserCommand@@@Z endp
.text$mn:00002D1C
.text$mn:00002D1C ; ---------------------------------------------------------------------------
.text$mn:00002D1D                 align 10h
.text$mn:00002D1D _text$mn        ends
.text$mn:00002D1D
.text$mn:00002D20 ; ===========================================================================
.text$mn:00002D20
.text$mn:00002D20 ; Segment type: Pure code
.text$mn:00002D20 ; Segment permissions: Read/Execute
.text$mn:00002D20 _text$mn        segment para public 'CODE' use32
.text$mn:00002D20                 assume cs:_text$mn
.text$mn:00002D20                 ;org 2D20h
.text$mn:00002D20 ; COMDAT (pick any)
.text$mn:00002D20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D20
.text$mn:00002D20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D20
.text$mn:00002D20 ; Attributes: bp-based frame
.text$mn:00002D20
.text$mn:00002D20 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00002D20                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00002D20 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00002D20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00002D20                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00002D20
.text$mn:00002D20 arg_0           = dword ptr  8
.text$mn:00002D20
.text$mn:00002D20                 push    ebp
.text$mn:00002D21                 mov     ebp, esp
.text$mn:00002D23                 mov     eax, [ebp+arg_0]
.text$mn:00002D26                 pop     ebp
.text$mn:00002D27                 retn
.text$mn:00002D27 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002D27
.text$mn:00002D27 _text$mn        ends
.text$mn:00002D27
.text$mn:00002D28 ; ===========================================================================
.text$mn:00002D28
.text$mn:00002D28 ; Segment type: Pure code
.text$mn:00002D28 ; Segment permissions: Read/Execute
.text$mn:00002D28 _text$mn        segment para public 'CODE' use32
.text$mn:00002D28                 assume cs:_text$mn
.text$mn:00002D28                 ;org 2D28h
.text$mn:00002D28 ; COMDAT (pick any)
.text$mn:00002D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D28
.text$mn:00002D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D28
.text$mn:00002D28 ; Attributes: bp-based frame
.text$mn:00002D28
.text$mn:00002D28 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00002D28                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00002D28 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00002D28                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00002D28                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00002D28
.text$mn:00002D28 arg_0           = dword ptr  8
.text$mn:00002D28
.text$mn:00002D28                 push    ebp
.text$mn:00002D29                 mov     ebp, esp
.text$mn:00002D2B                 mov     eax, [ebp+arg_0]
.text$mn:00002D2E                 pop     ebp
.text$mn:00002D2F                 retn
.text$mn:00002D2F ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00002D2F
.text$mn:00002D2F _text$mn        ends
.text$mn:00002D2F
.text$mn:00002D30 ; ===========================================================================
.text$mn:00002D30
.text$mn:00002D30 ; Segment type: Pure code
.text$mn:00002D30 ; Segment permissions: Read/Execute
.text$mn:00002D30 _text$mn        segment para public 'CODE' use32
.text$mn:00002D30                 assume cs:_text$mn
.text$mn:00002D30                 ;org 2D30h
.text$mn:00002D30 ; COMDAT (pick any)
.text$mn:00002D30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D30
.text$mn:00002D30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D30
.text$mn:00002D30 ; Attributes: bp-based frame
.text$mn:00002D30
.text$mn:00002D30 ; class UserCommand & __cdecl std::forward<class UserCommand &>(class UserCommand &)
.text$mn:00002D30                 public ??$forward@AAVUserCommand@@@std@@YAAAVUserCommand@@AAV1@@Z
.text$mn:00002D30 ??$forward@AAVUserCommand@@@std@@YAAAVUserCommand@@AAV1@@Z proc near
.text$mn:00002D30                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)+Bp
.text$mn:00002D30                                         ; std::allocator<UserCommand>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)+4Dp ...
.text$mn:00002D30
.text$mn:00002D30 arg_0           = dword ptr  8
.text$mn:00002D30
.text$mn:00002D30                 push    ebp
.text$mn:00002D31                 mov     ebp, esp
.text$mn:00002D33                 mov     eax, [ebp+arg_0]
.text$mn:00002D36                 pop     ebp
.text$mn:00002D37                 retn
.text$mn:00002D37 ??$forward@AAVUserCommand@@@std@@YAAAVUserCommand@@AAV1@@Z endp
.text$mn:00002D37
.text$mn:00002D37 _text$mn        ends
.text$mn:00002D37
.text$mn:00002D38 ; ===========================================================================
.text$mn:00002D38
.text$mn:00002D38 ; Segment type: Pure code
.text$mn:00002D38 ; Segment permissions: Read/Execute
.text$mn:00002D38 _text$mn        segment para public 'CODE' use32
.text$mn:00002D38                 assume cs:_text$mn
.text$mn:00002D38                 ;org 2D38h
.text$mn:00002D38 ; COMDAT (pick any)
.text$mn:00002D38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D38
.text$mn:00002D38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D38
.text$mn:00002D38 ; Attributes: bp-based frame
.text$mn:00002D38
.text$mn:00002D38 ; class UserCommand const & __cdecl std::forward<class UserCommand const &>(class UserCommand const &)
.text$mn:00002D38                 public ??$forward@ABVUserCommand@@@std@@YAABVUserCommand@@ABV1@@Z
.text$mn:00002D38 ??$forward@ABVUserCommand@@@std@@YAABVUserCommand@@ABV1@@Z proc near
.text$mn:00002D38                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(UserCommand *,UserCommand const &)+Bp
.text$mn:00002D38                                         ; std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(std::allocator<UserCommand> &,UserCommand *,UserCommand const &)+7p
.text$mn:00002D38
.text$mn:00002D38 arg_0           = dword ptr  8
.text$mn:00002D38
.text$mn:00002D38                 push    ebp
.text$mn:00002D39                 mov     ebp, esp
.text$mn:00002D3B                 mov     eax, [ebp+arg_0]
.text$mn:00002D3E                 pop     ebp
.text$mn:00002D3F                 retn
.text$mn:00002D3F ??$forward@ABVUserCommand@@@std@@YAABVUserCommand@@ABV1@@Z endp
.text$mn:00002D3F
.text$mn:00002D3F _text$mn        ends
.text$mn:00002D3F
.text$mn:00002D40 ; ===========================================================================
.text$mn:00002D40
.text$mn:00002D40 ; Segment type: Pure code
.text$mn:00002D40 ; Segment permissions: Read/Execute
.text$mn:00002D40 _text$mn        segment para public 'CODE' use32
.text$mn:00002D40                 assume cs:_text$mn
.text$mn:00002D40                 ;org 2D40h
.text$mn:00002D40 ; COMDAT (pick any)
.text$mn:00002D40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D40
.text$mn:00002D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D40
.text$mn:00002D40 ; Attributes: bp-based frame
.text$mn:00002D40
.text$mn:00002D40 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002D40                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002D40 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002D40                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00002D40
.text$mn:00002D40 arg_0           = dword ptr  8
.text$mn:00002D40
.text$mn:00002D40                 push    ebp
.text$mn:00002D41                 mov     ebp, esp
.text$mn:00002D43                 mov     eax, [ebp+arg_0]
.text$mn:00002D46                 pop     ebp
.text$mn:00002D47                 retn
.text$mn:00002D47 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00002D47
.text$mn:00002D47 _text$mn        ends
.text$mn:00002D47
.text$mn:00002D48 ; ===========================================================================
.text$mn:00002D48
.text$mn:00002D48 ; Segment type: Pure code
.text$mn:00002D48 ; Segment permissions: Read/Execute
.text$mn:00002D48 _text$mn        segment para public 'CODE' use32
.text$mn:00002D48                 assume cs:_text$mn
.text$mn:00002D48                 ;org 2D48h
.text$mn:00002D48 ; COMDAT (pick any)
.text$mn:00002D48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D48
.text$mn:00002D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D48
.text$mn:00002D48 ; Attributes: bp-based frame
.text$mn:00002D48
.text$mn:00002D48 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> && __cdecl std::forward<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:00002D48                 public ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:00002D48 ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:00002D48                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+54p
.text$mn:00002D48                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+D6p
.text$mn:00002D48
.text$mn:00002D48 arg_0           = dword ptr  8
.text$mn:00002D48
.text$mn:00002D48                 push    ebp
.text$mn:00002D49                 mov     ebp, esp
.text$mn:00002D4B                 mov     eax, [ebp+arg_0]
.text$mn:00002D4E                 pop     ebp
.text$mn:00002D4F                 retn
.text$mn:00002D4F ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:00002D4F
.text$mn:00002D4F _text$mn        ends
.text$mn:00002D4F
.text$mn:00002D50 ; ===========================================================================
.text$mn:00002D50
.text$mn:00002D50 ; Segment type: Pure code
.text$mn:00002D50 ; Segment permissions: Read/Execute
.text$mn:00002D50 _text$mn        segment para public 'CODE' use32
.text$mn:00002D50                 assume cs:_text$mn
.text$mn:00002D50                 ;org 2D50h
.text$mn:00002D50 ; COMDAT (pick any)
.text$mn:00002D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D50
.text$mn:00002D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D50
.text$mn:00002D50 ; Attributes: bp-based frame
.text$mn:00002D50
.text$mn:00002D50 ; class UserCommand && __cdecl std::forward<class UserCommand>(class UserCommand &)
.text$mn:00002D50                 public ??$forward@VUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z
.text$mn:00002D50 ??$forward@VUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z proc near
.text$mn:00002D50                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)+Bp
.text$mn:00002D50                                         ; std::allocator<UserCommand>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)+4Dp ...
.text$mn:00002D50
.text$mn:00002D50 arg_0           = dword ptr  8
.text$mn:00002D50
.text$mn:00002D50                 push    ebp
.text$mn:00002D51                 mov     ebp, esp
.text$mn:00002D53                 mov     eax, [ebp+arg_0]
.text$mn:00002D56                 pop     ebp
.text$mn:00002D57                 retn
.text$mn:00002D57 ??$forward@VUserCommand@@@std@@YA$$QAVUserCommand@@AAV1@@Z endp
.text$mn:00002D57
.text$mn:00002D57 _text$mn        ends
.text$mn:00002D57
.text$mn:00002D58 ; ===========================================================================
.text$mn:00002D58
.text$mn:00002D58 ; Segment type: Pure code
.text$mn:00002D58 ; Segment permissions: Read/Execute
.text$mn:00002D58 _text$mn        segment para public 'CODE' use32
.text$mn:00002D58                 assume cs:_text$mn
.text$mn:00002D58                 ;org 2D58h
.text$mn:00002D58 ; COMDAT (pick any)
.text$mn:00002D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D58
.text$mn:00002D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D58
.text$mn:00002D58 ; Attributes: bp-based frame
.text$mn:00002D58
.text$mn:00002D58 ; class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> && __cdecl std::move<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &)
.text$mn:00002D58                 public ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z
.text$mn:00002D58 ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z proc near
.text$mn:00002D58                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)+37p
.text$mn:00002D58
.text$mn:00002D58 arg_0           = dword ptr  8
.text$mn:00002D58
.text$mn:00002D58                 push    ebp
.text$mn:00002D59                 mov     ebp, esp
.text$mn:00002D5B                 mov     eax, [ebp+arg_0]
.text$mn:00002D5E                 pop     ebp
.text$mn:00002D5F                 retn
.text$mn:00002D5F ??$move@AAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z endp
.text$mn:00002D5F
.text$mn:00002D5F _text$mn        ends
.text$mn:00002D5F
.text$mn:00002D60 ; ===========================================================================
.text$mn:00002D60
.text$mn:00002D60 ; Segment type: Pure code
.text$mn:00002D60 ; Segment permissions: Read/Execute
.text$mn:00002D60 _text$mn        segment para public 'CODE' use32
.text$mn:00002D60                 assume cs:_text$mn
.text$mn:00002D60                 ;org 2D60h
.text$mn:00002D60 ; COMDAT (pick any)
.text$mn:00002D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D60
.text$mn:00002D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D60
.text$mn:00002D60 ; Attributes: bp-based frame
.text$mn:00002D60
.text$mn:00002D60 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:00002D60                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002D60 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:00002D60                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Dp
.text$mn:00002D60
.text$mn:00002D60 var_10          = dword ptr -10h
.text$mn:00002D60 var_C           = dword ptr -0Ch
.text$mn:00002D60 var_4           = dword ptr -4
.text$mn:00002D60 arg_0           = dword ptr  8
.text$mn:00002D60
.text$mn:00002D60                 push    ebp
.text$mn:00002D61                 mov     ebp, esp
.text$mn:00002D63                 push    0FFFFFFFFh
.text$mn:00002D65                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:00002D6A                 mov     eax, large fs:0
.text$mn:00002D70                 push    eax
.text$mn:00002D71                 push    ecx
.text$mn:00002D72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D77                 xor     eax, ebp
.text$mn:00002D79                 push    eax
.text$mn:00002D7A                 lea     eax, [ebp+var_C]
.text$mn:00002D7D                 mov     large fs:0, eax
.text$mn:00002D83                 mov     [ebp+var_10], ecx
.text$mn:00002D86                 mov     eax, [ebp+arg_0]
.text$mn:00002D89                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002D8A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002D8D                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:00002D92                 mov     [ebp+var_4], 0
.text$mn:00002D99                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002DA0                 mov     eax, [ebp+var_10]
.text$mn:00002DA3                 mov     ecx, [ebp+var_C]
.text$mn:00002DA6                 mov     large fs:0, ecx
.text$mn:00002DAD                 pop     ecx
.text$mn:00002DAE                 mov     esp, ebp
.text$mn:00002DB0                 pop     ebp
.text$mn:00002DB1                 retn    4
.text$mn:00002DB1 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:00002DB1
.text$mn:00002DB1 _text$mn        ends
.text$mn:00002DB1
.text$x:00002DB4 ; ===========================================================================
.text$x:00002DB4
.text$x:00002DB4 ; Segment type: Pure code
.text$x:00002DB4 ; Segment permissions: Read/Execute
.text$x:00002DB4 _text$x         segment para public 'CODE' use32
.text$x:00002DB4                 assume cs:_text$x
.text$x:00002DB4                 ;org 2DB4h
.text$x:00002DB4 ; COMDAT (pick associative to section at 2D60)
.text$x:00002DB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DB4
.text$x:00002DB4 ; =============== S U B R O U T I N E =======================================
.text$x:00002DB4
.text$x:00002DB4
.text$x:00002DB4 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00002DB4                                         ; DATA XREF: .xdata$x:00008B5Co
.text$x:00002DB4                 mov     ecx, [ebp-10h]  ; this
.text$x:00002DB7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002DB7 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00002DB7
.text$x:00002DBC
.text$x:00002DBC ; =============== S U B R O U T I N E =======================================
.text$x:00002DBC
.text$x:00002DBC
.text$x:00002DBC __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00002DBC                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)+5o
.text$x:00002DBC
.text$x:00002DBC arg_4           = dword ptr  8
.text$x:00002DBC
.text$x:00002DBC                 mov     edx, [esp+arg_4]
.text$x:00002DC0                 lea     eax, [edx+0Ch]
.text$x:00002DC3                 mov     ecx, [edx-8]
.text$x:00002DC6                 xor     ecx, eax
.text$x:00002DC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DCD                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00002DD2                 jmp     ___CxxFrameHandler3
.text$x:00002DD2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00002DD2
.text$x:00002DD2 ; ---------------------------------------------------------------------------
.text$x:00002DD7                 align 4
.text$x:00002DD7 _text$x         ends
.text$x:00002DD7
.text$mn:00002DD8 ; ===========================================================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Segment type: Pure code
.text$mn:00002DD8 ; Segment permissions: Read/Execute
.text$mn:00002DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD8                 assume cs:_text$mn
.text$mn:00002DD8                 ;org 2DD8h
.text$mn:00002DD8 ; COMDAT (pick any)
.text$mn:00002DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DD8
.text$mn:00002DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD8
.text$mn:00002DD8 ; Attributes: bp-based frame
.text$mn:00002DD8
.text$mn:00002DD8 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:00002DD8                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002DD8 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00002DD8                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+29p
.text$mn:00002DD8
.text$mn:00002DD8 var_10          = dword ptr -10h
.text$mn:00002DD8 var_C           = dword ptr -0Ch
.text$mn:00002DD8 var_4           = dword ptr -4
.text$mn:00002DD8
.text$mn:00002DD8                 push    ebp
.text$mn:00002DD9                 mov     ebp, esp
.text$mn:00002DDB                 push    0FFFFFFFFh
.text$mn:00002DDD                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002DE2                 mov     eax, large fs:0
.text$mn:00002DE8                 push    eax
.text$mn:00002DE9                 push    ecx
.text$mn:00002DEA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DEF                 xor     eax, ebp
.text$mn:00002DF1                 push    eax
.text$mn:00002DF2                 lea     eax, [ebp+var_C]
.text$mn:00002DF5                 mov     large fs:0, eax
.text$mn:00002DFB                 mov     [ebp+var_10], ecx
.text$mn:00002DFE                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E01                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00002E06                 mov     [ebp+var_4], 0
.text$mn:00002E0D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E14                 mov     eax, [ebp+var_10]
.text$mn:00002E17                 mov     ecx, [ebp+var_C]
.text$mn:00002E1A                 mov     large fs:0, ecx
.text$mn:00002E21                 pop     ecx
.text$mn:00002E22                 mov     esp, ebp
.text$mn:00002E24                 pop     ebp
.text$mn:00002E25                 retn
.text$mn:00002E25 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00002E25
.text$mn:00002E25 ; ---------------------------------------------------------------------------
.text$mn:00002E26                 align 4
.text$mn:00002E26 _text$mn        ends
.text$mn:00002E26
.text$x:00002E28 ; ===========================================================================
.text$x:00002E28
.text$x:00002E28 ; Segment type: Pure code
.text$x:00002E28 ; Segment permissions: Read/Execute
.text$x:00002E28 _text$x         segment para public 'CODE' use32
.text$x:00002E28                 assume cs:_text$x
.text$x:00002E28                 ;org 2E28h
.text$x:00002E28 ; COMDAT (pick associative to section at 2DD8)
.text$x:00002E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E28
.text$x:00002E28 ; =============== S U B R O U T I N E =======================================
.text$x:00002E28
.text$x:00002E28
.text$x:00002E28 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002E28                                         ; DATA XREF: .xdata$x:00008B04o
.text$x:00002E28                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E2B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00002E2B __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00002E2B
.text$x:00002E30
.text$x:00002E30 ; =============== S U B R O U T I N E =======================================
.text$x:00002E30
.text$x:00002E30
.text$x:00002E30 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00002E30                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:00002E30
.text$x:00002E30 arg_4           = dword ptr  8
.text$x:00002E30
.text$x:00002E30                 mov     edx, [esp+arg_4]
.text$x:00002E34                 lea     eax, [edx+0Ch]
.text$x:00002E37                 mov     ecx, [edx-8]
.text$x:00002E3A                 xor     ecx, eax
.text$x:00002E3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E41                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00002E46                 jmp     ___CxxFrameHandler3
.text$x:00002E46 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00002E46
.text$x:00002E46 ; ---------------------------------------------------------------------------
.text$x:00002E4B                 align 4
.text$x:00002E4B _text$x         ends
.text$x:00002E4B
.text$mn:00002E4C ; ===========================================================================
.text$mn:00002E4C
.text$mn:00002E4C ; Segment type: Pure code
.text$mn:00002E4C ; Segment permissions: Read/Execute
.text$mn:00002E4C _text$mn        segment para public 'CODE' use32
.text$mn:00002E4C                 assume cs:_text$mn
.text$mn:00002E4C                 ;org 2E4Ch
.text$mn:00002E4C ; COMDAT (pick any)
.text$mn:00002E4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E4C
.text$mn:00002E4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E4C
.text$mn:00002E4C ; Attributes: bp-based frame
.text$mn:00002E4C
.text$mn:00002E4C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00002E4C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002E4C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00002E4C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00002E4C
.text$mn:00002E4C var_10          = dword ptr -10h
.text$mn:00002E4C var_C           = dword ptr -0Ch
.text$mn:00002E4C var_4           = dword ptr -4
.text$mn:00002E4C
.text$mn:00002E4C                 push    ebp
.text$mn:00002E4D                 mov     ebp, esp
.text$mn:00002E4F                 push    0FFFFFFFFh
.text$mn:00002E51                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002E56                 mov     eax, large fs:0
.text$mn:00002E5C                 push    eax
.text$mn:00002E5D                 push    ecx
.text$mn:00002E5E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E63                 xor     eax, ebp
.text$mn:00002E65                 push    eax
.text$mn:00002E66                 lea     eax, [ebp+var_C]
.text$mn:00002E69                 mov     large fs:0, eax
.text$mn:00002E6F                 mov     [ebp+var_10], ecx
.text$mn:00002E72                 mov     ecx, [ebp+var_10]
.text$mn:00002E75                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:00002E7A                 mov     [ebp+var_4], 0
.text$mn:00002E81                 mov     ecx, [ebp+var_10]
.text$mn:00002E84                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00002E89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E90                 mov     eax, [ebp+var_10]
.text$mn:00002E93                 mov     ecx, [ebp+var_C]
.text$mn:00002E96                 mov     large fs:0, ecx
.text$mn:00002E9D                 pop     ecx
.text$mn:00002E9E                 mov     esp, ebp
.text$mn:00002EA0                 pop     ebp
.text$mn:00002EA1                 retn    4
.text$mn:00002EA1 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:00002EA1
.text$mn:00002EA1 _text$mn        ends
.text$mn:00002EA1
.text$x:00002EA4 ; ===========================================================================
.text$x:00002EA4
.text$x:00002EA4 ; Segment type: Pure code
.text$x:00002EA4 ; Segment permissions: Read/Execute
.text$x:00002EA4 _text$x         segment para public 'CODE' use32
.text$x:00002EA4                 assume cs:_text$x
.text$x:00002EA4                 ;org 2EA4h
.text$x:00002EA4 ; COMDAT (pick associative to section at 2E4C)
.text$x:00002EA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002EA4
.text$x:00002EA4 ; =============== S U B R O U T I N E =======================================
.text$x:00002EA4
.text$x:00002EA4
.text$x:00002EA4 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:00002EA4                                         ; DATA XREF: .xdata$x:00008164o
.text$x:00002EA4                 mov     ecx, [ebp-10h]
.text$x:00002EA7                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00002EA7 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:00002EA7
.text$x:00002EAC
.text$x:00002EAC ; =============== S U B R O U T I N E =======================================
.text$x:00002EAC
.text$x:00002EAC
.text$x:00002EAC __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:00002EAC                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:00002EAC
.text$x:00002EAC arg_4           = dword ptr  8
.text$x:00002EAC
.text$x:00002EAC                 mov     edx, [esp+arg_4]
.text$x:00002EB0                 lea     eax, [edx+0Ch]
.text$x:00002EB3                 mov     ecx, [edx-8]
.text$x:00002EB6                 xor     ecx, eax
.text$x:00002EB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002EBD                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002EC2                 jmp     ___CxxFrameHandler3
.text$x:00002EC2 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002EC2
.text$x:00002EC2 ; ---------------------------------------------------------------------------
.text$x:00002EC7                 align 4
.text$x:00002EC7 _text$x         ends
.text$x:00002EC7
.text$mn:00002EC8 ; ===========================================================================
.text$mn:00002EC8
.text$mn:00002EC8 ; Segment type: Pure code
.text$mn:00002EC8 ; Segment permissions: Read/Execute
.text$mn:00002EC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002EC8                 assume cs:_text$mn
.text$mn:00002EC8                 ;org 2EC8h
.text$mn:00002EC8 ; COMDAT (pick any)
.text$mn:00002EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EC8
.text$mn:00002EC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EC8
.text$mn:00002EC8 ; Attributes: bp-based frame
.text$mn:00002EC8
.text$mn:00002EC8 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:00002EC8                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002EC8 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00002EC8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+38p
.text$mn:00002EC8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p ...
.text$mn:00002EC8
.text$mn:00002EC8 var_10          = dword ptr -10h
.text$mn:00002EC8 var_C           = dword ptr -0Ch
.text$mn:00002EC8 var_4           = dword ptr -4
.text$mn:00002EC8
.text$mn:00002EC8                 push    ebp
.text$mn:00002EC9                 mov     ebp, esp
.text$mn:00002ECB                 push    0FFFFFFFFh
.text$mn:00002ECD                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00002ED2                 mov     eax, large fs:0
.text$mn:00002ED8                 push    eax
.text$mn:00002ED9                 push    ecx
.text$mn:00002EDA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002EDF                 xor     eax, ebp
.text$mn:00002EE1                 push    eax
.text$mn:00002EE2                 lea     eax, [ebp+var_C]
.text$mn:00002EE5                 mov     large fs:0, eax
.text$mn:00002EEB                 mov     [ebp+var_10], ecx
.text$mn:00002EEE                 mov     ecx, [ebp+var_10]
.text$mn:00002EF1                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00002EF6                 mov     [ebp+var_4], 0
.text$mn:00002EFD                 mov     ecx, [ebp+var_10]
.text$mn:00002F00                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00002F05                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F0C                 mov     eax, [ebp+var_10]
.text$mn:00002F0F                 mov     ecx, [ebp+var_C]
.text$mn:00002F12                 mov     large fs:0, ecx
.text$mn:00002F19                 pop     ecx
.text$mn:00002F1A                 mov     esp, ebp
.text$mn:00002F1C                 pop     ebp
.text$mn:00002F1D                 retn    4
.text$mn:00002F1D ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00002F1D
.text$mn:00002F1D _text$mn        ends
.text$mn:00002F1D
.text$x:00002F20 ; ===========================================================================
.text$x:00002F20
.text$x:00002F20 ; Segment type: Pure code
.text$x:00002F20 ; Segment permissions: Read/Execute
.text$x:00002F20 _text$x         segment para public 'CODE' use32
.text$x:00002F20                 assume cs:_text$x
.text$x:00002F20                 ;org 2F20h
.text$x:00002F20 ; COMDAT (pick associative to section at 2EC8)
.text$x:00002F20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F20
.text$x:00002F20 ; =============== S U B R O U T I N E =======================================
.text$x:00002F20
.text$x:00002F20
.text$x:00002F20 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00002F20                                         ; DATA XREF: .xdata$x:00008484o
.text$x:00002F20                 mov     ecx, [ebp-10h]
.text$x:00002F23                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00002F23 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00002F23
.text$x:00002F28
.text$x:00002F28 ; =============== S U B R O U T I N E =======================================
.text$x:00002F28
.text$x:00002F28
.text$x:00002F28 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:00002F28                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:00002F28
.text$x:00002F28 arg_4           = dword ptr  8
.text$x:00002F28
.text$x:00002F28                 mov     edx, [esp+arg_4]
.text$x:00002F2C                 lea     eax, [edx+0Ch]
.text$x:00002F2F                 mov     ecx, [edx-8]
.text$x:00002F32                 xor     ecx, eax
.text$x:00002F34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F39                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00002F3E                 jmp     ___CxxFrameHandler3
.text$x:00002F3E __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00002F3E
.text$x:00002F3E ; ---------------------------------------------------------------------------
.text$x:00002F43                 align 4
.text$x:00002F43 _text$x         ends
.text$x:00002F43
.text$mn:00002F44 ; ===========================================================================
.text$mn:00002F44
.text$mn:00002F44 ; Segment type: Pure code
.text$mn:00002F44 ; Segment permissions: Read/Execute
.text$mn:00002F44 _text$mn        segment para public 'CODE' use32
.text$mn:00002F44                 assume cs:_text$mn
.text$mn:00002F44                 ;org 2F44h
.text$mn:00002F44 ; COMDAT (pick any)
.text$mn:00002F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F44
.text$mn:00002F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F44
.text$mn:00002F44 ; Attributes: bp-based frame
.text$mn:00002F44
.text$mn:00002F44 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:00002F44                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002F44 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002F44                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+90p
.text$mn:00002F44                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+C7p ...
.text$mn:00002F44
.text$mn:00002F44 var_10          = dword ptr -10h
.text$mn:00002F44 var_C           = dword ptr -0Ch
.text$mn:00002F44 var_4           = dword ptr -4
.text$mn:00002F44 arg_0           = dword ptr  8
.text$mn:00002F44
.text$mn:00002F44                 push    ebp
.text$mn:00002F45                 mov     ebp, esp
.text$mn:00002F47                 push    0FFFFFFFFh
.text$mn:00002F49                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002F4E                 mov     eax, large fs:0
.text$mn:00002F54                 push    eax
.text$mn:00002F55                 push    ecx
.text$mn:00002F56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002F5B                 xor     eax, ebp
.text$mn:00002F5D                 push    eax
.text$mn:00002F5E                 lea     eax, [ebp+var_C]
.text$mn:00002F61                 mov     large fs:0, eax
.text$mn:00002F67                 mov     [ebp+var_10], ecx
.text$mn:00002F6A                 mov     eax, [ebp+arg_0]
.text$mn:00002F6D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002F6E                 mov     ecx, [ebp+var_10]
.text$mn:00002F71                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)
.text$mn:00002F76                 mov     [ebp+var_4], 0
.text$mn:00002F7D                 mov     ecx, [ebp+var_10]
.text$mn:00002F80                 mov     edx, [ebp+arg_0]
.text$mn:00002F83                 mov     eax, [edx+8]
.text$mn:00002F86                 mov     [ecx+8], eax
.text$mn:00002F89                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F90                 mov     eax, [ebp+var_10]
.text$mn:00002F93                 mov     ecx, [ebp+var_C]
.text$mn:00002F96                 mov     large fs:0, ecx
.text$mn:00002F9D                 pop     ecx
.text$mn:00002F9E                 mov     esp, ebp
.text$mn:00002FA0                 pop     ebp
.text$mn:00002FA1                 retn    4
.text$mn:00002FA1 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00002FA1
.text$mn:00002FA1 _text$mn        ends
.text$mn:00002FA1
.text$x:00002FA4 ; ===========================================================================
.text$x:00002FA4
.text$x:00002FA4 ; Segment type: Pure code
.text$x:00002FA4 ; Segment permissions: Read/Execute
.text$x:00002FA4 _text$x         segment para public 'CODE' use32
.text$x:00002FA4                 assume cs:_text$x
.text$x:00002FA4                 ;org 2FA4h
.text$x:00002FA4 ; COMDAT (pick associative to section at 2F44)
.text$x:00002FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002FA4
.text$x:00002FA4 ; =============== S U B R O U T I N E =======================================
.text$x:00002FA4
.text$x:00002FA4
.text$x:00002FA4 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002FA4                                         ; DATA XREF: .xdata$x:00008BE0o
.text$x:00002FA4                 mov     ecx, [ebp-10h]
.text$x:00002FA7                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:00002FA7 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00002FA7
.text$x:00002FAC
.text$x:00002FAC ; =============== S U B R O U T I N E =======================================
.text$x:00002FAC
.text$x:00002FAC
.text$x:00002FAC __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00002FAC                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:00002FAC
.text$x:00002FAC arg_4           = dword ptr  8
.text$x:00002FAC
.text$x:00002FAC                 mov     edx, [esp+arg_4]
.text$x:00002FB0                 lea     eax, [edx+0Ch]
.text$x:00002FB3                 mov     ecx, [edx-8]
.text$x:00002FB6                 xor     ecx, eax
.text$x:00002FB8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002FBD                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00002FC2                 jmp     ___CxxFrameHandler3
.text$x:00002FC2 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00002FC2
.text$x:00002FC2 ; ---------------------------------------------------------------------------
.text$x:00002FC7                 align 4
.text$x:00002FC7 _text$x         ends
.text$x:00002FC7
.text$mn:00002FC8 ; ===========================================================================
.text$mn:00002FC8
.text$mn:00002FC8 ; Segment type: Pure code
.text$mn:00002FC8 ; Segment permissions: Read/Execute
.text$mn:00002FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00002FC8                 assume cs:_text$mn
.text$mn:00002FC8                 ;org 2FC8h
.text$mn:00002FC8 ; COMDAT (pick any)
.text$mn:00002FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FC8
.text$mn:00002FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FC8
.text$mn:00002FC8 ; Attributes: bp-based frame
.text$mn:00002FC8
.text$mn:00002FC8 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:00002FC8                 public ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:00002FC8 ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$mn:00002FC8                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+31p
.text$mn:00002FC8
.text$mn:00002FC8 var_10          = dword ptr -10h
.text$mn:00002FC8 var_C           = dword ptr -0Ch
.text$mn:00002FC8 var_4           = dword ptr -4
.text$mn:00002FC8 arg_0           = dword ptr  8
.text$mn:00002FC8 arg_4           = dword ptr  0Ch
.text$mn:00002FC8
.text$mn:00002FC8                 push    ebp
.text$mn:00002FC9                 mov     ebp, esp
.text$mn:00002FCB                 push    0FFFFFFFFh
.text$mn:00002FCD                 push    offset __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$mn:00002FD2                 mov     eax, large fs:0
.text$mn:00002FD8                 push    eax
.text$mn:00002FD9                 push    ecx
.text$mn:00002FDA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FDF                 xor     eax, ebp
.text$mn:00002FE1                 push    eax
.text$mn:00002FE2                 lea     eax, [ebp+var_C]
.text$mn:00002FE5                 mov     large fs:0, eax
.text$mn:00002FEB                 mov     [ebp+var_10], ecx
.text$mn:00002FEE                 mov     ecx, [ebp+var_10]
.text$mn:00002FF1                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:00002FF6                 mov     [ebp+var_4], 0
.text$mn:00002FFD                 mov     eax, [ebp+arg_4]
.text$mn:00003000                 push    eax             ; struct std::_Container_base12 *
.text$mn:00003001                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003004                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00003009                 mov     ecx, [ebp+var_10]
.text$mn:0000300C                 mov     edx, [ebp+arg_0]
.text$mn:0000300F                 mov     [ecx+8], edx
.text$mn:00003012                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003019                 mov     eax, [ebp+var_10]
.text$mn:0000301C                 mov     ecx, [ebp+var_C]
.text$mn:0000301F                 mov     large fs:0, ecx
.text$mn:00003026                 pop     ecx
.text$mn:00003027                 mov     esp, ebp
.text$mn:00003029                 pop     ebp
.text$mn:0000302A                 retn    8
.text$mn:0000302A ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$mn:0000302A
.text$mn:0000302A ; ---------------------------------------------------------------------------
.text$mn:0000302D                 align 10h
.text$mn:0000302D _text$mn        ends
.text$mn:0000302D
.text$x:00003030 ; ===========================================================================
.text$x:00003030
.text$x:00003030 ; Segment type: Pure code
.text$x:00003030 ; Segment permissions: Read/Execute
.text$x:00003030 _text$x         segment para public 'CODE' use32
.text$x:00003030                 assume cs:_text$x
.text$x:00003030                 ;org 3030h
.text$x:00003030 ; COMDAT (pick associative to section at 2FC8)
.text$x:00003030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003030
.text$x:00003030 ; =============== S U B R O U T I N E =======================================
.text$x:00003030
.text$x:00003030
.text$x:00003030 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00003030                                         ; DATA XREF: .xdata$x:00008B88o
.text$x:00003030                 mov     ecx, [ebp-10h]
.text$x:00003033                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:00003033 __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0 endp
.text$x:00003033
.text$x:00003038
.text$x:00003038 ; =============== S U B R O U T I N E =======================================
.text$x:00003038
.text$x:00003038
.text$x:00003038 __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z proc near
.text$x:00003038                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+5o
.text$x:00003038
.text$x:00003038 arg_4           = dword ptr  8
.text$x:00003038
.text$x:00003038                 mov     edx, [esp+arg_4]
.text$x:0000303C                 lea     eax, [edx+0Ch]
.text$x:0000303F                 mov     ecx, [edx-8]
.text$x:00003042                 xor     ecx, eax
.text$x:00003044                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003049                 mov     eax, offset __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.text$x:0000304E                 jmp     ___CxxFrameHandler3
.text$x:0000304E __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z endp
.text$x:0000304E
.text$x:0000304E ; ---------------------------------------------------------------------------
.text$x:00003053                 align 4
.text$x:00003053 _text$x         ends
.text$x:00003053
.text$mn:00003054 ; ===========================================================================
.text$mn:00003054
.text$mn:00003054 ; Segment type: Pure code
.text$mn:00003054 ; Segment permissions: Read/Execute
.text$mn:00003054 _text$mn        segment para public 'CODE' use32
.text$mn:00003054                 assume cs:_text$mn
.text$mn:00003054                 ;org 3054h
.text$mn:00003054 ; COMDAT (pick any)
.text$mn:00003054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003054
.text$mn:00003054 ; =============== S U B R O U T I N E =======================================
.text$mn:00003054
.text$mn:00003054 ; Attributes: bp-based frame
.text$mn:00003054
.text$mn:00003054 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(struct std::_Iterator_base12 *)
.text$mn:00003054                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00003054 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00003054                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+3Bp
.text$mn:00003054                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+59p
.text$mn:00003054
.text$mn:00003054 var_10          = dword ptr -10h
.text$mn:00003054 var_C           = dword ptr -0Ch
.text$mn:00003054 var_4           = dword ptr -4
.text$mn:00003054 arg_0           = dword ptr  8
.text$mn:00003054
.text$mn:00003054                 push    ebp
.text$mn:00003055                 mov     ebp, esp
.text$mn:00003057                 push    0FFFFFFFFh
.text$mn:00003059                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000305E                 mov     eax, large fs:0
.text$mn:00003064                 push    eax
.text$mn:00003065                 push    ecx
.text$mn:00003066                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000306B                 xor     eax, ebp
.text$mn:0000306D                 push    eax
.text$mn:0000306E                 lea     eax, [ebp+var_C]
.text$mn:00003071                 mov     large fs:0, eax
.text$mn:00003077                 mov     [ebp+var_10], ecx
.text$mn:0000307A                 mov     eax, [ebp+arg_0]
.text$mn:0000307D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000307E                 mov     ecx, [ebp+var_10]
.text$mn:00003081                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00003086                 mov     [ebp+var_4], 0
.text$mn:0000308D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003094                 mov     eax, [ebp+var_10]
.text$mn:00003097                 mov     ecx, [ebp+var_C]
.text$mn:0000309A                 mov     large fs:0, ecx
.text$mn:000030A1                 pop     ecx
.text$mn:000030A2                 mov     esp, ebp
.text$mn:000030A4                 pop     ebp
.text$mn:000030A5                 retn    4
.text$mn:000030A5 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:000030A5
.text$mn:000030A5 _text$mn        ends
.text$mn:000030A5
.text$x:000030A8 ; ===========================================================================
.text$x:000030A8
.text$x:000030A8 ; Segment type: Pure code
.text$x:000030A8 ; Segment permissions: Read/Execute
.text$x:000030A8 _text$x         segment para public 'CODE' use32
.text$x:000030A8                 assume cs:_text$x
.text$x:000030A8                 ;org 30A8h
.text$x:000030A8 ; COMDAT (pick associative to section at 3054)
.text$x:000030A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030A8
.text$x:000030A8 ; =============== S U B R O U T I N E =======================================
.text$x:000030A8
.text$x:000030A8
.text$x:000030A8 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000030A8                                         ; DATA XREF: .xdata$x:00008C90o
.text$x:000030A8                 mov     ecx, [ebp-10h]
.text$x:000030AB                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000030AB __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:000030AB
.text$x:000030B0
.text$x:000030B0 ; =============== S U B R O U T I N E =======================================
.text$x:000030B0
.text$x:000030B0
.text$x:000030B0 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:000030B0                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:000030B0
.text$x:000030B0 arg_4           = dword ptr  8
.text$x:000030B0
.text$x:000030B0                 mov     edx, [esp+arg_4]
.text$x:000030B4                 lea     eax, [edx+0Ch]
.text$x:000030B7                 mov     ecx, [edx-8]
.text$x:000030BA                 xor     ecx, eax
.text$x:000030BC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030C1                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000030C6                 jmp     ___CxxFrameHandler3
.text$x:000030C6 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000030C6
.text$x:000030C6 ; ---------------------------------------------------------------------------
.text$x:000030CB                 align 4
.text$x:000030CB _text$x         ends
.text$x:000030CB
.text$mn:000030CC ; ===========================================================================
.text$mn:000030CC
.text$mn:000030CC ; Segment type: Pure code
.text$mn:000030CC ; Segment permissions: Read/Execute
.text$mn:000030CC _text$mn        segment para public 'CODE' use32
.text$mn:000030CC                 assume cs:_text$mn
.text$mn:000030CC                 ;org 30CCh
.text$mn:000030CC ; COMDAT (pick any)
.text$mn:000030CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030CC
.text$mn:000030CC ; =============== S U B R O U T I N E =======================================
.text$mn:000030CC
.text$mn:000030CC ; Attributes: bp-based frame
.text$mn:000030CC
.text$mn:000030CC ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(int, struct std::_Container_base12 *)
.text$mn:000030CC                 public ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:000030CC ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$mn:000030CC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+3Fp
.text$mn:000030CC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+48p
.text$mn:000030CC
.text$mn:000030CC var_10          = dword ptr -10h
.text$mn:000030CC var_C           = dword ptr -0Ch
.text$mn:000030CC var_4           = dword ptr -4
.text$mn:000030CC arg_0           = dword ptr  8
.text$mn:000030CC arg_4           = dword ptr  0Ch
.text$mn:000030CC
.text$mn:000030CC                 push    ebp
.text$mn:000030CD                 mov     ebp, esp
.text$mn:000030CF                 push    0FFFFFFFFh
.text$mn:000030D1                 push    offset __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$mn:000030D6                 mov     eax, large fs:0
.text$mn:000030DC                 push    eax
.text$mn:000030DD                 push    ecx
.text$mn:000030DE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030E3                 xor     eax, ebp
.text$mn:000030E5                 push    eax
.text$mn:000030E6                 lea     eax, [ebp+var_C]
.text$mn:000030E9                 mov     large fs:0, eax
.text$mn:000030EF                 mov     [ebp+var_10], ecx
.text$mn:000030F2                 mov     eax, [ebp+arg_4]
.text$mn:000030F5                 push    eax             ; struct std::_Container_base12 *
.text$mn:000030F6                 mov     ecx, [ebp+arg_0]
.text$mn:000030F9                 push    ecx             ; int
.text$mn:000030FA                 mov     ecx, [ebp+var_10]
.text$mn:000030FD                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)
.text$mn:00003102                 mov     [ebp+var_4], 0
.text$mn:00003109                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003110                 mov     eax, [ebp+var_10]
.text$mn:00003113                 mov     ecx, [ebp+var_C]
.text$mn:00003116                 mov     large fs:0, ecx
.text$mn:0000311D                 pop     ecx
.text$mn:0000311E                 mov     esp, ebp
.text$mn:00003120                 pop     ebp
.text$mn:00003121                 retn    8
.text$mn:00003121 ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$mn:00003121
.text$mn:00003121 _text$mn        ends
.text$mn:00003121
.text$x:00003124 ; ===========================================================================
.text$x:00003124
.text$x:00003124 ; Segment type: Pure code
.text$x:00003124 ; Segment permissions: Read/Execute
.text$x:00003124 _text$x         segment para public 'CODE' use32
.text$x:00003124                 assume cs:_text$x
.text$x:00003124                 ;org 3124h
.text$x:00003124 ; COMDAT (pick associative to section at 30CC)
.text$x:00003124                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003124
.text$x:00003124 ; =============== S U B R O U T I N E =======================================
.text$x:00003124
.text$x:00003124
.text$x:00003124 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 proc near
.text$x:00003124                                         ; DATA XREF: .xdata$x:00008C0Co
.text$x:00003124                 mov     ecx, [ebp-10h]
.text$x:00003127                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003127 __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0 endp
.text$x:00003127
.text$x:0000312C
.text$x:0000312C ; =============== S U B R O U T I N E =======================================
.text$x:0000312C
.text$x:0000312C
.text$x:0000312C __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z proc near
.text$x:0000312C                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)+5o
.text$x:0000312C
.text$x:0000312C arg_4           = dword ptr  8
.text$x:0000312C
.text$x:0000312C                 mov     edx, [esp+arg_4]
.text$x:00003130                 lea     eax, [edx+0Ch]
.text$x:00003133                 mov     ecx, [edx-8]
.text$x:00003136                 xor     ecx, eax
.text$x:00003138                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000313D                 mov     eax, offset __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.text$x:00003142                 jmp     ___CxxFrameHandler3
.text$x:00003142 __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z endp
.text$x:00003142
.text$x:00003142 ; ---------------------------------------------------------------------------
.text$x:00003147                 align 4
.text$x:00003147 _text$x         ends
.text$x:00003147
.text$mn:00003148 ; ===========================================================================
.text$mn:00003148
.text$mn:00003148 ; Segment type: Pure code
.text$mn:00003148 ; Segment permissions: Read/Execute
.text$mn:00003148 _text$mn        segment para public 'CODE' use32
.text$mn:00003148                 assume cs:_text$mn
.text$mn:00003148                 ;org 3148h
.text$mn:00003148 ; COMDAT (pick any)
.text$mn:00003148                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003148
.text$mn:00003148 ; =============== S U B R O U T I N E =======================================
.text$mn:00003148
.text$mn:00003148 ; Attributes: bp-based frame
.text$mn:00003148
.text$mn:00003148 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00003148                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00003148 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00003148                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00003148
.text$mn:00003148 var_10          = dword ptr -10h
.text$mn:00003148 var_C           = dword ptr -0Ch
.text$mn:00003148 var_4           = dword ptr -4
.text$mn:00003148
.text$mn:00003148                 push    ebp
.text$mn:00003149                 mov     ebp, esp
.text$mn:0000314B                 push    0FFFFFFFFh
.text$mn:0000314D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00003152                 mov     eax, large fs:0
.text$mn:00003158                 push    eax
.text$mn:00003159                 push    ecx
.text$mn:0000315A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000315F                 xor     eax, ebp
.text$mn:00003161                 push    eax
.text$mn:00003162                 lea     eax, [ebp+var_C]
.text$mn:00003165                 mov     large fs:0, eax
.text$mn:0000316B                 mov     [ebp+var_10], ecx
.text$mn:0000316E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003171                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00003176                 mov     [ebp+var_4], 0
.text$mn:0000317D                 mov     eax, [ebp+var_10]
.text$mn:00003180                 mov     dword ptr [eax+14h], 0
.text$mn:00003187                 mov     ecx, [ebp+var_10]
.text$mn:0000318A                 mov     dword ptr [ecx+18h], 0
.text$mn:00003191                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003198                 mov     eax, [ebp+var_10]
.text$mn:0000319B                 mov     ecx, [ebp+var_C]
.text$mn:0000319E                 mov     large fs:0, ecx
.text$mn:000031A5                 pop     ecx
.text$mn:000031A6                 mov     esp, ebp
.text$mn:000031A8                 pop     ebp
.text$mn:000031A9                 retn
.text$mn:000031A9 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000031A9
.text$mn:000031A9 ; ---------------------------------------------------------------------------
.text$mn:000031AA                 align 4
.text$mn:000031AA _text$mn        ends
.text$mn:000031AA
.text$x:000031AC ; ===========================================================================
.text$x:000031AC
.text$x:000031AC ; Segment type: Pure code
.text$x:000031AC ; Segment permissions: Read/Execute
.text$x:000031AC _text$x         segment para public 'CODE' use32
.text$x:000031AC                 assume cs:_text$x
.text$x:000031AC                 ;org 31ACh
.text$x:000031AC ; COMDAT (pick associative to section at 3148)
.text$x:000031AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000031AC
.text$x:000031AC ; =============== S U B R O U T I N E =======================================
.text$x:000031AC
.text$x:000031AC
.text$x:000031AC __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000031AC                                         ; DATA XREF: .xdata$x:0000810Co
.text$x:000031AC                 mov     ecx, [ebp-10h]  ; this
.text$x:000031AF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000031AF __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000031AF
.text$x:000031B4
.text$x:000031B4 ; =============== S U B R O U T I N E =======================================
.text$x:000031B4
.text$x:000031B4
.text$x:000031B4 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000031B4                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000031B4
.text$x:000031B4 arg_4           = dword ptr  8
.text$x:000031B4
.text$x:000031B4                 mov     edx, [esp+arg_4]
.text$x:000031B8                 lea     eax, [edx+0Ch]
.text$x:000031BB                 mov     ecx, [edx-8]
.text$x:000031BE                 xor     ecx, eax
.text$x:000031C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031C5                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000031CA                 jmp     ___CxxFrameHandler3
.text$x:000031CA __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000031CA
.text$x:000031CA ; ---------------------------------------------------------------------------
.text$x:000031CF                 align 10h
.text$x:000031CF _text$x         ends
.text$x:000031CF
.text$mn:000031D0 ; ===========================================================================
.text$mn:000031D0
.text$mn:000031D0 ; Segment type: Pure code
.text$mn:000031D0 ; Segment permissions: Read/Execute
.text$mn:000031D0 _text$mn        segment para public 'CODE' use32
.text$mn:000031D0                 assume cs:_text$mn
.text$mn:000031D0                 ;org 31D0h
.text$mn:000031D0 ; COMDAT (pick any)
.text$mn:000031D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031D0
.text$mn:000031D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031D0
.text$mn:000031D0 ; Attributes: bp-based frame
.text$mn:000031D0
.text$mn:000031D0 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:000031D0                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000031D0 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:000031D0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:000031D0
.text$mn:000031D0 var_10          = dword ptr -10h
.text$mn:000031D0 var_C           = dword ptr -0Ch
.text$mn:000031D0 var_4           = dword ptr -4
.text$mn:000031D0
.text$mn:000031D0                 push    ebp
.text$mn:000031D1                 mov     ebp, esp
.text$mn:000031D3                 push    0FFFFFFFFh
.text$mn:000031D5                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:000031DA                 mov     eax, large fs:0
.text$mn:000031E0                 push    eax
.text$mn:000031E1                 push    ecx
.text$mn:000031E2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000031E7                 xor     eax, ebp
.text$mn:000031E9                 push    eax
.text$mn:000031EA                 lea     eax, [ebp+var_C]
.text$mn:000031ED                 mov     large fs:0, eax
.text$mn:000031F3                 mov     [ebp+var_10], ecx
.text$mn:000031F6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000031F9                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000031FE                 mov     [ebp+var_4], 0
.text$mn:00003205                 mov     eax, [ebp+var_10]
.text$mn:00003208                 mov     dword ptr [eax+14h], 0
.text$mn:0000320F                 mov     ecx, [ebp+var_10]
.text$mn:00003212                 mov     dword ptr [ecx+18h], 0
.text$mn:00003219                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003220                 mov     eax, [ebp+var_10]
.text$mn:00003223                 mov     ecx, [ebp+var_C]
.text$mn:00003226                 mov     large fs:0, ecx
.text$mn:0000322D                 pop     ecx
.text$mn:0000322E                 mov     esp, ebp
.text$mn:00003230                 pop     ebp
.text$mn:00003231                 retn
.text$mn:00003231 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00003231
.text$mn:00003231 ; ---------------------------------------------------------------------------
.text$mn:00003232                 align 4
.text$mn:00003232 _text$mn        ends
.text$mn:00003232
.text$x:00003234 ; ===========================================================================
.text$x:00003234
.text$x:00003234 ; Segment type: Pure code
.text$x:00003234 ; Segment permissions: Read/Execute
.text$x:00003234 _text$x         segment para public 'CODE' use32
.text$x:00003234                 assume cs:_text$x
.text$x:00003234                 ;org 3234h
.text$x:00003234 ; COMDAT (pick associative to section at 31D0)
.text$x:00003234                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003234
.text$x:00003234 ; =============== S U B R O U T I N E =======================================
.text$x:00003234
.text$x:00003234
.text$x:00003234 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00003234                                         ; DATA XREF: .xdata$x:0000842Co
.text$x:00003234                 mov     ecx, [ebp-10h]  ; this
.text$x:00003237                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003237 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00003237
.text$x:0000323C
.text$x:0000323C ; =============== S U B R O U T I N E =======================================
.text$x:0000323C
.text$x:0000323C
.text$x:0000323C __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:0000323C                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:0000323C
.text$x:0000323C arg_4           = dword ptr  8
.text$x:0000323C
.text$x:0000323C                 mov     edx, [esp+arg_4]
.text$x:00003240                 lea     eax, [edx+0Ch]
.text$x:00003243                 mov     ecx, [edx-8]
.text$x:00003246                 xor     ecx, eax
.text$x:00003248                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000324D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00003252                 jmp     ___CxxFrameHandler3
.text$x:00003252 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00003252
.text$x:00003252 ; ---------------------------------------------------------------------------
.text$x:00003257                 align 4
.text$x:00003257 _text$x         ends
.text$x:00003257
.text$mn:00003258 ; ===========================================================================
.text$mn:00003258
.text$mn:00003258 ; Segment type: Pure code
.text$mn:00003258 ; Segment permissions: Read/Execute
.text$mn:00003258 _text$mn        segment para public 'CODE' use32
.text$mn:00003258                 assume cs:_text$mn
.text$mn:00003258                 ;org 3258h
.text$mn:00003258 ; COMDAT (pick any)
.text$mn:00003258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003258
.text$mn:00003258 ; =============== S U B R O U T I N E =======================================
.text$mn:00003258
.text$mn:00003258 ; Attributes: bp-based frame
.text$mn:00003258
.text$mn:00003258 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00003258                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00003258 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00003258                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00003258
.text$mn:00003258 var_4           = dword ptr -4
.text$mn:00003258
.text$mn:00003258                 push    ebp
.text$mn:00003259                 mov     ebp, esp
.text$mn:0000325B                 push    ecx
.text$mn:0000325C                 mov     [ebp+var_4], ecx
.text$mn:0000325F                 mov     ecx, [ebp+var_4]
.text$mn:00003262                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00003267                 mov     eax, [ebp+var_4]
.text$mn:0000326A                 mov     esp, ebp
.text$mn:0000326C                 pop     ebp
.text$mn:0000326D                 retn
.text$mn:0000326D ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:0000326D
.text$mn:0000326D ; ---------------------------------------------------------------------------
.text$mn:0000326E                 align 10h
.text$mn:0000326E _text$mn        ends
.text$mn:0000326E
.text$mn:00003270 ; ===========================================================================
.text$mn:00003270
.text$mn:00003270 ; Segment type: Pure code
.text$mn:00003270 ; Segment permissions: Read/Execute
.text$mn:00003270 _text$mn        segment para public 'CODE' use32
.text$mn:00003270                 assume cs:_text$mn
.text$mn:00003270                 ;org 3270h
.text$mn:00003270 ; COMDAT (pick any)
.text$mn:00003270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003270
.text$mn:00003270 ; =============== S U B R O U T I N E =======================================
.text$mn:00003270
.text$mn:00003270 ; Attributes: bp-based frame
.text$mn:00003270
.text$mn:00003270 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class UserCommand>>::_Wrap_alloc<class std::allocator<class UserCommand>>(void)
.text$mn:00003270                 public ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ
.text$mn:00003270 ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ proc near
.text$mn:00003270                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)+Ap
.text$mn:00003270
.text$mn:00003270 var_4           = dword ptr -4
.text$mn:00003270
.text$mn:00003270                 push    ebp
.text$mn:00003271                 mov     ebp, esp
.text$mn:00003273                 push    ecx
.text$mn:00003274                 mov     [ebp+var_4], ecx
.text$mn:00003277                 mov     ecx, [ebp+var_4]
.text$mn:0000327A                 call    ??0?$allocator@VUserCommand@@@std@@QAE@XZ ; std::allocator<UserCommand>::allocator<UserCommand>(void)
.text$mn:0000327F                 mov     eax, [ebp+var_4]
.text$mn:00003282                 mov     esp, ebp
.text$mn:00003284                 pop     ebp
.text$mn:00003285                 retn
.text$mn:00003285 ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ endp
.text$mn:00003285
.text$mn:00003285 ; ---------------------------------------------------------------------------
.text$mn:00003286                 align 4
.text$mn:00003286 _text$mn        ends
.text$mn:00003286
.text$mn:00003288 ; ===========================================================================
.text$mn:00003288
.text$mn:00003288 ; Segment type: Pure code
.text$mn:00003288 ; Segment permissions: Read/Execute
.text$mn:00003288 _text$mn        segment para public 'CODE' use32
.text$mn:00003288                 assume cs:_text$mn
.text$mn:00003288                 ;org 3288h
.text$mn:00003288 ; COMDAT (pick any)
.text$mn:00003288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003288
.text$mn:00003288 ; =============== S U B R O U T I N E =======================================
.text$mn:00003288
.text$mn:00003288 ; Attributes: bp-based frame
.text$mn:00003288
.text$mn:00003288 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(class std::allocator<wchar_t> const &)
.text$mn:00003288                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00003288 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:00003288                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00003288
.text$mn:00003288 var_4           = dword ptr -4
.text$mn:00003288 arg_0           = dword ptr  8
.text$mn:00003288
.text$mn:00003288                 push    ebp
.text$mn:00003289                 mov     ebp, esp
.text$mn:0000328B                 push    ecx
.text$mn:0000328C                 mov     [ebp+var_4], ecx
.text$mn:0000328F                 mov     eax, [ebp+arg_0]
.text$mn:00003292                 push    eax
.text$mn:00003293                 mov     ecx, [ebp+var_4]
.text$mn:00003296                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:0000329B                 mov     eax, [ebp+var_4]
.text$mn:0000329E                 mov     esp, ebp
.text$mn:000032A0                 pop     ebp
.text$mn:000032A1                 retn    4
.text$mn:000032A1 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:000032A1
.text$mn:000032A1 _text$mn        ends
.text$mn:000032A1
.text$mn:000032A4 ; ===========================================================================
.text$mn:000032A4
.text$mn:000032A4 ; Segment type: Pure code
.text$mn:000032A4 ; Segment permissions: Read/Execute
.text$mn:000032A4 _text$mn        segment para public 'CODE' use32
.text$mn:000032A4                 assume cs:_text$mn
.text$mn:000032A4                 ;org 32A4h
.text$mn:000032A4 ; COMDAT (pick any)
.text$mn:000032A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032A4
.text$mn:000032A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032A4
.text$mn:000032A4 ; Attributes: bp-based frame
.text$mn:000032A4
.text$mn:000032A4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:000032A4                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:000032A4 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:000032A4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:000032A4
.text$mn:000032A4 var_4           = dword ptr -4
.text$mn:000032A4
.text$mn:000032A4                 push    ebp
.text$mn:000032A5                 mov     ebp, esp
.text$mn:000032A7                 push    ecx
.text$mn:000032A8                 mov     [ebp+var_4], ecx
.text$mn:000032AB                 mov     ecx, [ebp+var_4]
.text$mn:000032AE                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000032B3                 mov     eax, [ebp+var_4]
.text$mn:000032B6                 mov     esp, ebp
.text$mn:000032B8                 pop     ebp
.text$mn:000032B9                 retn
.text$mn:000032B9 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:000032B9
.text$mn:000032B9 ; ---------------------------------------------------------------------------
.text$mn:000032BA                 align 4
.text$mn:000032BA _text$mn        ends
.text$mn:000032BA
.text$mn:000032BC ; ===========================================================================
.text$mn:000032BC
.text$mn:000032BC ; Segment type: Pure code
.text$mn:000032BC ; Segment permissions: Read/Execute
.text$mn:000032BC _text$mn        segment para public 'CODE' use32
.text$mn:000032BC                 assume cs:_text$mn
.text$mn:000032BC                 ;org 32BCh
.text$mn:000032BC ; COMDAT (pick any)
.text$mn:000032BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032BC
.text$mn:000032BC ; =============== S U B R O U T I N E =======================================
.text$mn:000032BC
.text$mn:000032BC ; Attributes: bp-based frame
.text$mn:000032BC
.text$mn:000032BC ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000032BC                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000032BC ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000032BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000032BC
.text$mn:000032BC var_4           = dword ptr -4
.text$mn:000032BC
.text$mn:000032BC                 push    ebp
.text$mn:000032BD                 mov     ebp, esp
.text$mn:000032BF                 push    ecx
.text$mn:000032C0                 mov     [ebp+var_4], ecx
.text$mn:000032C3                 mov     eax, [ebp+var_4]
.text$mn:000032C6                 mov     esp, ebp
.text$mn:000032C8                 pop     ebp
.text$mn:000032C9                 retn
.text$mn:000032C9 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000032C9
.text$mn:000032C9 ; ---------------------------------------------------------------------------
.text$mn:000032CA                 align 4
.text$mn:000032CA _text$mn        ends
.text$mn:000032CA
.text$mn:000032CC ; ===========================================================================
.text$mn:000032CC
.text$mn:000032CC ; Segment type: Pure code
.text$mn:000032CC ; Segment permissions: Read/Execute
.text$mn:000032CC _text$mn        segment para public 'CODE' use32
.text$mn:000032CC                 assume cs:_text$mn
.text$mn:000032CC                 ;org 32CCh
.text$mn:000032CC ; COMDAT (pick any)
.text$mn:000032CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032CC
.text$mn:000032CC ; =============== S U B R O U T I N E =======================================
.text$mn:000032CC
.text$mn:000032CC ; Attributes: bp-based frame
.text$mn:000032CC
.text$mn:000032CC ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000032CC                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000032CC ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000032CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000032CC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000032CC
.text$mn:000032CC var_4           = dword ptr -4
.text$mn:000032CC
.text$mn:000032CC                 push    ebp
.text$mn:000032CD                 mov     ebp, esp
.text$mn:000032CF                 push    ecx
.text$mn:000032D0                 mov     [ebp+var_4], ecx
.text$mn:000032D3                 mov     eax, [ebp+var_4]
.text$mn:000032D6                 mov     esp, ebp
.text$mn:000032D8                 pop     ebp
.text$mn:000032D9                 retn
.text$mn:000032D9 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000032D9
.text$mn:000032D9 ; ---------------------------------------------------------------------------
.text$mn:000032DA                 align 4
.text$mn:000032DA _text$mn        ends
.text$mn:000032DA
.text$mn:000032DC ; ===========================================================================
.text$mn:000032DC
.text$mn:000032DC ; Segment type: Pure code
.text$mn:000032DC ; Segment permissions: Read/Execute
.text$mn:000032DC _text$mn        segment para public 'CODE' use32
.text$mn:000032DC                 assume cs:_text$mn
.text$mn:000032DC                 ;org 32DCh
.text$mn:000032DC ; COMDAT (pick any)
.text$mn:000032DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032DC
.text$mn:000032DC ; =============== S U B R O U T I N E =======================================
.text$mn:000032DC
.text$mn:000032DC ; Attributes: bp-based frame
.text$mn:000032DC
.text$mn:000032DC ; public: __thiscall std::allocator<class UserCommand>::allocator<class UserCommand>(void)
.text$mn:000032DC                 public ??0?$allocator@VUserCommand@@@std@@QAE@XZ
.text$mn:000032DC ??0?$allocator@VUserCommand@@@std@@QAE@XZ proc near
.text$mn:000032DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::_Wrap_alloc<std::allocator<UserCommand>>(void)+Ap
.text$mn:000032DC
.text$mn:000032DC var_4           = dword ptr -4
.text$mn:000032DC
.text$mn:000032DC                 push    ebp
.text$mn:000032DD                 mov     ebp, esp
.text$mn:000032DF                 push    ecx
.text$mn:000032E0                 mov     [ebp+var_4], ecx
.text$mn:000032E3                 mov     eax, [ebp+var_4]
.text$mn:000032E6                 mov     esp, ebp
.text$mn:000032E8                 pop     ebp
.text$mn:000032E9                 retn
.text$mn:000032E9 ??0?$allocator@VUserCommand@@@std@@QAE@XZ endp
.text$mn:000032E9
.text$mn:000032E9 ; ---------------------------------------------------------------------------
.text$mn:000032EA                 align 4
.text$mn:000032EA _text$mn        ends
.text$mn:000032EA
.text$mn:000032EC ; ===========================================================================
.text$mn:000032EC
.text$mn:000032EC ; Segment type: Pure code
.text$mn:000032EC ; Segment permissions: Read/Execute
.text$mn:000032EC _text$mn        segment para public 'CODE' use32
.text$mn:000032EC                 assume cs:_text$mn
.text$mn:000032EC                 ;org 32ECh
.text$mn:000032EC ; COMDAT (pick any)
.text$mn:000032EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032EC
.text$mn:000032EC ; =============== S U B R O U T I N E =======================================
.text$mn:000032EC
.text$mn:000032EC ; Attributes: bp-based frame
.text$mn:000032EC
.text$mn:000032EC ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(class std::allocator<wchar_t> const &)
.text$mn:000032EC                 public ??0?$allocator@_W@std@@QAE@ABV01@@Z
.text$mn:000032EC ??0?$allocator@_W@std@@QAE@ABV01@@Z proc near
.text$mn:000032EC                                         ; CODE XREF: std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+Bp
.text$mn:000032EC                                         ; std::operator==<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)+18p ...
.text$mn:000032EC
.text$mn:000032EC var_4           = dword ptr -4
.text$mn:000032EC
.text$mn:000032EC                 push    ebp
.text$mn:000032ED                 mov     ebp, esp
.text$mn:000032EF                 push    ecx
.text$mn:000032F0                 mov     [ebp+var_4], ecx
.text$mn:000032F3                 mov     eax, [ebp+var_4]
.text$mn:000032F6                 mov     esp, ebp
.text$mn:000032F8                 pop     ebp
.text$mn:000032F9                 retn    4
.text$mn:000032F9 ??0?$allocator@_W@std@@QAE@ABV01@@Z endp
.text$mn:000032F9
.text$mn:000032F9 _text$mn        ends
.text$mn:000032F9
.text$mn:000032FC ; ===========================================================================
.text$mn:000032FC
.text$mn:000032FC ; Segment type: Pure code
.text$mn:000032FC ; Segment permissions: Read/Execute
.text$mn:000032FC _text$mn        segment para public 'CODE' use32
.text$mn:000032FC                 assume cs:_text$mn
.text$mn:000032FC                 ;org 32FCh
.text$mn:000032FC ; COMDAT (pick any)
.text$mn:000032FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032FC
.text$mn:000032FC ; =============== S U B R O U T I N E =======================================
.text$mn:000032FC
.text$mn:000032FC ; Attributes: bp-based frame
.text$mn:000032FC
.text$mn:000032FC ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000032FC                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:000032FC ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:000032FC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp ...
.text$mn:000032FC
.text$mn:000032FC var_4           = dword ptr -4
.text$mn:000032FC
.text$mn:000032FC                 push    ebp
.text$mn:000032FD                 mov     ebp, esp
.text$mn:000032FF                 push    ecx
.text$mn:00003300                 mov     [ebp+var_4], ecx
.text$mn:00003303                 mov     eax, [ebp+var_4]
.text$mn:00003306                 mov     esp, ebp
.text$mn:00003308                 pop     ebp
.text$mn:00003309                 retn
.text$mn:00003309 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:00003309
.text$mn:00003309 ; ---------------------------------------------------------------------------
.text$mn:0000330A                 align 4
.text$mn:0000330A _text$mn        ends
.text$mn:0000330A
.text$mn:0000330C ; ===========================================================================
.text$mn:0000330C
.text$mn:0000330C ; Segment type: Pure code
.text$mn:0000330C ; Segment permissions: Read/Execute
.text$mn:0000330C _text$mn        segment para public 'CODE' use32
.text$mn:0000330C                 assume cs:_text$mn
.text$mn:0000330C                 ;org 330Ch
.text$mn:0000330C ; COMDAT (pick any)
.text$mn:0000330C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000330C
.text$mn:0000330C ; =============== S U B R O U T I N E =======================================
.text$mn:0000330C
.text$mn:0000330C ; Attributes: bp-based frame
.text$mn:0000330C
.text$mn:0000330C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:0000330C                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:0000330C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:0000330C                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:0000330C                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:0000330C
.text$mn:0000330C var_14          = dword ptr -14h
.text$mn:0000330C var_D           = byte ptr -0Dh
.text$mn:0000330C var_C           = dword ptr -0Ch
.text$mn:0000330C var_4           = dword ptr -4
.text$mn:0000330C Str             = dword ptr  8
.text$mn:0000330C
.text$mn:0000330C                 push    ebp
.text$mn:0000330D                 mov     ebp, esp
.text$mn:0000330F                 push    0FFFFFFFFh
.text$mn:00003311                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00003316                 mov     eax, large fs:0
.text$mn:0000331C                 push    eax
.text$mn:0000331D                 sub     esp, 8
.text$mn:00003320                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003325                 xor     eax, ebp
.text$mn:00003327                 push    eax
.text$mn:00003328                 lea     eax, [ebp+var_C]
.text$mn:0000332B                 mov     large fs:0, eax
.text$mn:00003331                 mov     [ebp+var_14], ecx
.text$mn:00003334                 lea     ecx, [ebp+var_D]
.text$mn:00003337                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:0000333C                 push    eax
.text$mn:0000333D                 mov     ecx, [ebp+var_14]
.text$mn:00003340                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00003345                 mov     [ebp+var_4], 0
.text$mn:0000334C                 push    0               ; Size
.text$mn:0000334E                 push    0               ; char
.text$mn:00003350                 mov     ecx, [ebp+var_14]
.text$mn:00003353                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003358                 mov     eax, [ebp+Str]
.text$mn:0000335B                 push    eax             ; Str
.text$mn:0000335C                 mov     ecx, [ebp+var_14]
.text$mn:0000335F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00003364                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000336B                 mov     eax, [ebp+var_14]
.text$mn:0000336E                 mov     ecx, [ebp+var_C]
.text$mn:00003371                 mov     large fs:0, ecx
.text$mn:00003378                 pop     ecx
.text$mn:00003379                 mov     esp, ebp
.text$mn:0000337B                 pop     ebp
.text$mn:0000337C                 retn    4
.text$mn:0000337C ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:0000337C
.text$mn:0000337C ; ---------------------------------------------------------------------------
.text$mn:0000337F                 align 10h
.text$mn:0000337F _text$mn        ends
.text$mn:0000337F
.text$x:00003380 ; ===========================================================================
.text$x:00003380
.text$x:00003380 ; Segment type: Pure code
.text$x:00003380 ; Segment permissions: Read/Execute
.text$x:00003380 _text$x         segment para public 'CODE' use32
.text$x:00003380                 assume cs:_text$x
.text$x:00003380                 ;org 3380h
.text$x:00003380 ; COMDAT (pick associative to section at 330C)
.text$x:00003380                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003380
.text$x:00003380 ; =============== S U B R O U T I N E =======================================
.text$x:00003380
.text$x:00003380
.text$x:00003380 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00003380                                         ; DATA XREF: .xdata$x:000081BCo
.text$x:00003380                 mov     ecx, [ebp-14h]
.text$x:00003383                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00003383 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00003383
.text$x:00003388
.text$x:00003388 ; =============== S U B R O U T I N E =======================================
.text$x:00003388
.text$x:00003388
.text$x:00003388 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00003388                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00003388
.text$x:00003388 arg_4           = dword ptr  8
.text$x:00003388
.text$x:00003388                 mov     edx, [esp+arg_4]
.text$x:0000338C                 lea     eax, [edx+0Ch]
.text$x:0000338F                 mov     ecx, [edx-0Ch]
.text$x:00003392                 xor     ecx, eax
.text$x:00003394                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003399                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000339E                 jmp     ___CxxFrameHandler3
.text$x:0000339E __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000339E
.text$x:0000339E ; ---------------------------------------------------------------------------
.text$x:000033A3                 align 4
.text$x:000033A3 _text$x         ends
.text$x:000033A3
.text$mn:000033A4 ; ===========================================================================
.text$mn:000033A4
.text$mn:000033A4 ; Segment type: Pure code
.text$mn:000033A4 ; Segment permissions: Read/Execute
.text$mn:000033A4 _text$mn        segment para public 'CODE' use32
.text$mn:000033A4                 assume cs:_text$mn
.text$mn:000033A4                 ;org 33A4h
.text$mn:000033A4 ; COMDAT (pick any)
.text$mn:000033A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033A4
.text$mn:000033A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000033A4
.text$mn:000033A4 ; Attributes: bp-based frame
.text$mn:000033A4
.text$mn:000033A4 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:000033A4                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:000033A4 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$mn:000033A4                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)+43p
.text$mn:000033A4                                         ; std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7Fp ...
.text$mn:000033A4
.text$mn:000033A4 var_14          = dword ptr -14h
.text$mn:000033A4 var_D           = byte ptr -0Dh
.text$mn:000033A4 var_C           = dword ptr -0Ch
.text$mn:000033A4 var_4           = dword ptr -4
.text$mn:000033A4 arg_0           = dword ptr  8
.text$mn:000033A4
.text$mn:000033A4                 push    ebp
.text$mn:000033A5                 mov     ebp, esp
.text$mn:000033A7                 push    0FFFFFFFFh
.text$mn:000033A9                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$mn:000033AE                 mov     eax, large fs:0
.text$mn:000033B4                 push    eax
.text$mn:000033B5                 sub     esp, 8
.text$mn:000033B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000033BD                 xor     eax, ebp
.text$mn:000033BF                 push    eax
.text$mn:000033C0                 lea     eax, [ebp+var_C]
.text$mn:000033C3                 mov     large fs:0, eax
.text$mn:000033C9                 mov     [ebp+var_14], ecx
.text$mn:000033CC                 lea     eax, [ebp+var_D]
.text$mn:000033CF                 push    eax
.text$mn:000033D0                 mov     ecx, [ebp+arg_0]
.text$mn:000033D3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000033D8                 push    eax
.text$mn:000033D9                 mov     ecx, [ebp+var_14]
.text$mn:000033DC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000033E1                 mov     [ebp+var_4], 0
.text$mn:000033E8                 push    0
.text$mn:000033EA                 push    0
.text$mn:000033EC                 mov     ecx, [ebp+var_14]
.text$mn:000033EF                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000033F4                 mov     ecx, [ebp+arg_0]
.text$mn:000033F7                 push    ecx
.text$mn:000033F8                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:000033FD                 add     esp, 4
.text$mn:00003400                 push    eax
.text$mn:00003401                 mov     ecx, [ebp+var_14]
.text$mn:00003404                 call    ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00003409                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003410                 mov     eax, [ebp+var_14]
.text$mn:00003413                 mov     ecx, [ebp+var_C]
.text$mn:00003416                 mov     large fs:0, ecx
.text$mn:0000341D                 pop     ecx
.text$mn:0000341E                 mov     esp, ebp
.text$mn:00003420                 pop     ebp
.text$mn:00003421                 retn    4
.text$mn:00003421 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$mn:00003421
.text$mn:00003421 _text$mn        ends
.text$mn:00003421
.text$x:00003424 ; ===========================================================================
.text$x:00003424
.text$x:00003424 ; Segment type: Pure code
.text$x:00003424 ; Segment permissions: Read/Execute
.text$x:00003424 _text$x         segment para public 'CODE' use32
.text$x:00003424                 assume cs:_text$x
.text$x:00003424                 ;org 3424h
.text$x:00003424 ; COMDAT (pick associative to section at 33A4)
.text$x:00003424                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003424
.text$x:00003424 ; =============== S U B R O U T I N E =======================================
.text$x:00003424
.text$x:00003424
.text$x:00003424 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:00003424                                         ; DATA XREF: .xdata$x:00008560o
.text$x:00003424                 mov     ecx, [ebp-14h]
.text$x:00003427                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00003427 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:00003427
.text$x:0000342C
.text$x:0000342C ; =============== S U B R O U T I N E =======================================
.text$x:0000342C
.text$x:0000342C
.text$x:0000342C __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z proc near
.text$x:0000342C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:0000342C
.text$x:0000342C arg_4           = dword ptr  8
.text$x:0000342C
.text$x:0000342C                 mov     edx, [esp+arg_4]
.text$x:00003430                 lea     eax, [edx+0Ch]
.text$x:00003433                 mov     ecx, [edx-0Ch]
.text$x:00003436                 xor     ecx, eax
.text$x:00003438                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000343D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.text$x:00003442                 jmp     ___CxxFrameHandler3
.text$x:00003442 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z endp
.text$x:00003442
.text$x:00003442 ; ---------------------------------------------------------------------------
.text$x:00003447                 align 4
.text$x:00003447 _text$x         ends
.text$x:00003447
.text$mn:00003448 ; ===========================================================================
.text$mn:00003448
.text$mn:00003448 ; Segment type: Pure code
.text$mn:00003448 ; Segment permissions: Read/Execute
.text$mn:00003448 _text$mn        segment para public 'CODE' use32
.text$mn:00003448                 assume cs:_text$mn
.text$mn:00003448                 ;org 3448h
.text$mn:00003448 ; COMDAT (pick any)
.text$mn:00003448                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003448
.text$mn:00003448 ; =============== S U B R O U T I N E =======================================
.text$mn:00003448
.text$mn:00003448 ; Attributes: bp-based frame
.text$mn:00003448
.text$mn:00003448 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00003448                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00003448 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$mn:00003448                                         ; CODE XREF: UserCommand::UserCommand(UserCommand const &)+55p
.text$mn:00003448
.text$mn:00003448 var_14          = dword ptr -14h
.text$mn:00003448 var_E           = byte ptr -0Eh
.text$mn:00003448 var_D           = byte ptr -0Dh
.text$mn:00003448 var_C           = dword ptr -0Ch
.text$mn:00003448 var_4           = dword ptr -4
.text$mn:00003448 arg_0           = dword ptr  8
.text$mn:00003448
.text$mn:00003448                 push    ebp
.text$mn:00003449                 mov     ebp, esp
.text$mn:0000344B                 push    0FFFFFFFFh
.text$mn:0000344D                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$mn:00003452                 mov     eax, large fs:0
.text$mn:00003458                 push    eax
.text$mn:00003459                 sub     esp, 8
.text$mn:0000345C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003461                 xor     eax, ebp
.text$mn:00003463                 push    eax
.text$mn:00003464                 lea     eax, [ebp+var_C]
.text$mn:00003467                 mov     large fs:0, eax
.text$mn:0000346D                 mov     [ebp+var_14], ecx
.text$mn:00003470                 lea     eax, [ebp+var_D]
.text$mn:00003473                 push    eax
.text$mn:00003474                 lea     ecx, [ebp+var_E]
.text$mn:00003477                 push    ecx
.text$mn:00003478                 mov     ecx, [ebp+arg_0]
.text$mn:0000347B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003480                 mov     ecx, eax
.text$mn:00003482                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)
.text$mn:00003487                 push    eax
.text$mn:00003488                 mov     ecx, [ebp+var_14]
.text$mn:0000348B                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00003490                 mov     [ebp+var_4], 0
.text$mn:00003497                 push    0
.text$mn:00003499                 push    0
.text$mn:0000349B                 mov     ecx, [ebp+var_14]
.text$mn:0000349E                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000034A3                 mov     edx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000034A9                 push    edx
.text$mn:000034AA                 push    0
.text$mn:000034AC                 mov     eax, [ebp+arg_0]
.text$mn:000034AF                 push    eax
.text$mn:000034B0                 mov     ecx, [ebp+var_14]
.text$mn:000034B3                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000034B8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000034BF                 mov     eax, [ebp+var_14]
.text$mn:000034C2                 mov     ecx, [ebp+var_C]
.text$mn:000034C5                 mov     large fs:0, ecx
.text$mn:000034CC                 pop     ecx
.text$mn:000034CD                 mov     esp, ebp
.text$mn:000034CF                 pop     ebp
.text$mn:000034D0                 retn    4
.text$mn:000034D0 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$mn:000034D0
.text$mn:000034D0 ; ---------------------------------------------------------------------------
.text$mn:000034D3                 align 4
.text$mn:000034D3 _text$mn        ends
.text$mn:000034D3
.text$x:000034D4 ; ===========================================================================
.text$x:000034D4
.text$x:000034D4 ; Segment type: Pure code
.text$x:000034D4 ; Segment permissions: Read/Execute
.text$x:000034D4 _text$x         segment para public 'CODE' use32
.text$x:000034D4                 assume cs:_text$x
.text$x:000034D4                 ;org 34D4h
.text$x:000034D4 ; COMDAT (pick associative to section at 3448)
.text$x:000034D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000034D4
.text$x:000034D4 ; =============== S U B R O U T I N E =======================================
.text$x:000034D4
.text$x:000034D4
.text$x:000034D4 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 proc near
.text$x:000034D4                                         ; DATA XREF: .xdata$x:000084DCo
.text$x:000034D4                 mov     ecx, [ebp-14h]
.text$x:000034D7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000034D7 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0 endp
.text$x:000034D7
.text$x:000034DC
.text$x:000034DC ; =============== S U B R O U T I N E =======================================
.text$x:000034DC
.text$x:000034DC
.text$x:000034DC __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z proc near
.text$x:000034DC                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5o
.text$x:000034DC
.text$x:000034DC arg_4           = dword ptr  8
.text$x:000034DC
.text$x:000034DC                 mov     edx, [esp+arg_4]
.text$x:000034E0                 lea     eax, [edx+0Ch]
.text$x:000034E3                 mov     ecx, [edx-0Ch]
.text$x:000034E6                 xor     ecx, eax
.text$x:000034E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034ED                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.text$x:000034F2                 jmp     ___CxxFrameHandler3
.text$x:000034F2 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z endp
.text$x:000034F2
.text$x:000034F2 ; ---------------------------------------------------------------------------
.text$x:000034F7                 align 4
.text$x:000034F7 _text$x         ends
.text$x:000034F7
.text$mn:000034F8 ; ===========================================================================
.text$mn:000034F8
.text$mn:000034F8 ; Segment type: Pure code
.text$mn:000034F8 ; Segment permissions: Read/Execute
.text$mn:000034F8 _text$mn        segment para public 'CODE' use32
.text$mn:000034F8                 assume cs:_text$mn
.text$mn:000034F8                 ;org 34F8h
.text$mn:000034F8 ; COMDAT (pick any)
.text$mn:000034F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034F8
.text$mn:000034F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000034F8
.text$mn:000034F8 ; Attributes: bp-based frame
.text$mn:000034F8
.text$mn:000034F8 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:000034F8                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:000034F8 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:000034F8                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+489p
.text$mn:000034F8                                         ; UserCommand::UserCommand(Shortcut,wchar_t const *,int)+83p ...
.text$mn:000034F8
.text$mn:000034F8 var_14          = dword ptr -14h
.text$mn:000034F8 var_D           = byte ptr -0Dh
.text$mn:000034F8 var_C           = dword ptr -0Ch
.text$mn:000034F8 var_4           = dword ptr -4
.text$mn:000034F8 Str             = dword ptr  8
.text$mn:000034F8
.text$mn:000034F8                 push    ebp
.text$mn:000034F9                 mov     ebp, esp
.text$mn:000034FB                 push    0FFFFFFFFh
.text$mn:000034FD                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00003502                 mov     eax, large fs:0
.text$mn:00003508                 push    eax
.text$mn:00003509                 sub     esp, 8
.text$mn:0000350C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003511                 xor     eax, ebp
.text$mn:00003513                 push    eax
.text$mn:00003514                 lea     eax, [ebp+var_C]
.text$mn:00003517                 mov     large fs:0, eax
.text$mn:0000351D                 mov     [ebp+var_14], ecx
.text$mn:00003520                 lea     ecx, [ebp+var_D]
.text$mn:00003523                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:00003528                 push    eax
.text$mn:00003529                 mov     ecx, [ebp+var_14]
.text$mn:0000352C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:00003531                 mov     [ebp+var_4], 0
.text$mn:00003538                 push    0
.text$mn:0000353A                 push    0
.text$mn:0000353C                 mov     ecx, [ebp+var_14]
.text$mn:0000353F                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00003544                 mov     eax, [ebp+Str]
.text$mn:00003547                 push    eax             ; Str
.text$mn:00003548                 mov     ecx, [ebp+var_14]
.text$mn:0000354B                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:00003550                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003557                 mov     eax, [ebp+var_14]
.text$mn:0000355A                 mov     ecx, [ebp+var_C]
.text$mn:0000355D                 mov     large fs:0, ecx
.text$mn:00003564                 pop     ecx
.text$mn:00003565                 mov     esp, ebp
.text$mn:00003567                 pop     ebp
.text$mn:00003568                 retn    4
.text$mn:00003568 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00003568
.text$mn:00003568 ; ---------------------------------------------------------------------------
.text$mn:0000356B                 align 4
.text$mn:0000356B _text$mn        ends
.text$mn:0000356B
.text$x:0000356C ; ===========================================================================
.text$x:0000356C
.text$x:0000356C ; Segment type: Pure code
.text$x:0000356C ; Segment permissions: Read/Execute
.text$x:0000356C _text$x         segment para public 'CODE' use32
.text$x:0000356C                 assume cs:_text$x
.text$x:0000356C                 ;org 356Ch
.text$x:0000356C ; COMDAT (pick associative to section at 34F8)
.text$x:0000356C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000356C
.text$x:0000356C ; =============== S U B R O U T I N E =======================================
.text$x:0000356C
.text$x:0000356C
.text$x:0000356C __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:0000356C                                         ; DATA XREF: .xdata$x:00008534o
.text$x:0000356C                 mov     ecx, [ebp-14h]
.text$x:0000356F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:0000356F __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:0000356F
.text$x:00003574
.text$x:00003574 ; =============== S U B R O U T I N E =======================================
.text$x:00003574
.text$x:00003574
.text$x:00003574 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:00003574                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:00003574
.text$x:00003574 arg_4           = dword ptr  8
.text$x:00003574
.text$x:00003574                 mov     edx, [esp+arg_4]
.text$x:00003578                 lea     eax, [edx+0Ch]
.text$x:0000357B                 mov     ecx, [edx-0Ch]
.text$x:0000357E                 xor     ecx, eax
.text$x:00003580                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003585                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:0000358A                 jmp     ___CxxFrameHandler3
.text$x:0000358A __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:0000358A
.text$x:0000358A ; ---------------------------------------------------------------------------
.text$x:0000358F                 align 10h
.text$x:0000358F _text$x         ends
.text$x:0000358F
.text$mn:00003590 ; ===========================================================================
.text$mn:00003590
.text$mn:00003590 ; Segment type: Pure code
.text$mn:00003590 ; Segment permissions: Read/Execute
.text$mn:00003590 _text$mn        segment para public 'CODE' use32
.text$mn:00003590                 assume cs:_text$mn
.text$mn:00003590                 ;org 3590h
.text$mn:00003590 ; COMDAT (pick any)
.text$mn:00003590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003590
.text$mn:00003590 ; =============== S U B R O U T I N E =======================================
.text$mn:00003590
.text$mn:00003590 ; Attributes: bp-based frame
.text$mn:00003590
.text$mn:00003590 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00003590                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00003590 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00003590                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p
.text$mn:00003590
.text$mn:00003590 var_14          = dword ptr -14h
.text$mn:00003590 var_D           = byte ptr -0Dh
.text$mn:00003590 var_C           = dword ptr -0Ch
.text$mn:00003590 var_4           = dword ptr -4
.text$mn:00003590
.text$mn:00003590                 push    ebp
.text$mn:00003591                 mov     ebp, esp
.text$mn:00003593                 push    0FFFFFFFFh
.text$mn:00003595                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000359A                 mov     eax, large fs:0
.text$mn:000035A0                 push    eax
.text$mn:000035A1                 sub     esp, 8
.text$mn:000035A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000035A9                 xor     eax, ebp
.text$mn:000035AB                 push    eax
.text$mn:000035AC                 lea     eax, [ebp+var_C]
.text$mn:000035AF                 mov     large fs:0, eax
.text$mn:000035B5                 mov     [ebp+var_14], ecx
.text$mn:000035B8                 lea     ecx, [ebp+var_D]
.text$mn:000035BB                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000035C0                 push    eax
.text$mn:000035C1                 mov     ecx, [ebp+var_14]
.text$mn:000035C4                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000035C9                 mov     [ebp+var_4], 0
.text$mn:000035D0                 push    0
.text$mn:000035D2                 push    0
.text$mn:000035D4                 mov     ecx, [ebp+var_14]
.text$mn:000035D7                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000035DC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000035E3                 mov     eax, [ebp+var_14]
.text$mn:000035E6                 mov     ecx, [ebp+var_C]
.text$mn:000035E9                 mov     large fs:0, ecx
.text$mn:000035F0                 pop     ecx
.text$mn:000035F1                 mov     esp, ebp
.text$mn:000035F3                 pop     ebp
.text$mn:000035F4                 retn
.text$mn:000035F4 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:000035F4
.text$mn:000035F4 ; ---------------------------------------------------------------------------
.text$mn:000035F5                 align 4
.text$mn:000035F5 _text$mn        ends
.text$mn:000035F5
.text$x:000035F8 ; ===========================================================================
.text$x:000035F8
.text$x:000035F8 ; Segment type: Pure code
.text$x:000035F8 ; Segment permissions: Read/Execute
.text$x:000035F8 _text$x         segment para public 'CODE' use32
.text$x:000035F8                 assume cs:_text$x
.text$x:000035F8                 ;org 35F8h
.text$x:000035F8 ; COMDAT (pick associative to section at 3590)
.text$x:000035F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000035F8
.text$x:000035F8 ; =============== S U B R O U T I N E =======================================
.text$x:000035F8
.text$x:000035F8
.text$x:000035F8 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:000035F8                                         ; DATA XREF: .xdata$x:00008508o
.text$x:000035F8                 mov     ecx, [ebp-14h]
.text$x:000035FB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:000035FB __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:000035FB
.text$x:00003600
.text$x:00003600 ; =============== S U B R O U T I N E =======================================
.text$x:00003600
.text$x:00003600
.text$x:00003600 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00003600                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00003600
.text$x:00003600 arg_4           = dword ptr  8
.text$x:00003600
.text$x:00003600                 mov     edx, [esp+arg_4]
.text$x:00003604                 lea     eax, [edx+0Ch]
.text$x:00003607                 mov     ecx, [edx-0Ch]
.text$x:0000360A                 xor     ecx, eax
.text$x:0000360C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003611                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00003616                 jmp     ___CxxFrameHandler3
.text$x:00003616 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00003616
.text$x:00003616 ; ---------------------------------------------------------------------------
.text$x:0000361B                 align 4
.text$x:0000361B _text$x         ends
.text$x:0000361B
.text$mn:0000361C ; ===========================================================================
.text$mn:0000361C
.text$mn:0000361C ; Segment type: Pure code
.text$mn:0000361C ; Segment permissions: Read/Execute
.text$mn:0000361C _text$mn        segment para public 'CODE' use32
.text$mn:0000361C                 assume cs:_text$mn
.text$mn:0000361C                 ;org 361Ch
.text$mn:0000361C ; COMDAT (pick any)
.text$mn:0000361C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000361C
.text$mn:0000361C ; =============== S U B R O U T I N E =======================================
.text$mn:0000361C
.text$mn:0000361C ; Attributes: bp-based frame
.text$mn:0000361C
.text$mn:0000361C ; _DWORD __thiscall CommandShortcut::CommandShortcut(CommandShortcut *this, const struct CommandShortcut *)
.text$mn:0000361C                 public ??0CommandShortcut@@QAE@ABV0@@Z
.text$mn:0000361C ??0CommandShortcut@@QAE@ABV0@@Z proc near
.text$mn:0000361C                                         ; CODE XREF: UserCommand::UserCommand(UserCommand const &)+2Dp
.text$mn:0000361C
.text$mn:0000361C var_10          = dword ptr -10h
.text$mn:0000361C var_C           = dword ptr -0Ch
.text$mn:0000361C var_4           = dword ptr -4
.text$mn:0000361C arg_0           = dword ptr  8
.text$mn:0000361C
.text$mn:0000361C                 push    ebp
.text$mn:0000361D                 mov     ebp, esp
.text$mn:0000361F                 push    0FFFFFFFFh
.text$mn:00003621                 push    offset __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z
.text$mn:00003626                 mov     eax, large fs:0
.text$mn:0000362C                 push    eax
.text$mn:0000362D                 push    ecx
.text$mn:0000362E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003633                 xor     eax, ebp
.text$mn:00003635                 push    eax
.text$mn:00003636                 lea     eax, [ebp+var_C]
.text$mn:00003639                 mov     large fs:0, eax
.text$mn:0000363F                 mov     [ebp+var_10], ecx
.text$mn:00003642                 mov     eax, [ebp+arg_0]
.text$mn:00003645                 push    eax             ; Shortcut *
.text$mn:00003646                 mov     ecx, [ebp+var_10]
.text$mn:00003649                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:0000364E                 mov     [ebp+var_4], 0
.text$mn:00003655                 mov     ecx, [ebp+var_10]
.text$mn:00003658                 mov     dword ptr [ecx], offset ??_7CommandShortcut@@6B@ ; const CommandShortcut::`vftable'
.text$mn:0000365E                 mov     edx, [ebp+var_10]
.text$mn:00003661                 mov     eax, [ebp+arg_0]
.text$mn:00003664                 mov     ecx, [eax+128h]
.text$mn:0000366A                 mov     [edx+128h], ecx
.text$mn:00003670                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003677                 mov     eax, [ebp+var_10]
.text$mn:0000367A                 mov     ecx, [ebp+var_C]
.text$mn:0000367D                 mov     large fs:0, ecx
.text$mn:00003684                 pop     ecx
.text$mn:00003685                 mov     esp, ebp
.text$mn:00003687                 pop     ebp
.text$mn:00003688                 retn    4
.text$mn:00003688 ??0CommandShortcut@@QAE@ABV0@@Z endp
.text$mn:00003688
.text$mn:00003688 ; ---------------------------------------------------------------------------
.text$mn:0000368B                 align 4
.text$mn:0000368B _text$mn        ends
.text$mn:0000368B
.text$x:0000368C ; ===========================================================================
.text$x:0000368C
.text$x:0000368C ; Segment type: Pure code
.text$x:0000368C ; Segment permissions: Read/Execute
.text$x:0000368C _text$x         segment para public 'CODE' use32
.text$x:0000368C                 assume cs:_text$x
.text$x:0000368C                 ;org 368Ch
.text$x:0000368C ; COMDAT (pick associative to section at 361C)
.text$x:0000368C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000368C
.text$x:0000368C ; =============== S U B R O U T I N E =======================================
.text$x:0000368C
.text$x:0000368C
.text$x:0000368C __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0 proc near
.text$x:0000368C                                         ; DATA XREF: .xdata$x:0000891Co
.text$x:0000368C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000368F                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:0000368F __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0 endp
.text$x:0000368F
.text$x:00003694
.text$x:00003694 ; =============== S U B R O U T I N E =======================================
.text$x:00003694
.text$x:00003694
.text$x:00003694 __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z proc near
.text$x:00003694                                         ; DATA XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+5o
.text$x:00003694
.text$x:00003694 arg_4           = dword ptr  8
.text$x:00003694
.text$x:00003694                 mov     edx, [esp+arg_4]
.text$x:00003698                 lea     eax, [edx+0Ch]
.text$x:0000369B                 mov     ecx, [edx-8]
.text$x:0000369E                 xor     ecx, eax
.text$x:000036A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000036A5                 mov     eax, offset __ehfuncinfo$??0CommandShortcut@@QAE@ABV0@@Z
.text$x:000036AA                 jmp     ___CxxFrameHandler3
.text$x:000036AA __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z endp
.text$x:000036AA
.text$x:000036AA ; ---------------------------------------------------------------------------
.text$x:000036AF                 align 10h
.text$x:000036AF _text$x         ends
.text$x:000036AF
.text$mn:000036B0 ; ===========================================================================
.text$mn:000036B0
.text$mn:000036B0 ; Segment type: Pure code
.text$mn:000036B0 ; Segment permissions: Read/Execute
.text$mn:000036B0 _text$mn        segment para public 'CODE' use32
.text$mn:000036B0                 assume cs:_text$mn
.text$mn:000036B0                 ;org 36B0h
.text$mn:000036B0 ; COMDAT (pick any)
.text$mn:000036B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036B0
.text$mn:000036B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036B0
.text$mn:000036B0 ; Attributes: bp-based frame
.text$mn:000036B0
.text$mn:000036B0 ; public: __thiscall CommandShortcut::CommandShortcut(class Shortcut, long)
.text$mn:000036B0                 public ??0CommandShortcut@@QAE@VShortcut@@J@Z
.text$mn:000036B0 ??0CommandShortcut@@QAE@VShortcut@@J@Z proc near
.text$mn:000036B0                                         ; CODE XREF: UserCommand::UserCommand(Shortcut,wchar_t const *,int)+5Ep
.text$mn:000036B0
.text$mn:000036B0 var_10          = dword ptr -10h
.text$mn:000036B0 var_C           = dword ptr -0Ch
.text$mn:000036B0 var_4           = dword ptr -4
.text$mn:000036B0 arg_0           = byte ptr  8
.text$mn:000036B0 arg_128         = dword ptr  130h
.text$mn:000036B0
.text$mn:000036B0                 push    ebp
.text$mn:000036B1                 mov     ebp, esp
.text$mn:000036B3                 push    0FFFFFFFFh
.text$mn:000036B5                 push    offset __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z
.text$mn:000036BA                 mov     eax, large fs:0
.text$mn:000036C0                 push    eax
.text$mn:000036C1                 push    ecx
.text$mn:000036C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000036C7                 xor     eax, ebp
.text$mn:000036C9                 push    eax
.text$mn:000036CA                 lea     eax, [ebp+var_C]
.text$mn:000036CD                 mov     large fs:0, eax
.text$mn:000036D3                 mov     [ebp+var_10], ecx
.text$mn:000036D6                 mov     [ebp+var_4], 0
.text$mn:000036DD                 lea     eax, [ebp+arg_0]
.text$mn:000036E0                 push    eax             ; Shortcut *
.text$mn:000036E1                 mov     ecx, [ebp+var_10]
.text$mn:000036E4                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:000036E9                 mov     byte ptr [ebp+var_4], 1
.text$mn:000036ED                 mov     ecx, [ebp+var_10]
.text$mn:000036F0                 mov     dword ptr [ecx], offset ??_7CommandShortcut@@6B@ ; const CommandShortcut::`vftable'
.text$mn:000036F6                 mov     edx, [ebp+var_10]
.text$mn:000036F9                 mov     eax, [ebp+arg_128]
.text$mn:000036FF                 mov     [edx+128h], eax
.text$mn:00003705                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000370C                 lea     ecx, [ebp+arg_0] ; this
.text$mn:0000370F                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:00003714                 mov     eax, [ebp+var_10]
.text$mn:00003717                 mov     ecx, [ebp+var_C]
.text$mn:0000371A                 mov     large fs:0, ecx
.text$mn:00003721                 pop     ecx
.text$mn:00003722                 mov     esp, ebp
.text$mn:00003724                 pop     ebp
.text$mn:00003725                 retn    12Ch
.text$mn:00003725 ??0CommandShortcut@@QAE@VShortcut@@J@Z endp
.text$mn:00003725
.text$mn:00003725 _text$mn        ends
.text$mn:00003725
.text$x:00003728 ; ===========================================================================
.text$x:00003728
.text$x:00003728 ; Segment type: Pure code
.text$x:00003728 ; Segment permissions: Read/Execute
.text$x:00003728 _text$x         segment para public 'CODE' use32
.text$x:00003728                 assume cs:_text$x
.text$x:00003728                 ;org 3728h
.text$x:00003728 ; COMDAT (pick associative to section at 36B0)
.text$x:00003728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003728
.text$x:00003728 ; =============== S U B R O U T I N E =======================================
.text$x:00003728
.text$x:00003728
.text$x:00003728 __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$0 proc near
.text$x:00003728                                         ; DATA XREF: .xdata$x:000088BCo
.text$x:00003728                 lea     ecx, [ebp+8]    ; this
.text$x:0000372B                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:0000372B __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$0 endp
.text$x:0000372B
.text$x:00003730
.text$x:00003730 ; =============== S U B R O U T I N E =======================================
.text$x:00003730
.text$x:00003730
.text$x:00003730 __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$1 proc near
.text$x:00003730                                         ; DATA XREF: .xdata$x:000088C4o
.text$x:00003730                 mov     ecx, [ebp-10h]  ; this
.text$x:00003733                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00003733 __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$1 endp
.text$x:00003733
.text$x:00003738
.text$x:00003738 ; =============== S U B R O U T I N E =======================================
.text$x:00003738
.text$x:00003738
.text$x:00003738 __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z proc near
.text$x:00003738                                         ; DATA XREF: CommandShortcut::CommandShortcut(Shortcut,long)+5o
.text$x:00003738
.text$x:00003738 arg_4           = dword ptr  8
.text$x:00003738
.text$x:00003738                 mov     edx, [esp+arg_4]
.text$x:0000373C                 lea     eax, [edx+0Ch]
.text$x:0000373F                 mov     ecx, [edx-8]
.text$x:00003742                 xor     ecx, eax
.text$x:00003744                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003749                 mov     eax, offset __ehfuncinfo$??0CommandShortcut@@QAE@VShortcut@@J@Z
.text$x:0000374E                 jmp     ___CxxFrameHandler3
.text$x:0000374E __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z endp
.text$x:0000374E
.text$x:0000374E ; ---------------------------------------------------------------------------
.text$x:00003753                 align 4
.text$x:00003753 _text$x         ends
.text$x:00003753
.text$mn:00003754 ; ===========================================================================
.text$mn:00003754
.text$mn:00003754 ; Segment type: Pure code
.text$mn:00003754 ; Segment permissions: Read/Execute
.text$mn:00003754 _text$mn        segment para public 'CODE' use32
.text$mn:00003754                 assume cs:_text$mn
.text$mn:00003754                 ;org 3754h
.text$mn:00003754 ; COMDAT (pick any)
.text$mn:00003754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003754
.text$mn:00003754 ; =============== S U B R O U T I N E =======================================
.text$mn:00003754
.text$mn:00003754 ; Attributes: bp-based frame
.text$mn:00003754
.text$mn:00003754 ; int __stdcall Shortcut::Shortcut(Shortcut *)
.text$mn:00003754                 public ??0Shortcut@@QAE@ABV0@@Z
.text$mn:00003754 ??0Shortcut@@QAE@ABV0@@Z proc near      ; CODE XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+2Dp
.text$mn:00003754                                         ; CommandShortcut::CommandShortcut(Shortcut,long)+34p ...
.text$mn:00003754
.text$mn:00003754 var_10          = dword ptr -10h
.text$mn:00003754 var_C           = dword ptr -0Ch
.text$mn:00003754 var_4           = dword ptr -4
.text$mn:00003754 arg_0           = dword ptr  8
.text$mn:00003754
.text$mn:00003754                 push    ebp
.text$mn:00003755                 mov     ebp, esp
.text$mn:00003757                 push    0FFFFFFFFh
.text$mn:00003759                 push    offset __ehhandler$??0Shortcut@@QAE@ABV0@@Z
.text$mn:0000375E                 mov     eax, large fs:0
.text$mn:00003764                 push    eax
.text$mn:00003765                 push    ecx
.text$mn:00003766                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000376B                 xor     eax, ebp
.text$mn:0000376D                 push    eax
.text$mn:0000376E                 lea     eax, [ebp+var_C]
.text$mn:00003771                 mov     large fs:0, eax
.text$mn:00003777                 mov     [ebp+var_10], ecx
.text$mn:0000377A                 mov     ecx, [ebp+var_10]
.text$mn:0000377D                 call    ??0StaticDialog@@QAE@XZ ; StaticDialog::StaticDialog(void)
.text$mn:00003782                 mov     [ebp+var_4], 0
.text$mn:00003789                 mov     eax, [ebp+var_10]
.text$mn:0000378C                 mov     dword ptr [eax], offset ??_7Shortcut@@6B@ ; const Shortcut::`vftable'
.text$mn:00003792                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003795                 call    ?getMenuName@Shortcut@@QBEPB_WXZ ; Shortcut::getMenuName(void)
.text$mn:0000379A                 push    eax             ; wchar_t *
.text$mn:0000379B                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000379E                 call    ?setName@Shortcut@@QAEXPB_W@Z ; Shortcut::setName(wchar_t const *)
.text$mn:000037A3                 mov     ecx, [ebp+arg_0]
.text$mn:000037A6                 mov     edx, [ecx+20h]
.text$mn:000037A9                 mov     eax, [ebp+var_10]
.text$mn:000037AC                 mov     [eax+20h], edx
.text$mn:000037AF                 mov     ecx, [ebp+var_10]
.text$mn:000037B2                 mov     edx, [ebp+arg_0]
.text$mn:000037B5                 mov     al, [edx+24h]
.text$mn:000037B8                 mov     [ecx+24h], al
.text$mn:000037BB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000037C2                 mov     eax, [ebp+var_10]
.text$mn:000037C5                 mov     ecx, [ebp+var_C]
.text$mn:000037C8                 mov     large fs:0, ecx
.text$mn:000037CF                 pop     ecx
.text$mn:000037D0                 mov     esp, ebp
.text$mn:000037D2                 pop     ebp
.text$mn:000037D3                 retn    4
.text$mn:000037D3 ??0Shortcut@@QAE@ABV0@@Z endp
.text$mn:000037D3
.text$mn:000037D3 ; ---------------------------------------------------------------------------
.text$mn:000037D6                 align 4
.text$mn:000037D6 _text$mn        ends
.text$mn:000037D6
.text$x:000037D8 ; ===========================================================================
.text$x:000037D8
.text$x:000037D8 ; Segment type: Pure code
.text$x:000037D8 ; Segment permissions: Read/Execute
.text$x:000037D8 _text$x         segment para public 'CODE' use32
.text$x:000037D8                 assume cs:_text$x
.text$x:000037D8                 ;org 37D8h
.text$x:000037D8 ; COMDAT (pick associative to section at 3754)
.text$x:000037D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000037D8
.text$x:000037D8 ; =============== S U B R O U T I N E =======================================
.text$x:000037D8
.text$x:000037D8
.text$x:000037D8 __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0 proc near
.text$x:000037D8                                         ; DATA XREF: .xdata$x:00008828o
.text$x:000037D8                 mov     ecx, [ebp-10h]  ; this
.text$x:000037DB                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:000037DB __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0 endp
.text$x:000037DB
.text$x:000037E0
.text$x:000037E0 ; =============== S U B R O U T I N E =======================================
.text$x:000037E0
.text$x:000037E0
.text$x:000037E0 __ehhandler$??0Shortcut@@QAE@ABV0@@Z proc near
.text$x:000037E0                                         ; DATA XREF: Shortcut::Shortcut(Shortcut const &)+5o
.text$x:000037E0
.text$x:000037E0 arg_4           = dword ptr  8
.text$x:000037E0
.text$x:000037E0                 mov     edx, [esp+arg_4]
.text$x:000037E4                 lea     eax, [edx+0Ch]
.text$x:000037E7                 mov     ecx, [edx-8]
.text$x:000037EA                 xor     ecx, eax
.text$x:000037EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000037F1                 mov     eax, offset __ehfuncinfo$??0Shortcut@@QAE@ABV0@@Z
.text$x:000037F6                 jmp     ___CxxFrameHandler3
.text$x:000037F6 __ehhandler$??0Shortcut@@QAE@ABV0@@Z endp
.text$x:000037F6
.text$x:000037F6 ; ---------------------------------------------------------------------------
.text$x:000037FB                 align 4
.text$x:000037FB _text$x         ends
.text$x:000037FB
.text$mn:000037FC ; ===========================================================================
.text$mn:000037FC
.text$mn:000037FC ; Segment type: Pure code
.text$mn:000037FC ; Segment permissions: Read/Execute
.text$mn:000037FC _text$mn        segment para public 'CODE' use32
.text$mn:000037FC                 assume cs:_text$mn
.text$mn:000037FC                 ;org 37FCh
.text$mn:000037FC ; COMDAT (pick any)
.text$mn:000037FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037FC
.text$mn:000037FC ; =============== S U B R O U T I N E =======================================
.text$mn:000037FC
.text$mn:000037FC ; Attributes: bp-based frame
.text$mn:000037FC
.text$mn:000037FC ; public: __thiscall Shortcut::Shortcut(void)
.text$mn:000037FC                 public ??0Shortcut@@QAE@XZ
.text$mn:000037FC ??0Shortcut@@QAE@XZ proc near           ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+1B6p
.text$mn:000037FC
.text$mn:000037FC var_10          = dword ptr -10h
.text$mn:000037FC var_C           = dword ptr -0Ch
.text$mn:000037FC var_4           = dword ptr -4
.text$mn:000037FC
.text$mn:000037FC                 push    ebp
.text$mn:000037FD                 mov     ebp, esp
.text$mn:000037FF                 push    0FFFFFFFFh
.text$mn:00003801                 push    offset __ehhandler$??0Shortcut@@QAE@XZ
.text$mn:00003806                 mov     eax, large fs:0
.text$mn:0000380C                 push    eax
.text$mn:0000380D                 push    ecx
.text$mn:0000380E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003813                 xor     eax, ebp
.text$mn:00003815                 push    eax
.text$mn:00003816                 lea     eax, [ebp+var_C]
.text$mn:00003819                 mov     large fs:0, eax
.text$mn:0000381F                 mov     [ebp+var_10], ecx
.text$mn:00003822                 mov     ecx, [ebp+var_10]
.text$mn:00003825                 call    ??0StaticDialog@@QAE@XZ ; StaticDialog::StaticDialog(void)
.text$mn:0000382A                 mov     [ebp+var_4], 0
.text$mn:00003831                 mov     eax, [ebp+var_10]
.text$mn:00003834                 mov     dword ptr [eax], offset ??_7Shortcut@@6B@ ; const Shortcut::`vftable'
.text$mn:0000383A                 mov     ecx, [ebp+var_10]
.text$mn:0000383D                 mov     byte ptr [ecx+24h], 0
.text$mn:00003841                 push    offset ??_C@_11LOCGONAA@?$AA?$AA@ ; wchar_t *
.text$mn:00003846                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003849                 call    ?setName@Shortcut@@QAEXPB_W@Z ; Shortcut::setName(wchar_t const *)
.text$mn:0000384E                 mov     edx, [ebp+var_10]
.text$mn:00003851                 mov     byte ptr [edx+20h], 0
.text$mn:00003855                 mov     eax, [ebp+var_10]
.text$mn:00003858                 mov     byte ptr [eax+21h], 0
.text$mn:0000385C                 mov     ecx, [ebp+var_10]
.text$mn:0000385F                 mov     byte ptr [ecx+22h], 0
.text$mn:00003863                 mov     edx, [ebp+var_10]
.text$mn:00003866                 mov     byte ptr [edx+23h], 0
.text$mn:0000386A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003871                 mov     eax, [ebp+var_10]
.text$mn:00003874                 mov     ecx, [ebp+var_C]
.text$mn:00003877                 mov     large fs:0, ecx
.text$mn:0000387E                 pop     ecx
.text$mn:0000387F                 mov     esp, ebp
.text$mn:00003881                 pop     ebp
.text$mn:00003882                 retn
.text$mn:00003882 ??0Shortcut@@QAE@XZ endp
.text$mn:00003882
.text$mn:00003882 ; ---------------------------------------------------------------------------
.text$mn:00003883                 align 4
.text$mn:00003883 _text$mn        ends
.text$mn:00003883
.text$x:00003884 ; ===========================================================================
.text$x:00003884
.text$x:00003884 ; Segment type: Pure code
.text$x:00003884 ; Segment permissions: Read/Execute
.text$x:00003884 _text$x         segment para public 'CODE' use32
.text$x:00003884                 assume cs:_text$x
.text$x:00003884                 ;org 3884h
.text$x:00003884 ; COMDAT (pick associative to section at 37FC)
.text$x:00003884                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003884
.text$x:00003884 ; =============== S U B R O U T I N E =======================================
.text$x:00003884
.text$x:00003884
.text$x:00003884 __unwindfunclet$??0Shortcut@@QAE@XZ$0 proc near
.text$x:00003884                                         ; DATA XREF: .xdata$x:000087FCo
.text$x:00003884                 mov     ecx, [ebp-10h]  ; this
.text$x:00003887                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:00003887 __unwindfunclet$??0Shortcut@@QAE@XZ$0 endp
.text$x:00003887
.text$x:0000388C
.text$x:0000388C ; =============== S U B R O U T I N E =======================================
.text$x:0000388C
.text$x:0000388C
.text$x:0000388C __ehhandler$??0Shortcut@@QAE@XZ proc near
.text$x:0000388C                                         ; DATA XREF: Shortcut::Shortcut(void)+5o
.text$x:0000388C
.text$x:0000388C arg_4           = dword ptr  8
.text$x:0000388C
.text$x:0000388C                 mov     edx, [esp+arg_4]
.text$x:00003890                 lea     eax, [edx+0Ch]
.text$x:00003893                 mov     ecx, [edx-8]
.text$x:00003896                 xor     ecx, eax
.text$x:00003898                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000389D                 mov     eax, offset __ehfuncinfo$??0Shortcut@@QAE@XZ
.text$x:000038A2                 jmp     ___CxxFrameHandler3
.text$x:000038A2 __ehhandler$??0Shortcut@@QAE@XZ endp
.text$x:000038A2
.text$x:000038A2 ; ---------------------------------------------------------------------------
.text$x:000038A7                 align 4
.text$x:000038A7 _text$x         ends
.text$x:000038A7
.text$mn:000038A8 ; ===========================================================================
.text$mn:000038A8
.text$mn:000038A8 ; Segment type: Pure code
.text$mn:000038A8 ; Segment permissions: Read/Execute
.text$mn:000038A8 _text$mn        segment para public 'CODE' use32
.text$mn:000038A8                 assume cs:_text$mn
.text$mn:000038A8                 ;org 38A8h
.text$mn:000038A8 ; COMDAT (pick any)
.text$mn:000038A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038A8
.text$mn:000038A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038A8
.text$mn:000038A8 ; Attributes: bp-based frame
.text$mn:000038A8
.text$mn:000038A8 ; public: __thiscall StaticDialog::StaticDialog(void)
.text$mn:000038A8                 public ??0StaticDialog@@QAE@XZ
.text$mn:000038A8 ??0StaticDialog@@QAE@XZ proc near       ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+29p
.text$mn:000038A8                                         ; Shortcut::Shortcut(void)+29p
.text$mn:000038A8
.text$mn:000038A8 var_10          = dword ptr -10h
.text$mn:000038A8 var_C           = dword ptr -0Ch
.text$mn:000038A8 var_4           = dword ptr -4
.text$mn:000038A8
.text$mn:000038A8                 push    ebp
.text$mn:000038A9                 mov     ebp, esp
.text$mn:000038AB                 push    0FFFFFFFFh
.text$mn:000038AD                 push    offset __ehhandler$??0StaticDialog@@QAE@XZ
.text$mn:000038B2                 mov     eax, large fs:0
.text$mn:000038B8                 push    eax
.text$mn:000038B9                 push    ecx
.text$mn:000038BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000038BF                 xor     eax, ebp
.text$mn:000038C1                 push    eax
.text$mn:000038C2                 lea     eax, [ebp+var_C]
.text$mn:000038C5                 mov     large fs:0, eax
.text$mn:000038CB                 mov     [ebp+var_10], ecx
.text$mn:000038CE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000038D1                 call    ??0Window@@QAE@XZ ; Window::Window(void)
.text$mn:000038D6                 mov     [ebp+var_4], 0
.text$mn:000038DD                 mov     eax, [ebp+var_10]
.text$mn:000038E0                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:000038E6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000038ED                 mov     eax, [ebp+var_10]
.text$mn:000038F0                 mov     ecx, [ebp+var_C]
.text$mn:000038F3                 mov     large fs:0, ecx
.text$mn:000038FA                 pop     ecx
.text$mn:000038FB                 mov     esp, ebp
.text$mn:000038FD                 pop     ebp
.text$mn:000038FE                 retn
.text$mn:000038FE ??0StaticDialog@@QAE@XZ endp
.text$mn:000038FE
.text$mn:000038FE ; ---------------------------------------------------------------------------
.text$mn:000038FF                 align 10h
.text$mn:000038FF _text$mn        ends
.text$mn:000038FF
.text$x:00003900 ; ===========================================================================
.text$x:00003900
.text$x:00003900 ; Segment type: Pure code
.text$x:00003900 ; Segment permissions: Read/Execute
.text$x:00003900 _text$x         segment para public 'CODE' use32
.text$x:00003900                 assume cs:_text$x
.text$x:00003900                 ;org 3900h
.text$x:00003900 ; COMDAT (pick associative to section at 38A8)
.text$x:00003900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003900
.text$x:00003900 ; =============== S U B R O U T I N E =======================================
.text$x:00003900
.text$x:00003900
.text$x:00003900 __unwindfunclet$??0StaticDialog@@QAE@XZ$0 proc near
.text$x:00003900                                         ; DATA XREF: .xdata$x:00007FFCo
.text$x:00003900                 mov     ecx, [ebp-10h]  ; this
.text$x:00003903                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:00003903 __unwindfunclet$??0StaticDialog@@QAE@XZ$0 endp
.text$x:00003903
.text$x:00003908
.text$x:00003908 ; =============== S U B R O U T I N E =======================================
.text$x:00003908
.text$x:00003908
.text$x:00003908 __ehhandler$??0StaticDialog@@QAE@XZ proc near
.text$x:00003908                                         ; DATA XREF: StaticDialog::StaticDialog(void)+5o
.text$x:00003908
.text$x:00003908 arg_4           = dword ptr  8
.text$x:00003908
.text$x:00003908                 mov     edx, [esp+arg_4]
.text$x:0000390C                 lea     eax, [edx+0Ch]
.text$x:0000390F                 mov     ecx, [edx-8]
.text$x:00003912                 xor     ecx, eax
.text$x:00003914                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003919                 mov     eax, offset __ehfuncinfo$??0StaticDialog@@QAE@XZ
.text$x:0000391E                 jmp     ___CxxFrameHandler3
.text$x:0000391E __ehhandler$??0StaticDialog@@QAE@XZ endp
.text$x:0000391E
.text$x:0000391E ; ---------------------------------------------------------------------------
.text$x:00003923                 align 4
.text$x:00003923 _text$x         ends
.text$x:00003923
.text$mn:00003924 ; ===========================================================================
.text$mn:00003924
.text$mn:00003924 ; Segment type: Pure code
.text$mn:00003924 ; Segment permissions: Read/Execute
.text$mn:00003924 _text$mn        segment para public 'CODE' use32
.text$mn:00003924                 assume cs:_text$mn
.text$mn:00003924                 ;org 3924h
.text$mn:00003924 ; COMDAT (pick any)
.text$mn:00003924                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003924
.text$mn:00003924 ; =============== S U B R O U T I N E =======================================
.text$mn:00003924
.text$mn:00003924 ; Attributes: bp-based frame
.text$mn:00003924
.text$mn:00003924 ; int __stdcall UserCommand::UserCommand(struct CommandShortcut *)
.text$mn:00003924                 public ??0UserCommand@@QAE@ABV0@@Z
.text$mn:00003924 ??0UserCommand@@QAE@ABV0@@Z proc near   ; CODE XREF: std::allocator<UserCommand>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)+59p
.text$mn:00003924                                         ; std::allocator<UserCommand>::construct<UserCommand,UserCommand>(UserCommand *,UserCommand &&)+59p ...
.text$mn:00003924
.text$mn:00003924 var_10          = dword ptr -10h
.text$mn:00003924 var_C           = dword ptr -0Ch
.text$mn:00003924 var_4           = dword ptr -4
.text$mn:00003924 arg_0           = dword ptr  8
.text$mn:00003924
.text$mn:00003924                 push    ebp
.text$mn:00003925                 mov     ebp, esp
.text$mn:00003927                 push    0FFFFFFFFh
.text$mn:00003929                 push    offset __ehhandler$??0UserCommand@@QAE@ABV0@@Z
.text$mn:0000392E                 mov     eax, large fs:0
.text$mn:00003934                 push    eax
.text$mn:00003935                 push    ecx
.text$mn:00003936                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000393B                 xor     eax, ebp
.text$mn:0000393D                 push    eax
.text$mn:0000393E                 lea     eax, [ebp+var_C]
.text$mn:00003941                 mov     large fs:0, eax
.text$mn:00003947                 mov     [ebp+var_10], ecx
.text$mn:0000394A                 mov     eax, [ebp+arg_0]
.text$mn:0000394D                 push    eax             ; struct CommandShortcut *
.text$mn:0000394E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003951                 call    ??0CommandShortcut@@QAE@ABV0@@Z ; CommandShortcut::CommandShortcut(CommandShortcut const &)
.text$mn:00003956                 mov     [ebp+var_4], 0
.text$mn:0000395D                 mov     ecx, [ebp+var_10]
.text$mn:00003960                 mov     dword ptr [ecx], offset ??_7UserCommand@@6B@ ; const UserCommand::`vftable'
.text$mn:00003966                 mov     edx, [ebp+arg_0]
.text$mn:00003969                 add     edx, 12Ch
.text$mn:0000396F                 push    edx
.text$mn:00003970                 mov     ecx, [ebp+var_10]
.text$mn:00003973                 add     ecx, 12Ch
.text$mn:00003979                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:0000397E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003982                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003989                 mov     eax, [ebp+var_10]
.text$mn:0000398C                 mov     ecx, [ebp+var_C]
.text$mn:0000398F                 mov     large fs:0, ecx
.text$mn:00003996                 pop     ecx
.text$mn:00003997                 mov     esp, ebp
.text$mn:00003999                 pop     ebp
.text$mn:0000399A                 retn    4
.text$mn:0000399A ??0UserCommand@@QAE@ABV0@@Z endp
.text$mn:0000399A
.text$mn:0000399A ; ---------------------------------------------------------------------------
.text$mn:0000399D                 align 10h
.text$mn:0000399D _text$mn        ends
.text$mn:0000399D
.text$x:000039A0 ; ===========================================================================
.text$x:000039A0
.text$x:000039A0 ; Segment type: Pure code
.text$x:000039A0 ; Segment permissions: Read/Execute
.text$x:000039A0 _text$x         segment para public 'CODE' use32
.text$x:000039A0                 assume cs:_text$x
.text$x:000039A0                 ;org 39A0h
.text$x:000039A0 ; COMDAT (pick associative to section at 3924)
.text$x:000039A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000039A0
.text$x:000039A0 ; =============== S U B R O U T I N E =======================================
.text$x:000039A0
.text$x:000039A0
.text$x:000039A0 __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$0 proc near
.text$x:000039A0                                         ; DATA XREF: .xdata$x:000089C0o
.text$x:000039A0                 mov     ecx, [ebp-10h]  ; this
.text$x:000039A3                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:000039A3 __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$0 endp
.text$x:000039A3
.text$x:000039A8
.text$x:000039A8 ; =============== S U B R O U T I N E =======================================
.text$x:000039A8
.text$x:000039A8
.text$x:000039A8 __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$1 proc near
.text$x:000039A8                                         ; DATA XREF: .xdata$x:000089C8o
.text$x:000039A8                 mov     ecx, [ebp-10h]
.text$x:000039AB                 add     ecx, 12Ch
.text$x:000039B1                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:000039B1 __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$1 endp
.text$x:000039B1
.text$x:000039B6
.text$x:000039B6 ; =============== S U B R O U T I N E =======================================
.text$x:000039B6
.text$x:000039B6
.text$x:000039B6 __ehhandler$??0UserCommand@@QAE@ABV0@@Z proc near
.text$x:000039B6                                         ; DATA XREF: UserCommand::UserCommand(UserCommand const &)+5o
.text$x:000039B6
.text$x:000039B6 arg_4           = dword ptr  8
.text$x:000039B6
.text$x:000039B6                 mov     edx, [esp+arg_4]
.text$x:000039BA                 lea     eax, [edx+0Ch]
.text$x:000039BD                 mov     ecx, [edx-8]
.text$x:000039C0                 xor     ecx, eax
.text$x:000039C2                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039C7                 mov     eax, offset __ehfuncinfo$??0UserCommand@@QAE@ABV0@@Z
.text$x:000039CC                 jmp     ___CxxFrameHandler3
.text$x:000039CC __ehhandler$??0UserCommand@@QAE@ABV0@@Z endp
.text$x:000039CC
.text$x:000039CC ; ---------------------------------------------------------------------------
.text$x:000039D1                 align 4
.text$x:000039D1 _text$x         ends
.text$x:000039D1
.text$mn:000039D4 ; ===========================================================================
.text$mn:000039D4
.text$mn:000039D4 ; Segment type: Pure code
.text$mn:000039D4 ; Segment permissions: Read/Execute
.text$mn:000039D4 _text$mn        segment para public 'CODE' use32
.text$mn:000039D4                 assume cs:_text$mn
.text$mn:000039D4                 ;org 39D4h
.text$mn:000039D4 ; COMDAT (pick any)
.text$mn:000039D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039D4
.text$mn:000039D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039D4
.text$mn:000039D4 ; Attributes: bp-based frame
.text$mn:000039D4
.text$mn:000039D4 ; int __stdcall UserCommand::UserCommand(char, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, int, wchar_t *Str, int)
.text$mn:000039D4                 public ??0UserCommand@@QAE@VShortcut@@PB_WH@Z
.text$mn:000039D4 ??0UserCommand@@QAE@VShortcut@@PB_WH@Z proc near
.text$mn:000039D4                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+1E1p
.text$mn:000039D4
.text$mn:000039D4 var_20          = dword ptr -20h
.text$mn:000039D4 var_1C          = dword ptr -1Ch
.text$mn:000039D4 var_18          = dword ptr -18h
.text$mn:000039D4 var_14          = dword ptr -14h
.text$mn:000039D4 var_10          = dword ptr -10h
.text$mn:000039D4 var_C           = dword ptr -0Ch
.text$mn:000039D4 var_4           = dword ptr -4
.text$mn:000039D4 arg_0           = byte ptr  8
.text$mn:000039D4 Str             = dword ptr  130h
.text$mn:000039D4 arg_12C         = dword ptr  134h
.text$mn:000039D4
.text$mn:000039D4                 push    ebp
.text$mn:000039D5                 mov     ebp, esp
.text$mn:000039D7                 push    0FFFFFFFFh
.text$mn:000039D9                 push    offset __ehhandler$??0UserCommand@@QAE@VShortcut@@PB_WH@Z
.text$mn:000039DE                 mov     eax, large fs:0
.text$mn:000039E4                 push    eax
.text$mn:000039E5                 sub     esp, 14h
.text$mn:000039E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000039ED                 xor     eax, ebp
.text$mn:000039EF                 push    eax
.text$mn:000039F0                 lea     eax, [ebp+var_C]
.text$mn:000039F3                 mov     large fs:0, eax
.text$mn:000039F9                 mov     [ebp+var_10], ecx
.text$mn:000039FC                 mov     [ebp+var_4], 0
.text$mn:00003A03                 mov     eax, [ebp+arg_12C]
.text$mn:00003A09                 push    eax
.text$mn:00003A0A                 sub     esp, 128h
.text$mn:00003A10                 mov     ecx, esp
.text$mn:00003A12                 mov     [ebp+var_18], esp
.text$mn:00003A15                 lea     edx, [ebp+arg_0]
.text$mn:00003A18                 push    edx             ; Shortcut *
.text$mn:00003A19                 call    ??0Shortcut@@QAE@ABV0@@Z ; Shortcut::Shortcut(Shortcut const &)
.text$mn:00003A1E                 mov     [ebp+var_14], eax
.text$mn:00003A21                 mov     eax, [ebp+var_14]
.text$mn:00003A24                 mov     [ebp+var_1C], eax
.text$mn:00003A27                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003A2B                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003A2F                 mov     ecx, [ebp+var_10]
.text$mn:00003A32                 call    ??0CommandShortcut@@QAE@VShortcut@@J@Z ; CommandShortcut::CommandShortcut(Shortcut,long)
.text$mn:00003A37                 mov     [ebp+var_20], eax
.text$mn:00003A3A                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003A3E                 mov     ecx, [ebp+var_10]
.text$mn:00003A41                 mov     dword ptr [ecx], offset ??_7UserCommand@@6B@ ; const UserCommand::`vftable'
.text$mn:00003A47                 mov     edx, [ebp+Str]
.text$mn:00003A4D                 push    edx             ; Str
.text$mn:00003A4E                 mov     ecx, [ebp+var_10]
.text$mn:00003A51                 add     ecx, 12Ch
.text$mn:00003A57                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00003A5C                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003A60                 mov     eax, [ebp+var_10]
.text$mn:00003A63                 mov     byte ptr [eax+24h], 1
.text$mn:00003A67                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A6E                 lea     ecx, [ebp+arg_0] ; this
.text$mn:00003A71                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:00003A76                 mov     eax, [ebp+var_10]
.text$mn:00003A79                 mov     ecx, [ebp+var_C]
.text$mn:00003A7C                 mov     large fs:0, ecx
.text$mn:00003A83                 pop     ecx
.text$mn:00003A84                 mov     esp, ebp
.text$mn:00003A86                 pop     ebp
.text$mn:00003A87                 retn    130h
.text$mn:00003A87 ??0UserCommand@@QAE@VShortcut@@PB_WH@Z endp
.text$mn:00003A87
.text$mn:00003A87 ; ---------------------------------------------------------------------------
.text$mn:00003A8A                 align 4
.text$mn:00003A8A _text$mn        ends
.text$mn:00003A8A
.text$x:00003A8C ; ===========================================================================
.text$x:00003A8C
.text$x:00003A8C ; Segment type: Pure code
.text$x:00003A8C ; Segment permissions: Read/Execute
.text$x:00003A8C _text$x         segment para public 'CODE' use32
.text$x:00003A8C                 assume cs:_text$x
.text$x:00003A8C                 ;org 3A8Ch
.text$x:00003A8C ; COMDAT (pick associative to section at 39D4)
.text$x:00003A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003A8C
.text$x:00003A8C ; =============== S U B R O U T I N E =======================================
.text$x:00003A8C
.text$x:00003A8C
.text$x:00003A8C __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$0 proc near
.text$x:00003A8C                                         ; DATA XREF: .xdata$x:00008948o
.text$x:00003A8C                 lea     ecx, [ebp+8]    ; this
.text$x:00003A8F                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00003A8F __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$0 endp
.text$x:00003A8F
.text$x:00003A94
.text$x:00003A94 ; =============== S U B R O U T I N E =======================================
.text$x:00003A94
.text$x:00003A94
.text$x:00003A94 __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$1 proc near
.text$x:00003A94                                         ; DATA XREF: .xdata$x:00008950o
.text$x:00003A94                 mov     ecx, [ebp-18h]  ; this
.text$x:00003A97                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:00003A97 __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$1 endp
.text$x:00003A97
.text$x:00003A9C
.text$x:00003A9C ; =============== S U B R O U T I N E =======================================
.text$x:00003A9C
.text$x:00003A9C
.text$x:00003A9C __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$2 proc near
.text$x:00003A9C                                         ; DATA XREF: .xdata$x:00008958o
.text$x:00003A9C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003A9F                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:00003A9F __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$2 endp
.text$x:00003A9F
.text$x:00003AA4
.text$x:00003AA4 ; =============== S U B R O U T I N E =======================================
.text$x:00003AA4
.text$x:00003AA4
.text$x:00003AA4 __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$3 proc near
.text$x:00003AA4                                         ; DATA XREF: .xdata$x:00008960o
.text$x:00003AA4                 mov     ecx, [ebp-10h]
.text$x:00003AA7                 add     ecx, 12Ch
.text$x:00003AAD                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00003AAD __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$3 endp
.text$x:00003AAD
.text$x:00003AB2
.text$x:00003AB2 ; =============== S U B R O U T I N E =======================================
.text$x:00003AB2
.text$x:00003AB2
.text$x:00003AB2 __ehhandler$??0UserCommand@@QAE@VShortcut@@PB_WH@Z proc near
.text$x:00003AB2                                         ; DATA XREF: UserCommand::UserCommand(Shortcut,wchar_t const *,int)+5o
.text$x:00003AB2
.text$x:00003AB2 arg_4           = dword ptr  8
.text$x:00003AB2
.text$x:00003AB2                 mov     edx, [esp+arg_4]
.text$x:00003AB6                 lea     eax, [edx+0Ch]
.text$x:00003AB9                 mov     ecx, [edx-18h]
.text$x:00003ABC                 xor     ecx, eax
.text$x:00003ABE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AC3                 mov     eax, offset __ehfuncinfo$??0UserCommand@@QAE@VShortcut@@PB_WH@Z
.text$x:00003AC8                 jmp     ___CxxFrameHandler3
.text$x:00003AC8 __ehhandler$??0UserCommand@@QAE@VShortcut@@PB_WH@Z endp
.text$x:00003AC8
.text$x:00003AC8 ; ---------------------------------------------------------------------------
.text$x:00003ACD                 align 10h
.text$x:00003ACD _text$x         ends
.text$x:00003ACD
.text$mn:00003AD0 ; ===========================================================================
.text$mn:00003AD0
.text$mn:00003AD0 ; Segment type: Pure code
.text$mn:00003AD0 ; Segment permissions: Read/Execute
.text$mn:00003AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00003AD0                 assume cs:_text$mn
.text$mn:00003AD0                 ;org 3AD0h
.text$mn:00003AD0 ; COMDAT (pick any)
.text$mn:00003AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AD0
.text$mn:00003AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AD0
.text$mn:00003AD0 ; Attributes: bp-based frame
.text$mn:00003AD0
.text$mn:00003AD0 ; _DWORD __thiscall Window::Window(Window *__hidden this)
.text$mn:00003AD0                 public ??0Window@@QAE@XZ
.text$mn:00003AD0 ??0Window@@QAE@XZ proc near             ; CODE XREF: StaticDialog::StaticDialog(void)+29p
.text$mn:00003AD0
.text$mn:00003AD0 var_4           = dword ptr -4
.text$mn:00003AD0
.text$mn:00003AD0                 push    ebp
.text$mn:00003AD1                 mov     ebp, esp
.text$mn:00003AD3                 push    ecx
.text$mn:00003AD4                 mov     [ebp+var_4], ecx
.text$mn:00003AD7                 mov     eax, [ebp+var_4]
.text$mn:00003ADA                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:00003AE0                 mov     ecx, [ebp+var_4]
.text$mn:00003AE3                 mov     dword ptr [ecx+4], 0
.text$mn:00003AEA                 mov     edx, [ebp+var_4]
.text$mn:00003AED                 mov     dword ptr [edx+8], 0
.text$mn:00003AF4                 mov     eax, [ebp+var_4]
.text$mn:00003AF7                 mov     dword ptr [eax+0Ch], 0
.text$mn:00003AFE                 mov     eax, [ebp+var_4]
.text$mn:00003B01                 mov     esp, ebp
.text$mn:00003B03                 pop     ebp
.text$mn:00003B04                 retn
.text$mn:00003B04 ??0Window@@QAE@XZ endp
.text$mn:00003B04
.text$mn:00003B04 ; ---------------------------------------------------------------------------
.text$mn:00003B05                 align 4
.text$mn:00003B05 _text$mn        ends
.text$mn:00003B05
.text$mn:00003B08 ; ===========================================================================
.text$mn:00003B08
.text$mn:00003B08 ; Segment type: Pure code
.text$mn:00003B08 ; Segment permissions: Read/Execute
.text$mn:00003B08 _text$mn        segment para public 'CODE' use32
.text$mn:00003B08                 assume cs:_text$mn
.text$mn:00003B08                 ;org 3B08h
.text$mn:00003B08 ; COMDAT (pick any)
.text$mn:00003B08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B08
.text$mn:00003B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B08
.text$mn:00003B08 ; Attributes: bp-based frame
.text$mn:00003B08
.text$mn:00003B08 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00003B08                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00003B08 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00003B08                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00003B08                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p
.text$mn:00003B08
.text$mn:00003B08 var_4           = dword ptr -4
.text$mn:00003B08
.text$mn:00003B08                 push    ebp
.text$mn:00003B09                 mov     ebp, esp
.text$mn:00003B0B                 push    ecx
.text$mn:00003B0C                 mov     [ebp+var_4], ecx
.text$mn:00003B0F                 mov     eax, [ebp+var_4]
.text$mn:00003B12                 mov     dword ptr [eax], 0
.text$mn:00003B18                 mov     eax, [ebp+var_4]
.text$mn:00003B1B                 mov     esp, ebp
.text$mn:00003B1D                 pop     ebp
.text$mn:00003B1E                 retn
.text$mn:00003B1E ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00003B1E
.text$mn:00003B1E ; ---------------------------------------------------------------------------
.text$mn:00003B1F                 align 10h
.text$mn:00003B1F _text$mn        ends
.text$mn:00003B1F
.text$mn:00003B20 ; ===========================================================================
.text$mn:00003B20
.text$mn:00003B20 ; Segment type: Pure code
.text$mn:00003B20 ; Segment permissions: Read/Execute
.text$mn:00003B20 _text$mn        segment para public 'CODE' use32
.text$mn:00003B20                 assume cs:_text$mn
.text$mn:00003B20                 ;org 3B20h
.text$mn:00003B20 ; COMDAT (pick any)
.text$mn:00003B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B20
.text$mn:00003B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B20
.text$mn:00003B20 ; Attributes: bp-based frame
.text$mn:00003B20
.text$mn:00003B20 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00003B20                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00003B20 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00003B20                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00003B20                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p
.text$mn:00003B20
.text$mn:00003B20 var_4           = dword ptr -4
.text$mn:00003B20
.text$mn:00003B20                 push    ebp
.text$mn:00003B21                 mov     ebp, esp
.text$mn:00003B23                 push    ecx
.text$mn:00003B24                 mov     [ebp+var_4], ecx
.text$mn:00003B27                 mov     eax, [ebp+var_4]
.text$mn:00003B2A                 mov     dword ptr [eax], 0
.text$mn:00003B30                 mov     ecx, [ebp+var_4]
.text$mn:00003B33                 mov     dword ptr [ecx+4], 0
.text$mn:00003B3A                 mov     eax, [ebp+var_4]
.text$mn:00003B3D                 mov     esp, ebp
.text$mn:00003B3F                 pop     ebp
.text$mn:00003B40                 retn
.text$mn:00003B40 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00003B40
.text$mn:00003B40 ; ---------------------------------------------------------------------------
.text$mn:00003B41                 align 4
.text$mn:00003B41 _text$mn        ends
.text$mn:00003B41
.text$mn:00003B44 ; ===========================================================================
.text$mn:00003B44
.text$mn:00003B44 ; Segment type: Pure code
.text$mn:00003B44 ; Segment permissions: Read/Execute
.text$mn:00003B44 _text$mn        segment para public 'CODE' use32
.text$mn:00003B44                 assume cs:_text$mn
.text$mn:00003B44                 ;org 3B44h
.text$mn:00003B44 ; COMDAT (pick any)
.text$mn:00003B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B44
.text$mn:00003B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B44
.text$mn:00003B44 ; Attributes: bp-based frame
.text$mn:00003B44
.text$mn:00003B44 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00003B44                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00003B44 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00003B44                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00003B44                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00003B44
.text$mn:00003B44 var_10          = dword ptr -10h
.text$mn:00003B44 var_C           = dword ptr -0Ch
.text$mn:00003B44 var_4           = dword ptr -4
.text$mn:00003B44
.text$mn:00003B44                 push    ebp
.text$mn:00003B45                 mov     ebp, esp
.text$mn:00003B47                 push    0FFFFFFFFh
.text$mn:00003B49                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00003B4E                 mov     eax, large fs:0
.text$mn:00003B54                 push    eax
.text$mn:00003B55                 push    ecx
.text$mn:00003B56                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B5B                 xor     eax, ebp
.text$mn:00003B5D                 push    eax
.text$mn:00003B5E                 lea     eax, [ebp+var_C]
.text$mn:00003B61                 mov     large fs:0, eax
.text$mn:00003B67                 mov     [ebp+var_10], ecx
.text$mn:00003B6A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003B6D                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00003B72                 mov     [ebp+var_4], 0
.text$mn:00003B79                 mov     eax, [ebp+var_10]
.text$mn:00003B7C                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00003B82                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B89                 mov     eax, [ebp+var_10]
.text$mn:00003B8C                 mov     ecx, [ebp+var_C]
.text$mn:00003B8F                 mov     large fs:0, ecx
.text$mn:00003B96                 pop     ecx
.text$mn:00003B97                 mov     esp, ebp
.text$mn:00003B99                 pop     ebp
.text$mn:00003B9A                 retn
.text$mn:00003B9A ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00003B9A
.text$mn:00003B9A ; ---------------------------------------------------------------------------
.text$mn:00003B9B                 align 4
.text$mn:00003B9B _text$mn        ends
.text$mn:00003B9B
.text$x:00003B9C ; ===========================================================================
.text$x:00003B9C
.text$x:00003B9C ; Segment type: Pure code
.text$x:00003B9C ; Segment permissions: Read/Execute
.text$x:00003B9C _text$x         segment para public 'CODE' use32
.text$x:00003B9C                 assume cs:_text$x
.text$x:00003B9C                 ;org 3B9Ch
.text$x:00003B9C ; COMDAT (pick associative to section at 3B44)
.text$x:00003B9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B9C
.text$x:00003B9C ; =============== S U B R O U T I N E =======================================
.text$x:00003B9C
.text$x:00003B9C
.text$x:00003B9C __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00003B9C                                         ; DATA XREF: .xdata$x:000082A0o
.text$x:00003B9C                 mov     ecx, [ebp-10h]  ; this
.text$x:00003B9F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00003B9F __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00003B9F
.text$x:00003BA4
.text$x:00003BA4 ; =============== S U B R O U T I N E =======================================
.text$x:00003BA4
.text$x:00003BA4
.text$x:00003BA4 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00003BA4                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00003BA4
.text$x:00003BA4 arg_4           = dword ptr  8
.text$x:00003BA4
.text$x:00003BA4                 mov     edx, [esp+arg_4]
.text$x:00003BA8                 lea     eax, [edx+0Ch]
.text$x:00003BAB                 mov     ecx, [edx-8]
.text$x:00003BAE                 xor     ecx, eax
.text$x:00003BB0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BB5                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00003BBA                 jmp     ___CxxFrameHandler3
.text$x:00003BBA __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00003BBA
.text$x:00003BBA ; ---------------------------------------------------------------------------
.text$x:00003BBF                 align 10h
.text$x:00003BBF _text$x         ends
.text$x:00003BBF
.text$mn:00003BC0 ; ===========================================================================
.text$mn:00003BC0
.text$mn:00003BC0 ; Segment type: Pure code
.text$mn:00003BC0 ; Segment permissions: Read/Execute
.text$mn:00003BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003BC0                 assume cs:_text$mn
.text$mn:00003BC0                 ;org 3BC0h
.text$mn:00003BC0 ; COMDAT (pick any)
.text$mn:00003BC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BC0
.text$mn:00003BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BC0
.text$mn:00003BC0 ; Attributes: bp-based frame
.text$mn:00003BC0
.text$mn:00003BC0 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00003BC0                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00003BC0 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00003BC0
.text$mn:00003BC0 var_4           = dword ptr -4
.text$mn:00003BC0
.text$mn:00003BC0                 push    ebp
.text$mn:00003BC1                 mov     ebp, esp
.text$mn:00003BC3                 push    ecx
.text$mn:00003BC4                 mov     [ebp+var_4], ecx
.text$mn:00003BC7                 mov     eax, [ebp+var_4]
.text$mn:00003BCA                 mov     esp, ebp
.text$mn:00003BCC                 pop     ebp
.text$mn:00003BCD                 retn
.text$mn:00003BCD ??0_Ignore@std@@QAE@XZ endp
.text$mn:00003BCD
.text$mn:00003BCD ; ---------------------------------------------------------------------------
.text$mn:00003BCE                 align 10h
.text$mn:00003BCE _text$mn        ends
.text$mn:00003BCE
.text$mn:00003BD0 ; ===========================================================================
.text$mn:00003BD0
.text$mn:00003BD0 ; Segment type: Pure code
.text$mn:00003BD0 ; Segment permissions: Read/Execute
.text$mn:00003BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00003BD0                 assume cs:_text$mn
.text$mn:00003BD0                 ;org 3BD0h
.text$mn:00003BD0 ; COMDAT (pick any)
.text$mn:00003BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BD0
.text$mn:00003BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003BD0
.text$mn:00003BD0 ; Attributes: bp-based frame
.text$mn:00003BD0
.text$mn:00003BD0 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00003BD0                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00003BD0 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00003BD0                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00003BD0
.text$mn:00003BD0 var_10          = dword ptr -10h
.text$mn:00003BD0 var_C           = dword ptr -0Ch
.text$mn:00003BD0 var_4           = dword ptr -4
.text$mn:00003BD0
.text$mn:00003BD0                 push    ebp
.text$mn:00003BD1                 mov     ebp, esp
.text$mn:00003BD3                 push    0FFFFFFFFh
.text$mn:00003BD5                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00003BDA                 mov     eax, large fs:0
.text$mn:00003BE0                 push    eax
.text$mn:00003BE1                 push    ecx
.text$mn:00003BE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003BE7                 xor     eax, ebp
.text$mn:00003BE9                 push    eax
.text$mn:00003BEA                 lea     eax, [ebp+var_C]
.text$mn:00003BED                 mov     large fs:0, eax
.text$mn:00003BF3                 mov     [ebp+var_10], ecx
.text$mn:00003BF6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003BF9                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003BFE                 mov     [ebp+var_4], 0
.text$mn:00003C05                 mov     eax, [ebp+var_10]
.text$mn:00003C08                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00003C0E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C15                 mov     eax, [ebp+var_10]
.text$mn:00003C18                 mov     ecx, [ebp+var_C]
.text$mn:00003C1B                 mov     large fs:0, ecx
.text$mn:00003C22                 pop     ecx
.text$mn:00003C23                 mov     esp, ebp
.text$mn:00003C25                 pop     ebp
.text$mn:00003C26                 retn
.text$mn:00003C26 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00003C26
.text$mn:00003C26 ; ---------------------------------------------------------------------------
.text$mn:00003C27                 align 4
.text$mn:00003C27 _text$mn        ends
.text$mn:00003C27
.text$x:00003C28 ; ===========================================================================
.text$x:00003C28
.text$x:00003C28 ; Segment type: Pure code
.text$x:00003C28 ; Segment permissions: Read/Execute
.text$x:00003C28 _text$x         segment para public 'CODE' use32
.text$x:00003C28                 assume cs:_text$x
.text$x:00003C28                 ;org 3C28h
.text$x:00003C28 ; COMDAT (pick associative to section at 3BD0)
.text$x:00003C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003C28
.text$x:00003C28 ; =============== S U B R O U T I N E =======================================
.text$x:00003C28
.text$x:00003C28
.text$x:00003C28 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00003C28                                         ; DATA XREF: .xdata$x:00008324o
.text$x:00003C28                 mov     ecx, [ebp-10h]  ; this
.text$x:00003C2B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003C2B __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00003C2B
.text$x:00003C30
.text$x:00003C30 ; =============== S U B R O U T I N E =======================================
.text$x:00003C30
.text$x:00003C30
.text$x:00003C30 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00003C30                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00003C30
.text$x:00003C30 arg_4           = dword ptr  8
.text$x:00003C30
.text$x:00003C30                 mov     edx, [esp+arg_4]
.text$x:00003C34                 lea     eax, [edx+0Ch]
.text$x:00003C37                 mov     ecx, [edx-8]
.text$x:00003C3A                 xor     ecx, eax
.text$x:00003C3C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C41                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00003C46                 jmp     ___CxxFrameHandler3
.text$x:00003C46 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00003C46
.text$x:00003C46 ; ---------------------------------------------------------------------------
.text$x:00003C4B                 align 4
.text$x:00003C4B _text$x         ends
.text$x:00003C4B
.text$mn:00003C4C ; ===========================================================================
.text$mn:00003C4C
.text$mn:00003C4C ; Segment type: Pure code
.text$mn:00003C4C ; Segment permissions: Read/Execute
.text$mn:00003C4C _text$mn        segment para public 'CODE' use32
.text$mn:00003C4C                 assume cs:_text$mn
.text$mn:00003C4C                 ;org 3C4Ch
.text$mn:00003C4C ; COMDAT (pick any)
.text$mn:00003C4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C4C
.text$mn:00003C4C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C4C
.text$mn:00003C4C ; Attributes: bp-based frame
.text$mn:00003C4C
.text$mn:00003C4C ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00003C4C                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00003C4C ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00003C4C                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00003C4C
.text$mn:00003C4C var_4           = dword ptr -4
.text$mn:00003C4C arg_0           = dword ptr  8
.text$mn:00003C4C
.text$mn:00003C4C                 push    ebp
.text$mn:00003C4D                 mov     ebp, esp
.text$mn:00003C4F                 push    ecx
.text$mn:00003C50                 mov     [ebp+var_4], ecx
.text$mn:00003C53                 mov     eax, [ebp+var_4]
.text$mn:00003C56                 mov     dword ptr [eax], 0
.text$mn:00003C5C                 mov     ecx, [ebp+var_4]
.text$mn:00003C5F                 mov     dword ptr [ecx+4], 0
.text$mn:00003C66                 mov     edx, [ebp+arg_0]
.text$mn:00003C69                 push    edx
.text$mn:00003C6A                 mov     ecx, [ebp+var_4]
.text$mn:00003C6D                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00003C72                 mov     eax, [ebp+var_4]
.text$mn:00003C75                 mov     esp, ebp
.text$mn:00003C77                 pop     ebp
.text$mn:00003C78                 retn    4
.text$mn:00003C78 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00003C78
.text$mn:00003C78 ; ---------------------------------------------------------------------------
.text$mn:00003C7B                 align 4
.text$mn:00003C7B _text$mn        ends
.text$mn:00003C7B
.text$mn:00003C7C ; ===========================================================================
.text$mn:00003C7C
.text$mn:00003C7C ; Segment type: Pure code
.text$mn:00003C7C ; Segment permissions: Read/Execute
.text$mn:00003C7C _text$mn        segment para public 'CODE' use32
.text$mn:00003C7C                 assume cs:_text$mn
.text$mn:00003C7C                 ;org 3C7Ch
.text$mn:00003C7C ; COMDAT (pick any)
.text$mn:00003C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C7C
.text$mn:00003C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C7C
.text$mn:00003C7C ; Attributes: bp-based frame
.text$mn:00003C7C
.text$mn:00003C7C ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003C7C                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00003C7C ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003C7C                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+29p
.text$mn:00003C7C
.text$mn:00003C7C var_4           = dword ptr -4
.text$mn:00003C7C
.text$mn:00003C7C                 push    ebp
.text$mn:00003C7D                 mov     ebp, esp
.text$mn:00003C7F                 push    ecx
.text$mn:00003C80                 mov     [ebp+var_4], ecx
.text$mn:00003C83                 mov     eax, [ebp+var_4]
.text$mn:00003C86                 mov     dword ptr [eax], 0
.text$mn:00003C8C                 mov     ecx, [ebp+var_4]
.text$mn:00003C8F                 mov     dword ptr [ecx+4], 0
.text$mn:00003C96                 mov     eax, [ebp+var_4]
.text$mn:00003C99                 mov     esp, ebp
.text$mn:00003C9B                 pop     ebp
.text$mn:00003C9C                 retn
.text$mn:00003C9C ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00003C9C
.text$mn:00003C9C ; ---------------------------------------------------------------------------
.text$mn:00003C9D                 align 10h
.text$mn:00003C9D _text$mn        ends
.text$mn:00003C9D
.text$mn:00003CA0 ; ===========================================================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Segment type: Pure code
.text$mn:00003CA0 ; Segment permissions: Read/Execute
.text$mn:00003CA0 _text$mn        segment para public 'CODE' use32
.text$mn:00003CA0                 assume cs:_text$mn
.text$mn:00003CA0                 ;org 3CA0h
.text$mn:00003CA0 ; COMDAT (pick any)
.text$mn:00003CA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CA0
.text$mn:00003CA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CA0
.text$mn:00003CA0 ; Attributes: bp-based frame
.text$mn:00003CA0
.text$mn:00003CA0 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00003CA0                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00003CA0 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00003CA0                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00003CA0
.text$mn:00003CA0 var_10          = dword ptr -10h
.text$mn:00003CA0 var_C           = dword ptr -0Ch
.text$mn:00003CA0 var_4           = dword ptr -4
.text$mn:00003CA0
.text$mn:00003CA0                 push    ebp
.text$mn:00003CA1                 mov     ebp, esp
.text$mn:00003CA3                 push    0FFFFFFFFh
.text$mn:00003CA5                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00003CAA                 mov     eax, large fs:0
.text$mn:00003CB0                 push    eax
.text$mn:00003CB1                 push    ecx
.text$mn:00003CB2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003CB7                 xor     eax, ebp
.text$mn:00003CB9                 push    eax
.text$mn:00003CBA                 lea     eax, [ebp+var_C]
.text$mn:00003CBD                 mov     large fs:0, eax
.text$mn:00003CC3                 mov     [ebp+var_10], ecx
.text$mn:00003CC6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003CC9                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00003CCE                 mov     [ebp+var_4], 0
.text$mn:00003CD5                 mov     eax, [ebp+var_10]
.text$mn:00003CD8                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00003CDE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003CE5                 mov     eax, [ebp+var_10]
.text$mn:00003CE8                 mov     ecx, [ebp+var_C]
.text$mn:00003CEB                 mov     large fs:0, ecx
.text$mn:00003CF2                 pop     ecx
.text$mn:00003CF3                 mov     esp, ebp
.text$mn:00003CF5                 pop     ebp
.text$mn:00003CF6                 retn
.text$mn:00003CF6 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00003CF6
.text$mn:00003CF6 ; ---------------------------------------------------------------------------
.text$mn:00003CF7                 align 4
.text$mn:00003CF7 _text$mn        ends
.text$mn:00003CF7
.text$x:00003CF8 ; ===========================================================================
.text$x:00003CF8
.text$x:00003CF8 ; Segment type: Pure code
.text$x:00003CF8 ; Segment permissions: Read/Execute
.text$x:00003CF8 _text$x         segment para public 'CODE' use32
.text$x:00003CF8                 assume cs:_text$x
.text$x:00003CF8                 ;org 3CF8h
.text$x:00003CF8 ; COMDAT (pick associative to section at 3CA0)
.text$x:00003CF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003CF8
.text$x:00003CF8 ; =============== S U B R O U T I N E =======================================
.text$x:00003CF8
.text$x:00003CF8
.text$x:00003CF8 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00003CF8                                         ; DATA XREF: .xdata$x:000083A8o
.text$x:00003CF8                 mov     ecx, [ebp-10h]  ; this
.text$x:00003CFB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003CFB __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00003CFB
.text$x:00003D00
.text$x:00003D00 ; =============== S U B R O U T I N E =======================================
.text$x:00003D00
.text$x:00003D00
.text$x:00003D00 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00003D00                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00003D00
.text$x:00003D00 arg_4           = dword ptr  8
.text$x:00003D00
.text$x:00003D00                 mov     edx, [esp+arg_4]
.text$x:00003D04                 lea     eax, [edx+0Ch]
.text$x:00003D07                 mov     ecx, [edx-8]
.text$x:00003D0A                 xor     ecx, eax
.text$x:00003D0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003D11                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00003D16                 jmp     ___CxxFrameHandler3
.text$x:00003D16 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00003D16
.text$x:00003D16 ; ---------------------------------------------------------------------------
.text$x:00003D1B                 align 4
.text$x:00003D1B _text$x         ends
.text$x:00003D1B
.text$mn:00003D1C ; ===========================================================================
.text$mn:00003D1C
.text$mn:00003D1C ; Segment type: Pure code
.text$mn:00003D1C ; Segment permissions: Read/Execute
.text$mn:00003D1C _text$mn        segment para public 'CODE' use32
.text$mn:00003D1C                 assume cs:_text$mn
.text$mn:00003D1C                 ;org 3D1Ch
.text$mn:00003D1C ; COMDAT (pick any)
.text$mn:00003D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D1C
.text$mn:00003D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D1C
.text$mn:00003D1C ; Attributes: bp-based frame
.text$mn:00003D1C
.text$mn:00003D1C ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00003D1C                 public ??0error_category@std@@QAE@XZ
.text$mn:00003D1C ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00003D1C
.text$mn:00003D1C var_4           = dword ptr -4
.text$mn:00003D1C
.text$mn:00003D1C                 push    ebp
.text$mn:00003D1D                 mov     ebp, esp
.text$mn:00003D1F                 push    ecx
.text$mn:00003D20                 mov     [ebp+var_4], ecx
.text$mn:00003D23                 mov     eax, [ebp+var_4]
.text$mn:00003D26                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00003D2C                 mov     eax, [ebp+var_4]
.text$mn:00003D2F                 mov     esp, ebp
.text$mn:00003D31                 pop     ebp
.text$mn:00003D32                 retn
.text$mn:00003D32 ??0error_category@std@@QAE@XZ endp
.text$mn:00003D32
.text$mn:00003D32 ; ---------------------------------------------------------------------------
.text$mn:00003D33                 align 4
.text$mn:00003D33 _text$mn        ends
.text$mn:00003D33
.text$mn:00003D34 ; ===========================================================================
.text$mn:00003D34
.text$mn:00003D34 ; Segment type: Pure code
.text$mn:00003D34 ; Segment permissions: Read/Execute
.text$mn:00003D34 _text$mn        segment para public 'CODE' use32
.text$mn:00003D34                 assume cs:_text$mn
.text$mn:00003D34                 ;org 3D34h
.text$mn:00003D34 ; COMDAT (pick any)
.text$mn:00003D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D34
.text$mn:00003D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D34
.text$mn:00003D34 ; Attributes: bp-based frame
.text$mn:00003D34
.text$mn:00003D34 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00003D34                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00003D34 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00003D34                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00003D34                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00003D34
.text$mn:00003D34 var_4           = dword ptr -4
.text$mn:00003D34 arg_0           = dword ptr  8
.text$mn:00003D34 arg_4           = dword ptr  0Ch
.text$mn:00003D34
.text$mn:00003D34                 push    ebp
.text$mn:00003D35                 mov     ebp, esp
.text$mn:00003D37                 push    ecx
.text$mn:00003D38                 mov     [ebp+var_4], ecx
.text$mn:00003D3B                 mov     eax, [ebp+var_4]
.text$mn:00003D3E                 mov     ecx, [ebp+arg_0]
.text$mn:00003D41                 mov     [eax], ecx
.text$mn:00003D43                 mov     edx, [ebp+var_4]
.text$mn:00003D46                 mov     eax, [ebp+arg_4]
.text$mn:00003D49                 mov     [edx+4], eax
.text$mn:00003D4C                 mov     eax, [ebp+var_4]
.text$mn:00003D4F                 mov     esp, ebp
.text$mn:00003D51                 pop     ebp
.text$mn:00003D52                 retn    8
.text$mn:00003D52 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00003D52
.text$mn:00003D52 ; ---------------------------------------------------------------------------
.text$mn:00003D55                 align 4
.text$mn:00003D55 _text$mn        ends
.text$mn:00003D55
.text$mn:00003D58 ; ===========================================================================
.text$mn:00003D58
.text$mn:00003D58 ; Segment type: Pure code
.text$mn:00003D58 ; Segment permissions: Read/Execute
.text$mn:00003D58 _text$mn        segment para public 'CODE' use32
.text$mn:00003D58                 assume cs:_text$mn
.text$mn:00003D58                 ;org 3D58h
.text$mn:00003D58 ; COMDAT (pick any)
.text$mn:00003D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D58
.text$mn:00003D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D58
.text$mn:00003D58 ; Attributes: bp-based frame
.text$mn:00003D58
.text$mn:00003D58 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00003D58                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00003D58 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00003D58                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00003D58
.text$mn:00003D58 var_4           = dword ptr -4
.text$mn:00003D58 arg_0           = dword ptr  8
.text$mn:00003D58
.text$mn:00003D58                 push    ebp
.text$mn:00003D59                 mov     ebp, esp
.text$mn:00003D5B                 push    ecx
.text$mn:00003D5C                 mov     [ebp+var_4], ecx
.text$mn:00003D5F                 mov     eax, [ebp+var_4]
.text$mn:00003D62                 mov     ecx, [ebp+arg_0]
.text$mn:00003D65                 mov     [eax], ecx
.text$mn:00003D67                 mov     eax, [ebp+var_4]
.text$mn:00003D6A                 mov     esp, ebp
.text$mn:00003D6C                 pop     ebp
.text$mn:00003D6D                 retn    4
.text$mn:00003D6D ??0id@locale@std@@QAE@I@Z endp
.text$mn:00003D6D
.text$mn:00003D6D _text$mn        ends
.text$mn:00003D6D
.text$mn:00003D70 ; ===========================================================================
.text$mn:00003D70
.text$mn:00003D70 ; Segment type: Pure code
.text$mn:00003D70 ; Segment permissions: Read/Execute
.text$mn:00003D70 _text$mn        segment para public 'CODE' use32
.text$mn:00003D70                 assume cs:_text$mn
.text$mn:00003D70                 ;org 3D70h
.text$mn:00003D70 ; COMDAT (pick any)
.text$mn:00003D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D70
.text$mn:00003D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D70
.text$mn:00003D70 ; Attributes: bp-based frame
.text$mn:00003D70
.text$mn:00003D70 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, wchar_t, int, wchar_t const *, wchar_t const &, struct std::_Iterator_base12>(void)
.text$mn:00003D70                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003D70 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003D70                                         ; CODE XREF: __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00003D70                                         ; __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00003D70
.text$mn:00003D70 var_10          = dword ptr -10h
.text$mn:00003D70 var_C           = dword ptr -0Ch
.text$mn:00003D70 var_4           = dword ptr -4
.text$mn:00003D70
.text$mn:00003D70                 push    ebp
.text$mn:00003D71                 mov     ebp, esp
.text$mn:00003D73                 push    0FFFFFFFFh
.text$mn:00003D75                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003D7A                 mov     eax, large fs:0
.text$mn:00003D80                 push    eax
.text$mn:00003D81                 push    ecx
.text$mn:00003D82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003D87                 xor     eax, ebp
.text$mn:00003D89                 push    eax
.text$mn:00003D8A                 lea     eax, [ebp+var_C]
.text$mn:00003D8D                 mov     large fs:0, eax
.text$mn:00003D93                 mov     [ebp+var_10], ecx
.text$mn:00003D96                 mov     [ebp+var_4], 0
.text$mn:00003D9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003DA4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003DA7                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:00003DAC                 mov     ecx, [ebp+var_C]
.text$mn:00003DAF                 mov     large fs:0, ecx
.text$mn:00003DB6                 pop     ecx
.text$mn:00003DB7                 mov     esp, ebp
.text$mn:00003DB9                 pop     ebp
.text$mn:00003DBA                 retn
.text$mn:00003DBA ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00003DBA
.text$mn:00003DBA ; ---------------------------------------------------------------------------
.text$mn:00003DBB                 align 4
.text$mn:00003DBB _text$mn        ends
.text$mn:00003DBB
.text$x:00003DBC ; ===========================================================================
.text$x:00003DBC
.text$x:00003DBC ; Segment type: Pure code
.text$x:00003DBC ; Segment permissions: Read/Execute
.text$x:00003DBC _text$x         segment para public 'CODE' use32
.text$x:00003DBC                 assume cs:_text$x
.text$x:00003DBC                 ;org 3DBCh
.text$x:00003DBC ; COMDAT (pick associative to section at 3D70)
.text$x:00003DBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003DBC
.text$x:00003DBC ; =============== S U B R O U T I N E =======================================
.text$x:00003DBC
.text$x:00003DBC
.text$x:00003DBC __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00003DBC                                         ; DATA XREF: .xdata$x:00008B30o
.text$x:00003DBC                 mov     ecx, [ebp-10h]  ; this
.text$x:00003DBF                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00003DBF __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00003DBF
.text$x:00003DC4
.text$x:00003DC4 ; =============== S U B R O U T I N E =======================================
.text$x:00003DC4
.text$x:00003DC4
.text$x:00003DC4 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00003DC4                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)+5o
.text$x:00003DC4
.text$x:00003DC4 arg_4           = dword ptr  8
.text$x:00003DC4
.text$x:00003DC4                 mov     edx, [esp+arg_4]
.text$x:00003DC8                 lea     eax, [edx+0Ch]
.text$x:00003DCB                 mov     ecx, [edx-8]
.text$x:00003DCE                 xor     ecx, eax
.text$x:00003DD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003DD5                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.text$x:00003DDA                 jmp     ___CxxFrameHandler3
.text$x:00003DDA __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00003DDA
.text$x:00003DDA ; ---------------------------------------------------------------------------
.text$x:00003DDF                 align 10h
.text$x:00003DDF _text$x         ends
.text$x:00003DDF
.text$mn:00003DE0 ; ===========================================================================
.text$mn:00003DE0
.text$mn:00003DE0 ; Segment type: Pure code
.text$mn:00003DE0 ; Segment permissions: Read/Execute
.text$mn:00003DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DE0                 assume cs:_text$mn
.text$mn:00003DE0                 ;org 3DE0h
.text$mn:00003DE0 ; COMDAT (pick any)
.text$mn:00003DE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DE0
.text$mn:00003DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DE0
.text$mn:00003DE0 ; Attributes: bp-based frame
.text$mn:00003DE0
.text$mn:00003DE0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00003DE0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003DE0 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003DE0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00003DE0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00003DE0
.text$mn:00003DE0 var_10          = dword ptr -10h
.text$mn:00003DE0 var_C           = dword ptr -0Ch
.text$mn:00003DE0 var_4           = dword ptr -4
.text$mn:00003DE0
.text$mn:00003DE0                 push    ebp
.text$mn:00003DE1                 mov     ebp, esp
.text$mn:00003DE3                 push    0FFFFFFFFh
.text$mn:00003DE5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003DEA                 mov     eax, large fs:0
.text$mn:00003DF0                 push    eax
.text$mn:00003DF1                 push    ecx
.text$mn:00003DF2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003DF7                 xor     eax, ebp
.text$mn:00003DF9                 push    eax
.text$mn:00003DFA                 lea     eax, [ebp+var_C]
.text$mn:00003DFD                 mov     large fs:0, eax
.text$mn:00003E03                 mov     [ebp+var_10], ecx
.text$mn:00003E06                 mov     [ebp+var_4], 0
.text$mn:00003E0D                 mov     ecx, [ebp+var_10]
.text$mn:00003E10                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003E15                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E1C                 mov     ecx, [ebp+var_10]
.text$mn:00003E1F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00003E24                 mov     ecx, [ebp+var_C]
.text$mn:00003E27                 mov     large fs:0, ecx
.text$mn:00003E2E                 pop     ecx
.text$mn:00003E2F                 mov     esp, ebp
.text$mn:00003E31                 pop     ebp
.text$mn:00003E32                 retn
.text$mn:00003E32 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003E32
.text$mn:00003E32 ; ---------------------------------------------------------------------------
.text$mn:00003E33                 align 4
.text$mn:00003E33 _text$mn        ends
.text$mn:00003E33
.text$x:00003E34 ; ===========================================================================
.text$x:00003E34
.text$x:00003E34 ; Segment type: Pure code
.text$x:00003E34 ; Segment permissions: Read/Execute
.text$x:00003E34 _text$x         segment para public 'CODE' use32
.text$x:00003E34                 assume cs:_text$x
.text$x:00003E34                 ;org 3E34h
.text$x:00003E34 ; COMDAT (pick associative to section at 3DE0)
.text$x:00003E34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003E34
.text$x:00003E34 ; =============== S U B R O U T I N E =======================================
.text$x:00003E34
.text$x:00003E34
.text$x:00003E34 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003E34                                         ; DATA XREF: .xdata$x:00008190o
.text$x:00003E34                 mov     ecx, [ebp-10h]
.text$x:00003E37                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00003E37 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003E37
.text$x:00003E3C
.text$x:00003E3C ; =============== S U B R O U T I N E =======================================
.text$x:00003E3C
.text$x:00003E3C
.text$x:00003E3C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003E3C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00003E3C
.text$x:00003E3C arg_4           = dword ptr  8
.text$x:00003E3C
.text$x:00003E3C                 mov     edx, [esp+arg_4]
.text$x:00003E40                 lea     eax, [edx+0Ch]
.text$x:00003E43                 mov     ecx, [edx-8]
.text$x:00003E46                 xor     ecx, eax
.text$x:00003E48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003E4D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00003E52                 jmp     ___CxxFrameHandler3
.text$x:00003E52 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00003E52
.text$x:00003E52 ; ---------------------------------------------------------------------------
.text$x:00003E57                 align 4
.text$x:00003E57 _text$x         ends
.text$x:00003E57
.text$mn:00003E58 ; ===========================================================================
.text$mn:00003E58
.text$mn:00003E58 ; Segment type: Pure code
.text$mn:00003E58 ; Segment permissions: Read/Execute
.text$mn:00003E58 _text$mn        segment para public 'CODE' use32
.text$mn:00003E58                 assume cs:_text$mn
.text$mn:00003E58                 ;org 3E58h
.text$mn:00003E58 ; COMDAT (pick any)
.text$mn:00003E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E58
.text$mn:00003E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E58
.text$mn:00003E58 ; Attributes: bp-based frame
.text$mn:00003E58
.text$mn:00003E58 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:00003E58                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003E58 ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003E58                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:00003E58                                         ; __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0+3j ...
.text$mn:00003E58
.text$mn:00003E58 var_10          = dword ptr -10h
.text$mn:00003E58 var_C           = dword ptr -0Ch
.text$mn:00003E58 var_4           = dword ptr -4
.text$mn:00003E58
.text$mn:00003E58                 push    ebp
.text$mn:00003E59                 mov     ebp, esp
.text$mn:00003E5B                 push    0FFFFFFFFh
.text$mn:00003E5D                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003E62                 mov     eax, large fs:0
.text$mn:00003E68                 push    eax
.text$mn:00003E69                 push    ecx
.text$mn:00003E6A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E6F                 xor     eax, ebp
.text$mn:00003E71                 push    eax
.text$mn:00003E72                 lea     eax, [ebp+var_C]
.text$mn:00003E75                 mov     large fs:0, eax
.text$mn:00003E7B                 mov     [ebp+var_10], ecx
.text$mn:00003E7E                 mov     [ebp+var_4], 0
.text$mn:00003E85                 mov     ecx, [ebp+var_10]
.text$mn:00003E88                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00003E8D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003E94                 mov     ecx, [ebp+var_10]
.text$mn:00003E97                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:00003E9C                 mov     ecx, [ebp+var_C]
.text$mn:00003E9F                 mov     large fs:0, ecx
.text$mn:00003EA6                 pop     ecx
.text$mn:00003EA7                 mov     esp, ebp
.text$mn:00003EA9                 pop     ebp
.text$mn:00003EAA                 retn
.text$mn:00003EAA ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003EAA
.text$mn:00003EAA ; ---------------------------------------------------------------------------
.text$mn:00003EAB                 align 4
.text$mn:00003EAB _text$mn        ends
.text$mn:00003EAB
.text$x:00003EAC ; ===========================================================================
.text$x:00003EAC
.text$x:00003EAC ; Segment type: Pure code
.text$x:00003EAC ; Segment permissions: Read/Execute
.text$x:00003EAC _text$x         segment para public 'CODE' use32
.text$x:00003EAC                 assume cs:_text$x
.text$x:00003EAC                 ;org 3EACh
.text$x:00003EAC ; COMDAT (pick associative to section at 3E58)
.text$x:00003EAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003EAC
.text$x:00003EAC ; =============== S U B R O U T I N E =======================================
.text$x:00003EAC
.text$x:00003EAC
.text$x:00003EAC __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003EAC                                         ; DATA XREF: .xdata$x:000084B0o
.text$x:00003EAC                 mov     ecx, [ebp-10h]
.text$x:00003EAF                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00003EAF __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003EAF
.text$x:00003EB4
.text$x:00003EB4 ; =============== S U B R O U T I N E =======================================
.text$x:00003EB4
.text$x:00003EB4
.text$x:00003EB4 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003EB4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00003EB4
.text$x:00003EB4 arg_4           = dword ptr  8
.text$x:00003EB4
.text$x:00003EB4                 mov     edx, [esp+arg_4]
.text$x:00003EB8                 lea     eax, [edx+0Ch]
.text$x:00003EBB                 mov     ecx, [edx-8]
.text$x:00003EBE                 xor     ecx, eax
.text$x:00003EC0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003EC5                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00003ECA                 jmp     ___CxxFrameHandler3
.text$x:00003ECA __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00003ECA
.text$x:00003ECA ; ---------------------------------------------------------------------------
.text$x:00003ECF                 align 10h
.text$x:00003ECF _text$x         ends
.text$x:00003ECF
.text$mn:00003ED0 ; ===========================================================================
.text$mn:00003ED0
.text$mn:00003ED0 ; Segment type: Pure code
.text$mn:00003ED0 ; Segment permissions: Read/Execute
.text$mn:00003ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00003ED0                 assume cs:_text$mn
.text$mn:00003ED0                 ;org 3ED0h
.text$mn:00003ED0 ; COMDAT (pick any)
.text$mn:00003ED0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003ED0
.text$mn:00003ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003ED0
.text$mn:00003ED0 ; Attributes: bp-based frame
.text$mn:00003ED0
.text$mn:00003ED0 ; public: __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:00003ED0                 public ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003ED0 ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003ED0                                         ; CODE XREF: __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5+3j
.text$mn:00003ED0                                         ; __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7+3j ...
.text$mn:00003ED0
.text$mn:00003ED0 var_10          = dword ptr -10h
.text$mn:00003ED0 var_C           = dword ptr -0Ch
.text$mn:00003ED0 var_4           = dword ptr -4
.text$mn:00003ED0
.text$mn:00003ED0                 push    ebp
.text$mn:00003ED1                 mov     ebp, esp
.text$mn:00003ED3                 push    0FFFFFFFFh
.text$mn:00003ED5                 push    offset __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003EDA                 mov     eax, large fs:0
.text$mn:00003EE0                 push    eax
.text$mn:00003EE1                 push    ecx
.text$mn:00003EE2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003EE7                 xor     eax, ebp
.text$mn:00003EE9                 push    eax
.text$mn:00003EEA                 lea     eax, [ebp+var_C]
.text$mn:00003EED                 mov     large fs:0, eax
.text$mn:00003EF3                 mov     [ebp+var_10], ecx
.text$mn:00003EF6                 mov     [ebp+var_4], 0
.text$mn:00003EFD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F04                 mov     ecx, [ebp+var_10]
.text$mn:00003F07                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$mn:00003F0C                 mov     ecx, [ebp+var_C]
.text$mn:00003F0F                 mov     large fs:0, ecx
.text$mn:00003F16                 pop     ecx
.text$mn:00003F17                 mov     esp, ebp
.text$mn:00003F19                 pop     ebp
.text$mn:00003F1A                 retn
.text$mn:00003F1A ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003F1A
.text$mn:00003F1A ; ---------------------------------------------------------------------------
.text$mn:00003F1B                 align 4
.text$mn:00003F1B _text$mn        ends
.text$mn:00003F1B
.text$x:00003F1C ; ===========================================================================
.text$x:00003F1C
.text$x:00003F1C ; Segment type: Pure code
.text$x:00003F1C ; Segment permissions: Read/Execute
.text$x:00003F1C _text$x         segment para public 'CODE' use32
.text$x:00003F1C                 assume cs:_text$x
.text$x:00003F1C                 ;org 3F1Ch
.text$x:00003F1C ; COMDAT (pick associative to section at 3ED0)
.text$x:00003F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F1C
.text$x:00003F1C ; =============== S U B R O U T I N E =======================================
.text$x:00003F1C
.text$x:00003F1C
.text$x:00003F1C __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003F1C                                         ; DATA XREF: .xdata$x:00008BB4o
.text$x:00003F1C                 mov     ecx, [ebp-10h]
.text$x:00003F1F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,wchar_t,int,wchar_t const *,wchar_t const &,std::_Iterator_base12>(void)
.text$x:00003F1F __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003F1F
.text$x:00003F24
.text$x:00003F24 ; =============== S U B R O U T I N E =======================================
.text$x:00003F24
.text$x:00003F24
.text$x:00003F24 __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003F24                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:00003F24
.text$x:00003F24 arg_4           = dword ptr  8
.text$x:00003F24
.text$x:00003F24                 mov     edx, [esp+arg_4]
.text$x:00003F28                 lea     eax, [edx+0Ch]
.text$x:00003F2B                 mov     ecx, [edx-8]
.text$x:00003F2E                 xor     ecx, eax
.text$x:00003F30                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F35                 mov     eax, offset __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:00003F3A                 jmp     ___CxxFrameHandler3
.text$x:00003F3A __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00003F3A
.text$x:00003F3A ; ---------------------------------------------------------------------------
.text$x:00003F3F                 align 10h
.text$x:00003F3F _text$x         ends
.text$x:00003F3F
.text$mn:00003F40 ; ===========================================================================
.text$mn:00003F40
.text$mn:00003F40 ; Segment type: Pure code
.text$mn:00003F40 ; Segment permissions: Read/Execute
.text$mn:00003F40 _text$mn        segment para public 'CODE' use32
.text$mn:00003F40                 assume cs:_text$mn
.text$mn:00003F40                 ;org 3F40h
.text$mn:00003F40 ; COMDAT (pick any)
.text$mn:00003F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F40
.text$mn:00003F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F40
.text$mn:00003F40 ; Attributes: bp-based frame
.text$mn:00003F40
.text$mn:00003F40 ; public: __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::~_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>(void)
.text$mn:00003F40                 public ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003F40 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003F40                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+F5p
.text$mn:00003F40                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+101p ...
.text$mn:00003F40
.text$mn:00003F40 var_10          = dword ptr -10h
.text$mn:00003F40 var_C           = dword ptr -0Ch
.text$mn:00003F40 var_4           = dword ptr -4
.text$mn:00003F40
.text$mn:00003F40                 push    ebp
.text$mn:00003F41                 mov     ebp, esp
.text$mn:00003F43                 push    0FFFFFFFFh
.text$mn:00003F45                 push    offset __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$mn:00003F4A                 mov     eax, large fs:0
.text$mn:00003F50                 push    eax
.text$mn:00003F51                 push    ecx
.text$mn:00003F52                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003F57                 xor     eax, ebp
.text$mn:00003F59                 push    eax
.text$mn:00003F5A                 lea     eax, [ebp+var_C]
.text$mn:00003F5D                 mov     large fs:0, eax
.text$mn:00003F63                 mov     [ebp+var_10], ecx
.text$mn:00003F66                 mov     [ebp+var_4], 0
.text$mn:00003F6D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003F74                 mov     ecx, [ebp+var_10]
.text$mn:00003F77                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00003F7C                 mov     ecx, [ebp+var_C]
.text$mn:00003F7F                 mov     large fs:0, ecx
.text$mn:00003F86                 pop     ecx
.text$mn:00003F87                 mov     esp, ebp
.text$mn:00003F89                 pop     ebp
.text$mn:00003F8A                 retn
.text$mn:00003F8A ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003F8A
.text$mn:00003F8A ; ---------------------------------------------------------------------------
.text$mn:00003F8B                 align 4
.text$mn:00003F8B _text$mn        ends
.text$mn:00003F8B
.text$x:00003F8C ; ===========================================================================
.text$x:00003F8C
.text$x:00003F8C ; Segment type: Pure code
.text$x:00003F8C ; Segment permissions: Read/Execute
.text$x:00003F8C _text$x         segment para public 'CODE' use32
.text$x:00003F8C                 assume cs:_text$x
.text$x:00003F8C                 ;org 3F8Ch
.text$x:00003F8C ; COMDAT (pick associative to section at 3F40)
.text$x:00003F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F8C
.text$x:00003F8C ; =============== S U B R O U T I N E =======================================
.text$x:00003F8C
.text$x:00003F8C
.text$x:00003F8C __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003F8C                                         ; DATA XREF: .xdata$x:00008C64o
.text$x:00003F8C                 mov     ecx, [ebp-10h]
.text$x:00003F8F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00003F8F __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003F8F
.text$x:00003F94
.text$x:00003F94 ; =============== S U B R O U T I N E =======================================
.text$x:00003F94
.text$x:00003F94
.text$x:00003F94 __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003F94                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)+5o
.text$x:00003F94
.text$x:00003F94 arg_4           = dword ptr  8
.text$x:00003F94
.text$x:00003F94                 mov     edx, [esp+arg_4]
.text$x:00003F98                 lea     eax, [edx+0Ch]
.text$x:00003F9B                 mov     ecx, [edx-8]
.text$x:00003F9E                 xor     ecx, eax
.text$x:00003FA0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003FA5                 mov     eax, offset __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.text$x:00003FAA                 jmp     ___CxxFrameHandler3
.text$x:00003FAA __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00003FAA
.text$x:00003FAA ; ---------------------------------------------------------------------------
.text$x:00003FAF                 align 10h
.text$x:00003FAF _text$x         ends
.text$x:00003FAF
.text$mn:00003FB0 ; ===========================================================================
.text$mn:00003FB0
.text$mn:00003FB0 ; Segment type: Pure code
.text$mn:00003FB0 ; Segment permissions: Read/Execute
.text$mn:00003FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FB0                 assume cs:_text$mn
.text$mn:00003FB0                 ;org 3FB0h
.text$mn:00003FB0 ; COMDAT (pick any)
.text$mn:00003FB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FB0
.text$mn:00003FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FB0
.text$mn:00003FB0 ; Attributes: bp-based frame
.text$mn:00003FB0
.text$mn:00003FB0 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00003FB0                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00003FB0 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00003FB0                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00003FB0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00003FB0
.text$mn:00003FB0 var_10          = dword ptr -10h
.text$mn:00003FB0 var_C           = dword ptr -0Ch
.text$mn:00003FB0 var_4           = dword ptr -4
.text$mn:00003FB0
.text$mn:00003FB0                 push    ebp
.text$mn:00003FB1                 mov     ebp, esp
.text$mn:00003FB3                 push    0FFFFFFFFh
.text$mn:00003FB5                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00003FBA                 mov     eax, large fs:0
.text$mn:00003FC0                 push    eax
.text$mn:00003FC1                 push    ecx
.text$mn:00003FC2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FC7                 xor     eax, ebp
.text$mn:00003FC9                 push    eax
.text$mn:00003FCA                 lea     eax, [ebp+var_C]
.text$mn:00003FCD                 mov     large fs:0, eax
.text$mn:00003FD3                 mov     [ebp+var_10], ecx
.text$mn:00003FD6                 mov     [ebp+var_4], 0
.text$mn:00003FDD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003FE4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003FE7                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00003FEC                 mov     ecx, [ebp+var_C]
.text$mn:00003FEF                 mov     large fs:0, ecx
.text$mn:00003FF6                 pop     ecx
.text$mn:00003FF7                 mov     esp, ebp
.text$mn:00003FF9                 pop     ebp
.text$mn:00003FFA                 retn
.text$mn:00003FFA ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00003FFA
.text$mn:00003FFA ; ---------------------------------------------------------------------------
.text$mn:00003FFB                 align 4
.text$mn:00003FFB _text$mn        ends
.text$mn:00003FFB
.text$x:00003FFC ; ===========================================================================
.text$x:00003FFC
.text$x:00003FFC ; Segment type: Pure code
.text$x:00003FFC ; Segment permissions: Read/Execute
.text$x:00003FFC _text$x         segment para public 'CODE' use32
.text$x:00003FFC                 assume cs:_text$x
.text$x:00003FFC                 ;org 3FFCh
.text$x:00003FFC ; COMDAT (pick associative to section at 3FB0)
.text$x:00003FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003FFC
.text$x:00003FFC ; =============== S U B R O U T I N E =======================================
.text$x:00003FFC
.text$x:00003FFC
.text$x:00003FFC __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00003FFC                                         ; DATA XREF: .xdata$x:00008138o
.text$x:00003FFC                 mov     ecx, [ebp-10h]  ; this
.text$x:00003FFF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003FFF __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00003FFF
.text$x:00004004
.text$x:00004004 ; =============== S U B R O U T I N E =======================================
.text$x:00004004
.text$x:00004004
.text$x:00004004 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00004004                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00004004
.text$x:00004004 arg_4           = dword ptr  8
.text$x:00004004
.text$x:00004004                 mov     edx, [esp+arg_4]
.text$x:00004008                 lea     eax, [edx+0Ch]
.text$x:0000400B                 mov     ecx, [edx-8]
.text$x:0000400E                 xor     ecx, eax
.text$x:00004010                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004015                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000401A                 jmp     ___CxxFrameHandler3
.text$x:0000401A __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000401A
.text$x:0000401A ; ---------------------------------------------------------------------------
.text$x:0000401F                 align 10h
.text$x:0000401F _text$x         ends
.text$x:0000401F
.text$mn:00004020 ; ===========================================================================
.text$mn:00004020
.text$mn:00004020 ; Segment type: Pure code
.text$mn:00004020 ; Segment permissions: Read/Execute
.text$mn:00004020 _text$mn        segment para public 'CODE' use32
.text$mn:00004020                 assume cs:_text$mn
.text$mn:00004020                 ;org 4020h
.text$mn:00004020 ; COMDAT (pick any)
.text$mn:00004020                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004020
.text$mn:00004020 ; =============== S U B R O U T I N E =======================================
.text$mn:00004020
.text$mn:00004020 ; Attributes: bp-based frame
.text$mn:00004020
.text$mn:00004020 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00004020                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00004020 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00004020                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00004020                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00004020
.text$mn:00004020 var_10          = dword ptr -10h
.text$mn:00004020 var_C           = dword ptr -0Ch
.text$mn:00004020 var_4           = dword ptr -4
.text$mn:00004020
.text$mn:00004020                 push    ebp
.text$mn:00004021                 mov     ebp, esp
.text$mn:00004023                 push    0FFFFFFFFh
.text$mn:00004025                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000402A                 mov     eax, large fs:0
.text$mn:00004030                 push    eax
.text$mn:00004031                 push    ecx
.text$mn:00004032                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004037                 xor     eax, ebp
.text$mn:00004039                 push    eax
.text$mn:0000403A                 lea     eax, [ebp+var_C]
.text$mn:0000403D                 mov     large fs:0, eax
.text$mn:00004043                 mov     [ebp+var_10], ecx
.text$mn:00004046                 mov     [ebp+var_4], 0
.text$mn:0000404D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004054                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004057                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000405C                 mov     ecx, [ebp+var_C]
.text$mn:0000405F                 mov     large fs:0, ecx
.text$mn:00004066                 pop     ecx
.text$mn:00004067                 mov     esp, ebp
.text$mn:00004069                 pop     ebp
.text$mn:0000406A                 retn
.text$mn:0000406A ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:0000406A
.text$mn:0000406A ; ---------------------------------------------------------------------------
.text$mn:0000406B                 align 4
.text$mn:0000406B _text$mn        ends
.text$mn:0000406B
.text$x:0000406C ; ===========================================================================
.text$x:0000406C
.text$x:0000406C ; Segment type: Pure code
.text$x:0000406C ; Segment permissions: Read/Execute
.text$x:0000406C _text$x         segment para public 'CODE' use32
.text$x:0000406C                 assume cs:_text$x
.text$x:0000406C                 ;org 406Ch
.text$x:0000406C ; COMDAT (pick associative to section at 4020)
.text$x:0000406C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000406C
.text$x:0000406C ; =============== S U B R O U T I N E =======================================
.text$x:0000406C
.text$x:0000406C
.text$x:0000406C __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:0000406C                                         ; DATA XREF: .xdata$x:00008458o
.text$x:0000406C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000406F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000406F __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:0000406F
.text$x:00004074
.text$x:00004074 ; =============== S U B R O U T I N E =======================================
.text$x:00004074
.text$x:00004074
.text$x:00004074 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00004074                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00004074
.text$x:00004074 arg_4           = dword ptr  8
.text$x:00004074
.text$x:00004074                 mov     edx, [esp+arg_4]
.text$x:00004078                 lea     eax, [edx+0Ch]
.text$x:0000407B                 mov     ecx, [edx-8]
.text$x:0000407E                 xor     ecx, eax
.text$x:00004080                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004085                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:0000408A                 jmp     ___CxxFrameHandler3
.text$x:0000408A __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:0000408A
.text$x:0000408A ; ---------------------------------------------------------------------------
.text$x:0000408F                 align 10h
.text$x:0000408F _text$x         ends
.text$x:0000408F
.text$mn:00004090 ; ===========================================================================
.text$mn:00004090
.text$mn:00004090 ; Segment type: Pure code
.text$mn:00004090 ; Segment permissions: Read/Execute
.text$mn:00004090 _text$mn        segment para public 'CODE' use32
.text$mn:00004090                 assume cs:_text$mn
.text$mn:00004090                 ;org 4090h
.text$mn:00004090 ; COMDAT (pick any)
.text$mn:00004090                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004090
.text$mn:00004090 ; =============== S U B R O U T I N E =======================================
.text$mn:00004090
.text$mn:00004090 ; Attributes: bp-based frame
.text$mn:00004090
.text$mn:00004090 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00004090                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00004090 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00004090                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00004090                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00004090
.text$mn:00004090 var_10          = dword ptr -10h
.text$mn:00004090 var_C           = dword ptr -0Ch
.text$mn:00004090 var_4           = dword ptr -4
.text$mn:00004090
.text$mn:00004090                 push    ebp
.text$mn:00004091                 mov     ebp, esp
.text$mn:00004093                 push    0FFFFFFFFh
.text$mn:00004095                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000409A                 mov     eax, large fs:0
.text$mn:000040A0                 push    eax
.text$mn:000040A1                 push    ecx
.text$mn:000040A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040A7                 xor     eax, ebp
.text$mn:000040A9                 push    eax
.text$mn:000040AA                 lea     eax, [ebp+var_C]
.text$mn:000040AD                 mov     large fs:0, eax
.text$mn:000040B3                 mov     [ebp+var_10], ecx
.text$mn:000040B6                 mov     [ebp+var_4], 0
.text$mn:000040BD                 push    0               ; Size
.text$mn:000040BF                 push    1               ; char
.text$mn:000040C1                 mov     ecx, [ebp+var_10]
.text$mn:000040C4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000040C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040D0                 mov     ecx, [ebp+var_10]
.text$mn:000040D3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000040D8                 mov     ecx, [ebp+var_C]
.text$mn:000040DB                 mov     large fs:0, ecx
.text$mn:000040E2                 pop     ecx
.text$mn:000040E3                 mov     esp, ebp
.text$mn:000040E5                 pop     ebp
.text$mn:000040E6                 retn
.text$mn:000040E6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000040E6
.text$mn:000040E6 ; ---------------------------------------------------------------------------
.text$mn:000040E7                 align 4
.text$mn:000040E7 _text$mn        ends
.text$mn:000040E7
.text$x:000040E8 ; ===========================================================================
.text$x:000040E8
.text$x:000040E8 ; Segment type: Pure code
.text$x:000040E8 ; Segment permissions: Read/Execute
.text$x:000040E8 _text$x         segment para public 'CODE' use32
.text$x:000040E8                 assume cs:_text$x
.text$x:000040E8                 ;org 40E8h
.text$x:000040E8 ; COMDAT (pick associative to section at 4090)
.text$x:000040E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000040E8
.text$x:000040E8 ; =============== S U B R O U T I N E =======================================
.text$x:000040E8
.text$x:000040E8
.text$x:000040E8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000040E8                                         ; DATA XREF: .xdata$x:000081E8o
.text$x:000040E8                 mov     ecx, [ebp-10h]
.text$x:000040EB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000040EB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000040EB
.text$x:000040F0
.text$x:000040F0 ; =============== S U B R O U T I N E =======================================
.text$x:000040F0
.text$x:000040F0
.text$x:000040F0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000040F0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000040F0
.text$x:000040F0 arg_4           = dword ptr  8
.text$x:000040F0
.text$x:000040F0                 mov     edx, [esp+arg_4]
.text$x:000040F4                 lea     eax, [edx+0Ch]
.text$x:000040F7                 mov     ecx, [edx-8]
.text$x:000040FA                 xor     ecx, eax
.text$x:000040FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004101                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00004106                 jmp     ___CxxFrameHandler3
.text$x:00004106 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00004106
.text$x:00004106 ; ---------------------------------------------------------------------------
.text$x:0000410B                 align 4
.text$x:0000410B _text$x         ends
.text$x:0000410B
.text$mn:0000410C ; ===========================================================================
.text$mn:0000410C
.text$mn:0000410C ; Segment type: Pure code
.text$mn:0000410C ; Segment permissions: Read/Execute
.text$mn:0000410C _text$mn        segment para public 'CODE' use32
.text$mn:0000410C                 assume cs:_text$mn
.text$mn:0000410C                 ;org 410Ch
.text$mn:0000410C ; COMDAT (pick any)
.text$mn:0000410C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000410C
.text$mn:0000410C ; =============== S U B R O U T I N E =======================================
.text$mn:0000410C
.text$mn:0000410C ; Attributes: bp-based frame
.text$mn:0000410C
.text$mn:0000410C ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:0000410C                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:0000410C ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:0000410C                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+2E3p
.text$mn:0000410C                                         ; RunDlg::run_dlgProc(uint,uint,long)+3A1p ...
.text$mn:0000410C
.text$mn:0000410C var_10          = dword ptr -10h
.text$mn:0000410C var_C           = dword ptr -0Ch
.text$mn:0000410C var_4           = dword ptr -4
.text$mn:0000410C
.text$mn:0000410C                 push    ebp
.text$mn:0000410D                 mov     ebp, esp
.text$mn:0000410F                 push    0FFFFFFFFh
.text$mn:00004111                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00004116                 mov     eax, large fs:0
.text$mn:0000411C                 push    eax
.text$mn:0000411D                 push    ecx
.text$mn:0000411E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004123                 xor     eax, ebp
.text$mn:00004125                 push    eax
.text$mn:00004126                 lea     eax, [ebp+var_C]
.text$mn:00004129                 mov     large fs:0, eax
.text$mn:0000412F                 mov     [ebp+var_10], ecx
.text$mn:00004132                 mov     [ebp+var_4], 0
.text$mn:00004139                 push    0
.text$mn:0000413B                 push    1
.text$mn:0000413D                 mov     ecx, [ebp+var_10]
.text$mn:00004140                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00004145                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000414C                 mov     ecx, [ebp+var_10]
.text$mn:0000414F                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00004154                 mov     ecx, [ebp+var_C]
.text$mn:00004157                 mov     large fs:0, ecx
.text$mn:0000415E                 pop     ecx
.text$mn:0000415F                 mov     esp, ebp
.text$mn:00004161                 pop     ebp
.text$mn:00004162                 retn
.text$mn:00004162 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00004162
.text$mn:00004162 ; ---------------------------------------------------------------------------
.text$mn:00004163                 align 4
.text$mn:00004163 _text$mn        ends
.text$mn:00004163
.text$x:00004164 ; ===========================================================================
.text$x:00004164
.text$x:00004164 ; Segment type: Pure code
.text$x:00004164 ; Segment permissions: Read/Execute
.text$x:00004164 _text$x         segment para public 'CODE' use32
.text$x:00004164                 assume cs:_text$x
.text$x:00004164                 ;org 4164h
.text$x:00004164 ; COMDAT (pick associative to section at 410C)
.text$x:00004164                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004164
.text$x:00004164 ; =============== S U B R O U T I N E =======================================
.text$x:00004164
.text$x:00004164
.text$x:00004164 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00004164                                         ; DATA XREF: .xdata$x:000085C0o
.text$x:00004164                 mov     ecx, [ebp-10h]
.text$x:00004167                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00004167 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00004167
.text$x:0000416C
.text$x:0000416C ; =============== S U B R O U T I N E =======================================
.text$x:0000416C
.text$x:0000416C
.text$x:0000416C __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:0000416C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:0000416C
.text$x:0000416C arg_4           = dword ptr  8
.text$x:0000416C
.text$x:0000416C                 mov     edx, [esp+arg_4]
.text$x:00004170                 lea     eax, [edx+0Ch]
.text$x:00004173                 mov     ecx, [edx-8]
.text$x:00004176                 xor     ecx, eax
.text$x:00004178                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000417D                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00004182                 jmp     ___CxxFrameHandler3
.text$x:00004182 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00004182
.text$x:00004182 ; ---------------------------------------------------------------------------
.text$x:00004187                 align 4
.text$x:00004187 _text$x         ends
.text$x:00004187
.text$mn:00004188 ; ===========================================================================
.text$mn:00004188
.text$mn:00004188 ; Segment type: Pure code
.text$mn:00004188 ; Segment permissions: Read/Execute
.text$mn:00004188 _text$mn        segment para public 'CODE' use32
.text$mn:00004188                 assume cs:_text$mn
.text$mn:00004188                 ;org 4188h
.text$mn:00004188 ; COMDAT (pick any)
.text$mn:00004188                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004188
.text$mn:00004188 ; =============== S U B R O U T I N E =======================================
.text$mn:00004188
.text$mn:00004188 ; Attributes: bp-based frame
.text$mn:00004188
.text$mn:00004188 ; _DWORD __thiscall CommandShortcut::~CommandShortcut(CommandShortcut *__hidden this)
.text$mn:00004188                 public ??1CommandShortcut@@UAE@XZ
.text$mn:00004188 ??1CommandShortcut@@UAE@XZ proc near    ; CODE XREF: __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$0+3j
.text$mn:00004188                                         ; __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$2+3j ...
.text$mn:00004188
.text$mn:00004188 var_10          = dword ptr -10h
.text$mn:00004188 var_C           = dword ptr -0Ch
.text$mn:00004188 var_4           = dword ptr -4
.text$mn:00004188
.text$mn:00004188                 push    ebp
.text$mn:00004189                 mov     ebp, esp
.text$mn:0000418B                 push    0FFFFFFFFh
.text$mn:0000418D                 push    offset __ehhandler$??1CommandShortcut@@UAE@XZ
.text$mn:00004192                 mov     eax, large fs:0
.text$mn:00004198                 push    eax
.text$mn:00004199                 push    ecx
.text$mn:0000419A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000419F                 xor     eax, ebp
.text$mn:000041A1                 push    eax
.text$mn:000041A2                 lea     eax, [ebp+var_C]
.text$mn:000041A5                 mov     large fs:0, eax
.text$mn:000041AB                 mov     [ebp+var_10], ecx
.text$mn:000041AE                 mov     [ebp+var_4], 0
.text$mn:000041B5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000041BC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000041BF                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:000041C4                 mov     ecx, [ebp+var_C]
.text$mn:000041C7                 mov     large fs:0, ecx
.text$mn:000041CE                 pop     ecx
.text$mn:000041CF                 mov     esp, ebp
.text$mn:000041D1                 pop     ebp
.text$mn:000041D2                 retn
.text$mn:000041D2 ??1CommandShortcut@@UAE@XZ endp
.text$mn:000041D2
.text$mn:000041D2 ; ---------------------------------------------------------------------------
.text$mn:000041D3                 align 4
.text$mn:000041D3 _text$mn        ends
.text$mn:000041D3
.text$x:000041D4 ; ===========================================================================
.text$x:000041D4
.text$x:000041D4 ; Segment type: Pure code
.text$x:000041D4 ; Segment permissions: Read/Execute
.text$x:000041D4 _text$x         segment para public 'CODE' use32
.text$x:000041D4                 assume cs:_text$x
.text$x:000041D4                 ;org 41D4h
.text$x:000041D4 ; COMDAT (pick associative to section at 4188)
.text$x:000041D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000041D4
.text$x:000041D4 ; =============== S U B R O U T I N E =======================================
.text$x:000041D4
.text$x:000041D4
.text$x:000041D4 __unwindfunclet$??1CommandShortcut@@UAE@XZ$0 proc near
.text$x:000041D4                                         ; DATA XREF: .xdata$x:000088F0o
.text$x:000041D4                 mov     ecx, [ebp-10h]  ; this
.text$x:000041D7                 jmp     ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$x:000041D7 __unwindfunclet$??1CommandShortcut@@UAE@XZ$0 endp
.text$x:000041D7
.text$x:000041DC
.text$x:000041DC ; =============== S U B R O U T I N E =======================================
.text$x:000041DC
.text$x:000041DC
.text$x:000041DC __ehhandler$??1CommandShortcut@@UAE@XZ proc near
.text$x:000041DC                                         ; DATA XREF: CommandShortcut::~CommandShortcut(void)+5o
.text$x:000041DC
.text$x:000041DC arg_4           = dword ptr  8
.text$x:000041DC
.text$x:000041DC                 mov     edx, [esp+arg_4]
.text$x:000041E0                 lea     eax, [edx+0Ch]
.text$x:000041E3                 mov     ecx, [edx-8]
.text$x:000041E6                 xor     ecx, eax
.text$x:000041E8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000041ED                 mov     eax, offset __ehfuncinfo$??1CommandShortcut@@UAE@XZ
.text$x:000041F2                 jmp     ___CxxFrameHandler3
.text$x:000041F2 __ehhandler$??1CommandShortcut@@UAE@XZ endp
.text$x:000041F2
.text$x:000041F2 ; ---------------------------------------------------------------------------
.text$x:000041F7                 align 4
.text$x:000041F7 _text$x         ends
.text$x:000041F7
.text$mn:000041F8 ; ===========================================================================
.text$mn:000041F8
.text$mn:000041F8 ; Segment type: Pure code
.text$mn:000041F8 ; Segment permissions: Read/Execute
.text$mn:000041F8 _text$mn        segment para public 'CODE' use32
.text$mn:000041F8                 assume cs:_text$mn
.text$mn:000041F8                 ;org 41F8h
.text$mn:000041F8 ; COMDAT (pick any)
.text$mn:000041F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041F8
.text$mn:000041F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000041F8
.text$mn:000041F8 ; Attributes: bp-based frame
.text$mn:000041F8
.text$mn:000041F8 ; _DWORD __thiscall Shortcut::~Shortcut(Shortcut *__hidden this)
.text$mn:000041F8                 public ??1Shortcut@@UAE@XZ
.text$mn:000041F8 ??1Shortcut@@UAE@XZ proc near           ; CODE XREF: __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$0+6j
.text$mn:000041F8                                         ; __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0+3j ...
.text$mn:000041F8
.text$mn:000041F8 var_10          = dword ptr -10h
.text$mn:000041F8 var_C           = dword ptr -0Ch
.text$mn:000041F8 var_4           = dword ptr -4
.text$mn:000041F8
.text$mn:000041F8                 push    ebp
.text$mn:000041F9                 mov     ebp, esp
.text$mn:000041FB                 push    0FFFFFFFFh
.text$mn:000041FD                 push    offset __ehhandler$??1Shortcut@@UAE@XZ
.text$mn:00004202                 mov     eax, large fs:0
.text$mn:00004208                 push    eax
.text$mn:00004209                 push    ecx
.text$mn:0000420A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000420F                 xor     eax, ebp
.text$mn:00004211                 push    eax
.text$mn:00004212                 lea     eax, [ebp+var_C]
.text$mn:00004215                 mov     large fs:0, eax
.text$mn:0000421B                 mov     [ebp+var_10], ecx
.text$mn:0000421E                 mov     [ebp+var_4], 0
.text$mn:00004225                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000422C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000422F                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:00004234                 mov     ecx, [ebp+var_C]
.text$mn:00004237                 mov     large fs:0, ecx
.text$mn:0000423E                 pop     ecx
.text$mn:0000423F                 mov     esp, ebp
.text$mn:00004241                 pop     ebp
.text$mn:00004242                 retn
.text$mn:00004242 ??1Shortcut@@UAE@XZ endp
.text$mn:00004242
.text$mn:00004242 ; ---------------------------------------------------------------------------
.text$mn:00004243                 align 4
.text$mn:00004243 _text$mn        ends
.text$mn:00004243
.text$x:00004244 ; ===========================================================================
.text$x:00004244
.text$x:00004244 ; Segment type: Pure code
.text$x:00004244 ; Segment permissions: Read/Execute
.text$x:00004244 _text$x         segment para public 'CODE' use32
.text$x:00004244                 assume cs:_text$x
.text$x:00004244                 ;org 4244h
.text$x:00004244 ; COMDAT (pick associative to section at 41F8)
.text$x:00004244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004244
.text$x:00004244 ; =============== S U B R O U T I N E =======================================
.text$x:00004244
.text$x:00004244
.text$x:00004244 __unwindfunclet$??1Shortcut@@UAE@XZ$0 proc near
.text$x:00004244                                         ; DATA XREF: .xdata$x:00008890o
.text$x:00004244                 mov     ecx, [ebp-10h]  ; this
.text$x:00004247                 jmp     ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$x:00004247 __unwindfunclet$??1Shortcut@@UAE@XZ$0 endp
.text$x:00004247
.text$x:0000424C
.text$x:0000424C ; =============== S U B R O U T I N E =======================================
.text$x:0000424C
.text$x:0000424C
.text$x:0000424C __ehhandler$??1Shortcut@@UAE@XZ proc near
.text$x:0000424C                                         ; DATA XREF: Shortcut::~Shortcut(void)+5o
.text$x:0000424C
.text$x:0000424C arg_4           = dword ptr  8
.text$x:0000424C
.text$x:0000424C                 mov     edx, [esp+arg_4]
.text$x:00004250                 lea     eax, [edx+0Ch]
.text$x:00004253                 mov     ecx, [edx-8]
.text$x:00004256                 xor     ecx, eax
.text$x:00004258                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000425D                 mov     eax, offset __ehfuncinfo$??1Shortcut@@UAE@XZ
.text$x:00004262                 jmp     ___CxxFrameHandler3
.text$x:00004262 __ehhandler$??1Shortcut@@UAE@XZ endp
.text$x:00004262
.text$x:00004262 ; ---------------------------------------------------------------------------
.text$x:00004267                 align 4
.text$x:00004267 _text$x         ends
.text$x:00004267
.text$mn:00004268 ; ===========================================================================
.text$mn:00004268
.text$mn:00004268 ; Segment type: Pure code
.text$mn:00004268 ; Segment permissions: Read/Execute
.text$mn:00004268 _text$mn        segment para public 'CODE' use32
.text$mn:00004268                 assume cs:_text$mn
.text$mn:00004268                 ;org 4268h
.text$mn:00004268 ; COMDAT (pick any)
.text$mn:00004268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004268
.text$mn:00004268 ; =============== S U B R O U T I N E =======================================
.text$mn:00004268
.text$mn:00004268 ; Attributes: bp-based frame
.text$mn:00004268
.text$mn:00004268 ; _DWORD __thiscall StaticDialog::~StaticDialog(StaticDialog *__hidden this)
.text$mn:00004268                 public ??1StaticDialog@@UAE@XZ
.text$mn:00004268 ??1StaticDialog@@UAE@XZ proc near       ; CODE XREF: __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0+3j
.text$mn:00004268                                         ; __unwindfunclet$??0Shortcut@@QAE@XZ$0+3j ...
.text$mn:00004268
.text$mn:00004268 var_10          = dword ptr -10h
.text$mn:00004268 var_C           = dword ptr -0Ch
.text$mn:00004268 var_4           = dword ptr -4
.text$mn:00004268
.text$mn:00004268                 push    ebp
.text$mn:00004269                 mov     ebp, esp
.text$mn:0000426B                 push    0FFFFFFFFh
.text$mn:0000426D                 push    offset __ehhandler$??1StaticDialog@@UAE@XZ
.text$mn:00004272                 mov     eax, large fs:0
.text$mn:00004278                 push    eax
.text$mn:00004279                 push    ecx
.text$mn:0000427A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000427F                 xor     eax, ebp
.text$mn:00004281                 push    eax
.text$mn:00004282                 lea     eax, [ebp+var_C]
.text$mn:00004285                 mov     large fs:0, eax
.text$mn:0000428B                 mov     [ebp+var_10], ecx
.text$mn:0000428E                 mov     eax, [ebp+var_10]
.text$mn:00004291                 mov     dword ptr [eax], offset ??_7StaticDialog@@6B@ ; const StaticDialog::`vftable'
.text$mn:00004297                 mov     [ebp+var_4], 0
.text$mn:0000429E                 mov     ecx, [ebp+var_10] ; this
.text$mn:000042A1                 call    ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.text$mn:000042A6                 movzx   ecx, al
.text$mn:000042A9                 test    ecx, ecx
.text$mn:000042AB                 jz      short loc_42C6
.text$mn:000042AD                 push    0               ; dwNewLong
.text$mn:000042AF                 push    0FFFFFFEBh      ; nIndex
.text$mn:000042B1                 mov     edx, [ebp+var_10]
.text$mn:000042B4                 mov     eax, [edx+0Ch]
.text$mn:000042B7                 push    eax             ; hWnd
.text$mn:000042B8                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000042BE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000042C1                 call    ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.text$mn:000042C6
.text$mn:000042C6 loc_42C6:                               ; CODE XREF: StaticDialog::~StaticDialog(void)+43j
.text$mn:000042C6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000042CD                 mov     ecx, [ebp+var_10] ; this
.text$mn:000042D0                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:000042D5                 mov     ecx, [ebp+var_C]
.text$mn:000042D8                 mov     large fs:0, ecx
.text$mn:000042DF                 pop     ecx
.text$mn:000042E0                 mov     esp, ebp
.text$mn:000042E2                 pop     ebp
.text$mn:000042E3                 retn
.text$mn:000042E3 ??1StaticDialog@@UAE@XZ endp
.text$mn:000042E3
.text$mn:000042E3 _text$mn        ends
.text$mn:000042E3
.text$x:000042E4 ; ===========================================================================
.text$x:000042E4
.text$x:000042E4 ; Segment type: Pure code
.text$x:000042E4 ; Segment permissions: Read/Execute
.text$x:000042E4 _text$x         segment para public 'CODE' use32
.text$x:000042E4                 assume cs:_text$x
.text$x:000042E4                 ;org 42E4h
.text$x:000042E4 ; COMDAT (pick associative to section at 4268)
.text$x:000042E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000042E4
.text$x:000042E4 ; =============== S U B R O U T I N E =======================================
.text$x:000042E4
.text$x:000042E4
.text$x:000042E4 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 proc near
.text$x:000042E4                                         ; DATA XREF: .xdata$x:00008028o
.text$x:000042E4                 mov     ecx, [ebp-10h]  ; this
.text$x:000042E7                 jmp     ??1Window@@UAE@XZ ; Window::~Window(void)
.text$x:000042E7 __unwindfunclet$??1StaticDialog@@UAE@XZ$0 endp
.text$x:000042E7
.text$x:000042EC
.text$x:000042EC ; =============== S U B R O U T I N E =======================================
.text$x:000042EC
.text$x:000042EC
.text$x:000042EC __ehhandler$??1StaticDialog@@UAE@XZ proc near
.text$x:000042EC                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+5o
.text$x:000042EC
.text$x:000042EC arg_4           = dword ptr  8
.text$x:000042EC
.text$x:000042EC                 mov     edx, [esp+arg_4]
.text$x:000042F0                 lea     eax, [edx+0Ch]
.text$x:000042F3                 mov     ecx, [edx-8]
.text$x:000042F6                 xor     ecx, eax
.text$x:000042F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000042FD                 mov     eax, offset __ehfuncinfo$??1StaticDialog@@UAE@XZ
.text$x:00004302                 jmp     ___CxxFrameHandler3
.text$x:00004302 __ehhandler$??1StaticDialog@@UAE@XZ endp
.text$x:00004302
.text$x:00004302 ; ---------------------------------------------------------------------------
.text$x:00004307                 align 4
.text$x:00004307 _text$x         ends
.text$x:00004307
.text$mn:00004308 ; ===========================================================================
.text$mn:00004308
.text$mn:00004308 ; Segment type: Pure code
.text$mn:00004308 ; Segment permissions: Read/Execute
.text$mn:00004308 _text$mn        segment para public 'CODE' use32
.text$mn:00004308                 assume cs:_text$mn
.text$mn:00004308                 ;org 4308h
.text$mn:00004308 ; COMDAT (pick any)
.text$mn:00004308                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004308
.text$mn:00004308 ; =============== S U B R O U T I N E =======================================
.text$mn:00004308
.text$mn:00004308 ; Attributes: bp-based frame
.text$mn:00004308
.text$mn:00004308 ; _DWORD __thiscall UserCommand::~UserCommand(UserCommand *__hidden this)
.text$mn:00004308                 public ??1UserCommand@@UAE@XZ
.text$mn:00004308 ??1UserCommand@@UAE@XZ proc near        ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+3D0p
.text$mn:00004308                                         ; __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$1+6j ...
.text$mn:00004308
.text$mn:00004308 var_10          = dword ptr -10h
.text$mn:00004308 var_C           = dword ptr -0Ch
.text$mn:00004308 var_4           = dword ptr -4
.text$mn:00004308
.text$mn:00004308                 push    ebp
.text$mn:00004309                 mov     ebp, esp
.text$mn:0000430B                 push    0FFFFFFFFh
.text$mn:0000430D                 push    offset __ehhandler$??1UserCommand@@UAE@XZ
.text$mn:00004312                 mov     eax, large fs:0
.text$mn:00004318                 push    eax
.text$mn:00004319                 push    ecx
.text$mn:0000431A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000431F                 xor     eax, ebp
.text$mn:00004321                 push    eax
.text$mn:00004322                 lea     eax, [ebp+var_C]
.text$mn:00004325                 mov     large fs:0, eax
.text$mn:0000432B                 mov     [ebp+var_10], ecx
.text$mn:0000432E                 mov     [ebp+var_4], 1
.text$mn:00004335                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004339                 mov     ecx, [ebp+var_10]
.text$mn:0000433C                 add     ecx, 12Ch
.text$mn:00004342                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00004347                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000434E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004351                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:00004356                 mov     ecx, [ebp+var_C]
.text$mn:00004359                 mov     large fs:0, ecx
.text$mn:00004360                 pop     ecx
.text$mn:00004361                 mov     esp, ebp
.text$mn:00004363                 pop     ebp
.text$mn:00004364                 retn
.text$mn:00004364 ??1UserCommand@@UAE@XZ endp
.text$mn:00004364
.text$mn:00004364 ; ---------------------------------------------------------------------------
.text$mn:00004365                 align 4
.text$mn:00004365 _text$mn        ends
.text$mn:00004365
.text$x:00004368 ; ===========================================================================
.text$x:00004368
.text$x:00004368 ; Segment type: Pure code
.text$x:00004368 ; Segment permissions: Read/Execute
.text$x:00004368 _text$x         segment para public 'CODE' use32
.text$x:00004368                 assume cs:_text$x
.text$x:00004368                 ;org 4368h
.text$x:00004368 ; COMDAT (pick associative to section at 4308)
.text$x:00004368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004368
.text$x:00004368 ; =============== S U B R O U T I N E =======================================
.text$x:00004368
.text$x:00004368
.text$x:00004368 __unwindfunclet$??1UserCommand@@UAE@XZ$0 proc near
.text$x:00004368                                         ; DATA XREF: .xdata$x:0000898Co
.text$x:00004368                 mov     ecx, [ebp-10h]  ; this
.text$x:0000436B                 jmp     ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$x:0000436B __unwindfunclet$??1UserCommand@@UAE@XZ$0 endp
.text$x:0000436B
.text$x:00004370
.text$x:00004370 ; =============== S U B R O U T I N E =======================================
.text$x:00004370
.text$x:00004370
.text$x:00004370 __unwindfunclet$??1UserCommand@@UAE@XZ$1 proc near
.text$x:00004370                                         ; DATA XREF: .xdata$x:00008994o
.text$x:00004370                 mov     ecx, [ebp-10h]
.text$x:00004373                 add     ecx, 12Ch
.text$x:00004379                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00004379 __unwindfunclet$??1UserCommand@@UAE@XZ$1 endp
.text$x:00004379
.text$x:0000437E
.text$x:0000437E ; =============== S U B R O U T I N E =======================================
.text$x:0000437E
.text$x:0000437E
.text$x:0000437E __ehhandler$??1UserCommand@@UAE@XZ proc near
.text$x:0000437E                                         ; DATA XREF: UserCommand::~UserCommand(void)+5o
.text$x:0000437E
.text$x:0000437E arg_4           = dword ptr  8
.text$x:0000437E
.text$x:0000437E                 mov     edx, [esp+arg_4]
.text$x:00004382                 lea     eax, [edx+0Ch]
.text$x:00004385                 mov     ecx, [edx-8]
.text$x:00004388                 xor     ecx, eax
.text$x:0000438A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000438F                 mov     eax, offset __ehfuncinfo$??1UserCommand@@UAE@XZ
.text$x:00004394                 jmp     ___CxxFrameHandler3
.text$x:00004394 __ehhandler$??1UserCommand@@UAE@XZ endp
.text$x:00004394
.text$x:00004394 ; ---------------------------------------------------------------------------
.text$x:00004399                 align 4
.text$x:00004399 _text$x         ends
.text$x:00004399
.text$mn:0000439C ; ===========================================================================
.text$mn:0000439C
.text$mn:0000439C ; Segment type: Pure code
.text$mn:0000439C ; Segment permissions: Read/Execute
.text$mn:0000439C _text$mn        segment para public 'CODE' use32
.text$mn:0000439C                 assume cs:_text$mn
.text$mn:0000439C                 ;org 439Ch
.text$mn:0000439C ; COMDAT (pick any)
.text$mn:0000439C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000439C
.text$mn:0000439C ; =============== S U B R O U T I N E =======================================
.text$mn:0000439C
.text$mn:0000439C ; Attributes: bp-based frame
.text$mn:0000439C
.text$mn:0000439C ; _DWORD __thiscall Window::~Window(Window *__hidden this)
.text$mn:0000439C                 public ??1Window@@UAE@XZ
.text$mn:0000439C ??1Window@@UAE@XZ proc near             ; CODE XREF: __unwindfunclet$??0StaticDialog@@QAE@XZ$0+3j
.text$mn:0000439C                                         ; StaticDialog::~StaticDialog(void)+68p ...
.text$mn:0000439C
.text$mn:0000439C var_4           = dword ptr -4
.text$mn:0000439C
.text$mn:0000439C                 push    ebp
.text$mn:0000439D                 mov     ebp, esp
.text$mn:0000439F                 push    ecx
.text$mn:000043A0                 mov     [ebp+var_4], ecx
.text$mn:000043A3                 mov     eax, [ebp+var_4]
.text$mn:000043A6                 mov     dword ptr [eax], offset ??_7Window@@6B@ ; const Window::`vftable'
.text$mn:000043AC                 mov     esp, ebp
.text$mn:000043AE                 pop     ebp
.text$mn:000043AF                 retn
.text$mn:000043AF ??1Window@@UAE@XZ endp
.text$mn:000043AF
.text$mn:000043AF _text$mn        ends
.text$mn:000043AF
.text$mn:000043B0 ; ===========================================================================
.text$mn:000043B0
.text$mn:000043B0 ; Segment type: Pure code
.text$mn:000043B0 ; Segment permissions: Read/Execute
.text$mn:000043B0 _text$mn        segment para public 'CODE' use32
.text$mn:000043B0                 assume cs:_text$mn
.text$mn:000043B0                 ;org 43B0h
.text$mn:000043B0 ; COMDAT (pick any)
.text$mn:000043B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043B0
.text$mn:000043B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000043B0
.text$mn:000043B0 ; Attributes: bp-based frame
.text$mn:000043B0
.text$mn:000043B0 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000043B0                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000043B0 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000043B0                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000043B0                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:000043B0
.text$mn:000043B0 var_4           = dword ptr -4
.text$mn:000043B0
.text$mn:000043B0                 push    ebp
.text$mn:000043B1                 mov     ebp, esp
.text$mn:000043B3                 push    ecx
.text$mn:000043B4                 mov     [ebp+var_4], ecx
.text$mn:000043B7                 mov     ecx, [ebp+var_4] ; this
.text$mn:000043BA                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000043BF                 mov     esp, ebp
.text$mn:000043C1                 pop     ebp
.text$mn:000043C2                 retn
.text$mn:000043C2 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:000043C2
.text$mn:000043C2 ; ---------------------------------------------------------------------------
.text$mn:000043C3                 align 4
.text$mn:000043C3 _text$mn        ends
.text$mn:000043C3
.text$mn:000043C4 ; ===========================================================================
.text$mn:000043C4
.text$mn:000043C4 ; Segment type: Pure code
.text$mn:000043C4 ; Segment permissions: Read/Execute
.text$mn:000043C4 _text$mn        segment para public 'CODE' use32
.text$mn:000043C4                 assume cs:_text$mn
.text$mn:000043C4                 ;org 43C4h
.text$mn:000043C4 ; COMDAT (pick any)
.text$mn:000043C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043C4
.text$mn:000043C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000043C4
.text$mn:000043C4 ; Attributes: bp-based frame
.text$mn:000043C4
.text$mn:000043C4 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000043C4                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:000043C4 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:000043C4                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:000043C4                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:000043C4
.text$mn:000043C4 var_10          = dword ptr -10h
.text$mn:000043C4 var_C           = dword ptr -0Ch
.text$mn:000043C4 var_4           = dword ptr -4
.text$mn:000043C4
.text$mn:000043C4                 push    ebp
.text$mn:000043C5                 mov     ebp, esp
.text$mn:000043C7                 push    0FFFFFFFFh
.text$mn:000043C9                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000043CE                 mov     eax, large fs:0
.text$mn:000043D4                 push    eax
.text$mn:000043D5                 push    ecx
.text$mn:000043D6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000043DB                 xor     eax, ebp
.text$mn:000043DD                 push    eax
.text$mn:000043DE                 lea     eax, [ebp+var_C]
.text$mn:000043E1                 mov     large fs:0, eax
.text$mn:000043E7                 mov     [ebp+var_10], ecx
.text$mn:000043EA                 mov     [ebp+var_4], 0
.text$mn:000043F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000043F8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000043FB                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00004400                 mov     ecx, [ebp+var_C]
.text$mn:00004403                 mov     large fs:0, ecx
.text$mn:0000440A                 pop     ecx
.text$mn:0000440B                 mov     esp, ebp
.text$mn:0000440D                 pop     ebp
.text$mn:0000440E                 retn
.text$mn:0000440E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:0000440E
.text$mn:0000440E ; ---------------------------------------------------------------------------
.text$mn:0000440F                 align 10h
.text$mn:0000440F _text$mn        ends
.text$mn:0000440F
.text$x:00004410 ; ===========================================================================
.text$x:00004410
.text$x:00004410 ; Segment type: Pure code
.text$x:00004410 ; Segment permissions: Read/Execute
.text$x:00004410 _text$x         segment para public 'CODE' use32
.text$x:00004410                 assume cs:_text$x
.text$x:00004410                 ;org 4410h
.text$x:00004410 ; COMDAT (pick associative to section at 43C4)
.text$x:00004410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004410
.text$x:00004410 ; =============== S U B R O U T I N E =======================================
.text$x:00004410
.text$x:00004410
.text$x:00004410 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00004410                                         ; DATA XREF: .xdata$x:000082F8o
.text$x:00004410                 mov     ecx, [ebp-10h]  ; this
.text$x:00004413                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00004413 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00004413
.text$x:00004418
.text$x:00004418 ; =============== S U B R O U T I N E =======================================
.text$x:00004418
.text$x:00004418
.text$x:00004418 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00004418                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00004418
.text$x:00004418 arg_4           = dword ptr  8
.text$x:00004418
.text$x:00004418                 mov     edx, [esp+arg_4]
.text$x:0000441C                 lea     eax, [edx+0Ch]
.text$x:0000441F                 mov     ecx, [edx-8]
.text$x:00004422                 xor     ecx, eax
.text$x:00004424                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004429                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000442E                 jmp     ___CxxFrameHandler3
.text$x:0000442E __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000442E
.text$x:0000442E ; ---------------------------------------------------------------------------
.text$x:00004433                 align 4
.text$x:00004433 _text$x         ends
.text$x:00004433
.text$mn:00004434 ; ===========================================================================
.text$mn:00004434
.text$mn:00004434 ; Segment type: Pure code
.text$mn:00004434 ; Segment permissions: Read/Execute
.text$mn:00004434 _text$mn        segment para public 'CODE' use32
.text$mn:00004434                 assume cs:_text$mn
.text$mn:00004434                 ;org 4434h
.text$mn:00004434 ; COMDAT (pick any)
.text$mn:00004434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004434
.text$mn:00004434 ; =============== S U B R O U T I N E =======================================
.text$mn:00004434
.text$mn:00004434 ; Attributes: bp-based frame
.text$mn:00004434
.text$mn:00004434 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00004434                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00004434 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00004434                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00004434                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00004434
.text$mn:00004434 var_10          = dword ptr -10h
.text$mn:00004434 var_C           = dword ptr -0Ch
.text$mn:00004434 var_4           = dword ptr -4
.text$mn:00004434
.text$mn:00004434                 push    ebp
.text$mn:00004435                 mov     ebp, esp
.text$mn:00004437                 push    0FFFFFFFFh
.text$mn:00004439                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000443E                 mov     eax, large fs:0
.text$mn:00004444                 push    eax
.text$mn:00004445                 push    ecx
.text$mn:00004446                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000444B                 xor     eax, ebp
.text$mn:0000444D                 push    eax
.text$mn:0000444E                 lea     eax, [ebp+var_C]
.text$mn:00004451                 mov     large fs:0, eax
.text$mn:00004457                 mov     [ebp+var_10], ecx
.text$mn:0000445A                 mov     [ebp+var_4], 0
.text$mn:00004461                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004468                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000446B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00004470                 mov     ecx, [ebp+var_C]
.text$mn:00004473                 mov     large fs:0, ecx
.text$mn:0000447A                 pop     ecx
.text$mn:0000447B                 mov     esp, ebp
.text$mn:0000447D                 pop     ebp
.text$mn:0000447E                 retn
.text$mn:0000447E ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000447E
.text$mn:0000447E ; ---------------------------------------------------------------------------
.text$mn:0000447F                 align 10h
.text$mn:0000447F _text$mn        ends
.text$mn:0000447F
.text$x:00004480 ; ===========================================================================
.text$x:00004480
.text$x:00004480 ; Segment type: Pure code
.text$x:00004480 ; Segment permissions: Read/Execute
.text$x:00004480 _text$x         segment para public 'CODE' use32
.text$x:00004480                 assume cs:_text$x
.text$x:00004480                 ;org 4480h
.text$x:00004480 ; COMDAT (pick associative to section at 4434)
.text$x:00004480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004480
.text$x:00004480 ; =============== S U B R O U T I N E =======================================
.text$x:00004480
.text$x:00004480
.text$x:00004480 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00004480                                         ; DATA XREF: .xdata$x:0000837Co
.text$x:00004480                 mov     ecx, [ebp-10h]  ; this
.text$x:00004483                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004483 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00004483
.text$x:00004488
.text$x:00004488 ; =============== S U B R O U T I N E =======================================
.text$x:00004488
.text$x:00004488
.text$x:00004488 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00004488                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00004488
.text$x:00004488 arg_4           = dword ptr  8
.text$x:00004488
.text$x:00004488                 mov     edx, [esp+arg_4]
.text$x:0000448C                 lea     eax, [edx+0Ch]
.text$x:0000448F                 mov     ecx, [edx-8]
.text$x:00004492                 xor     ecx, eax
.text$x:00004494                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004499                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000449E                 jmp     ___CxxFrameHandler3
.text$x:0000449E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000449E
.text$x:0000449E ; ---------------------------------------------------------------------------
.text$x:000044A3                 align 4
.text$x:000044A3 _text$x         ends
.text$x:000044A3
.text$mn:000044A4 ; ===========================================================================
.text$mn:000044A4
.text$mn:000044A4 ; Segment type: Pure code
.text$mn:000044A4 ; Segment permissions: Read/Execute
.text$mn:000044A4 _text$mn        segment para public 'CODE' use32
.text$mn:000044A4                 assume cs:_text$mn
.text$mn:000044A4                 ;org 44A4h
.text$mn:000044A4 ; COMDAT (pick any)
.text$mn:000044A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044A4
.text$mn:000044A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000044A4
.text$mn:000044A4 ; Attributes: bp-based frame
.text$mn:000044A4
.text$mn:000044A4 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:000044A4                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:000044A4 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:000044A4                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:000044A4                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:000044A4
.text$mn:000044A4 var_14          = byte ptr -14h
.text$mn:000044A4 var_10          = dword ptr -10h
.text$mn:000044A4 var_C           = dword ptr -0Ch
.text$mn:000044A4 var_4           = dword ptr -4
.text$mn:000044A4
.text$mn:000044A4                 push    ebp
.text$mn:000044A5                 mov     ebp, esp
.text$mn:000044A7                 push    0FFFFFFFFh
.text$mn:000044A9                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:000044AE                 mov     eax, large fs:0
.text$mn:000044B4                 push    eax
.text$mn:000044B5                 sub     esp, 8
.text$mn:000044B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000044BD                 xor     eax, ebp
.text$mn:000044BF                 push    eax
.text$mn:000044C0                 lea     eax, [ebp+var_C]
.text$mn:000044C3                 mov     large fs:0, eax
.text$mn:000044C9                 mov     [ebp+var_10], ecx
.text$mn:000044CC                 push    3               ; int
.text$mn:000044CE                 lea     ecx, [ebp+var_14] ; this
.text$mn:000044D1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000044D6                 mov     [ebp+var_4], 0
.text$mn:000044DD                 mov     ecx, [ebp+var_10] ; this
.text$mn:000044E0                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000044E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044EC                 lea     ecx, [ebp+var_14] ; this
.text$mn:000044EF                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000044F4                 mov     ecx, [ebp+var_C]
.text$mn:000044F7                 mov     large fs:0, ecx
.text$mn:000044FE                 pop     ecx
.text$mn:000044FF                 mov     esp, ebp
.text$mn:00004501                 pop     ebp
.text$mn:00004502                 retn
.text$mn:00004502 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:00004502
.text$mn:00004502 ; ---------------------------------------------------------------------------
.text$mn:00004503                 align 4
.text$mn:00004503 _text$mn        ends
.text$mn:00004503
.text$x:00004504 ; ===========================================================================
.text$x:00004504
.text$x:00004504 ; Segment type: Pure code
.text$x:00004504 ; Segment permissions: Read/Execute
.text$x:00004504 _text$x         segment para public 'CODE' use32
.text$x:00004504                 assume cs:_text$x
.text$x:00004504                 ;org 4504h
.text$x:00004504 ; COMDAT (pick associative to section at 44A4)
.text$x:00004504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004504
.text$x:00004504 ; =============== S U B R O U T I N E =======================================
.text$x:00004504
.text$x:00004504
.text$x:00004504 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:00004504                                         ; DATA XREF: .xdata$x:000080ACo
.text$x:00004504                 lea     ecx, [ebp-14h]  ; this
.text$x:00004507                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004507 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:00004507
.text$x:0000450C
.text$x:0000450C ; =============== S U B R O U T I N E =======================================
.text$x:0000450C
.text$x:0000450C
.text$x:0000450C __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:0000450C                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:0000450C
.text$x:0000450C arg_4           = dword ptr  8
.text$x:0000450C
.text$x:0000450C                 mov     edx, [esp+arg_4]
.text$x:00004510                 lea     eax, [edx+0Ch]
.text$x:00004513                 mov     ecx, [edx-0Ch]
.text$x:00004516                 xor     ecx, eax
.text$x:00004518                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000451D                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00004522                 jmp     ___CxxFrameHandler3
.text$x:00004522 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00004522
.text$x:00004522 ; ---------------------------------------------------------------------------
.text$x:00004527                 align 4
.text$x:00004527 _text$x         ends
.text$x:00004527
.text$mn:00004528 ; ===========================================================================
.text$mn:00004528
.text$mn:00004528 ; Segment type: Pure code
.text$mn:00004528 ; Segment permissions: Read/Execute
.text$mn:00004528 _text$mn        segment para public 'CODE' use32
.text$mn:00004528                 assume cs:_text$mn
.text$mn:00004528                 ;org 4528h
.text$mn:00004528 ; COMDAT (pick any)
.text$mn:00004528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004528
.text$mn:00004528 ; =============== S U B R O U T I N E =======================================
.text$mn:00004528
.text$mn:00004528 ; Attributes: bp-based frame
.text$mn:00004528
.text$mn:00004528 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00004528                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00004528 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00004528                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00004528                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00004528
.text$mn:00004528 var_10          = dword ptr -10h
.text$mn:00004528 var_C           = dword ptr -0Ch
.text$mn:00004528 var_4           = dword ptr -4
.text$mn:00004528
.text$mn:00004528                 push    ebp
.text$mn:00004529                 mov     ebp, esp
.text$mn:0000452B                 push    0FFFFFFFFh
.text$mn:0000452D                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00004532                 mov     eax, large fs:0
.text$mn:00004538                 push    eax
.text$mn:00004539                 push    ecx
.text$mn:0000453A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000453F                 xor     eax, ebp
.text$mn:00004541                 push    eax
.text$mn:00004542                 lea     eax, [ebp+var_C]
.text$mn:00004545                 mov     large fs:0, eax
.text$mn:0000454B                 mov     [ebp+var_10], ecx
.text$mn:0000454E                 mov     [ebp+var_4], 0
.text$mn:00004555                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000455C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000455F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00004564                 mov     ecx, [ebp+var_C]
.text$mn:00004567                 mov     large fs:0, ecx
.text$mn:0000456E                 pop     ecx
.text$mn:0000456F                 mov     esp, ebp
.text$mn:00004571                 pop     ebp
.text$mn:00004572                 retn
.text$mn:00004572 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00004572
.text$mn:00004572 ; ---------------------------------------------------------------------------
.text$mn:00004573                 align 4
.text$mn:00004573 _text$mn        ends
.text$mn:00004573
.text$x:00004574 ; ===========================================================================
.text$x:00004574
.text$x:00004574 ; Segment type: Pure code
.text$x:00004574 ; Segment permissions: Read/Execute
.text$x:00004574 _text$x         segment para public 'CODE' use32
.text$x:00004574                 assume cs:_text$x
.text$x:00004574                 ;org 4574h
.text$x:00004574 ; COMDAT (pick associative to section at 4528)
.text$x:00004574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004574
.text$x:00004574 ; =============== S U B R O U T I N E =======================================
.text$x:00004574
.text$x:00004574
.text$x:00004574 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00004574                                         ; DATA XREF: .xdata$x:00008400o
.text$x:00004574                 mov     ecx, [ebp-10h]  ; this
.text$x:00004577                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004577 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00004577
.text$x:0000457C
.text$x:0000457C ; =============== S U B R O U T I N E =======================================
.text$x:0000457C
.text$x:0000457C
.text$x:0000457C __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:0000457C                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:0000457C
.text$x:0000457C arg_4           = dword ptr  8
.text$x:0000457C
.text$x:0000457C                 mov     edx, [esp+arg_4]
.text$x:00004580                 lea     eax, [edx+0Ch]
.text$x:00004583                 mov     ecx, [edx-8]
.text$x:00004586                 xor     ecx, eax
.text$x:00004588                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000458D                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00004592                 jmp     ___CxxFrameHandler3
.text$x:00004592 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00004592
.text$x:00004592 ; ---------------------------------------------------------------------------
.text$x:00004597                 align 4
.text$x:00004597 _text$x         ends
.text$x:00004597
.text$mn:00004598 ; ===========================================================================
.text$mn:00004598
.text$mn:00004598 ; Segment type: Pure code
.text$mn:00004598 ; Segment permissions: Read/Execute
.text$mn:00004598 _text$mn        segment para public 'CODE' use32
.text$mn:00004598                 assume cs:_text$mn
.text$mn:00004598                 ;org 4598h
.text$mn:00004598 ; COMDAT (pick any)
.text$mn:00004598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004598
.text$mn:00004598 ; =============== S U B R O U T I N E =======================================
.text$mn:00004598
.text$mn:00004598 ; Attributes: bp-based frame
.text$mn:00004598
.text$mn:00004598 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00004598                 public ??1error_category@std@@UAE@XZ
.text$mn:00004598 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00004598                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00004598
.text$mn:00004598 var_4           = dword ptr -4
.text$mn:00004598
.text$mn:00004598                 push    ebp
.text$mn:00004599                 mov     ebp, esp
.text$mn:0000459B                 push    ecx
.text$mn:0000459C                 mov     [ebp+var_4], ecx
.text$mn:0000459F                 mov     eax, [ebp+var_4]
.text$mn:000045A2                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000045A8                 mov     esp, ebp
.text$mn:000045AA                 pop     ebp
.text$mn:000045AB                 retn
.text$mn:000045AB ??1error_category@std@@UAE@XZ endp
.text$mn:000045AB
.text$mn:000045AB _text$mn        ends
.text$mn:000045AB
.text$mn:000045AC ; ===========================================================================
.text$mn:000045AC
.text$mn:000045AC ; Segment type: Pure code
.text$mn:000045AC ; Segment permissions: Read/Execute
.text$mn:000045AC _text$mn        segment para public 'CODE' use32
.text$mn:000045AC                 assume cs:_text$mn
.text$mn:000045AC                 ;org 45ACh
.text$mn:000045AC ; COMDAT (pick any)
.text$mn:000045AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045AC
.text$mn:000045AC ; =============== S U B R O U T I N E =======================================
.text$mn:000045AC
.text$mn:000045AC ; Attributes: bp-based frame
.text$mn:000045AC
.text$mn:000045AC ; void *__cdecl operator new(unsigned int, void *)
.text$mn:000045AC                 public ??2@YAPAXIPAX@Z
.text$mn:000045AC ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:000045AC                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:000045AC
.text$mn:000045AC arg_4           = dword ptr  0Ch
.text$mn:000045AC
.text$mn:000045AC                 push    ebp
.text$mn:000045AD                 mov     ebp, esp
.text$mn:000045AF                 mov     eax, [ebp+arg_4]
.text$mn:000045B2                 pop     ebp
.text$mn:000045B3                 retn
.text$mn:000045B3 ??2@YAPAXIPAX@Z endp
.text$mn:000045B3
.text$mn:000045B3 _text$mn        ends
.text$mn:000045B3
.text$mn:000045B4 ; ===========================================================================
.text$mn:000045B4
.text$mn:000045B4 ; Segment type: Pure code
.text$mn:000045B4 ; Segment permissions: Read/Execute
.text$mn:000045B4 _text$mn        segment para public 'CODE' use32
.text$mn:000045B4                 assume cs:_text$mn
.text$mn:000045B4                 ;org 45B4h
.text$mn:000045B4 ; COMDAT (pick any)
.text$mn:000045B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045B4
.text$mn:000045B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000045B4
.text$mn:000045B4 ; Attributes: bp-based frame
.text$mn:000045B4
.text$mn:000045B4 ; void __cdecl operator delete(void *)
.text$mn:000045B4                 public ??3@YAXPAX0@Z
.text$mn:000045B4 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:000045B4                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:000045B4                 push    ebp
.text$mn:000045B5                 mov     ebp, esp
.text$mn:000045B7                 pop     ebp
.text$mn:000045B8                 retn
.text$mn:000045B8 ??3@YAXPAX0@Z   endp
.text$mn:000045B8
.text$mn:000045B8 ; ---------------------------------------------------------------------------
.text$mn:000045B9                 align 4
.text$mn:000045B9 _text$mn        ends
.text$mn:000045B9
.text$mn:000045BC ; ===========================================================================
.text$mn:000045BC
.text$mn:000045BC ; Segment type: Pure code
.text$mn:000045BC ; Segment permissions: Read/Execute
.text$mn:000045BC _text$mn        segment para public 'CODE' use32
.text$mn:000045BC                 assume cs:_text$mn
.text$mn:000045BC                 ;org 45BCh
.text$mn:000045BC ; COMDAT (pick any)
.text$mn:000045BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045BC
.text$mn:000045BC ; =============== S U B R O U T I N E =======================================
.text$mn:000045BC
.text$mn:000045BC ; Attributes: bp-based frame
.text$mn:000045BC
.text$mn:000045BC ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:000045BC                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.text$mn:000045BC ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z proc near
.text$mn:000045BC                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+501p
.text$mn:000045BC
.text$mn:000045BC var_2C          = dword ptr -2Ch
.text$mn:000045BC var_28          = dword ptr -28h
.text$mn:000045BC var_24          = dword ptr -24h
.text$mn:000045BC var_20          = dword ptr -20h
.text$mn:000045BC var_1C          = dword ptr -1Ch
.text$mn:000045BC var_18          = dword ptr -18h
.text$mn:000045BC var_14          = dword ptr -14h
.text$mn:000045BC var_F           = byte ptr -0Fh
.text$mn:000045BC var_E           = byte ptr -0Eh
.text$mn:000045BC var_D           = byte ptr -0Dh
.text$mn:000045BC var_C           = dword ptr -0Ch
.text$mn:000045BC var_4           = dword ptr -4
.text$mn:000045BC arg_0           = dword ptr  8
.text$mn:000045BC
.text$mn:000045BC                 push    ebp
.text$mn:000045BD                 mov     ebp, esp
.text$mn:000045BF                 push    0FFFFFFFFh
.text$mn:000045C1                 push    offset __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.text$mn:000045C6                 mov     eax, large fs:0
.text$mn:000045CC                 push    eax
.text$mn:000045CD                 sub     esp, 20h
.text$mn:000045D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000045D5                 xor     eax, ebp
.text$mn:000045D7                 push    eax
.text$mn:000045D8                 lea     eax, [ebp+var_C]
.text$mn:000045DB                 mov     large fs:0, eax
.text$mn:000045E1                 mov     [ebp+var_14], ecx
.text$mn:000045E4                 mov     eax, [ebp+var_14]
.text$mn:000045E7                 cmp     eax, [ebp+arg_0]
.text$mn:000045EA                 jz      loc_46A3
.text$mn:000045F0                 push    0
.text$mn:000045F2                 push    1
.text$mn:000045F4                 mov     ecx, [ebp+var_14]
.text$mn:000045F7                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000045FC                 xor     ecx, ecx
.text$mn:000045FE                 jz      short loc_4615
.text$mn:00004600                 lea     edx, [ebp+var_D]
.text$mn:00004603                 push    edx
.text$mn:00004604                 mov     ecx, [ebp+arg_0]
.text$mn:00004607                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000460C                 push    eax
.text$mn:0000460D                 mov     ecx, [ebp+var_14]
.text$mn:00004610                 call    ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00004615
.text$mn:00004615 loc_4615:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+42j
.text$mn:00004615                 lea     eax, [ebp+var_E]
.text$mn:00004618                 push    eax
.text$mn:00004619                 mov     ecx, [ebp+arg_0]
.text$mn:0000461C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004621                 push    eax
.text$mn:00004622                 lea     ecx, [ebp+var_F]
.text$mn:00004625                 push    ecx
.text$mn:00004626                 mov     ecx, [ebp+var_14]
.text$mn:00004629                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000462E                 push    eax
.text$mn:0000462F                 call    ??$?9V?$allocator@_W@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@_W@std@@@0@0@Z ; std::operator!=<std::allocator<wchar_t>,std::allocator<wchar_t>>(std::_Wrap_alloc<std::allocator<wchar_t>> const &,std::_Wrap_alloc<std::allocator<wchar_t>> const &)
.text$mn:00004634                 add     esp, 8
.text$mn:00004637                 movzx   edx, al
.text$mn:0000463A                 test    edx, edx
.text$mn:0000463C                 jz      short loc_468E
.text$mn:0000463E                 sub     esp, 0Ch
.text$mn:00004641                 mov     eax, esp
.text$mn:00004643                 mov     [ebp+var_20], esp
.text$mn:00004646                 push    eax
.text$mn:00004647                 mov     ecx, [ebp+arg_0]
.text$mn:0000464A                 call    ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)
.text$mn:0000464F                 mov     [ebp+var_18], eax
.text$mn:00004652                 mov     ecx, [ebp+var_18]
.text$mn:00004655                 mov     [ebp+var_24], ecx
.text$mn:00004658                 mov     [ebp+var_4], 0
.text$mn:0000465F                 sub     esp, 0Ch
.text$mn:00004662                 mov     edx, esp
.text$mn:00004664                 mov     [ebp+var_28], esp
.text$mn:00004667                 push    edx
.text$mn:00004668                 mov     ecx, [ebp+arg_0]
.text$mn:0000466B                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00004670                 mov     [ebp+var_1C], eax
.text$mn:00004673                 mov     eax, [ebp+var_1C]
.text$mn:00004676                 mov     [ebp+var_2C], eax
.text$mn:00004679                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000467D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004684                 mov     ecx, [ebp+var_14]
.text$mn:00004687                 call    ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:0000468C                 jmp     short loc_46A3
.text$mn:0000468E ; ---------------------------------------------------------------------------
.text$mn:0000468E
.text$mn:0000468E loc_468E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+80j
.text$mn:0000468E                 mov     ecx, [ebp+arg_0]
.text$mn:00004691                 push    ecx
.text$mn:00004692                 call    ??$forward@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@YA$$QAV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@AAV10@@Z ; std::forward<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &)
.text$mn:00004697                 add     esp, 4
.text$mn:0000469A                 push    eax
.text$mn:0000469B                 mov     ecx, [ebp+var_14]
.text$mn:0000469E                 call    ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:000046A3
.text$mn:000046A3 loc_46A3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Ej
.text$mn:000046A3                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+D0j
.text$mn:000046A3                 mov     eax, [ebp+var_14]
.text$mn:000046A6                 mov     ecx, [ebp+var_C]
.text$mn:000046A9                 mov     large fs:0, ecx
.text$mn:000046B0                 pop     ecx
.text$mn:000046B1                 mov     esp, ebp
.text$mn:000046B3                 pop     ebp
.text$mn:000046B4                 retn    4
.text$mn:000046B4 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z endp
.text$mn:000046B4
.text$mn:000046B4 ; ---------------------------------------------------------------------------
.text$mn:000046B7                 align 4
.text$mn:000046B7 _text$mn        ends
.text$mn:000046B7
.text$x:000046B8 ; ===========================================================================
.text$x:000046B8
.text$x:000046B8 ; Segment type: Pure code
.text$x:000046B8 ; Segment permissions: Read/Execute
.text$x:000046B8 _text$x         segment para public 'CODE' use32
.text$x:000046B8                 assume cs:_text$x
.text$x:000046B8                 ;org 46B8h
.text$x:000046B8 ; COMDAT (pick associative to section at 45BC)
.text$x:000046B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000046B8
.text$x:000046B8 ; =============== S U B R O U T I N E =======================================
.text$x:000046B8
.text$x:000046B8
.text$x:000046B8 __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$0 proc near
.text$x:000046B8                                         ; DATA XREF: .xdata$x:0000858Co
.text$x:000046B8                 mov     ecx, [ebp-20h]
.text$x:000046BB                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000046BB __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$0 endp
.text$x:000046BB
.text$x:000046C0
.text$x:000046C0 ; =============== S U B R O U T I N E =======================================
.text$x:000046C0
.text$x:000046C0
.text$x:000046C0 __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$1 proc near
.text$x:000046C0                                         ; DATA XREF: .xdata$x:00008594o
.text$x:000046C0                 mov     ecx, [ebp-28h]
.text$x:000046C3                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000046C3 __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$1 endp
.text$x:000046C3
.text$x:000046C8
.text$x:000046C8 ; =============== S U B R O U T I N E =======================================
.text$x:000046C8
.text$x:000046C8
.text$x:000046C8 __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z proc near
.text$x:000046C8                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+5o
.text$x:000046C8
.text$x:000046C8 arg_4           = dword ptr  8
.text$x:000046C8
.text$x:000046C8                 mov     edx, [esp+arg_4]
.text$x:000046CC                 lea     eax, [edx+0Ch]
.text$x:000046CF                 mov     ecx, [edx-24h]
.text$x:000046D2                 xor     ecx, eax
.text$x:000046D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000046D9                 mov     eax, offset __ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.text$x:000046DE                 jmp     ___CxxFrameHandler3
.text$x:000046DE __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z endp
.text$x:000046DE
.text$x:000046DE ; ---------------------------------------------------------------------------
.text$x:000046E3                 align 4
.text$x:000046E3 _text$x         ends
.text$x:000046E3
.text$mn:000046E4 ; ===========================================================================
.text$mn:000046E4
.text$mn:000046E4 ; Segment type: Pure code
.text$mn:000046E4 ; Segment permissions: Read/Execute
.text$mn:000046E4 _text$mn        segment para public 'CODE' use32
.text$mn:000046E4                 assume cs:_text$mn
.text$mn:000046E4                 ;org 46E4h
.text$mn:000046E4 ; COMDAT (pick any)
.text$mn:000046E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046E4
.text$mn:000046E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000046E4
.text$mn:000046E4 ; Attributes: bp-based frame
.text$mn:000046E4
.text$mn:000046E4 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t *Str)
.text$mn:000046E4                 public ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:000046E4 ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:000046E4                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+DEp
.text$mn:000046E4                                         ; RunDlg::run_dlgProc(uint,uint,long)+368p
.text$mn:000046E4
.text$mn:000046E4 var_4           = dword ptr -4
.text$mn:000046E4 Str             = dword ptr  8
.text$mn:000046E4
.text$mn:000046E4                 push    ebp
.text$mn:000046E5                 mov     ebp, esp
.text$mn:000046E7                 push    ecx
.text$mn:000046E8                 mov     [ebp+var_4], ecx
.text$mn:000046EB                 mov     eax, [ebp+Str]
.text$mn:000046EE                 push    eax             ; Str
.text$mn:000046EF                 mov     ecx, [ebp+var_4]
.text$mn:000046F2                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:000046F7                 mov     esp, ebp
.text$mn:000046F9                 pop     ebp
.text$mn:000046FA                 retn    4
.text$mn:000046FA ??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:000046FA
.text$mn:000046FA ; ---------------------------------------------------------------------------
.text$mn:000046FD                 align 10h
.text$mn:000046FD _text$mn        ends
.text$mn:000046FD
.text$mn:00004700 ; ===========================================================================
.text$mn:00004700
.text$mn:00004700 ; Segment type: Pure code
.text$mn:00004700 ; Segment permissions: Read/Execute
.text$mn:00004700 _text$mn        segment para public 'CODE' use32
.text$mn:00004700                 assume cs:_text$mn
.text$mn:00004700                 ;org 4700h
.text$mn:00004700 ; COMDAT (pick any)
.text$mn:00004700                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004700
.text$mn:00004700 ; =============== S U B R O U T I N E =======================================
.text$mn:00004700
.text$mn:00004700 ; Attributes: bp-based frame
.text$mn:00004700
.text$mn:00004700 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00004700                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00004700 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00004700                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00004700
.text$mn:00004700 var_14          = byte ptr -14h
.text$mn:00004700 var_10          = dword ptr -10h
.text$mn:00004700 var_C           = dword ptr -0Ch
.text$mn:00004700 var_4           = dword ptr -4
.text$mn:00004700 arg_0           = dword ptr  8
.text$mn:00004700
.text$mn:00004700                 push    ebp
.text$mn:00004701                 mov     ebp, esp
.text$mn:00004703                 push    0FFFFFFFFh
.text$mn:00004705                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000470A                 mov     eax, large fs:0
.text$mn:00004710                 push    eax
.text$mn:00004711                 sub     esp, 8
.text$mn:00004714                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004719                 xor     eax, ebp
.text$mn:0000471B                 push    eax
.text$mn:0000471C                 lea     eax, [ebp+var_C]
.text$mn:0000471F                 mov     large fs:0, eax
.text$mn:00004725                 mov     [ebp+var_10], ecx
.text$mn:00004728                 mov     eax, [ebp+var_10]
.text$mn:0000472B                 mov     ecx, [ebp+arg_0]
.text$mn:0000472E                 mov     edx, [eax]
.text$mn:00004730                 cmp     edx, [ecx]
.text$mn:00004732                 jnz     short loc_4736
.text$mn:00004734                 jmp     short loc_4778
.text$mn:00004736 ; ---------------------------------------------------------------------------
.text$mn:00004736
.text$mn:00004736 loc_4736:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00004736                 mov     eax, [ebp+arg_0]
.text$mn:00004739                 cmp     dword ptr [eax], 0
.text$mn:0000473C                 jz      short loc_4750
.text$mn:0000473E                 mov     ecx, [ebp+arg_0]
.text$mn:00004741                 mov     edx, [ecx]
.text$mn:00004743                 mov     eax, [edx]
.text$mn:00004745                 push    eax             ; struct std::_Container_base12 *
.text$mn:00004746                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004749                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000474E                 jmp     short loc_4778
.text$mn:00004750 ; ---------------------------------------------------------------------------
.text$mn:00004750
.text$mn:00004750 loc_4750:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00004750                 push    3               ; int
.text$mn:00004752                 lea     ecx, [ebp+var_14] ; this
.text$mn:00004755                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000475A                 mov     [ebp+var_4], 0
.text$mn:00004761                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004764                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00004769                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004770                 lea     ecx, [ebp+var_14] ; this
.text$mn:00004773                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004778
.text$mn:00004778 loc_4778:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00004778                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00004778                 mov     eax, [ebp+var_10]
.text$mn:0000477B                 mov     ecx, [ebp+var_C]
.text$mn:0000477E                 mov     large fs:0, ecx
.text$mn:00004785                 pop     ecx
.text$mn:00004786                 mov     esp, ebp
.text$mn:00004788                 pop     ebp
.text$mn:00004789                 retn    4
.text$mn:00004789 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00004789
.text$mn:00004789 _text$mn        ends
.text$mn:00004789
.text$x:0000478C ; ===========================================================================
.text$x:0000478C
.text$x:0000478C ; Segment type: Pure code
.text$x:0000478C ; Segment permissions: Read/Execute
.text$x:0000478C _text$x         segment para public 'CODE' use32
.text$x:0000478C                 assume cs:_text$x
.text$x:0000478C                 ;org 478Ch
.text$x:0000478C ; COMDAT (pick associative to section at 4700)
.text$x:0000478C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000478C
.text$x:0000478C ; =============== S U B R O U T I N E =======================================
.text$x:0000478C
.text$x:0000478C
.text$x:0000478C __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:0000478C                                         ; DATA XREF: .xdata$x:00008080o
.text$x:0000478C                 lea     ecx, [ebp-14h]  ; this
.text$x:0000478F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000478F __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:0000478F
.text$x:00004794
.text$x:00004794 ; =============== S U B R O U T I N E =======================================
.text$x:00004794
.text$x:00004794
.text$x:00004794 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00004794                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00004794
.text$x:00004794 arg_4           = dword ptr  8
.text$x:00004794
.text$x:00004794                 mov     edx, [esp+arg_4]
.text$x:00004798                 lea     eax, [edx+0Ch]
.text$x:0000479B                 mov     ecx, [edx-0Ch]
.text$x:0000479E                 xor     ecx, eax
.text$x:000047A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000047A5                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:000047AA                 jmp     ___CxxFrameHandler3
.text$x:000047AA __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:000047AA
.text$x:000047AA ; ---------------------------------------------------------------------------
.text$x:000047AF                 align 10h
.text$x:000047AF _text$x         ends
.text$x:000047AF
.text$mn:000047B0 ; ===========================================================================
.text$mn:000047B0
.text$mn:000047B0 ; Segment type: Pure code
.text$mn:000047B0 ; Segment permissions: Read/Execute
.text$mn:000047B0 _text$mn        segment para public 'CODE' use32
.text$mn:000047B0                 assume cs:_text$mn
.text$mn:000047B0                 ;org 47B0h
.text$mn:000047B0 ; COMDAT (pick any)
.text$mn:000047B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047B0
.text$mn:000047B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000047B0
.text$mn:000047B0 ; Attributes: bp-based frame
.text$mn:000047B0
.text$mn:000047B0 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_Iterator_base12 *)
.text$mn:000047B0                 public ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:000047B0 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:000047B0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+39p
.text$mn:000047B0
.text$mn:000047B0 var_8           = dword ptr -8
.text$mn:000047B0 var_4           = dword ptr -4
.text$mn:000047B0 arg_0           = dword ptr  8
.text$mn:000047B0
.text$mn:000047B0                 push    ebp
.text$mn:000047B1                 mov     ebp, esp
.text$mn:000047B3                 sub     esp, 8
.text$mn:000047B6                 mov     [ebp+var_4], ecx
.text$mn:000047B9                 mov     eax, [ebp+arg_0]
.text$mn:000047BC                 push    eax             ; std::_Iterator_base12 *
.text$mn:000047BD                 mov     ecx, [ebp+var_4]
.text$mn:000047C0                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000047C5                 mov     ecx, [ebp+var_4]
.text$mn:000047C8                 mov     edx, [ebp+arg_0]
.text$mn:000047CB                 mov     eax, [ecx+8]
.text$mn:000047CE                 cmp     eax, [edx+8]
.text$mn:000047D1                 jnz     short loc_47DC
.text$mn:000047D3                 mov     [ebp+var_8], 1
.text$mn:000047DA                 jmp     short loc_47E3
.text$mn:000047DC ; ---------------------------------------------------------------------------
.text$mn:000047DC
.text$mn:000047DC loc_47DC:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+21j
.text$mn:000047DC                 mov     [ebp+var_8], 0
.text$mn:000047E3
.text$mn:000047E3 loc_47E3:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+2Aj
.text$mn:000047E3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000047E6                 mov     esp, ebp
.text$mn:000047E8                 pop     ebp
.text$mn:000047E9                 retn    4
.text$mn:000047E9 ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:000047E9
.text$mn:000047E9 _text$mn        ends
.text$mn:000047E9
.text$mn:000047EC ; ===========================================================================
.text$mn:000047EC
.text$mn:000047EC ; Segment type: Pure code
.text$mn:000047EC ; Segment permissions: Read/Execute
.text$mn:000047EC _text$mn        segment para public 'CODE' use32
.text$mn:000047EC                 assume cs:_text$mn
.text$mn:000047EC                 ;org 47ECh
.text$mn:000047EC ; COMDAT (pick any)
.text$mn:000047EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047EC
.text$mn:000047EC ; =============== S U B R O U T I N E =======================================
.text$mn:000047EC
.text$mn:000047EC ; Attributes: bp-based frame
.text$mn:000047EC
.text$mn:000047EC ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:000047EC                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:000047EC ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:000047EC                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:000047EC                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:000047EC
.text$mn:000047EC var_8           = dword ptr -8
.text$mn:000047EC var_4           = dword ptr -4
.text$mn:000047EC arg_0           = dword ptr  8
.text$mn:000047EC
.text$mn:000047EC                 push    ebp
.text$mn:000047ED                 mov     ebp, esp
.text$mn:000047EF                 sub     esp, 8
.text$mn:000047F2                 mov     [ebp+var_8], ecx
.text$mn:000047F5                 mov     eax, [ebp+var_8]
.text$mn:000047F8                 cmp     eax, [ebp+arg_0]
.text$mn:000047FB                 jnz     short loc_4806
.text$mn:000047FD                 mov     [ebp+var_4], 1
.text$mn:00004804                 jmp     short loc_480D
.text$mn:00004806 ; ---------------------------------------------------------------------------
.text$mn:00004806
.text$mn:00004806 loc_4806:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00004806                 mov     [ebp+var_4], 0
.text$mn:0000480D
.text$mn:0000480D loc_480D:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:0000480D                 mov     al, byte ptr [ebp+var_4]
.text$mn:00004810                 mov     esp, ebp
.text$mn:00004812                 pop     ebp
.text$mn:00004813                 retn    4
.text$mn:00004813 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00004813
.text$mn:00004813 ; ---------------------------------------------------------------------------
.text$mn:00004816                 align 4
.text$mn:00004816 _text$mn        ends
.text$mn:00004816
.text$mn:00004818 ; ===========================================================================
.text$mn:00004818
.text$mn:00004818 ; Segment type: Pure code
.text$mn:00004818 ; Segment permissions: Read/Execute
.text$mn:00004818 _text$mn        segment para public 'CODE' use32
.text$mn:00004818                 assume cs:_text$mn
.text$mn:00004818                 ;org 4818h
.text$mn:00004818 ; COMDAT (pick any)
.text$mn:00004818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004818
.text$mn:00004818 ; =============== S U B R O U T I N E =======================================
.text$mn:00004818
.text$mn:00004818 ; Attributes: bp-based frame
.text$mn:00004818
.text$mn:00004818 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00004818                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00004818 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00004818                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00004818
.text$mn:00004818 var_8           = dword ptr -8
.text$mn:00004818 var_4           = dword ptr -4
.text$mn:00004818 arg_0           = dword ptr  8
.text$mn:00004818
.text$mn:00004818                 push    ebp
.text$mn:00004819                 mov     ebp, esp
.text$mn:0000481B                 sub     esp, 8
.text$mn:0000481E                 push    esi
.text$mn:0000481F                 mov     [ebp+var_4], ecx
.text$mn:00004822                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004825                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000482A                 push    eax
.text$mn:0000482B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000482E                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00004833                 mov     ecx, eax
.text$mn:00004835                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000483A                 movzx   eax, al
.text$mn:0000483D                 test    eax, eax
.text$mn:0000483F                 jz      short loc_4860
.text$mn:00004841                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004844                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00004849                 mov     esi, eax
.text$mn:0000484B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000484E                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00004853                 cmp     esi, eax
.text$mn:00004855                 jnz     short loc_4860
.text$mn:00004857                 mov     [ebp+var_8], 1
.text$mn:0000485E                 jmp     short loc_4867
.text$mn:00004860 ; ---------------------------------------------------------------------------
.text$mn:00004860
.text$mn:00004860 loc_4860:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00004860                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00004860                 mov     [ebp+var_8], 0
.text$mn:00004867
.text$mn:00004867 loc_4867:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00004867                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000486A                 pop     esi
.text$mn:0000486B                 mov     esp, ebp
.text$mn:0000486D                 pop     ebp
.text$mn:0000486E                 retn    4
.text$mn:0000486E ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:0000486E
.text$mn:0000486E ; ---------------------------------------------------------------------------
.text$mn:00004871                 align 4
.text$mn:00004871 _text$mn        ends
.text$mn:00004871
.text$mn:00004874 ; ===========================================================================
.text$mn:00004874
.text$mn:00004874 ; Segment type: Pure code
.text$mn:00004874 ; Segment permissions: Read/Execute
.text$mn:00004874 _text$mn        segment para public 'CODE' use32
.text$mn:00004874                 assume cs:_text$mn
.text$mn:00004874                 ;org 4874h
.text$mn:00004874 ; COMDAT (pick any)
.text$mn:00004874                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004874
.text$mn:00004874 ; =============== S U B R O U T I N E =======================================
.text$mn:00004874
.text$mn:00004874 ; Attributes: bp-based frame
.text$mn:00004874
.text$mn:00004874 ; public: wchar_t const & __thiscall std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator*(void)const
.text$mn:00004874                 public ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ
.text$mn:00004874 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ proc near
.text$mn:00004874                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+Ap
.text$mn:00004874
.text$mn:00004874 var_4           = dword ptr -4
.text$mn:00004874
.text$mn:00004874                 push    ebp
.text$mn:00004875                 mov     ebp, esp
.text$mn:00004877                 push    ecx
.text$mn:00004878                 push    esi
.text$mn:00004879                 mov     [ebp+var_4], ecx
.text$mn:0000487C                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000487F                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004884                 test    eax, eax
.text$mn:00004886                 jz      short loc_48CF
.text$mn:00004888                 mov     eax, [ebp+var_4]
.text$mn:0000488B                 cmp     dword ptr [eax+8], 0
.text$mn:0000488F                 jz      short loc_48CF
.text$mn:00004891                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004894                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004899                 mov     ecx, eax
.text$mn:0000489B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000048A0                 mov     ecx, [ebp+var_4]
.text$mn:000048A3                 cmp     [ecx+8], eax
.text$mn:000048A6                 jb      short loc_48CF
.text$mn:000048A8                 mov     ecx, [ebp+var_4] ; this
.text$mn:000048AB                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000048B0                 mov     ecx, eax
.text$mn:000048B2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000048B7                 mov     esi, eax
.text$mn:000048B9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000048BC                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000048C1                 mov     edx, [eax+14h]
.text$mn:000048C4                 lea     eax, [esi+edx*2]
.text$mn:000048C7                 mov     ecx, [ebp+var_4]
.text$mn:000048CA                 cmp     eax, [ecx+8]
.text$mn:000048CD                 ja      short loc_492E
.text$mn:000048CF
.text$mn:000048CF loc_48CF:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+12j
.text$mn:000048CF                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+1Bj ...
.text$mn:000048CF                 push    4Fh ; 'O'       ; unsigned int
.text$mn:000048D1                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000048D6                 push    offset ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "string iterator not dereferencable"
.text$mn:000048DB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000048E0                 add     esp, 0Ch
.text$mn:000048E3                 mov     edx, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:000048E8                 test    edx, edx
.text$mn:000048EA                 jz      short loc_48F0
.text$mn:000048EC                 xor     eax, eax
.text$mn:000048EE                 jnz     short loc_4913
.text$mn:000048F0
.text$mn:000048F0 loc_48F0:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+76j
.text$mn:000048F0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:000048F5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:000048FA                 push    0
.text$mn:000048FC                 push    50h ; 'P'
.text$mn:000048FE                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004903                 push    2
.text$mn:00004905                 call    __CrtDbgReportW
.text$mn:0000490A                 add     esp, 18h
.text$mn:0000490D                 cmp     eax, 1
.text$mn:00004910                 jnz     short loc_4913
.text$mn:00004912                 int     3               ; Trap to Debugger
.text$mn:00004913
.text$mn:00004913 loc_4913:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+7Aj
.text$mn:00004913                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+9Cj
.text$mn:00004913                 push    0
.text$mn:00004915                 push    50h ; 'P'
.text$mn:00004917                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000491C                 push    offset ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:00004921                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00004926                 call    __invalid_parameter
.text$mn:0000492B                 add     esp, 14h
.text$mn:0000492E
.text$mn:0000492E loc_492E:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+59j
.text$mn:0000492E                 mov     edx, [ebp+var_4]
.text$mn:00004931                 mov     eax, [edx+8]
.text$mn:00004934                 pop     esi
.text$mn:00004935                 mov     esp, ebp
.text$mn:00004937                 pop     ebp
.text$mn:00004938                 retn
.text$mn:00004938 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ endp
.text$mn:00004938
.text$mn:00004938 ; ---------------------------------------------------------------------------
.text$mn:00004939                 align 4
.text$mn:00004939 _text$mn        ends
.text$mn:00004939
.text$mn:0000493C ; ===========================================================================
.text$mn:0000493C
.text$mn:0000493C ; Segment type: Pure code
.text$mn:0000493C ; Segment permissions: Read/Execute
.text$mn:0000493C _text$mn        segment para public 'CODE' use32
.text$mn:0000493C                 assume cs:_text$mn
.text$mn:0000493C                 ;org 493Ch
.text$mn:0000493C ; COMDAT (pick any)
.text$mn:0000493C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000493C
.text$mn:0000493C ; =============== S U B R O U T I N E =======================================
.text$mn:0000493C
.text$mn:0000493C ; Attributes: bp-based frame
.text$mn:0000493C
.text$mn:0000493C ; public: wchar_t & __thiscall std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>::operator*(void)const
.text$mn:0000493C                 public ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ
.text$mn:0000493C ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ proc near
.text$mn:0000493C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+135p
.text$mn:0000493C
.text$mn:0000493C var_4           = dword ptr -4
.text$mn:0000493C
.text$mn:0000493C                 push    ebp
.text$mn:0000493D                 mov     ebp, esp
.text$mn:0000493F                 push    ecx
.text$mn:00004940                 mov     [ebp+var_4], ecx
.text$mn:00004943                 mov     ecx, [ebp+var_4]
.text$mn:00004946                 call    ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAB_WXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:0000494B                 mov     esp, ebp
.text$mn:0000494D                 pop     ebp
.text$mn:0000494E                 retn
.text$mn:0000494E ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ endp
.text$mn:0000494E
.text$mn:0000494E ; ---------------------------------------------------------------------------
.text$mn:0000494F                 align 10h
.text$mn:0000494F _text$mn        ends
.text$mn:0000494F
.text$mn:00004950 ; ===========================================================================
.text$mn:00004950
.text$mn:00004950 ; Segment type: Pure code
.text$mn:00004950 ; Segment permissions: Read/Execute
.text$mn:00004950 _text$mn        segment para public 'CODE' use32
.text$mn:00004950                 assume cs:_text$mn
.text$mn:00004950                 ;org 4950h
.text$mn:00004950 ; COMDAT (pick any)
.text$mn:00004950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004950
.text$mn:00004950 ; =============== S U B R O U T I N E =======================================
.text$mn:00004950
.text$mn:00004950 ; Attributes: bp-based frame
.text$mn:00004950
.text$mn:00004950 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:00004950                 public ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:00004950 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:00004950                                         ; CODE XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+4Bp
.text$mn:00004950                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+42p
.text$mn:00004950
.text$mn:00004950 var_4           = dword ptr -4
.text$mn:00004950 arg_0           = dword ptr  8
.text$mn:00004950
.text$mn:00004950                 push    ebp
.text$mn:00004951                 mov     ebp, esp
.text$mn:00004953                 push    ecx
.text$mn:00004954                 mov     [ebp+var_4], ecx
.text$mn:00004957                 mov     eax, [ebp+arg_0]
.text$mn:0000495A                 push    eax             ; std::_Iterator_base12 *
.text$mn:0000495B                 mov     ecx, [ebp+var_4]
.text$mn:0000495E                 call    ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00004963                 mov     ecx, [ebp+var_4]
.text$mn:00004966                 mov     edx, [ebp+arg_0]
.text$mn:00004969                 mov     eax, [ecx+8]
.text$mn:0000496C                 sub     eax, [edx+8]
.text$mn:0000496F                 sar     eax, 1
.text$mn:00004971                 mov     esp, ebp
.text$mn:00004973                 pop     ebp
.text$mn:00004974                 retn    4
.text$mn:00004974 ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:00004974
.text$mn:00004974 ; ---------------------------------------------------------------------------
.text$mn:00004977                 align 4
.text$mn:00004977 _text$mn        ends
.text$mn:00004977
.text$mn:00004978 ; ===========================================================================
.text$mn:00004978
.text$mn:00004978 ; Segment type: Pure code
.text$mn:00004978 ; Segment permissions: Read/Execute
.text$mn:00004978 _text$mn        segment para public 'CODE' use32
.text$mn:00004978                 assume cs:_text$mn
.text$mn:00004978                 ;org 4978h
.text$mn:00004978 ; COMDAT (pick any)
.text$mn:00004978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004978
.text$mn:00004978 ; =============== S U B R O U T I N E =======================================
.text$mn:00004978
.text$mn:00004978 ; Attributes: bp-based frame
.text$mn:00004978
.text$mn:00004978 ; int __stdcall std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_Iterator_base12 *)
.text$mn:00004978                 public ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:00004978 ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$mn:00004978                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+12Cp
.text$mn:00004978
.text$mn:00004978 var_28          = byte ptr -28h
.text$mn:00004978 var_1C          = dword ptr -1Ch
.text$mn:00004978 var_18          = dword ptr -18h
.text$mn:00004978 var_14          = dword ptr -14h
.text$mn:00004978 var_10          = dword ptr -10h
.text$mn:00004978 var_C           = dword ptr -0Ch
.text$mn:00004978 var_4           = dword ptr -4
.text$mn:00004978 arg_0           = dword ptr  8
.text$mn:00004978
.text$mn:00004978                 push    ebp
.text$mn:00004979                 mov     ebp, esp
.text$mn:0000497B                 push    0FFFFFFFFh
.text$mn:0000497D                 push    offset __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$mn:00004982                 mov     eax, large fs:0
.text$mn:00004988                 push    eax
.text$mn:00004989                 sub     esp, 1Ch
.text$mn:0000498C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004991                 xor     eax, ebp
.text$mn:00004993                 push    eax
.text$mn:00004994                 lea     eax, [ebp+var_C]
.text$mn:00004997                 mov     large fs:0, eax
.text$mn:0000499D                 mov     [ebp+var_10], ecx
.text$mn:000049A0                 mov     eax, [ebp+arg_0]
.text$mn:000049A3                 push    eax             ; std::_Iterator_base12 *
.text$mn:000049A4                 mov     ecx, [ebp+var_10]
.text$mn:000049A7                 push    ecx             ; struct std::_Iterator_base12 *
.text$mn:000049A8                 lea     ecx, [ebp+var_28]
.text$mn:000049AB                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000049B0                 mov     [ebp+var_14], eax
.text$mn:000049B3                 mov     edx, [ebp+var_14]
.text$mn:000049B6                 mov     [ebp+var_18], edx
.text$mn:000049B9                 mov     [ebp+var_4], 0
.text$mn:000049C0                 mov     ecx, [ebp+var_18]
.text$mn:000049C3                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:000049C8                 mov     [ebp+var_1C], eax
.text$mn:000049CB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000049D2                 lea     ecx, [ebp+var_28]
.text$mn:000049D5                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:000049DA                 mov     eax, [ebp+var_1C]
.text$mn:000049DD                 mov     ecx, [ebp+var_C]
.text$mn:000049E0                 mov     large fs:0, ecx
.text$mn:000049E7                 pop     ecx
.text$mn:000049E8                 mov     esp, ebp
.text$mn:000049EA                 pop     ebp
.text$mn:000049EB                 retn    4
.text$mn:000049EB ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$mn:000049EB
.text$mn:000049EB ; ---------------------------------------------------------------------------
.text$mn:000049EE                 align 10h
.text$mn:000049EE _text$mn        ends
.text$mn:000049EE
.text$x:000049F0 ; ===========================================================================
.text$x:000049F0
.text$x:000049F0 ; Segment type: Pure code
.text$x:000049F0 ; Segment permissions: Read/Execute
.text$x:000049F0 _text$x         segment para public 'CODE' use32
.text$x:000049F0                 assume cs:_text$x
.text$x:000049F0                 ;org 49F0h
.text$x:000049F0 ; COMDAT (pick associative to section at 4978)
.text$x:000049F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000049F0
.text$x:000049F0 ; =============== S U B R O U T I N E =======================================
.text$x:000049F0
.text$x:000049F0
.text$x:000049F0 __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 proc near
.text$x:000049F0                                         ; DATA XREF: .xdata$x:00008C38o
.text$x:000049F0                 lea     ecx, [ebp-28h]
.text$x:000049F3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:000049F3 __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0 endp
.text$x:000049F3
.text$x:000049F8
.text$x:000049F8 ; =============== S U B R O U T I N E =======================================
.text$x:000049F8
.text$x:000049F8
.text$x:000049F8 __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z proc near
.text$x:000049F8                                         ; DATA XREF: std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+5o
.text$x:000049F8
.text$x:000049F8 arg_4           = dword ptr  8
.text$x:000049F8
.text$x:000049F8                 mov     edx, [esp+arg_4]
.text$x:000049FC                 lea     eax, [edx+0Ch]
.text$x:000049FF                 mov     ecx, [edx-20h]
.text$x:00004A02                 xor     ecx, eax
.text$x:00004A04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A09                 mov     eax, offset __ehfuncinfo$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.text$x:00004A0E                 jmp     ___CxxFrameHandler3
.text$x:00004A0E __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z endp
.text$x:00004A0E
.text$x:00004A0E ; ---------------------------------------------------------------------------
.text$x:00004A13                 align 4
.text$x:00004A13 _text$x         ends
.text$x:00004A13
.text$mn:00004A14 ; ===========================================================================
.text$mn:00004A14
.text$mn:00004A14 ; Segment type: Pure code
.text$mn:00004A14 ; Segment permissions: Read/Execute
.text$mn:00004A14 _text$mn        segment para public 'CODE' use32
.text$mn:00004A14                 assume cs:_text$mn
.text$mn:00004A14                 ;org 4A14h
.text$mn:00004A14 ; COMDAT (pick any)
.text$mn:00004A14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A14
.text$mn:00004A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A14
.text$mn:00004A14 ; Attributes: bp-based frame
.text$mn:00004A14
.text$mn:00004A14 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::operator+=(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00004A14                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z
.text$mn:00004A14 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:00004A14                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+73p
.text$mn:00004A14                                         ; Shortcut::toMenuItemString(void)+90p
.text$mn:00004A14
.text$mn:00004A14 var_4           = dword ptr -4
.text$mn:00004A14 arg_0           = dword ptr  8
.text$mn:00004A14
.text$mn:00004A14                 push    ebp
.text$mn:00004A15                 mov     ebp, esp
.text$mn:00004A17                 push    ecx
.text$mn:00004A18                 mov     [ebp+var_4], ecx
.text$mn:00004A1B                 mov     eax, [ebp+arg_0]
.text$mn:00004A1E                 push    eax
.text$mn:00004A1F                 mov     ecx, [ebp+var_4]
.text$mn:00004A22                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00004A27                 mov     esp, ebp
.text$mn:00004A29                 pop     ebp
.text$mn:00004A2A                 retn    4
.text$mn:00004A2A ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00004A2A
.text$mn:00004A2A ; ---------------------------------------------------------------------------
.text$mn:00004A2D                 align 10h
.text$mn:00004A2D _text$mn        ends
.text$mn:00004A2D
.text$mn:00004A30 ; ===========================================================================
.text$mn:00004A30
.text$mn:00004A30 ; Segment type: Pure code
.text$mn:00004A30 ; Segment permissions: Read/Execute
.text$mn:00004A30 _text$mn        segment para public 'CODE' use32
.text$mn:00004A30                 assume cs:_text$mn
.text$mn:00004A30                 ;org 4A30h
.text$mn:00004A30 ; COMDAT (pick any)
.text$mn:00004A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A30
.text$mn:00004A30 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A30
.text$mn:00004A30 ; Attributes: bp-based frame
.text$mn:00004A30
.text$mn:00004A30 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t *Str)
.text$mn:00004A30                 public ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z
.text$mn:00004A30 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z proc near
.text$mn:00004A30                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+67p
.text$mn:00004A30                                         ; Shortcut::toMenuItemString(void)+66p
.text$mn:00004A30
.text$mn:00004A30 var_4           = dword ptr -4
.text$mn:00004A30 Str             = dword ptr  8
.text$mn:00004A30
.text$mn:00004A30                 push    ebp
.text$mn:00004A31                 mov     ebp, esp
.text$mn:00004A33                 push    ecx
.text$mn:00004A34                 mov     [ebp+var_4], ecx
.text$mn:00004A37                 mov     eax, [ebp+Str]
.text$mn:00004A3A                 push    eax             ; Str
.text$mn:00004A3B                 mov     ecx, [ebp+var_4]
.text$mn:00004A3E                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)
.text$mn:00004A43                 mov     esp, ebp
.text$mn:00004A45                 pop     ebp
.text$mn:00004A46                 retn    4
.text$mn:00004A46 ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z endp
.text$mn:00004A46
.text$mn:00004A46 ; ---------------------------------------------------------------------------
.text$mn:00004A49                 align 4
.text$mn:00004A49 _text$mn        ends
.text$mn:00004A49
.text$mn:00004A4C ; ===========================================================================
.text$mn:00004A4C
.text$mn:00004A4C ; Segment type: Pure code
.text$mn:00004A4C ; Segment permissions: Read/Execute
.text$mn:00004A4C _text$mn        segment para public 'CODE' use32
.text$mn:00004A4C                 assume cs:_text$mn
.text$mn:00004A4C                 ;org 4A4Ch
.text$mn:00004A4C ; COMDAT (pick any)
.text$mn:00004A4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A4C
.text$mn:00004A4C ; =============== S U B R O U T I N E =======================================
.text$mn:00004A4C
.text$mn:00004A4C ; Attributes: bp-based frame
.text$mn:00004A4C
.text$mn:00004A4C ; public: virtual void * __thiscall CommandShortcut::`scalar deleting destructor'(unsigned int)
.text$mn:00004A4C                 public ??_GCommandShortcut@@UAEPAXI@Z
.text$mn:00004A4C ??_GCommandShortcut@@UAEPAXI@Z proc near
.text$mn:00004A4C
.text$mn:00004A4C var_4           = dword ptr -4
.text$mn:00004A4C arg_0           = dword ptr  8
.text$mn:00004A4C
.text$mn:00004A4C                 push    ebp
.text$mn:00004A4D                 mov     ebp, esp
.text$mn:00004A4F                 push    ecx
.text$mn:00004A50                 mov     [ebp+var_4], ecx
.text$mn:00004A53                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004A56                 call    ??1CommandShortcut@@UAE@XZ ; CommandShortcut::~CommandShortcut(void)
.text$mn:00004A5B                 mov     eax, [ebp+arg_0]
.text$mn:00004A5E                 and     eax, 1
.text$mn:00004A61                 jz      short loc_4A6F
.text$mn:00004A63                 mov     ecx, [ebp+var_4]
.text$mn:00004A66                 push    ecx             ; void *
.text$mn:00004A67                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004A6C                 add     esp, 4
.text$mn:00004A6F
.text$mn:00004A6F loc_4A6F:                               ; CODE XREF: CommandShortcut::`scalar deleting destructor'(uint)+15j
.text$mn:00004A6F                 mov     eax, [ebp+var_4]
.text$mn:00004A72                 mov     esp, ebp
.text$mn:00004A74                 pop     ebp
.text$mn:00004A75                 retn    4
.text$mn:00004A75 ??_GCommandShortcut@@UAEPAXI@Z endp
.text$mn:00004A75
.text$mn:00004A75 _text$mn        ends
.text$mn:00004A75
.text$mn:00004A78 ; ===========================================================================
.text$mn:00004A78
.text$mn:00004A78 ; Segment type: Pure code
.text$mn:00004A78 ; Segment permissions: Read/Execute
.text$mn:00004A78 _text$mn        segment para public 'CODE' use32
.text$mn:00004A78                 assume cs:_text$mn
.text$mn:00004A78                 ;org 4A78h
.text$mn:00004A78 ; COMDAT (pick any)
.text$mn:00004A78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A78
.text$mn:00004A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A78
.text$mn:00004A78 ; Attributes: bp-based frame
.text$mn:00004A78
.text$mn:00004A78 ; public: virtual void * __thiscall Shortcut::`scalar deleting destructor'(unsigned int)
.text$mn:00004A78                 public ??_GShortcut@@UAEPAXI@Z
.text$mn:00004A78 ??_GShortcut@@UAEPAXI@Z proc near
.text$mn:00004A78
.text$mn:00004A78 var_4           = dword ptr -4
.text$mn:00004A78 arg_0           = dword ptr  8
.text$mn:00004A78
.text$mn:00004A78                 push    ebp
.text$mn:00004A79                 mov     ebp, esp
.text$mn:00004A7B                 push    ecx
.text$mn:00004A7C                 mov     [ebp+var_4], ecx
.text$mn:00004A7F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004A82                 call    ??1Shortcut@@UAE@XZ ; Shortcut::~Shortcut(void)
.text$mn:00004A87                 mov     eax, [ebp+arg_0]
.text$mn:00004A8A                 and     eax, 1
.text$mn:00004A8D                 jz      short loc_4A9B
.text$mn:00004A8F                 mov     ecx, [ebp+var_4]
.text$mn:00004A92                 push    ecx             ; void *
.text$mn:00004A93                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004A98                 add     esp, 4
.text$mn:00004A9B
.text$mn:00004A9B loc_4A9B:                               ; CODE XREF: Shortcut::`scalar deleting destructor'(uint)+15j
.text$mn:00004A9B                 mov     eax, [ebp+var_4]
.text$mn:00004A9E                 mov     esp, ebp
.text$mn:00004AA0                 pop     ebp
.text$mn:00004AA1                 retn    4
.text$mn:00004AA1 ??_GShortcut@@UAEPAXI@Z endp
.text$mn:00004AA1
.text$mn:00004AA1 _text$mn        ends
.text$mn:00004AA1
.text$mn:00004AA4 ; ===========================================================================
.text$mn:00004AA4
.text$mn:00004AA4 ; Segment type: Pure code
.text$mn:00004AA4 ; Segment permissions: Read/Execute
.text$mn:00004AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AA4                 assume cs:_text$mn
.text$mn:00004AA4                 ;org 4AA4h
.text$mn:00004AA4 ; COMDAT (pick any)
.text$mn:00004AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AA4
.text$mn:00004AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AA4
.text$mn:00004AA4 ; Attributes: bp-based frame
.text$mn:00004AA4
.text$mn:00004AA4 ; public: virtual void * __thiscall StaticDialog::`scalar deleting destructor'(unsigned int)
.text$mn:00004AA4                 public ??_GStaticDialog@@UAEPAXI@Z
.text$mn:00004AA4 ??_GStaticDialog@@UAEPAXI@Z proc near
.text$mn:00004AA4
.text$mn:00004AA4 var_4           = dword ptr -4
.text$mn:00004AA4 arg_0           = dword ptr  8
.text$mn:00004AA4
.text$mn:00004AA4                 push    ebp
.text$mn:00004AA5                 mov     ebp, esp
.text$mn:00004AA7                 push    ecx
.text$mn:00004AA8                 mov     [ebp+var_4], ecx
.text$mn:00004AAB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004AAE                 call    ??1StaticDialog@@UAE@XZ ; StaticDialog::~StaticDialog(void)
.text$mn:00004AB3                 mov     eax, [ebp+arg_0]
.text$mn:00004AB6                 and     eax, 1
.text$mn:00004AB9                 jz      short loc_4AC7
.text$mn:00004ABB                 mov     ecx, [ebp+var_4]
.text$mn:00004ABE                 push    ecx             ; void *
.text$mn:00004ABF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004AC4                 add     esp, 4
.text$mn:00004AC7
.text$mn:00004AC7 loc_4AC7:                               ; CODE XREF: StaticDialog::`scalar deleting destructor'(uint)+15j
.text$mn:00004AC7                 mov     eax, [ebp+var_4]
.text$mn:00004ACA                 mov     esp, ebp
.text$mn:00004ACC                 pop     ebp
.text$mn:00004ACD                 retn    4
.text$mn:00004ACD ??_GStaticDialog@@UAEPAXI@Z endp
.text$mn:00004ACD
.text$mn:00004ACD _text$mn        ends
.text$mn:00004ACD
.text$mn:00004AD0 ; ===========================================================================
.text$mn:00004AD0
.text$mn:00004AD0 ; Segment type: Pure code
.text$mn:00004AD0 ; Segment permissions: Read/Execute
.text$mn:00004AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00004AD0                 assume cs:_text$mn
.text$mn:00004AD0                 ;org 4AD0h
.text$mn:00004AD0 ; COMDAT (pick any)
.text$mn:00004AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AD0
.text$mn:00004AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AD0
.text$mn:00004AD0 ; Attributes: bp-based frame
.text$mn:00004AD0
.text$mn:00004AD0 ; public: virtual void * __thiscall UserCommand::`scalar deleting destructor'(unsigned int)
.text$mn:00004AD0                 public ??_GUserCommand@@UAEPAXI@Z
.text$mn:00004AD0 ??_GUserCommand@@UAEPAXI@Z proc near
.text$mn:00004AD0
.text$mn:00004AD0 var_4           = dword ptr -4
.text$mn:00004AD0 arg_0           = dword ptr  8
.text$mn:00004AD0
.text$mn:00004AD0                 push    ebp
.text$mn:00004AD1                 mov     ebp, esp
.text$mn:00004AD3                 push    ecx
.text$mn:00004AD4                 mov     [ebp+var_4], ecx
.text$mn:00004AD7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004ADA                 call    ??1UserCommand@@UAE@XZ ; UserCommand::~UserCommand(void)
.text$mn:00004ADF                 mov     eax, [ebp+arg_0]
.text$mn:00004AE2                 and     eax, 1
.text$mn:00004AE5                 jz      short loc_4AF3
.text$mn:00004AE7                 mov     ecx, [ebp+var_4]
.text$mn:00004AEA                 push    ecx             ; void *
.text$mn:00004AEB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004AF0                 add     esp, 4
.text$mn:00004AF3
.text$mn:00004AF3 loc_4AF3:                               ; CODE XREF: UserCommand::`scalar deleting destructor'(uint)+15j
.text$mn:00004AF3                 mov     eax, [ebp+var_4]
.text$mn:00004AF6                 mov     esp, ebp
.text$mn:00004AF8                 pop     ebp
.text$mn:00004AF9                 retn    4
.text$mn:00004AF9 ??_GUserCommand@@UAEPAXI@Z endp
.text$mn:00004AF9
.text$mn:00004AF9 _text$mn        ends
.text$mn:00004AF9
.text$mn:00004AFC ; ===========================================================================
.text$mn:00004AFC
.text$mn:00004AFC ; Segment type: Pure code
.text$mn:00004AFC ; Segment permissions: Read/Execute
.text$mn:00004AFC _text$mn        segment para public 'CODE' use32
.text$mn:00004AFC                 assume cs:_text$mn
.text$mn:00004AFC                 ;org 4AFCh
.text$mn:00004AFC ; COMDAT (pick any)
.text$mn:00004AFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AFC
.text$mn:00004AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00004AFC
.text$mn:00004AFC ; Attributes: bp-based frame
.text$mn:00004AFC
.text$mn:00004AFC ; public: virtual void * __thiscall Window::`scalar deleting destructor'(unsigned int)
.text$mn:00004AFC                 public ??_GWindow@@UAEPAXI@Z
.text$mn:00004AFC ??_GWindow@@UAEPAXI@Z proc near
.text$mn:00004AFC
.text$mn:00004AFC var_4           = dword ptr -4
.text$mn:00004AFC arg_0           = dword ptr  8
.text$mn:00004AFC
.text$mn:00004AFC                 push    ebp
.text$mn:00004AFD                 mov     ebp, esp
.text$mn:00004AFF                 push    ecx
.text$mn:00004B00                 mov     [ebp+var_4], ecx
.text$mn:00004B03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004B06                 call    ??1Window@@UAE@XZ ; Window::~Window(void)
.text$mn:00004B0B                 mov     eax, [ebp+arg_0]
.text$mn:00004B0E                 and     eax, 1
.text$mn:00004B11                 jz      short loc_4B1F
.text$mn:00004B13                 mov     ecx, [ebp+var_4]
.text$mn:00004B16                 push    ecx             ; void *
.text$mn:00004B17                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004B1C                 add     esp, 4
.text$mn:00004B1F
.text$mn:00004B1F loc_4B1F:                               ; CODE XREF: Window::`scalar deleting destructor'(uint)+15j
.text$mn:00004B1F                 mov     eax, [ebp+var_4]
.text$mn:00004B22                 mov     esp, ebp
.text$mn:00004B24                 pop     ebp
.text$mn:00004B25                 retn    4
.text$mn:00004B25 ??_GWindow@@UAEPAXI@Z endp
.text$mn:00004B25
.text$mn:00004B25 _text$mn        ends
.text$mn:00004B25
.text$mn:00004B28 ; ===========================================================================
.text$mn:00004B28
.text$mn:00004B28 ; Segment type: Pure code
.text$mn:00004B28 ; Segment permissions: Read/Execute
.text$mn:00004B28 _text$mn        segment para public 'CODE' use32
.text$mn:00004B28                 assume cs:_text$mn
.text$mn:00004B28                 ;org 4B28h
.text$mn:00004B28 ; COMDAT (pick any)
.text$mn:00004B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B28
.text$mn:00004B28 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B28
.text$mn:00004B28 ; Attributes: bp-based frame
.text$mn:00004B28
.text$mn:00004B28 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004B28                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00004B28 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004B28
.text$mn:00004B28 var_4           = dword ptr -4
.text$mn:00004B28 arg_0           = dword ptr  8
.text$mn:00004B28
.text$mn:00004B28                 push    ebp
.text$mn:00004B29                 mov     ebp, esp
.text$mn:00004B2B                 push    ecx
.text$mn:00004B2C                 mov     [ebp+var_4], ecx
.text$mn:00004B2F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004B32                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00004B37                 mov     eax, [ebp+arg_0]
.text$mn:00004B3A                 and     eax, 1
.text$mn:00004B3D                 jz      short loc_4B4B
.text$mn:00004B3F                 mov     ecx, [ebp+var_4]
.text$mn:00004B42                 push    ecx             ; void *
.text$mn:00004B43                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004B48                 add     esp, 4
.text$mn:00004B4B
.text$mn:00004B4B loc_4B4B:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004B4B                 mov     eax, [ebp+var_4]
.text$mn:00004B4E                 mov     esp, ebp
.text$mn:00004B50                 pop     ebp
.text$mn:00004B51                 retn    4
.text$mn:00004B51 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00004B51
.text$mn:00004B51 _text$mn        ends
.text$mn:00004B51
.text$mn:00004B54 ; ===========================================================================
.text$mn:00004B54
.text$mn:00004B54 ; Segment type: Pure code
.text$mn:00004B54 ; Segment permissions: Read/Execute
.text$mn:00004B54 _text$mn        segment para public 'CODE' use32
.text$mn:00004B54                 assume cs:_text$mn
.text$mn:00004B54                 ;org 4B54h
.text$mn:00004B54 ; COMDAT (pick any)
.text$mn:00004B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B54
.text$mn:00004B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B54
.text$mn:00004B54 ; Attributes: bp-based frame
.text$mn:00004B54
.text$mn:00004B54 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004B54                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00004B54 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004B54
.text$mn:00004B54 var_4           = dword ptr -4
.text$mn:00004B54 arg_0           = dword ptr  8
.text$mn:00004B54
.text$mn:00004B54                 push    ebp
.text$mn:00004B55                 mov     ebp, esp
.text$mn:00004B57                 push    ecx
.text$mn:00004B58                 mov     [ebp+var_4], ecx
.text$mn:00004B5B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004B5E                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00004B63                 mov     eax, [ebp+arg_0]
.text$mn:00004B66                 and     eax, 1
.text$mn:00004B69                 jz      short loc_4B77
.text$mn:00004B6B                 mov     ecx, [ebp+var_4]
.text$mn:00004B6E                 push    ecx             ; void *
.text$mn:00004B6F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004B74                 add     esp, 4
.text$mn:00004B77
.text$mn:00004B77 loc_4B77:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004B77                 mov     eax, [ebp+var_4]
.text$mn:00004B7A                 mov     esp, ebp
.text$mn:00004B7C                 pop     ebp
.text$mn:00004B7D                 retn    4
.text$mn:00004B7D ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00004B7D
.text$mn:00004B7D _text$mn        ends
.text$mn:00004B7D
.text$mn:00004B80 ; ===========================================================================
.text$mn:00004B80
.text$mn:00004B80 ; Segment type: Pure code
.text$mn:00004B80 ; Segment permissions: Read/Execute
.text$mn:00004B80 _text$mn        segment para public 'CODE' use32
.text$mn:00004B80                 assume cs:_text$mn
.text$mn:00004B80                 ;org 4B80h
.text$mn:00004B80 ; COMDAT (pick any)
.text$mn:00004B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B80
.text$mn:00004B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B80
.text$mn:00004B80 ; Attributes: bp-based frame
.text$mn:00004B80
.text$mn:00004B80 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004B80                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00004B80 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00004B80
.text$mn:00004B80 var_4           = dword ptr -4
.text$mn:00004B80 arg_0           = dword ptr  8
.text$mn:00004B80
.text$mn:00004B80                 push    ebp
.text$mn:00004B81                 mov     ebp, esp
.text$mn:00004B83                 push    ecx
.text$mn:00004B84                 mov     [ebp+var_4], ecx
.text$mn:00004B87                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004B8A                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00004B8F                 mov     eax, [ebp+arg_0]
.text$mn:00004B92                 and     eax, 1
.text$mn:00004B95                 jz      short loc_4BA3
.text$mn:00004B97                 mov     ecx, [ebp+var_4]
.text$mn:00004B9A                 push    ecx             ; void *
.text$mn:00004B9B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004BA0                 add     esp, 4
.text$mn:00004BA3
.text$mn:00004BA3 loc_4BA3:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004BA3                 mov     eax, [ebp+var_4]
.text$mn:00004BA6                 mov     esp, ebp
.text$mn:00004BA8                 pop     ebp
.text$mn:00004BA9                 retn    4
.text$mn:00004BA9 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00004BA9
.text$mn:00004BA9 _text$mn        ends
.text$mn:00004BA9
.text$mn:00004BAC ; ===========================================================================
.text$mn:00004BAC
.text$mn:00004BAC ; Segment type: Pure code
.text$mn:00004BAC ; Segment permissions: Read/Execute
.text$mn:00004BAC _text$mn        segment para public 'CODE' use32
.text$mn:00004BAC                 assume cs:_text$mn
.text$mn:00004BAC                 ;org 4BACh
.text$mn:00004BAC ; COMDAT (pick any)
.text$mn:00004BAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BAC
.text$mn:00004BAC ; =============== S U B R O U T I N E =======================================
.text$mn:00004BAC
.text$mn:00004BAC ; Attributes: bp-based frame
.text$mn:00004BAC
.text$mn:00004BAC ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00004BAC                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00004BAC ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00004BAC
.text$mn:00004BAC var_4           = dword ptr -4
.text$mn:00004BAC arg_0           = dword ptr  8
.text$mn:00004BAC
.text$mn:00004BAC                 push    ebp
.text$mn:00004BAD                 mov     ebp, esp
.text$mn:00004BAF                 push    ecx
.text$mn:00004BB0                 mov     [ebp+var_4], ecx
.text$mn:00004BB3                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004BB6                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00004BBB                 mov     eax, [ebp+arg_0]
.text$mn:00004BBE                 and     eax, 1
.text$mn:00004BC1                 jz      short loc_4BCF
.text$mn:00004BC3                 mov     ecx, [ebp+var_4]
.text$mn:00004BC6                 push    ecx             ; void *
.text$mn:00004BC7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004BCC                 add     esp, 4
.text$mn:00004BCF
.text$mn:00004BCF loc_4BCF:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00004BCF                 mov     eax, [ebp+var_4]
.text$mn:00004BD2                 mov     esp, ebp
.text$mn:00004BD4                 pop     ebp
.text$mn:00004BD5                 retn    4
.text$mn:00004BD5 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00004BD5
.text$mn:00004BD5 _text$mn        ends
.text$mn:00004BD5
.text$di:00004BD8 ; ===========================================================================
.text$di:00004BD8
.text$di:00004BD8 ; Segment type: Pure code
.text$di:00004BD8 ; Segment permissions: Read/Execute
.text$di:00004BD8 _text$di        segment para public 'CODE' use32
.text$di:00004BD8                 assume cs:_text$di
.text$di:00004BD8                 ;org 4BD8h
.text$di:00004BD8 ; COMDAT (pick any)
.text$di:00004BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004BD8
.text$di:00004BD8 ; =============== S U B R O U T I N E =======================================
.text$di:00004BD8
.text$di:00004BD8 ; Attributes: bp-based frame
.text$di:00004BD8
.text$di:00004BD8 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00004BD8 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00004BD8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00004BD8                 push    ebp
.text$di:00004BD9                 mov     ebp, esp
.text$di:00004BDB                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00004BE0                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00004BE5                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00004BEA                 call    _atexit
.text$di:00004BEF                 add     esp, 4
.text$di:00004BF2                 pop     ebp
.text$di:00004BF3                 retn
.text$di:00004BF3 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00004BF3
.text$di:00004BF3 _text$di        ends
.text$di:00004BF3
.text$di:00004BF4 ; ===========================================================================
.text$di:00004BF4
.text$di:00004BF4 ; Segment type: Pure code
.text$di:00004BF4 ; Segment permissions: Read/Execute
.text$di:00004BF4 _text$di        segment para public 'CODE' use32
.text$di:00004BF4                 assume cs:_text$di
.text$di:00004BF4                 ;org 4BF4h
.text$di:00004BF4 ; COMDAT (pick any)
.text$di:00004BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004BF4
.text$di:00004BF4 ; =============== S U B R O U T I N E =======================================
.text$di:00004BF4
.text$di:00004BF4 ; Attributes: bp-based frame
.text$di:00004BF4
.text$di:00004BF4 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00004BF4 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00004BF4                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00004BF4                 push    ebp
.text$di:00004BF5                 mov     ebp, esp
.text$di:00004BF7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00004BFC                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00004C01                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00004C06                 call    _atexit
.text$di:00004C0B                 add     esp, 4
.text$di:00004C0E                 pop     ebp
.text$di:00004C0F                 retn
.text$di:00004C0F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00004C0F
.text$di:00004C0F _text$di        ends
.text$di:00004C0F
.text$di:00004C10 ; ===========================================================================
.text$di:00004C10
.text$di:00004C10 ; Segment type: Pure code
.text$di:00004C10 ; Segment permissions: Read/Execute
.text$di:00004C10 _text$di        segment para public 'CODE' use32
.text$di:00004C10                 assume cs:_text$di
.text$di:00004C10                 ;org 4C10h
.text$di:00004C10 ; COMDAT (pick any)
.text$di:00004C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C10
.text$di:00004C10 ; =============== S U B R O U T I N E =======================================
.text$di:00004C10
.text$di:00004C10 ; Attributes: bp-based frame
.text$di:00004C10
.text$di:00004C10 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00004C10 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00004C10                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00004C10                 push    ebp
.text$di:00004C11                 mov     ebp, esp
.text$di:00004C13                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00004C18                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00004C1D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00004C22                 call    _atexit
.text$di:00004C27                 add     esp, 4
.text$di:00004C2A                 pop     ebp
.text$di:00004C2B                 retn
.text$di:00004C2B ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00004C2B
.text$di:00004C2B _text$di        ends
.text$di:00004C2B
.text$di:00004C2C ; ===========================================================================
.text$di:00004C2C
.text$di:00004C2C ; Segment type: Pure code
.text$di:00004C2C ; Segment permissions: Read/Execute
.text$di:00004C2C _text$di        segment para public 'CODE' use32
.text$di:00004C2C                 assume cs:_text$di
.text$di:00004C2C                 ;org 4C2Ch
.text$di:00004C2C ; COMDAT (pick any)
.text$di:00004C2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C2C
.text$di:00004C2C ; =============== S U B R O U T I N E =======================================
.text$di:00004C2C
.text$di:00004C2C ; Attributes: bp-based frame
.text$di:00004C2C
.text$di:00004C2C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00004C2C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004C2C                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00004C2C                 push    ebp
.text$di:00004C2D                 mov     ebp, esp
.text$di:00004C2F                 push    0               ; unsigned int
.text$di:00004C31                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00004C36                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00004C3B                 pop     ebp
.text$di:00004C3C                 retn
.text$di:00004C3C ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004C3C
.text$di:00004C3C ; ---------------------------------------------------------------------------
.text$di:00004C3D                 align 10h
.text$di:00004C3D _text$di        ends
.text$di:00004C3D
.text$di:00004C40 ; ===========================================================================
.text$di:00004C40
.text$di:00004C40 ; Segment type: Pure code
.text$di:00004C40 ; Segment permissions: Read/Execute
.text$di:00004C40 _text$di        segment para public 'CODE' use32
.text$di:00004C40                 assume cs:_text$di
.text$di:00004C40                 ;org 4C40h
.text$di:00004C40 ; COMDAT (pick any)
.text$di:00004C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C40
.text$di:00004C40 ; =============== S U B R O U T I N E =======================================
.text$di:00004C40
.text$di:00004C40 ; Attributes: bp-based frame
.text$di:00004C40
.text$di:00004C40 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00004C40 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004C40                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00004C40                 push    ebp
.text$di:00004C41                 mov     ebp, esp
.text$di:00004C43                 push    0               ; unsigned int
.text$di:00004C45                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00004C4A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00004C4F                 pop     ebp
.text$di:00004C50                 retn
.text$di:00004C50 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004C50
.text$di:00004C50 ; ---------------------------------------------------------------------------
.text$di:00004C51                 align 4
.text$di:00004C51 _text$di        ends
.text$di:00004C51
.text$di:00004C54 ; ===========================================================================
.text$di:00004C54
.text$di:00004C54 ; Segment type: Pure code
.text$di:00004C54 ; Segment permissions: Read/Execute
.text$di:00004C54 _text$di        segment para public 'CODE' use32
.text$di:00004C54                 assume cs:_text$di
.text$di:00004C54                 ;org 4C54h
.text$di:00004C54 ; COMDAT (pick any)
.text$di:00004C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C54
.text$di:00004C54 ; =============== S U B R O U T I N E =======================================
.text$di:00004C54
.text$di:00004C54 ; Attributes: bp-based frame
.text$di:00004C54
.text$di:00004C54 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00004C54 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004C54                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00004C54                 push    ebp
.text$di:00004C55                 mov     ebp, esp
.text$di:00004C57                 push    0               ; unsigned int
.text$di:00004C59                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00004C5E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00004C63                 pop     ebp
.text$di:00004C64                 retn
.text$di:00004C64 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004C64
.text$di:00004C64 ; ---------------------------------------------------------------------------
.text$di:00004C65                 align 4
.text$di:00004C65 _text$di        ends
.text$di:00004C65
.text$di:00004C68 ; ===========================================================================
.text$di:00004C68
.text$di:00004C68 ; Segment type: Pure code
.text$di:00004C68 ; Segment permissions: Read/Execute
.text$di:00004C68 _text$di        segment para public 'CODE' use32
.text$di:00004C68                 assume cs:_text$di
.text$di:00004C68                 ;org 4C68h
.text$di:00004C68 ; COMDAT (pick any)
.text$di:00004C68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C68
.text$di:00004C68 ; =============== S U B R O U T I N E =======================================
.text$di:00004C68
.text$di:00004C68 ; Attributes: bp-based frame
.text$di:00004C68
.text$di:00004C68 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00004C68 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00004C68                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00004C68                 push    ebp
.text$di:00004C69                 mov     ebp, esp
.text$di:00004C6B                 push    0               ; unsigned int
.text$di:00004C6D                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00004C72                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00004C77                 pop     ebp
.text$di:00004C78                 retn
.text$di:00004C78 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00004C78
.text$di:00004C78 ; ---------------------------------------------------------------------------
.text$di:00004C79                 align 4
.text$di:00004C79 _text$di        ends
.text$di:00004C79
.text$di:00004C7C ; ===========================================================================
.text$di:00004C7C
.text$di:00004C7C ; Segment type: Pure code
.text$di:00004C7C ; Segment permissions: Read/Execute
.text$di:00004C7C _text$di        segment para public 'CODE' use32
.text$di:00004C7C                 assume cs:_text$di
.text$di:00004C7C                 ;org 4C7Ch
.text$di:00004C7C ; COMDAT (pick any)
.text$di:00004C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C7C
.text$di:00004C7C ; =============== S U B R O U T I N E =======================================
.text$di:00004C7C
.text$di:00004C7C ; Attributes: bp-based frame
.text$di:00004C7C
.text$di:00004C7C ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00004C7C ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00004C7C
.text$di:00004C7C var_1           = byte ptr -1
.text$di:00004C7C
.text$di:00004C7C                 push    ebp
.text$di:00004C7D                 mov     ebp, esp
.text$di:00004C7F                 push    ecx
.text$di:00004C80                 xor     eax, eax
.text$di:00004C82                 mov     [ebp+var_1], al
.text$di:00004C85                 mov     esp, ebp
.text$di:00004C87                 pop     ebp
.text$di:00004C88                 retn
.text$di:00004C88 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00004C88
.text$di:00004C88 ; ---------------------------------------------------------------------------
.text$di:00004C89                 align 4
.text$di:00004C89 _text$di        ends
.text$di:00004C89
.text$di:00004C8C ; ===========================================================================
.text$di:00004C8C
.text$di:00004C8C ; Segment type: Pure code
.text$di:00004C8C ; Segment permissions: Read/Execute
.text$di:00004C8C _text$di        segment para public 'CODE' use32
.text$di:00004C8C                 assume cs:_text$di
.text$di:00004C8C                 ;org 4C8Ch
.text$di:00004C8C ; COMDAT (pick any)
.text$di:00004C8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C8C
.text$di:00004C8C ; =============== S U B R O U T I N E =======================================
.text$di:00004C8C
.text$di:00004C8C ; Attributes: bp-based frame
.text$di:00004C8C
.text$di:00004C8C ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00004C8C ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00004C8C
.text$di:00004C8C var_1           = byte ptr -1
.text$di:00004C8C
.text$di:00004C8C                 push    ebp
.text$di:00004C8D                 mov     ebp, esp
.text$di:00004C8F                 push    ecx
.text$di:00004C90                 xor     eax, eax
.text$di:00004C92                 mov     [ebp+var_1], al
.text$di:00004C95                 mov     esp, ebp
.text$di:00004C97                 pop     ebp
.text$di:00004C98                 retn
.text$di:00004C98 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00004C98
.text$di:00004C98 ; ---------------------------------------------------------------------------
.text$di:00004C99                 align 4
.text$di:00004C99 _text$di        ends
.text$di:00004C99
.text$di:00004C9C ; ===========================================================================
.text$di:00004C9C
.text$di:00004C9C ; Segment type: Pure code
.text$di:00004C9C ; Segment permissions: Read/Execute
.text$di:00004C9C _text$di        segment para public 'CODE' use32
.text$di:00004C9C                 assume cs:_text$di
.text$di:00004C9C                 ;org 4C9Ch
.text$di:00004C9C ; COMDAT (pick any)
.text$di:00004C9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004C9C
.text$di:00004C9C ; =============== S U B R O U T I N E =======================================
.text$di:00004C9C
.text$di:00004C9C ; Attributes: bp-based frame
.text$di:00004C9C
.text$di:00004C9C ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00004C9C ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00004C9C                 push    ebp
.text$di:00004C9D                 mov     ebp, esp
.text$di:00004C9F                 mov     ecx, offset _ignore ; this
.text$di:00004CA4                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00004CA9                 pop     ebp
.text$di:00004CAA                 retn
.text$di:00004CAA ??__Eignore@std@@YAXXZ endp
.text$di:00004CAA
.text$di:00004CAA ; ---------------------------------------------------------------------------
.text$di:00004CAB                 align 4
.text$di:00004CAB _text$di        ends
.text$di:00004CAB
.text$di:00004CAC ; ===========================================================================
.text$di:00004CAC
.text$di:00004CAC ; Segment type: Pure code
.text$di:00004CAC ; Segment permissions: Read/Execute
.text$di:00004CAC _text$di        segment para public 'CODE' use32
.text$di:00004CAC                 assume cs:_text$di
.text$di:00004CAC                 ;org 4CACh
.text$di:00004CAC ; COMDAT (pick any)
.text$di:00004CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00004CAC
.text$di:00004CAC ; =============== S U B R O U T I N E =======================================
.text$di:00004CAC
.text$di:00004CAC ; Attributes: bp-based frame
.text$di:00004CAC
.text$di:00004CAC ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00004CAC ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00004CAC                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00004CAC
.text$di:00004CAC var_1           = byte ptr -1
.text$di:00004CAC
.text$di:00004CAC                 push    ebp
.text$di:00004CAD                 mov     ebp, esp
.text$di:00004CAF                 push    ecx
.text$di:00004CB0                 xor     eax, eax
.text$di:00004CB2                 mov     [ebp+var_1], al
.text$di:00004CB5                 mov     esp, ebp
.text$di:00004CB7                 pop     ebp
.text$di:00004CB8                 retn
.text$di:00004CB8 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00004CB8
.text$di:00004CB8 ; ---------------------------------------------------------------------------
.text$di:00004CB9                 align 4
.text$di:00004CB9 _text$di        ends
.text$di:00004CB9
.text$yd:00004CBC ; ===========================================================================
.text$yd:00004CBC
.text$yd:00004CBC ; Segment type: Pure code
.text$yd:00004CBC ; Segment permissions: Read/Execute
.text$yd:00004CBC _text$yd        segment para public 'CODE' use32
.text$yd:00004CBC                 assume cs:_text$yd
.text$yd:00004CBC                 ;org 4CBCh
.text$yd:00004CBC ; COMDAT (pick any)
.text$yd:00004CBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004CBC
.text$yd:00004CBC ; =============== S U B R O U T I N E =======================================
.text$yd:00004CBC
.text$yd:00004CBC ; Attributes: bp-based frame
.text$yd:00004CBC
.text$yd:00004CBC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00004CBC ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00004CBC                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00004CBC                 push    ebp
.text$yd:00004CBD                 mov     ebp, esp
.text$yd:00004CBF                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00004CC4                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00004CC9                 pop     ebp
.text$yd:00004CCA                 retn
.text$yd:00004CCA ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00004CCA
.text$yd:00004CCA ; ---------------------------------------------------------------------------
.text$yd:00004CCB                 align 4
.text$yd:00004CCB _text$yd        ends
.text$yd:00004CCB
.text$yd:00004CCC ; ===========================================================================
.text$yd:00004CCC
.text$yd:00004CCC ; Segment type: Pure code
.text$yd:00004CCC ; Segment permissions: Read/Execute
.text$yd:00004CCC _text$yd        segment para public 'CODE' use32
.text$yd:00004CCC                 assume cs:_text$yd
.text$yd:00004CCC                 ;org 4CCCh
.text$yd:00004CCC ; COMDAT (pick any)
.text$yd:00004CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004CCC
.text$yd:00004CCC ; =============== S U B R O U T I N E =======================================
.text$yd:00004CCC
.text$yd:00004CCC ; Attributes: bp-based frame
.text$yd:00004CCC
.text$yd:00004CCC ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00004CCC ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00004CCC                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00004CCC                 push    ebp
.text$yd:00004CCD                 mov     ebp, esp
.text$yd:00004CCF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00004CD4                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00004CD9                 pop     ebp
.text$yd:00004CDA                 retn
.text$yd:00004CDA ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00004CDA
.text$yd:00004CDA ; ---------------------------------------------------------------------------
.text$yd:00004CDB                 align 4
.text$yd:00004CDB _text$yd        ends
.text$yd:00004CDB
.text$yd:00004CDC ; ===========================================================================
.text$yd:00004CDC
.text$yd:00004CDC ; Segment type: Pure code
.text$yd:00004CDC ; Segment permissions: Read/Execute
.text$yd:00004CDC _text$yd        segment para public 'CODE' use32
.text$yd:00004CDC                 assume cs:_text$yd
.text$yd:00004CDC                 ;org 4CDCh
.text$yd:00004CDC ; COMDAT (pick any)
.text$yd:00004CDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00004CDC
.text$yd:00004CDC ; =============== S U B R O U T I N E =======================================
.text$yd:00004CDC
.text$yd:00004CDC ; Attributes: bp-based frame
.text$yd:00004CDC
.text$yd:00004CDC ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00004CDC ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00004CDC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00004CDC                 push    ebp
.text$yd:00004CDD                 mov     ebp, esp
.text$yd:00004CDF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00004CE4                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00004CE9                 pop     ebp
.text$yd:00004CEA                 retn
.text$yd:00004CEA ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00004CEA
.text$yd:00004CEA ; ---------------------------------------------------------------------------
.text$yd:00004CEB                 align 4
.text$yd:00004CEB _text$yd        ends
.text$yd:00004CEB
.text$mn:00004CEC ; ===========================================================================
.text$mn:00004CEC
.text$mn:00004CEC ; Segment type: Pure code
.text$mn:00004CEC ; Segment permissions: Read/Execute
.text$mn:00004CEC _text$mn        segment para public 'CODE' use32
.text$mn:00004CEC                 assume cs:_text$mn
.text$mn:00004CEC                 ;org 4CECh
.text$mn:00004CEC ; COMDAT (pick any)
.text$mn:00004CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004CEC
.text$mn:00004CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00004CEC
.text$mn:00004CEC ; Attributes: bp-based frame
.text$mn:00004CEC
.text$mn:00004CEC ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00004CEC                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00004CEC ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00004CEC                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t const *,std::_Container_base12 const *)+3Cp
.text$mn:00004CEC                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:00004CEC
.text$mn:00004CEC var_1C          = byte ptr -1Ch
.text$mn:00004CEC var_18          = byte ptr -18h
.text$mn:00004CEC var_14          = dword ptr -14h
.text$mn:00004CEC var_10          = dword ptr -10h
.text$mn:00004CEC var_C           = dword ptr -0Ch
.text$mn:00004CEC var_4           = dword ptr -4
.text$mn:00004CEC arg_0           = dword ptr  8
.text$mn:00004CEC
.text$mn:00004CEC                 push    ebp
.text$mn:00004CED                 mov     ebp, esp
.text$mn:00004CEF                 push    0FFFFFFFFh
.text$mn:00004CF1                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00004CF6                 mov     eax, large fs:0
.text$mn:00004CFC                 push    eax
.text$mn:00004CFD                 sub     esp, 10h
.text$mn:00004D00                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D05                 xor     eax, ebp
.text$mn:00004D07                 push    eax
.text$mn:00004D08                 lea     eax, [ebp+var_C]
.text$mn:00004D0B                 mov     large fs:0, eax
.text$mn:00004D11                 mov     [ebp+var_10], ecx
.text$mn:00004D14                 cmp     [ebp+arg_0], 0
.text$mn:00004D18                 jnz     short loc_4D44
.text$mn:00004D1A                 push    3               ; int
.text$mn:00004D1C                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004D1F                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004D24                 mov     [ebp+var_4], 0
.text$mn:00004D2B                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004D2E                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00004D33                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D3A                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004D3D                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004D42                 jmp     short loc_4D9B
.text$mn:00004D44 ; ---------------------------------------------------------------------------
.text$mn:00004D44
.text$mn:00004D44 loc_4D44:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00004D44                 mov     eax, [ebp+arg_0]
.text$mn:00004D47                 mov     ecx, [eax]
.text$mn:00004D49                 mov     [ebp+var_14], ecx
.text$mn:00004D4C                 mov     edx, [ebp+var_10]
.text$mn:00004D4F                 mov     eax, [edx]
.text$mn:00004D51                 cmp     eax, [ebp+var_14]
.text$mn:00004D54                 jz      short loc_4D9B
.text$mn:00004D56                 push    3               ; int
.text$mn:00004D58                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00004D5B                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004D60                 mov     [ebp+var_4], 1
.text$mn:00004D67                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004D6A                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00004D6F                 mov     ecx, [ebp+var_10]
.text$mn:00004D72                 mov     edx, [ebp+var_14]
.text$mn:00004D75                 mov     eax, [edx+4]
.text$mn:00004D78                 mov     [ecx+4], eax
.text$mn:00004D7B                 mov     ecx, [ebp+var_14]
.text$mn:00004D7E                 mov     edx, [ebp+var_10]
.text$mn:00004D81                 mov     [ecx+4], edx
.text$mn:00004D84                 mov     eax, [ebp+var_10]
.text$mn:00004D87                 mov     ecx, [ebp+var_14]
.text$mn:00004D8A                 mov     [eax], ecx
.text$mn:00004D8C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D93                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00004D96                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004D9B
.text$mn:00004D9B loc_4D9B:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00004D9B                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00004D9B                 mov     ecx, [ebp+var_C]
.text$mn:00004D9E                 mov     large fs:0, ecx
.text$mn:00004DA5                 pop     ecx
.text$mn:00004DA6                 mov     esp, ebp
.text$mn:00004DA8                 pop     ebp
.text$mn:00004DA9                 retn    4
.text$mn:00004DA9 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00004DA9
.text$mn:00004DA9 _text$mn        ends
.text$mn:00004DA9
.text$x:00004DAC ; ===========================================================================
.text$x:00004DAC
.text$x:00004DAC ; Segment type: Pure code
.text$x:00004DAC ; Segment permissions: Read/Execute
.text$x:00004DAC _text$x         segment para public 'CODE' use32
.text$x:00004DAC                 assume cs:_text$x
.text$x:00004DAC                 ;org 4DACh
.text$x:00004DAC ; COMDAT (pick associative to section at 4CEC)
.text$x:00004DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004DAC
.text$x:00004DAC ; =============== S U B R O U T I N E =======================================
.text$x:00004DAC
.text$x:00004DAC
.text$x:00004DAC __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00004DAC                                         ; DATA XREF: .xdata$x:000080D8o
.text$x:00004DAC                 lea     ecx, [ebp-18h]  ; this
.text$x:00004DAF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004DAF __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00004DAF
.text$x:00004DB4
.text$x:00004DB4 ; =============== S U B R O U T I N E =======================================
.text$x:00004DB4
.text$x:00004DB4
.text$x:00004DB4 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00004DB4                                         ; DATA XREF: .xdata$x:000080E0o
.text$x:00004DB4                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00004DB7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00004DB7 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00004DB7
.text$x:00004DBC
.text$x:00004DBC ; =============== S U B R O U T I N E =======================================
.text$x:00004DBC
.text$x:00004DBC
.text$x:00004DBC __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00004DBC                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00004DBC
.text$x:00004DBC arg_4           = dword ptr  8
.text$x:00004DBC
.text$x:00004DBC                 mov     edx, [esp+arg_4]
.text$x:00004DC0                 lea     eax, [edx+0Ch]
.text$x:00004DC3                 mov     ecx, [edx-14h]
.text$x:00004DC6                 xor     ecx, eax
.text$x:00004DC8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004DCD                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00004DD2                 jmp     ___CxxFrameHandler3
.text$x:00004DD2 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00004DD2
.text$x:00004DD2 ; ---------------------------------------------------------------------------
.text$x:00004DD7                 align 4
.text$x:00004DD7 _text$x         ends
.text$x:00004DD7
.text$mn:00004DD8 ; ===========================================================================
.text$mn:00004DD8
.text$mn:00004DD8 ; Segment type: Pure code
.text$mn:00004DD8 ; Segment permissions: Read/Execute
.text$mn:00004DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00004DD8                 assume cs:_text$mn
.text$mn:00004DD8                 ;org 4DD8h
.text$mn:00004DD8 ; COMDAT (pick any)
.text$mn:00004DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DD8
.text$mn:00004DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DD8
.text$mn:00004DD8 ; Attributes: bp-based frame
.text$mn:00004DD8
.text$mn:00004DD8 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00004DD8                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00004DD8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004DD8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00004DD8
.text$mn:00004DD8 var_10          = byte ptr -10h
.text$mn:00004DD8 var_8           = dword ptr -8
.text$mn:00004DD8 var_1           = byte ptr -1
.text$mn:00004DD8
.text$mn:00004DD8                 push    ebp
.text$mn:00004DD9                 mov     ebp, esp
.text$mn:00004DDB                 sub     esp, 10h
.text$mn:00004DDE                 mov     [ebp+var_8], ecx
.text$mn:00004DE1                 lea     ecx, [ebp+var_1]
.text$mn:00004DE4                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004DE9                 push    1
.text$mn:00004DEB                 lea     ecx, [ebp+var_1]
.text$mn:00004DEE                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00004DF3                 mov     ecx, [ebp+var_8]
.text$mn:00004DF6                 mov     [ecx], eax
.text$mn:00004DF8                 lea     ecx, [ebp+var_10] ; this
.text$mn:00004DFB                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00004E00                 push    eax             ; int
.text$mn:00004E01                 mov     edx, [ebp+var_8]
.text$mn:00004E04                 mov     eax, [edx]
.text$mn:00004E06                 push    eax             ; void *
.text$mn:00004E07                 lea     ecx, [ebp+var_1]
.text$mn:00004E0A                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004E0F                 mov     ecx, [ebp+var_8]
.text$mn:00004E12                 mov     edx, [ecx]
.text$mn:00004E14                 mov     eax, [ebp+var_8]
.text$mn:00004E17                 mov     [edx], eax
.text$mn:00004E19                 mov     esp, ebp
.text$mn:00004E1B                 pop     ebp
.text$mn:00004E1C                 retn
.text$mn:00004E1C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004E1C
.text$mn:00004E1C ; ---------------------------------------------------------------------------
.text$mn:00004E1D                 align 10h
.text$mn:00004E1D _text$mn        ends
.text$mn:00004E1D
.text$mn:00004E20 ; ===========================================================================
.text$mn:00004E20
.text$mn:00004E20 ; Segment type: Pure code
.text$mn:00004E20 ; Segment permissions: Read/Execute
.text$mn:00004E20 _text$mn        segment para public 'CODE' use32
.text$mn:00004E20                 assume cs:_text$mn
.text$mn:00004E20                 ;org 4E20h
.text$mn:00004E20 ; COMDAT (pick any)
.text$mn:00004E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E20
.text$mn:00004E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E20
.text$mn:00004E20 ; Attributes: bp-based frame
.text$mn:00004E20
.text$mn:00004E20 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00004E20                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00004E20 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004E20                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00004E20
.text$mn:00004E20 var_10          = byte ptr -10h
.text$mn:00004E20 var_8           = dword ptr -8
.text$mn:00004E20 var_1           = byte ptr -1
.text$mn:00004E20
.text$mn:00004E20                 push    ebp
.text$mn:00004E21                 mov     ebp, esp
.text$mn:00004E23                 sub     esp, 10h
.text$mn:00004E26                 mov     [ebp+var_8], ecx
.text$mn:00004E29                 lea     ecx, [ebp+var_1]
.text$mn:00004E2C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004E31                 push    1
.text$mn:00004E33                 lea     ecx, [ebp+var_1]
.text$mn:00004E36                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00004E3B                 mov     ecx, [ebp+var_8]
.text$mn:00004E3E                 mov     [ecx], eax
.text$mn:00004E40                 lea     ecx, [ebp+var_10] ; this
.text$mn:00004E43                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00004E48                 push    eax             ; int
.text$mn:00004E49                 mov     edx, [ebp+var_8]
.text$mn:00004E4C                 mov     eax, [edx]
.text$mn:00004E4E                 push    eax             ; void *
.text$mn:00004E4F                 lea     ecx, [ebp+var_1]
.text$mn:00004E52                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00004E57                 mov     ecx, [ebp+var_8]
.text$mn:00004E5A                 mov     edx, [ecx]
.text$mn:00004E5C                 mov     eax, [ebp+var_8]
.text$mn:00004E5F                 mov     [edx], eax
.text$mn:00004E61                 mov     esp, ebp
.text$mn:00004E63                 pop     ebp
.text$mn:00004E64                 retn
.text$mn:00004E64 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004E64
.text$mn:00004E64 ; ---------------------------------------------------------------------------
.text$mn:00004E65                 align 4
.text$mn:00004E65 _text$mn        ends
.text$mn:00004E65
.text$mn:00004E68 ; ===========================================================================
.text$mn:00004E68
.text$mn:00004E68 ; Segment type: Pure code
.text$mn:00004E68 ; Segment permissions: Read/Execute
.text$mn:00004E68 _text$mn        segment para public 'CODE' use32
.text$mn:00004E68                 assume cs:_text$mn
.text$mn:00004E68                 ;org 4E68h
.text$mn:00004E68 ; COMDAT (pick any)
.text$mn:00004E68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E68
.text$mn:00004E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E68
.text$mn:00004E68 ; Attributes: bp-based frame
.text$mn:00004E68
.text$mn:00004E68 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Assign_rv(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> &&)
.text$mn:00004E68                 public ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z
.text$mn:00004E68 ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z proc near
.text$mn:00004E68                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+60p
.text$mn:00004E68                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+E2p
.text$mn:00004E68
.text$mn:00004E68 var_8           = dword ptr -8
.text$mn:00004E68 var_1           = byte ptr -1
.text$mn:00004E68 arg_0           = dword ptr  8
.text$mn:00004E68
.text$mn:00004E68                 push    ebp
.text$mn:00004E69                 mov     ebp, esp
.text$mn:00004E6B                 sub     esp, 8
.text$mn:00004E6E                 mov     [ebp+var_8], ecx
.text$mn:00004E71                 mov     eax, [ebp+arg_0]
.text$mn:00004E74                 cmp     dword ptr [eax+18h], 8
.text$mn:00004E78                 jnb     short loc_4E9C
.text$mn:00004E7A                 mov     ecx, [ebp+arg_0]
.text$mn:00004E7D                 mov     edx, [ecx+14h]
.text$mn:00004E80                 add     edx, 1
.text$mn:00004E83                 push    edx             ; int
.text$mn:00004E84                 mov     eax, [ebp+arg_0]
.text$mn:00004E87                 add     eax, 4
.text$mn:00004E8A                 push    eax             ; Src
.text$mn:00004E8B                 mov     ecx, [ebp+var_8]
.text$mn:00004E8E                 add     ecx, 4
.text$mn:00004E91                 push    ecx             ; Dst
.text$mn:00004E92                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00004E97                 add     esp, 0Ch
.text$mn:00004E9A                 jmp     short loc_4EC7
.text$mn:00004E9C ; ---------------------------------------------------------------------------
.text$mn:00004E9C
.text$mn:00004E9C loc_4E9C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+10j
.text$mn:00004E9C                 mov     edx, [ebp+arg_0]
.text$mn:00004E9F                 add     edx, 4
.text$mn:00004EA2                 push    edx             ; int
.text$mn:00004EA3                 mov     eax, [ebp+var_8]
.text$mn:00004EA6                 add     eax, 4
.text$mn:00004EA9                 push    eax             ; void *
.text$mn:00004EAA                 lea     ecx, [ebp+var_1]
.text$mn:00004EAD                 push    ecx
.text$mn:00004EAE                 mov     ecx, [ebp+var_8]
.text$mn:00004EB1                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00004EB6                 mov     ecx, eax
.text$mn:00004EB8                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00004EBD                 mov     edx, [ebp+arg_0]
.text$mn:00004EC0                 mov     dword ptr [edx+4], 0
.text$mn:00004EC7
.text$mn:00004EC7 loc_4EC7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+32j
.text$mn:00004EC7                 mov     eax, [ebp+var_8]
.text$mn:00004ECA                 mov     ecx, [ebp+arg_0]
.text$mn:00004ECD                 mov     edx, [ecx+14h]
.text$mn:00004ED0                 mov     [eax+14h], edx
.text$mn:00004ED3                 mov     eax, [ebp+var_8]
.text$mn:00004ED6                 mov     ecx, [ebp+arg_0]
.text$mn:00004ED9                 mov     edx, [ecx+18h]
.text$mn:00004EDC                 mov     [eax+18h], edx
.text$mn:00004EDF                 push    0
.text$mn:00004EE1                 push    0
.text$mn:00004EE3                 mov     ecx, [ebp+arg_0]
.text$mn:00004EE6                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00004EEB                 mov     esp, ebp
.text$mn:00004EED                 pop     ebp
.text$mn:00004EEE                 retn    4
.text$mn:00004EEE ?_Assign_rv@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX$$QAV12@@Z endp
.text$mn:00004EEE
.text$mn:00004EEE ; ---------------------------------------------------------------------------
.text$mn:00004EF1                 align 4
.text$mn:00004EF1 _text$mn        ends
.text$mn:00004EF1
.text$mn:00004EF4 ; ===========================================================================
.text$mn:00004EF4
.text$mn:00004EF4 ; Segment type: Pure code
.text$mn:00004EF4 ; Segment permissions: Read/Execute
.text$mn:00004EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EF4                 assume cs:_text$mn
.text$mn:00004EF4                 ;org 4EF4h
.text$mn:00004EF4 ; COMDAT (pick any)
.text$mn:00004EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EF4
.text$mn:00004EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EF4
.text$mn:00004EF4 ; Attributes: bp-based frame
.text$mn:00004EF4
.text$mn:00004EF4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<wchar_t>> const &)
.text$mn:00004EF4                 public ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z
.text$mn:00004EF4 ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z proc near
.text$mn:00004EF4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+54p
.text$mn:00004EF4
.text$mn:00004EF4 var_4           = dword ptr -4
.text$mn:00004EF4
.text$mn:00004EF4                 push    ebp
.text$mn:00004EF5                 mov     ebp, esp
.text$mn:00004EF7                 push    ecx
.text$mn:00004EF8                 mov     [ebp+var_4], ecx
.text$mn:00004EFB                 mov     esp, ebp
.text$mn:00004EFD                 pop     ebp
.text$mn:00004EFE                 retn    4
.text$mn:00004EFE ?_Change_alloc@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@_W@std@@@2@@Z endp
.text$mn:00004EFE
.text$mn:00004EFE ; ---------------------------------------------------------------------------
.text$mn:00004F01                 align 4
.text$mn:00004F01 _text$mn        ends
.text$mn:00004F01
.text$mn:00004F04 ; ===========================================================================
.text$mn:00004F04
.text$mn:00004F04 ; Segment type: Pure code
.text$mn:00004F04 ; Segment permissions: Read/Execute
.text$mn:00004F04 _text$mn        segment para public 'CODE' use32
.text$mn:00004F04                 assume cs:_text$mn
.text$mn:00004F04                 ;org 4F04h
.text$mn:00004F04 ; COMDAT (pick any)
.text$mn:00004F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F04
.text$mn:00004F04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F04
.text$mn:00004F04 ; Attributes: bp-based frame
.text$mn:00004F04
.text$mn:00004F04 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00004F04                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00004F04 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00004F04                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+80p
.text$mn:00004F04
.text$mn:00004F04 var_4           = dword ptr -4
.text$mn:00004F04
.text$mn:00004F04                 push    ebp
.text$mn:00004F05                 mov     ebp, esp
.text$mn:00004F07                 push    ecx
.text$mn:00004F08                 mov     [ebp+var_4], ecx
.text$mn:00004F0B                 mov     eax, [ebp+var_4]
.text$mn:00004F0E                 mov     dword ptr [eax], 0
.text$mn:00004F14                 mov     esp, ebp
.text$mn:00004F16                 pop     ebp
.text$mn:00004F17                 retn
.text$mn:00004F17 ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00004F17
.text$mn:00004F17 _text$mn        ends
.text$mn:00004F17
.text$mn:00004F18 ; ===========================================================================
.text$mn:00004F18
.text$mn:00004F18 ; Segment type: Pure code
.text$mn:00004F18 ; Segment permissions: Read/Execute
.text$mn:00004F18 _text$mn        segment para public 'CODE' use32
.text$mn:00004F18                 assume cs:_text$mn
.text$mn:00004F18                 ;org 4F18h
.text$mn:00004F18 ; COMDAT (pick any)
.text$mn:00004F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F18
.text$mn:00004F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F18
.text$mn:00004F18 ; Attributes: bp-based frame
.text$mn:00004F18
.text$mn:00004F18 ; int __stdcall std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_Iterator_base12 *)
.text$mn:00004F18                 public ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:00004F18 ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:00004F18                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+10p
.text$mn:00004F18                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+Ep
.text$mn:00004F18
.text$mn:00004F18 var_4           = dword ptr -4
.text$mn:00004F18 arg_0           = dword ptr  8
.text$mn:00004F18
.text$mn:00004F18                 push    ebp
.text$mn:00004F19                 mov     ebp, esp
.text$mn:00004F1B                 push    ecx
.text$mn:00004F1C                 push    esi
.text$mn:00004F1D                 mov     [ebp+var_4], ecx
.text$mn:00004F20                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004F23                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004F28                 test    eax, eax
.text$mn:00004F2A                 jz      short loc_4F42
.text$mn:00004F2C                 mov     ecx, [ebp+var_4] ; this
.text$mn:00004F2F                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004F34                 mov     esi, eax
.text$mn:00004F36                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004F39                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00004F3E                 cmp     esi, eax
.text$mn:00004F40                 jz      short loc_4FAA
.text$mn:00004F42
.text$mn:00004F42 loc_4F42:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+12j
.text$mn:00004F42                 push    0FAh ; '·'      ; unsigned int
.text$mn:00004F47                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004F4C                 push    offset ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "string iterators incompatible"
.text$mn:00004F51                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00004F56                 add     esp, 0Ch
.text$mn:00004F59                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:00004F5E                 test    eax, eax
.text$mn:00004F60                 jz      short loc_4F66
.text$mn:00004F62                 xor     ecx, ecx
.text$mn:00004F64                 jnz     short loc_4F8C
.text$mn:00004F66
.text$mn:00004F66 loc_4F66:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+48j
.text$mn:00004F66                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:00004F6B                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00004F70                 push    0
.text$mn:00004F72                 push    0FBh ; 'v'
.text$mn:00004F77                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004F7C                 push    2
.text$mn:00004F7E                 call    __CrtDbgReportW
.text$mn:00004F83                 add     esp, 18h
.text$mn:00004F86                 cmp     eax, 1
.text$mn:00004F89                 jnz     short loc_4F8C
.text$mn:00004F8B                 int     3               ; Trap to Debugger
.text$mn:00004F8C
.text$mn:00004F8C loc_4F8C:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+4Cj
.text$mn:00004F8C                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+71j
.text$mn:00004F8C                 push    0
.text$mn:00004F8E                 push    0FBh ; 'v'
.text$mn:00004F93                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004F98                 push    offset ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_String_const_iterator<class std::"...
.text$mn:00004F9D                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00004FA2                 call    __invalid_parameter
.text$mn:00004FA7                 add     esp, 14h
.text$mn:00004FAA
.text$mn:00004FAA loc_4FAA:                               ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+28j
.text$mn:00004FAA                 pop     esi
.text$mn:00004FAB                 mov     esp, ebp
.text$mn:00004FAD                 pop     ebp
.text$mn:00004FAE                 retn    4
.text$mn:00004FAE ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00004FAE
.text$mn:00004FAE ; ---------------------------------------------------------------------------
.text$mn:00004FB1                 align 4
.text$mn:00004FB1 _text$mn        ends
.text$mn:00004FB1
.text$mn:00004FB4 ; ===========================================================================
.text$mn:00004FB4
.text$mn:00004FB4 ; Segment type: Pure code
.text$mn:00004FB4 ; Segment permissions: Read/Execute
.text$mn:00004FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00004FB4                 assume cs:_text$mn
.text$mn:00004FB4                 ;org 4FB4h
.text$mn:00004FB4 ; COMDAT (pick any)
.text$mn:00004FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FB4
.text$mn:00004FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FB4
.text$mn:00004FB4 ; Attributes: bp-based frame
.text$mn:00004FB4
.text$mn:00004FB4 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00004FB4                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004FB4 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00004FB4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00004FB4
.text$mn:00004FB4 var_20          = dword ptr -20h
.text$mn:00004FB4 var_1C          = dword ptr -1Ch
.text$mn:00004FB4 var_18          = dword ptr -18h
.text$mn:00004FB4 var_11          = byte ptr -11h
.text$mn:00004FB4 var_10          = dword ptr -10h
.text$mn:00004FB4 var_C           = byte ptr -0Ch
.text$mn:00004FB4 var_4           = dword ptr -4
.text$mn:00004FB4 arg_0           = dword ptr  8
.text$mn:00004FB4
.text$mn:00004FB4 ; FUNCTION CHUNK AT .text$mn:000050D6 SIZE 00000009 BYTES
.text$mn:00004FB4
.text$mn:00004FB4                 push    ebp
.text$mn:00004FB5                 mov     ebp, esp
.text$mn:00004FB7                 push    0FFFFFFFFh
.text$mn:00004FB9                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00004FBE                 mov     eax, large fs:0
.text$mn:00004FC4                 push    eax
.text$mn:00004FC5                 push    ecx
.text$mn:00004FC6                 sub     esp, 10h
.text$mn:00004FC9                 push    ebx
.text$mn:00004FCA                 push    esi
.text$mn:00004FCB                 push    edi
.text$mn:00004FCC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004FD1                 xor     eax, ebp
.text$mn:00004FD3                 push    eax
.text$mn:00004FD4                 lea     eax, [ebp+var_C]
.text$mn:00004FD7                 mov     large fs:0, eax
.text$mn:00004FDD                 mov     [ebp+var_10], esp
.text$mn:00004FE0                 mov     [ebp+var_18], ecx
.text$mn:00004FE3                 mov     eax, [ebp+arg_0]
.text$mn:00004FE6                 or      eax, 0Fh
.text$mn:00004FE9                 mov     [ebp+var_1C], eax
.text$mn:00004FEC                 mov     ecx, [ebp+var_18]
.text$mn:00004FEF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004FF4                 cmp     eax, [ebp+var_1C]
.text$mn:00004FF7                 jnb     short loc_5001
.text$mn:00004FF9                 mov     ecx, [ebp+arg_0]
.text$mn:00004FFC                 mov     [ebp+var_1C], ecx
.text$mn:00004FFF                 jmp     short loc_5053
.text$mn:00005001 ; ---------------------------------------------------------------------------
.text$mn:00005001
.text$mn:00005001 loc_5001:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00005001                 mov     edx, [ebp+var_18]
.text$mn:00005004                 mov     ecx, [edx+18h]
.text$mn:00005007                 shr     ecx, 1
.text$mn:00005009                 mov     eax, [ebp+var_1C]
.text$mn:0000500C                 xor     edx, edx
.text$mn:0000500E                 mov     esi, 3
.text$mn:00005013                 div     esi
.text$mn:00005015                 cmp     ecx, eax
.text$mn:00005017                 ja      short loc_501B
.text$mn:00005019                 jmp     short loc_5053
.text$mn:0000501B ; ---------------------------------------------------------------------------
.text$mn:0000501B
.text$mn:0000501B loc_501B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:0000501B                 mov     ecx, [ebp+var_18]
.text$mn:0000501E                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00005023                 mov     edx, [ebp+var_18]
.text$mn:00005026                 mov     ecx, [edx+18h]
.text$mn:00005029                 shr     ecx, 1
.text$mn:0000502B                 sub     eax, ecx
.text$mn:0000502D                 mov     edx, [ebp+var_18]
.text$mn:00005030                 cmp     [edx+18h], eax
.text$mn:00005033                 ja      short loc_5048
.text$mn:00005035                 mov     eax, [ebp+var_18]
.text$mn:00005038                 mov     ecx, [eax+18h]
.text$mn:0000503B                 shr     ecx, 1
.text$mn:0000503D                 mov     edx, [ebp+var_18]
.text$mn:00005040                 add     ecx, [edx+18h]
.text$mn:00005043                 mov     [ebp+var_1C], ecx
.text$mn:00005046                 jmp     short loc_5053
.text$mn:00005048 ; ---------------------------------------------------------------------------
.text$mn:00005048
.text$mn:00005048 loc_5048:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00005048                 mov     ecx, [ebp+var_18]
.text$mn:0000504B                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00005050                 mov     [ebp+var_1C], eax
.text$mn:00005053
.text$mn:00005053 loc_5053:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00005053                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00005053                 mov     [ebp+var_4], 0
.text$mn:0000505A                 mov     eax, [ebp+var_1C]
.text$mn:0000505D                 add     eax, 1
.text$mn:00005060                 push    eax
.text$mn:00005061                 lea     ecx, [ebp+var_11]
.text$mn:00005064                 push    ecx
.text$mn:00005065                 mov     ecx, [ebp+var_18]
.text$mn:00005068                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000506D                 mov     ecx, eax
.text$mn:0000506F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00005074                 mov     [ebp+var_20], eax
.text$mn:00005077                 jmp     short loc_50D6
.text$mn:00005077 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00005077
.text$mn:00005079
.text$mn:00005079 ; =============== S U B R O U T I N E =======================================
.text$mn:00005079
.text$mn:00005079
.text$mn:00005079 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00005079                                         ; DATA XREF: .xdata$x:0000821Co
.text$mn:00005079
.text$mn:00005079 ; FUNCTION CHUNK AT .text$mn:000050C0 SIZE 00000009 BYTES
.text$mn:00005079 ; FUNCTION CHUNK AT .text$mn:000050D0 SIZE 00000006 BYTES
.text$mn:00005079
.text$mn:00005079                 mov     [ebp-10h], esp
.text$mn:0000507C                 mov     edx, [ebp+8]
.text$mn:0000507F                 mov     [ebp-1Ch], edx
.text$mn:00005082                 mov     byte ptr [ebp-4], 2
.text$mn:00005086                 mov     eax, [ebp-1Ch]
.text$mn:00005089                 add     eax, 1
.text$mn:0000508C                 push    eax
.text$mn:0000508D                 lea     ecx, [ebp-12h]
.text$mn:00005090                 push    ecx
.text$mn:00005091                 mov     ecx, [ebp-18h]
.text$mn:00005094                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005099                 mov     ecx, eax
.text$mn:0000509B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000050A0                 mov     [ebp-20h], eax
.text$mn:000050A3                 jmp     short loc_50C0
.text$mn:000050A3 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000050A3
.text$mn:000050A5
.text$mn:000050A5 ; =============== S U B R O U T I N E =======================================
.text$mn:000050A5
.text$mn:000050A5 ; Attributes: noreturn
.text$mn:000050A5
.text$mn:000050A5 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000050A5                                         ; DATA XREF: .xdata$x:0000822Co
.text$mn:000050A5                 push    0               ; Size
.text$mn:000050A7                 push    1               ; char
.text$mn:000050A9                 mov     ecx, [ebp-18h]
.text$mn:000050AC                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000050B1                 push    0
.text$mn:000050B3                 push    0
.text$mn:000050B5                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000050B5 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000050B5
.text$mn:000050BA ; ---------------------------------------------------------------------------
.text$mn:000050BA                 mov     eax, offset $LN17
.text$mn:000050BF                 retn
.text$mn:000050C0 ; ---------------------------------------------------------------------------
.text$mn:000050C0 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000050C0
.text$mn:000050C0 loc_50C0:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000050C0                 mov     dword ptr [ebp-4], 1
.text$mn:000050C7                 jmp     short loc_50D0
.text$mn:000050C7 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000050C9
.text$mn:000050C9 ; =============== S U B R O U T I N E =======================================
.text$mn:000050C9
.text$mn:000050C9
.text$mn:000050C9 $LN17           proc near               ; DATA XREF: .text$mn:000050BAo
.text$mn:000050C9                 mov     dword ptr [ebp-4], 1
.text$mn:000050C9 $LN17           endp ; sp-analysis failed
.text$mn:000050C9
.text$mn:000050D0 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000050D0
.text$mn:000050D0 loc_50D0:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000050D0                 mov     eax, offset $LN19
.text$mn:000050D5                 retn
.text$mn:000050D5 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000050D6 ; ---------------------------------------------------------------------------
.text$mn:000050D6 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000050D6
.text$mn:000050D6 loc_50D6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000050D6                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050DD                 jmp     short loc_50E6
.text$mn:000050DD ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000050DF
.text$mn:000050DF ; =============== S U B R O U T I N E =======================================
.text$mn:000050DF
.text$mn:000050DF
.text$mn:000050DF $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_50D0o
.text$mn:000050DF                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000050E6
.text$mn:000050E6 loc_50E6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:000050E6                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000050EA                 jbe     short loc_5105
.text$mn:000050EC                 mov     edx, [ebp+0Ch]
.text$mn:000050EF                 push    edx             ; Size
.text$mn:000050F0                 mov     ecx, [ebp-18h]
.text$mn:000050F3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000050F8                 push    eax             ; Src
.text$mn:000050F9                 mov     eax, [ebp-20h]
.text$mn:000050FC                 push    eax             ; Dst
.text$mn:000050FD                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00005102                 add     esp, 0Ch
.text$mn:00005105
.text$mn:00005105 loc_5105:                               ; CODE XREF: $LN19+Bj
.text$mn:00005105                 push    0               ; Size
.text$mn:00005107                 push    1               ; char
.text$mn:00005109                 mov     ecx, [ebp-18h]
.text$mn:0000510C                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005111                 lea     ecx, [ebp-20h]
.text$mn:00005114                 push    ecx             ; int
.text$mn:00005115                 mov     edx, [ebp-18h]
.text$mn:00005118                 add     edx, 4
.text$mn:0000511B                 push    edx             ; void *
.text$mn:0000511C                 lea     eax, [ebp-13h]
.text$mn:0000511F                 push    eax
.text$mn:00005120                 mov     ecx, [ebp-18h]
.text$mn:00005123                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005128                 mov     ecx, eax
.text$mn:0000512A                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:0000512F                 mov     ecx, [ebp-18h]
.text$mn:00005132                 mov     edx, [ebp-1Ch]
.text$mn:00005135                 mov     [ecx+18h], edx
.text$mn:00005138                 mov     eax, [ebp+0Ch]
.text$mn:0000513B                 push    eax
.text$mn:0000513C                 mov     ecx, [ebp-18h]
.text$mn:0000513F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005144                 mov     ecx, [ebp-0Ch]
.text$mn:00005147                 mov     large fs:0, ecx
.text$mn:0000514E                 pop     ecx
.text$mn:0000514F                 pop     edi
.text$mn:00005150                 pop     esi
.text$mn:00005151                 pop     ebx
.text$mn:00005152                 mov     esp, ebp
.text$mn:00005154                 pop     ebp
.text$mn:00005155                 retn    8
.text$mn:00005155 $LN19           endp ; sp-analysis failed
.text$mn:00005155
.text$mn:00005155 _text$mn        ends
.text$mn:00005155
.text$x:00005158 ; ===========================================================================
.text$x:00005158
.text$x:00005158 ; Segment type: Pure code
.text$x:00005158 ; Segment permissions: Read/Execute
.text$x:00005158 _text$x         segment para public 'CODE' use32
.text$x:00005158                 assume cs:_text$x
.text$x:00005158                 ;org 5158h
.text$x:00005158 ; COMDAT (pick associative to section at 4FB4)
.text$x:00005158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005158
.text$x:00005158 ; =============== S U B R O U T I N E =======================================
.text$x:00005158
.text$x:00005158
.text$x:00005158 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00005158                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00005158
.text$x:00005158 arg_4           = dword ptr  8
.text$x:00005158
.text$x:00005158                 mov     edx, [esp+arg_4]
.text$x:0000515C                 lea     eax, [edx+0Ch]
.text$x:0000515F                 mov     ecx, [edx-24h]
.text$x:00005162                 xor     ecx, eax
.text$x:00005164                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005169                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:0000516E                 jmp     ___CxxFrameHandler3
.text$x:0000516E __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:0000516E
.text$x:0000516E ; ---------------------------------------------------------------------------
.text$x:00005173                 align 4
.text$x:00005173 _text$x         ends
.text$x:00005173
.text$mn:00005174 ; ===========================================================================
.text$mn:00005174
.text$mn:00005174 ; Segment type: Pure code
.text$mn:00005174 ; Segment permissions: Read/Execute
.text$mn:00005174 _text$mn        segment para public 'CODE' use32
.text$mn:00005174                 assume cs:_text$mn
.text$mn:00005174                 ;org 5174h
.text$mn:00005174 ; COMDAT (pick any)
.text$mn:00005174                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005174
.text$mn:00005174 ; =============== S U B R O U T I N E =======================================
.text$mn:00005174
.text$mn:00005174 ; Attributes: bp-based frame
.text$mn:00005174
.text$mn:00005174 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:00005174                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00005174 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:00005174                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:00005174
.text$mn:00005174 var_20          = dword ptr -20h
.text$mn:00005174 var_1C          = dword ptr -1Ch
.text$mn:00005174 var_18          = dword ptr -18h
.text$mn:00005174 var_11          = byte ptr -11h
.text$mn:00005174 var_10          = dword ptr -10h
.text$mn:00005174 var_C           = byte ptr -0Ch
.text$mn:00005174 var_4           = dword ptr -4
.text$mn:00005174 arg_0           = dword ptr  8
.text$mn:00005174
.text$mn:00005174 ; FUNCTION CHUNK AT .text$mn:00005296 SIZE 00000009 BYTES
.text$mn:00005174
.text$mn:00005174                 push    ebp
.text$mn:00005175                 mov     ebp, esp
.text$mn:00005177                 push    0FFFFFFFFh
.text$mn:00005179                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000517E                 mov     eax, large fs:0
.text$mn:00005184                 push    eax
.text$mn:00005185                 push    ecx
.text$mn:00005186                 sub     esp, 10h
.text$mn:00005189                 push    ebx
.text$mn:0000518A                 push    esi
.text$mn:0000518B                 push    edi
.text$mn:0000518C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005191                 xor     eax, ebp
.text$mn:00005193                 push    eax
.text$mn:00005194                 lea     eax, [ebp+var_C]
.text$mn:00005197                 mov     large fs:0, eax
.text$mn:0000519D                 mov     [ebp+var_10], esp
.text$mn:000051A0                 mov     [ebp+var_18], ecx
.text$mn:000051A3                 mov     eax, [ebp+arg_0]
.text$mn:000051A6                 or      eax, 7
.text$mn:000051A9                 mov     [ebp+var_1C], eax
.text$mn:000051AC                 mov     ecx, [ebp+var_18]
.text$mn:000051AF                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000051B4                 cmp     eax, [ebp+var_1C]
.text$mn:000051B7                 jnb     short loc_51C1
.text$mn:000051B9                 mov     ecx, [ebp+arg_0]
.text$mn:000051BC                 mov     [ebp+var_1C], ecx
.text$mn:000051BF                 jmp     short loc_5213
.text$mn:000051C1 ; ---------------------------------------------------------------------------
.text$mn:000051C1
.text$mn:000051C1 loc_51C1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:000051C1                 mov     edx, [ebp+var_18]
.text$mn:000051C4                 mov     ecx, [edx+18h]
.text$mn:000051C7                 shr     ecx, 1
.text$mn:000051C9                 mov     eax, [ebp+var_1C]
.text$mn:000051CC                 xor     edx, edx
.text$mn:000051CE                 mov     esi, 3
.text$mn:000051D3                 div     esi
.text$mn:000051D5                 cmp     ecx, eax
.text$mn:000051D7                 ja      short loc_51DB
.text$mn:000051D9                 jmp     short loc_5213
.text$mn:000051DB ; ---------------------------------------------------------------------------
.text$mn:000051DB
.text$mn:000051DB loc_51DB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:000051DB                 mov     ecx, [ebp+var_18]
.text$mn:000051DE                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000051E3                 mov     edx, [ebp+var_18]
.text$mn:000051E6                 mov     ecx, [edx+18h]
.text$mn:000051E9                 shr     ecx, 1
.text$mn:000051EB                 sub     eax, ecx
.text$mn:000051ED                 mov     edx, [ebp+var_18]
.text$mn:000051F0                 cmp     [edx+18h], eax
.text$mn:000051F3                 ja      short loc_5208
.text$mn:000051F5                 mov     eax, [ebp+var_18]
.text$mn:000051F8                 mov     ecx, [eax+18h]
.text$mn:000051FB                 shr     ecx, 1
.text$mn:000051FD                 mov     edx, [ebp+var_18]
.text$mn:00005200                 add     ecx, [edx+18h]
.text$mn:00005203                 mov     [ebp+var_1C], ecx
.text$mn:00005206                 jmp     short loc_5213
.text$mn:00005208 ; ---------------------------------------------------------------------------
.text$mn:00005208
.text$mn:00005208 loc_5208:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00005208                 mov     ecx, [ebp+var_18]
.text$mn:0000520B                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00005210                 mov     [ebp+var_1C], eax
.text$mn:00005213
.text$mn:00005213 loc_5213:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:00005213                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:00005213                 mov     [ebp+var_4], 0
.text$mn:0000521A                 mov     eax, [ebp+var_1C]
.text$mn:0000521D                 add     eax, 1
.text$mn:00005220                 push    eax
.text$mn:00005221                 lea     ecx, [ebp+var_11]
.text$mn:00005224                 push    ecx
.text$mn:00005225                 mov     ecx, [ebp+var_18]
.text$mn:00005228                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:0000522D                 mov     ecx, eax
.text$mn:0000522F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00005234                 mov     [ebp+var_20], eax
.text$mn:00005237                 jmp     short loc_5296
.text$mn:00005237 ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:00005237
.text$mn:00005239
.text$mn:00005239 ; =============== S U B R O U T I N E =======================================
.text$mn:00005239
.text$mn:00005239
.text$mn:00005239 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00005239                                         ; DATA XREF: .xdata$x:000086E0o
.text$mn:00005239
.text$mn:00005239 ; FUNCTION CHUNK AT .text$mn:00005280 SIZE 00000009 BYTES
.text$mn:00005239 ; FUNCTION CHUNK AT .text$mn:00005290 SIZE 00000006 BYTES
.text$mn:00005239
.text$mn:00005239                 mov     [ebp-10h], esp
.text$mn:0000523C                 mov     edx, [ebp+8]
.text$mn:0000523F                 mov     [ebp-1Ch], edx
.text$mn:00005242                 mov     byte ptr [ebp-4], 2
.text$mn:00005246                 mov     eax, [ebp-1Ch]
.text$mn:00005249                 add     eax, 1
.text$mn:0000524C                 push    eax
.text$mn:0000524D                 lea     ecx, [ebp-12h]
.text$mn:00005250                 push    ecx
.text$mn:00005251                 mov     ecx, [ebp-18h]
.text$mn:00005254                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005259                 mov     ecx, eax
.text$mn:0000525B                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00005260                 mov     [ebp-20h], eax
.text$mn:00005263                 jmp     short loc_5280
.text$mn:00005263 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:00005263
.text$mn:00005265
.text$mn:00005265 ; =============== S U B R O U T I N E =======================================
.text$mn:00005265
.text$mn:00005265 ; Attributes: noreturn
.text$mn:00005265
.text$mn:00005265 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:00005265                                         ; DATA XREF: .xdata$x:000086F0o
.text$mn:00005265                 push    0
.text$mn:00005267                 push    1
.text$mn:00005269                 mov     ecx, [ebp-18h]
.text$mn:0000526C                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00005271                 push    0
.text$mn:00005273                 push    0
.text$mn:00005275                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005275 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:00005275
.text$mn:0000527A ; ---------------------------------------------------------------------------
.text$mn:0000527A                 mov     eax, offset $LN17_0
.text$mn:0000527F                 retn
.text$mn:00005280 ; ---------------------------------------------------------------------------
.text$mn:00005280 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00005280
.text$mn:00005280 loc_5280:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00005280                 mov     dword ptr [ebp-4], 1
.text$mn:00005287                 jmp     short loc_5290
.text$mn:00005287 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00005289
.text$mn:00005289 ; =============== S U B R O U T I N E =======================================
.text$mn:00005289
.text$mn:00005289
.text$mn:00005289 $LN17_0         proc near               ; DATA XREF: .text$mn:0000527Ao
.text$mn:00005289                 mov     dword ptr [ebp-4], 1
.text$mn:00005289 $LN17_0         endp ; sp-analysis failed
.text$mn:00005289
.text$mn:00005290 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00005290
.text$mn:00005290 loc_5290:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00005290                 mov     eax, offset $LN19_0
.text$mn:00005295                 retn
.text$mn:00005295 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:00005296 ; ---------------------------------------------------------------------------
.text$mn:00005296 ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:00005296
.text$mn:00005296 loc_5296:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:00005296                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000529D                 jmp     short loc_52A6
.text$mn:0000529D ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000529F
.text$mn:0000529F ; =============== S U B R O U T I N E =======================================
.text$mn:0000529F
.text$mn:0000529F
.text$mn:0000529F $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_5290o
.text$mn:0000529F                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000052A6
.text$mn:000052A6 loc_52A6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:000052A6                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000052AA                 jbe     short loc_52C5
.text$mn:000052AC                 mov     edx, [ebp+0Ch]
.text$mn:000052AF                 push    edx             ; int
.text$mn:000052B0                 mov     ecx, [ebp-18h]
.text$mn:000052B3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000052B8                 push    eax             ; Src
.text$mn:000052B9                 mov     eax, [ebp-20h]
.text$mn:000052BC                 push    eax             ; Dst
.text$mn:000052BD                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000052C2                 add     esp, 0Ch
.text$mn:000052C5
.text$mn:000052C5 loc_52C5:                               ; CODE XREF: $LN19_0+Bj
.text$mn:000052C5                 push    0
.text$mn:000052C7                 push    1
.text$mn:000052C9                 mov     ecx, [ebp-18h]
.text$mn:000052CC                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000052D1                 lea     ecx, [ebp-20h]
.text$mn:000052D4                 push    ecx             ; int
.text$mn:000052D5                 mov     edx, [ebp-18h]
.text$mn:000052D8                 add     edx, 4
.text$mn:000052DB                 push    edx             ; void *
.text$mn:000052DC                 lea     eax, [ebp-13h]
.text$mn:000052DF                 push    eax
.text$mn:000052E0                 mov     ecx, [ebp-18h]
.text$mn:000052E3                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000052E8                 mov     ecx, eax
.text$mn:000052EA                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:000052EF                 mov     ecx, [ebp-18h]
.text$mn:000052F2                 mov     edx, [ebp-1Ch]
.text$mn:000052F5                 mov     [ecx+18h], edx
.text$mn:000052F8                 mov     eax, [ebp+0Ch]
.text$mn:000052FB                 push    eax
.text$mn:000052FC                 mov     ecx, [ebp-18h]
.text$mn:000052FF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005304                 mov     ecx, [ebp-0Ch]
.text$mn:00005307                 mov     large fs:0, ecx
.text$mn:0000530E                 pop     ecx
.text$mn:0000530F                 pop     edi
.text$mn:00005310                 pop     esi
.text$mn:00005311                 pop     ebx
.text$mn:00005312                 mov     esp, ebp
.text$mn:00005314                 pop     ebp
.text$mn:00005315                 retn    8
.text$mn:00005315 $LN19_0         endp ; sp-analysis failed
.text$mn:00005315
.text$mn:00005315 _text$mn        ends
.text$mn:00005315
.text$x:00005318 ; ===========================================================================
.text$x:00005318
.text$x:00005318 ; Segment type: Pure code
.text$x:00005318 ; Segment permissions: Read/Execute
.text$x:00005318 _text$x         segment para public 'CODE' use32
.text$x:00005318                 assume cs:_text$x
.text$x:00005318                 ;org 5318h
.text$x:00005318 ; COMDAT (pick associative to section at 5174)
.text$x:00005318                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005318
.text$x:00005318 ; =============== S U B R O U T I N E =======================================
.text$x:00005318
.text$x:00005318
.text$x:00005318 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00005318                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00005318
.text$x:00005318 arg_4           = dword ptr  8
.text$x:00005318
.text$x:00005318                 mov     edx, [esp+arg_4]
.text$x:0000531C                 lea     eax, [edx+0Ch]
.text$x:0000531F                 mov     ecx, [edx-24h]
.text$x:00005322                 xor     ecx, eax
.text$x:00005324                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005329                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:0000532E                 jmp     ___CxxFrameHandler3
.text$x:0000532E __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:0000532E
.text$x:0000532E ; ---------------------------------------------------------------------------
.text$x:00005333                 align 4
.text$x:00005333 _text$x         ends
.text$x:00005333
.text$mn:00005334 ; ===========================================================================
.text$mn:00005334
.text$mn:00005334 ; Segment type: Pure code
.text$mn:00005334 ; Segment permissions: Read/Execute
.text$mn:00005334 _text$mn        segment para public 'CODE' use32
.text$mn:00005334                 assume cs:_text$mn
.text$mn:00005334                 ;org 5334h
.text$mn:00005334 ; COMDAT (pick any)
.text$mn:00005334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005334
.text$mn:00005334 ; =============== S U B R O U T I N E =======================================
.text$mn:00005334
.text$mn:00005334 ; Attributes: bp-based frame
.text$mn:00005334
.text$mn:00005334 ; protected: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Destroy(class UserCommand *, class UserCommand *)
.text$mn:00005334                 public ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z
.text$mn:00005334 ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z proc near
.text$mn:00005334                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+CBp
.text$mn:00005334
.text$mn:00005334 var_8           = dword ptr -8
.text$mn:00005334 var_1           = byte ptr -1
.text$mn:00005334 arg_0           = dword ptr  8
.text$mn:00005334 arg_4           = dword ptr  0Ch
.text$mn:00005334
.text$mn:00005334                 push    ebp
.text$mn:00005335                 mov     ebp, esp
.text$mn:00005337                 sub     esp, 8
.text$mn:0000533A                 mov     [ebp+var_8], ecx
.text$mn:0000533D                 lea     eax, [ebp+var_1]
.text$mn:00005340                 push    eax
.text$mn:00005341                 mov     ecx, [ebp+var_8]
.text$mn:00005344                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:00005349                 lea     ecx, [ebp+var_1]
.text$mn:0000534C                 push    ecx
.text$mn:0000534D                 mov     edx, [ebp+arg_4]
.text$mn:00005350                 push    edx
.text$mn:00005351                 mov     eax, [ebp+arg_0]
.text$mn:00005354                 push    eax
.text$mn:00005355                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@@std@@YAXPAVUserCommand@@0AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<UserCommand>>>(UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &)
.text$mn:0000535A                 add     esp, 0Ch
.text$mn:0000535D                 mov     esp, ebp
.text$mn:0000535F                 pop     ebp
.text$mn:00005360                 retn    8
.text$mn:00005360 ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z endp
.text$mn:00005360
.text$mn:00005360 ; ---------------------------------------------------------------------------
.text$mn:00005363                 align 4
.text$mn:00005363 _text$mn        ends
.text$mn:00005363
.text$mn:00005364 ; ===========================================================================
.text$mn:00005364
.text$mn:00005364 ; Segment type: Pure code
.text$mn:00005364 ; Segment permissions: Read/Execute
.text$mn:00005364 _text$mn        segment para public 'CODE' use32
.text$mn:00005364                 assume cs:_text$mn
.text$mn:00005364                 ;org 5364h
.text$mn:00005364 ; COMDAT (pick any)
.text$mn:00005364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005364
.text$mn:00005364 ; =============== S U B R O U T I N E =======================================
.text$mn:00005364
.text$mn:00005364 ; Attributes: bp-based frame
.text$mn:00005364
.text$mn:00005364 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00005364                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00005364 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00005364                                         ; CODE XREF: $LN19+60p
.text$mn:00005364                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00005364
.text$mn:00005364 var_8           = dword ptr -8
.text$mn:00005364 var_1           = byte ptr -1
.text$mn:00005364 arg_0           = dword ptr  8
.text$mn:00005364
.text$mn:00005364                 push    ebp
.text$mn:00005365                 mov     ebp, esp
.text$mn:00005367                 sub     esp, 8
.text$mn:0000536A                 mov     [ebp+var_8], ecx
.text$mn:0000536D                 mov     [ebp+var_1], 0
.text$mn:00005371                 mov     eax, [ebp+var_8]
.text$mn:00005374                 mov     ecx, [ebp+arg_0]
.text$mn:00005377                 mov     [eax+14h], ecx
.text$mn:0000537A                 lea     edx, [ebp+var_1]
.text$mn:0000537D                 push    edx
.text$mn:0000537E                 mov     ecx, [ebp+var_8]
.text$mn:00005381                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005386                 add     eax, [ebp+arg_0]
.text$mn:00005389                 push    eax
.text$mn:0000538A                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:0000538F                 add     esp, 8
.text$mn:00005392                 mov     esp, ebp
.text$mn:00005394                 pop     ebp
.text$mn:00005395                 retn    4
.text$mn:00005395 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00005395
.text$mn:00005395 _text$mn        ends
.text$mn:00005395
.text$mn:00005398 ; ===========================================================================
.text$mn:00005398
.text$mn:00005398 ; Segment type: Pure code
.text$mn:00005398 ; Segment permissions: Read/Execute
.text$mn:00005398 _text$mn        segment para public 'CODE' use32
.text$mn:00005398                 assume cs:_text$mn
.text$mn:00005398                 ;org 5398h
.text$mn:00005398 ; COMDAT (pick any)
.text$mn:00005398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005398
.text$mn:00005398 ; =============== S U B R O U T I N E =======================================
.text$mn:00005398
.text$mn:00005398 ; Attributes: bp-based frame
.text$mn:00005398
.text$mn:00005398 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00005398                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00005398 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00005398                                         ; CODE XREF: $LN19_0+60p
.text$mn:00005398                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00005398
.text$mn:00005398 var_8           = dword ptr -8
.text$mn:00005398 var_2           = word ptr -2
.text$mn:00005398 arg_0           = dword ptr  8
.text$mn:00005398
.text$mn:00005398                 push    ebp
.text$mn:00005399                 mov     ebp, esp
.text$mn:0000539B                 sub     esp, 8
.text$mn:0000539E                 mov     [ebp+var_8], ecx
.text$mn:000053A1                 xor     eax, eax
.text$mn:000053A3                 mov     [ebp+var_2], ax
.text$mn:000053A7                 mov     ecx, [ebp+var_8]
.text$mn:000053AA                 mov     edx, [ebp+arg_0]
.text$mn:000053AD                 mov     [ecx+14h], edx
.text$mn:000053B0                 lea     eax, [ebp+var_2]
.text$mn:000053B3                 push    eax
.text$mn:000053B4                 mov     ecx, [ebp+var_8]
.text$mn:000053B7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000053BC                 mov     ecx, [ebp+arg_0]
.text$mn:000053BF                 lea     edx, [eax+ecx*2]
.text$mn:000053C2                 push    edx
.text$mn:000053C3                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:000053C8                 add     esp, 8
.text$mn:000053CB                 mov     esp, ebp
.text$mn:000053CD                 pop     ebp
.text$mn:000053CE                 retn    4
.text$mn:000053CE ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:000053CE
.text$mn:000053CE ; ---------------------------------------------------------------------------
.text$mn:000053D1                 align 4
.text$mn:000053D1 _text$mn        ends
.text$mn:000053D1
.text$mn:000053D4 ; ===========================================================================
.text$mn:000053D4
.text$mn:000053D4 ; Segment type: Pure code
.text$mn:000053D4 ; Segment permissions: Read/Execute
.text$mn:000053D4 _text$mn        segment para public 'CODE' use32
.text$mn:000053D4                 assume cs:_text$mn
.text$mn:000053D4                 ;org 53D4h
.text$mn:000053D4 ; COMDAT (pick any)
.text$mn:000053D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053D4
.text$mn:000053D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000053D4
.text$mn:000053D4 ; Attributes: bp-based frame
.text$mn:000053D4
.text$mn:000053D4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000053D4                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000053D4 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000053D4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000053D4
.text$mn:000053D4 var_8           = dword ptr -8
.text$mn:000053D4 var_1           = byte ptr -1
.text$mn:000053D4
.text$mn:000053D4                 push    ebp
.text$mn:000053D5                 mov     ebp, esp
.text$mn:000053D7                 sub     esp, 8
.text$mn:000053DA                 mov     [ebp+var_8], ecx
.text$mn:000053DD                 lea     ecx, [ebp+var_1]
.text$mn:000053E0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000053E5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000053E8                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000053ED                 mov     eax, [ebp+var_8]
.text$mn:000053F0                 mov     ecx, [eax]
.text$mn:000053F2                 push    ecx
.text$mn:000053F3                 lea     ecx, [ebp+var_1]
.text$mn:000053F6                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000053FB                 push    1               ; int
.text$mn:000053FD                 mov     edx, [ebp+var_8]
.text$mn:00005400                 mov     eax, [edx]
.text$mn:00005402                 push    eax             ; void *
.text$mn:00005403                 lea     ecx, [ebp+var_1]
.text$mn:00005406                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000540B                 mov     ecx, [ebp+var_8]
.text$mn:0000540E                 mov     dword ptr [ecx], 0
.text$mn:00005414                 mov     esp, ebp
.text$mn:00005416                 pop     ebp
.text$mn:00005417                 retn
.text$mn:00005417 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00005417
.text$mn:00005417 _text$mn        ends
.text$mn:00005417
.text$mn:00005418 ; ===========================================================================
.text$mn:00005418
.text$mn:00005418 ; Segment type: Pure code
.text$mn:00005418 ; Segment permissions: Read/Execute
.text$mn:00005418 _text$mn        segment para public 'CODE' use32
.text$mn:00005418                 assume cs:_text$mn
.text$mn:00005418                 ;org 5418h
.text$mn:00005418 ; COMDAT (pick any)
.text$mn:00005418                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005418
.text$mn:00005418 ; =============== S U B R O U T I N E =======================================
.text$mn:00005418
.text$mn:00005418 ; Attributes: bp-based frame
.text$mn:00005418
.text$mn:00005418 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00005418                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00005418 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00005418                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00005418
.text$mn:00005418 var_8           = dword ptr -8
.text$mn:00005418 var_1           = byte ptr -1
.text$mn:00005418
.text$mn:00005418                 push    ebp
.text$mn:00005419                 mov     ebp, esp
.text$mn:0000541B                 sub     esp, 8
.text$mn:0000541E                 mov     [ebp+var_8], ecx
.text$mn:00005421                 lea     ecx, [ebp+var_1]
.text$mn:00005424                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00005429                 mov     ecx, [ebp+var_8] ; this
.text$mn:0000542C                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005431                 mov     eax, [ebp+var_8]
.text$mn:00005434                 mov     ecx, [eax]
.text$mn:00005436                 push    ecx
.text$mn:00005437                 lea     ecx, [ebp+var_1]
.text$mn:0000543A                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000543F                 push    1               ; int
.text$mn:00005441                 mov     edx, [ebp+var_8]
.text$mn:00005444                 mov     eax, [edx]
.text$mn:00005446                 push    eax             ; void *
.text$mn:00005447                 lea     ecx, [ebp+var_1]
.text$mn:0000544A                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000544F                 mov     ecx, [ebp+var_8]
.text$mn:00005452                 mov     dword ptr [ecx], 0
.text$mn:00005458                 mov     esp, ebp
.text$mn:0000545A                 pop     ebp
.text$mn:0000545B                 retn
.text$mn:0000545B ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000545B
.text$mn:0000545B _text$mn        ends
.text$mn:0000545B
.text$mn:0000545C ; ===========================================================================
.text$mn:0000545C
.text$mn:0000545C ; Segment type: Pure code
.text$mn:0000545C ; Segment permissions: Read/Execute
.text$mn:0000545C _text$mn        segment para public 'CODE' use32
.text$mn:0000545C                 assume cs:_text$mn
.text$mn:0000545C                 ;org 545Ch
.text$mn:0000545C ; COMDAT (pick any)
.text$mn:0000545C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000545C
.text$mn:0000545C ; =============== S U B R O U T I N E =======================================
.text$mn:0000545C
.text$mn:0000545C ; Attributes: bp-based frame
.text$mn:0000545C
.text$mn:0000545C ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:0000545C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:0000545C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:0000545C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:0000545C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:0000545C
.text$mn:0000545C var_4           = dword ptr -4
.text$mn:0000545C arg_0           = dword ptr  8
.text$mn:0000545C
.text$mn:0000545C                 push    ebp
.text$mn:0000545D                 mov     ebp, esp
.text$mn:0000545F                 push    ecx
.text$mn:00005460                 mov     [ebp+var_4], ecx
.text$mn:00005463                 mov     ecx, [ebp+arg_0]
.text$mn:00005466                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:0000546B                 mov     eax, [ebp+arg_0]
.text$mn:0000546E                 mov     esp, ebp
.text$mn:00005470                 pop     ebp
.text$mn:00005471                 retn    4
.text$mn:00005471 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00005471
.text$mn:00005471 _text$mn        ends
.text$mn:00005471
.text$mn:00005474 ; ===========================================================================
.text$mn:00005474
.text$mn:00005474 ; Segment type: Pure code
.text$mn:00005474 ; Segment permissions: Read/Execute
.text$mn:00005474 _text$mn        segment para public 'CODE' use32
.text$mn:00005474                 assume cs:_text$mn
.text$mn:00005474                 ;org 5474h
.text$mn:00005474 ; COMDAT (pick any)
.text$mn:00005474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005474
.text$mn:00005474 ; =============== S U B R O U T I N E =======================================
.text$mn:00005474
.text$mn:00005474 ; Attributes: bp-based frame
.text$mn:00005474
.text$mn:00005474 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:00005474                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:00005474 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:00005474                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Fp
.text$mn:00005474                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+33p ...
.text$mn:00005474
.text$mn:00005474 var_4           = dword ptr -4
.text$mn:00005474 arg_0           = dword ptr  8
.text$mn:00005474
.text$mn:00005474                 push    ebp
.text$mn:00005475                 mov     ebp, esp
.text$mn:00005477                 push    ecx
.text$mn:00005478                 mov     [ebp+var_4], ecx
.text$mn:0000547B                 mov     ecx, [ebp+arg_0]
.text$mn:0000547E                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:00005483                 mov     eax, [ebp+arg_0]
.text$mn:00005486                 mov     esp, ebp
.text$mn:00005488                 pop     ebp
.text$mn:00005489                 retn    4
.text$mn:00005489 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00005489
.text$mn:00005489 _text$mn        ends
.text$mn:00005489
.text$mn:0000548C ; ===========================================================================
.text$mn:0000548C
.text$mn:0000548C ; Segment type: Pure code
.text$mn:0000548C ; Segment permissions: Read/Execute
.text$mn:0000548C _text$mn        segment para public 'CODE' use32
.text$mn:0000548C                 assume cs:_text$mn
.text$mn:0000548C                 ;org 548Ch
.text$mn:0000548C ; COMDAT (pick any)
.text$mn:0000548C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000548C
.text$mn:0000548C ; =============== S U B R O U T I N E =======================================
.text$mn:0000548C
.text$mn:0000548C ; Attributes: bp-based frame
.text$mn:0000548C
.text$mn:0000548C ; public: struct std::_Wrap_alloc<class std::allocator<class UserCommand>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class UserCommand, class std::allocator<class UserCommand>>>::_Getal(void)const
.text$mn:0000548C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ
.text$mn:0000548C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ proc near
.text$mn:0000548C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Umove<UserCommand *>(UserCommand *,UserCommand *,UserCommand *)+10p
.text$mn:0000548C                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Destroy(UserCommand *,UserCommand *)+10p ...
.text$mn:0000548C
.text$mn:0000548C var_4           = dword ptr -4
.text$mn:0000548C arg_0           = dword ptr  8
.text$mn:0000548C
.text$mn:0000548C                 push    ebp
.text$mn:0000548D                 mov     ebp, esp
.text$mn:0000548F                 push    ecx
.text$mn:00005490                 mov     [ebp+var_4], ecx
.text$mn:00005493                 mov     ecx, [ebp+arg_0]
.text$mn:00005496                 call    ??0?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<UserCommand>>::_Wrap_alloc<std::allocator<UserCommand>>(void)
.text$mn:0000549B                 mov     eax, [ebp+arg_0]
.text$mn:0000549E                 mov     esp, ebp
.text$mn:000054A0                 pop     ebp
.text$mn:000054A1                 retn    4
.text$mn:000054A1 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ endp
.text$mn:000054A1
.text$mn:000054A1 _text$mn        ends
.text$mn:000054A1
.text$mn:000054A4 ; ===========================================================================
.text$mn:000054A4
.text$mn:000054A4 ; Segment type: Pure code
.text$mn:000054A4 ; Segment permissions: Read/Execute
.text$mn:000054A4 _text$mn        segment para public 'CODE' use32
.text$mn:000054A4                 assume cs:_text$mn
.text$mn:000054A4                 ;org 54A4h
.text$mn:000054A4 ; COMDAT (pick any)
.text$mn:000054A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054A4
.text$mn:000054A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000054A4
.text$mn:000054A4 ; Attributes: bp-based frame
.text$mn:000054A4
.text$mn:000054A4 ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:000054A4                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:000054A4 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:000054A4                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+Bp
.text$mn:000054A4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+20p ...
.text$mn:000054A4
.text$mn:000054A4 var_8           = dword ptr -8
.text$mn:000054A4 var_4           = dword ptr -4
.text$mn:000054A4
.text$mn:000054A4                 push    ebp
.text$mn:000054A5                 mov     ebp, esp
.text$mn:000054A7                 sub     esp, 8
.text$mn:000054AA                 mov     [ebp+var_4], ecx
.text$mn:000054AD                 mov     eax, [ebp+var_4]
.text$mn:000054B0                 cmp     dword ptr [eax], 0
.text$mn:000054B3                 jnz     short loc_54BE
.text$mn:000054B5                 mov     [ebp+var_8], 0
.text$mn:000054BC                 jmp     short loc_54C8
.text$mn:000054BE ; ---------------------------------------------------------------------------
.text$mn:000054BE
.text$mn:000054BE loc_54BE:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:000054BE                 mov     ecx, [ebp+var_4]
.text$mn:000054C1                 mov     edx, [ecx]
.text$mn:000054C3                 mov     eax, [edx]
.text$mn:000054C5                 mov     [ebp+var_8], eax
.text$mn:000054C8
.text$mn:000054C8 loc_54C8:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:000054C8                 mov     eax, [ebp+var_8]
.text$mn:000054CB                 mov     esp, ebp
.text$mn:000054CD                 pop     ebp
.text$mn:000054CE                 retn
.text$mn:000054CE ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:000054CE
.text$mn:000054CE ; ---------------------------------------------------------------------------
.text$mn:000054CF                 align 10h
.text$mn:000054CF _text$mn        ends
.text$mn:000054CF
.text$mn:000054D0 ; ===========================================================================
.text$mn:000054D0
.text$mn:000054D0 ; Segment type: Pure code
.text$mn:000054D0 ; Segment permissions: Read/Execute
.text$mn:000054D0 _text$mn        segment para public 'CODE' use32
.text$mn:000054D0                 assume cs:_text$mn
.text$mn:000054D0                 ;org 54D0h
.text$mn:000054D0 ; COMDAT (pick any)
.text$mn:000054D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054D0
.text$mn:000054D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000054D0
.text$mn:000054D0 ; Attributes: bp-based frame
.text$mn:000054D0
.text$mn:000054D0 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:000054D0                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:000054D0 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:000054D0                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+3Cp
.text$mn:000054D0
.text$mn:000054D0 var_8           = dword ptr -8
.text$mn:000054D0 var_4           = dword ptr -4
.text$mn:000054D0
.text$mn:000054D0                 push    ebp
.text$mn:000054D1                 mov     ebp, esp
.text$mn:000054D3                 sub     esp, 8
.text$mn:000054D6                 mov     [ebp+var_4], ecx
.text$mn:000054D9                 mov     eax, [ebp+var_4]
.text$mn:000054DC                 cmp     dword ptr [eax], 0
.text$mn:000054DF                 jnz     short loc_54EA
.text$mn:000054E1                 mov     [ebp+var_8], 0
.text$mn:000054E8                 jmp     short loc_54F5
.text$mn:000054EA ; ---------------------------------------------------------------------------
.text$mn:000054EA
.text$mn:000054EA loc_54EA:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:000054EA                 mov     ecx, [ebp+var_4]
.text$mn:000054ED                 mov     edx, [ecx]
.text$mn:000054EF                 add     edx, 4
.text$mn:000054F2                 mov     [ebp+var_8], edx
.text$mn:000054F5
.text$mn:000054F5 loc_54F5:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:000054F5                 mov     eax, [ebp+var_8]
.text$mn:000054F8                 mov     esp, ebp
.text$mn:000054FA                 pop     ebp
.text$mn:000054FB                 retn
.text$mn:000054FB ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:000054FB
.text$mn:000054FB _text$mn        ends
.text$mn:000054FB
.text$mn:000054FC ; ===========================================================================
.text$mn:000054FC
.text$mn:000054FC ; Segment type: Pure code
.text$mn:000054FC ; Segment permissions: Read/Execute
.text$mn:000054FC _text$mn        segment para public 'CODE' use32
.text$mn:000054FC                 assume cs:_text$mn
.text$mn:000054FC                 ;org 54FCh
.text$mn:000054FC ; COMDAT (pick any)
.text$mn:000054FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054FC
.text$mn:000054FC ; =============== S U B R O U T I N E =======================================
.text$mn:000054FC
.text$mn:000054FC ; Attributes: bp-based frame
.text$mn:000054FC
.text$mn:000054FC ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:000054FC                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:000054FC ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:000054FC                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+71p
.text$mn:000054FC                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+8Ap
.text$mn:000054FC
.text$mn:000054FC var_4           = dword ptr -4
.text$mn:000054FC
.text$mn:000054FC                 push    ebp
.text$mn:000054FD                 mov     ebp, esp
.text$mn:000054FF                 push    ecx
.text$mn:00005500                 mov     [ebp+var_4], ecx
.text$mn:00005503                 mov     eax, [ebp+var_4]
.text$mn:00005506                 add     eax, 4
.text$mn:00005509                 mov     esp, ebp
.text$mn:0000550B                 pop     ebp
.text$mn:0000550C                 retn
.text$mn:0000550C ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:0000550C
.text$mn:0000550C ; ---------------------------------------------------------------------------
.text$mn:0000550D                 align 10h
.text$mn:0000550D _text$mn        ends
.text$mn:0000550D
.text$mn:00005510 ; ===========================================================================
.text$mn:00005510
.text$mn:00005510 ; Segment type: Pure code
.text$mn:00005510 ; Segment permissions: Read/Execute
.text$mn:00005510 _text$mn        segment para public 'CODE' use32
.text$mn:00005510                 assume cs:_text$mn
.text$mn:00005510                 ;org 5510h
.text$mn:00005510 ; COMDAT (pick any)
.text$mn:00005510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005510
.text$mn:00005510 ; =============== S U B R O U T I N E =======================================
.text$mn:00005510
.text$mn:00005510 ; Attributes: bp-based frame
.text$mn:00005510
.text$mn:00005510 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00005510                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00005510 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00005510                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00005510                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00005510
.text$mn:00005510 var_C           = dword ptr -0Ch
.text$mn:00005510 Size            = dword ptr -8
.text$mn:00005510 var_4           = dword ptr -4
.text$mn:00005510 arg_0           = dword ptr  8
.text$mn:00005510 arg_4           = byte ptr  0Ch
.text$mn:00005510
.text$mn:00005510                 push    ebp
.text$mn:00005511                 mov     ebp, esp
.text$mn:00005513                 sub     esp, 0Ch
.text$mn:00005516                 mov     [ebp+var_4], ecx
.text$mn:00005519                 mov     ecx, [ebp+var_4]
.text$mn:0000551C                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00005521                 cmp     eax, [ebp+arg_0]
.text$mn:00005524                 jnb     short loc_552E
.text$mn:00005526                 mov     ecx, [ebp+var_4]
.text$mn:00005529                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000552E
.text$mn:0000552E loc_552E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000552E                 mov     eax, [ebp+var_4]
.text$mn:00005531                 mov     ecx, [eax+18h]
.text$mn:00005534                 cmp     ecx, [ebp+arg_0]
.text$mn:00005537                 jnb     short loc_554E
.text$mn:00005539                 mov     edx, [ebp+var_4]
.text$mn:0000553C                 mov     eax, [edx+14h]
.text$mn:0000553F                 push    eax
.text$mn:00005540                 mov     ecx, [ebp+arg_0]
.text$mn:00005543                 push    ecx
.text$mn:00005544                 mov     ecx, [ebp+var_4]
.text$mn:00005547                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:0000554C                 jmp     short loc_5598
.text$mn:0000554E ; ---------------------------------------------------------------------------
.text$mn:0000554E
.text$mn:0000554E loc_554E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000554E                 movzx   edx, [ebp+arg_4]
.text$mn:00005552                 test    edx, edx
.text$mn:00005554                 jz      short loc_5588
.text$mn:00005556                 cmp     [ebp+arg_0], 10h
.text$mn:0000555A                 jnb     short loc_5588
.text$mn:0000555C                 mov     eax, [ebp+var_4]
.text$mn:0000555F                 mov     ecx, [ebp+arg_0]
.text$mn:00005562                 cmp     ecx, [eax+14h]
.text$mn:00005565                 jnb     short loc_556F
.text$mn:00005567                 mov     edx, [ebp+arg_0]
.text$mn:0000556A                 mov     [ebp+Size], edx
.text$mn:0000556D                 jmp     short loc_5578
.text$mn:0000556F ; ---------------------------------------------------------------------------
.text$mn:0000556F
.text$mn:0000556F loc_556F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:0000556F                 mov     eax, [ebp+var_4]
.text$mn:00005572                 mov     ecx, [eax+14h]
.text$mn:00005575                 mov     [ebp+Size], ecx
.text$mn:00005578
.text$mn:00005578 loc_5578:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00005578                 mov     edx, [ebp+Size]
.text$mn:0000557B                 push    edx             ; Size
.text$mn:0000557C                 push    1               ; char
.text$mn:0000557E                 mov     ecx, [ebp+var_4]
.text$mn:00005581                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00005586                 jmp     short loc_5598
.text$mn:00005588 ; ---------------------------------------------------------------------------
.text$mn:00005588
.text$mn:00005588 loc_5588:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00005588                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00005588                 cmp     [ebp+arg_0], 0
.text$mn:0000558C                 jnz     short loc_5598
.text$mn:0000558E                 push    0
.text$mn:00005590                 mov     ecx, [ebp+var_4]
.text$mn:00005593                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005598
.text$mn:00005598 loc_5598:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00005598                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00005598                 cmp     [ebp+arg_0], 0
.text$mn:0000559C                 jbe     short loc_55A7
.text$mn:0000559E                 mov     [ebp+var_C], 1
.text$mn:000055A5                 jmp     short loc_55AE
.text$mn:000055A7 ; ---------------------------------------------------------------------------
.text$mn:000055A7
.text$mn:000055A7 loc_55A7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000055A7                 mov     [ebp+var_C], 0
.text$mn:000055AE
.text$mn:000055AE loc_55AE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000055AE                 mov     al, byte ptr [ebp+var_C]
.text$mn:000055B1                 mov     esp, ebp
.text$mn:000055B3                 pop     ebp
.text$mn:000055B4                 retn    8
.text$mn:000055B4 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000055B4
.text$mn:000055B4 ; ---------------------------------------------------------------------------
.text$mn:000055B7                 align 4
.text$mn:000055B7 _text$mn        ends
.text$mn:000055B7
.text$mn:000055B8 ; ===========================================================================
.text$mn:000055B8
.text$mn:000055B8 ; Segment type: Pure code
.text$mn:000055B8 ; Segment permissions: Read/Execute
.text$mn:000055B8 _text$mn        segment para public 'CODE' use32
.text$mn:000055B8                 assume cs:_text$mn
.text$mn:000055B8                 ;org 55B8h
.text$mn:000055B8 ; COMDAT (pick any)
.text$mn:000055B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055B8
.text$mn:000055B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000055B8
.text$mn:000055B8 ; Attributes: bp-based frame
.text$mn:000055B8
.text$mn:000055B8 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:000055B8                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:000055B8 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:000055B8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Dp
.text$mn:000055B8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+8Ep ...
.text$mn:000055B8
.text$mn:000055B8 var_C           = dword ptr -0Ch
.text$mn:000055B8 var_8           = dword ptr -8
.text$mn:000055B8 var_4           = dword ptr -4
.text$mn:000055B8 arg_0           = dword ptr  8
.text$mn:000055B8 arg_4           = byte ptr  0Ch
.text$mn:000055B8
.text$mn:000055B8                 push    ebp
.text$mn:000055B9                 mov     ebp, esp
.text$mn:000055BB                 sub     esp, 0Ch
.text$mn:000055BE                 mov     [ebp+var_4], ecx
.text$mn:000055C1                 mov     ecx, [ebp+var_4]
.text$mn:000055C4                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000055C9                 cmp     eax, [ebp+arg_0]
.text$mn:000055CC                 jnb     short loc_55D6
.text$mn:000055CE                 mov     ecx, [ebp+var_4]
.text$mn:000055D1                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000055D6
.text$mn:000055D6 loc_55D6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:000055D6                 mov     eax, [ebp+var_4]
.text$mn:000055D9                 mov     ecx, [eax+18h]
.text$mn:000055DC                 cmp     ecx, [ebp+arg_0]
.text$mn:000055DF                 jnb     short loc_55F6
.text$mn:000055E1                 mov     edx, [ebp+var_4]
.text$mn:000055E4                 mov     eax, [edx+14h]
.text$mn:000055E7                 push    eax
.text$mn:000055E8                 mov     ecx, [ebp+arg_0]
.text$mn:000055EB                 push    ecx
.text$mn:000055EC                 mov     ecx, [ebp+var_4]
.text$mn:000055EF                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:000055F4                 jmp     short loc_5640
.text$mn:000055F6 ; ---------------------------------------------------------------------------
.text$mn:000055F6
.text$mn:000055F6 loc_55F6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:000055F6                 movzx   edx, [ebp+arg_4]
.text$mn:000055FA                 test    edx, edx
.text$mn:000055FC                 jz      short loc_5630
.text$mn:000055FE                 cmp     [ebp+arg_0], 8
.text$mn:00005602                 jnb     short loc_5630
.text$mn:00005604                 mov     eax, [ebp+var_4]
.text$mn:00005607                 mov     ecx, [ebp+arg_0]
.text$mn:0000560A                 cmp     ecx, [eax+14h]
.text$mn:0000560D                 jnb     short loc_5617
.text$mn:0000560F                 mov     edx, [ebp+arg_0]
.text$mn:00005612                 mov     [ebp+var_8], edx
.text$mn:00005615                 jmp     short loc_5620
.text$mn:00005617 ; ---------------------------------------------------------------------------
.text$mn:00005617
.text$mn:00005617 loc_5617:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:00005617                 mov     eax, [ebp+var_4]
.text$mn:0000561A                 mov     ecx, [eax+14h]
.text$mn:0000561D                 mov     [ebp+var_8], ecx
.text$mn:00005620
.text$mn:00005620 loc_5620:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00005620                 mov     edx, [ebp+var_8]
.text$mn:00005623                 push    edx
.text$mn:00005624                 push    1
.text$mn:00005626                 mov     ecx, [ebp+var_4]
.text$mn:00005629                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:0000562E                 jmp     short loc_5640
.text$mn:00005630 ; ---------------------------------------------------------------------------
.text$mn:00005630
.text$mn:00005630 loc_5630:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:00005630                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:00005630                 cmp     [ebp+arg_0], 0
.text$mn:00005634                 jnz     short loc_5640
.text$mn:00005636                 push    0
.text$mn:00005638                 mov     ecx, [ebp+var_4]
.text$mn:0000563B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005640
.text$mn:00005640 loc_5640:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:00005640                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:00005640                 cmp     [ebp+arg_0], 0
.text$mn:00005644                 jbe     short loc_564F
.text$mn:00005646                 mov     [ebp+var_C], 1
.text$mn:0000564D                 jmp     short loc_5656
.text$mn:0000564F ; ---------------------------------------------------------------------------
.text$mn:0000564F
.text$mn:0000564F loc_564F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:0000564F                 mov     [ebp+var_C], 0
.text$mn:00005656
.text$mn:00005656 loc_5656:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:00005656                 mov     al, byte ptr [ebp+var_C]
.text$mn:00005659                 mov     esp, ebp
.text$mn:0000565B                 pop     ebp
.text$mn:0000565C                 retn    8
.text$mn:0000565C ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:0000565C
.text$mn:0000565C ; ---------------------------------------------------------------------------
.text$mn:0000565F                 align 10h
.text$mn:0000565F _text$mn        ends
.text$mn:0000565F
.text$mn:00005660 ; ===========================================================================
.text$mn:00005660
.text$mn:00005660 ; Segment type: Pure code
.text$mn:00005660 ; Segment permissions: Read/Execute
.text$mn:00005660 _text$mn        segment para public 'CODE' use32
.text$mn:00005660                 assume cs:_text$mn
.text$mn:00005660                 ;org 5660h
.text$mn:00005660 ; COMDAT (pick any)
.text$mn:00005660                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005660
.text$mn:00005660 ; =============== S U B R O U T I N E =======================================
.text$mn:00005660
.text$mn:00005660 ; Attributes: bp-based frame
.text$mn:00005660
.text$mn:00005660 ; protected: unsigned int __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Grow_to(unsigned int)const
.text$mn:00005660                 public ?_Grow_to@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEII@Z
.text$mn:00005660 ?_Grow_to@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEII@Z proc near
.text$mn:00005660                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)+45p
.text$mn:00005660
.text$mn:00005660 var_C           = dword ptr -0Ch
.text$mn:00005660 var_8           = dword ptr -8
.text$mn:00005660 var_4           = dword ptr -4
.text$mn:00005660 arg_0           = dword ptr  8
.text$mn:00005660
.text$mn:00005660                 push    ebp
.text$mn:00005661                 mov     ebp, esp
.text$mn:00005663                 sub     esp, 0Ch
.text$mn:00005666                 mov     [ebp+var_8], ecx
.text$mn:00005669                 mov     ecx, [ebp+var_8]
.text$mn:0000566C                 call    ?capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::capacity(void)
.text$mn:00005671                 mov     [ebp+var_4], eax
.text$mn:00005674                 mov     ecx, [ebp+var_8]
.text$mn:00005677                 call    ?max_size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::max_size(void)
.text$mn:0000567C                 mov     ecx, [ebp+var_4]
.text$mn:0000567F                 shr     ecx, 1
.text$mn:00005681                 sub     eax, ecx
.text$mn:00005683                 cmp     eax, [ebp+var_4]
.text$mn:00005686                 jnb     short loc_5691
.text$mn:00005688                 mov     [ebp+var_C], 0
.text$mn:0000568F                 jmp     short loc_569C
.text$mn:00005691 ; ---------------------------------------------------------------------------
.text$mn:00005691
.text$mn:00005691 loc_5691:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Grow_to(uint)+26j
.text$mn:00005691                 mov     edx, [ebp+var_4]
.text$mn:00005694                 shr     edx, 1
.text$mn:00005696                 add     edx, [ebp+var_4]
.text$mn:00005699                 mov     [ebp+var_C], edx
.text$mn:0000569C
.text$mn:0000569C loc_569C:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Grow_to(uint)+2Fj
.text$mn:0000569C                 mov     eax, [ebp+var_C]
.text$mn:0000569F                 mov     [ebp+var_4], eax
.text$mn:000056A2                 mov     ecx, [ebp+var_4]
.text$mn:000056A5                 cmp     ecx, [ebp+arg_0]
.text$mn:000056A8                 jnb     short loc_56B0
.text$mn:000056AA                 mov     edx, [ebp+arg_0]
.text$mn:000056AD                 mov     [ebp+var_4], edx
.text$mn:000056B0
.text$mn:000056B0 loc_56B0:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Grow_to(uint)+48j
.text$mn:000056B0                 mov     eax, [ebp+var_4]
.text$mn:000056B3                 mov     esp, ebp
.text$mn:000056B5                 pop     ebp
.text$mn:000056B6                 retn    4
.text$mn:000056B6 ?_Grow_to@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEII@Z endp
.text$mn:000056B6
.text$mn:000056B6 ; ---------------------------------------------------------------------------
.text$mn:000056B9                 align 4
.text$mn:000056B9 _text$mn        ends
.text$mn:000056B9
.text$mn:000056BC ; ===========================================================================
.text$mn:000056BC
.text$mn:000056BC ; Segment type: Pure code
.text$mn:000056BC ; Segment permissions: Read/Execute
.text$mn:000056BC _text$mn        segment para public 'CODE' use32
.text$mn:000056BC                 assume cs:_text$mn
.text$mn:000056BC                 ;org 56BCh
.text$mn:000056BC ; COMDAT (pick any)
.text$mn:000056BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056BC
.text$mn:000056BC ; =============== S U B R O U T I N E =======================================
.text$mn:000056BC
.text$mn:000056BC ; Attributes: bp-based frame
.text$mn:000056BC
.text$mn:000056BC ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000056BC                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000056BC ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000056BC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000056BC
.text$mn:000056BC var_4           = dword ptr -4
.text$mn:000056BC arg_0           = dword ptr  8
.text$mn:000056BC
.text$mn:000056BC                 push    ebp
.text$mn:000056BD                 mov     ebp, esp
.text$mn:000056BF                 push    ecx
.text$mn:000056C0                 mov     [ebp+var_4], ecx
.text$mn:000056C3                 cmp     [ebp+arg_0], 0
.text$mn:000056C7                 jz      short loc_56E9
.text$mn:000056C9                 mov     ecx, [ebp+var_4]
.text$mn:000056CC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000056D1                 cmp     [ebp+arg_0], eax
.text$mn:000056D4                 jb      short loc_56E9
.text$mn:000056D6                 mov     ecx, [ebp+var_4]
.text$mn:000056D9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000056DE                 mov     ecx, [ebp+var_4]
.text$mn:000056E1                 add     eax, [ecx+14h]
.text$mn:000056E4                 cmp     eax, [ebp+arg_0]
.text$mn:000056E7                 ja      short loc_56EF
.text$mn:000056E9
.text$mn:000056E9 loc_56E9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:000056E9                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:000056E9                 xor     al, al
.text$mn:000056EB                 jmp     short loc_56F1
.text$mn:000056ED ; ---------------------------------------------------------------------------
.text$mn:000056ED                 jmp     short loc_56F1
.text$mn:000056EF ; ---------------------------------------------------------------------------
.text$mn:000056EF
.text$mn:000056EF loc_56EF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:000056EF                 mov     al, 1
.text$mn:000056F1
.text$mn:000056F1 loc_56F1:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:000056F1                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:000056F1                 mov     esp, ebp
.text$mn:000056F3                 pop     ebp
.text$mn:000056F4                 retn    4
.text$mn:000056F4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:000056F4
.text$mn:000056F4 ; ---------------------------------------------------------------------------
.text$mn:000056F7                 align 4
.text$mn:000056F7 _text$mn        ends
.text$mn:000056F7
.text$mn:000056F8 ; ===========================================================================
.text$mn:000056F8
.text$mn:000056F8 ; Segment type: Pure code
.text$mn:000056F8 ; Segment permissions: Read/Execute
.text$mn:000056F8 _text$mn        segment para public 'CODE' use32
.text$mn:000056F8                 assume cs:_text$mn
.text$mn:000056F8                 ;org 56F8h
.text$mn:000056F8 ; COMDAT (pick any)
.text$mn:000056F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056F8
.text$mn:000056F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000056F8
.text$mn:000056F8 ; Attributes: bp-based frame
.text$mn:000056F8
.text$mn:000056F8 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000056F8                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:000056F8 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:000056F8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+2Cp
.text$mn:000056F8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap ...
.text$mn:000056F8
.text$mn:000056F8 var_4           = dword ptr -4
.text$mn:000056F8 arg_0           = dword ptr  8
.text$mn:000056F8
.text$mn:000056F8                 push    ebp
.text$mn:000056F9                 mov     ebp, esp
.text$mn:000056FB                 push    ecx
.text$mn:000056FC                 mov     [ebp+var_4], ecx
.text$mn:000056FF                 cmp     [ebp+arg_0], 0
.text$mn:00005703                 jz      short loc_5728
.text$mn:00005705                 mov     ecx, [ebp+var_4]
.text$mn:00005708                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000570D                 cmp     [ebp+arg_0], eax
.text$mn:00005710                 jb      short loc_5728
.text$mn:00005712                 mov     ecx, [ebp+var_4]
.text$mn:00005715                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000571A                 mov     ecx, [ebp+var_4]
.text$mn:0000571D                 mov     edx, [ecx+14h]
.text$mn:00005720                 lea     eax, [eax+edx*2]
.text$mn:00005723                 cmp     eax, [ebp+arg_0]
.text$mn:00005726                 ja      short loc_572E
.text$mn:00005728
.text$mn:00005728 loc_5728:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00005728                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00005728                 xor     al, al
.text$mn:0000572A                 jmp     short loc_5730
.text$mn:0000572C ; ---------------------------------------------------------------------------
.text$mn:0000572C                 jmp     short loc_5730
.text$mn:0000572E ; ---------------------------------------------------------------------------
.text$mn:0000572E
.text$mn:0000572E loc_572E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:0000572E                 mov     al, 1
.text$mn:00005730
.text$mn:00005730 loc_5730:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00005730                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00005730                 mov     esp, ebp
.text$mn:00005732                 pop     ebp
.text$mn:00005733                 retn    4
.text$mn:00005733 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:00005733
.text$mn:00005733 ; ---------------------------------------------------------------------------
.text$mn:00005736                 align 4
.text$mn:00005736 _text$mn        ends
.text$mn:00005736
.text$mn:00005738 ; ===========================================================================
.text$mn:00005738
.text$mn:00005738 ; Segment type: Pure code
.text$mn:00005738 ; Segment permissions: Read/Execute
.text$mn:00005738 _text$mn        segment para public 'CODE' use32
.text$mn:00005738                 assume cs:_text$mn
.text$mn:00005738                 ;org 5738h
.text$mn:00005738 ; COMDAT (pick any)
.text$mn:00005738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005738
.text$mn:00005738 ; =============== S U B R O U T I N E =======================================
.text$mn:00005738
.text$mn:00005738 ; Attributes: bp-based frame
.text$mn:00005738
.text$mn:00005738 ; protected: bool __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Inside(class UserCommand const *)const
.text$mn:00005738                 public ?_Inside@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBE_NPBVUserCommand@@@Z
.text$mn:00005738 ?_Inside@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBE_NPBVUserCommand@@@Z proc near
.text$mn:00005738                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+19p
.text$mn:00005738
.text$mn:00005738 var_8           = dword ptr -8
.text$mn:00005738 var_4           = dword ptr -4
.text$mn:00005738 arg_0           = dword ptr  8
.text$mn:00005738
.text$mn:00005738                 push    ebp
.text$mn:00005739                 mov     ebp, esp
.text$mn:0000573B                 sub     esp, 8
.text$mn:0000573E                 mov     [ebp+var_4], ecx
.text$mn:00005741                 mov     eax, [ebp+var_4]
.text$mn:00005744                 mov     ecx, [ebp+arg_0]
.text$mn:00005747                 cmp     ecx, [eax+8]
.text$mn:0000574A                 jnb     short loc_5760
.text$mn:0000574C                 mov     edx, [ebp+var_4]
.text$mn:0000574F                 mov     eax, [edx+4]
.text$mn:00005752                 cmp     eax, [ebp+arg_0]
.text$mn:00005755                 ja      short loc_5760
.text$mn:00005757                 mov     [ebp+var_8], 1
.text$mn:0000575E                 jmp     short loc_5767
.text$mn:00005760 ; ---------------------------------------------------------------------------
.text$mn:00005760
.text$mn:00005760 loc_5760:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Inside(UserCommand const *)+12j
.text$mn:00005760                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Inside(UserCommand const *)+1Dj
.text$mn:00005760                 mov     [ebp+var_8], 0
.text$mn:00005767
.text$mn:00005767 loc_5767:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Inside(UserCommand const *)+26j
.text$mn:00005767                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000576A                 mov     esp, ebp
.text$mn:0000576C                 pop     ebp
.text$mn:0000576D                 retn    4
.text$mn:0000576D ?_Inside@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBE_NPBVUserCommand@@@Z endp
.text$mn:0000576D
.text$mn:0000576D _text$mn        ends
.text$mn:0000576D
.text$mn:00005770 ; ===========================================================================
.text$mn:00005770
.text$mn:00005770 ; Segment type: Pure code
.text$mn:00005770 ; Segment permissions: Read/Execute
.text$mn:00005770 _text$mn        segment para public 'CODE' use32
.text$mn:00005770                 assume cs:_text$mn
.text$mn:00005770                 ;org 5770h
.text$mn:00005770 ; COMDAT (pick any)
.text$mn:00005770                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005770
.text$mn:00005770 ; =============== S U B R O U T I N E =======================================
.text$mn:00005770
.text$mn:00005770 ; Attributes: bp-based frame
.text$mn:00005770
.text$mn:00005770 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00005770                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00005770 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00005770                                         ; CODE XREF: $LN19+14p
.text$mn:00005770                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00005770
.text$mn:00005770 var_8           = dword ptr -8
.text$mn:00005770 var_4           = dword ptr -4
.text$mn:00005770
.text$mn:00005770                 push    ebp
.text$mn:00005771                 mov     ebp, esp
.text$mn:00005773                 sub     esp, 8
.text$mn:00005776                 mov     [ebp+var_4], ecx
.text$mn:00005779                 mov     eax, [ebp+var_4]
.text$mn:0000577C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00005780                 jb      short loc_5796
.text$mn:00005782                 mov     ecx, [ebp+var_4]
.text$mn:00005785                 mov     edx, [ecx+4]
.text$mn:00005788                 push    edx
.text$mn:00005789                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000578E                 add     esp, 4
.text$mn:00005791                 mov     [ebp+var_8], eax
.text$mn:00005794                 jmp     short loc_579F
.text$mn:00005796 ; ---------------------------------------------------------------------------
.text$mn:00005796
.text$mn:00005796 loc_5796:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00005796                 mov     eax, [ebp+var_4]
.text$mn:00005799                 add     eax, 4
.text$mn:0000579C                 mov     [ebp+var_8], eax
.text$mn:0000579F
.text$mn:0000579F loc_579F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000579F                 mov     eax, [ebp+var_8]
.text$mn:000057A2                 mov     esp, ebp
.text$mn:000057A4                 pop     ebp
.text$mn:000057A5                 retn
.text$mn:000057A5 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:000057A5
.text$mn:000057A5 ; ---------------------------------------------------------------------------
.text$mn:000057A6                 align 4
.text$mn:000057A6 _text$mn        ends
.text$mn:000057A6
.text$mn:000057A8 ; ===========================================================================
.text$mn:000057A8
.text$mn:000057A8 ; Segment type: Pure code
.text$mn:000057A8 ; Segment permissions: Read/Execute
.text$mn:000057A8 _text$mn        segment para public 'CODE' use32
.text$mn:000057A8                 assume cs:_text$mn
.text$mn:000057A8                 ;org 57A8h
.text$mn:000057A8 ; COMDAT (pick any)
.text$mn:000057A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057A8
.text$mn:000057A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000057A8
.text$mn:000057A8 ; Attributes: bp-based frame
.text$mn:000057A8
.text$mn:000057A8 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:000057A8                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:000057A8 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:000057A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:000057A8
.text$mn:000057A8 var_8           = dword ptr -8
.text$mn:000057A8 var_4           = dword ptr -4
.text$mn:000057A8
.text$mn:000057A8                 push    ebp
.text$mn:000057A9                 mov     ebp, esp
.text$mn:000057AB                 sub     esp, 8
.text$mn:000057AE                 mov     [ebp+var_4], ecx
.text$mn:000057B1                 mov     eax, [ebp+var_4]
.text$mn:000057B4                 cmp     dword ptr [eax+18h], 10h
.text$mn:000057B8                 jb      short loc_57CE
.text$mn:000057BA                 mov     ecx, [ebp+var_4]
.text$mn:000057BD                 mov     edx, [ecx+4]
.text$mn:000057C0                 push    edx
.text$mn:000057C1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000057C6                 add     esp, 4
.text$mn:000057C9                 mov     [ebp+var_8], eax
.text$mn:000057CC                 jmp     short loc_57D7
.text$mn:000057CE ; ---------------------------------------------------------------------------
.text$mn:000057CE
.text$mn:000057CE loc_57CE:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000057CE                 mov     eax, [ebp+var_4]
.text$mn:000057D1                 add     eax, 4
.text$mn:000057D4                 mov     [ebp+var_8], eax
.text$mn:000057D7
.text$mn:000057D7 loc_57D7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000057D7                 mov     eax, [ebp+var_8]
.text$mn:000057DA                 mov     esp, ebp
.text$mn:000057DC                 pop     ebp
.text$mn:000057DD                 retn
.text$mn:000057DD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000057DD
.text$mn:000057DD ; ---------------------------------------------------------------------------
.text$mn:000057DE                 align 10h
.text$mn:000057DE _text$mn        ends
.text$mn:000057DE
.text$mn:000057E0 ; ===========================================================================
.text$mn:000057E0
.text$mn:000057E0 ; Segment type: Pure code
.text$mn:000057E0 ; Segment permissions: Read/Execute
.text$mn:000057E0 _text$mn        segment para public 'CODE' use32
.text$mn:000057E0                 assume cs:_text$mn
.text$mn:000057E0                 ;org 57E0h
.text$mn:000057E0 ; COMDAT (pick any)
.text$mn:000057E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000057E0
.text$mn:000057E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000057E0
.text$mn:000057E0 ; Attributes: bp-based frame
.text$mn:000057E0
.text$mn:000057E0 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000057E0                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:000057E0 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:000057E0                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+27p
.text$mn:000057E0                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+3Ep ...
.text$mn:000057E0
.text$mn:000057E0 var_8           = dword ptr -8
.text$mn:000057E0 var_4           = dword ptr -4
.text$mn:000057E0
.text$mn:000057E0                 push    ebp
.text$mn:000057E1                 mov     ebp, esp
.text$mn:000057E3                 sub     esp, 8
.text$mn:000057E6                 mov     [ebp+var_4], ecx
.text$mn:000057E9                 mov     eax, [ebp+var_4]
.text$mn:000057EC                 cmp     dword ptr [eax+18h], 8
.text$mn:000057F0                 jb      short loc_5806
.text$mn:000057F2                 mov     ecx, [ebp+var_4]
.text$mn:000057F5                 mov     edx, [ecx+4]
.text$mn:000057F8                 push    edx
.text$mn:000057F9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000057FE                 add     esp, 4
.text$mn:00005801                 mov     [ebp+var_8], eax
.text$mn:00005804                 jmp     short loc_580F
.text$mn:00005806 ; ---------------------------------------------------------------------------
.text$mn:00005806
.text$mn:00005806 loc_5806:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:00005806                 mov     eax, [ebp+var_4]
.text$mn:00005809                 add     eax, 4
.text$mn:0000580C                 mov     [ebp+var_8], eax
.text$mn:0000580F
.text$mn:0000580F loc_580F:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:0000580F                 mov     eax, [ebp+var_8]
.text$mn:00005812                 mov     esp, ebp
.text$mn:00005814                 pop     ebp
.text$mn:00005815                 retn
.text$mn:00005815 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:00005815
.text$mn:00005815 ; ---------------------------------------------------------------------------
.text$mn:00005816                 align 4
.text$mn:00005816 _text$mn        ends
.text$mn:00005816
.text$mn:00005818 ; ===========================================================================
.text$mn:00005818
.text$mn:00005818 ; Segment type: Pure code
.text$mn:00005818 ; Segment permissions: Read/Execute
.text$mn:00005818 _text$mn        segment para public 'CODE' use32
.text$mn:00005818                 assume cs:_text$mn
.text$mn:00005818                 ;org 5818h
.text$mn:00005818 ; COMDAT (pick any)
.text$mn:00005818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005818
.text$mn:00005818 ; =============== S U B R O U T I N E =======================================
.text$mn:00005818
.text$mn:00005818 ; Attributes: bp-based frame
.text$mn:00005818
.text$mn:00005818 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:00005818                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:00005818 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:00005818                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+80p
.text$mn:00005818                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp ...
.text$mn:00005818
.text$mn:00005818 var_8           = dword ptr -8
.text$mn:00005818 var_4           = dword ptr -4
.text$mn:00005818
.text$mn:00005818                 push    ebp
.text$mn:00005819                 mov     ebp, esp
.text$mn:0000581B                 sub     esp, 8
.text$mn:0000581E                 mov     [ebp+var_4], ecx
.text$mn:00005821                 mov     eax, [ebp+var_4]
.text$mn:00005824                 cmp     dword ptr [eax+18h], 8
.text$mn:00005828                 jb      short loc_583E
.text$mn:0000582A                 mov     ecx, [ebp+var_4]
.text$mn:0000582D                 mov     edx, [ecx+4]
.text$mn:00005830                 push    edx
.text$mn:00005831                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00005836                 add     esp, 4
.text$mn:00005839                 mov     [ebp+var_8], eax
.text$mn:0000583C                 jmp     short loc_5847
.text$mn:0000583E ; ---------------------------------------------------------------------------
.text$mn:0000583E
.text$mn:0000583E loc_583E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000583E                 mov     eax, [ebp+var_4]
.text$mn:00005841                 add     eax, 4
.text$mn:00005844                 mov     [ebp+var_8], eax
.text$mn:00005847
.text$mn:00005847 loc_5847:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00005847                 mov     eax, [ebp+var_8]
.text$mn:0000584A                 mov     esp, ebp
.text$mn:0000584C                 pop     ebp
.text$mn:0000584D                 retn
.text$mn:0000584D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:0000584D
.text$mn:0000584D ; ---------------------------------------------------------------------------
.text$mn:0000584E                 align 10h
.text$mn:0000584E _text$mn        ends
.text$mn:0000584E
.text$mn:00005850 ; ===========================================================================
.text$mn:00005850
.text$mn:00005850 ; Segment type: Pure code
.text$mn:00005850 ; Segment permissions: Read/Execute
.text$mn:00005850 _text$mn        segment para public 'CODE' use32
.text$mn:00005850                 assume cs:_text$mn
.text$mn:00005850                 ;org 5850h
.text$mn:00005850 ; COMDAT (pick any)
.text$mn:00005850                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005850
.text$mn:00005850 ; =============== S U B R O U T I N E =======================================
.text$mn:00005850
.text$mn:00005850 ; Attributes: bp-based frame
.text$mn:00005850
.text$mn:00005850 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00005850                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00005850 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00005850                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00005850                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00005850
.text$mn:00005850 var_18          = byte ptr -18h
.text$mn:00005850 var_14          = dword ptr -14h
.text$mn:00005850 var_10          = dword ptr -10h
.text$mn:00005850 var_C           = dword ptr -0Ch
.text$mn:00005850 var_4           = dword ptr -4
.text$mn:00005850
.text$mn:00005850                 push    ebp
.text$mn:00005851                 mov     ebp, esp
.text$mn:00005853                 push    0FFFFFFFFh
.text$mn:00005855                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000585A                 mov     eax, large fs:0
.text$mn:00005860                 push    eax
.text$mn:00005861                 sub     esp, 0Ch
.text$mn:00005864                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005869                 xor     eax, ebp
.text$mn:0000586B                 push    eax
.text$mn:0000586C                 lea     eax, [ebp+var_C]
.text$mn:0000586F                 mov     large fs:0, eax
.text$mn:00005875                 mov     [ebp+var_14], ecx
.text$mn:00005878                 mov     eax, [ebp+var_14]
.text$mn:0000587B                 cmp     dword ptr [eax], 0
.text$mn:0000587E                 jz      short loc_58DB
.text$mn:00005880                 push    3               ; int
.text$mn:00005882                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005885                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000588A                 mov     [ebp+var_4], 0
.text$mn:00005891                 mov     ecx, [ebp+var_14]
.text$mn:00005894                 mov     edx, [ecx]
.text$mn:00005896                 add     edx, 4
.text$mn:00005899                 mov     [ebp+var_10], edx
.text$mn:0000589C                 jmp     short loc_58AB
.text$mn:0000589E ; ---------------------------------------------------------------------------
.text$mn:0000589E
.text$mn:0000589E loc_589E:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000589E                 mov     eax, [ebp+var_10]
.text$mn:000058A1                 mov     ecx, [eax]
.text$mn:000058A3                 mov     edx, [ebp+var_10]
.text$mn:000058A6                 mov     eax, [ecx+4]
.text$mn:000058A9                 mov     [edx], eax
.text$mn:000058AB
.text$mn:000058AB loc_58AB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000058AB                 mov     ecx, [ebp+var_10]
.text$mn:000058AE                 cmp     dword ptr [ecx], 0
.text$mn:000058B1                 jz      short loc_58C0
.text$mn:000058B3                 mov     edx, [ebp+var_10]
.text$mn:000058B6                 mov     eax, [edx]
.text$mn:000058B8                 mov     dword ptr [eax], 0
.text$mn:000058BE                 jmp     short loc_589E
.text$mn:000058C0 ; ---------------------------------------------------------------------------
.text$mn:000058C0
.text$mn:000058C0 loc_58C0:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000058C0                 mov     ecx, [ebp+var_14]
.text$mn:000058C3                 mov     edx, [ecx]
.text$mn:000058C5                 mov     dword ptr [edx+4], 0
.text$mn:000058CC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000058D3                 lea     ecx, [ebp+var_18] ; this
.text$mn:000058D6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000058DB
.text$mn:000058DB loc_58DB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000058DB                 mov     ecx, [ebp+var_C]
.text$mn:000058DE                 mov     large fs:0, ecx
.text$mn:000058E5                 pop     ecx
.text$mn:000058E6                 mov     esp, ebp
.text$mn:000058E8                 pop     ebp
.text$mn:000058E9                 retn
.text$mn:000058E9 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000058E9
.text$mn:000058E9 ; ---------------------------------------------------------------------------
.text$mn:000058EA                 align 4
.text$mn:000058EA _text$mn        ends
.text$mn:000058EA
.text$x:000058EC ; ===========================================================================
.text$x:000058EC
.text$x:000058EC ; Segment type: Pure code
.text$x:000058EC ; Segment permissions: Read/Execute
.text$x:000058EC _text$x         segment para public 'CODE' use32
.text$x:000058EC                 assume cs:_text$x
.text$x:000058EC                 ;org 58ECh
.text$x:000058EC ; COMDAT (pick associative to section at 5850)
.text$x:000058EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000058EC
.text$x:000058EC ; =============== S U B R O U T I N E =======================================
.text$x:000058EC
.text$x:000058EC
.text$x:000058EC __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000058EC                                         ; DATA XREF: .xdata$x:00008054o
.text$x:000058EC                 lea     ecx, [ebp-18h]  ; this
.text$x:000058EF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000058EF __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000058EF
.text$x:000058F4
.text$x:000058F4 ; =============== S U B R O U T I N E =======================================
.text$x:000058F4
.text$x:000058F4
.text$x:000058F4 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000058F4                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000058F4
.text$x:000058F4 arg_4           = dword ptr  8
.text$x:000058F4
.text$x:000058F4                 mov     edx, [esp+arg_4]
.text$x:000058F8                 lea     eax, [edx+0Ch]
.text$x:000058FB                 mov     ecx, [edx-10h]
.text$x:000058FE                 xor     ecx, eax
.text$x:00005900                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005905                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000590A                 jmp     ___CxxFrameHandler3
.text$x:0000590A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000590A
.text$x:0000590A ; ---------------------------------------------------------------------------
.text$x:0000590F                 align 10h
.text$x:0000590F _text$x         ends
.text$x:0000590F
.text$mn:00005910 ; ===========================================================================
.text$mn:00005910
.text$mn:00005910 ; Segment type: Pure code
.text$mn:00005910 ; Segment permissions: Read/Execute
.text$mn:00005910 _text$mn        segment para public 'CODE' use32
.text$mn:00005910                 assume cs:_text$mn
.text$mn:00005910                 ;org 5910h
.text$mn:00005910 ; COMDAT (pick any)
.text$mn:00005910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005910
.text$mn:00005910 ; =============== S U B R O U T I N E =======================================
.text$mn:00005910
.text$mn:00005910 ; Attributes: bp-based frame
.text$mn:00005910
.text$mn:00005910 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00005910                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00005910 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00005910                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00005910                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00005910
.text$mn:00005910 var_8           = dword ptr -8
.text$mn:00005910 var_4           = dword ptr -4
.text$mn:00005910
.text$mn:00005910                 push    ebp
.text$mn:00005911                 mov     ebp, esp
.text$mn:00005913                 sub     esp, 8
.text$mn:00005916                 mov     [ebp+var_8], ecx
.text$mn:00005919                 mov     eax, [ebp+var_8]
.text$mn:0000591C                 cmp     dword ptr [eax], 0
.text$mn:0000591F                 jz      short loc_597E
.text$mn:00005921                 mov     ecx, [ebp+var_8]
.text$mn:00005924                 mov     edx, [ecx]
.text$mn:00005926                 add     edx, 4
.text$mn:00005929                 mov     [ebp+var_4], edx
.text$mn:0000592C
.text$mn:0000592C loc_592C:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:0000592C                 mov     eax, [ebp+var_4]
.text$mn:0000592F                 cmp     dword ptr [eax], 0
.text$mn:00005932                 jz      short loc_594B
.text$mn:00005934                 mov     ecx, [ebp+var_4]
.text$mn:00005937                 mov     edx, [ecx]
.text$mn:00005939                 cmp     edx, [ebp+var_8]
.text$mn:0000593C                 jz      short loc_594B
.text$mn:0000593E                 mov     eax, [ebp+var_4]
.text$mn:00005941                 mov     ecx, [eax]
.text$mn:00005943                 add     ecx, 4
.text$mn:00005946                 mov     [ebp+var_4], ecx
.text$mn:00005949                 jmp     short loc_592C
.text$mn:0000594B ; ---------------------------------------------------------------------------
.text$mn:0000594B
.text$mn:0000594B loc_594B:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:0000594B                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:0000594B                 mov     edx, [ebp+var_4]
.text$mn:0000594E                 cmp     dword ptr [edx], 0
.text$mn:00005951                 jnz     short loc_596A
.text$mn:00005953                 push    0C9h ; '+'      ; unsigned int
.text$mn:00005958                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000595D                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:00005962                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005967                 add     esp, 0Ch
.text$mn:0000596A
.text$mn:0000596A loc_596A:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:0000596A                 mov     eax, [ebp+var_4]
.text$mn:0000596D                 mov     ecx, [ebp+var_8]
.text$mn:00005970                 mov     edx, [ecx+4]
.text$mn:00005973                 mov     [eax], edx
.text$mn:00005975                 mov     eax, [ebp+var_8]
.text$mn:00005978                 mov     dword ptr [eax], 0
.text$mn:0000597E
.text$mn:0000597E loc_597E:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:0000597E                 mov     esp, ebp
.text$mn:00005980                 pop     ebp
.text$mn:00005981                 retn
.text$mn:00005981 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:00005981
.text$mn:00005981 ; ---------------------------------------------------------------------------
.text$mn:00005982                 align 4
.text$mn:00005982 _text$mn        ends
.text$mn:00005982
.text$mn:00005984 ; ===========================================================================
.text$mn:00005984
.text$mn:00005984 ; Segment type: Pure code
.text$mn:00005984 ; Segment permissions: Read/Execute
.text$mn:00005984 _text$mn        segment para public 'CODE' use32
.text$mn:00005984                 assume cs:_text$mn
.text$mn:00005984                 ;org 5984h
.text$mn:00005984 ; COMDAT (pick any)
.text$mn:00005984                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005984
.text$mn:00005984 ; =============== S U B R O U T I N E =======================================
.text$mn:00005984
.text$mn:00005984 ; Attributes: bp-based frame
.text$mn:00005984
.text$mn:00005984 ; protected: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Orphan_range(class UserCommand *, class UserCommand *)const
.text$mn:00005984                 public ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.text$mn:00005984 ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z proc near
.text$mn:00005984                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+6Fp
.text$mn:00005984                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+D8p
.text$mn:00005984
.text$mn:00005984 var_18          = byte ptr -18h
.text$mn:00005984 var_14          = dword ptr -14h
.text$mn:00005984 var_10          = dword ptr -10h
.text$mn:00005984 var_C           = dword ptr -0Ch
.text$mn:00005984 var_4           = dword ptr -4
.text$mn:00005984 arg_0           = dword ptr  8
.text$mn:00005984 arg_4           = dword ptr  0Ch
.text$mn:00005984
.text$mn:00005984                 push    ebp
.text$mn:00005985                 mov     ebp, esp
.text$mn:00005987                 push    0FFFFFFFFh
.text$mn:00005989                 push    offset __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.text$mn:0000598E                 mov     eax, large fs:0
.text$mn:00005994                 push    eax
.text$mn:00005995                 sub     esp, 0Ch
.text$mn:00005998                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000599D                 xor     eax, ebp
.text$mn:0000599F                 push    eax
.text$mn:000059A0                 lea     eax, [ebp+var_C]
.text$mn:000059A3                 mov     large fs:0, eax
.text$mn:000059A9                 mov     [ebp+var_14], ecx
.text$mn:000059AC                 push    3               ; int
.text$mn:000059AE                 lea     ecx, [ebp+var_18] ; this
.text$mn:000059B1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000059B6                 mov     [ebp+var_4], 0
.text$mn:000059BD                 mov     ecx, [ebp+var_14] ; this
.text$mn:000059C0                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:000059C5                 mov     [ebp+var_10], eax
.text$mn:000059C8                 cmp     [ebp+var_10], 0
.text$mn:000059CC                 jz      short loc_5A1C
.text$mn:000059CE
.text$mn:000059CE loc_59CE:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *):loc_5A1Aj
.text$mn:000059CE                 mov     eax, [ebp+var_10]
.text$mn:000059D1                 cmp     dword ptr [eax], 0
.text$mn:000059D4                 jz      short loc_5A1C
.text$mn:000059D6                 mov     ecx, [ebp+var_10]
.text$mn:000059D9                 mov     edx, [ecx]
.text$mn:000059DB                 mov     eax, [edx+8]
.text$mn:000059DE                 cmp     eax, [ebp+arg_0]
.text$mn:000059E1                 jb      short loc_59F0
.text$mn:000059E3                 mov     ecx, [ebp+var_10]
.text$mn:000059E6                 mov     edx, [ecx]
.text$mn:000059E8                 mov     eax, [ebp+arg_4]
.text$mn:000059EB                 cmp     eax, [edx+8]
.text$mn:000059EE                 jnb     short loc_59FF
.text$mn:000059F0
.text$mn:000059F0 loc_59F0:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+5Dj
.text$mn:000059F0                 mov     ecx, [ebp+var_10]
.text$mn:000059F3                 mov     ecx, [ecx]      ; this
.text$mn:000059F5                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:000059FA                 mov     [ebp+var_10], eax
.text$mn:000059FD                 jmp     short loc_5A1A
.text$mn:000059FF ; ---------------------------------------------------------------------------
.text$mn:000059FF
.text$mn:000059FF loc_59FF:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+6Aj
.text$mn:000059FF                 mov     edx, [ebp+var_10]
.text$mn:00005A02                 mov     ecx, [edx]      ; this
.text$mn:00005A04                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00005A09                 mov     eax, [ebp+var_10]
.text$mn:00005A0C                 mov     ecx, [eax]      ; this
.text$mn:00005A0E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00005A13                 mov     ecx, [ebp+var_10]
.text$mn:00005A16                 mov     edx, [eax]
.text$mn:00005A18                 mov     [ecx], edx
.text$mn:00005A1A
.text$mn:00005A1A loc_5A1A:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+79j
.text$mn:00005A1A                 jmp     short loc_59CE
.text$mn:00005A1C ; ---------------------------------------------------------------------------
.text$mn:00005A1C
.text$mn:00005A1C loc_5A1C:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+48j
.text$mn:00005A1C                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+50j
.text$mn:00005A1C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005A23                 lea     ecx, [ebp+var_18] ; this
.text$mn:00005A26                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005A2B                 mov     ecx, [ebp+var_C]
.text$mn:00005A2E                 mov     large fs:0, ecx
.text$mn:00005A35                 pop     ecx
.text$mn:00005A36                 mov     esp, ebp
.text$mn:00005A38                 pop     ebp
.text$mn:00005A39                 retn    8
.text$mn:00005A39 ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z endp
.text$mn:00005A39
.text$mn:00005A39 _text$mn        ends
.text$mn:00005A39
.text$x:00005A3C ; ===========================================================================
.text$x:00005A3C
.text$x:00005A3C ; Segment type: Pure code
.text$x:00005A3C ; Segment permissions: Read/Execute
.text$x:00005A3C _text$x         segment para public 'CODE' use32
.text$x:00005A3C                 assume cs:_text$x
.text$x:00005A3C                 ;org 5A3Ch
.text$x:00005A3C ; COMDAT (pick associative to section at 5984)
.text$x:00005A3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005A3C
.text$x:00005A3C ; =============== S U B R O U T I N E =======================================
.text$x:00005A3C
.text$x:00005A3C
.text$x:00005A3C __unwindfunclet$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z$0 proc near
.text$x:00005A3C                                         ; DATA XREF: .xdata$x:00008A78o
.text$x:00005A3C                 lea     ecx, [ebp-18h]  ; this
.text$x:00005A3F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005A3F __unwindfunclet$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z$0 endp
.text$x:00005A3F
.text$x:00005A44
.text$x:00005A44 ; =============== S U B R O U T I N E =======================================
.text$x:00005A44
.text$x:00005A44
.text$x:00005A44 __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z proc near
.text$x:00005A44                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)+5o
.text$x:00005A44
.text$x:00005A44 arg_4           = dword ptr  8
.text$x:00005A44
.text$x:00005A44                 mov     edx, [esp+arg_4]
.text$x:00005A48                 lea     eax, [edx+0Ch]
.text$x:00005A4B                 mov     ecx, [edx-10h]
.text$x:00005A4E                 xor     ecx, eax
.text$x:00005A50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005A55                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.text$x:00005A5A                 jmp     ___CxxFrameHandler3
.text$x:00005A5A __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z endp
.text$x:00005A5A
.text$x:00005A5A ; ---------------------------------------------------------------------------
.text$x:00005A5F                 align 10h
.text$x:00005A5F _text$x         ends
.text$x:00005A5F
.text$mn:00005A60 ; ===========================================================================
.text$mn:00005A60
.text$mn:00005A60 ; Segment type: Pure code
.text$mn:00005A60 ; Segment permissions: Read/Execute
.text$mn:00005A60 _text$mn        segment para public 'CODE' use32
.text$mn:00005A60                 assume cs:_text$mn
.text$mn:00005A60                 ;org 5A60h
.text$mn:00005A60 ; COMDAT (pick any)
.text$mn:00005A60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005A60
.text$mn:00005A60 ; =============== S U B R O U T I N E =======================================
.text$mn:00005A60
.text$mn:00005A60 ; Attributes: bp-based frame
.text$mn:00005A60
.text$mn:00005A60 ; public: static unsigned int __cdecl std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Pdif(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:00005A60                 public ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$mn:00005A60 ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z proc near
.text$mn:00005A60                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+89p
.text$mn:00005A60                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+FAp ...
.text$mn:00005A60
.text$mn:00005A60 var_14          = dword ptr -14h
.text$mn:00005A60 var_10          = dword ptr -10h
.text$mn:00005A60 var_C           = dword ptr -0Ch
.text$mn:00005A60 var_4           = dword ptr -4
.text$mn:00005A60 arg_0           = byte ptr  8
.text$mn:00005A60 arg_8           = dword ptr  10h
.text$mn:00005A60 arg_C           = byte ptr  14h
.text$mn:00005A60
.text$mn:00005A60                 push    ebp
.text$mn:00005A61                 mov     ebp, esp
.text$mn:00005A63                 push    0FFFFFFFFh
.text$mn:00005A65                 push    offset __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$mn:00005A6A                 mov     eax, large fs:0
.text$mn:00005A70                 push    eax
.text$mn:00005A71                 sub     esp, 8
.text$mn:00005A74                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005A79                 xor     eax, ebp
.text$mn:00005A7B                 push    eax
.text$mn:00005A7C                 lea     eax, [ebp+var_C]
.text$mn:00005A7F                 mov     large fs:0, eax
.text$mn:00005A85                 mov     [ebp+var_4], 1
.text$mn:00005A8C                 cmp     [ebp+arg_8], 0
.text$mn:00005A90                 jnz     short loc_5A9B
.text$mn:00005A92                 mov     [ebp+var_10], 0
.text$mn:00005A99                 jmp     short loc_5AAA
.text$mn:00005A9B ; ---------------------------------------------------------------------------
.text$mn:00005A9B
.text$mn:00005A9B loc_5A9B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+30j
.text$mn:00005A9B                 lea     eax, [ebp+arg_C]
.text$mn:00005A9E                 push    eax             ; std::_Iterator_base12 *
.text$mn:00005A9F                 lea     ecx, [ebp+arg_0]
.text$mn:00005AA2                 call    ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00005AA7                 mov     [ebp+var_10], eax
.text$mn:00005AAA
.text$mn:00005AAA loc_5AAA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+39j
.text$mn:00005AAA                 mov     ecx, [ebp+var_10]
.text$mn:00005AAD                 mov     [ebp+var_14], ecx
.text$mn:00005AB0                 mov     byte ptr [ebp+var_4], 0
.text$mn:00005AB4                 lea     ecx, [ebp+arg_0]
.text$mn:00005AB7                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00005ABC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005AC3                 lea     ecx, [ebp+arg_C]
.text$mn:00005AC6                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00005ACB                 mov     eax, [ebp+var_14]
.text$mn:00005ACE                 mov     ecx, [ebp+var_C]
.text$mn:00005AD1                 mov     large fs:0, ecx
.text$mn:00005AD8                 pop     ecx
.text$mn:00005AD9                 mov     esp, ebp
.text$mn:00005ADB                 pop     ebp
.text$mn:00005ADC                 retn
.text$mn:00005ADC ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z endp
.text$mn:00005ADC
.text$mn:00005ADC ; ---------------------------------------------------------------------------
.text$mn:00005ADD                 align 10h
.text$mn:00005ADD _text$mn        ends
.text$mn:00005ADD
.text$x:00005AE0 ; ===========================================================================
.text$x:00005AE0
.text$x:00005AE0 ; Segment type: Pure code
.text$x:00005AE0 ; Segment permissions: Read/Execute
.text$x:00005AE0 _text$x         segment para public 'CODE' use32
.text$x:00005AE0                 assume cs:_text$x
.text$x:00005AE0                 ;org 5AE0h
.text$x:00005AE0 ; COMDAT (pick associative to section at 5A60)
.text$x:00005AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005AE0
.text$x:00005AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00005AE0
.text$x:00005AE0
.text$x:00005AE0 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0 proc near
.text$x:00005AE0                                         ; DATA XREF: .xdata$x:00008764o
.text$x:00005AE0                 lea     ecx, [ebp+14h]
.text$x:00005AE3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005AE3 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0 endp
.text$x:00005AE3
.text$x:00005AE8
.text$x:00005AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00005AE8
.text$x:00005AE8
.text$x:00005AE8 __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1 proc near
.text$x:00005AE8                                         ; DATA XREF: .xdata$x:0000876Co
.text$x:00005AE8                 lea     ecx, [ebp+8]
.text$x:00005AEB                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00005AEB __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1 endp
.text$x:00005AEB
.text$x:00005AF0
.text$x:00005AF0 ; =============== S U B R O U T I N E =======================================
.text$x:00005AF0
.text$x:00005AF0
.text$x:00005AF0 __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z proc near
.text$x:00005AF0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00005AF0
.text$x:00005AF0 arg_4           = dword ptr  8
.text$x:00005AF0
.text$x:00005AF0                 mov     edx, [esp+arg_4]
.text$x:00005AF4                 lea     eax, [edx+0Ch]
.text$x:00005AF7                 mov     ecx, [edx-0Ch]
.text$x:00005AFA                 xor     ecx, eax
.text$x:00005AFC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B01                 mov     eax, offset __ehfuncinfo$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.text$x:00005B06                 jmp     ___CxxFrameHandler3
.text$x:00005B06 __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z endp
.text$x:00005B06
.text$x:00005B06 ; ---------------------------------------------------------------------------
.text$x:00005B0B                 align 4
.text$x:00005B0B _text$x         ends
.text$x:00005B0B
.text$mn:00005B0C ; ===========================================================================
.text$mn:00005B0C
.text$mn:00005B0C ; Segment type: Pure code
.text$mn:00005B0C ; Segment permissions: Read/Execute
.text$mn:00005B0C _text$mn        segment para public 'CODE' use32
.text$mn:00005B0C                 assume cs:_text$mn
.text$mn:00005B0C                 ;org 5B0Ch
.text$mn:00005B0C ; COMDAT (pick any)
.text$mn:00005B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B0C
.text$mn:00005B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00005B0C
.text$mn:00005B0C ; Attributes: bp-based frame
.text$mn:00005B0C
.text$mn:00005B0C ; protected: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Reallocate(unsigned int)
.text$mn:00005B0C                 public ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$mn:00005B0C ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z proc near
.text$mn:00005B0C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)+4Ep
.text$mn:00005B0C
.text$mn:00005B0C var_20          = dword ptr -20h
.text$mn:00005B0C var_1C          = dword ptr -1Ch
.text$mn:00005B0C var_18          = dword ptr -18h
.text$mn:00005B0C var_13          = byte ptr -13h
.text$mn:00005B0C var_11          = byte ptr -11h
.text$mn:00005B0C var_10          = dword ptr -10h
.text$mn:00005B0C var_C           = dword ptr -0Ch
.text$mn:00005B0C var_4           = dword ptr -4
.text$mn:00005B0C arg_0           = dword ptr  8
.text$mn:00005B0C
.text$mn:00005B0C ; FUNCTION CHUNK AT .text$mn:00005BA2 SIZE 00000009 BYTES
.text$mn:00005B0C ; FUNCTION CHUNK AT .text$mn:00005BB2 SIZE 0000009E BYTES
.text$mn:00005B0C
.text$mn:00005B0C                 push    ebp
.text$mn:00005B0D                 mov     ebp, esp
.text$mn:00005B0F                 push    0FFFFFFFFh
.text$mn:00005B11                 push    offset __ehhandler$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$mn:00005B16                 mov     eax, large fs:0
.text$mn:00005B1C                 push    eax
.text$mn:00005B1D                 push    ecx
.text$mn:00005B1E                 sub     esp, 10h
.text$mn:00005B21                 push    ebx
.text$mn:00005B22                 push    esi
.text$mn:00005B23                 push    edi
.text$mn:00005B24                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005B29                 xor     eax, ebp
.text$mn:00005B2B                 push    eax
.text$mn:00005B2C                 lea     eax, [ebp+var_C]
.text$mn:00005B2F                 mov     large fs:0, eax
.text$mn:00005B35                 mov     [ebp+var_10], esp
.text$mn:00005B38                 mov     [ebp+var_18], ecx
.text$mn:00005B3B                 mov     eax, [ebp+arg_0]
.text$mn:00005B3E                 push    eax
.text$mn:00005B3F                 lea     ecx, [ebp+var_11]
.text$mn:00005B42                 push    ecx
.text$mn:00005B43                 mov     ecx, [ebp+var_18]
.text$mn:00005B46                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:00005B4B                 mov     ecx, eax
.text$mn:00005B4D                 call    ?allocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEPAVUserCommand@@I@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::allocate(uint)
.text$mn:00005B52                 mov     [ebp+var_1C], eax
.text$mn:00005B55                 mov     [ebp+var_4], 0
.text$mn:00005B5C                 mov     edx, [ebp+var_1C]
.text$mn:00005B5F                 push    edx
.text$mn:00005B60                 mov     eax, [ebp+var_18]
.text$mn:00005B63                 mov     ecx, [eax+8]
.text$mn:00005B66                 push    ecx
.text$mn:00005B67                 mov     edx, [ebp+var_18]
.text$mn:00005B6A                 mov     eax, [edx+4]
.text$mn:00005B6D                 push    eax
.text$mn:00005B6E                 mov     ecx, [ebp+var_18]
.text$mn:00005B71                 call    ??$_Umove@PAVUserCommand@@@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEPAVUserCommand@@PAV2@00@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Umove<UserCommand *>(UserCommand *,UserCommand *,UserCommand *)
.text$mn:00005B76                 jmp     short loc_5BA2
.text$mn:00005B76 ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z endp
.text$mn:00005B76
.text$mn:00005B78
.text$mn:00005B78 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B78
.text$mn:00005B78 ; Attributes: noreturn
.text$mn:00005B78
.text$mn:00005B78 __catch$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z$0 proc near
.text$mn:00005B78                                         ; DATA XREF: .xdata$x:00008A28o
.text$mn:00005B78                 mov     ecx, [ebp+8]
.text$mn:00005B7B                 push    ecx             ; int
.text$mn:00005B7C                 mov     edx, [ebp-1Ch]
.text$mn:00005B7F                 push    edx             ; void *
.text$mn:00005B80                 lea     eax, [ebp-12h]
.text$mn:00005B83                 push    eax
.text$mn:00005B84                 mov     ecx, [ebp-18h]
.text$mn:00005B87                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:00005B8C                 mov     ecx, eax
.text$mn:00005B8E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@I@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::deallocate(UserCommand *,uint)
.text$mn:00005B93                 push    0
.text$mn:00005B95                 push    0
.text$mn:00005B97                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005B97 __catch$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z$0 endp
.text$mn:00005B97
.text$mn:00005B9C ; ---------------------------------------------------------------------------
.text$mn:00005B9C                 mov     eax, offset $LN8
.text$mn:00005BA1                 retn
.text$mn:00005BA2 ; ---------------------------------------------------------------------------
.text$mn:00005BA2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$mn:00005BA2
.text$mn:00005BA2 loc_5BA2:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+6Aj
.text$mn:00005BA2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005BA9                 jmp     short loc_5BB2
.text$mn:00005BA9 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$mn:00005BAB
.text$mn:00005BAB ; =============== S U B R O U T I N E =======================================
.text$mn:00005BAB
.text$mn:00005BAB
.text$mn:00005BAB $LN8            proc near               ; DATA XREF: .text$mn:00005B9Co
.text$mn:00005BAB                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005BAB $LN8            endp ; sp-analysis failed
.text$mn:00005BAB
.text$mn:00005BB2 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$mn:00005BB2
.text$mn:00005BB2 loc_5BB2:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+9Dj
.text$mn:00005BB2                 mov     ecx, [ebp+var_18]
.text$mn:00005BB5                 call    ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::size(void)
.text$mn:00005BBA                 mov     [ebp+var_20], eax
.text$mn:00005BBD                 mov     ecx, [ebp+var_18]
.text$mn:00005BC0                 cmp     dword ptr [ecx+4], 0
.text$mn:00005BC4                 jz      short loc_5C0B
.text$mn:00005BC6                 mov     edx, [ebp+var_18]
.text$mn:00005BC9                 mov     eax, [edx+8]
.text$mn:00005BCC                 push    eax
.text$mn:00005BCD                 mov     ecx, [ebp+var_18]
.text$mn:00005BD0                 mov     edx, [ecx+4]
.text$mn:00005BD3                 push    edx
.text$mn:00005BD4                 mov     ecx, [ebp+var_18]
.text$mn:00005BD7                 call    ?_Destroy@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXPAVUserCommand@@0@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Destroy(UserCommand *,UserCommand *)
.text$mn:00005BDC                 mov     eax, [ebp+var_18]
.text$mn:00005BDF                 mov     ecx, [ebp+var_18]
.text$mn:00005BE2                 mov     eax, [eax+0Ch]
.text$mn:00005BE5                 sub     eax, [ecx+4]
.text$mn:00005BE8                 cdq
.text$mn:00005BE9                 mov     ecx, 148h
.text$mn:00005BEE                 idiv    ecx
.text$mn:00005BF0                 push    eax             ; int
.text$mn:00005BF1                 mov     edx, [ebp+var_18]
.text$mn:00005BF4                 mov     eax, [edx+4]
.text$mn:00005BF7                 push    eax             ; void *
.text$mn:00005BF8                 lea     ecx, [ebp+var_13]
.text$mn:00005BFB                 push    ecx
.text$mn:00005BFC                 mov     ecx, [ebp+var_18]
.text$mn:00005BFF                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:00005C04                 mov     ecx, eax
.text$mn:00005C06                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@I@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::deallocate(UserCommand *,uint)
.text$mn:00005C0B
.text$mn:00005C0B loc_5C0B:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+B8j
.text$mn:00005C0B                 mov     ecx, [ebp+var_18] ; this
.text$mn:00005C0E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005C13                 imul    edx, [ebp+arg_0], 148h
.text$mn:00005C1A                 add     edx, [ebp+var_1C]
.text$mn:00005C1D                 mov     eax, [ebp+var_18]
.text$mn:00005C20                 mov     [eax+0Ch], edx
.text$mn:00005C23                 imul    ecx, [ebp+var_20], 148h
.text$mn:00005C2A                 add     ecx, [ebp+var_1C]
.text$mn:00005C2D                 mov     edx, [ebp+var_18]
.text$mn:00005C30                 mov     [edx+8], ecx
.text$mn:00005C33                 mov     eax, [ebp+var_18]
.text$mn:00005C36                 mov     ecx, [ebp+var_1C]
.text$mn:00005C39                 mov     [eax+4], ecx
.text$mn:00005C3C                 mov     ecx, [ebp+var_C]
.text$mn:00005C3F                 mov     large fs:0, ecx
.text$mn:00005C46                 pop     ecx
.text$mn:00005C47                 pop     edi
.text$mn:00005C48                 pop     esi
.text$mn:00005C49                 pop     ebx
.text$mn:00005C4A                 mov     esp, ebp
.text$mn:00005C4C                 pop     ebp
.text$mn:00005C4D                 retn    4
.text$mn:00005C4D ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$mn:00005C4D _text$mn        ends
.text$mn:00005C4D
.text$x:00005C50 ; ===========================================================================
.text$x:00005C50
.text$x:00005C50 ; Segment type: Pure code
.text$x:00005C50 ; Segment permissions: Read/Execute
.text$x:00005C50 _text$x         segment para public 'CODE' use32
.text$x:00005C50                 assume cs:_text$x
.text$x:00005C50                 ;org 5C50h
.text$x:00005C50 ; COMDAT (pick associative to section at 5B0C)
.text$x:00005C50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005C50
.text$x:00005C50 ; =============== S U B R O U T I N E =======================================
.text$x:00005C50
.text$x:00005C50
.text$x:00005C50 __ehhandler$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z proc near
.text$x:00005C50                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+5o
.text$x:00005C50
.text$x:00005C50 arg_4           = dword ptr  8
.text$x:00005C50
.text$x:00005C50                 mov     edx, [esp+arg_4]
.text$x:00005C54                 lea     eax, [edx+0Ch]
.text$x:00005C57                 mov     ecx, [edx-24h]
.text$x:00005C5A                 xor     ecx, eax
.text$x:00005C5C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005C61                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$x:00005C66                 jmp     ___CxxFrameHandler3
.text$x:00005C66 __ehhandler$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z endp
.text$x:00005C66
.text$x:00005C66 ; ---------------------------------------------------------------------------
.text$x:00005C6B                 align 4
.text$x:00005C6B _text$x         ends
.text$x:00005C6B
.text$mn:00005C6C ; ===========================================================================
.text$mn:00005C6C
.text$mn:00005C6C ; Segment type: Pure code
.text$mn:00005C6C ; Segment permissions: Read/Execute
.text$mn:00005C6C _text$mn        segment para public 'CODE' use32
.text$mn:00005C6C                 assume cs:_text$mn
.text$mn:00005C6C                 ;org 5C6Ch
.text$mn:00005C6C ; COMDAT (pick any)
.text$mn:00005C6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C6C
.text$mn:00005C6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C6C
.text$mn:00005C6C ; Attributes: bp-based frame
.text$mn:00005C6C
.text$mn:00005C6C ; protected: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Reserve(unsigned int)
.text$mn:00005C6C                 public ?_Reserve@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.text$mn:00005C6C ?_Reserve@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z proc near
.text$mn:00005C6C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+59p
.text$mn:00005C6C                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+C2p
.text$mn:00005C6C
.text$mn:00005C6C var_4           = dword ptr -4
.text$mn:00005C6C arg_0           = dword ptr  8
.text$mn:00005C6C
.text$mn:00005C6C                 push    ebp
.text$mn:00005C6D                 mov     ebp, esp
.text$mn:00005C6F                 push    ecx
.text$mn:00005C70                 push    esi
.text$mn:00005C71                 mov     [ebp+var_4], ecx
.text$mn:00005C74                 mov     ecx, [ebp+var_4]
.text$mn:00005C77                 call    ?_Unused_capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::_Unused_capacity(void)
.text$mn:00005C7C                 cmp     eax, [ebp+arg_0]
.text$mn:00005C7F                 jnb     short loc_5CBF
.text$mn:00005C81                 mov     ecx, [ebp+var_4]
.text$mn:00005C84                 call    ?max_size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::max_size(void)
.text$mn:00005C89                 mov     esi, eax
.text$mn:00005C8B                 mov     ecx, [ebp+var_4]
.text$mn:00005C8E                 call    ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::size(void)
.text$mn:00005C93                 sub     esi, eax
.text$mn:00005C95                 cmp     esi, [ebp+arg_0]
.text$mn:00005C98                 jnb     short loc_5CA2
.text$mn:00005C9A                 mov     ecx, [ebp+var_4]
.text$mn:00005C9D                 call    ?_Xlen@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::_Xlen(void)
.text$mn:00005CA2
.text$mn:00005CA2 loc_5CA2:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)+2Cj
.text$mn:00005CA2                 mov     ecx, [ebp+var_4]
.text$mn:00005CA5                 call    ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::vector<UserCommand,std::allocator<UserCommand>>::size(void)
.text$mn:00005CAA                 add     eax, [ebp+arg_0]
.text$mn:00005CAD                 push    eax
.text$mn:00005CAE                 mov     ecx, [ebp+var_4]
.text$mn:00005CB1                 call    ?_Grow_to@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEII@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Grow_to(uint)
.text$mn:00005CB6                 push    eax
.text$mn:00005CB7                 mov     ecx, [ebp+var_4]
.text$mn:00005CBA                 call    ?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)
.text$mn:00005CBF
.text$mn:00005CBF loc_5CBF:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)+13j
.text$mn:00005CBF                 pop     esi
.text$mn:00005CC0                 mov     esp, ebp
.text$mn:00005CC2                 pop     ebp
.text$mn:00005CC3                 retn    4
.text$mn:00005CC3 ?_Reserve@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z endp
.text$mn:00005CC3
.text$mn:00005CC3 ; ---------------------------------------------------------------------------
.text$mn:00005CC6                 align 4
.text$mn:00005CC6 _text$mn        ends
.text$mn:00005CC6
.text$mn:00005CC8 ; ===========================================================================
.text$mn:00005CC8
.text$mn:00005CC8 ; Segment type: Pure code
.text$mn:00005CC8 ; Segment permissions: Read/Execute
.text$mn:00005CC8 _text$mn        segment para public 'CODE' use32
.text$mn:00005CC8                 assume cs:_text$mn
.text$mn:00005CC8                 ;org 5CC8h
.text$mn:00005CC8 ; COMDAT (pick any)
.text$mn:00005CC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CC8
.text$mn:00005CC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CC8
.text$mn:00005CC8 ; Attributes: bp-based frame
.text$mn:00005CC8
.text$mn:00005CC8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00005CC8                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00005CC8 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00005CC8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00005CC8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00005CC8
.text$mn:00005CC8 var_C           = dword ptr -0Ch
.text$mn:00005CC8 var_8           = dword ptr -8
.text$mn:00005CC8 var_2           = byte ptr -2
.text$mn:00005CC8 var_1           = byte ptr -1
.text$mn:00005CC8 arg_0           = byte ptr  8
.text$mn:00005CC8 Size            = dword ptr  0Ch
.text$mn:00005CC8
.text$mn:00005CC8                 push    ebp
.text$mn:00005CC9                 mov     ebp, esp
.text$mn:00005CCB                 sub     esp, 0Ch
.text$mn:00005CCE                 mov     [ebp+var_8], ecx
.text$mn:00005CD1                 movzx   eax, [ebp+arg_0]
.text$mn:00005CD5                 test    eax, eax
.text$mn:00005CD7                 jnz     short loc_5CDB
.text$mn:00005CD9                 jmp     short loc_5D4E
.text$mn:00005CDB ; ---------------------------------------------------------------------------
.text$mn:00005CDB
.text$mn:00005CDB loc_5CDB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00005CDB                 mov     ecx, [ebp+var_8]
.text$mn:00005CDE                 cmp     dword ptr [ecx+18h], 10h
.text$mn:00005CE2                 jb      short loc_5D4E
.text$mn:00005CE4                 mov     edx, [ebp+var_8]
.text$mn:00005CE7                 mov     eax, [edx+4]
.text$mn:00005CEA                 mov     [ebp+var_C], eax
.text$mn:00005CED                 mov     ecx, [ebp+var_8]
.text$mn:00005CF0                 add     ecx, 4
.text$mn:00005CF3                 push    ecx
.text$mn:00005CF4                 lea     edx, [ebp+var_1]
.text$mn:00005CF7                 push    edx
.text$mn:00005CF8                 mov     ecx, [ebp+var_8]
.text$mn:00005CFB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005D00                 mov     ecx, eax
.text$mn:00005D02                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00005D07                 cmp     [ebp+Size], 0
.text$mn:00005D0B                 jbe     short loc_5D2D
.text$mn:00005D0D                 mov     eax, [ebp+Size]
.text$mn:00005D10                 push    eax             ; Size
.text$mn:00005D11                 mov     ecx, [ebp+var_C]
.text$mn:00005D14                 push    ecx
.text$mn:00005D15                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00005D1A                 add     esp, 4
.text$mn:00005D1D                 push    eax             ; Src
.text$mn:00005D1E                 mov     edx, [ebp+var_8]
.text$mn:00005D21                 add     edx, 4
.text$mn:00005D24                 push    edx             ; Dst
.text$mn:00005D25                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00005D2A                 add     esp, 0Ch
.text$mn:00005D2D
.text$mn:00005D2D loc_5D2D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00005D2D                 mov     eax, [ebp+var_8]
.text$mn:00005D30                 mov     ecx, [eax+18h]
.text$mn:00005D33                 add     ecx, 1
.text$mn:00005D36                 push    ecx             ; int
.text$mn:00005D37                 mov     edx, [ebp+var_C]
.text$mn:00005D3A                 push    edx             ; void *
.text$mn:00005D3B                 lea     eax, [ebp+var_2]
.text$mn:00005D3E                 push    eax
.text$mn:00005D3F                 mov     ecx, [ebp+var_8]
.text$mn:00005D42                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00005D47                 mov     ecx, eax
.text$mn:00005D49                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00005D4E
.text$mn:00005D4E loc_5D4E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00005D4E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00005D4E                 mov     ecx, [ebp+var_8]
.text$mn:00005D51                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00005D58                 mov     edx, [ebp+Size]
.text$mn:00005D5B                 push    edx
.text$mn:00005D5C                 mov     ecx, [ebp+var_8]
.text$mn:00005D5F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00005D64                 mov     esp, ebp
.text$mn:00005D66                 pop     ebp
.text$mn:00005D67                 retn    8
.text$mn:00005D67 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00005D67
.text$mn:00005D67 ; ---------------------------------------------------------------------------
.text$mn:00005D6A                 align 4
.text$mn:00005D6A _text$mn        ends
.text$mn:00005D6A
.text$mn:00005D6C ; ===========================================================================
.text$mn:00005D6C
.text$mn:00005D6C ; Segment type: Pure code
.text$mn:00005D6C ; Segment permissions: Read/Execute
.text$mn:00005D6C _text$mn        segment para public 'CODE' use32
.text$mn:00005D6C                 assume cs:_text$mn
.text$mn:00005D6C                 ;org 5D6Ch
.text$mn:00005D6C ; COMDAT (pick any)
.text$mn:00005D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D6C
.text$mn:00005D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005D6C
.text$mn:00005D6C ; Attributes: bp-based frame
.text$mn:00005D6C
.text$mn:00005D6C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00005D6C                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00005D6C ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00005D6C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+4Bp
.text$mn:00005D6C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+56p ...
.text$mn:00005D6C
.text$mn:00005D6C var_C           = dword ptr -0Ch
.text$mn:00005D6C var_8           = dword ptr -8
.text$mn:00005D6C var_2           = byte ptr -2
.text$mn:00005D6C var_1           = byte ptr -1
.text$mn:00005D6C arg_0           = byte ptr  8
.text$mn:00005D6C arg_4           = dword ptr  0Ch
.text$mn:00005D6C
.text$mn:00005D6C                 push    ebp
.text$mn:00005D6D                 mov     ebp, esp
.text$mn:00005D6F                 sub     esp, 0Ch
.text$mn:00005D72                 mov     [ebp+var_8], ecx
.text$mn:00005D75                 movzx   eax, [ebp+arg_0]
.text$mn:00005D79                 test    eax, eax
.text$mn:00005D7B                 jnz     short loc_5D7F
.text$mn:00005D7D                 jmp     short loc_5DF2
.text$mn:00005D7F ; ---------------------------------------------------------------------------
.text$mn:00005D7F
.text$mn:00005D7F loc_5D7F:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:00005D7F                 mov     ecx, [ebp+var_8]
.text$mn:00005D82                 cmp     dword ptr [ecx+18h], 8
.text$mn:00005D86                 jb      short loc_5DF2
.text$mn:00005D88                 mov     edx, [ebp+var_8]
.text$mn:00005D8B                 mov     eax, [edx+4]
.text$mn:00005D8E                 mov     [ebp+var_C], eax
.text$mn:00005D91                 mov     ecx, [ebp+var_8]
.text$mn:00005D94                 add     ecx, 4
.text$mn:00005D97                 push    ecx
.text$mn:00005D98                 lea     edx, [ebp+var_1]
.text$mn:00005D9B                 push    edx
.text$mn:00005D9C                 mov     ecx, [ebp+var_8]
.text$mn:00005D9F                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005DA4                 mov     ecx, eax
.text$mn:00005DA6                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00005DAB                 cmp     [ebp+arg_4], 0
.text$mn:00005DAF                 jbe     short loc_5DD1
.text$mn:00005DB1                 mov     eax, [ebp+arg_4]
.text$mn:00005DB4                 push    eax             ; int
.text$mn:00005DB5                 mov     ecx, [ebp+var_C]
.text$mn:00005DB8                 push    ecx
.text$mn:00005DB9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00005DBE                 add     esp, 4
.text$mn:00005DC1                 push    eax             ; Src
.text$mn:00005DC2                 mov     edx, [ebp+var_8]
.text$mn:00005DC5                 add     edx, 4
.text$mn:00005DC8                 push    edx             ; Dst
.text$mn:00005DC9                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00005DCE                 add     esp, 0Ch
.text$mn:00005DD1
.text$mn:00005DD1 loc_5DD1:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:00005DD1                 mov     eax, [ebp+var_8]
.text$mn:00005DD4                 mov     ecx, [eax+18h]
.text$mn:00005DD7                 add     ecx, 1
.text$mn:00005DDA                 push    ecx             ; int
.text$mn:00005DDB                 mov     edx, [ebp+var_C]
.text$mn:00005DDE                 push    edx             ; void *
.text$mn:00005DDF                 lea     eax, [ebp+var_2]
.text$mn:00005DE2                 push    eax
.text$mn:00005DE3                 mov     ecx, [ebp+var_8]
.text$mn:00005DE6                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00005DEB                 mov     ecx, eax
.text$mn:00005DED                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00005DF2
.text$mn:00005DF2 loc_5DF2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00005DF2                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00005DF2                 mov     ecx, [ebp+var_8]
.text$mn:00005DF5                 mov     dword ptr [ecx+18h], 7
.text$mn:00005DFC                 mov     edx, [ebp+arg_4]
.text$mn:00005DFF                 push    edx
.text$mn:00005E00                 mov     ecx, [ebp+var_8]
.text$mn:00005E03                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00005E08                 mov     esp, ebp
.text$mn:00005E0A                 pop     ebp
.text$mn:00005E0B                 retn    8
.text$mn:00005E0B ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00005E0B
.text$mn:00005E0B ; ---------------------------------------------------------------------------
.text$mn:00005E0E                 align 10h
.text$mn:00005E0E _text$mn        ends
.text$mn:00005E0E
.text$mn:00005E10 ; ===========================================================================
.text$mn:00005E10
.text$mn:00005E10 ; Segment type: Pure code
.text$mn:00005E10 ; Segment permissions: Read/Execute
.text$mn:00005E10 _text$mn        segment para public 'CODE' use32
.text$mn:00005E10                 assume cs:_text$mn
.text$mn:00005E10                 ;org 5E10h
.text$mn:00005E10 ; COMDAT (pick any)
.text$mn:00005E10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E10
.text$mn:00005E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E10
.text$mn:00005E10 ; Attributes: bp-based frame
.text$mn:00005E10
.text$mn:00005E10 ; public: unsigned int __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Unused_capacity(void)const
.text$mn:00005E10                 public ?_Unused_capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ
.text$mn:00005E10 ?_Unused_capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:00005E10                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)+Bp
.text$mn:00005E10
.text$mn:00005E10 var_4           = dword ptr -4
.text$mn:00005E10
.text$mn:00005E10                 push    ebp
.text$mn:00005E11                 mov     ebp, esp
.text$mn:00005E13                 push    ecx
.text$mn:00005E14                 mov     [ebp+var_4], ecx
.text$mn:00005E17                 mov     eax, [ebp+var_4]
.text$mn:00005E1A                 mov     ecx, [ebp+var_4]
.text$mn:00005E1D                 mov     eax, [eax+0Ch]
.text$mn:00005E20                 sub     eax, [ecx+8]
.text$mn:00005E23                 cdq
.text$mn:00005E24                 mov     ecx, 148h
.text$mn:00005E29                 idiv    ecx
.text$mn:00005E2B                 mov     esp, ebp
.text$mn:00005E2D                 pop     ebp
.text$mn:00005E2E                 retn
.text$mn:00005E2E ?_Unused_capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ endp
.text$mn:00005E2E
.text$mn:00005E2E ; ---------------------------------------------------------------------------
.text$mn:00005E2F                 align 10h
.text$mn:00005E2F _text$mn        ends
.text$mn:00005E2F
.text$mn:00005E30 ; ===========================================================================
.text$mn:00005E30
.text$mn:00005E30 ; Segment type: Pure code
.text$mn:00005E30 ; Segment permissions: Read/Execute
.text$mn:00005E30 _text$mn        segment para public 'CODE' use32
.text$mn:00005E30                 assume cs:_text$mn
.text$mn:00005E30                 ;org 5E30h
.text$mn:00005E30 ; COMDAT (pick any)
.text$mn:00005E30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E30
.text$mn:00005E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E30
.text$mn:00005E30 ; Attributes: bp-based frame
.text$mn:00005E30
.text$mn:00005E30 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00005E30                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00005E30 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00005E30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00005E30
.text$mn:00005E30 var_4           = dword ptr -4
.text$mn:00005E30
.text$mn:00005E30                 push    ebp
.text$mn:00005E31                 mov     ebp, esp
.text$mn:00005E33                 push    ecx
.text$mn:00005E34                 mov     [ebp+var_4], ecx
.text$mn:00005E37                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00005E3C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00005E41                 mov     esp, ebp
.text$mn:00005E43                 pop     ebp
.text$mn:00005E44                 retn
.text$mn:00005E44 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00005E44
.text$mn:00005E44 ; ---------------------------------------------------------------------------
.text$mn:00005E45                 align 4
.text$mn:00005E45 _text$mn        ends
.text$mn:00005E45
.text$mn:00005E48 ; ===========================================================================
.text$mn:00005E48
.text$mn:00005E48 ; Segment type: Pure code
.text$mn:00005E48 ; Segment permissions: Read/Execute
.text$mn:00005E48 _text$mn        segment para public 'CODE' use32
.text$mn:00005E48                 assume cs:_text$mn
.text$mn:00005E48                 ;org 5E48h
.text$mn:00005E48 ; COMDAT (pick any)
.text$mn:00005E48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E48
.text$mn:00005E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E48
.text$mn:00005E48 ; Attributes: bp-based frame
.text$mn:00005E48
.text$mn:00005E48 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00005E48                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00005E48 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00005E48                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00005E48                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Dp ...
.text$mn:00005E48
.text$mn:00005E48 var_4           = dword ptr -4
.text$mn:00005E48
.text$mn:00005E48                 push    ebp
.text$mn:00005E49                 mov     ebp, esp
.text$mn:00005E4B                 push    ecx
.text$mn:00005E4C                 mov     [ebp+var_4], ecx
.text$mn:00005E4F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00005E54                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00005E59                 mov     esp, ebp
.text$mn:00005E5B                 pop     ebp
.text$mn:00005E5C                 retn
.text$mn:00005E5C ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00005E5C
.text$mn:00005E5C ; ---------------------------------------------------------------------------
.text$mn:00005E5D                 align 10h
.text$mn:00005E5D _text$mn        ends
.text$mn:00005E5D
.text$mn:00005E60 ; ===========================================================================
.text$mn:00005E60
.text$mn:00005E60 ; Segment type: Pure code
.text$mn:00005E60 ; Segment permissions: Read/Execute
.text$mn:00005E60 _text$mn        segment para public 'CODE' use32
.text$mn:00005E60                 assume cs:_text$mn
.text$mn:00005E60                 ;org 5E60h
.text$mn:00005E60 ; COMDAT (pick any)
.text$mn:00005E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E60
.text$mn:00005E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E60
.text$mn:00005E60 ; Attributes: bp-based frame
.text$mn:00005E60
.text$mn:00005E60 ; protected: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::_Xlen(void)const
.text$mn:00005E60                 public ?_Xlen@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXXZ
.text$mn:00005E60 ?_Xlen@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXXZ proc near
.text$mn:00005E60                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)+31p
.text$mn:00005E60
.text$mn:00005E60 var_4           = dword ptr -4
.text$mn:00005E60
.text$mn:00005E60                 push    ebp
.text$mn:00005E61                 mov     ebp, esp
.text$mn:00005E63                 push    ecx
.text$mn:00005E64                 mov     [ebp+var_4], ecx
.text$mn:00005E67                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00005E6C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00005E71                 mov     esp, ebp
.text$mn:00005E73                 pop     ebp
.text$mn:00005E74                 retn
.text$mn:00005E74 ?_Xlen@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXXZ endp
.text$mn:00005E74
.text$mn:00005E74 ; ---------------------------------------------------------------------------
.text$mn:00005E75                 align 4
.text$mn:00005E75 _text$mn        ends
.text$mn:00005E75
.text$mn:00005E78 ; ===========================================================================
.text$mn:00005E78
.text$mn:00005E78 ; Segment type: Pure code
.text$mn:00005E78 ; Segment permissions: Read/Execute
.text$mn:00005E78 _text$mn        segment para public 'CODE' use32
.text$mn:00005E78                 assume cs:_text$mn
.text$mn:00005E78                 ;org 5E78h
.text$mn:00005E78 ; COMDAT (pick any)
.text$mn:00005E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E78
.text$mn:00005E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E78
.text$mn:00005E78 ; Attributes: bp-based frame
.text$mn:00005E78
.text$mn:00005E78 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00005E78                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00005E78 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00005E78                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00005E78                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00005E78
.text$mn:00005E78 var_4           = dword ptr -4
.text$mn:00005E78
.text$mn:00005E78                 push    ebp
.text$mn:00005E79                 mov     ebp, esp
.text$mn:00005E7B                 push    ecx
.text$mn:00005E7C                 mov     [ebp+var_4], ecx
.text$mn:00005E7F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00005E84                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00005E89                 mov     esp, ebp
.text$mn:00005E8B                 pop     ebp
.text$mn:00005E8C                 retn
.text$mn:00005E8C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00005E8C
.text$mn:00005E8C ; ---------------------------------------------------------------------------
.text$mn:00005E8D                 align 10h
.text$mn:00005E8D _text$mn        ends
.text$mn:00005E8D
.text$mn:00005E90 ; ===========================================================================
.text$mn:00005E90
.text$mn:00005E90 ; Segment type: Pure code
.text$mn:00005E90 ; Segment permissions: Read/Execute
.text$mn:00005E90 _text$mn        segment para public 'CODE' use32
.text$mn:00005E90                 assume cs:_text$mn
.text$mn:00005E90                 ;org 5E90h
.text$mn:00005E90 ; COMDAT (pick any)
.text$mn:00005E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E90
.text$mn:00005E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E90
.text$mn:00005E90 ; Attributes: bp-based frame
.text$mn:00005E90
.text$mn:00005E90 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00005E90                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00005E90 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00005E90                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00005E90                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p ...
.text$mn:00005E90
.text$mn:00005E90 var_4           = dword ptr -4
.text$mn:00005E90
.text$mn:00005E90                 push    ebp
.text$mn:00005E91                 mov     ebp, esp
.text$mn:00005E93                 push    ecx
.text$mn:00005E94                 mov     [ebp+var_4], ecx
.text$mn:00005E97                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00005E9C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00005EA1                 mov     esp, ebp
.text$mn:00005EA3                 pop     ebp
.text$mn:00005EA4                 retn
.text$mn:00005EA4 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00005EA4
.text$mn:00005EA4 ; ---------------------------------------------------------------------------
.text$mn:00005EA5                 align 4
.text$mn:00005EA5 _text$mn        ends
.text$mn:00005EA5
.text$mn:00005EA8 ; ===========================================================================
.text$mn:00005EA8
.text$mn:00005EA8 ; Segment type: Pure code
.text$mn:00005EA8 ; Segment permissions: Read/Execute
.text$mn:00005EA8 _text$mn        segment para public 'CODE' use32
.text$mn:00005EA8                 assume cs:_text$mn
.text$mn:00005EA8                 ;org 5EA8h
.text$mn:00005EA8 ; COMDAT (pick any)
.text$mn:00005EA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EA8
.text$mn:00005EA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EA8
.text$mn:00005EA8 ; Attributes: bp-based frame
.text$mn:00005EA8
.text$mn:00005EA8 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00005EA8                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00005EA8 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00005EA8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00005EA8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00005EA8
.text$mn:00005EA8 var_4           = dword ptr -4
.text$mn:00005EA8 arg_0           = dword ptr  8
.text$mn:00005EA8
.text$mn:00005EA8                 push    ebp
.text$mn:00005EA9                 mov     ebp, esp
.text$mn:00005EAB                 push    ecx
.text$mn:00005EAC                 mov     [ebp+var_4], ecx
.text$mn:00005EAF                 mov     eax, [ebp+arg_0]
.text$mn:00005EB2                 push    eax
.text$mn:00005EB3                 mov     ecx, [ebp+var_4]
.text$mn:00005EB6                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00005EBB                 mov     esp, ebp
.text$mn:00005EBD                 pop     ebp
.text$mn:00005EBE                 retn    4
.text$mn:00005EBE ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00005EBE
.text$mn:00005EBE ; ---------------------------------------------------------------------------
.text$mn:00005EC1                 align 4
.text$mn:00005EC1 _text$mn        ends
.text$mn:00005EC1
.text$mn:00005EC4 ; ===========================================================================
.text$mn:00005EC4
.text$mn:00005EC4 ; Segment type: Pure code
.text$mn:00005EC4 ; Segment permissions: Read/Execute
.text$mn:00005EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00005EC4                 assume cs:_text$mn
.text$mn:00005EC4                 ;org 5EC4h
.text$mn:00005EC4 ; COMDAT (pick any)
.text$mn:00005EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EC4
.text$mn:00005EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EC4
.text$mn:00005EC4 ; Attributes: bp-based frame
.text$mn:00005EC4
.text$mn:00005EC4 ; public: class UserCommand * __thiscall std::_Wrap_alloc<class std::allocator<class UserCommand>>::allocate(unsigned int)
.text$mn:00005EC4                 public ?allocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEPAVUserCommand@@I@Z
.text$mn:00005EC4 ?allocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEPAVUserCommand@@I@Z proc near
.text$mn:00005EC4                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+41p
.text$mn:00005EC4
.text$mn:00005EC4 var_4           = dword ptr -4
.text$mn:00005EC4 arg_0           = dword ptr  8
.text$mn:00005EC4
.text$mn:00005EC4                 push    ebp
.text$mn:00005EC5                 mov     ebp, esp
.text$mn:00005EC7                 push    ecx
.text$mn:00005EC8                 mov     [ebp+var_4], ecx
.text$mn:00005ECB                 mov     eax, [ebp+arg_0]
.text$mn:00005ECE                 push    eax
.text$mn:00005ECF                 mov     ecx, [ebp+var_4]
.text$mn:00005ED2                 call    ?allocate@?$allocator@VUserCommand@@@std@@QAEPAVUserCommand@@I@Z ; std::allocator<UserCommand>::allocate(uint)
.text$mn:00005ED7                 mov     esp, ebp
.text$mn:00005ED9                 pop     ebp
.text$mn:00005EDA                 retn    4
.text$mn:00005EDA ?allocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEPAVUserCommand@@I@Z endp
.text$mn:00005EDA
.text$mn:00005EDA ; ---------------------------------------------------------------------------
.text$mn:00005EDD                 align 10h
.text$mn:00005EDD _text$mn        ends
.text$mn:00005EDD
.text$mn:00005EE0 ; ===========================================================================
.text$mn:00005EE0
.text$mn:00005EE0 ; Segment type: Pure code
.text$mn:00005EE0 ; Segment permissions: Read/Execute
.text$mn:00005EE0 _text$mn        segment para public 'CODE' use32
.text$mn:00005EE0                 assume cs:_text$mn
.text$mn:00005EE0                 ;org 5EE0h
.text$mn:00005EE0 ; COMDAT (pick any)
.text$mn:00005EE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EE0
.text$mn:00005EE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EE0
.text$mn:00005EE0 ; Attributes: bp-based frame
.text$mn:00005EE0
.text$mn:00005EE0 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00005EE0                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00005EE0 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00005EE0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00005EE0                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00005EE0
.text$mn:00005EE0 var_4           = dword ptr -4
.text$mn:00005EE0 arg_0           = dword ptr  8
.text$mn:00005EE0
.text$mn:00005EE0                 push    ebp
.text$mn:00005EE1                 mov     ebp, esp
.text$mn:00005EE3                 push    ecx
.text$mn:00005EE4                 mov     [ebp+var_4], ecx
.text$mn:00005EE7                 mov     eax, [ebp+arg_0]
.text$mn:00005EEA                 push    eax
.text$mn:00005EEB                 mov     ecx, [ebp+var_4]
.text$mn:00005EEE                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00005EF3                 mov     esp, ebp
.text$mn:00005EF5                 pop     ebp
.text$mn:00005EF6                 retn    4
.text$mn:00005EF6 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:00005EF6
.text$mn:00005EF6 ; ---------------------------------------------------------------------------
.text$mn:00005EF9                 align 4
.text$mn:00005EF9 _text$mn        ends
.text$mn:00005EF9
.text$mn:00005EFC ; ===========================================================================
.text$mn:00005EFC
.text$mn:00005EFC ; Segment type: Pure code
.text$mn:00005EFC ; Segment permissions: Read/Execute
.text$mn:00005EFC _text$mn        segment para public 'CODE' use32
.text$mn:00005EFC                 assume cs:_text$mn
.text$mn:00005EFC                 ;org 5EFCh
.text$mn:00005EFC ; COMDAT (pick any)
.text$mn:00005EFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EFC
.text$mn:00005EFC ; =============== S U B R O U T I N E =======================================
.text$mn:00005EFC
.text$mn:00005EFC ; Attributes: bp-based frame
.text$mn:00005EFC
.text$mn:00005EFC ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00005EFC                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00005EFC ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00005EFC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00005EFC
.text$mn:00005EFC var_4           = dword ptr -4
.text$mn:00005EFC arg_0           = dword ptr  8
.text$mn:00005EFC
.text$mn:00005EFC                 push    ebp
.text$mn:00005EFD                 mov     ebp, esp
.text$mn:00005EFF                 push    ecx
.text$mn:00005F00                 mov     [ebp+var_4], ecx
.text$mn:00005F03                 push    0
.text$mn:00005F05                 mov     eax, [ebp+arg_0]
.text$mn:00005F08                 push    eax
.text$mn:00005F09                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00005F0E                 add     esp, 8
.text$mn:00005F11                 mov     esp, ebp
.text$mn:00005F13                 pop     ebp
.text$mn:00005F14                 retn    4
.text$mn:00005F14 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00005F14
.text$mn:00005F14 ; ---------------------------------------------------------------------------
.text$mn:00005F17                 align 4
.text$mn:00005F17 _text$mn        ends
.text$mn:00005F17
.text$mn:00005F18 ; ===========================================================================
.text$mn:00005F18
.text$mn:00005F18 ; Segment type: Pure code
.text$mn:00005F18 ; Segment permissions: Read/Execute
.text$mn:00005F18 _text$mn        segment para public 'CODE' use32
.text$mn:00005F18                 assume cs:_text$mn
.text$mn:00005F18                 ;org 5F18h
.text$mn:00005F18 ; COMDAT (pick any)
.text$mn:00005F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F18
.text$mn:00005F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F18
.text$mn:00005F18 ; Attributes: bp-based frame
.text$mn:00005F18
.text$mn:00005F18 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00005F18                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00005F18 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00005F18                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00005F18                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:00005F18
.text$mn:00005F18 var_4           = dword ptr -4
.text$mn:00005F18 arg_0           = dword ptr  8
.text$mn:00005F18
.text$mn:00005F18                 push    ebp
.text$mn:00005F19                 mov     ebp, esp
.text$mn:00005F1B                 push    ecx
.text$mn:00005F1C                 mov     [ebp+var_4], ecx
.text$mn:00005F1F                 push    0
.text$mn:00005F21                 mov     eax, [ebp+arg_0]
.text$mn:00005F24                 push    eax
.text$mn:00005F25                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00005F2A                 add     esp, 8
.text$mn:00005F2D                 mov     esp, ebp
.text$mn:00005F2F                 pop     ebp
.text$mn:00005F30                 retn    4
.text$mn:00005F30 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00005F30
.text$mn:00005F30 ; ---------------------------------------------------------------------------
.text$mn:00005F33                 align 4
.text$mn:00005F33 _text$mn        ends
.text$mn:00005F33
.text$mn:00005F34 ; ===========================================================================
.text$mn:00005F34
.text$mn:00005F34 ; Segment type: Pure code
.text$mn:00005F34 ; Segment permissions: Read/Execute
.text$mn:00005F34 _text$mn        segment para public 'CODE' use32
.text$mn:00005F34                 assume cs:_text$mn
.text$mn:00005F34                 ;org 5F34h
.text$mn:00005F34 ; COMDAT (pick any)
.text$mn:00005F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F34
.text$mn:00005F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F34
.text$mn:00005F34 ; Attributes: bp-based frame
.text$mn:00005F34
.text$mn:00005F34 ; public: class UserCommand * __thiscall std::allocator<class UserCommand>::allocate(unsigned int)
.text$mn:00005F34                 public ?allocate@?$allocator@VUserCommand@@@std@@QAEPAVUserCommand@@I@Z
.text$mn:00005F34 ?allocate@?$allocator@VUserCommand@@@std@@QAEPAVUserCommand@@I@Z proc near
.text$mn:00005F34                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::allocate(uint)+Ep
.text$mn:00005F34
.text$mn:00005F34 var_4           = dword ptr -4
.text$mn:00005F34 arg_0           = dword ptr  8
.text$mn:00005F34
.text$mn:00005F34                 push    ebp
.text$mn:00005F35                 mov     ebp, esp
.text$mn:00005F37                 push    ecx
.text$mn:00005F38                 mov     [ebp+var_4], ecx
.text$mn:00005F3B                 push    0
.text$mn:00005F3D                 mov     eax, [ebp+arg_0]
.text$mn:00005F40                 push    eax
.text$mn:00005F41                 call    ??$_Allocate@VUserCommand@@@std@@YAPAVUserCommand@@IPAV1@@Z ; std::_Allocate<UserCommand>(uint,UserCommand *)
.text$mn:00005F46                 add     esp, 8
.text$mn:00005F49                 mov     esp, ebp
.text$mn:00005F4B                 pop     ebp
.text$mn:00005F4C                 retn    4
.text$mn:00005F4C ?allocate@?$allocator@VUserCommand@@@std@@QAEPAVUserCommand@@I@Z endp
.text$mn:00005F4C
.text$mn:00005F4C ; ---------------------------------------------------------------------------
.text$mn:00005F4F                 align 10h
.text$mn:00005F4F _text$mn        ends
.text$mn:00005F4F
.text$mn:00005F50 ; ===========================================================================
.text$mn:00005F50
.text$mn:00005F50 ; Segment type: Pure code
.text$mn:00005F50 ; Segment permissions: Read/Execute
.text$mn:00005F50 _text$mn        segment para public 'CODE' use32
.text$mn:00005F50                 assume cs:_text$mn
.text$mn:00005F50                 ;org 5F50h
.text$mn:00005F50 ; COMDAT (pick any)
.text$mn:00005F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F50
.text$mn:00005F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F50
.text$mn:00005F50 ; Attributes: bp-based frame
.text$mn:00005F50
.text$mn:00005F50 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00005F50                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00005F50 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00005F50                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00005F50
.text$mn:00005F50 var_4           = dword ptr -4
.text$mn:00005F50 arg_0           = dword ptr  8
.text$mn:00005F50
.text$mn:00005F50                 push    ebp
.text$mn:00005F51                 mov     ebp, esp
.text$mn:00005F53                 push    ecx
.text$mn:00005F54                 mov     [ebp+var_4], ecx
.text$mn:00005F57                 push    0
.text$mn:00005F59                 mov     eax, [ebp+arg_0]
.text$mn:00005F5C                 push    eax
.text$mn:00005F5D                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00005F62                 add     esp, 8
.text$mn:00005F65                 mov     esp, ebp
.text$mn:00005F67                 pop     ebp
.text$mn:00005F68                 retn    4
.text$mn:00005F68 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00005F68
.text$mn:00005F68 ; ---------------------------------------------------------------------------
.text$mn:00005F6B                 align 4
.text$mn:00005F6B _text$mn        ends
.text$mn:00005F6B
.text$mn:00005F6C ; ===========================================================================
.text$mn:00005F6C
.text$mn:00005F6C ; Segment type: Pure code
.text$mn:00005F6C ; Segment permissions: Read/Execute
.text$mn:00005F6C _text$mn        segment para public 'CODE' use32
.text$mn:00005F6C                 assume cs:_text$mn
.text$mn:00005F6C                 ;org 5F6Ch
.text$mn:00005F6C ; COMDAT (pick any)
.text$mn:00005F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F6C
.text$mn:00005F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F6C
.text$mn:00005F6C ; Attributes: bp-based frame
.text$mn:00005F6C
.text$mn:00005F6C ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &)
.text$mn:00005F6C                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z
.text$mn:00005F6C ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z proc near
.text$mn:00005F6C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+Ep
.text$mn:00005F6C
.text$mn:00005F6C var_4           = dword ptr -4
.text$mn:00005F6C arg_0           = dword ptr  8
.text$mn:00005F6C
.text$mn:00005F6C                 push    ebp
.text$mn:00005F6D                 mov     ebp, esp
.text$mn:00005F6F                 push    ecx
.text$mn:00005F70                 mov     [ebp+var_4], ecx
.text$mn:00005F73                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00005F78                 push    eax
.text$mn:00005F79                 push    0
.text$mn:00005F7B                 mov     ecx, [ebp+arg_0]
.text$mn:00005F7E                 push    ecx
.text$mn:00005F7F                 mov     ecx, [ebp+var_4]
.text$mn:00005F82                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00005F87                 mov     esp, ebp
.text$mn:00005F89                 pop     ebp
.text$mn:00005F8A                 retn    4
.text$mn:00005F8A ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@@Z endp
.text$mn:00005F8A
.text$mn:00005F8A ; ---------------------------------------------------------------------------
.text$mn:00005F8D                 align 10h
.text$mn:00005F8D _text$mn        ends
.text$mn:00005F8D
.text$mn:00005F90 ; ===========================================================================
.text$mn:00005F90
.text$mn:00005F90 ; Segment type: Pure code
.text$mn:00005F90 ; Segment permissions: Read/Execute
.text$mn:00005F90 _text$mn        segment para public 'CODE' use32
.text$mn:00005F90                 assume cs:_text$mn
.text$mn:00005F90                 ;org 5F90h
.text$mn:00005F90 ; COMDAT (pick any)
.text$mn:00005F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F90
.text$mn:00005F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F90
.text$mn:00005F90 ; Attributes: bp-based frame
.text$mn:00005F90
.text$mn:00005F90 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::append(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00005F90                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00005F90 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00005F90                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+16p
.text$mn:00005F90                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+53p
.text$mn:00005F90
.text$mn:00005F90 var_8           = dword ptr -8
.text$mn:00005F90 var_4           = dword ptr -4
.text$mn:00005F90 arg_0           = dword ptr  8
.text$mn:00005F90 arg_4           = dword ptr  0Ch
.text$mn:00005F90 arg_8           = dword ptr  10h
.text$mn:00005F90
.text$mn:00005F90                 push    ebp
.text$mn:00005F91                 mov     ebp, esp
.text$mn:00005F93                 sub     esp, 8
.text$mn:00005F96                 mov     [ebp+var_4], ecx
.text$mn:00005F99                 mov     ecx, [ebp+arg_0]
.text$mn:00005F9C                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00005FA1                 cmp     eax, [ebp+arg_4]
.text$mn:00005FA4                 jnb     short loc_5FAE
.text$mn:00005FA6                 mov     ecx, [ebp+var_4]
.text$mn:00005FA9                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00005FAE
.text$mn:00005FAE loc_5FAE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00005FAE                 mov     ecx, [ebp+arg_0]
.text$mn:00005FB1                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00005FB6                 sub     eax, [ebp+arg_4]
.text$mn:00005FB9                 mov     [ebp+var_8], eax
.text$mn:00005FBC                 mov     eax, [ebp+var_8]
.text$mn:00005FBF                 cmp     eax, [ebp+arg_8]
.text$mn:00005FC2                 jnb     short loc_5FCA
.text$mn:00005FC4                 mov     ecx, [ebp+var_8]
.text$mn:00005FC7                 mov     [ebp+arg_8], ecx
.text$mn:00005FCA
.text$mn:00005FCA loc_5FCA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00005FCA                 mov     edx, [ebp+var_4]
.text$mn:00005FCD                 mov     eax, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:00005FD2                 sub     eax, [edx+14h]
.text$mn:00005FD5                 cmp     eax, [ebp+arg_8]
.text$mn:00005FD8                 ja      short loc_5FE2
.text$mn:00005FDA                 mov     ecx, [ebp+var_4]
.text$mn:00005FDD                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:00005FE2
.text$mn:00005FE2 loc_5FE2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+48j
.text$mn:00005FE2                 cmp     [ebp+arg_8], 0
.text$mn:00005FE6                 jbe     short loc_6042
.text$mn:00005FE8                 mov     ecx, [ebp+var_4]
.text$mn:00005FEB                 mov     edx, [ecx+14h]
.text$mn:00005FEE                 add     edx, [ebp+arg_8]
.text$mn:00005FF1                 mov     [ebp+var_8], edx
.text$mn:00005FF4                 push    0
.text$mn:00005FF6                 mov     eax, [ebp+var_8]
.text$mn:00005FF9                 push    eax
.text$mn:00005FFA                 mov     ecx, [ebp+var_4]
.text$mn:00005FFD                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00006002                 movzx   ecx, al
.text$mn:00006005                 test    ecx, ecx
.text$mn:00006007                 jz      short loc_6042
.text$mn:00006009                 mov     edx, [ebp+arg_8]
.text$mn:0000600C                 push    edx             ; int
.text$mn:0000600D                 mov     ecx, [ebp+arg_0]
.text$mn:00006010                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006015                 mov     ecx, [ebp+arg_4]
.text$mn:00006018                 lea     edx, [eax+ecx*2]
.text$mn:0000601B                 push    edx             ; Src
.text$mn:0000601C                 mov     ecx, [ebp+var_4]
.text$mn:0000601F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006024                 mov     ecx, [ebp+var_4]
.text$mn:00006027                 mov     edx, [ecx+14h]
.text$mn:0000602A                 lea     eax, [eax+edx*2]
.text$mn:0000602D                 push    eax             ; Dst
.text$mn:0000602E                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00006033                 add     esp, 0Ch
.text$mn:00006036                 mov     ecx, [ebp+var_8]
.text$mn:00006039                 push    ecx
.text$mn:0000603A                 mov     ecx, [ebp+var_4]
.text$mn:0000603D                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006042
.text$mn:00006042 loc_6042:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+56j
.text$mn:00006042                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+77j
.text$mn:00006042                 mov     eax, [ebp+var_4]
.text$mn:00006045                 mov     esp, ebp
.text$mn:00006047                 pop     ebp
.text$mn:00006048                 retn    0Ch
.text$mn:00006048 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00006048
.text$mn:00006048 ; ---------------------------------------------------------------------------
.text$mn:0000604B                 align 4
.text$mn:0000604B _text$mn        ends
.text$mn:0000604B
.text$mn:0000604C ; ===========================================================================
.text$mn:0000604C
.text$mn:0000604C ; Segment type: Pure code
.text$mn:0000604C ; Segment permissions: Read/Execute
.text$mn:0000604C _text$mn        segment para public 'CODE' use32
.text$mn:0000604C                 assume cs:_text$mn
.text$mn:0000604C                 ;org 604Ch
.text$mn:0000604C ; COMDAT (pick any)
.text$mn:0000604C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000604C
.text$mn:0000604C ; =============== S U B R O U T I N E =======================================
.text$mn:0000604C
.text$mn:0000604C ; Attributes: bp-based frame
.text$mn:0000604C
.text$mn:0000604C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t *Str)
.text$mn:0000604C                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:0000604C ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:0000604C                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&,wchar_t const *)+31p
.text$mn:0000604C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)+Ep
.text$mn:0000604C
.text$mn:0000604C var_4           = dword ptr -4
.text$mn:0000604C Str             = dword ptr  8
.text$mn:0000604C
.text$mn:0000604C                 push    ebp
.text$mn:0000604D                 mov     ebp, esp
.text$mn:0000604F                 push    ecx
.text$mn:00006050                 mov     [ebp+var_4], ecx
.text$mn:00006053                 push    43Eh            ; unsigned int
.text$mn:00006058                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000605D                 mov     eax, [ebp+Str]
.text$mn:00006060                 push    eax             ; int
.text$mn:00006061                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00006066                 add     esp, 0Ch
.text$mn:00006069                 mov     ecx, [ebp+Str]
.text$mn:0000606C                 push    ecx             ; Str
.text$mn:0000606D                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00006072                 add     esp, 4
.text$mn:00006075                 push    eax             ; int
.text$mn:00006076                 mov     edx, [ebp+Str]
.text$mn:00006079                 push    edx             ; Src
.text$mn:0000607A                 mov     ecx, [ebp+var_4]
.text$mn:0000607D                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)
.text$mn:00006082                 mov     esp, ebp
.text$mn:00006084                 pop     ebp
.text$mn:00006085                 retn    4
.text$mn:00006085 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00006085
.text$mn:00006085 _text$mn        ends
.text$mn:00006085
.text$mn:00006088 ; ===========================================================================
.text$mn:00006088
.text$mn:00006088 ; Segment type: Pure code
.text$mn:00006088 ; Segment permissions: Read/Execute
.text$mn:00006088 _text$mn        segment para public 'CODE' use32
.text$mn:00006088                 assume cs:_text$mn
.text$mn:00006088                 ;org 6088h
.text$mn:00006088 ; COMDAT (pick any)
.text$mn:00006088                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006088
.text$mn:00006088 ; =============== S U B R O U T I N E =======================================
.text$mn:00006088
.text$mn:00006088 ; Attributes: bp-based frame
.text$mn:00006088
.text$mn:00006088 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(void *Src, int)
.text$mn:00006088                 public ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00006088 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00006088                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+31p
.text$mn:00006088
.text$mn:00006088 var_8           = dword ptr -8
.text$mn:00006088 var_4           = dword ptr -4
.text$mn:00006088 Src             = dword ptr  8
.text$mn:00006088 arg_4           = dword ptr  0Ch
.text$mn:00006088
.text$mn:00006088                 push    ebp
.text$mn:00006089                 mov     ebp, esp
.text$mn:0000608B                 sub     esp, 8
.text$mn:0000608E                 mov     [ebp+var_4], ecx
.text$mn:00006091                 cmp     [ebp+arg_4], 0
.text$mn:00006095                 jz      short loc_60AD
.text$mn:00006097                 push    42Ah            ; unsigned int
.text$mn:0000609C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000060A1                 mov     eax, [ebp+Src]
.text$mn:000060A4                 push    eax             ; int
.text$mn:000060A5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000060AA                 add     esp, 0Ch
.text$mn:000060AD
.text$mn:000060AD loc_60AD:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+Dj
.text$mn:000060AD                 mov     ecx, [ebp+Src]
.text$mn:000060B0                 push    ecx
.text$mn:000060B1                 mov     ecx, [ebp+var_4]
.text$mn:000060B4                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000060B9                 movzx   edx, al
.text$mn:000060BC                 test    edx, edx
.text$mn:000060BE                 jz      short loc_60E2
.text$mn:000060C0                 mov     eax, [ebp+arg_4]
.text$mn:000060C3                 push    eax
.text$mn:000060C4                 mov     ecx, [ebp+var_4]
.text$mn:000060C7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000060CC                 mov     ecx, [ebp+Src]
.text$mn:000060CF                 sub     ecx, eax
.text$mn:000060D1                 sar     ecx, 1
.text$mn:000060D3                 push    ecx
.text$mn:000060D4                 mov     edx, [ebp+var_4]
.text$mn:000060D7                 push    edx
.text$mn:000060D8                 mov     ecx, [ebp+var_4]
.text$mn:000060DB                 call    ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000060E0                 jmp     short loc_6153
.text$mn:000060E2 ; ---------------------------------------------------------------------------
.text$mn:000060E2
.text$mn:000060E2 loc_60E2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+36j
.text$mn:000060E2                 mov     eax, [ebp+var_4]
.text$mn:000060E5                 mov     ecx, ds:?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB ; uint const std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::npos
.text$mn:000060EB                 sub     ecx, [eax+14h]
.text$mn:000060EE                 cmp     ecx, [ebp+arg_4]
.text$mn:000060F1                 ja      short loc_60FB
.text$mn:000060F3                 mov     ecx, [ebp+var_4]
.text$mn:000060F6                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000060FB
.text$mn:000060FB loc_60FB:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+69j
.text$mn:000060FB                 cmp     [ebp+arg_4], 0
.text$mn:000060FF                 jbe     short loc_6150
.text$mn:00006101                 mov     edx, [ebp+var_4]
.text$mn:00006104                 mov     eax, [edx+14h]
.text$mn:00006107                 add     eax, [ebp+arg_4]
.text$mn:0000610A                 mov     [ebp+var_8], eax
.text$mn:0000610D                 push    0
.text$mn:0000610F                 mov     ecx, [ebp+var_8]
.text$mn:00006112                 push    ecx
.text$mn:00006113                 mov     ecx, [ebp+var_4]
.text$mn:00006116                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000611B                 movzx   edx, al
.text$mn:0000611E                 test    edx, edx
.text$mn:00006120                 jz      short loc_6150
.text$mn:00006122                 mov     eax, [ebp+arg_4]
.text$mn:00006125                 push    eax             ; int
.text$mn:00006126                 mov     ecx, [ebp+Src]
.text$mn:00006129                 push    ecx             ; Src
.text$mn:0000612A                 mov     ecx, [ebp+var_4]
.text$mn:0000612D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006132                 mov     edx, [ebp+var_4]
.text$mn:00006135                 mov     ecx, [edx+14h]
.text$mn:00006138                 lea     edx, [eax+ecx*2]
.text$mn:0000613B                 push    edx             ; Dst
.text$mn:0000613C                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00006141                 add     esp, 0Ch
.text$mn:00006144                 mov     eax, [ebp+var_8]
.text$mn:00006147                 push    eax
.text$mn:00006148                 mov     ecx, [ebp+var_4]
.text$mn:0000614B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006150
.text$mn:00006150 loc_6150:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+77j
.text$mn:00006150                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+98j
.text$mn:00006150                 mov     eax, [ebp+var_4]
.text$mn:00006153
.text$mn:00006153 loc_6153:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *,uint)+58j
.text$mn:00006153                 mov     esp, ebp
.text$mn:00006155                 pop     ebp
.text$mn:00006156                 retn    8
.text$mn:00006156 ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00006156
.text$mn:00006156 ; ---------------------------------------------------------------------------
.text$mn:00006159                 align 4
.text$mn:00006159 _text$mn        ends
.text$mn:00006159
.text$mn:0000615C ; ===========================================================================
.text$mn:0000615C
.text$mn:0000615C ; Segment type: Pure code
.text$mn:0000615C ; Segment permissions: Read/Execute
.text$mn:0000615C _text$mn        segment para public 'CODE' use32
.text$mn:0000615C                 assume cs:_text$mn
.text$mn:0000615C                 ;org 615Ch
.text$mn:0000615C ; COMDAT (pick any)
.text$mn:0000615C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000615C
.text$mn:0000615C ; =============== S U B R O U T I N E =======================================
.text$mn:0000615C
.text$mn:0000615C ; Attributes: bp-based frame
.text$mn:0000615C
.text$mn:0000615C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:0000615C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:0000615C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:0000615C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:0000615C
.text$mn:0000615C Size            = dword ptr -8
.text$mn:0000615C var_4           = dword ptr -4
.text$mn:0000615C arg_0           = dword ptr  8
.text$mn:0000615C arg_4           = dword ptr  0Ch
.text$mn:0000615C arg_8           = dword ptr  10h
.text$mn:0000615C
.text$mn:0000615C                 push    ebp
.text$mn:0000615D                 mov     ebp, esp
.text$mn:0000615F                 sub     esp, 8
.text$mn:00006162                 mov     [ebp+var_4], ecx
.text$mn:00006165                 mov     ecx, [ebp+arg_0]
.text$mn:00006168                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000616D                 cmp     eax, [ebp+arg_4]
.text$mn:00006170                 jnb     short loc_617A
.text$mn:00006172                 mov     ecx, [ebp+var_4]
.text$mn:00006175                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:0000617A
.text$mn:0000617A loc_617A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:0000617A                 mov     ecx, [ebp+arg_0]
.text$mn:0000617D                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00006182                 sub     eax, [ebp+arg_4]
.text$mn:00006185                 mov     [ebp+Size], eax
.text$mn:00006188                 mov     eax, [ebp+arg_8]
.text$mn:0000618B                 cmp     eax, [ebp+Size]
.text$mn:0000618E                 jnb     short loc_6196
.text$mn:00006190                 mov     ecx, [ebp+arg_8]
.text$mn:00006193                 mov     [ebp+Size], ecx
.text$mn:00006196
.text$mn:00006196 loc_6196:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00006196                 mov     edx, [ebp+var_4]
.text$mn:00006199                 cmp     edx, [ebp+arg_0]
.text$mn:0000619C                 jnz     short loc_61BD
.text$mn:0000619E                 mov     eax, [ebp+arg_4]
.text$mn:000061A1                 add     eax, [ebp+Size]
.text$mn:000061A4                 push    eax
.text$mn:000061A5                 mov     ecx, [ebp+var_4]
.text$mn:000061A8                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:000061AD                 mov     ecx, [ebp+arg_4]
.text$mn:000061B0                 push    ecx
.text$mn:000061B1                 push    0
.text$mn:000061B3                 mov     ecx, [ebp+var_4]
.text$mn:000061B6                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:000061BB                 jmp     short loc_61FF
.text$mn:000061BD ; ---------------------------------------------------------------------------
.text$mn:000061BD
.text$mn:000061BD loc_61BD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:000061BD                 push    0
.text$mn:000061BF                 mov     edx, [ebp+Size]
.text$mn:000061C2                 push    edx
.text$mn:000061C3                 mov     ecx, [ebp+var_4]
.text$mn:000061C6                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000061CB                 movzx   eax, al
.text$mn:000061CE                 test    eax, eax
.text$mn:000061D0                 jz      short loc_61FF
.text$mn:000061D2                 mov     ecx, [ebp+Size]
.text$mn:000061D5                 push    ecx             ; Size
.text$mn:000061D6                 mov     ecx, [ebp+arg_0]
.text$mn:000061D9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000061DE                 add     eax, [ebp+arg_4]
.text$mn:000061E1                 push    eax             ; Src
.text$mn:000061E2                 mov     ecx, [ebp+var_4]
.text$mn:000061E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000061EA                 push    eax             ; Dst
.text$mn:000061EB                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000061F0                 add     esp, 0Ch
.text$mn:000061F3                 mov     edx, [ebp+Size]
.text$mn:000061F6                 push    edx
.text$mn:000061F7                 mov     ecx, [ebp+var_4]
.text$mn:000061FA                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000061FF
.text$mn:000061FF loc_61FF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000061FF                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000061FF                 mov     eax, [ebp+var_4]
.text$mn:00006202                 mov     esp, ebp
.text$mn:00006204                 pop     ebp
.text$mn:00006205                 retn    0Ch
.text$mn:00006205 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00006205
.text$mn:00006205 _text$mn        ends
.text$mn:00006205
.text$mn:00006208 ; ===========================================================================
.text$mn:00006208
.text$mn:00006208 ; Segment type: Pure code
.text$mn:00006208 ; Segment permissions: Read/Execute
.text$mn:00006208 _text$mn        segment para public 'CODE' use32
.text$mn:00006208                 assume cs:_text$mn
.text$mn:00006208                 ;org 6208h
.text$mn:00006208 ; COMDAT (pick any)
.text$mn:00006208                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006208
.text$mn:00006208 ; =============== S U B R O U T I N E =======================================
.text$mn:00006208
.text$mn:00006208 ; Attributes: bp-based frame
.text$mn:00006208
.text$mn:00006208 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00006208                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00006208 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00006208                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00006208
.text$mn:00006208 var_4           = dword ptr -4
.text$mn:00006208 Str             = dword ptr  8
.text$mn:00006208
.text$mn:00006208                 push    ebp
.text$mn:00006209                 mov     ebp, esp
.text$mn:0000620B                 push    ecx
.text$mn:0000620C                 mov     [ebp+var_4], ecx
.text$mn:0000620F                 push    490h            ; unsigned int
.text$mn:00006214                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006219                 mov     eax, [ebp+Str]
.text$mn:0000621C                 push    eax             ; int
.text$mn:0000621D                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00006222                 add     esp, 0Ch
.text$mn:00006225                 mov     ecx, [ebp+Str]
.text$mn:00006228                 push    ecx             ; Str
.text$mn:00006229                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:0000622E                 add     esp, 4
.text$mn:00006231                 push    eax             ; Size
.text$mn:00006232                 mov     edx, [ebp+Str]
.text$mn:00006235                 push    edx             ; Src
.text$mn:00006236                 mov     ecx, [ebp+var_4]
.text$mn:00006239                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:0000623E                 mov     esp, ebp
.text$mn:00006240                 pop     ebp
.text$mn:00006241                 retn    4
.text$mn:00006241 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00006241
.text$mn:00006241 _text$mn        ends
.text$mn:00006241
.text$mn:00006244 ; ===========================================================================
.text$mn:00006244
.text$mn:00006244 ; Segment type: Pure code
.text$mn:00006244 ; Segment permissions: Read/Execute
.text$mn:00006244 _text$mn        segment para public 'CODE' use32
.text$mn:00006244                 assume cs:_text$mn
.text$mn:00006244                 ;org 6244h
.text$mn:00006244 ; COMDAT (pick any)
.text$mn:00006244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006244
.text$mn:00006244 ; =============== S U B R O U T I N E =======================================
.text$mn:00006244
.text$mn:00006244 ; Attributes: bp-based frame
.text$mn:00006244
.text$mn:00006244 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00006244                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00006244 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00006244                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00006244
.text$mn:00006244 var_4           = dword ptr -4
.text$mn:00006244 Src             = dword ptr  8
.text$mn:00006244 Size            = dword ptr  0Ch
.text$mn:00006244
.text$mn:00006244                 push    ebp
.text$mn:00006245                 mov     ebp, esp
.text$mn:00006247                 push    ecx
.text$mn:00006248                 mov     [ebp+var_4], ecx
.text$mn:0000624B                 cmp     [ebp+Size], 0
.text$mn:0000624F                 jz      short loc_6267
.text$mn:00006251                 push    47Fh            ; unsigned int
.text$mn:00006256                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000625B                 mov     eax, [ebp+Src]
.text$mn:0000625E                 push    eax             ; int
.text$mn:0000625F                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00006264                 add     esp, 0Ch
.text$mn:00006267
.text$mn:00006267 loc_6267:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00006267                 mov     ecx, [ebp+Src]
.text$mn:0000626A                 push    ecx
.text$mn:0000626B                 mov     ecx, [ebp+var_4]
.text$mn:0000626E                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00006273                 movzx   edx, al
.text$mn:00006276                 test    edx, edx
.text$mn:00006278                 jz      short loc_629A
.text$mn:0000627A                 mov     eax, [ebp+Size]
.text$mn:0000627D                 push    eax
.text$mn:0000627E                 mov     ecx, [ebp+var_4]
.text$mn:00006281                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006286                 mov     ecx, [ebp+Src]
.text$mn:00006289                 sub     ecx, eax
.text$mn:0000628B                 push    ecx
.text$mn:0000628C                 mov     edx, [ebp+var_4]
.text$mn:0000628F                 push    edx
.text$mn:00006290                 mov     ecx, [ebp+var_4]
.text$mn:00006293                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00006298                 jmp     short loc_62D7
.text$mn:0000629A ; ---------------------------------------------------------------------------
.text$mn:0000629A
.text$mn:0000629A loc_629A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:0000629A                 push    0
.text$mn:0000629C                 mov     eax, [ebp+Size]
.text$mn:0000629F                 push    eax
.text$mn:000062A0                 mov     ecx, [ebp+var_4]
.text$mn:000062A3                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:000062A8                 movzx   ecx, al
.text$mn:000062AB                 test    ecx, ecx
.text$mn:000062AD                 jz      short loc_62D4
.text$mn:000062AF                 mov     edx, [ebp+Size]
.text$mn:000062B2                 push    edx             ; Size
.text$mn:000062B3                 mov     eax, [ebp+Src]
.text$mn:000062B6                 push    eax             ; Src
.text$mn:000062B7                 mov     ecx, [ebp+var_4]
.text$mn:000062BA                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000062BF                 push    eax             ; Dst
.text$mn:000062C0                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000062C5                 add     esp, 0Ch
.text$mn:000062C8                 mov     ecx, [ebp+Size]
.text$mn:000062CB                 push    ecx
.text$mn:000062CC                 mov     ecx, [ebp+var_4]
.text$mn:000062CF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000062D4
.text$mn:000062D4 loc_62D4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:000062D4                 mov     eax, [ebp+var_4]
.text$mn:000062D7
.text$mn:000062D7 loc_62D7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:000062D7                 mov     esp, ebp
.text$mn:000062D9                 pop     ebp
.text$mn:000062DA                 retn    8
.text$mn:000062DA ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000062DA
.text$mn:000062DA ; ---------------------------------------------------------------------------
.text$mn:000062DD                 align 10h
.text$mn:000062DD _text$mn        ends
.text$mn:000062DD
.text$mn:000062E0 ; ===========================================================================
.text$mn:000062E0
.text$mn:000062E0 ; Segment type: Pure code
.text$mn:000062E0 ; Segment permissions: Read/Execute
.text$mn:000062E0 _text$mn        segment para public 'CODE' use32
.text$mn:000062E0                 assume cs:_text$mn
.text$mn:000062E0                 ;org 62E0h
.text$mn:000062E0 ; COMDAT (pick any)
.text$mn:000062E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000062E0
.text$mn:000062E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000062E0
.text$mn:000062E0 ; Attributes: bp-based frame
.text$mn:000062E0
.text$mn:000062E0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:000062E0                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000062E0 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000062E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+6Bp
.text$mn:000062E0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:000062E0
.text$mn:000062E0 var_8           = dword ptr -8
.text$mn:000062E0 var_4           = dword ptr -4
.text$mn:000062E0 arg_0           = dword ptr  8
.text$mn:000062E0 arg_4           = dword ptr  0Ch
.text$mn:000062E0 arg_8           = dword ptr  10h
.text$mn:000062E0
.text$mn:000062E0                 push    ebp
.text$mn:000062E1                 mov     ebp, esp
.text$mn:000062E3                 sub     esp, 8
.text$mn:000062E6                 mov     [ebp+var_4], ecx
.text$mn:000062E9                 mov     ecx, [ebp+arg_0]
.text$mn:000062EC                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:000062F1                 cmp     eax, [ebp+arg_4]
.text$mn:000062F4                 jnb     short loc_62FE
.text$mn:000062F6                 mov     ecx, [ebp+var_4]
.text$mn:000062F9                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000062FE
.text$mn:000062FE loc_62FE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:000062FE                 mov     ecx, [ebp+arg_0]
.text$mn:00006301                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00006306                 sub     eax, [ebp+arg_4]
.text$mn:00006309                 mov     [ebp+var_8], eax
.text$mn:0000630C                 mov     eax, [ebp+arg_8]
.text$mn:0000630F                 cmp     eax, [ebp+var_8]
.text$mn:00006312                 jnb     short loc_631A
.text$mn:00006314                 mov     ecx, [ebp+arg_8]
.text$mn:00006317                 mov     [ebp+var_8], ecx
.text$mn:0000631A
.text$mn:0000631A loc_631A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:0000631A                 mov     edx, [ebp+var_4]
.text$mn:0000631D                 cmp     edx, [ebp+arg_0]
.text$mn:00006320                 jnz     short loc_6341
.text$mn:00006322                 mov     eax, [ebp+arg_4]
.text$mn:00006325                 add     eax, [ebp+var_8]
.text$mn:00006328                 push    eax
.text$mn:00006329                 mov     ecx, [ebp+var_4]
.text$mn:0000632C                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00006331                 mov     ecx, [ebp+arg_4]
.text$mn:00006334                 push    ecx
.text$mn:00006335                 push    0
.text$mn:00006337                 mov     ecx, [ebp+var_4]
.text$mn:0000633A                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:0000633F                 jmp     short loc_6386
.text$mn:00006341 ; ---------------------------------------------------------------------------
.text$mn:00006341
.text$mn:00006341 loc_6341:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00006341                 push    0
.text$mn:00006343                 mov     edx, [ebp+var_8]
.text$mn:00006346                 push    edx
.text$mn:00006347                 mov     ecx, [ebp+var_4]
.text$mn:0000634A                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:0000634F                 movzx   eax, al
.text$mn:00006352                 test    eax, eax
.text$mn:00006354                 jz      short loc_6386
.text$mn:00006356                 mov     ecx, [ebp+var_8]
.text$mn:00006359                 push    ecx             ; int
.text$mn:0000635A                 mov     ecx, [ebp+arg_0]
.text$mn:0000635D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006362                 mov     edx, [ebp+arg_4]
.text$mn:00006365                 lea     eax, [eax+edx*2]
.text$mn:00006368                 push    eax             ; Src
.text$mn:00006369                 mov     ecx, [ebp+var_4]
.text$mn:0000636C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006371                 push    eax             ; Dst
.text$mn:00006372                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00006377                 add     esp, 0Ch
.text$mn:0000637A                 mov     ecx, [ebp+var_8]
.text$mn:0000637D                 push    ecx
.text$mn:0000637E                 mov     ecx, [ebp+var_4]
.text$mn:00006381                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006386
.text$mn:00006386 loc_6386:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00006386                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00006386                 mov     eax, [ebp+var_4]
.text$mn:00006389                 mov     esp, ebp
.text$mn:0000638B                 pop     ebp
.text$mn:0000638C                 retn    0Ch
.text$mn:0000638C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:0000638C
.text$mn:0000638C ; ---------------------------------------------------------------------------
.text$mn:0000638F                 align 10h
.text$mn:0000638F _text$mn        ends
.text$mn:0000638F
.text$mn:00006390 ; ===========================================================================
.text$mn:00006390
.text$mn:00006390 ; Segment type: Pure code
.text$mn:00006390 ; Segment permissions: Read/Execute
.text$mn:00006390 _text$mn        segment para public 'CODE' use32
.text$mn:00006390                 assume cs:_text$mn
.text$mn:00006390                 ;org 6390h
.text$mn:00006390 ; COMDAT (pick any)
.text$mn:00006390                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006390
.text$mn:00006390 ; =============== S U B R O U T I N E =======================================
.text$mn:00006390
.text$mn:00006390 ; Attributes: bp-based frame
.text$mn:00006390
.text$mn:00006390 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00006390                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00006390 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00006390                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:00006390                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(wchar_t const *)+Ep
.text$mn:00006390
.text$mn:00006390 var_4           = dword ptr -4
.text$mn:00006390 Str             = dword ptr  8
.text$mn:00006390
.text$mn:00006390                 push    ebp
.text$mn:00006391                 mov     ebp, esp
.text$mn:00006393                 push    ecx
.text$mn:00006394                 mov     [ebp+var_4], ecx
.text$mn:00006397                 push    490h            ; unsigned int
.text$mn:0000639C                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000063A1                 mov     eax, [ebp+Str]
.text$mn:000063A4                 push    eax             ; int
.text$mn:000063A5                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000063AA                 add     esp, 0Ch
.text$mn:000063AD                 mov     ecx, [ebp+Str]
.text$mn:000063B0                 push    ecx             ; Str
.text$mn:000063B1                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:000063B6                 add     esp, 4
.text$mn:000063B9                 push    eax             ; int
.text$mn:000063BA                 mov     edx, [ebp+Str]
.text$mn:000063BD                 push    edx             ; Src
.text$mn:000063BE                 mov     ecx, [ebp+var_4]
.text$mn:000063C1                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:000063C6                 mov     esp, ebp
.text$mn:000063C8                 pop     ebp
.text$mn:000063C9                 retn    4
.text$mn:000063C9 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:000063C9
.text$mn:000063C9 _text$mn        ends
.text$mn:000063C9
.text$mn:000063CC ; ===========================================================================
.text$mn:000063CC
.text$mn:000063CC ; Segment type: Pure code
.text$mn:000063CC ; Segment permissions: Read/Execute
.text$mn:000063CC _text$mn        segment para public 'CODE' use32
.text$mn:000063CC                 assume cs:_text$mn
.text$mn:000063CC                 ;org 63CCh
.text$mn:000063CC ; COMDAT (pick any)
.text$mn:000063CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000063CC
.text$mn:000063CC ; =============== S U B R O U T I N E =======================================
.text$mn:000063CC
.text$mn:000063CC ; Attributes: bp-based frame
.text$mn:000063CC
.text$mn:000063CC ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:000063CC                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:000063CC ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:000063CC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:000063CC
.text$mn:000063CC var_4           = dword ptr -4
.text$mn:000063CC Src             = dword ptr  8
.text$mn:000063CC arg_4           = dword ptr  0Ch
.text$mn:000063CC
.text$mn:000063CC                 push    ebp
.text$mn:000063CD                 mov     ebp, esp
.text$mn:000063CF                 push    ecx
.text$mn:000063D0                 mov     [ebp+var_4], ecx
.text$mn:000063D3                 cmp     [ebp+arg_4], 0
.text$mn:000063D7                 jz      short loc_63EF
.text$mn:000063D9                 push    47Fh            ; unsigned int
.text$mn:000063DE                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000063E3                 mov     eax, [ebp+Src]
.text$mn:000063E6                 push    eax             ; int
.text$mn:000063E7                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000063EC                 add     esp, 0Ch
.text$mn:000063EF
.text$mn:000063EF loc_63EF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:000063EF                 mov     ecx, [ebp+Src]
.text$mn:000063F2                 push    ecx
.text$mn:000063F3                 mov     ecx, [ebp+var_4]
.text$mn:000063F6                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:000063FB                 movzx   edx, al
.text$mn:000063FE                 test    edx, edx
.text$mn:00006400                 jz      short loc_6424
.text$mn:00006402                 mov     eax, [ebp+arg_4]
.text$mn:00006405                 push    eax
.text$mn:00006406                 mov     ecx, [ebp+var_4]
.text$mn:00006409                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000640E                 mov     ecx, [ebp+Src]
.text$mn:00006411                 sub     ecx, eax
.text$mn:00006413                 sar     ecx, 1
.text$mn:00006415                 push    ecx
.text$mn:00006416                 mov     edx, [ebp+var_4]
.text$mn:00006419                 push    edx
.text$mn:0000641A                 mov     ecx, [ebp+var_4]
.text$mn:0000641D                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00006422                 jmp     short loc_6461
.text$mn:00006424 ; ---------------------------------------------------------------------------
.text$mn:00006424
.text$mn:00006424 loc_6424:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00006424                 push    0
.text$mn:00006426                 mov     eax, [ebp+arg_4]
.text$mn:00006429                 push    eax
.text$mn:0000642A                 mov     ecx, [ebp+var_4]
.text$mn:0000642D                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00006432                 movzx   ecx, al
.text$mn:00006435                 test    ecx, ecx
.text$mn:00006437                 jz      short loc_645E
.text$mn:00006439                 mov     edx, [ebp+arg_4]
.text$mn:0000643C                 push    edx             ; int
.text$mn:0000643D                 mov     eax, [ebp+Src]
.text$mn:00006440                 push    eax             ; Src
.text$mn:00006441                 mov     ecx, [ebp+var_4]
.text$mn:00006444                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006449                 push    eax             ; Dst
.text$mn:0000644A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000644F                 add     esp, 0Ch
.text$mn:00006452                 mov     ecx, [ebp+arg_4]
.text$mn:00006455                 push    ecx
.text$mn:00006456                 mov     ecx, [ebp+var_4]
.text$mn:00006459                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000645E
.text$mn:0000645E loc_645E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:0000645E                 mov     eax, [ebp+var_4]
.text$mn:00006461
.text$mn:00006461 loc_6461:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00006461                 mov     esp, ebp
.text$mn:00006463                 pop     ebp
.text$mn:00006464                 retn    8
.text$mn:00006464 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00006464
.text$mn:00006464 ; ---------------------------------------------------------------------------
.text$mn:00006467                 align 4
.text$mn:00006467 _text$mn        ends
.text$mn:00006467
.text$mn:00006468 ; ===========================================================================
.text$mn:00006468
.text$mn:00006468 ; Segment type: Pure code
.text$mn:00006468 ; Segment permissions: Read/Execute
.text$mn:00006468 _text$mn        segment para public 'CODE' use32
.text$mn:00006468                 assume cs:_text$mn
.text$mn:00006468                 ;org 6468h
.text$mn:00006468 ; COMDAT (pick any)
.text$mn:00006468                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006468
.text$mn:00006468 ; =============== S U B R O U T I N E =======================================
.text$mn:00006468
.text$mn:00006468 ; Attributes: bp-based frame
.text$mn:00006468
.text$mn:00006468 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00006468                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00006468 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00006468                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00006468
.text$mn:00006468 arg_0           = dword ptr  8
.text$mn:00006468 arg_4           = dword ptr  0Ch
.text$mn:00006468
.text$mn:00006468                 push    ebp
.text$mn:00006469                 mov     ebp, esp
.text$mn:0000646B                 mov     eax, [ebp+arg_0]
.text$mn:0000646E                 mov     ecx, [ebp+arg_4]
.text$mn:00006471                 mov     dl, [ecx]
.text$mn:00006473                 mov     [eax], dl
.text$mn:00006475                 pop     ebp
.text$mn:00006476                 retn
.text$mn:00006476 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00006476
.text$mn:00006476 ; ---------------------------------------------------------------------------
.text$mn:00006477                 align 4
.text$mn:00006477 _text$mn        ends
.text$mn:00006477
.text$mn:00006478 ; ===========================================================================
.text$mn:00006478
.text$mn:00006478 ; Segment type: Pure code
.text$mn:00006478 ; Segment permissions: Read/Execute
.text$mn:00006478 _text$mn        segment para public 'CODE' use32
.text$mn:00006478                 assume cs:_text$mn
.text$mn:00006478                 ;org 6478h
.text$mn:00006478 ; COMDAT (pick any)
.text$mn:00006478                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006478
.text$mn:00006478 ; =============== S U B R O U T I N E =======================================
.text$mn:00006478
.text$mn:00006478 ; Attributes: bp-based frame
.text$mn:00006478
.text$mn:00006478 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00006478                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00006478 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00006478                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00006478
.text$mn:00006478 arg_0           = dword ptr  8
.text$mn:00006478 arg_4           = dword ptr  0Ch
.text$mn:00006478
.text$mn:00006478                 push    ebp
.text$mn:00006479                 mov     ebp, esp
.text$mn:0000647B                 mov     eax, [ebp+arg_0]
.text$mn:0000647E                 mov     ecx, [ebp+arg_4]
.text$mn:00006481                 mov     dx, [ecx]
.text$mn:00006484                 mov     [eax], dx
.text$mn:00006487                 pop     ebp
.text$mn:00006488                 retn
.text$mn:00006488 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00006488
.text$mn:00006488 ; ---------------------------------------------------------------------------
.text$mn:00006489                 align 4
.text$mn:00006489 _text$mn        ends
.text$mn:00006489
.text$mn:0000648C ; ===========================================================================
.text$mn:0000648C
.text$mn:0000648C ; Segment type: Pure code
.text$mn:0000648C ; Segment permissions: Read/Execute
.text$mn:0000648C _text$mn        segment para public 'CODE' use32
.text$mn:0000648C                 assume cs:_text$mn
.text$mn:0000648C                 ;org 648Ch
.text$mn:0000648C ; COMDAT (pick any)
.text$mn:0000648C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000648C
.text$mn:0000648C ; =============== S U B R O U T I N E =======================================
.text$mn:0000648C
.text$mn:0000648C ; Attributes: bp-based frame
.text$mn:0000648C
.text$mn:0000648C ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::begin(void)
.text$mn:0000648C                 public ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:0000648C ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:0000648C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+A9p
.text$mn:0000648C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+AFp ...
.text$mn:0000648C
.text$mn:0000648C var_14          = dword ptr -14h
.text$mn:0000648C var_10          = dword ptr -10h
.text$mn:0000648C var_C           = dword ptr -0Ch
.text$mn:0000648C var_4           = dword ptr -4
.text$mn:0000648C arg_0           = dword ptr  8
.text$mn:0000648C
.text$mn:0000648C                 push    ebp
.text$mn:0000648D                 mov     ebp, esp
.text$mn:0000648F                 push    0FFFFFFFFh
.text$mn:00006491                 push    offset __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:00006496                 mov     eax, large fs:0
.text$mn:0000649C                 push    eax
.text$mn:0000649D                 sub     esp, 8
.text$mn:000064A0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000064A5                 xor     eax, ebp
.text$mn:000064A7                 push    eax
.text$mn:000064A8                 lea     eax, [ebp+var_C]
.text$mn:000064AB                 mov     large fs:0, eax
.text$mn:000064B1                 mov     [ebp+var_10], ecx
.text$mn:000064B4                 mov     [ebp+var_14], 0
.text$mn:000064BB                 mov     eax, [ebp+var_10]
.text$mn:000064BE                 push    eax             ; struct std::_Container_base12 *
.text$mn:000064BF                 mov     ecx, [ebp+var_10]
.text$mn:000064C2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000064C7                 push    eax             ; int
.text$mn:000064C8                 mov     ecx, [ebp+arg_0]
.text$mn:000064CB                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:000064D0                 mov     [ebp+var_4], 0
.text$mn:000064D7                 mov     ecx, [ebp+var_14]
.text$mn:000064DA                 or      ecx, 1
.text$mn:000064DD                 mov     [ebp+var_14], ecx
.text$mn:000064E0                 mov     eax, [ebp+arg_0]
.text$mn:000064E3                 mov     ecx, [ebp+var_C]
.text$mn:000064E6                 mov     large fs:0, ecx
.text$mn:000064ED                 pop     ecx
.text$mn:000064EE                 mov     esp, ebp
.text$mn:000064F0                 pop     ebp
.text$mn:000064F1                 retn    4
.text$mn:000064F1 ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:000064F1
.text$mn:000064F1 _text$mn        ends
.text$mn:000064F1
.text$x:000064F4 ; ===========================================================================
.text$x:000064F4
.text$x:000064F4 ; Segment type: Pure code
.text$x:000064F4 ; Segment permissions: Read/Execute
.text$x:000064F4 _text$x         segment para public 'CODE' use32
.text$x:000064F4                 assume cs:_text$x
.text$x:000064F4                 ;org 64F4h
.text$x:000064F4 ; COMDAT (pick associative to section at 648C)
.text$x:000064F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000064F4
.text$x:000064F4 ; =============== S U B R O U T I N E =======================================
.text$x:000064F4
.text$x:000064F4
.text$x:000064F4 __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:000064F4                                         ; DATA XREF: .xdata$x:00008680o
.text$x:000064F4                 mov     eax, [ebp-14h]
.text$x:000064F7                 and     eax, 1
.text$x:000064FA                 jz      $LN4
.text$x:00006500                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00006504                 mov     ecx, [ebp+8]
.text$x:00006507                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:0000650C ; ---------------------------------------------------------------------------
.text$x:0000650C
.text$x:0000650C $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:0000650C                 retn
.text$x:0000650C __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:0000650C
.text$x:0000650D
.text$x:0000650D ; =============== S U B R O U T I N E =======================================
.text$x:0000650D
.text$x:0000650D
.text$x:0000650D __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:0000650D                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)+5o
.text$x:0000650D
.text$x:0000650D arg_4           = dword ptr  8
.text$x:0000650D
.text$x:0000650D                 mov     edx, [esp+arg_4]
.text$x:00006511                 lea     eax, [edx+0Ch]
.text$x:00006514                 mov     ecx, [edx-0Ch]
.text$x:00006517                 xor     ecx, eax
.text$x:00006519                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000651E                 mov     eax, offset __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:00006523                 jmp     ___CxxFrameHandler3
.text$x:00006523 __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:00006523
.text$x:00006523 _text$x         ends
.text$x:00006523
.text$mn:00006528 ; ===========================================================================
.text$mn:00006528
.text$mn:00006528 ; Segment type: Pure code
.text$mn:00006528 ; Segment permissions: Read/Execute
.text$mn:00006528 _text$mn        segment para public 'CODE' use32
.text$mn:00006528                 assume cs:_text$mn
.text$mn:00006528                 ;org 6528h
.text$mn:00006528 ; COMDAT (pick any)
.text$mn:00006528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006528
.text$mn:00006528 ; =============== S U B R O U T I N E =======================================
.text$mn:00006528
.text$mn:00006528 ; Attributes: bp-based frame
.text$mn:00006528
.text$mn:00006528 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00006528                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00006528 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00006528                                         ; CODE XREF: Command::run(HWND__ *)+37p
.text$mn:00006528                                         ; RunDlg::run_dlgProc(uint,uint,long)+10Ap ...
.text$mn:00006528
.text$mn:00006528 var_4           = dword ptr -4
.text$mn:00006528
.text$mn:00006528                 push    ebp
.text$mn:00006529                 mov     ebp, esp
.text$mn:0000652B                 push    ecx
.text$mn:0000652C                 mov     [ebp+var_4], ecx
.text$mn:0000652F                 mov     ecx, [ebp+var_4]
.text$mn:00006532                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006537                 mov     esp, ebp
.text$mn:00006539                 pop     ebp
.text$mn:0000653A                 retn
.text$mn:0000653A ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:0000653A
.text$mn:0000653A ; ---------------------------------------------------------------------------
.text$mn:0000653B                 align 4
.text$mn:0000653B _text$mn        ends
.text$mn:0000653B
.text$mn:0000653C ; ===========================================================================
.text$mn:0000653C
.text$mn:0000653C ; Segment type: Pure code
.text$mn:0000653C ; Segment permissions: Read/Execute
.text$mn:0000653C _text$mn        segment para public 'CODE' use32
.text$mn:0000653C                 assume cs:_text$mn
.text$mn:0000653C                 ;org 653Ch
.text$mn:0000653C ; COMDAT (pick any)
.text$mn:0000653C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000653C
.text$mn:0000653C ; =============== S U B R O U T I N E =======================================
.text$mn:0000653C
.text$mn:0000653C ; Attributes: bp-based frame
.text$mn:0000653C
.text$mn:0000653C ; public: unsigned int __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::capacity(void)const
.text$mn:0000653C                 public ?capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ
.text$mn:0000653C ?capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:0000653C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Grow_to(uint)+Cp
.text$mn:0000653C
.text$mn:0000653C var_4           = dword ptr -4
.text$mn:0000653C
.text$mn:0000653C                 push    ebp
.text$mn:0000653D                 mov     ebp, esp
.text$mn:0000653F                 push    ecx
.text$mn:00006540                 mov     [ebp+var_4], ecx
.text$mn:00006543                 mov     eax, [ebp+var_4]
.text$mn:00006546                 mov     ecx, [ebp+var_4]
.text$mn:00006549                 mov     eax, [eax+0Ch]
.text$mn:0000654C                 sub     eax, [ecx+4]
.text$mn:0000654F                 cdq
.text$mn:00006550                 mov     ecx, 148h
.text$mn:00006555                 idiv    ecx
.text$mn:00006557                 mov     esp, ebp
.text$mn:00006559                 pop     ebp
.text$mn:0000655A                 retn
.text$mn:0000655A ?capacity@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ endp
.text$mn:0000655A
.text$mn:0000655A ; ---------------------------------------------------------------------------
.text$mn:0000655B                 align 4
.text$mn:0000655B _text$mn        ends
.text$mn:0000655B
.text$mn:0000655C ; ===========================================================================
.text$mn:0000655C
.text$mn:0000655C ; Segment type: Pure code
.text$mn:0000655C ; Segment permissions: Read/Execute
.text$mn:0000655C _text$mn        segment para public 'CODE' use32
.text$mn:0000655C                 assume cs:_text$mn
.text$mn:0000655C                 ;org 655Ch
.text$mn:0000655C ; COMDAT (pick any)
.text$mn:0000655C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000655C
.text$mn:0000655C ; =============== S U B R O U T I N E =======================================
.text$mn:0000655C
.text$mn:0000655C ; Attributes: bp-based frame
.text$mn:0000655C
.text$mn:0000655C ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:0000655C                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:0000655C ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000655C                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:0000655C
.text$mn:0000655C var_4           = dword ptr -4
.text$mn:0000655C
.text$mn:0000655C                 push    ebp
.text$mn:0000655D                 mov     ebp, esp
.text$mn:0000655F                 push    ecx
.text$mn:00006560                 mov     [ebp+var_4], ecx
.text$mn:00006563                 mov     eax, [ebp+var_4]
.text$mn:00006566                 mov     eax, [eax+4]
.text$mn:00006569                 mov     esp, ebp
.text$mn:0000656B                 pop     ebp
.text$mn:0000656C                 retn
.text$mn:0000656C ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000656C
.text$mn:0000656C ; ---------------------------------------------------------------------------
.text$mn:0000656D                 align 10h
.text$mn:0000656D _text$mn        ends
.text$mn:0000656D
.text$mn:00006570 ; ===========================================================================
.text$mn:00006570
.text$mn:00006570 ; Segment type: Pure code
.text$mn:00006570 ; Segment permissions: Read/Execute
.text$mn:00006570 _text$mn        segment para public 'CODE' use32
.text$mn:00006570                 assume cs:_text$mn
.text$mn:00006570                 ;org 6570h
.text$mn:00006570 ; COMDAT (pick any)
.text$mn:00006570                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006570
.text$mn:00006570 ; =============== S U B R O U T I N E =======================================
.text$mn:00006570
.text$mn:00006570 ; Attributes: bp-based frame
.text$mn:00006570
.text$mn:00006570 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00006570                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00006570 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00006570                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00006570                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00006570
.text$mn:00006570 var_4           = dword ptr -4
.text$mn:00006570
.text$mn:00006570                 push    ebp
.text$mn:00006571                 mov     ebp, esp
.text$mn:00006573                 push    ecx
.text$mn:00006574                 mov     [ebp+var_4], ecx
.text$mn:00006577                 mov     eax, [ebp+var_4]
.text$mn:0000657A                 mov     eax, [eax+4]
.text$mn:0000657D                 mov     esp, ebp
.text$mn:0000657F                 pop     ebp
.text$mn:00006580                 retn
.text$mn:00006580 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00006580
.text$mn:00006580 ; ---------------------------------------------------------------------------
.text$mn:00006581                 align 4
.text$mn:00006581 _text$mn        ends
.text$mn:00006581
.text$mn:00006584 ; ===========================================================================
.text$mn:00006584
.text$mn:00006584 ; Segment type: Pure code
.text$mn:00006584 ; Segment permissions: Read/Execute
.text$mn:00006584 _text$mn        segment para public 'CODE' use32
.text$mn:00006584                 assume cs:_text$mn
.text$mn:00006584                 ;org 6584h
.text$mn:00006584 ; COMDAT (pick any)
.text$mn:00006584                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006584
.text$mn:00006584 ; =============== S U B R O U T I N E =======================================
.text$mn:00006584
.text$mn:00006584 ; Attributes: bp-based frame
.text$mn:00006584
.text$mn:00006584 ; public: int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::compare(unsigned int, unsigned int, wchar_t const *, unsigned int)const
.text$mn:00006584                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z
.text$mn:00006584 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z proc near
.text$mn:00006584                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t const *)+3Ap
.text$mn:00006584
.text$mn:00006584 var_18          = dword ptr -18h
.text$mn:00006584 var_14          = dword ptr -14h
.text$mn:00006584 var_10          = dword ptr -10h
.text$mn:00006584 var_C           = dword ptr -0Ch
.text$mn:00006584 var_8           = dword ptr -8
.text$mn:00006584 var_4           = dword ptr -4
.text$mn:00006584 arg_0           = dword ptr  8
.text$mn:00006584 arg_4           = dword ptr  0Ch
.text$mn:00006584 arg_8           = dword ptr  10h
.text$mn:00006584 arg_C           = dword ptr  14h
.text$mn:00006584
.text$mn:00006584                 push    ebp
.text$mn:00006585                 mov     ebp, esp
.text$mn:00006587                 sub     esp, 18h
.text$mn:0000658A                 mov     [ebp+var_4], ecx
.text$mn:0000658D                 cmp     [ebp+arg_C], 0
.text$mn:00006591                 jz      short loc_65A9
.text$mn:00006593                 push    87Dh            ; unsigned int
.text$mn:00006598                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000659D                 mov     eax, [ebp+arg_8]
.text$mn:000065A0                 push    eax             ; int
.text$mn:000065A1                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:000065A6                 add     esp, 0Ch
.text$mn:000065A9
.text$mn:000065A9 loc_65A9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+Dj
.text$mn:000065A9                 mov     ecx, [ebp+var_4]
.text$mn:000065AC                 mov     edx, [ecx+14h]
.text$mn:000065AF                 cmp     edx, [ebp+arg_0]
.text$mn:000065B2                 jnb     short loc_65BC
.text$mn:000065B4                 mov     ecx, [ebp+var_4]
.text$mn:000065B7                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000065BC
.text$mn:000065BC loc_65BC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+2Ej
.text$mn:000065BC                 mov     eax, [ebp+var_4]
.text$mn:000065BF                 mov     ecx, [eax+14h]
.text$mn:000065C2                 sub     ecx, [ebp+arg_0]
.text$mn:000065C5                 cmp     ecx, [ebp+arg_4]
.text$mn:000065C8                 jnb     short loc_65D6
.text$mn:000065CA                 mov     edx, [ebp+var_4]
.text$mn:000065CD                 mov     eax, [edx+14h]
.text$mn:000065D0                 sub     eax, [ebp+arg_0]
.text$mn:000065D3                 mov     [ebp+arg_4], eax
.text$mn:000065D6
.text$mn:000065D6 loc_65D6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+44j
.text$mn:000065D6                 mov     ecx, [ebp+arg_4]
.text$mn:000065D9                 cmp     ecx, [ebp+arg_C]
.text$mn:000065DC                 jnb     short loc_65E6
.text$mn:000065DE                 mov     edx, [ebp+arg_4]
.text$mn:000065E1                 mov     [ebp+var_8], edx
.text$mn:000065E4                 jmp     short loc_65EC
.text$mn:000065E6 ; ---------------------------------------------------------------------------
.text$mn:000065E6
.text$mn:000065E6 loc_65E6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+58j
.text$mn:000065E6                 mov     eax, [ebp+arg_C]
.text$mn:000065E9                 mov     [ebp+var_8], eax
.text$mn:000065EC
.text$mn:000065EC loc_65EC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+60j
.text$mn:000065EC                 mov     ecx, [ebp+var_8]
.text$mn:000065EF                 push    ecx
.text$mn:000065F0                 mov     edx, [ebp+arg_8]
.text$mn:000065F3                 push    edx
.text$mn:000065F4                 mov     ecx, [ebp+var_4]
.text$mn:000065F7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000065FC                 mov     ecx, [ebp+arg_0]
.text$mn:000065FF                 lea     edx, [eax+ecx*2]
.text$mn:00006602                 push    edx
.text$mn:00006603                 call    ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z ; std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)
.text$mn:00006608                 add     esp, 0Ch
.text$mn:0000660B                 mov     [ebp+var_C], eax
.text$mn:0000660E                 cmp     [ebp+var_C], 0
.text$mn:00006612                 jz      short loc_661C
.text$mn:00006614                 mov     eax, [ebp+var_C]
.text$mn:00006617                 mov     [ebp+var_18], eax
.text$mn:0000661A                 jmp     short loc_6651
.text$mn:0000661C ; ---------------------------------------------------------------------------
.text$mn:0000661C
.text$mn:0000661C loc_661C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+8Ej
.text$mn:0000661C                 mov     ecx, [ebp+arg_4]
.text$mn:0000661F                 cmp     ecx, [ebp+arg_C]
.text$mn:00006622                 jnb     short loc_662D
.text$mn:00006624                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:0000662B                 jmp     short loc_664B
.text$mn:0000662D ; ---------------------------------------------------------------------------
.text$mn:0000662D
.text$mn:0000662D loc_662D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+9Ej
.text$mn:0000662D                 mov     edx, [ebp+arg_4]
.text$mn:00006630                 cmp     edx, [ebp+arg_C]
.text$mn:00006633                 jnz     short loc_663E
.text$mn:00006635                 mov     [ebp+var_10], 0
.text$mn:0000663C                 jmp     short loc_6645
.text$mn:0000663E ; ---------------------------------------------------------------------------
.text$mn:0000663E
.text$mn:0000663E loc_663E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+AFj
.text$mn:0000663E                 mov     [ebp+var_10], 1
.text$mn:00006645
.text$mn:00006645 loc_6645:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+B8j
.text$mn:00006645                 mov     eax, [ebp+var_10]
.text$mn:00006648                 mov     [ebp+var_14], eax
.text$mn:0000664B
.text$mn:0000664B loc_664B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+A7j
.text$mn:0000664B                 mov     ecx, [ebp+var_14]
.text$mn:0000664E                 mov     [ebp+var_18], ecx
.text$mn:00006651
.text$mn:00006651 loc_6651:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+96j
.text$mn:00006651                 mov     eax, [ebp+var_18]
.text$mn:00006654                 mov     esp, ebp
.text$mn:00006656                 pop     ebp
.text$mn:00006657                 retn    10h
.text$mn:00006657 ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z endp
.text$mn:00006657
.text$mn:00006657 ; ---------------------------------------------------------------------------
.text$mn:0000665A                 align 4
.text$mn:0000665A _text$mn        ends
.text$mn:0000665A
.text$mn:0000665C ; ===========================================================================
.text$mn:0000665C
.text$mn:0000665C ; Segment type: Pure code
.text$mn:0000665C ; Segment permissions: Read/Execute
.text$mn:0000665C _text$mn        segment para public 'CODE' use32
.text$mn:0000665C                 assume cs:_text$mn
.text$mn:0000665C                 ;org 665Ch
.text$mn:0000665C ; COMDAT (pick any)
.text$mn:0000665C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000665C
.text$mn:0000665C ; =============== S U B R O U T I N E =======================================
.text$mn:0000665C
.text$mn:0000665C ; Attributes: bp-based frame
.text$mn:0000665C
.text$mn:0000665C ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(wchar_t *Str)
.text$mn:0000665C                 public ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z
.text$mn:0000665C ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z proc near
.text$mn:0000665C                                         ; CODE XREF: std::operator==<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,wchar_t const *)+Bp
.text$mn:0000665C
.text$mn:0000665C var_4           = dword ptr -4
.text$mn:0000665C Str             = dword ptr  8
.text$mn:0000665C
.text$mn:0000665C                 push    ebp
.text$mn:0000665D                 mov     ebp, esp
.text$mn:0000665F                 push    ecx
.text$mn:00006660                 mov     [ebp+var_4], ecx
.text$mn:00006663                 push    86Eh            ; unsigned int
.text$mn:00006668                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000666D                 mov     eax, [ebp+Str]
.text$mn:00006670                 push    eax             ; int
.text$mn:00006671                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00006676                 add     esp, 0Ch
.text$mn:00006679                 mov     ecx, [ebp+Str]
.text$mn:0000667C                 push    ecx             ; Str
.text$mn:0000667D                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00006682                 add     esp, 4
.text$mn:00006685                 push    eax
.text$mn:00006686                 mov     edx, [ebp+Str]
.text$mn:00006689                 push    edx
.text$mn:0000668A                 mov     eax, [ebp+var_4]
.text$mn:0000668D                 mov     ecx, [eax+14h]
.text$mn:00006690                 push    ecx
.text$mn:00006691                 push    0
.text$mn:00006693                 mov     ecx, [ebp+var_4]
.text$mn:00006696                 call    ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHIIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)
.text$mn:0000669B                 mov     esp, ebp
.text$mn:0000669D                 pop     ebp
.text$mn:0000669E                 retn    4
.text$mn:0000669E ?compare@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEHPB_W@Z endp
.text$mn:0000669E
.text$mn:0000669E ; ---------------------------------------------------------------------------
.text$mn:000066A1                 align 4
.text$mn:000066A1 _text$mn        ends
.text$mn:000066A1
.text$mn:000066A4 ; ===========================================================================
.text$mn:000066A4
.text$mn:000066A4 ; Segment type: Pure code
.text$mn:000066A4 ; Segment permissions: Read/Execute
.text$mn:000066A4 _text$mn        segment para public 'CODE' use32
.text$mn:000066A4                 assume cs:_text$mn
.text$mn:000066A4                 ;org 66A4h
.text$mn:000066A4 ; COMDAT (pick any)
.text$mn:000066A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066A4
.text$mn:000066A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000066A4
.text$mn:000066A4 ; Attributes: bp-based frame
.text$mn:000066A4
.text$mn:000066A4 ; public: static int __cdecl std::char_traits<wchar_t>::compare(wchar_t const *, wchar_t const *, unsigned int)
.text$mn:000066A4                 public ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z
.text$mn:000066A4 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z proc near
.text$mn:000066A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::compare(uint,uint,wchar_t const *,uint)+7Fp
.text$mn:000066A4
.text$mn:000066A4 var_4           = dword ptr -4
.text$mn:000066A4 arg_0           = dword ptr  8
.text$mn:000066A4 arg_4           = dword ptr  0Ch
.text$mn:000066A4 arg_8           = dword ptr  10h
.text$mn:000066A4
.text$mn:000066A4                 push    ebp
.text$mn:000066A5                 mov     ebp, esp
.text$mn:000066A7                 push    ecx
.text$mn:000066A8                 cmp     [ebp+arg_8], 0
.text$mn:000066AC                 jnz     short loc_66B7
.text$mn:000066AE                 mov     [ebp+var_4], 0
.text$mn:000066B5                 jmp     short loc_66CE
.text$mn:000066B7 ; ---------------------------------------------------------------------------
.text$mn:000066B7
.text$mn:000066B7 loc_66B7:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+8j
.text$mn:000066B7                 mov     eax, [ebp+arg_8]
.text$mn:000066BA                 push    eax
.text$mn:000066BB                 mov     ecx, [ebp+arg_4]
.text$mn:000066BE                 push    ecx
.text$mn:000066BF                 mov     edx, [ebp+arg_0]
.text$mn:000066C2                 push    edx
.text$mn:000066C3                 call    _wmemcmp
.text$mn:000066C8                 add     esp, 0Ch
.text$mn:000066CB                 mov     [ebp+var_4], eax
.text$mn:000066CE
.text$mn:000066CE loc_66CE:                               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+11j
.text$mn:000066CE                 mov     eax, [ebp+var_4]
.text$mn:000066D1                 mov     esp, ebp
.text$mn:000066D3                 pop     ebp
.text$mn:000066D4                 retn
.text$mn:000066D4 ?compare@?$char_traits@_W@std@@SAHPB_W0I@Z endp
.text$mn:000066D4
.text$mn:000066D4 ; ---------------------------------------------------------------------------
.text$mn:000066D5                 align 4
.text$mn:000066D5 _text$mn        ends
.text$mn:000066D5
.text$mn:000066D8 ; ===========================================================================
.text$mn:000066D8
.text$mn:000066D8 ; Segment type: Pure code
.text$mn:000066D8 ; Segment permissions: Read/Execute
.text$mn:000066D8 _text$mn        segment para public 'CODE' use32
.text$mn:000066D8                 assume cs:_text$mn
.text$mn:000066D8                 ;org 66D8h
.text$mn:000066D8 ; COMDAT (pick any)
.text$mn:000066D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066D8
.text$mn:000066D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000066D8
.text$mn:000066D8 ; Attributes: bp-based frame
.text$mn:000066D8
.text$mn:000066D8 ; int __stdcall std::allocator<UserCommand>::construct(void *, struct CommandShortcut *)
.text$mn:000066D8                 public ?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z
.text$mn:000066D8 ?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z proc near
.text$mn:000066D8                                         ; CODE XREF: std::allocator_traits<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(std::allocator<UserCommand> &,UserCommand *,UserCommand const &)+17p
.text$mn:000066D8
.text$mn:000066D8 var_1C          = dword ptr -1Ch
.text$mn:000066D8 var_18          = dword ptr -18h
.text$mn:000066D8 var_14          = dword ptr -14h
.text$mn:000066D8 var_10          = dword ptr -10h
.text$mn:000066D8 var_C           = dword ptr -0Ch
.text$mn:000066D8 var_4           = dword ptr -4
.text$mn:000066D8 arg_0           = dword ptr  8
.text$mn:000066D8 arg_4           = dword ptr  0Ch
.text$mn:000066D8
.text$mn:000066D8                 push    ebp
.text$mn:000066D9                 mov     ebp, esp
.text$mn:000066DB                 push    0FFFFFFFFh
.text$mn:000066DD                 push    offset __ehhandler$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z
.text$mn:000066E2                 mov     eax, large fs:0
.text$mn:000066E8                 push    eax
.text$mn:000066E9                 sub     esp, 10h
.text$mn:000066EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000066F1                 xor     eax, ebp
.text$mn:000066F3                 push    eax
.text$mn:000066F4                 lea     eax, [ebp+var_C]
.text$mn:000066F7                 mov     large fs:0, eax
.text$mn:000066FD                 mov     [ebp+var_18], ecx
.text$mn:00006700                 mov     eax, [ebp+arg_0]
.text$mn:00006703                 push    eax             ; void *
.text$mn:00006704                 push    148h            ; unsigned int
.text$mn:00006709                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000670E                 add     esp, 8
.text$mn:00006711                 mov     [ebp+var_10], eax
.text$mn:00006714                 mov     [ebp+var_4], 0
.text$mn:0000671B                 cmp     [ebp+var_10], 0
.text$mn:0000671F                 jz      short loc_6732
.text$mn:00006721                 mov     ecx, [ebp+arg_4]
.text$mn:00006724                 push    ecx             ; struct CommandShortcut *
.text$mn:00006725                 mov     ecx, [ebp+var_10]
.text$mn:00006728                 call    ??0UserCommand@@QAE@ABV0@@Z ; UserCommand::UserCommand(UserCommand const &)
.text$mn:0000672D                 mov     [ebp+var_14], eax
.text$mn:00006730                 jmp     short loc_6739
.text$mn:00006732 ; ---------------------------------------------------------------------------
.text$mn:00006732
.text$mn:00006732 loc_6732:                               ; CODE XREF: std::allocator<UserCommand>::construct(UserCommand *,UserCommand const &)+47j
.text$mn:00006732                 mov     [ebp+var_14], 0
.text$mn:00006739
.text$mn:00006739 loc_6739:                               ; CODE XREF: std::allocator<UserCommand>::construct(UserCommand *,UserCommand const &)+58j
.text$mn:00006739                 mov     edx, [ebp+var_14]
.text$mn:0000673C                 mov     [ebp+var_1C], edx
.text$mn:0000673F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006746                 mov     ecx, [ebp+var_C]
.text$mn:00006749                 mov     large fs:0, ecx
.text$mn:00006750                 pop     ecx
.text$mn:00006751                 mov     esp, ebp
.text$mn:00006753                 pop     ebp
.text$mn:00006754                 retn    8
.text$mn:00006754 ?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z endp
.text$mn:00006754
.text$mn:00006754 ; ---------------------------------------------------------------------------
.text$mn:00006757                 align 4
.text$mn:00006757 _text$mn        ends
.text$mn:00006757
.text$x:00006758 ; ===========================================================================
.text$x:00006758
.text$x:00006758 ; Segment type: Pure code
.text$x:00006758 ; Segment permissions: Read/Execute
.text$x:00006758 _text$x         segment para public 'CODE' use32
.text$x:00006758                 assume cs:_text$x
.text$x:00006758                 ;org 6758h
.text$x:00006758 ; COMDAT (pick associative to section at 66D8)
.text$x:00006758                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006758
.text$x:00006758 ; =============== S U B R O U T I N E =======================================
.text$x:00006758
.text$x:00006758
.text$x:00006758 __unwindfunclet$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z$0 proc near
.text$x:00006758                                         ; DATA XREF: .xdata$x:000089F4o
.text$x:00006758                 mov     eax, [ebp+8]
.text$x:0000675B                 push    eax
.text$x:0000675C                 mov     eax, [ebp-10h]
.text$x:0000675F                 push    eax             ; void *
.text$x:00006760                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00006765                 add     esp, 8
.text$x:00006768                 retn
.text$x:00006768 __unwindfunclet$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z$0 endp
.text$x:00006768
.text$x:00006769
.text$x:00006769 ; =============== S U B R O U T I N E =======================================
.text$x:00006769
.text$x:00006769
.text$x:00006769 __ehhandler$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z proc near
.text$x:00006769                                         ; DATA XREF: std::allocator<UserCommand>::construct(UserCommand *,UserCommand const &)+5o
.text$x:00006769
.text$x:00006769 arg_4           = dword ptr  8
.text$x:00006769
.text$x:00006769                 mov     edx, [esp+arg_4]
.text$x:0000676D                 lea     eax, [edx+0Ch]
.text$x:00006770                 mov     ecx, [edx-14h]
.text$x:00006773                 xor     ecx, eax
.text$x:00006775                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000677A                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z
.text$x:0000677F                 jmp     ___CxxFrameHandler3
.text$x:0000677F __ehhandler$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z endp
.text$x:0000677F
.text$x:0000677F _text$x         ends
.text$x:0000677F
.text$mn:00006784 ; ===========================================================================
.text$mn:00006784
.text$mn:00006784 ; Segment type: Pure code
.text$mn:00006784 ; Segment permissions: Read/Execute
.text$mn:00006784 _text$mn        segment para public 'CODE' use32
.text$mn:00006784                 assume cs:_text$mn
.text$mn:00006784                 ;org 6784h
.text$mn:00006784 ; COMDAT (pick any)
.text$mn:00006784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006784
.text$mn:00006784 ; =============== S U B R O U T I N E =======================================
.text$mn:00006784
.text$mn:00006784 ; Attributes: bp-based frame
.text$mn:00006784
.text$mn:00006784 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00006784                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00006784 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00006784                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00006784
.text$mn:00006784 var_4           = dword ptr -4
.text$mn:00006784 Dst             = dword ptr  8
.text$mn:00006784 Src             = dword ptr  0Ch
.text$mn:00006784 Size            = dword ptr  10h
.text$mn:00006784
.text$mn:00006784                 push    ebp
.text$mn:00006785                 mov     ebp, esp
.text$mn:00006787                 push    ecx
.text$mn:00006788                 cmp     [ebp+Size], 0
.text$mn:0000678C                 jnz     short loc_6796
.text$mn:0000678E                 mov     eax, [ebp+Dst]
.text$mn:00006791                 mov     [ebp+var_4], eax
.text$mn:00006794                 jmp     short loc_67AD
.text$mn:00006796 ; ---------------------------------------------------------------------------
.text$mn:00006796
.text$mn:00006796 loc_6796:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00006796                 mov     ecx, [ebp+Size]
.text$mn:00006799                 push    ecx             ; Size
.text$mn:0000679A                 mov     edx, [ebp+Src]
.text$mn:0000679D                 push    edx             ; Src
.text$mn:0000679E                 mov     eax, [ebp+Dst]
.text$mn:000067A1                 push    eax             ; Dst
.text$mn:000067A2                 call    _memcpy
.text$mn:000067A7                 add     esp, 0Ch
.text$mn:000067AA                 mov     [ebp+var_4], eax
.text$mn:000067AD
.text$mn:000067AD loc_67AD:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000067AD                 mov     eax, [ebp+var_4]
.text$mn:000067B0                 mov     esp, ebp
.text$mn:000067B2                 pop     ebp
.text$mn:000067B3                 retn
.text$mn:000067B3 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000067B3
.text$mn:000067B3 _text$mn        ends
.text$mn:000067B3
.text$mn:000067B4 ; ===========================================================================
.text$mn:000067B4
.text$mn:000067B4 ; Segment type: Pure code
.text$mn:000067B4 ; Segment permissions: Read/Execute
.text$mn:000067B4 _text$mn        segment para public 'CODE' use32
.text$mn:000067B4                 assume cs:_text$mn
.text$mn:000067B4                 ;org 67B4h
.text$mn:000067B4 ; COMDAT (pick any)
.text$mn:000067B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067B4
.text$mn:000067B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000067B4
.text$mn:000067B4 ; Attributes: bp-based frame
.text$mn:000067B4
.text$mn:000067B4 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:000067B4                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:000067B4 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:000067B4                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:000067B4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:000067B4
.text$mn:000067B4 var_4           = dword ptr -4
.text$mn:000067B4 Dst             = dword ptr  8
.text$mn:000067B4 Src             = dword ptr  0Ch
.text$mn:000067B4 arg_8           = dword ptr  10h
.text$mn:000067B4
.text$mn:000067B4                 push    ebp
.text$mn:000067B5                 mov     ebp, esp
.text$mn:000067B7                 push    ecx
.text$mn:000067B8                 cmp     [ebp+arg_8], 0
.text$mn:000067BC                 jnz     short loc_67C6
.text$mn:000067BE                 mov     eax, [ebp+Dst]
.text$mn:000067C1                 mov     [ebp+var_4], eax
.text$mn:000067C4                 jmp     short loc_67DD
.text$mn:000067C6 ; ---------------------------------------------------------------------------
.text$mn:000067C6
.text$mn:000067C6 loc_67C6:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000067C6                 mov     ecx, [ebp+arg_8]
.text$mn:000067C9                 push    ecx             ; int
.text$mn:000067CA                 mov     edx, [ebp+Src]
.text$mn:000067CD                 push    edx             ; Src
.text$mn:000067CE                 mov     eax, [ebp+Dst]
.text$mn:000067D1                 push    eax             ; Dst
.text$mn:000067D2                 call    _wmemcpy
.text$mn:000067D7                 add     esp, 0Ch
.text$mn:000067DA                 mov     [ebp+var_4], eax
.text$mn:000067DD
.text$mn:000067DD loc_67DD:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:000067DD                 mov     eax, [ebp+var_4]
.text$mn:000067E0                 mov     esp, ebp
.text$mn:000067E2                 pop     ebp
.text$mn:000067E3                 retn
.text$mn:000067E3 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:000067E3
.text$mn:000067E3 _text$mn        ends
.text$mn:000067E3
.text$mn:000067E4 ; ===========================================================================
.text$mn:000067E4
.text$mn:000067E4 ; Segment type: Pure code
.text$mn:000067E4 ; Segment permissions: Read/Execute
.text$mn:000067E4 _text$mn        segment para public 'CODE' use32
.text$mn:000067E4                 assume cs:_text$mn
.text$mn:000067E4                 ;org 67E4h
.text$mn:000067E4 ; COMDAT (pick any)
.text$mn:000067E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067E4
.text$mn:000067E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000067E4
.text$mn:000067E4 ; Attributes: bp-based frame
.text$mn:000067E4
.text$mn:000067E4 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000067E4                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000067E4 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000067E4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000067E4
.text$mn:000067E4 var_4           = dword ptr -4
.text$mn:000067E4 arg_0           = dword ptr  8
.text$mn:000067E4 arg_4           = dword ptr  0Ch
.text$mn:000067E4
.text$mn:000067E4                 push    ebp
.text$mn:000067E5                 mov     ebp, esp
.text$mn:000067E7                 push    ecx
.text$mn:000067E8                 mov     [ebp+var_4], ecx
.text$mn:000067EB                 mov     eax, [ebp+arg_4]
.text$mn:000067EE                 push    eax             ; int
.text$mn:000067EF                 mov     ecx, [ebp+arg_0]
.text$mn:000067F2                 push    ecx             ; void *
.text$mn:000067F3                 mov     ecx, [ebp+var_4]
.text$mn:000067F6                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000067FB                 mov     esp, ebp
.text$mn:000067FD                 pop     ebp
.text$mn:000067FE                 retn    8
.text$mn:000067FE ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000067FE
.text$mn:000067FE ; ---------------------------------------------------------------------------
.text$mn:00006801                 align 4
.text$mn:00006801 _text$mn        ends
.text$mn:00006801
.text$mn:00006804 ; ===========================================================================
.text$mn:00006804
.text$mn:00006804 ; Segment type: Pure code
.text$mn:00006804 ; Segment permissions: Read/Execute
.text$mn:00006804 _text$mn        segment para public 'CODE' use32
.text$mn:00006804                 assume cs:_text$mn
.text$mn:00006804                 ;org 6804h
.text$mn:00006804 ; COMDAT (pick any)
.text$mn:00006804                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006804
.text$mn:00006804 ; =============== S U B R O U T I N E =======================================
.text$mn:00006804
.text$mn:00006804 ; Attributes: bp-based frame
.text$mn:00006804
.text$mn:00006804 ; int __stdcall std::_Wrap_alloc<std::allocator<UserCommand>>::deallocate(void *, int)
.text$mn:00006804                 public ?deallocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@I@Z
.text$mn:00006804 ?deallocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@I@Z proc near
.text$mn:00006804                                         ; CODE XREF: __catch$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z$0+16p
.text$mn:00006804                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+FAp
.text$mn:00006804
.text$mn:00006804 var_4           = dword ptr -4
.text$mn:00006804 arg_0           = dword ptr  8
.text$mn:00006804 arg_4           = dword ptr  0Ch
.text$mn:00006804
.text$mn:00006804                 push    ebp
.text$mn:00006805                 mov     ebp, esp
.text$mn:00006807                 push    ecx
.text$mn:00006808                 mov     [ebp+var_4], ecx
.text$mn:0000680B                 mov     eax, [ebp+arg_4]
.text$mn:0000680E                 push    eax             ; int
.text$mn:0000680F                 mov     ecx, [ebp+arg_0]
.text$mn:00006812                 push    ecx             ; void *
.text$mn:00006813                 mov     ecx, [ebp+var_4]
.text$mn:00006816                 call    ?deallocate@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@I@Z ; std::allocator<UserCommand>::deallocate(UserCommand *,uint)
.text$mn:0000681B                 mov     esp, ebp
.text$mn:0000681D                 pop     ebp
.text$mn:0000681E                 retn    8
.text$mn:0000681E ?deallocate@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@I@Z endp
.text$mn:0000681E
.text$mn:0000681E ; ---------------------------------------------------------------------------
.text$mn:00006821                 align 4
.text$mn:00006821 _text$mn        ends
.text$mn:00006821
.text$mn:00006824 ; ===========================================================================
.text$mn:00006824
.text$mn:00006824 ; Segment type: Pure code
.text$mn:00006824 ; Segment permissions: Read/Execute
.text$mn:00006824 _text$mn        segment para public 'CODE' use32
.text$mn:00006824                 assume cs:_text$mn
.text$mn:00006824                 ;org 6824h
.text$mn:00006824 ; COMDAT (pick any)
.text$mn:00006824                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006824
.text$mn:00006824 ; =============== S U B R O U T I N E =======================================
.text$mn:00006824
.text$mn:00006824 ; Attributes: bp-based frame
.text$mn:00006824
.text$mn:00006824 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00006824                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00006824 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00006824                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00006824
.text$mn:00006824 var_4           = dword ptr -4
.text$mn:00006824 arg_0           = dword ptr  8
.text$mn:00006824 arg_4           = dword ptr  0Ch
.text$mn:00006824
.text$mn:00006824                 push    ebp
.text$mn:00006825                 mov     ebp, esp
.text$mn:00006827                 push    ecx
.text$mn:00006828                 mov     [ebp+var_4], ecx
.text$mn:0000682B                 mov     eax, [ebp+arg_4]
.text$mn:0000682E                 push    eax             ; int
.text$mn:0000682F                 mov     ecx, [ebp+arg_0]
.text$mn:00006832                 push    ecx             ; void *
.text$mn:00006833                 mov     ecx, [ebp+var_4]
.text$mn:00006836                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:0000683B                 mov     esp, ebp
.text$mn:0000683D                 pop     ebp
.text$mn:0000683E                 retn    8
.text$mn:0000683E ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:0000683E
.text$mn:0000683E ; ---------------------------------------------------------------------------
.text$mn:00006841                 align 4
.text$mn:00006841 _text$mn        ends
.text$mn:00006841
.text$mn:00006844 ; ===========================================================================
.text$mn:00006844
.text$mn:00006844 ; Segment type: Pure code
.text$mn:00006844 ; Segment permissions: Read/Execute
.text$mn:00006844 _text$mn        segment para public 'CODE' use32
.text$mn:00006844                 assume cs:_text$mn
.text$mn:00006844                 ;org 6844h
.text$mn:00006844 ; COMDAT (pick any)
.text$mn:00006844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006844
.text$mn:00006844 ; =============== S U B R O U T I N E =======================================
.text$mn:00006844
.text$mn:00006844 ; Attributes: bp-based frame
.text$mn:00006844
.text$mn:00006844 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00006844                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00006844 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00006844                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00006844
.text$mn:00006844 var_4           = dword ptr -4
.text$mn:00006844 arg_0           = dword ptr  8
.text$mn:00006844
.text$mn:00006844                 push    ebp
.text$mn:00006845                 mov     ebp, esp
.text$mn:00006847                 push    ecx
.text$mn:00006848                 mov     [ebp+var_4], ecx
.text$mn:0000684B                 mov     eax, [ebp+arg_0]
.text$mn:0000684E                 push    eax             ; void *
.text$mn:0000684F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006854                 add     esp, 4
.text$mn:00006857                 mov     esp, ebp
.text$mn:00006859                 pop     ebp
.text$mn:0000685A                 retn    8
.text$mn:0000685A ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:0000685A
.text$mn:0000685A ; ---------------------------------------------------------------------------
.text$mn:0000685D                 align 10h
.text$mn:0000685D _text$mn        ends
.text$mn:0000685D
.text$mn:00006860 ; ===========================================================================
.text$mn:00006860
.text$mn:00006860 ; Segment type: Pure code
.text$mn:00006860 ; Segment permissions: Read/Execute
.text$mn:00006860 _text$mn        segment para public 'CODE' use32
.text$mn:00006860                 assume cs:_text$mn
.text$mn:00006860                 ;org 6860h
.text$mn:00006860 ; COMDAT (pick any)
.text$mn:00006860                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006860
.text$mn:00006860 ; =============== S U B R O U T I N E =======================================
.text$mn:00006860
.text$mn:00006860 ; Attributes: bp-based frame
.text$mn:00006860
.text$mn:00006860 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00006860                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00006860 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00006860                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00006860                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:00006860
.text$mn:00006860 var_4           = dword ptr -4
.text$mn:00006860 arg_0           = dword ptr  8
.text$mn:00006860
.text$mn:00006860                 push    ebp
.text$mn:00006861                 mov     ebp, esp
.text$mn:00006863                 push    ecx
.text$mn:00006864                 mov     [ebp+var_4], ecx
.text$mn:00006867                 mov     eax, [ebp+arg_0]
.text$mn:0000686A                 push    eax             ; void *
.text$mn:0000686B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006870                 add     esp, 4
.text$mn:00006873                 mov     esp, ebp
.text$mn:00006875                 pop     ebp
.text$mn:00006876                 retn    8
.text$mn:00006876 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00006876
.text$mn:00006876 ; ---------------------------------------------------------------------------
.text$mn:00006879                 align 4
.text$mn:00006879 _text$mn        ends
.text$mn:00006879
.text$mn:0000687C ; ===========================================================================
.text$mn:0000687C
.text$mn:0000687C ; Segment type: Pure code
.text$mn:0000687C ; Segment permissions: Read/Execute
.text$mn:0000687C _text$mn        segment para public 'CODE' use32
.text$mn:0000687C                 assume cs:_text$mn
.text$mn:0000687C                 ;org 687Ch
.text$mn:0000687C ; COMDAT (pick any)
.text$mn:0000687C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000687C
.text$mn:0000687C ; =============== S U B R O U T I N E =======================================
.text$mn:0000687C
.text$mn:0000687C ; Attributes: bp-based frame
.text$mn:0000687C
.text$mn:0000687C ; int __stdcall std::allocator<UserCommand>::deallocate(void *, int)
.text$mn:0000687C                 public ?deallocate@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@I@Z
.text$mn:0000687C ?deallocate@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@I@Z proc near
.text$mn:0000687C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::deallocate(UserCommand *,uint)+12p
.text$mn:0000687C
.text$mn:0000687C var_4           = dword ptr -4
.text$mn:0000687C arg_0           = dword ptr  8
.text$mn:0000687C
.text$mn:0000687C                 push    ebp
.text$mn:0000687D                 mov     ebp, esp
.text$mn:0000687F                 push    ecx
.text$mn:00006880                 mov     [ebp+var_4], ecx
.text$mn:00006883                 mov     eax, [ebp+arg_0]
.text$mn:00006886                 push    eax             ; void *
.text$mn:00006887                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000688C                 add     esp, 4
.text$mn:0000688F                 mov     esp, ebp
.text$mn:00006891                 pop     ebp
.text$mn:00006892                 retn    8
.text$mn:00006892 ?deallocate@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@I@Z endp
.text$mn:00006892
.text$mn:00006892 ; ---------------------------------------------------------------------------
.text$mn:00006895                 align 4
.text$mn:00006895 _text$mn        ends
.text$mn:00006895
.text$mn:00006898 ; ===========================================================================
.text$mn:00006898
.text$mn:00006898 ; Segment type: Pure code
.text$mn:00006898 ; Segment permissions: Read/Execute
.text$mn:00006898 _text$mn        segment para public 'CODE' use32
.text$mn:00006898                 assume cs:_text$mn
.text$mn:00006898                 ;org 6898h
.text$mn:00006898 ; COMDAT (pick any)
.text$mn:00006898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006898
.text$mn:00006898 ; =============== S U B R O U T I N E =======================================
.text$mn:00006898
.text$mn:00006898 ; Attributes: bp-based frame
.text$mn:00006898
.text$mn:00006898 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00006898                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00006898 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00006898                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00006898
.text$mn:00006898 var_4           = dword ptr -4
.text$mn:00006898 arg_0           = dword ptr  8
.text$mn:00006898
.text$mn:00006898                 push    ebp
.text$mn:00006899                 mov     ebp, esp
.text$mn:0000689B                 push    ecx
.text$mn:0000689C                 mov     [ebp+var_4], ecx
.text$mn:0000689F                 mov     eax, [ebp+arg_0]
.text$mn:000068A2                 push    eax             ; void *
.text$mn:000068A3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000068A8                 add     esp, 4
.text$mn:000068AB                 mov     esp, ebp
.text$mn:000068AD                 pop     ebp
.text$mn:000068AE                 retn    8
.text$mn:000068AE ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:000068AE
.text$mn:000068AE ; ---------------------------------------------------------------------------
.text$mn:000068B1                 align 4
.text$mn:000068B1 _text$mn        ends
.text$mn:000068B1
.text$mn:000068B4 ; ===========================================================================
.text$mn:000068B4
.text$mn:000068B4 ; Segment type: Pure code
.text$mn:000068B4 ; Segment permissions: Read/Execute
.text$mn:000068B4 _text$mn        segment para public 'CODE' use32
.text$mn:000068B4                 assume cs:_text$mn
.text$mn:000068B4                 ;org 68B4h
.text$mn:000068B4 ; COMDAT (pick any)
.text$mn:000068B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000068B4
.text$mn:000068B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000068B4
.text$mn:000068B4 ; Attributes: bp-based frame
.text$mn:000068B4
.text$mn:000068B4 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:000068B4                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000068B4 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000068B4                                         ; DATA XREF: .rdata:0000903Co
.text$mn:000068B4
.text$mn:000068B4 var_4           = dword ptr -4
.text$mn:000068B4 arg_0           = dword ptr  8
.text$mn:000068B4 arg_4           = dword ptr  0Ch
.text$mn:000068B4
.text$mn:000068B4                 push    ebp
.text$mn:000068B5                 mov     ebp, esp
.text$mn:000068B7                 push    ecx
.text$mn:000068B8                 mov     [ebp+var_4], ecx
.text$mn:000068BB                 mov     eax, [ebp+arg_4]
.text$mn:000068BE                 push    eax             ; int
.text$mn:000068BF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000068C4                 add     esp, 4
.text$mn:000068C7                 test    eax, eax
.text$mn:000068C9                 jz      short loc_68E4
.text$mn:000068CB                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:000068D0                 push    eax             ; struct std::error_category *
.text$mn:000068D1                 mov     ecx, [ebp+arg_4]
.text$mn:000068D4                 push    ecx             ; int
.text$mn:000068D5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000068D8                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000068DD                 mov     eax, [ebp+arg_0]
.text$mn:000068E0                 jmp     short loc_68F9
.text$mn:000068E2 ; ---------------------------------------------------------------------------
.text$mn:000068E2                 jmp     short loc_68F9
.text$mn:000068E4 ; ---------------------------------------------------------------------------
.text$mn:000068E4
.text$mn:000068E4 loc_68E4:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:000068E4                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:000068E9                 push    eax             ; struct std::error_category *
.text$mn:000068EA                 mov     edx, [ebp+arg_4]
.text$mn:000068ED                 push    edx             ; int
.text$mn:000068EE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000068F1                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000068F6                 mov     eax, [ebp+arg_0]
.text$mn:000068F9
.text$mn:000068F9 loc_68F9:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000068F9                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000068F9                 mov     esp, ebp
.text$mn:000068FB                 pop     ebp
.text$mn:000068FC                 retn    8
.text$mn:000068FC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000068FC
.text$mn:000068FC ; ---------------------------------------------------------------------------
.text$mn:000068FF                 align 10h
.text$mn:000068FF _text$mn        ends
.text$mn:000068FF
.text$mn:00006900 ; ===========================================================================
.text$mn:00006900
.text$mn:00006900 ; Segment type: Pure code
.text$mn:00006900 ; Segment permissions: Read/Execute
.text$mn:00006900 _text$mn        segment para public 'CODE' use32
.text$mn:00006900                 assume cs:_text$mn
.text$mn:00006900                 ;org 6900h
.text$mn:00006900 ; COMDAT (pick any)
.text$mn:00006900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006900
.text$mn:00006900 ; =============== S U B R O U T I N E =======================================
.text$mn:00006900
.text$mn:00006900 ; Attributes: bp-based frame
.text$mn:00006900
.text$mn:00006900 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00006900                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00006900 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00006900                                         ; DATA XREF: .rdata:00008FACo
.text$mn:00006900                                         ; .rdata:00008FC8o ...
.text$mn:00006900
.text$mn:00006900 var_4           = dword ptr -4
.text$mn:00006900 arg_0           = dword ptr  8
.text$mn:00006900 arg_4           = dword ptr  0Ch
.text$mn:00006900
.text$mn:00006900                 push    ebp
.text$mn:00006901                 mov     ebp, esp
.text$mn:00006903                 push    ecx
.text$mn:00006904                 mov     [ebp+var_4], ecx
.text$mn:00006907                 mov     eax, [ebp+var_4]
.text$mn:0000690A                 push    eax             ; struct std::error_category *
.text$mn:0000690B                 mov     ecx, [ebp+arg_4]
.text$mn:0000690E                 push    ecx             ; int
.text$mn:0000690F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006912                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00006917                 mov     eax, [ebp+arg_0]
.text$mn:0000691A                 mov     esp, ebp
.text$mn:0000691C                 pop     ebp
.text$mn:0000691D                 retn    8
.text$mn:0000691D ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:0000691D
.text$mn:0000691D _text$mn        ends
.text$mn:0000691D
.text$mn:00006920 ; ===========================================================================
.text$mn:00006920
.text$mn:00006920 ; Segment type: Pure code
.text$mn:00006920 ; Segment permissions: Read/Execute
.text$mn:00006920 _text$mn        segment para public 'CODE' use32
.text$mn:00006920                 assume cs:_text$mn
.text$mn:00006920                 ;org 6920h
.text$mn:00006920 ; COMDAT (pick any)
.text$mn:00006920                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006920
.text$mn:00006920 ; =============== S U B R O U T I N E =======================================
.text$mn:00006920
.text$mn:00006920 ; Attributes: bp-based frame
.text$mn:00006920
.text$mn:00006920 ; void __thiscall StaticDialog::destroy(StaticDialog *__hidden this)
.text$mn:00006920                 public ?destroy@StaticDialog@@UAEXXZ
.text$mn:00006920 ?destroy@StaticDialog@@UAEXXZ proc near ; CODE XREF: StaticDialog::~StaticDialog(void)+59p
.text$mn:00006920                                         ; DATA XREF: .rdata:00008EA0o ...
.text$mn:00006920
.text$mn:00006920 var_4           = dword ptr -4
.text$mn:00006920
.text$mn:00006920                 push    ebp
.text$mn:00006921                 mov     ebp, esp
.text$mn:00006923                 push    ecx
.text$mn:00006924                 mov     [ebp+var_4], ecx
.text$mn:00006927                 mov     eax, [ebp+var_4]
.text$mn:0000692A                 mov     ecx, [eax+0Ch]
.text$mn:0000692D                 push    ecx             ; lParam
.text$mn:0000692E                 push    1               ; wParam
.text$mn:00006930                 push    7F4h            ; Msg
.text$mn:00006935                 mov     edx, [ebp+var_4]
.text$mn:00006938                 mov     eax, [edx+8]
.text$mn:0000693B                 push    eax             ; hWnd
.text$mn:0000693C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00006942                 mov     ecx, [ebp+var_4]
.text$mn:00006945                 mov     edx, [ecx+0Ch]
.text$mn:00006948                 push    edx             ; hWnd
.text$mn:00006949                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:0000694F                 mov     esp, ebp
.text$mn:00006951                 pop     ebp
.text$mn:00006952                 retn
.text$mn:00006952 ?destroy@StaticDialog@@UAEXXZ endp
.text$mn:00006952
.text$mn:00006952 ; ---------------------------------------------------------------------------
.text$mn:00006953                 align 4
.text$mn:00006953 _text$mn        ends
.text$mn:00006953
.text$mn:00006954 ; ===========================================================================
.text$mn:00006954
.text$mn:00006954 ; Segment type: Pure code
.text$mn:00006954 ; Segment permissions: Read/Execute
.text$mn:00006954 _text$mn        segment para public 'CODE' use32
.text$mn:00006954                 assume cs:_text$mn
.text$mn:00006954                 ;org 6954h
.text$mn:00006954 ; COMDAT (pick any)
.text$mn:00006954                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006954
.text$mn:00006954 ; =============== S U B R O U T I N E =======================================
.text$mn:00006954
.text$mn:00006954 ; Attributes: bp-based frame
.text$mn:00006954
.text$mn:00006954 ; void __thiscall Window::display(Window *this, bool)
.text$mn:00006954                 public ?display@Window@@UBEX_N@Z
.text$mn:00006954 ?display@Window@@UBEX_N@Z proc near     ; DATA XREF: .rdata:00008E70o
.text$mn:00006954
.text$mn:00006954 var_8           = dword ptr -8
.text$mn:00006954 nCmdShow        = dword ptr -4
.text$mn:00006954 arg_0           = byte ptr  8
.text$mn:00006954
.text$mn:00006954                 push    ebp
.text$mn:00006955                 mov     ebp, esp
.text$mn:00006957                 sub     esp, 8
.text$mn:0000695A                 mov     [ebp+var_8], ecx
.text$mn:0000695D                 movzx   eax, [ebp+arg_0]
.text$mn:00006961                 test    eax, eax
.text$mn:00006963                 jz      short loc_696E
.text$mn:00006965                 mov     [ebp+nCmdShow], 5
.text$mn:0000696C                 jmp     short loc_6975
.text$mn:0000696E ; ---------------------------------------------------------------------------
.text$mn:0000696E
.text$mn:0000696E loc_696E:                               ; CODE XREF: Window::display(bool)+Fj
.text$mn:0000696E                 mov     [ebp+nCmdShow], 0
.text$mn:00006975
.text$mn:00006975 loc_6975:                               ; CODE XREF: Window::display(bool)+18j
.text$mn:00006975                 mov     ecx, [ebp+nCmdShow]
.text$mn:00006978                 push    ecx             ; nCmdShow
.text$mn:00006979                 mov     edx, [ebp+var_8]
.text$mn:0000697C                 mov     eax, [edx+0Ch]
.text$mn:0000697F                 push    eax             ; hWnd
.text$mn:00006980                 call    dword ptr ds:__imp__ShowWindow@8 ; ShowWindow(x,x)
.text$mn:00006986                 mov     esp, ebp
.text$mn:00006988                 pop     ebp
.text$mn:00006989                 retn    4
.text$mn:00006989 ?display@Window@@UBEX_N@Z endp
.text$mn:00006989
.text$mn:00006989 _text$mn        ends
.text$mn:00006989
.text$mn:0000698C ; ===========================================================================
.text$mn:0000698C
.text$mn:0000698C ; Segment type: Pure code
.text$mn:0000698C ; Segment permissions: Read/Execute
.text$mn:0000698C _text$mn        segment para public 'CODE' use32
.text$mn:0000698C                 assume cs:_text$mn
.text$mn:0000698C                 ;org 698Ch
.text$mn:0000698C ; COMDAT (pick any)
.text$mn:0000698C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000698C
.text$mn:0000698C ; =============== S U B R O U T I N E =======================================
.text$mn:0000698C
.text$mn:0000698C ; Attributes: bp-based frame
.text$mn:0000698C
.text$mn:0000698C ; int __thiscall Shortcut::doDialog(Shortcut *__hidden this)
.text$mn:0000698C                 public ?doDialog@Shortcut@@UAEHXZ
.text$mn:0000698C ?doDialog@Shortcut@@UAEHXZ proc near    ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+212p
.text$mn:0000698C                                         ; DATA XREF: .rdata:000090A8o ...
.text$mn:0000698C
.text$mn:0000698C dwInitParam     = dword ptr -4
.text$mn:0000698C
.text$mn:0000698C                 push    ebp
.text$mn:0000698D                 mov     ebp, esp
.text$mn:0000698F                 push    ecx
.text$mn:00006990                 mov     [ebp+dwInitParam], ecx
.text$mn:00006993                 mov     eax, [ebp+dwInitParam]
.text$mn:00006996                 push    eax             ; dwInitParam
.text$mn:00006997                 push    offset ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z ; lpDialogFunc
.text$mn:0000699C                 mov     ecx, [ebp+dwInitParam]
.text$mn:0000699F                 mov     edx, [ecx+8]
.text$mn:000069A2                 push    edx             ; hWndParent
.text$mn:000069A3                 push    offset TemplateName ; lpTemplateName
.text$mn:000069A8                 mov     eax, [ebp+dwInitParam]
.text$mn:000069AB                 mov     ecx, [eax+4]
.text$mn:000069AE                 push    ecx             ; hInstance
.text$mn:000069AF                 call    dword ptr ds:__imp__DialogBoxParamW@20 ; DialogBoxParamW(x,x,x,x,x)
.text$mn:000069B5                 mov     esp, ebp
.text$mn:000069B7                 pop     ebp
.text$mn:000069B8                 retn
.text$mn:000069B8 ?doDialog@Shortcut@@UAEHXZ endp
.text$mn:000069B8
.text$mn:000069B8 ; ---------------------------------------------------------------------------
.text$mn:000069B9                 align 4
.text$mn:000069B9 _text$mn        ends
.text$mn:000069B9
.text$mn:000069BC ; ===========================================================================
.text$mn:000069BC
.text$mn:000069BC ; Segment type: Pure code
.text$mn:000069BC ; Segment permissions: Read/Execute
.text$mn:000069BC _text$mn        segment para public 'CODE' use32
.text$mn:000069BC                 assume cs:_text$mn
.text$mn:000069BC                 ;org 69BCh
.text$mn:000069BC ; COMDAT (pick any)
.text$mn:000069BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000069BC
.text$mn:000069BC ; =============== S U B R O U T I N E =======================================
.text$mn:000069BC
.text$mn:000069BC ; Attributes: bp-based frame
.text$mn:000069BC
.text$mn:000069BC ; public: class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>> __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::end(void)
.text$mn:000069BC                 public ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:000069BC ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$mn:000069BC                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+72p
.text$mn:000069BC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+8Ep
.text$mn:000069BC
.text$mn:000069BC var_14          = dword ptr -14h
.text$mn:000069BC var_10          = dword ptr -10h
.text$mn:000069BC var_C           = dword ptr -0Ch
.text$mn:000069BC var_4           = dword ptr -4
.text$mn:000069BC arg_0           = dword ptr  8
.text$mn:000069BC
.text$mn:000069BC                 push    ebp
.text$mn:000069BD                 mov     ebp, esp
.text$mn:000069BF                 push    0FFFFFFFFh
.text$mn:000069C1                 push    offset __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$mn:000069C6                 mov     eax, large fs:0
.text$mn:000069CC                 push    eax
.text$mn:000069CD                 sub     esp, 8
.text$mn:000069D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000069D5                 xor     eax, ebp
.text$mn:000069D7                 push    eax
.text$mn:000069D8                 lea     eax, [ebp+var_C]
.text$mn:000069DB                 mov     large fs:0, eax
.text$mn:000069E1                 mov     [ebp+var_10], ecx
.text$mn:000069E4                 mov     [ebp+var_14], 0
.text$mn:000069EB                 mov     eax, [ebp+var_10]
.text$mn:000069EE                 push    eax             ; struct std::_Container_base12 *
.text$mn:000069EF                 mov     ecx, [ebp+var_10]
.text$mn:000069F2                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000069F7                 mov     ecx, [ebp+var_10]
.text$mn:000069FA                 mov     edx, [ecx+14h]
.text$mn:000069FD                 lea     eax, [eax+edx*2]
.text$mn:00006A00                 push    eax             ; int
.text$mn:00006A01                 mov     ecx, [ebp+arg_0]
.text$mn:00006A04                 call    ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(wchar_t *,std::_Container_base12 const *)
.text$mn:00006A09                 mov     [ebp+var_4], 0
.text$mn:00006A10                 mov     ecx, [ebp+var_14]
.text$mn:00006A13                 or      ecx, 1
.text$mn:00006A16                 mov     [ebp+var_14], ecx
.text$mn:00006A19                 mov     eax, [ebp+arg_0]
.text$mn:00006A1C                 mov     ecx, [ebp+var_C]
.text$mn:00006A1F                 mov     large fs:0, ecx
.text$mn:00006A26                 pop     ecx
.text$mn:00006A27                 mov     esp, ebp
.text$mn:00006A29                 pop     ebp
.text$mn:00006A2A                 retn    4
.text$mn:00006A2A ?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$mn:00006A2A
.text$mn:00006A2A ; ---------------------------------------------------------------------------
.text$mn:00006A2D                 align 10h
.text$mn:00006A2D _text$mn        ends
.text$mn:00006A2D
.text$x:00006A30 ; ===========================================================================
.text$x:00006A30
.text$x:00006A30 ; Segment type: Pure code
.text$x:00006A30 ; Segment permissions: Read/Execute
.text$x:00006A30 _text$x         segment para public 'CODE' use32
.text$x:00006A30                 assume cs:_text$x
.text$x:00006A30                 ;org 6A30h
.text$x:00006A30 ; COMDAT (pick associative to section at 69BC)
.text$x:00006A30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006A30
.text$x:00006A30 ; =============== S U B R O U T I N E =======================================
.text$x:00006A30
.text$x:00006A30
.text$x:00006A30 __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 proc near
.text$x:00006A30                                         ; DATA XREF: .xdata$x:000086ACo
.text$x:00006A30                 mov     eax, [ebp-14h]
.text$x:00006A33                 and     eax, 1
.text$x:00006A36                 jz      $LN4_0
.text$x:00006A3C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00006A40                 mov     ecx, [ebp+8]
.text$x:00006A43                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00006A48 ; ---------------------------------------------------------------------------
.text$x:00006A48
.text$x:00006A48 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0+6j
.text$x:00006A48                 retn
.text$x:00006A48 __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0 endp
.text$x:00006A48
.text$x:00006A49
.text$x:00006A49 ; =============== S U B R O U T I N E =======================================
.text$x:00006A49
.text$x:00006A49
.text$x:00006A49 __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ proc near
.text$x:00006A49                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::end(void)+5o
.text$x:00006A49
.text$x:00006A49 arg_4           = dword ptr  8
.text$x:00006A49
.text$x:00006A49                 mov     edx, [esp+arg_4]
.text$x:00006A4D                 lea     eax, [edx+0Ch]
.text$x:00006A50                 mov     ecx, [edx-0Ch]
.text$x:00006A53                 xor     ecx, eax
.text$x:00006A55                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006A5A                 mov     eax, offset __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.text$x:00006A5F                 jmp     ___CxxFrameHandler3
.text$x:00006A5F __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ endp
.text$x:00006A5F
.text$x:00006A5F _text$x         ends
.text$x:00006A5F
.text$mn:00006A64 ; ===========================================================================
.text$mn:00006A64
.text$mn:00006A64 ; Segment type: Pure code
.text$mn:00006A64 ; Segment permissions: Read/Execute
.text$mn:00006A64 _text$mn        segment para public 'CODE' use32
.text$mn:00006A64                 assume cs:_text$mn
.text$mn:00006A64                 ;org 6A64h
.text$mn:00006A64 ; COMDAT (pick any)
.text$mn:00006A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A64
.text$mn:00006A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A64
.text$mn:00006A64 ; Attributes: bp-based frame
.text$mn:00006A64
.text$mn:00006A64 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00006A64                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00006A64 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00006A64                                         ; DATA XREF: .rdata:00008FB0o
.text$mn:00006A64                                         ; .rdata:00008FCCo ...
.text$mn:00006A64
.text$mn:00006A64 var_8           = dword ptr -8
.text$mn:00006A64 var_4           = dword ptr -4
.text$mn:00006A64 arg_0           = dword ptr  8
.text$mn:00006A64 arg_4           = dword ptr  0Ch
.text$mn:00006A64
.text$mn:00006A64                 push    ebp
.text$mn:00006A65                 mov     ebp, esp
.text$mn:00006A67                 sub     esp, 8
.text$mn:00006A6A                 mov     [ebp+var_8], ecx
.text$mn:00006A6D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006A70                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00006A75                 push    eax
.text$mn:00006A76                 mov     ecx, [ebp+var_8]
.text$mn:00006A79                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00006A7E                 movzx   eax, al
.text$mn:00006A81                 test    eax, eax
.text$mn:00006A83                 jz      short loc_6A9B
.text$mn:00006A85                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00006A88                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00006A8D                 cmp     eax, [ebp+arg_4]
.text$mn:00006A90                 jnz     short loc_6A9B
.text$mn:00006A92                 mov     [ebp+var_4], 1
.text$mn:00006A99                 jmp     short loc_6AA2
.text$mn:00006A9B ; ---------------------------------------------------------------------------
.text$mn:00006A9B
.text$mn:00006A9B loc_6A9B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00006A9B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00006A9B                 mov     [ebp+var_4], 0
.text$mn:00006AA2
.text$mn:00006AA2 loc_6AA2:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00006AA2                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006AA5                 mov     esp, ebp
.text$mn:00006AA7                 pop     ebp
.text$mn:00006AA8                 retn    8
.text$mn:00006AA8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00006AA8
.text$mn:00006AA8 ; ---------------------------------------------------------------------------
.text$mn:00006AAB                 align 4
.text$mn:00006AAB _text$mn        ends
.text$mn:00006AAB
.text$mn:00006AAC ; ===========================================================================
.text$mn:00006AAC
.text$mn:00006AAC ; Segment type: Pure code
.text$mn:00006AAC ; Segment permissions: Read/Execute
.text$mn:00006AAC _text$mn        segment para public 'CODE' use32
.text$mn:00006AAC                 assume cs:_text$mn
.text$mn:00006AAC                 ;org 6AACh
.text$mn:00006AAC ; COMDAT (pick any)
.text$mn:00006AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AAC
.text$mn:00006AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00006AAC
.text$mn:00006AAC ; Attributes: bp-based frame
.text$mn:00006AAC
.text$mn:00006AAC ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00006AAC                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00006AAC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00006AAC                                         ; DATA XREF: .rdata:00008FB4o
.text$mn:00006AAC                                         ; .rdata:00008FD0o ...
.text$mn:00006AAC
.text$mn:00006AAC var_C           = byte ptr -0Ch
.text$mn:00006AAC var_4           = dword ptr -4
.text$mn:00006AAC arg_0           = dword ptr  8
.text$mn:00006AAC arg_4           = dword ptr  0Ch
.text$mn:00006AAC
.text$mn:00006AAC                 push    ebp
.text$mn:00006AAD                 mov     ebp, esp
.text$mn:00006AAF                 sub     esp, 0Ch
.text$mn:00006AB2                 mov     [ebp+var_4], ecx
.text$mn:00006AB5                 mov     eax, [ebp+arg_4]
.text$mn:00006AB8                 push    eax             ; std::error_condition *
.text$mn:00006AB9                 mov     ecx, [ebp+arg_0]
.text$mn:00006ABC                 push    ecx
.text$mn:00006ABD                 lea     edx, [ebp+var_C]
.text$mn:00006AC0                 push    edx
.text$mn:00006AC1                 mov     eax, [ebp+var_4]
.text$mn:00006AC4                 mov     edx, [eax]
.text$mn:00006AC6                 mov     ecx, [ebp+var_4]
.text$mn:00006AC9                 mov     eax, [edx+0Ch]
.text$mn:00006ACC                 call    eax
.text$mn:00006ACE                 mov     ecx, eax
.text$mn:00006AD0                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00006AD5                 mov     esp, ebp
.text$mn:00006AD7                 pop     ebp
.text$mn:00006AD8                 retn    8
.text$mn:00006AD8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00006AD8
.text$mn:00006AD8 ; ---------------------------------------------------------------------------
.text$mn:00006ADB                 align 4
.text$mn:00006ADB _text$mn        ends
.text$mn:00006ADB
.text$mn:00006ADC ; ===========================================================================
.text$mn:00006ADC
.text$mn:00006ADC ; Segment type: Pure code
.text$mn:00006ADC ; Segment permissions: Read/Execute
.text$mn:00006ADC _text$mn        segment para public 'CODE' use32
.text$mn:00006ADC                 assume cs:_text$mn
.text$mn:00006ADC                 ;org 6ADCh
.text$mn:00006ADC ; COMDAT (pick any)
.text$mn:00006ADC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006ADC
.text$mn:00006ADC ; =============== S U B R O U T I N E =======================================
.text$mn:00006ADC
.text$mn:00006ADC ; Attributes: bp-based frame
.text$mn:00006ADC
.text$mn:00006ADC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00006ADC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00006ADC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00006ADC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00006ADC
.text$mn:00006ADC var_4           = dword ptr -4
.text$mn:00006ADC arg_0           = dword ptr  8
.text$mn:00006ADC
.text$mn:00006ADC                 push    ebp
.text$mn:00006ADD                 mov     ebp, esp
.text$mn:00006ADF                 push    ecx
.text$mn:00006AE0                 mov     [ebp+var_4], ecx
.text$mn:00006AE3                 mov     eax, [ebp+var_4]
.text$mn:00006AE6                 mov     ecx, [eax+14h]
.text$mn:00006AE9                 cmp     ecx, [ebp+arg_0]
.text$mn:00006AEC                 jnb     short loc_6AF6
.text$mn:00006AEE                 mov     ecx, [ebp+var_4]
.text$mn:00006AF1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00006AF6
.text$mn:00006AF6 loc_6AF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00006AF6                 mov     edx, [ebp+arg_0]
.text$mn:00006AF9                 push    edx
.text$mn:00006AFA                 mov     ecx, [ebp+var_4]
.text$mn:00006AFD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006B02                 mov     eax, [ebp+var_4]
.text$mn:00006B05                 mov     esp, ebp
.text$mn:00006B07                 pop     ebp
.text$mn:00006B08                 retn    4
.text$mn:00006B08 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00006B08
.text$mn:00006B08 ; ---------------------------------------------------------------------------
.text$mn:00006B0B                 align 4
.text$mn:00006B0B _text$mn        ends
.text$mn:00006B0B
.text$mn:00006B0C ; ===========================================================================
.text$mn:00006B0C
.text$mn:00006B0C ; Segment type: Pure code
.text$mn:00006B0C ; Segment permissions: Read/Execute
.text$mn:00006B0C _text$mn        segment para public 'CODE' use32
.text$mn:00006B0C                 assume cs:_text$mn
.text$mn:00006B0C                 ;org 6B0Ch
.text$mn:00006B0C ; COMDAT (pick any)
.text$mn:00006B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B0C
.text$mn:00006B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B0C
.text$mn:00006B0C ; Attributes: bp-based frame
.text$mn:00006B0C
.text$mn:00006B0C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00006B0C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00006B0C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00006B0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00006B0C
.text$mn:00006B0C var_C           = dword ptr -0Ch
.text$mn:00006B0C Dst             = dword ptr -8
.text$mn:00006B0C var_4           = dword ptr -4
.text$mn:00006B0C arg_0           = dword ptr  8
.text$mn:00006B0C arg_4           = dword ptr  0Ch
.text$mn:00006B0C
.text$mn:00006B0C                 push    ebp
.text$mn:00006B0D                 mov     ebp, esp
.text$mn:00006B0F                 sub     esp, 0Ch
.text$mn:00006B12                 mov     [ebp+var_4], ecx
.text$mn:00006B15                 mov     eax, [ebp+var_4]
.text$mn:00006B18                 mov     ecx, [eax+14h]
.text$mn:00006B1B                 cmp     ecx, [ebp+arg_0]
.text$mn:00006B1E                 jnb     short loc_6B28
.text$mn:00006B20                 mov     ecx, [ebp+var_4]
.text$mn:00006B23                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00006B28
.text$mn:00006B28 loc_6B28:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00006B28                 mov     edx, [ebp+var_4]
.text$mn:00006B2B                 mov     eax, [edx+14h]
.text$mn:00006B2E                 sub     eax, [ebp+arg_0]
.text$mn:00006B31                 cmp     eax, [ebp+arg_4]
.text$mn:00006B34                 ja      short loc_6B44
.text$mn:00006B36                 mov     ecx, [ebp+arg_0]
.text$mn:00006B39                 push    ecx
.text$mn:00006B3A                 mov     ecx, [ebp+var_4]
.text$mn:00006B3D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006B42                 jmp     short loc_6B8A
.text$mn:00006B44 ; ---------------------------------------------------------------------------
.text$mn:00006B44
.text$mn:00006B44 loc_6B44:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00006B44                 cmp     [ebp+arg_4], 0
.text$mn:00006B48                 jbe     short loc_6B8A
.text$mn:00006B4A                 mov     ecx, [ebp+var_4]
.text$mn:00006B4D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006B52                 add     eax, [ebp+arg_0]
.text$mn:00006B55                 mov     [ebp+Dst], eax
.text$mn:00006B58                 mov     edx, [ebp+var_4]
.text$mn:00006B5B                 mov     eax, [edx+14h]
.text$mn:00006B5E                 sub     eax, [ebp+arg_4]
.text$mn:00006B61                 mov     [ebp+var_C], eax
.text$mn:00006B64                 mov     ecx, [ebp+var_C]
.text$mn:00006B67                 sub     ecx, [ebp+arg_0]
.text$mn:00006B6A                 push    ecx             ; Size
.text$mn:00006B6B                 mov     edx, [ebp+Dst]
.text$mn:00006B6E                 add     edx, [ebp+arg_4]
.text$mn:00006B71                 push    edx             ; Src
.text$mn:00006B72                 mov     eax, [ebp+Dst]
.text$mn:00006B75                 push    eax             ; Dst
.text$mn:00006B76                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00006B7B                 add     esp, 0Ch
.text$mn:00006B7E                 mov     ecx, [ebp+var_C]
.text$mn:00006B81                 push    ecx
.text$mn:00006B82                 mov     ecx, [ebp+var_4]
.text$mn:00006B85                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006B8A
.text$mn:00006B8A loc_6B8A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00006B8A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00006B8A                 mov     eax, [ebp+var_4]
.text$mn:00006B8D                 mov     esp, ebp
.text$mn:00006B8F                 pop     ebp
.text$mn:00006B90                 retn    8
.text$mn:00006B90 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00006B90
.text$mn:00006B90 ; ---------------------------------------------------------------------------
.text$mn:00006B93                 align 4
.text$mn:00006B93 _text$mn        ends
.text$mn:00006B93
.text$mn:00006B94 ; ===========================================================================
.text$mn:00006B94
.text$mn:00006B94 ; Segment type: Pure code
.text$mn:00006B94 ; Segment permissions: Read/Execute
.text$mn:00006B94 _text$mn        segment para public 'CODE' use32
.text$mn:00006B94                 assume cs:_text$mn
.text$mn:00006B94                 ;org 6B94h
.text$mn:00006B94 ; COMDAT (pick any)
.text$mn:00006B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B94
.text$mn:00006B94 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B94
.text$mn:00006B94 ; Attributes: bp-based frame
.text$mn:00006B94
.text$mn:00006B94 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00006B94                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00006B94 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00006B94                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00006B94
.text$mn:00006B94 var_4           = dword ptr -4
.text$mn:00006B94 arg_0           = dword ptr  8
.text$mn:00006B94
.text$mn:00006B94                 push    ebp
.text$mn:00006B95                 mov     ebp, esp
.text$mn:00006B97                 push    ecx
.text$mn:00006B98                 mov     [ebp+var_4], ecx
.text$mn:00006B9B                 mov     eax, [ebp+var_4]
.text$mn:00006B9E                 mov     ecx, [eax+14h]
.text$mn:00006BA1                 cmp     ecx, [ebp+arg_0]
.text$mn:00006BA4                 jnb     short loc_6BAE
.text$mn:00006BA6                 mov     ecx, [ebp+var_4]
.text$mn:00006BA9                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00006BAE
.text$mn:00006BAE loc_6BAE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:00006BAE                 mov     edx, [ebp+arg_0]
.text$mn:00006BB1                 push    edx
.text$mn:00006BB2                 mov     ecx, [ebp+var_4]
.text$mn:00006BB5                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006BBA                 mov     eax, [ebp+var_4]
.text$mn:00006BBD                 mov     esp, ebp
.text$mn:00006BBF                 pop     ebp
.text$mn:00006BC0                 retn    4
.text$mn:00006BC0 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:00006BC0
.text$mn:00006BC0 ; ---------------------------------------------------------------------------
.text$mn:00006BC3                 align 4
.text$mn:00006BC3 _text$mn        ends
.text$mn:00006BC3
.text$mn:00006BC4 ; ===========================================================================
.text$mn:00006BC4
.text$mn:00006BC4 ; Segment type: Pure code
.text$mn:00006BC4 ; Segment permissions: Read/Execute
.text$mn:00006BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00006BC4                 assume cs:_text$mn
.text$mn:00006BC4                 ;org 6BC4h
.text$mn:00006BC4 ; COMDAT (pick any)
.text$mn:00006BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BC4
.text$mn:00006BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BC4
.text$mn:00006BC4 ; Attributes: bp-based frame
.text$mn:00006BC4
.text$mn:00006BC4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00006BC4                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00006BC4 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00006BC4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00006BC4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+10Cp
.text$mn:00006BC4
.text$mn:00006BC4 var_C           = dword ptr -0Ch
.text$mn:00006BC4 Dst             = dword ptr -8
.text$mn:00006BC4 var_4           = dword ptr -4
.text$mn:00006BC4 arg_0           = dword ptr  8
.text$mn:00006BC4 arg_4           = dword ptr  0Ch
.text$mn:00006BC4
.text$mn:00006BC4                 push    ebp
.text$mn:00006BC5                 mov     ebp, esp
.text$mn:00006BC7                 sub     esp, 0Ch
.text$mn:00006BCA                 mov     [ebp+var_4], ecx
.text$mn:00006BCD                 mov     eax, [ebp+var_4]
.text$mn:00006BD0                 mov     ecx, [eax+14h]
.text$mn:00006BD3                 cmp     ecx, [ebp+arg_0]
.text$mn:00006BD6                 jnb     short loc_6BE0
.text$mn:00006BD8                 mov     ecx, [ebp+var_4]
.text$mn:00006BDB                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00006BE0
.text$mn:00006BE0 loc_6BE0:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:00006BE0                 mov     edx, [ebp+var_4]
.text$mn:00006BE3                 mov     eax, [edx+14h]
.text$mn:00006BE6                 sub     eax, [ebp+arg_0]
.text$mn:00006BE9                 cmp     eax, [ebp+arg_4]
.text$mn:00006BEC                 ja      short loc_6BFC
.text$mn:00006BEE                 mov     ecx, [ebp+arg_0]
.text$mn:00006BF1                 push    ecx
.text$mn:00006BF2                 mov     ecx, [ebp+var_4]
.text$mn:00006BF5                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006BFA                 jmp     short loc_6C48
.text$mn:00006BFC ; ---------------------------------------------------------------------------
.text$mn:00006BFC
.text$mn:00006BFC loc_6BFC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00006BFC                 cmp     [ebp+arg_4], 0
.text$mn:00006C00                 jbe     short loc_6C48
.text$mn:00006C02                 mov     ecx, [ebp+var_4]
.text$mn:00006C05                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00006C0A                 mov     edx, [ebp+arg_0]
.text$mn:00006C0D                 lea     eax, [eax+edx*2]
.text$mn:00006C10                 mov     [ebp+Dst], eax
.text$mn:00006C13                 mov     ecx, [ebp+var_4]
.text$mn:00006C16                 mov     edx, [ecx+14h]
.text$mn:00006C19                 sub     edx, [ebp+arg_4]
.text$mn:00006C1C                 mov     [ebp+var_C], edx
.text$mn:00006C1F                 mov     eax, [ebp+var_C]
.text$mn:00006C22                 sub     eax, [ebp+arg_0]
.text$mn:00006C25                 push    eax             ; int
.text$mn:00006C26                 mov     ecx, [ebp+arg_4]
.text$mn:00006C29                 mov     edx, [ebp+Dst]
.text$mn:00006C2C                 lea     eax, [edx+ecx*2]
.text$mn:00006C2F                 push    eax             ; Src
.text$mn:00006C30                 mov     ecx, [ebp+Dst]
.text$mn:00006C33                 push    ecx             ; Dst
.text$mn:00006C34                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00006C39                 add     esp, 0Ch
.text$mn:00006C3C                 mov     edx, [ebp+var_C]
.text$mn:00006C3F                 push    edx
.text$mn:00006C40                 mov     ecx, [ebp+var_4]
.text$mn:00006C43                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00006C48
.text$mn:00006C48 loc_6C48:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:00006C48                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:00006C48                 mov     eax, [ebp+var_4]
.text$mn:00006C4B                 mov     esp, ebp
.text$mn:00006C4D                 pop     ebp
.text$mn:00006C4E                 retn    8
.text$mn:00006C4E ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:00006C4E
.text$mn:00006C4E ; ---------------------------------------------------------------------------
.text$mn:00006C51                 align 4
.text$mn:00006C51 _text$mn        ends
.text$mn:00006C51
.text$mn:00006C54 ; ===========================================================================
.text$mn:00006C54
.text$mn:00006C54 ; Segment type: Pure code
.text$mn:00006C54 ; Segment permissions: Read/Execute
.text$mn:00006C54 _text$mn        segment para public 'CODE' use32
.text$mn:00006C54                 assume cs:_text$mn
.text$mn:00006C54                 ;org 6C54h
.text$mn:00006C54 ; COMDAT (pick any)
.text$mn:00006C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C54
.text$mn:00006C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C54
.text$mn:00006C54 ; Attributes: bp-based frame
.text$mn:00006C54
.text$mn:00006C54 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00006C54                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00006C54 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00006C54                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00006C54                 push    ebp
.text$mn:00006C55                 mov     ebp, esp
.text$mn:00006C57                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00006C5C                 pop     ebp
.text$mn:00006C5D                 retn
.text$mn:00006C5D ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00006C5D
.text$mn:00006C5D ; ---------------------------------------------------------------------------
.text$mn:00006C5E                 align 10h
.text$mn:00006C5E _text$mn        ends
.text$mn:00006C5E
.text$mn:00006C60 ; ===========================================================================
.text$mn:00006C60
.text$mn:00006C60 ; Segment type: Pure code
.text$mn:00006C60 ; Segment permissions: Read/Execute
.text$mn:00006C60 _text$mn        segment para public 'CODE' use32
.text$mn:00006C60                 assume cs:_text$mn
.text$mn:00006C60                 ;org 6C60h
.text$mn:00006C60 ; COMDAT (pick any)
.text$mn:00006C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C60
.text$mn:00006C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C60
.text$mn:00006C60 ; Attributes: bp-based frame
.text$mn:00006C60
.text$mn:00006C60 ; struct Accelerator *__thiscall NppParameters::getAccelerator(NppParameters *__hidden this)
.text$mn:00006C60                 public ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ
.text$mn:00006C60 ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ proc near
.text$mn:00006C60                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+3ADp
.text$mn:00006C60
.text$mn:00006C60 var_4           = dword ptr -4
.text$mn:00006C60
.text$mn:00006C60                 push    ebp
.text$mn:00006C61                 mov     ebp, esp
.text$mn:00006C63                 push    ecx
.text$mn:00006C64                 mov     [ebp+var_4], ecx
.text$mn:00006C67                 mov     eax, [ebp+var_4]
.text$mn:00006C6A                 mov     eax, [eax+1CBA0h]
.text$mn:00006C70                 mov     esp, ebp
.text$mn:00006C72                 pop     ebp
.text$mn:00006C73                 retn
.text$mn:00006C73 ?getAccelerator@NppParameters@@QAEPAVAccelerator@@XZ endp
.text$mn:00006C73
.text$mn:00006C73 _text$mn        ends
.text$mn:00006C73
.text$mn:00006C74 ; ===========================================================================
.text$mn:00006C74
.text$mn:00006C74 ; Segment type: Pure code
.text$mn:00006C74 ; Segment permissions: Read/Execute
.text$mn:00006C74 _text$mn        segment para public 'CODE' use32
.text$mn:00006C74                 assume cs:_text$mn
.text$mn:00006C74                 ;org 6C74h
.text$mn:00006C74 ; COMDAT (pick any)
.text$mn:00006C74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C74
.text$mn:00006C74 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C74
.text$mn:00006C74 ; Attributes: bp-based frame
.text$mn:00006C74
.text$mn:00006C74 ; void __thiscall Window::getClientRect(Window *this, struct tagRECT *)
.text$mn:00006C74                 public ?getClientRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00006C74 ?getClientRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00006C74                                         ; DATA XREF: .rdata:00008E80o
.text$mn:00006C74                                         ; .rdata:00008EB4o ...
.text$mn:00006C74
.text$mn:00006C74 var_4           = dword ptr -4
.text$mn:00006C74 lpRect          = dword ptr  8
.text$mn:00006C74
.text$mn:00006C74                 push    ebp
.text$mn:00006C75                 mov     ebp, esp
.text$mn:00006C77                 push    ecx
.text$mn:00006C78                 mov     [ebp+var_4], ecx
.text$mn:00006C7B                 mov     eax, [ebp+lpRect]
.text$mn:00006C7E                 push    eax             ; lpRect
.text$mn:00006C7F                 mov     ecx, [ebp+var_4]
.text$mn:00006C82                 mov     edx, [ecx+0Ch]
.text$mn:00006C85                 push    edx             ; hWnd
.text$mn:00006C86                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00006C8C                 mov     esp, ebp
.text$mn:00006C8E                 pop     ebp
.text$mn:00006C8F                 retn    4
.text$mn:00006C8F ?getClientRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00006C8F
.text$mn:00006C8F ; ---------------------------------------------------------------------------
.text$mn:00006C92                 align 4
.text$mn:00006C92 _text$mn        ends
.text$mn:00006C92
.text$mn:00006C94 ; ===========================================================================
.text$mn:00006C94
.text$mn:00006C94 ; Segment type: Pure code
.text$mn:00006C94 ; Segment permissions: Read/Execute
.text$mn:00006C94 _text$mn        segment para public 'CODE' use32
.text$mn:00006C94                 assume cs:_text$mn
.text$mn:00006C94                 ;org 6C94h
.text$mn:00006C94 ; COMDAT (pick any)
.text$mn:00006C94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C94
.text$mn:00006C94 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C94
.text$mn:00006C94 ; Attributes: bp-based frame
.text$mn:00006C94
.text$mn:00006C94 ; int __thiscall Window::getHeight(Window *__hidden this)
.text$mn:00006C94                 public ?getHeight@Window@@UBEHXZ
.text$mn:00006C94 ?getHeight@Window@@UBEHXZ proc near     ; DATA XREF: .rdata:00008E8Co
.text$mn:00006C94                                         ; .rdata:00008EC0o ...
.text$mn:00006C94
.text$mn:00006C94 var_18          = dword ptr -18h
.text$mn:00006C94 Rect            = tagRECT ptr -14h
.text$mn:00006C94 var_4           = dword ptr -4
.text$mn:00006C94
.text$mn:00006C94                 push    ebp
.text$mn:00006C95                 mov     ebp, esp
.text$mn:00006C97                 sub     esp, 18h
.text$mn:00006C9A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006C9F                 xor     eax, ebp
.text$mn:00006CA1                 mov     [ebp+var_4], eax
.text$mn:00006CA4                 mov     [ebp+var_18], ecx
.text$mn:00006CA7                 lea     eax, [ebp+Rect]
.text$mn:00006CAA                 push    eax             ; lpRect
.text$mn:00006CAB                 mov     ecx, [ebp+var_18]
.text$mn:00006CAE                 mov     edx, [ecx+0Ch]
.text$mn:00006CB1                 push    edx             ; hWnd
.text$mn:00006CB2                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00006CB8                 mov     eax, [ebp+var_18]
.text$mn:00006CBB                 mov     ecx, [eax+0Ch]
.text$mn:00006CBE                 push    ecx             ; hWnd
.text$mn:00006CBF                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00006CC5                 cmp     eax, 1
.text$mn:00006CC8                 jnz     short loc_6CD2
.text$mn:00006CCA                 mov     eax, [ebp+Rect.bottom]
.text$mn:00006CCD                 sub     eax, [ebp+Rect.top]
.text$mn:00006CD0                 jmp     short loc_6CD4
.text$mn:00006CD2 ; ---------------------------------------------------------------------------
.text$mn:00006CD2
.text$mn:00006CD2 loc_6CD2:                               ; CODE XREF: Window::getHeight(void)+34j
.text$mn:00006CD2                 xor     eax, eax
.text$mn:00006CD4
.text$mn:00006CD4 loc_6CD4:                               ; CODE XREF: Window::getHeight(void)+3Cj
.text$mn:00006CD4                 mov     ecx, [ebp+var_4]
.text$mn:00006CD7                 xor     ecx, ebp
.text$mn:00006CD9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00006CDE                 mov     esp, ebp
.text$mn:00006CE0                 pop     ebp
.text$mn:00006CE1                 retn
.text$mn:00006CE1 ?getHeight@Window@@UBEHXZ endp
.text$mn:00006CE1
.text$mn:00006CE1 ; ---------------------------------------------------------------------------
.text$mn:00006CE2                 align 4
.text$mn:00006CE2 _text$mn        ends
.text$mn:00006CE2
.text$mn:00006CE4 ; ===========================================================================
.text$mn:00006CE4
.text$mn:00006CE4 ; Segment type: Pure code
.text$mn:00006CE4 ; Segment permissions: Read/Execute
.text$mn:00006CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00006CE4                 assume cs:_text$mn
.text$mn:00006CE4                 ;org 6CE4h
.text$mn:00006CE4 ; COMDAT (pick any)
.text$mn:00006CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CE4
.text$mn:00006CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CE4
.text$mn:00006CE4 ; Attributes: bp-based frame
.text$mn:00006CE4
.text$mn:00006CE4 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00006CE4                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00006CE4 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00006CE4                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long):loc_1953p
.text$mn:00006CE4                                         ; RunDlg::run_dlgProc(uint,uint,long)+315p ...
.text$mn:00006CE4                 push    ebp
.text$mn:00006CE5                 mov     ebp, esp
.text$mn:00006CE7                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00006CEC                 pop     ebp
.text$mn:00006CED                 retn
.text$mn:00006CED ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00006CED
.text$mn:00006CED ; ---------------------------------------------------------------------------
.text$mn:00006CEE                 align 10h
.text$mn:00006CEE _text$mn        ends
.text$mn:00006CEE
.text$mn:00006CF0 ; ===========================================================================
.text$mn:00006CF0
.text$mn:00006CF0 ; Segment type: Pure code
.text$mn:00006CF0 ; Segment permissions: Read/Execute
.text$mn:00006CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00006CF0                 assume cs:_text$mn
.text$mn:00006CF0                 ;org 6CF0h
.text$mn:00006CF0 ; COMDAT (pick any)
.text$mn:00006CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CF0
.text$mn:00006CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006CF0
.text$mn:00006CF0 ; Attributes: bp-based frame
.text$mn:00006CF0
.text$mn:00006CF0 ; const wchar_t *__thiscall Shortcut::getMenuName(Shortcut *__hidden this)
.text$mn:00006CF0                 public ?getMenuName@Shortcut@@QBEPB_WXZ
.text$mn:00006CF0 ?getMenuName@Shortcut@@QBEPB_WXZ proc near
.text$mn:00006CF0                                         ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+41p
.text$mn:00006CF0
.text$mn:00006CF0 var_4           = dword ptr -4
.text$mn:00006CF0
.text$mn:00006CF0                 push    ebp
.text$mn:00006CF1                 mov     ebp, esp
.text$mn:00006CF3                 push    ecx
.text$mn:00006CF4                 mov     [ebp+var_4], ecx
.text$mn:00006CF7                 mov     eax, [ebp+var_4]
.text$mn:00006CFA                 add     eax, 0A6h ; 'ª'
.text$mn:00006CFF                 mov     esp, ebp
.text$mn:00006D01                 pop     ebp
.text$mn:00006D02                 retn
.text$mn:00006D02 ?getMenuName@Shortcut@@QBEPB_WXZ endp
.text$mn:00006D02
.text$mn:00006D02 ; ---------------------------------------------------------------------------
.text$mn:00006D03                 align 4
.text$mn:00006D03 _text$mn        ends
.text$mn:00006D03
.text$mn:00006D04 ; ===========================================================================
.text$mn:00006D04
.text$mn:00006D04 ; Segment type: Pure code
.text$mn:00006D04 ; Segment permissions: Read/Execute
.text$mn:00006D04 _text$mn        segment para public 'CODE' use32
.text$mn:00006D04                 assume cs:_text$mn
.text$mn:00006D04                 ;org 6D04h
.text$mn:00006D04 ; COMDAT (pick any)
.text$mn:00006D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D04
.text$mn:00006D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D04
.text$mn:00006D04 ; Attributes: bp-based frame
.text$mn:00006D04
.text$mn:00006D04 ; struct NativeLangSpeaker *__thiscall NppParameters::getNativeLangSpeaker(NppParameters *__hidden this)
.text$mn:00006D04                 public ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ
.text$mn:00006D04 ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ proc near
.text$mn:00006D04                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+31Cp
.text$mn:00006D04
.text$mn:00006D04 var_4           = dword ptr -4
.text$mn:00006D04
.text$mn:00006D04                 push    ebp
.text$mn:00006D05                 mov     ebp, esp
.text$mn:00006D07                 push    ecx
.text$mn:00006D08                 mov     [ebp+var_4], ecx
.text$mn:00006D0B                 mov     eax, [ebp+var_4]
.text$mn:00006D0E                 mov     eax, [eax+1CC20h]
.text$mn:00006D14                 mov     esp, ebp
.text$mn:00006D16                 pop     ebp
.text$mn:00006D17                 retn
.text$mn:00006D17 ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ endp
.text$mn:00006D17
.text$mn:00006D17 _text$mn        ends
.text$mn:00006D17
.text$mn:00006D18 ; ===========================================================================
.text$mn:00006D18
.text$mn:00006D18 ; Segment type: Pure code
.text$mn:00006D18 ; Segment permissions: Read/Execute
.text$mn:00006D18 _text$mn        segment para public 'CODE' use32
.text$mn:00006D18                 assume cs:_text$mn
.text$mn:00006D18                 ;org 6D18h
.text$mn:00006D18 ; COMDAT (pick any)
.text$mn:00006D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D18
.text$mn:00006D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D18
.text$mn:00006D18 ; Attributes: bp-based frame
.text$mn:00006D18
.text$mn:00006D18 ; public: class std::vector<class UserCommand, class std::allocator<class UserCommand>> & __thiscall NppParameters::getUserCommandList(void)
.text$mn:00006D18                 public ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ
.text$mn:00006D18 ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ proc near
.text$mn:00006D18                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+14Ep
.text$mn:00006D18
.text$mn:00006D18 var_4           = dword ptr -4
.text$mn:00006D18
.text$mn:00006D18                 push    ebp
.text$mn:00006D19                 mov     ebp, esp
.text$mn:00006D1B                 push    ecx
.text$mn:00006D1C                 mov     [ebp+var_4], ecx
.text$mn:00006D1F                 mov     eax, [ebp+var_4]
.text$mn:00006D22                 add     eax, 1C934h
.text$mn:00006D27                 mov     esp, ebp
.text$mn:00006D29                 pop     ebp
.text$mn:00006D2A                 retn
.text$mn:00006D2A ?getUserCommandList@NppParameters@@QAEAAV?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@XZ endp
.text$mn:00006D2A
.text$mn:00006D2A ; ---------------------------------------------------------------------------
.text$mn:00006D2B                 align 4
.text$mn:00006D2B _text$mn        ends
.text$mn:00006D2B
.text$mn:00006D2C ; ===========================================================================
.text$mn:00006D2C
.text$mn:00006D2C ; Segment type: Pure code
.text$mn:00006D2C ; Segment permissions: Read/Execute
.text$mn:00006D2C _text$mn        segment para public 'CODE' use32
.text$mn:00006D2C                 assume cs:_text$mn
.text$mn:00006D2C                 ;org 6D2Ch
.text$mn:00006D2C ; COMDAT (pick any)
.text$mn:00006D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D2C
.text$mn:00006D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00006D2C
.text$mn:00006D2C ; Attributes: bp-based frame
.text$mn:00006D2C
.text$mn:00006D2C ; int __thiscall Window::getWidth(Window *__hidden this)
.text$mn:00006D2C                 public ?getWidth@Window@@UBEHXZ
.text$mn:00006D2C ?getWidth@Window@@UBEHXZ proc near      ; DATA XREF: .rdata:00008E88o
.text$mn:00006D2C                                         ; .rdata:00008EBCo ...
.text$mn:00006D2C
.text$mn:00006D2C var_18          = dword ptr -18h
.text$mn:00006D2C Rect            = tagRECT ptr -14h
.text$mn:00006D2C var_4           = dword ptr -4
.text$mn:00006D2C
.text$mn:00006D2C                 push    ebp
.text$mn:00006D2D                 mov     ebp, esp
.text$mn:00006D2F                 sub     esp, 18h
.text$mn:00006D32                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006D37                 xor     eax, ebp
.text$mn:00006D39                 mov     [ebp+var_4], eax
.text$mn:00006D3C                 mov     [ebp+var_18], ecx
.text$mn:00006D3F                 lea     eax, [ebp+Rect]
.text$mn:00006D42                 push    eax             ; lpRect
.text$mn:00006D43                 mov     ecx, [ebp+var_18]
.text$mn:00006D46                 mov     edx, [ecx+0Ch]
.text$mn:00006D49                 push    edx             ; hWnd
.text$mn:00006D4A                 call    dword ptr ds:__imp__GetClientRect@8 ; GetClientRect(x,x)
.text$mn:00006D50                 mov     eax, [ebp+Rect.right]
.text$mn:00006D53                 sub     eax, [ebp+Rect.left]
.text$mn:00006D56                 mov     ecx, [ebp+var_4]
.text$mn:00006D59                 xor     ecx, ebp
.text$mn:00006D5B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00006D60                 mov     esp, ebp
.text$mn:00006D62                 pop     ebp
.text$mn:00006D63                 retn
.text$mn:00006D63 ?getWidth@Window@@UBEHXZ endp
.text$mn:00006D63
.text$mn:00006D63 _text$mn        ends
.text$mn:00006D63
.text$mn:00006D64 ; ===========================================================================
.text$mn:00006D64
.text$mn:00006D64 ; Segment type: Pure code
.text$mn:00006D64 ; Segment permissions: Read/Execute
.text$mn:00006D64 _text$mn        segment para public 'CODE' use32
.text$mn:00006D64                 assume cs:_text$mn
.text$mn:00006D64                 ;org 6D64h
.text$mn:00006D64 ; COMDAT (pick any)
.text$mn:00006D64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D64
.text$mn:00006D64 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D64
.text$mn:00006D64 ; Attributes: bp-based frame
.text$mn:00006D64
.text$mn:00006D64 ; void __thiscall Window::getWindowRect(Window *this, struct tagRECT *)
.text$mn:00006D64                 public ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z
.text$mn:00006D64 ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z proc near
.text$mn:00006D64                                         ; DATA XREF: .rdata:00008E84o
.text$mn:00006D64                                         ; .rdata:00008EB8o ...
.text$mn:00006D64
.text$mn:00006D64 var_4           = dword ptr -4
.text$mn:00006D64 lpRect          = dword ptr  8
.text$mn:00006D64
.text$mn:00006D64                 push    ebp
.text$mn:00006D65                 mov     ebp, esp
.text$mn:00006D67                 push    ecx
.text$mn:00006D68                 mov     [ebp+var_4], ecx
.text$mn:00006D6B                 mov     eax, [ebp+lpRect]
.text$mn:00006D6E                 push    eax             ; lpRect
.text$mn:00006D6F                 mov     ecx, [ebp+var_4]
.text$mn:00006D72                 mov     edx, [ecx+0Ch]
.text$mn:00006D75                 push    edx             ; hWnd
.text$mn:00006D76                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00006D7C                 mov     esp, ebp
.text$mn:00006D7E                 pop     ebp
.text$mn:00006D7F                 retn    4
.text$mn:00006D7F ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z endp
.text$mn:00006D7F
.text$mn:00006D7F ; ---------------------------------------------------------------------------
.text$mn:00006D82                 align 4
.text$mn:00006D82 _text$mn        ends
.text$mn:00006D82
.text$mn:00006D84 ; ===========================================================================
.text$mn:00006D84
.text$mn:00006D84 ; Segment type: Pure code
.text$mn:00006D84 ; Segment permissions: Read/Execute
.text$mn:00006D84 _text$mn        segment para public 'CODE' use32
.text$mn:00006D84                 assume cs:_text$mn
.text$mn:00006D84                 ;org 6D84h
.text$mn:00006D84 ; COMDAT (pick any)
.text$mn:00006D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D84
.text$mn:00006D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D84
.text$mn:00006D84 ; Attributes: bp-based frame
.text$mn:00006D84
.text$mn:00006D84 ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:00006D84                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00006D84 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00006D84                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+207p
.text$mn:00006D84                                         ; DATA XREF: .rdata:00008E68o ...
.text$mn:00006D84
.text$mn:00006D84 var_4           = dword ptr -4
.text$mn:00006D84 arg_0           = dword ptr  8
.text$mn:00006D84 arg_4           = dword ptr  0Ch
.text$mn:00006D84
.text$mn:00006D84                 push    ebp
.text$mn:00006D85                 mov     ebp, esp
.text$mn:00006D87                 push    ecx
.text$mn:00006D88                 mov     [ebp+var_4], ecx
.text$mn:00006D8B                 mov     eax, [ebp+var_4]
.text$mn:00006D8E                 mov     ecx, [ebp+arg_0]
.text$mn:00006D91                 mov     [eax+4], ecx
.text$mn:00006D94                 mov     edx, [ebp+var_4]
.text$mn:00006D97                 mov     eax, [ebp+arg_4]
.text$mn:00006D9A                 mov     [edx+8], eax
.text$mn:00006D9D                 mov     esp, ebp
.text$mn:00006D9F                 pop     ebp
.text$mn:00006DA0                 retn    8
.text$mn:00006DA0 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00006DA0
.text$mn:00006DA0 ; ---------------------------------------------------------------------------
.text$mn:00006DA3                 align 4
.text$mn:00006DA3 _text$mn        ends
.text$mn:00006DA3
.text$mn:00006DA4 ; ===========================================================================
.text$mn:00006DA4
.text$mn:00006DA4 ; Segment type: Pure code
.text$mn:00006DA4 ; Segment permissions: Read/Execute
.text$mn:00006DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00006DA4                 assume cs:_text$mn
.text$mn:00006DA4                 ;org 6DA4h
.text$mn:00006DA4 ; COMDAT (pick any)
.text$mn:00006DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DA4
.text$mn:00006DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006DA4
.text$mn:00006DA4 ; Attributes: bp-based frame
.text$mn:00006DA4
.text$mn:00006DA4 ; bool __thiscall StaticDialog::isCreated(StaticDialog *__hidden this)
.text$mn:00006DA4                 public ?isCreated@StaticDialog@@UBE_NXZ
.text$mn:00006DA4 ?isCreated@StaticDialog@@UBE_NXZ proc near
.text$mn:00006DA4                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+39p
.text$mn:00006DA4                                         ; DATA XREF: .rdata:00008ECCo ...
.text$mn:00006DA4
.text$mn:00006DA4 var_8           = dword ptr -8
.text$mn:00006DA4 var_4           = dword ptr -4
.text$mn:00006DA4
.text$mn:00006DA4                 push    ebp
.text$mn:00006DA5                 mov     ebp, esp
.text$mn:00006DA7                 sub     esp, 8
.text$mn:00006DAA                 mov     [ebp+var_8], ecx
.text$mn:00006DAD                 mov     eax, [ebp+var_8]
.text$mn:00006DB0                 cmp     dword ptr [eax+0Ch], 0
.text$mn:00006DB4                 jz      short loc_6DBF
.text$mn:00006DB6                 mov     [ebp+var_4], 1
.text$mn:00006DBD                 jmp     short loc_6DC6
.text$mn:00006DBF ; ---------------------------------------------------------------------------
.text$mn:00006DBF
.text$mn:00006DBF loc_6DBF:                               ; CODE XREF: StaticDialog::isCreated(void)+10j
.text$mn:00006DBF                 mov     [ebp+var_4], 0
.text$mn:00006DC6
.text$mn:00006DC6 loc_6DC6:                               ; CODE XREF: StaticDialog::isCreated(void)+19j
.text$mn:00006DC6                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006DC9                 mov     esp, ebp
.text$mn:00006DCB                 pop     ebp
.text$mn:00006DCC                 retn
.text$mn:00006DCC ?isCreated@StaticDialog@@UBE_NXZ endp
.text$mn:00006DCC
.text$mn:00006DCC ; ---------------------------------------------------------------------------
.text$mn:00006DCD                 align 10h
.text$mn:00006DCD _text$mn        ends
.text$mn:00006DCD
.text$mn:00006DD0 ; ===========================================================================
.text$mn:00006DD0
.text$mn:00006DD0 ; Segment type: Pure code
.text$mn:00006DD0 ; Segment permissions: Read/Execute
.text$mn:00006DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00006DD0                 assume cs:_text$mn
.text$mn:00006DD0                 ;org 6DD0h
.text$mn:00006DD0 ; COMDAT (pick any)
.text$mn:00006DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DD0
.text$mn:00006DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006DD0
.text$mn:00006DD0 ; Attributes: bp-based frame
.text$mn:00006DD0
.text$mn:00006DD0 ; bool __thiscall Shortcut::isEnabled(Shortcut *__hidden this)
.text$mn:00006DD0                 public ?isEnabled@Shortcut@@UBE_NXZ
.text$mn:00006DD0 ?isEnabled@Shortcut@@UBE_NXZ proc near  ; DATA XREF: .rdata:000090B0o
.text$mn:00006DD0                                         ; .rdata:00009108o ...
.text$mn:00006DD0
.text$mn:00006DD0 var_8           = dword ptr -8
.text$mn:00006DD0 var_4           = dword ptr -4
.text$mn:00006DD0
.text$mn:00006DD0                 push    ebp
.text$mn:00006DD1                 mov     ebp, esp
.text$mn:00006DD3                 sub     esp, 8
.text$mn:00006DD6                 mov     [ebp+var_8], ecx
.text$mn:00006DD9                 mov     eax, [ebp+var_8]
.text$mn:00006DDC                 movzx   ecx, byte ptr [eax+23h]
.text$mn:00006DE0                 test    ecx, ecx
.text$mn:00006DE2                 jz      short loc_6DED
.text$mn:00006DE4                 mov     [ebp+var_4], 1
.text$mn:00006DEB                 jmp     short loc_6DF4
.text$mn:00006DED ; ---------------------------------------------------------------------------
.text$mn:00006DED
.text$mn:00006DED loc_6DED:                               ; CODE XREF: Shortcut::isEnabled(void)+12j
.text$mn:00006DED                 mov     [ebp+var_4], 0
.text$mn:00006DF4
.text$mn:00006DF4 loc_6DF4:                               ; CODE XREF: Shortcut::isEnabled(void)+1Bj
.text$mn:00006DF4                 mov     al, byte ptr [ebp+var_4]
.text$mn:00006DF7                 mov     esp, ebp
.text$mn:00006DF9                 pop     ebp
.text$mn:00006DFA                 retn
.text$mn:00006DFA ?isEnabled@Shortcut@@UBE_NXZ endp
.text$mn:00006DFA
.text$mn:00006DFA ; ---------------------------------------------------------------------------
.text$mn:00006DFB                 align 4
.text$mn:00006DFB _text$mn        ends
.text$mn:00006DFB
.text$mn:00006DFC ; ===========================================================================
.text$mn:00006DFC
.text$mn:00006DFC ; Segment type: Pure code
.text$mn:00006DFC ; Segment permissions: Read/Execute
.text$mn:00006DFC _text$mn        segment para public 'CODE' use32
.text$mn:00006DFC                 assume cs:_text$mn
.text$mn:00006DFC                 ;org 6DFCh
.text$mn:00006DFC ; COMDAT (pick any)
.text$mn:00006DFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006DFC
.text$mn:00006DFC ; =============== S U B R O U T I N E =======================================
.text$mn:00006DFC
.text$mn:00006DFC ; Attributes: bp-based frame
.text$mn:00006DFC
.text$mn:00006DFC ; bool __thiscall Shortcut::isValid(Shortcut *__hidden this)
.text$mn:00006DFC                 public ?isValid@Shortcut@@UBE_NXZ
.text$mn:00006DFC ?isValid@Shortcut@@UBE_NXZ proc near    ; DATA XREF: .rdata:000090ACo
.text$mn:00006DFC                                         ; .rdata:00009104o ...
.text$mn:00006DFC
.text$mn:00006DFC var_8           = dword ptr -8
.text$mn:00006DFC var_4           = dword ptr -4
.text$mn:00006DFC
.text$mn:00006DFC                 push    ebp
.text$mn:00006DFD                 mov     ebp, esp
.text$mn:00006DFF                 sub     esp, 8
.text$mn:00006E02                 mov     [ebp+var_4], ecx
.text$mn:00006E05                 mov     eax, [ebp+var_4]
.text$mn:00006E08                 movzx   ecx, byte ptr [eax+23h]
.text$mn:00006E0C                 test    ecx, ecx
.text$mn:00006E0E                 jnz     short loc_6E17
.text$mn:00006E10                 mov     al, 1
.text$mn:00006E12                 jmp     loc_6EA4
.text$mn:00006E17 ; ---------------------------------------------------------------------------
.text$mn:00006E17
.text$mn:00006E17 loc_6E17:                               ; CODE XREF: Shortcut::isValid(void)+12j
.text$mn:00006E17                 mov     edx, [ebp+var_4]
.text$mn:00006E1A                 movzx   eax, byte ptr [edx+23h]
.text$mn:00006E1E                 cmp     eax, 41h ; 'A'
.text$mn:00006E21                 jl      short loc_6E2F
.text$mn:00006E23                 mov     ecx, [ebp+var_4]
.text$mn:00006E26                 movzx   edx, byte ptr [ecx+23h]
.text$mn:00006E2A                 cmp     edx, 5Ah ; 'Z'
.text$mn:00006E2D                 jle     short loc_6E77
.text$mn:00006E2F
.text$mn:00006E2F loc_6E2F:                               ; CODE XREF: Shortcut::isValid(void)+25j
.text$mn:00006E2F                 mov     eax, [ebp+var_4]
.text$mn:00006E32                 movzx   ecx, byte ptr [eax+23h]
.text$mn:00006E36                 cmp     ecx, 30h ; '0'
.text$mn:00006E39                 jl      short loc_6E47
.text$mn:00006E3B                 mov     edx, [ebp+var_4]
.text$mn:00006E3E                 movzx   eax, byte ptr [edx+23h]
.text$mn:00006E42                 cmp     eax, 39h ; '9'
.text$mn:00006E45                 jle     short loc_6E77
.text$mn:00006E47
.text$mn:00006E47 loc_6E47:                               ; CODE XREF: Shortcut::isValid(void)+3Dj
.text$mn:00006E47                 mov     ecx, [ebp+var_4]
.text$mn:00006E4A                 movzx   edx, byte ptr [ecx+23h]
.text$mn:00006E4E                 cmp     edx, 20h ; ' '
.text$mn:00006E51                 jz      short loc_6E77
.text$mn:00006E53                 mov     eax, [ebp+var_4]
.text$mn:00006E56                 movzx   ecx, byte ptr [eax+23h]
.text$mn:00006E5A                 cmp     ecx, 14h
.text$mn:00006E5D                 jz      short loc_6E77
.text$mn:00006E5F                 mov     edx, [ebp+var_4]
.text$mn:00006E62                 movzx   eax, byte ptr [edx+23h]
.text$mn:00006E66                 cmp     eax, 8
.text$mn:00006E69                 jz      short loc_6E77
.text$mn:00006E6B                 mov     ecx, [ebp+var_4]
.text$mn:00006E6E                 movzx   edx, byte ptr [ecx+23h]
.text$mn:00006E72                 cmp     edx, 0Dh
.text$mn:00006E75                 jnz     short loc_6EA2
.text$mn:00006E77
.text$mn:00006E77 loc_6E77:                               ; CODE XREF: Shortcut::isValid(void)+31j
.text$mn:00006E77                                         ; Shortcut::isValid(void)+49j ...
.text$mn:00006E77                 mov     eax, [ebp+var_4]
.text$mn:00006E7A                 movzx   ecx, byte ptr [eax+20h]
.text$mn:00006E7E                 test    ecx, ecx
.text$mn:00006E80                 jnz     short loc_6E96
.text$mn:00006E82                 mov     edx, [ebp+var_4]
.text$mn:00006E85                 movzx   eax, byte ptr [edx+21h]
.text$mn:00006E89                 test    eax, eax
.text$mn:00006E8B                 jnz     short loc_6E96
.text$mn:00006E8D                 mov     [ebp+var_8], 0
.text$mn:00006E94                 jmp     short loc_6E9D
.text$mn:00006E96 ; ---------------------------------------------------------------------------
.text$mn:00006E96
.text$mn:00006E96 loc_6E96:                               ; CODE XREF: Shortcut::isValid(void)+84j
.text$mn:00006E96                                         ; Shortcut::isValid(void)+8Fj
.text$mn:00006E96                 mov     [ebp+var_8], 1
.text$mn:00006E9D
.text$mn:00006E9D loc_6E9D:                               ; CODE XREF: Shortcut::isValid(void)+98j
.text$mn:00006E9D                 mov     al, byte ptr [ebp+var_8]
.text$mn:00006EA0                 jmp     short loc_6EA4
.text$mn:00006EA2 ; ---------------------------------------------------------------------------
.text$mn:00006EA2
.text$mn:00006EA2 loc_6EA2:                               ; CODE XREF: Shortcut::isValid(void)+79j
.text$mn:00006EA2                 mov     al, 1
.text$mn:00006EA4
.text$mn:00006EA4 loc_6EA4:                               ; CODE XREF: Shortcut::isValid(void)+16j
.text$mn:00006EA4                                         ; Shortcut::isValid(void)+A4j
.text$mn:00006EA4                 mov     esp, ebp
.text$mn:00006EA6                 pop     ebp
.text$mn:00006EA7                 retn
.text$mn:00006EA7 ?isValid@Shortcut@@UBE_NXZ endp
.text$mn:00006EA7
.text$mn:00006EA7 _text$mn        ends
.text$mn:00006EA7
.text$mn:00006EA8 ; ===========================================================================
.text$mn:00006EA8
.text$mn:00006EA8 ; Segment type: Pure code
.text$mn:00006EA8 ; Segment permissions: Read/Execute
.text$mn:00006EA8 _text$mn        segment para public 'CODE' use32
.text$mn:00006EA8                 assume cs:_text$mn
.text$mn:00006EA8                 ;org 6EA8h
.text$mn:00006EA8 ; COMDAT (pick any)
.text$mn:00006EA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006EA8
.text$mn:00006EA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EA8
.text$mn:00006EA8 ; Attributes: bp-based frame
.text$mn:00006EA8
.text$mn:00006EA8 ; bool __thiscall Window::isVisible(Window *__hidden this)
.text$mn:00006EA8                 public ?isVisible@Window@@UBE_NXZ
.text$mn:00006EA8 ?isVisible@Window@@UBE_NXZ proc near    ; DATA XREF: .rdata:00008E90o
.text$mn:00006EA8                                         ; .rdata:00008EC4o ...
.text$mn:00006EA8
.text$mn:00006EA8 var_8           = dword ptr -8
.text$mn:00006EA8 var_1           = byte ptr -1
.text$mn:00006EA8
.text$mn:00006EA8                 push    ebp
.text$mn:00006EA9                 mov     ebp, esp
.text$mn:00006EAB                 sub     esp, 8
.text$mn:00006EAE                 mov     [ebp+var_8], ecx
.text$mn:00006EB1                 mov     eax, [ebp+var_8]
.text$mn:00006EB4                 mov     ecx, [eax+0Ch]
.text$mn:00006EB7                 push    ecx             ; hWnd
.text$mn:00006EB8                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00006EBE                 test    eax, eax
.text$mn:00006EC0                 jz      short loc_6EC8
.text$mn:00006EC2                 mov     [ebp+var_1], 1
.text$mn:00006EC6                 jmp     short loc_6ECC
.text$mn:00006EC8 ; ---------------------------------------------------------------------------
.text$mn:00006EC8
.text$mn:00006EC8 loc_6EC8:                               ; CODE XREF: Window::isVisible(void)+18j
.text$mn:00006EC8                 mov     [ebp+var_1], 0
.text$mn:00006ECC
.text$mn:00006ECC loc_6ECC:                               ; CODE XREF: Window::isVisible(void)+1Ej
.text$mn:00006ECC                 mov     al, [ebp+var_1]
.text$mn:00006ECF                 mov     esp, ebp
.text$mn:00006ED1                 pop     ebp
.text$mn:00006ED2                 retn
.text$mn:00006ED2 ?isVisible@Window@@UBE_NXZ endp
.text$mn:00006ED2
.text$mn:00006ED2 ; ---------------------------------------------------------------------------
.text$mn:00006ED3                 align 4
.text$mn:00006ED3 _text$mn        ends
.text$mn:00006ED3
.text$mn:00006ED4 ; ===========================================================================
.text$mn:00006ED4
.text$mn:00006ED4 ; Segment type: Pure code
.text$mn:00006ED4 ; Segment permissions: Read/Execute
.text$mn:00006ED4 _text$mn        segment para public 'CODE' use32
.text$mn:00006ED4                 assume cs:_text$mn
.text$mn:00006ED4                 ;org 6ED4h
.text$mn:00006ED4 ; COMDAT (pick any)
.text$mn:00006ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006ED4
.text$mn:00006ED4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006ED4
.text$mn:00006ED4 ; Attributes: bp-based frame
.text$mn:00006ED4
.text$mn:00006ED4 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00006ED4                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00006ED4 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00006ED4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00006ED4
.text$mn:00006ED4 var_4           = dword ptr -4
.text$mn:00006ED4 Str             = dword ptr  8
.text$mn:00006ED4
.text$mn:00006ED4                 push    ebp
.text$mn:00006ED5                 mov     ebp, esp
.text$mn:00006ED7                 push    ecx
.text$mn:00006ED8                 mov     eax, [ebp+Str]
.text$mn:00006EDB                 movsx   ecx, byte ptr [eax]
.text$mn:00006EDE                 test    ecx, ecx
.text$mn:00006EE0                 jnz     short loc_6EEB
.text$mn:00006EE2                 mov     [ebp+var_4], 0
.text$mn:00006EE9                 jmp     short loc_6EFA
.text$mn:00006EEB ; ---------------------------------------------------------------------------
.text$mn:00006EEB
.text$mn:00006EEB loc_6EEB:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00006EEB                 mov     edx, [ebp+Str]
.text$mn:00006EEE                 push    edx             ; Str
.text$mn:00006EEF                 call    _strlen
.text$mn:00006EF4                 add     esp, 4
.text$mn:00006EF7                 mov     [ebp+var_4], eax
.text$mn:00006EFA
.text$mn:00006EFA loc_6EFA:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00006EFA                 mov     eax, [ebp+var_4]
.text$mn:00006EFD                 mov     esp, ebp
.text$mn:00006EFF                 pop     ebp
.text$mn:00006F00                 retn
.text$mn:00006F00 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00006F00
.text$mn:00006F00 ; ---------------------------------------------------------------------------
.text$mn:00006F01                 align 4
.text$mn:00006F01 _text$mn        ends
.text$mn:00006F01
.text$mn:00006F04 ; ===========================================================================
.text$mn:00006F04
.text$mn:00006F04 ; Segment type: Pure code
.text$mn:00006F04 ; Segment permissions: Read/Execute
.text$mn:00006F04 _text$mn        segment para public 'CODE' use32
.text$mn:00006F04                 assume cs:_text$mn
.text$mn:00006F04                 ;org 6F04h
.text$mn:00006F04 ; COMDAT (pick any)
.text$mn:00006F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F04
.text$mn:00006F04 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F04
.text$mn:00006F04 ; Attributes: bp-based frame
.text$mn:00006F04
.text$mn:00006F04 ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:00006F04                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:00006F04 ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:00006F04                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+43p
.text$mn:00006F04                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(wchar_t const *)+21p ...
.text$mn:00006F04
.text$mn:00006F04 var_4           = dword ptr -4
.text$mn:00006F04 Str             = dword ptr  8
.text$mn:00006F04
.text$mn:00006F04                 push    ebp
.text$mn:00006F05                 mov     ebp, esp
.text$mn:00006F07                 push    ecx
.text$mn:00006F08                 mov     eax, [ebp+Str]
.text$mn:00006F0B                 movzx   ecx, word ptr [eax]
.text$mn:00006F0E                 test    ecx, ecx
.text$mn:00006F10                 jnz     short loc_6F1B
.text$mn:00006F12                 mov     [ebp+var_4], 0
.text$mn:00006F19                 jmp     short loc_6F2A
.text$mn:00006F1B ; ---------------------------------------------------------------------------
.text$mn:00006F1B
.text$mn:00006F1B loc_6F1B:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00006F1B                 mov     edx, [ebp+Str]
.text$mn:00006F1E                 push    edx             ; Str
.text$mn:00006F1F                 call    _wcslen
.text$mn:00006F24                 add     esp, 4
.text$mn:00006F27                 mov     [ebp+var_4], eax
.text$mn:00006F2A
.text$mn:00006F2A loc_6F2A:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00006F2A                 mov     eax, [ebp+var_4]
.text$mn:00006F2D                 mov     esp, ebp
.text$mn:00006F2F                 pop     ebp
.text$mn:00006F30                 retn
.text$mn:00006F30 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00006F30
.text$mn:00006F30 ; ---------------------------------------------------------------------------
.text$mn:00006F31                 align 4
.text$mn:00006F31 _text$mn        ends
.text$mn:00006F31
.text$mn:00006F34 ; ===========================================================================
.text$mn:00006F34
.text$mn:00006F34 ; Segment type: Pure code
.text$mn:00006F34 ; Segment permissions: Read/Execute
.text$mn:00006F34 _text$mn        segment para public 'CODE' use32
.text$mn:00006F34                 assume cs:_text$mn
.text$mn:00006F34                 ;org 6F34h
.text$mn:00006F34 ; COMDAT (pick any)
.text$mn:00006F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F34
.text$mn:00006F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F34
.text$mn:00006F34 ; Attributes: bp-based frame
.text$mn:00006F34
.text$mn:00006F34 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00006F34                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00006F34 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00006F34                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00006F34
.text$mn:00006F34 var_4           = dword ptr -4
.text$mn:00006F34
.text$mn:00006F34                 push    ebp
.text$mn:00006F35                 mov     ebp, esp
.text$mn:00006F37                 push    ecx
.text$mn:00006F38                 mov     [ebp+var_4], ecx
.text$mn:00006F3B                 mov     eax, [ebp+var_4]
.text$mn:00006F3E                 push    eax
.text$mn:00006F3F                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00006F44                 add     esp, 4
.text$mn:00006F47                 mov     esp, ebp
.text$mn:00006F49                 pop     ebp
.text$mn:00006F4A                 retn
.text$mn:00006F4A ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00006F4A
.text$mn:00006F4A ; ---------------------------------------------------------------------------
.text$mn:00006F4B                 align 4
.text$mn:00006F4B _text$mn        ends
.text$mn:00006F4B
.text$mn:00006F4C ; ===========================================================================
.text$mn:00006F4C
.text$mn:00006F4C ; Segment type: Pure code
.text$mn:00006F4C ; Segment permissions: Read/Execute
.text$mn:00006F4C _text$mn        segment para public 'CODE' use32
.text$mn:00006F4C                 assume cs:_text$mn
.text$mn:00006F4C                 ;org 6F4Ch
.text$mn:00006F4C ; COMDAT (pick any)
.text$mn:00006F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F4C
.text$mn:00006F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F4C
.text$mn:00006F4C ; Attributes: bp-based frame
.text$mn:00006F4C
.text$mn:00006F4C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class UserCommand>>::max_size(void)const
.text$mn:00006F4C                 public ?max_size@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ
.text$mn:00006F4C ?max_size@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:00006F4C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::max_size(void)+17p
.text$mn:00006F4C
.text$mn:00006F4C var_4           = dword ptr -4
.text$mn:00006F4C
.text$mn:00006F4C                 push    ebp
.text$mn:00006F4D                 mov     ebp, esp
.text$mn:00006F4F                 push    ecx
.text$mn:00006F50                 mov     [ebp+var_4], ecx
.text$mn:00006F53                 mov     eax, [ebp+var_4]
.text$mn:00006F56                 push    eax
.text$mn:00006F57                 call    ?max_size@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAIABV?$allocator@VUserCommand@@@2@@Z ; std::allocator_traits<std::allocator<UserCommand>>::max_size(std::allocator<UserCommand> const &)
.text$mn:00006F5C                 add     esp, 4
.text$mn:00006F5F                 mov     esp, ebp
.text$mn:00006F61                 pop     ebp
.text$mn:00006F62                 retn
.text$mn:00006F62 ?max_size@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ endp
.text$mn:00006F62
.text$mn:00006F62 ; ---------------------------------------------------------------------------
.text$mn:00006F63                 align 4
.text$mn:00006F63 _text$mn        ends
.text$mn:00006F63
.text$mn:00006F64 ; ===========================================================================
.text$mn:00006F64
.text$mn:00006F64 ; Segment type: Pure code
.text$mn:00006F64 ; Segment permissions: Read/Execute
.text$mn:00006F64 _text$mn        segment para public 'CODE' use32
.text$mn:00006F64                 assume cs:_text$mn
.text$mn:00006F64                 ;org 6F64h
.text$mn:00006F64 ; COMDAT (pick any)
.text$mn:00006F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F64
.text$mn:00006F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00006F64
.text$mn:00006F64 ; Attributes: bp-based frame
.text$mn:00006F64
.text$mn:00006F64 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:00006F64                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:00006F64 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:00006F64                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:00006F64
.text$mn:00006F64 var_4           = dword ptr -4
.text$mn:00006F64
.text$mn:00006F64                 push    ebp
.text$mn:00006F65                 mov     ebp, esp
.text$mn:00006F67                 push    ecx
.text$mn:00006F68                 mov     [ebp+var_4], ecx
.text$mn:00006F6B                 mov     eax, [ebp+var_4]
.text$mn:00006F6E                 push    eax
.text$mn:00006F6F                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:00006F74                 add     esp, 4
.text$mn:00006F77                 mov     esp, ebp
.text$mn:00006F79                 pop     ebp
.text$mn:00006F7A                 retn
.text$mn:00006F7A ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:00006F7A
.text$mn:00006F7A ; ---------------------------------------------------------------------------
.text$mn:00006F7B                 align 4
.text$mn:00006F7B _text$mn        ends
.text$mn:00006F7B
.text$mn:00006F7C ; ===========================================================================
.text$mn:00006F7C
.text$mn:00006F7C ; Segment type: Pure code
.text$mn:00006F7C ; Segment permissions: Read/Execute
.text$mn:00006F7C _text$mn        segment para public 'CODE' use32
.text$mn:00006F7C                 assume cs:_text$mn
.text$mn:00006F7C                 ;org 6F7Ch
.text$mn:00006F7C ; COMDAT (pick any)
.text$mn:00006F7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F7C
.text$mn:00006F7C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F7C
.text$mn:00006F7C ; Attributes: bp-based frame
.text$mn:00006F7C
.text$mn:00006F7C ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00006F7C                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00006F7C ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00006F7C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00006F7C
.text$mn:00006F7C var_4           = dword ptr -4
.text$mn:00006F7C
.text$mn:00006F7C                 push    ebp
.text$mn:00006F7D                 mov     ebp, esp
.text$mn:00006F7F                 push    ecx
.text$mn:00006F80                 mov     [ebp+var_4], ecx
.text$mn:00006F83                 or      eax, 0FFFFFFFFh
.text$mn:00006F86                 mov     esp, ebp
.text$mn:00006F88                 pop     ebp
.text$mn:00006F89                 retn
.text$mn:00006F89 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00006F89
.text$mn:00006F89 ; ---------------------------------------------------------------------------
.text$mn:00006F8A                 align 4
.text$mn:00006F8A _text$mn        ends
.text$mn:00006F8A
.text$mn:00006F8C ; ===========================================================================
.text$mn:00006F8C
.text$mn:00006F8C ; Segment type: Pure code
.text$mn:00006F8C ; Segment permissions: Read/Execute
.text$mn:00006F8C _text$mn        segment para public 'CODE' use32
.text$mn:00006F8C                 assume cs:_text$mn
.text$mn:00006F8C                 ;org 6F8Ch
.text$mn:00006F8C ; COMDAT (pick any)
.text$mn:00006F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F8C
.text$mn:00006F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F8C
.text$mn:00006F8C ; Attributes: bp-based frame
.text$mn:00006F8C
.text$mn:00006F8C ; public: unsigned int __thiscall std::allocator<class UserCommand>::max_size(void)const
.text$mn:00006F8C                 public ?max_size@?$allocator@VUserCommand@@@std@@QBEIXZ
.text$mn:00006F8C ?max_size@?$allocator@VUserCommand@@@std@@QBEIXZ proc near
.text$mn:00006F8C                                         ; CODE XREF: std::allocator_traits<std::allocator<UserCommand>>::max_size(std::allocator<UserCommand> const &)+6p
.text$mn:00006F8C
.text$mn:00006F8C var_4           = dword ptr -4
.text$mn:00006F8C
.text$mn:00006F8C                 push    ebp
.text$mn:00006F8D                 mov     ebp, esp
.text$mn:00006F8F                 push    ecx
.text$mn:00006F90                 mov     [ebp+var_4], ecx
.text$mn:00006F93                 mov     eax, 0C7CE0Ch
.text$mn:00006F98                 mov     esp, ebp
.text$mn:00006F9A                 pop     ebp
.text$mn:00006F9B                 retn
.text$mn:00006F9B ?max_size@?$allocator@VUserCommand@@@std@@QBEIXZ endp
.text$mn:00006F9B
.text$mn:00006F9B _text$mn        ends
.text$mn:00006F9B
.text$mn:00006F9C ; ===========================================================================
.text$mn:00006F9C
.text$mn:00006F9C ; Segment type: Pure code
.text$mn:00006F9C ; Segment permissions: Read/Execute
.text$mn:00006F9C _text$mn        segment para public 'CODE' use32
.text$mn:00006F9C                 assume cs:_text$mn
.text$mn:00006F9C                 ;org 6F9Ch
.text$mn:00006F9C ; COMDAT (pick any)
.text$mn:00006F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006F9C
.text$mn:00006F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00006F9C
.text$mn:00006F9C ; Attributes: bp-based frame
.text$mn:00006F9C
.text$mn:00006F9C ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:00006F9C                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:00006F9C ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:00006F9C                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:00006F9C
.text$mn:00006F9C var_4           = dword ptr -4
.text$mn:00006F9C
.text$mn:00006F9C                 push    ebp
.text$mn:00006F9D                 mov     ebp, esp
.text$mn:00006F9F                 push    ecx
.text$mn:00006FA0                 mov     [ebp+var_4], ecx
.text$mn:00006FA3                 mov     eax, 7FFFFFFFh
.text$mn:00006FA8                 mov     esp, ebp
.text$mn:00006FAA                 pop     ebp
.text$mn:00006FAB                 retn
.text$mn:00006FAB ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:00006FAB
.text$mn:00006FAB _text$mn        ends
.text$mn:00006FAB
.text$mn:00006FAC ; ===========================================================================
.text$mn:00006FAC
.text$mn:00006FAC ; Segment type: Pure code
.text$mn:00006FAC ; Segment permissions: Read/Execute
.text$mn:00006FAC _text$mn        segment para public 'CODE' use32
.text$mn:00006FAC                 assume cs:_text$mn
.text$mn:00006FAC                 ;org 6FACh
.text$mn:00006FAC ; COMDAT (pick any)
.text$mn:00006FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FAC
.text$mn:00006FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FAC
.text$mn:00006FAC ; Attributes: bp-based frame
.text$mn:00006FAC
.text$mn:00006FAC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00006FAC                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00006FAC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00006FAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00006FAC
.text$mn:00006FAC arg_0           = dword ptr  8
.text$mn:00006FAC
.text$mn:00006FAC                 push    ebp
.text$mn:00006FAD                 mov     ebp, esp
.text$mn:00006FAF                 mov     ecx, [ebp+arg_0]
.text$mn:00006FB2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00006FB7                 pop     ebp
.text$mn:00006FB8                 retn
.text$mn:00006FB8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00006FB8
.text$mn:00006FB8 ; ---------------------------------------------------------------------------
.text$mn:00006FB9                 align 4
.text$mn:00006FB9 _text$mn        ends
.text$mn:00006FB9
.text$mn:00006FBC ; ===========================================================================
.text$mn:00006FBC
.text$mn:00006FBC ; Segment type: Pure code
.text$mn:00006FBC ; Segment permissions: Read/Execute
.text$mn:00006FBC _text$mn        segment para public 'CODE' use32
.text$mn:00006FBC                 assume cs:_text$mn
.text$mn:00006FBC                 ;org 6FBCh
.text$mn:00006FBC ; COMDAT (pick any)
.text$mn:00006FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FBC
.text$mn:00006FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FBC
.text$mn:00006FBC ; Attributes: bp-based frame
.text$mn:00006FBC
.text$mn:00006FBC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class UserCommand>>::max_size(class std::allocator<class UserCommand> const &)
.text$mn:00006FBC                 public ?max_size@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAIABV?$allocator@VUserCommand@@@2@@Z
.text$mn:00006FBC ?max_size@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAIABV?$allocator@VUserCommand@@@2@@Z proc near
.text$mn:00006FBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<UserCommand>>::max_size(void)+Bp
.text$mn:00006FBC
.text$mn:00006FBC arg_0           = dword ptr  8
.text$mn:00006FBC
.text$mn:00006FBC                 push    ebp
.text$mn:00006FBD                 mov     ebp, esp
.text$mn:00006FBF                 mov     ecx, [ebp+arg_0]
.text$mn:00006FC2                 call    ?max_size@?$allocator@VUserCommand@@@std@@QBEIXZ ; std::allocator<UserCommand>::max_size(void)
.text$mn:00006FC7                 pop     ebp
.text$mn:00006FC8                 retn
.text$mn:00006FC8 ?max_size@?$allocator_traits@V?$allocator@VUserCommand@@@std@@@std@@SAIABV?$allocator@VUserCommand@@@2@@Z endp
.text$mn:00006FC8
.text$mn:00006FC8 ; ---------------------------------------------------------------------------
.text$mn:00006FC9                 align 4
.text$mn:00006FC9 _text$mn        ends
.text$mn:00006FC9
.text$mn:00006FCC ; ===========================================================================
.text$mn:00006FCC
.text$mn:00006FCC ; Segment type: Pure code
.text$mn:00006FCC ; Segment permissions: Read/Execute
.text$mn:00006FCC _text$mn        segment para public 'CODE' use32
.text$mn:00006FCC                 assume cs:_text$mn
.text$mn:00006FCC                 ;org 6FCCh
.text$mn:00006FCC ; COMDAT (pick any)
.text$mn:00006FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FCC
.text$mn:00006FCC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FCC
.text$mn:00006FCC ; Attributes: bp-based frame
.text$mn:00006FCC
.text$mn:00006FCC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:00006FCC                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:00006FCC ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:00006FCC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:00006FCC
.text$mn:00006FCC arg_0           = dword ptr  8
.text$mn:00006FCC
.text$mn:00006FCC                 push    ebp
.text$mn:00006FCD                 mov     ebp, esp
.text$mn:00006FCF                 mov     ecx, [ebp+arg_0]
.text$mn:00006FD2                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:00006FD7                 pop     ebp
.text$mn:00006FD8                 retn
.text$mn:00006FD8 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:00006FD8
.text$mn:00006FD8 ; ---------------------------------------------------------------------------
.text$mn:00006FD9                 align 4
.text$mn:00006FD9 _text$mn        ends
.text$mn:00006FD9
.text$mn:00006FDC ; ===========================================================================
.text$mn:00006FDC
.text$mn:00006FDC ; Segment type: Pure code
.text$mn:00006FDC ; Segment permissions: Read/Execute
.text$mn:00006FDC _text$mn        segment para public 'CODE' use32
.text$mn:00006FDC                 assume cs:_text$mn
.text$mn:00006FDC                 ;org 6FDCh
.text$mn:00006FDC ; COMDAT (pick any)
.text$mn:00006FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006FDC
.text$mn:00006FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00006FDC
.text$mn:00006FDC ; Attributes: bp-based frame
.text$mn:00006FDC
.text$mn:00006FDC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00006FDC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00006FDC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00006FDC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00006FDC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00006FDC
.text$mn:00006FDC var_10          = dword ptr -10h
.text$mn:00006FDC var_C           = dword ptr -0Ch
.text$mn:00006FDC var_8           = dword ptr -8
.text$mn:00006FDC var_1           = byte ptr -1
.text$mn:00006FDC
.text$mn:00006FDC                 push    ebp
.text$mn:00006FDD                 mov     ebp, esp
.text$mn:00006FDF                 sub     esp, 10h
.text$mn:00006FE2                 mov     [ebp+var_10], ecx
.text$mn:00006FE5                 lea     eax, [ebp+var_1]
.text$mn:00006FE8                 push    eax
.text$mn:00006FE9                 mov     ecx, [ebp+var_10]
.text$mn:00006FEC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00006FF1                 mov     ecx, eax
.text$mn:00006FF3                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00006FF8                 mov     [ebp+var_8], eax
.text$mn:00006FFB                 cmp     [ebp+var_8], 1
.text$mn:00006FFF                 ja      short loc_700A
.text$mn:00007001                 mov     [ebp+var_C], 1
.text$mn:00007008                 jmp     short loc_7013
.text$mn:0000700A ; ---------------------------------------------------------------------------
.text$mn:0000700A
.text$mn:0000700A loc_700A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000700A                 mov     ecx, [ebp+var_8]
.text$mn:0000700D                 sub     ecx, 1
.text$mn:00007010                 mov     [ebp+var_C], ecx
.text$mn:00007013
.text$mn:00007013 loc_7013:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00007013                 mov     eax, [ebp+var_C]
.text$mn:00007016                 mov     esp, ebp
.text$mn:00007018                 pop     ebp
.text$mn:00007019                 retn
.text$mn:00007019 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00007019
.text$mn:00007019 ; ---------------------------------------------------------------------------
.text$mn:0000701A                 align 4
.text$mn:0000701A _text$mn        ends
.text$mn:0000701A
.text$mn:0000701C ; ===========================================================================
.text$mn:0000701C
.text$mn:0000701C ; Segment type: Pure code
.text$mn:0000701C ; Segment permissions: Read/Execute
.text$mn:0000701C _text$mn        segment para public 'CODE' use32
.text$mn:0000701C                 assume cs:_text$mn
.text$mn:0000701C                 ;org 701Ch
.text$mn:0000701C ; COMDAT (pick any)
.text$mn:0000701C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000701C
.text$mn:0000701C ; =============== S U B R O U T I N E =======================================
.text$mn:0000701C
.text$mn:0000701C ; Attributes: bp-based frame
.text$mn:0000701C
.text$mn:0000701C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000701C                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000701C ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000701C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000701C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000701C
.text$mn:0000701C var_10          = dword ptr -10h
.text$mn:0000701C var_C           = dword ptr -0Ch
.text$mn:0000701C var_8           = dword ptr -8
.text$mn:0000701C var_1           = byte ptr -1
.text$mn:0000701C
.text$mn:0000701C                 push    ebp
.text$mn:0000701D                 mov     ebp, esp
.text$mn:0000701F                 sub     esp, 10h
.text$mn:00007022                 mov     [ebp+var_10], ecx
.text$mn:00007025                 lea     eax, [ebp+var_1]
.text$mn:00007028                 push    eax
.text$mn:00007029                 mov     ecx, [ebp+var_10]
.text$mn:0000702C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00007031                 mov     ecx, eax
.text$mn:00007033                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00007038                 mov     [ebp+var_8], eax
.text$mn:0000703B                 cmp     [ebp+var_8], 1
.text$mn:0000703F                 ja      short loc_704A
.text$mn:00007041                 mov     [ebp+var_C], 1
.text$mn:00007048                 jmp     short loc_7053
.text$mn:0000704A ; ---------------------------------------------------------------------------
.text$mn:0000704A
.text$mn:0000704A loc_704A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000704A                 mov     ecx, [ebp+var_8]
.text$mn:0000704D                 sub     ecx, 1
.text$mn:00007050                 mov     [ebp+var_C], ecx
.text$mn:00007053
.text$mn:00007053 loc_7053:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00007053                 mov     eax, [ebp+var_C]
.text$mn:00007056                 mov     esp, ebp
.text$mn:00007058                 pop     ebp
.text$mn:00007059                 retn
.text$mn:00007059 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00007059
.text$mn:00007059 ; ---------------------------------------------------------------------------
.text$mn:0000705A                 align 4
.text$mn:0000705A _text$mn        ends
.text$mn:0000705A
.text$mn:0000705C ; ===========================================================================
.text$mn:0000705C
.text$mn:0000705C ; Segment type: Pure code
.text$mn:0000705C ; Segment permissions: Read/Execute
.text$mn:0000705C _text$mn        segment para public 'CODE' use32
.text$mn:0000705C                 assume cs:_text$mn
.text$mn:0000705C                 ;org 705Ch
.text$mn:0000705C ; COMDAT (pick any)
.text$mn:0000705C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000705C
.text$mn:0000705C ; =============== S U B R O U T I N E =======================================
.text$mn:0000705C
.text$mn:0000705C ; Attributes: bp-based frame
.text$mn:0000705C
.text$mn:0000705C ; public: unsigned int __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::max_size(void)const
.text$mn:0000705C                 public ?max_size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ
.text$mn:0000705C ?max_size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:0000705C                                         ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Grow_to(uint)+17p
.text$mn:0000705C                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)+18p
.text$mn:0000705C
.text$mn:0000705C var_8           = dword ptr -8
.text$mn:0000705C var_1           = byte ptr -1
.text$mn:0000705C
.text$mn:0000705C                 push    ebp
.text$mn:0000705D                 mov     ebp, esp
.text$mn:0000705F                 sub     esp, 8
.text$mn:00007062                 mov     [ebp+var_8], ecx
.text$mn:00007065                 lea     eax, [ebp+var_1]
.text$mn:00007068                 push    eax
.text$mn:00007069                 mov     ecx, [ebp+var_8]
.text$mn:0000706C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:00007071                 mov     ecx, eax
.text$mn:00007073                 call    ?max_size@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<UserCommand>>::max_size(void)
.text$mn:00007078                 mov     esp, ebp
.text$mn:0000707A                 pop     ebp
.text$mn:0000707B                 retn
.text$mn:0000707B ?max_size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ endp
.text$mn:0000707B
.text$mn:0000707B _text$mn        ends
.text$mn:0000707B
.text$mn:0000707C ; ===========================================================================
.text$mn:0000707C
.text$mn:0000707C ; Segment type: Pure code
.text$mn:0000707C ; Segment permissions: Read/Execute
.text$mn:0000707C _text$mn        segment para public 'CODE' use32
.text$mn:0000707C                 assume cs:_text$mn
.text$mn:0000707C                 ;org 707Ch
.text$mn:0000707C ; COMDAT (pick any)
.text$mn:0000707C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000707C
.text$mn:0000707C ; =============== S U B R O U T I N E =======================================
.text$mn:0000707C
.text$mn:0000707C ; Attributes: bp-based frame
.text$mn:0000707C
.text$mn:0000707C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000707C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000707C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000707C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000707C                                         ; DATA XREF: .rdata:00008FC4o
.text$mn:0000707C
.text$mn:0000707C var_1C          = dword ptr -1Ch
.text$mn:0000707C var_18          = dword ptr -18h
.text$mn:0000707C Str             = dword ptr -14h
.text$mn:0000707C var_10          = dword ptr -10h
.text$mn:0000707C var_C           = dword ptr -0Ch
.text$mn:0000707C var_4           = dword ptr -4
.text$mn:0000707C arg_0           = dword ptr  8
.text$mn:0000707C arg_4           = dword ptr  0Ch
.text$mn:0000707C
.text$mn:0000707C                 push    ebp
.text$mn:0000707D                 mov     ebp, esp
.text$mn:0000707F                 push    0FFFFFFFFh
.text$mn:00007081                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007086                 mov     eax, large fs:0
.text$mn:0000708C                 push    eax
.text$mn:0000708D                 sub     esp, 10h
.text$mn:00007090                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007095                 xor     eax, ebp
.text$mn:00007097                 push    eax
.text$mn:00007098                 lea     eax, [ebp+var_C]
.text$mn:0000709B                 mov     large fs:0, eax
.text$mn:000070A1                 mov     [ebp+var_1C], ecx
.text$mn:000070A4                 mov     [ebp+var_18], 0
.text$mn:000070AB                 mov     eax, [ebp+arg_4]
.text$mn:000070AE                 push    eax             ; int
.text$mn:000070AF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000070B4                 add     esp, 4
.text$mn:000070B7                 mov     [ebp+var_10], eax
.text$mn:000070BA                 cmp     [ebp+var_10], 0
.text$mn:000070BE                 jz      short loc_70C8
.text$mn:000070C0                 mov     ecx, [ebp+var_10]
.text$mn:000070C3                 mov     [ebp+Str], ecx
.text$mn:000070C6                 jmp     short loc_70CF
.text$mn:000070C8 ; ---------------------------------------------------------------------------
.text$mn:000070C8
.text$mn:000070C8 loc_70C8:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000070C8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000070CF
.text$mn:000070CF loc_70CF:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000070CF                 mov     edx, [ebp+Str]
.text$mn:000070D2                 push    edx             ; Str
.text$mn:000070D3                 mov     ecx, [ebp+arg_0]
.text$mn:000070D6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000070DB                 mov     [ebp+var_4], 0
.text$mn:000070E2                 mov     eax, [ebp+var_18]
.text$mn:000070E5                 or      eax, 1
.text$mn:000070E8                 mov     [ebp+var_18], eax
.text$mn:000070EB                 mov     eax, [ebp+arg_0]
.text$mn:000070EE                 mov     ecx, [ebp+var_C]
.text$mn:000070F1                 mov     large fs:0, ecx
.text$mn:000070F8                 pop     ecx
.text$mn:000070F9                 mov     esp, ebp
.text$mn:000070FB                 pop     ebp
.text$mn:000070FC                 retn    8
.text$mn:000070FC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000070FC
.text$mn:000070FC ; ---------------------------------------------------------------------------
.text$mn:000070FF                 align 10h
.text$mn:000070FF _text$mn        ends
.text$mn:000070FF
.text$x:00007100 ; ===========================================================================
.text$x:00007100
.text$x:00007100 ; Segment type: Pure code
.text$x:00007100 ; Segment permissions: Read/Execute
.text$x:00007100 _text$x         segment para public 'CODE' use32
.text$x:00007100                 assume cs:_text$x
.text$x:00007100                 ;org 7100h
.text$x:00007100 ; COMDAT (pick associative to section at 707C)
.text$x:00007100                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007100
.text$x:00007100 ; =============== S U B R O U T I N E =======================================
.text$x:00007100
.text$x:00007100
.text$x:00007100 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00007100                                         ; DATA XREF: .xdata$x:000082CCo
.text$x:00007100                 mov     eax, [ebp-18h]
.text$x:00007103                 and     eax, 1
.text$x:00007106                 jz      $LN6
.text$x:0000710C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00007110                 mov     ecx, [ebp+8]
.text$x:00007113                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00007118 ; ---------------------------------------------------------------------------
.text$x:00007118
.text$x:00007118 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00007118                 retn
.text$x:00007118 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00007118
.text$x:00007119
.text$x:00007119 ; =============== S U B R O U T I N E =======================================
.text$x:00007119
.text$x:00007119
.text$x:00007119 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00007119                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00007119
.text$x:00007119 arg_4           = dword ptr  8
.text$x:00007119
.text$x:00007119                 mov     edx, [esp+arg_4]
.text$x:0000711D                 lea     eax, [edx+0Ch]
.text$x:00007120                 mov     ecx, [edx-14h]
.text$x:00007123                 xor     ecx, eax
.text$x:00007125                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000712A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000712F                 jmp     ___CxxFrameHandler3
.text$x:0000712F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000712F
.text$x:0000712F _text$x         ends
.text$x:0000712F
.text$mn:00007134 ; ===========================================================================
.text$mn:00007134
.text$mn:00007134 ; Segment type: Pure code
.text$mn:00007134 ; Segment permissions: Read/Execute
.text$mn:00007134 _text$mn        segment para public 'CODE' use32
.text$mn:00007134                 assume cs:_text$mn
.text$mn:00007134                 ;org 7134h
.text$mn:00007134 ; COMDAT (pick any)
.text$mn:00007134                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007134
.text$mn:00007134 ; =============== S U B R O U T I N E =======================================
.text$mn:00007134
.text$mn:00007134 ; Attributes: bp-based frame
.text$mn:00007134
.text$mn:00007134 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00007134                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007134 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00007134                                         ; DATA XREF: .rdata:00008FF8o
.text$mn:00007134
.text$mn:00007134 var_14          = dword ptr -14h
.text$mn:00007134 var_10          = dword ptr -10h
.text$mn:00007134 var_C           = dword ptr -0Ch
.text$mn:00007134 var_4           = dword ptr -4
.text$mn:00007134 arg_0           = dword ptr  8
.text$mn:00007134 arg_4           = dword ptr  0Ch
.text$mn:00007134
.text$mn:00007134                 push    ebp
.text$mn:00007135                 mov     ebp, esp
.text$mn:00007137                 push    0FFFFFFFFh
.text$mn:00007139                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000713E                 mov     eax, large fs:0
.text$mn:00007144                 push    eax
.text$mn:00007145                 sub     esp, 8
.text$mn:00007148                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000714D                 xor     eax, ebp
.text$mn:0000714F                 push    eax
.text$mn:00007150                 lea     eax, [ebp+var_C]
.text$mn:00007153                 mov     large fs:0, eax
.text$mn:00007159                 mov     [ebp+var_14], ecx
.text$mn:0000715C                 mov     [ebp+var_10], 0
.text$mn:00007163                 cmp     [ebp+arg_4], 1
.text$mn:00007167                 jnz     short loc_718D
.text$mn:00007169                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000716E                 mov     ecx, [ebp+arg_0]
.text$mn:00007171                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00007176                 mov     [ebp+var_4], 0
.text$mn:0000717D                 mov     eax, [ebp+var_10]
.text$mn:00007180                 or      eax, 1
.text$mn:00007183                 mov     [ebp+var_10], eax
.text$mn:00007186                 mov     eax, [ebp+arg_0]
.text$mn:00007189                 jmp     short loc_71B0
.text$mn:0000718B ; ---------------------------------------------------------------------------
.text$mn:0000718B                 jmp     short loc_71B0
.text$mn:0000718D ; ---------------------------------------------------------------------------
.text$mn:0000718D
.text$mn:0000718D loc_718D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000718D                 mov     ecx, [ebp+arg_4]
.text$mn:00007190                 push    ecx
.text$mn:00007191                 mov     edx, [ebp+arg_0]
.text$mn:00007194                 push    edx
.text$mn:00007195                 mov     ecx, [ebp+var_14]
.text$mn:00007198                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000719D                 mov     [ebp+var_4], 0
.text$mn:000071A4                 mov     eax, [ebp+var_10]
.text$mn:000071A7                 or      eax, 1
.text$mn:000071AA                 mov     [ebp+var_10], eax
.text$mn:000071AD                 mov     eax, [ebp+arg_0]
.text$mn:000071B0
.text$mn:000071B0 loc_71B0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000071B0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000071B0                 mov     ecx, [ebp+var_C]
.text$mn:000071B3                 mov     large fs:0, ecx
.text$mn:000071BA                 pop     ecx
.text$mn:000071BB                 mov     esp, ebp
.text$mn:000071BD                 pop     ebp
.text$mn:000071BE                 retn    8
.text$mn:000071BE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000071BE
.text$mn:000071BE ; ---------------------------------------------------------------------------
.text$mn:000071C1                 align 4
.text$mn:000071C1 _text$mn        ends
.text$mn:000071C1
.text$x:000071C4 ; ===========================================================================
.text$x:000071C4
.text$x:000071C4 ; Segment type: Pure code
.text$x:000071C4 ; Segment permissions: Read/Execute
.text$x:000071C4 _text$x         segment para public 'CODE' use32
.text$x:000071C4                 assume cs:_text$x
.text$x:000071C4                 ;org 71C4h
.text$x:000071C4 ; COMDAT (pick associative to section at 7134)
.text$x:000071C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000071C4
.text$x:000071C4 ; =============== S U B R O U T I N E =======================================
.text$x:000071C4
.text$x:000071C4
.text$x:000071C4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000071C4                                         ; DATA XREF: .xdata$x:00008350o
.text$x:000071C4                 mov     eax, [ebp-10h]
.text$x:000071C7                 and     eax, 1
.text$x:000071CA                 jz      $LN6_0
.text$x:000071D0                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000071D4                 mov     ecx, [ebp+8]
.text$x:000071D7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000071DC ; ---------------------------------------------------------------------------
.text$x:000071DC
.text$x:000071DC $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000071DC                 retn
.text$x:000071DC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000071DC
.text$x:000071DD
.text$x:000071DD ; =============== S U B R O U T I N E =======================================
.text$x:000071DD
.text$x:000071DD
.text$x:000071DD __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000071DD                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000071DD
.text$x:000071DD arg_4           = dword ptr  8
.text$x:000071DD
.text$x:000071DD                 mov     edx, [esp+arg_4]
.text$x:000071E1                 lea     eax, [edx+0Ch]
.text$x:000071E4                 mov     ecx, [edx-0Ch]
.text$x:000071E7                 xor     ecx, eax
.text$x:000071E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000071EE                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000071F3                 jmp     ___CxxFrameHandler3
.text$x:000071F3 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000071F3
.text$x:000071F3 _text$x         ends
.text$x:000071F3
.text$mn:000071F8 ; ===========================================================================
.text$mn:000071F8
.text$mn:000071F8 ; Segment type: Pure code
.text$mn:000071F8 ; Segment permissions: Read/Execute
.text$mn:000071F8 _text$mn        segment para public 'CODE' use32
.text$mn:000071F8                 assume cs:_text$mn
.text$mn:000071F8                 ;org 71F8h
.text$mn:000071F8 ; COMDAT (pick any)
.text$mn:000071F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000071F8
.text$mn:000071F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000071F8
.text$mn:000071F8 ; Attributes: bp-based frame
.text$mn:000071F8
.text$mn:000071F8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000071F8                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000071F8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000071F8                                         ; DATA XREF: .rdata:00009038o
.text$mn:000071F8
.text$mn:000071F8 var_1C          = dword ptr -1Ch
.text$mn:000071F8 var_18          = dword ptr -18h
.text$mn:000071F8 Str             = dword ptr -14h
.text$mn:000071F8 var_10          = dword ptr -10h
.text$mn:000071F8 var_C           = dword ptr -0Ch
.text$mn:000071F8 var_4           = dword ptr -4
.text$mn:000071F8 arg_0           = dword ptr  8
.text$mn:000071F8 arg_4           = dword ptr  0Ch
.text$mn:000071F8
.text$mn:000071F8                 push    ebp
.text$mn:000071F9                 mov     ebp, esp
.text$mn:000071FB                 push    0FFFFFFFFh
.text$mn:000071FD                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00007202                 mov     eax, large fs:0
.text$mn:00007208                 push    eax
.text$mn:00007209                 sub     esp, 10h
.text$mn:0000720C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007211                 xor     eax, ebp
.text$mn:00007213                 push    eax
.text$mn:00007214                 lea     eax, [ebp+var_C]
.text$mn:00007217                 mov     large fs:0, eax
.text$mn:0000721D                 mov     [ebp+var_1C], ecx
.text$mn:00007220                 mov     [ebp+var_18], 0
.text$mn:00007227                 mov     eax, [ebp+arg_4]
.text$mn:0000722A                 push    eax             ; int
.text$mn:0000722B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00007230                 add     esp, 4
.text$mn:00007233                 mov     [ebp+var_10], eax
.text$mn:00007236                 cmp     [ebp+var_10], 0
.text$mn:0000723A                 jz      short loc_7244
.text$mn:0000723C                 mov     ecx, [ebp+var_10]
.text$mn:0000723F                 mov     [ebp+Str], ecx
.text$mn:00007242                 jmp     short loc_724B
.text$mn:00007244 ; ---------------------------------------------------------------------------
.text$mn:00007244
.text$mn:00007244 loc_7244:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00007244                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000724B
.text$mn:0000724B loc_724B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000724B                 mov     edx, [ebp+Str]
.text$mn:0000724E                 push    edx             ; Str
.text$mn:0000724F                 mov     ecx, [ebp+arg_0]
.text$mn:00007252                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00007257                 mov     [ebp+var_4], 0
.text$mn:0000725E                 mov     eax, [ebp+var_18]
.text$mn:00007261                 or      eax, 1
.text$mn:00007264                 mov     [ebp+var_18], eax
.text$mn:00007267                 mov     eax, [ebp+arg_0]
.text$mn:0000726A                 mov     ecx, [ebp+var_C]
.text$mn:0000726D                 mov     large fs:0, ecx
.text$mn:00007274                 pop     ecx
.text$mn:00007275                 mov     esp, ebp
.text$mn:00007277                 pop     ebp
.text$mn:00007278                 retn    8
.text$mn:00007278 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00007278
.text$mn:00007278 ; ---------------------------------------------------------------------------
.text$mn:0000727B                 align 4
.text$mn:0000727B _text$mn        ends
.text$mn:0000727B
.text$x:0000727C ; ===========================================================================
.text$x:0000727C
.text$x:0000727C ; Segment type: Pure code
.text$x:0000727C ; Segment permissions: Read/Execute
.text$x:0000727C _text$x         segment para public 'CODE' use32
.text$x:0000727C                 assume cs:_text$x
.text$x:0000727C                 ;org 727Ch
.text$x:0000727C ; COMDAT (pick associative to section at 71F8)
.text$x:0000727C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000727C
.text$x:0000727C ; =============== S U B R O U T I N E =======================================
.text$x:0000727C
.text$x:0000727C
.text$x:0000727C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000727C                                         ; DATA XREF: .xdata$x:000083D4o
.text$x:0000727C                 mov     eax, [ebp-18h]
.text$x:0000727F                 and     eax, 1
.text$x:00007282                 jz      $LN6_1
.text$x:00007288                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000728C                 mov     ecx, [ebp+8]
.text$x:0000728F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00007294 ; ---------------------------------------------------------------------------
.text$x:00007294
.text$x:00007294 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00007294                 retn
.text$x:00007294 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00007294
.text$x:00007295
.text$x:00007295 ; =============== S U B R O U T I N E =======================================
.text$x:00007295
.text$x:00007295
.text$x:00007295 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00007295                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00007295
.text$x:00007295 arg_4           = dword ptr  8
.text$x:00007295
.text$x:00007295                 mov     edx, [esp+arg_4]
.text$x:00007299                 lea     eax, [edx+0Ch]
.text$x:0000729C                 mov     ecx, [edx-14h]
.text$x:0000729F                 xor     ecx, eax
.text$x:000072A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000072A6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000072AB                 jmp     ___CxxFrameHandler3
.text$x:000072AB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000072AB
.text$x:000072AB _text$x         ends
.text$x:000072AB
.text$mn:000072B0 ; ===========================================================================
.text$mn:000072B0
.text$mn:000072B0 ; Segment type: Pure code
.text$mn:000072B0 ; Segment permissions: Read/Execute
.text$mn:000072B0 _text$mn        segment para public 'CODE' use32
.text$mn:000072B0                 assume cs:_text$mn
.text$mn:000072B0                 ;org 72B0h
.text$mn:000072B0 ; COMDAT (pick any)
.text$mn:000072B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000072B0
.text$mn:000072B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000072B0
.text$mn:000072B0 ; Attributes: bp-based frame
.text$mn:000072B0
.text$mn:000072B0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000072B0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000072B0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000072B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000072B0
.text$mn:000072B0 var_4           = dword ptr -4
.text$mn:000072B0 Dst             = dword ptr  8
.text$mn:000072B0 Src             = dword ptr  0Ch
.text$mn:000072B0 Size            = dword ptr  10h
.text$mn:000072B0
.text$mn:000072B0                 push    ebp
.text$mn:000072B1                 mov     ebp, esp
.text$mn:000072B3                 push    ecx
.text$mn:000072B4                 cmp     [ebp+Size], 0
.text$mn:000072B8                 jnz     short loc_72C2
.text$mn:000072BA                 mov     eax, [ebp+Dst]
.text$mn:000072BD                 mov     [ebp+var_4], eax
.text$mn:000072C0                 jmp     short loc_72D9
.text$mn:000072C2 ; ---------------------------------------------------------------------------
.text$mn:000072C2
.text$mn:000072C2 loc_72C2:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000072C2                 mov     ecx, [ebp+Size]
.text$mn:000072C5                 push    ecx             ; Size
.text$mn:000072C6                 mov     edx, [ebp+Src]
.text$mn:000072C9                 push    edx             ; Src
.text$mn:000072CA                 mov     eax, [ebp+Dst]
.text$mn:000072CD                 push    eax             ; Dst
.text$mn:000072CE                 call    _memmove
.text$mn:000072D3                 add     esp, 0Ch
.text$mn:000072D6                 mov     [ebp+var_4], eax
.text$mn:000072D9
.text$mn:000072D9 loc_72D9:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000072D9                 mov     eax, [ebp+var_4]
.text$mn:000072DC                 mov     esp, ebp
.text$mn:000072DE                 pop     ebp
.text$mn:000072DF                 retn
.text$mn:000072DF ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000072DF
.text$mn:000072DF _text$mn        ends
.text$mn:000072DF
.text$mn:000072E0 ; ===========================================================================
.text$mn:000072E0
.text$mn:000072E0 ; Segment type: Pure code
.text$mn:000072E0 ; Segment permissions: Read/Execute
.text$mn:000072E0 _text$mn        segment para public 'CODE' use32
.text$mn:000072E0                 assume cs:_text$mn
.text$mn:000072E0                 ;org 72E0h
.text$mn:000072E0 ; COMDAT (pick any)
.text$mn:000072E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000072E0
.text$mn:000072E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000072E0
.text$mn:000072E0 ; Attributes: bp-based frame
.text$mn:000072E0
.text$mn:000072E0 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:000072E0                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:000072E0 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:000072E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Assign_rv(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)+2Ap
.text$mn:000072E0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p ...
.text$mn:000072E0
.text$mn:000072E0 var_4           = dword ptr -4
.text$mn:000072E0 Dst             = dword ptr  8
.text$mn:000072E0 Src             = dword ptr  0Ch
.text$mn:000072E0 arg_8           = dword ptr  10h
.text$mn:000072E0
.text$mn:000072E0                 push    ebp
.text$mn:000072E1                 mov     ebp, esp
.text$mn:000072E3                 push    ecx
.text$mn:000072E4                 cmp     [ebp+arg_8], 0
.text$mn:000072E8                 jnz     short loc_72F2
.text$mn:000072EA                 mov     eax, [ebp+Dst]
.text$mn:000072ED                 mov     [ebp+var_4], eax
.text$mn:000072F0                 jmp     short loc_7309
.text$mn:000072F2 ; ---------------------------------------------------------------------------
.text$mn:000072F2
.text$mn:000072F2 loc_72F2:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000072F2                 mov     ecx, [ebp+arg_8]
.text$mn:000072F5                 push    ecx             ; int
.text$mn:000072F6                 mov     edx, [ebp+Src]
.text$mn:000072F9                 push    edx             ; Src
.text$mn:000072FA                 mov     eax, [ebp+Dst]
.text$mn:000072FD                 push    eax             ; Dst
.text$mn:000072FE                 call    _wmemmove
.text$mn:00007303                 add     esp, 0Ch
.text$mn:00007306                 mov     [ebp+var_4], eax
.text$mn:00007309
.text$mn:00007309 loc_7309:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00007309                 mov     eax, [ebp+var_4]
.text$mn:0000730C                 mov     esp, ebp
.text$mn:0000730E                 pop     ebp
.text$mn:0000730F                 retn
.text$mn:0000730F ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000730F
.text$mn:0000730F _text$mn        ends
.text$mn:0000730F
.text$mn:00007310 ; ===========================================================================
.text$mn:00007310
.text$mn:00007310 ; Segment type: Pure code
.text$mn:00007310 ; Segment permissions: Read/Execute
.text$mn:00007310 _text$mn        segment para public 'CODE' use32
.text$mn:00007310                 assume cs:_text$mn
.text$mn:00007310                 ;org 7310h
.text$mn:00007310 ; COMDAT (pick any)
.text$mn:00007310                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007310
.text$mn:00007310 ; =============== S U B R O U T I N E =======================================
.text$mn:00007310
.text$mn:00007310 ; Attributes: bp-based frame
.text$mn:00007310
.text$mn:00007310 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00007310                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00007310 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00007310                                         ; DATA XREF: .rdata:00008FC0o
.text$mn:00007310
.text$mn:00007310 var_4           = dword ptr -4
.text$mn:00007310
.text$mn:00007310                 push    ebp
.text$mn:00007311                 mov     ebp, esp
.text$mn:00007313                 push    ecx
.text$mn:00007314                 mov     [ebp+var_4], ecx
.text$mn:00007317                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000731C                 mov     esp, ebp
.text$mn:0000731E                 pop     ebp
.text$mn:0000731F                 retn
.text$mn:0000731F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000731F
.text$mn:0000731F _text$mn        ends
.text$mn:0000731F
.text$mn:00007320 ; ===========================================================================
.text$mn:00007320
.text$mn:00007320 ; Segment type: Pure code
.text$mn:00007320 ; Segment permissions: Read/Execute
.text$mn:00007320 _text$mn        segment para public 'CODE' use32
.text$mn:00007320                 assume cs:_text$mn
.text$mn:00007320                 ;org 7320h
.text$mn:00007320 ; COMDAT (pick any)
.text$mn:00007320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007320
.text$mn:00007320 ; =============== S U B R O U T I N E =======================================
.text$mn:00007320
.text$mn:00007320 ; Attributes: bp-based frame
.text$mn:00007320
.text$mn:00007320 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00007320                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00007320 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00007320                                         ; DATA XREF: .rdata:00008FF4o
.text$mn:00007320
.text$mn:00007320 var_4           = dword ptr -4
.text$mn:00007320
.text$mn:00007320                 push    ebp
.text$mn:00007321                 mov     ebp, esp
.text$mn:00007323                 push    ecx
.text$mn:00007324                 mov     [ebp+var_4], ecx
.text$mn:00007327                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000732C                 mov     esp, ebp
.text$mn:0000732E                 pop     ebp
.text$mn:0000732F                 retn
.text$mn:0000732F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000732F
.text$mn:0000732F _text$mn        ends
.text$mn:0000732F
.text$mn:00007330 ; ===========================================================================
.text$mn:00007330
.text$mn:00007330 ; Segment type: Pure code
.text$mn:00007330 ; Segment permissions: Read/Execute
.text$mn:00007330 _text$mn        segment para public 'CODE' use32
.text$mn:00007330                 assume cs:_text$mn
.text$mn:00007330                 ;org 7330h
.text$mn:00007330 ; COMDAT (pick any)
.text$mn:00007330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007330
.text$mn:00007330 ; =============== S U B R O U T I N E =======================================
.text$mn:00007330
.text$mn:00007330 ; Attributes: bp-based frame
.text$mn:00007330
.text$mn:00007330 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00007330                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00007330 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00007330                                         ; DATA XREF: .rdata:00009034o
.text$mn:00007330
.text$mn:00007330 var_4           = dword ptr -4
.text$mn:00007330
.text$mn:00007330                 push    ebp
.text$mn:00007331                 mov     ebp, esp
.text$mn:00007333                 push    ecx
.text$mn:00007334                 mov     [ebp+var_4], ecx
.text$mn:00007337                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000733C                 mov     esp, ebp
.text$mn:0000733E                 pop     ebp
.text$mn:0000733F                 retn
.text$mn:0000733F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000733F
.text$mn:0000733F _text$mn        ends
.text$mn:0000733F
.text$mn:00007340 ; ===========================================================================
.text$mn:00007340
.text$mn:00007340 ; Segment type: Pure code
.text$mn:00007340 ; Segment permissions: Read/Execute
.text$mn:00007340 _text$mn        segment para public 'CODE' use32
.text$mn:00007340                 assume cs:_text$mn
.text$mn:00007340                 ;org 7340h
.text$mn:00007340 ; COMDAT (pick any)
.text$mn:00007340                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007340
.text$mn:00007340 ; =============== S U B R O U T I N E =======================================
.text$mn:00007340
.text$mn:00007340 ; Attributes: bp-based frame
.text$mn:00007340
.text$mn:00007340 ; public: void __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::push_back(class UserCommand const &)
.text$mn:00007340                 public ?push_back@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEXABVUserCommand@@@Z
.text$mn:00007340 ?push_back@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEXABVUserCommand@@@Z proc near
.text$mn:00007340                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+27Dp
.text$mn:00007340
.text$mn:00007340 var_C           = dword ptr -0Ch
.text$mn:00007340 var_8           = dword ptr -8
.text$mn:00007340 var_2           = byte ptr -2
.text$mn:00007340 var_1           = byte ptr -1
.text$mn:00007340 arg_0           = dword ptr  8
.text$mn:00007340
.text$mn:00007340                 push    ebp
.text$mn:00007341                 mov     ebp, esp
.text$mn:00007343                 sub     esp, 0Ch
.text$mn:00007346                 mov     [ebp+var_8], ecx
.text$mn:00007349                 mov     eax, [ebp+arg_0]
.text$mn:0000734C                 push    eax
.text$mn:0000734D                 call    ??$addressof@$$CBVUserCommand@@@std@@YAPBVUserCommand@@ABV1@@Z ; std::addressof<UserCommand const>(UserCommand const &)
.text$mn:00007352                 add     esp, 4
.text$mn:00007355                 push    eax
.text$mn:00007356                 mov     ecx, [ebp+var_8]
.text$mn:00007359                 call    ?_Inside@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBE_NPBVUserCommand@@@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Inside(UserCommand const *)
.text$mn:0000735E                 movzx   ecx, al
.text$mn:00007361                 test    ecx, ecx
.text$mn:00007363                 jz      loc_73EF
.text$mn:00007369                 mov     edx, [ebp+arg_0]
.text$mn:0000736C                 push    edx
.text$mn:0000736D                 call    ??$addressof@$$CBVUserCommand@@@std@@YAPBVUserCommand@@ABV1@@Z ; std::addressof<UserCommand const>(UserCommand const &)
.text$mn:00007372                 add     esp, 4
.text$mn:00007375                 mov     ecx, [ebp+var_8]
.text$mn:00007378                 sub     eax, [ecx+4]
.text$mn:0000737B                 cdq
.text$mn:0000737C                 mov     ecx, 148h
.text$mn:00007381                 idiv    ecx
.text$mn:00007383                 mov     [ebp+var_C], eax
.text$mn:00007386                 mov     edx, [ebp+var_8]
.text$mn:00007389                 mov     eax, [ebp+var_8]
.text$mn:0000738C                 mov     ecx, [edx+8]
.text$mn:0000738F                 cmp     ecx, [eax+0Ch]
.text$mn:00007392                 jnz     short loc_739E
.text$mn:00007394                 push    1
.text$mn:00007396                 mov     ecx, [ebp+var_8]
.text$mn:00007399                 call    ?_Reserve@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)
.text$mn:0000739E
.text$mn:0000739E loc_739E:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+52j
.text$mn:0000739E                 mov     edx, [ebp+var_8]
.text$mn:000073A1                 mov     eax, [edx+8]
.text$mn:000073A4                 push    eax
.text$mn:000073A5                 mov     ecx, [ebp+var_8]
.text$mn:000073A8                 mov     edx, [ecx+8]
.text$mn:000073AB                 push    edx
.text$mn:000073AC                 mov     ecx, [ebp+var_8]
.text$mn:000073AF                 call    ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)
.text$mn:000073B4                 imul    eax, [ebp+var_C], 148h
.text$mn:000073BB                 mov     ecx, [ebp+var_8]
.text$mn:000073BE                 add     eax, [ecx+4]
.text$mn:000073C1                 push    eax             ; int
.text$mn:000073C2                 mov     edx, [ebp+var_8]
.text$mn:000073C5                 mov     eax, [edx+8]
.text$mn:000073C8                 push    eax             ; void *
.text$mn:000073C9                 lea     ecx, [ebp+var_1]
.text$mn:000073CC                 push    ecx
.text$mn:000073CD                 mov     ecx, [ebp+var_8]
.text$mn:000073D0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:000073D5                 mov     ecx, eax
.text$mn:000073D7                 call    ??$construct@VUserCommand@@AAV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@AAV2@@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand &>(UserCommand *,UserCommand &)
.text$mn:000073DC                 mov     edx, [ebp+var_8]
.text$mn:000073DF                 mov     eax, [edx+8]
.text$mn:000073E2                 add     eax, 148h
.text$mn:000073E7                 mov     ecx, [ebp+var_8]
.text$mn:000073EA                 mov     [ecx+8], eax
.text$mn:000073ED                 jmp     short loc_744D
.text$mn:000073EF ; ---------------------------------------------------------------------------
.text$mn:000073EF
.text$mn:000073EF loc_73EF:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+23j
.text$mn:000073EF                 mov     edx, [ebp+var_8]
.text$mn:000073F2                 mov     eax, [ebp+var_8]
.text$mn:000073F5                 mov     ecx, [edx+8]
.text$mn:000073F8                 cmp     ecx, [eax+0Ch]
.text$mn:000073FB                 jnz     short loc_7407
.text$mn:000073FD                 push    1
.text$mn:000073FF                 mov     ecx, [ebp+var_8]
.text$mn:00007402                 call    ?_Reserve@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Reserve(uint)
.text$mn:00007407
.text$mn:00007407 loc_7407:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+BBj
.text$mn:00007407                 mov     edx, [ebp+var_8]
.text$mn:0000740A                 mov     eax, [edx+8]
.text$mn:0000740D                 push    eax
.text$mn:0000740E                 mov     ecx, [ebp+var_8]
.text$mn:00007411                 mov     edx, [ecx+8]
.text$mn:00007414                 push    edx
.text$mn:00007415                 mov     ecx, [ebp+var_8]
.text$mn:00007418                 call    ?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z ; std::vector<UserCommand,std::allocator<UserCommand>>::_Orphan_range(UserCommand *,UserCommand *)
.text$mn:0000741D                 mov     eax, [ebp+arg_0]
.text$mn:00007420                 push    eax             ; int
.text$mn:00007421                 mov     ecx, [ebp+var_8]
.text$mn:00007424                 mov     edx, [ecx+8]
.text$mn:00007427                 push    edx             ; void *
.text$mn:00007428                 lea     eax, [ebp+var_2]
.text$mn:0000742B                 push    eax
.text$mn:0000742C                 mov     ecx, [ebp+var_8]
.text$mn:0000742F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<UserCommand,std::allocator<UserCommand>>>::_Getal(void)
.text$mn:00007434                 mov     ecx, eax
.text$mn:00007436                 call    ??$construct@VUserCommand@@ABV1@@?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@std@@QAEXPAVUserCommand@@ABV2@@Z ; std::_Wrap_alloc<std::allocator<UserCommand>>::construct<UserCommand,UserCommand const &>(UserCommand *,UserCommand const &)
.text$mn:0000743B                 mov     ecx, [ebp+var_8]
.text$mn:0000743E                 mov     edx, [ecx+8]
.text$mn:00007441                 add     edx, 148h
.text$mn:00007447                 mov     eax, [ebp+var_8]
.text$mn:0000744A                 mov     [eax+8], edx
.text$mn:0000744D
.text$mn:0000744D loc_744D:                               ; CODE XREF: std::vector<UserCommand,std::allocator<UserCommand>>::push_back(UserCommand const &)+ADj
.text$mn:0000744D                 mov     esp, ebp
.text$mn:0000744F                 pop     ebp
.text$mn:00007450                 retn    4
.text$mn:00007450 ?push_back@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QAEXABVUserCommand@@@Z endp
.text$mn:00007450
.text$mn:00007450 ; ---------------------------------------------------------------------------
.text$mn:00007453                 align 4
.text$mn:00007453 _text$mn        ends
.text$mn:00007453
.text$mn:00007454 ; ===========================================================================
.text$mn:00007454
.text$mn:00007454 ; Segment type: Pure code
.text$mn:00007454 ; Segment permissions: Read/Execute
.text$mn:00007454 _text$mn        segment para public 'CODE' use32
.text$mn:00007454                 assume cs:_text$mn
.text$mn:00007454                 ;org 7454h
.text$mn:00007454 ; COMDAT (pick any)
.text$mn:00007454                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007454
.text$mn:00007454 ; =============== S U B R O U T I N E =======================================
.text$mn:00007454
.text$mn:00007454 ; Attributes: bp-based frame
.text$mn:00007454
.text$mn:00007454 ; void __thiscall Window::reSizeTo(Window *this, struct tagRECT *)
.text$mn:00007454                 public ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z
.text$mn:00007454 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:00007454                                         ; DATA XREF: .rdata:00008E74o
.text$mn:00007454                                         ; .rdata:00008EA8o ...
.text$mn:00007454
.text$mn:00007454 var_4           = dword ptr -4
.text$mn:00007454 arg_0           = dword ptr  8
.text$mn:00007454
.text$mn:00007454                 push    ebp
.text$mn:00007455                 mov     ebp, esp
.text$mn:00007457                 push    ecx
.text$mn:00007458                 mov     [ebp+var_4], ecx
.text$mn:0000745B                 push    1               ; bRepaint
.text$mn:0000745D                 mov     eax, [ebp+arg_0]
.text$mn:00007460                 mov     ecx, [eax+0Ch]
.text$mn:00007463                 push    ecx             ; nHeight
.text$mn:00007464                 mov     edx, [ebp+arg_0]
.text$mn:00007467                 mov     eax, [edx+8]
.text$mn:0000746A                 push    eax             ; nWidth
.text$mn:0000746B                 mov     ecx, [ebp+arg_0]
.text$mn:0000746E                 mov     edx, [ecx+4]
.text$mn:00007471                 push    edx             ; Y
.text$mn:00007472                 mov     eax, [ebp+arg_0]
.text$mn:00007475                 mov     ecx, [eax]
.text$mn:00007477                 push    ecx             ; X
.text$mn:00007478                 mov     edx, [ebp+var_4]
.text$mn:0000747B                 mov     eax, [edx+0Ch]
.text$mn:0000747E                 push    eax             ; hWnd
.text$mn:0000747F                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00007485                 push    0
.text$mn:00007487                 mov     ecx, [ebp+var_4]
.text$mn:0000748A                 mov     edx, [ecx]
.text$mn:0000748C                 mov     ecx, [ebp+var_4]
.text$mn:0000748F                 mov     eax, [edx+18h]
.text$mn:00007492                 call    eax
.text$mn:00007494                 mov     esp, ebp
.text$mn:00007496                 pop     ebp
.text$mn:00007497                 retn    4
.text$mn:00007497 ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:00007497
.text$mn:00007497 ; ---------------------------------------------------------------------------
.text$mn:0000749A                 align 4
.text$mn:0000749A _text$mn        ends
.text$mn:0000749A
.text$mn:0000749C ; ===========================================================================
.text$mn:0000749C
.text$mn:0000749C ; Segment type: Pure code
.text$mn:0000749C ; Segment permissions: Read/Execute
.text$mn:0000749C _text$mn        segment para public 'CODE' use32
.text$mn:0000749C                 assume cs:_text$mn
.text$mn:0000749C                 ;org 749Ch
.text$mn:0000749C ; COMDAT (pick any)
.text$mn:0000749C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000749C
.text$mn:0000749C ; =============== S U B R O U T I N E =======================================
.text$mn:0000749C
.text$mn:0000749C ; Attributes: bp-based frame
.text$mn:0000749C
.text$mn:0000749C ; void __thiscall Window::reSizeToWH(Window *this, struct tagRECT *)
.text$mn:0000749C                 public ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z
.text$mn:0000749C ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z proc near
.text$mn:0000749C                                         ; DATA XREF: .rdata:00008E78o
.text$mn:0000749C                                         ; .rdata:00008EACo ...
.text$mn:0000749C
.text$mn:0000749C var_4           = dword ptr -4
.text$mn:0000749C arg_0           = dword ptr  8
.text$mn:0000749C
.text$mn:0000749C                 push    ebp
.text$mn:0000749D                 mov     ebp, esp
.text$mn:0000749F                 push    ecx
.text$mn:000074A0                 mov     [ebp+var_4], ecx
.text$mn:000074A3                 push    1               ; bRepaint
.text$mn:000074A5                 mov     eax, [ebp+arg_0]
.text$mn:000074A8                 mov     ecx, [ebp+arg_0]
.text$mn:000074AB                 mov     edx, [eax+0Ch]
.text$mn:000074AE                 sub     edx, [ecx+4]
.text$mn:000074B1                 push    edx             ; nHeight
.text$mn:000074B2                 mov     eax, [ebp+arg_0]
.text$mn:000074B5                 mov     ecx, [ebp+arg_0]
.text$mn:000074B8                 mov     edx, [eax+8]
.text$mn:000074BB                 sub     edx, [ecx]
.text$mn:000074BD                 push    edx             ; nWidth
.text$mn:000074BE                 mov     eax, [ebp+arg_0]
.text$mn:000074C1                 mov     ecx, [eax+4]
.text$mn:000074C4                 push    ecx             ; Y
.text$mn:000074C5                 mov     edx, [ebp+arg_0]
.text$mn:000074C8                 mov     eax, [edx]
.text$mn:000074CA                 push    eax             ; X
.text$mn:000074CB                 mov     ecx, [ebp+var_4]
.text$mn:000074CE                 mov     edx, [ecx+0Ch]
.text$mn:000074D1                 push    edx             ; hWnd
.text$mn:000074D2                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:000074D8                 push    0
.text$mn:000074DA                 mov     eax, [ebp+var_4]
.text$mn:000074DD                 mov     edx, [eax]
.text$mn:000074DF                 mov     ecx, [ebp+var_4]
.text$mn:000074E2                 mov     eax, [edx+18h]
.text$mn:000074E5                 call    eax
.text$mn:000074E7                 mov     esp, ebp
.text$mn:000074E9                 pop     ebp
.text$mn:000074EA                 retn    4
.text$mn:000074EA ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z endp
.text$mn:000074EA
.text$mn:000074EA ; ---------------------------------------------------------------------------
.text$mn:000074ED                 align 10h
.text$mn:000074ED _text$mn        ends
.text$mn:000074ED
.text$mn:000074F0 ; ===========================================================================
.text$mn:000074F0
.text$mn:000074F0 ; Segment type: Pure code
.text$mn:000074F0 ; Segment permissions: Read/Execute
.text$mn:000074F0 _text$mn        segment para public 'CODE' use32
.text$mn:000074F0                 assume cs:_text$mn
.text$mn:000074F0                 ;org 74F0h
.text$mn:000074F0 ; COMDAT (pick any)
.text$mn:000074F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074F0
.text$mn:000074F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000074F0
.text$mn:000074F0 ; Attributes: bp-based frame
.text$mn:000074F0
.text$mn:000074F0 ; void __thiscall Window::redraw(Window *this, bool)
.text$mn:000074F0                 public ?redraw@Window@@UBEX_N@Z
.text$mn:000074F0 ?redraw@Window@@UBEX_N@Z proc near      ; DATA XREF: .rdata:00008E7Co
.text$mn:000074F0                                         ; .rdata:00008EB0o ...
.text$mn:000074F0
.text$mn:000074F0 var_4           = dword ptr -4
.text$mn:000074F0 arg_0           = byte ptr  8
.text$mn:000074F0
.text$mn:000074F0                 push    ebp
.text$mn:000074F1                 mov     ebp, esp
.text$mn:000074F3                 push    ecx
.text$mn:000074F4                 mov     [ebp+var_4], ecx
.text$mn:000074F7                 push    1               ; bErase
.text$mn:000074F9                 push    0               ; lpRect
.text$mn:000074FB                 mov     eax, [ebp+var_4]
.text$mn:000074FE                 mov     ecx, [eax+0Ch]
.text$mn:00007501                 push    ecx             ; hWnd
.text$mn:00007502                 call    dword ptr ds:__imp__InvalidateRect@12 ; InvalidateRect(x,x,x)
.text$mn:00007508                 movzx   edx, [ebp+arg_0]
.text$mn:0000750C                 test    edx, edx
.text$mn:0000750E                 jz      short loc_751D
.text$mn:00007510                 mov     eax, [ebp+var_4]
.text$mn:00007513                 mov     ecx, [eax+0Ch]
.text$mn:00007516                 push    ecx             ; hWnd
.text$mn:00007517                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:0000751D
.text$mn:0000751D loc_751D:                               ; CODE XREF: Window::redraw(bool)+1Ej
.text$mn:0000751D                 mov     esp, ebp
.text$mn:0000751F                 pop     ebp
.text$mn:00007520                 retn    4
.text$mn:00007520 ?redraw@Window@@UBEX_N@Z endp
.text$mn:00007520
.text$mn:00007520 ; ---------------------------------------------------------------------------
.text$mn:00007523                 align 4
.text$mn:00007523 _text$mn        ends
.text$mn:00007523
.text$mn:00007524 ; ===========================================================================
.text$mn:00007524
.text$mn:00007524 ; Segment type: Pure code
.text$mn:00007524 ; Segment permissions: Read/Execute
.text$mn:00007524 _text$mn        segment para public 'CODE' use32
.text$mn:00007524                 assume cs:_text$mn
.text$mn:00007524                 ;org 7524h
.text$mn:00007524 ; COMDAT (pick any)
.text$mn:00007524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007524
.text$mn:00007524 ; =============== S U B R O U T I N E =======================================
.text$mn:00007524
.text$mn:00007524 ; Attributes: bp-based frame
.text$mn:00007524
.text$mn:00007524 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::replace(unsigned int, unsigned int, class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00007524                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z
.text$mn:00007524 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z proc near
.text$mn:00007524                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+5Bp
.text$mn:00007524
.text$mn:00007524 var_10          = dword ptr -10h
.text$mn:00007524 var_C           = dword ptr -0Ch
.text$mn:00007524 var_8           = dword ptr -8
.text$mn:00007524 var_4           = dword ptr -4
.text$mn:00007524 arg_0           = dword ptr  8
.text$mn:00007524 arg_4           = dword ptr  0Ch
.text$mn:00007524 arg_8           = dword ptr  10h
.text$mn:00007524 arg_C           = dword ptr  14h
.text$mn:00007524 arg_10          = dword ptr  18h
.text$mn:00007524
.text$mn:00007524                 push    ebp
.text$mn:00007525                 mov     ebp, esp
.text$mn:00007527                 sub     esp, 10h
.text$mn:0000752A                 mov     [ebp+var_4], ecx
.text$mn:0000752D                 mov     eax, [ebp+var_4]
.text$mn:00007530                 mov     ecx, [eax+14h]
.text$mn:00007533                 cmp     ecx, [ebp+arg_0]
.text$mn:00007536                 jb      short loc_7545
.text$mn:00007538                 mov     ecx, [ebp+arg_8]
.text$mn:0000753B                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00007540                 cmp     eax, [ebp+arg_C]
.text$mn:00007543                 jnb     short loc_754D
.text$mn:00007545
.text$mn:00007545 loc_7545:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+12j
.text$mn:00007545                 mov     ecx, [ebp+var_4]
.text$mn:00007548                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000754D
.text$mn:0000754D loc_754D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+1Fj
.text$mn:0000754D                 mov     edx, [ebp+var_4]
.text$mn:00007550                 mov     eax, [edx+14h]
.text$mn:00007553                 sub     eax, [ebp+arg_0]
.text$mn:00007556                 cmp     eax, [ebp+arg_4]
.text$mn:00007559                 jnb     short loc_7567
.text$mn:0000755B                 mov     ecx, [ebp+var_4]
.text$mn:0000755E                 mov     edx, [ecx+14h]
.text$mn:00007561                 sub     edx, [ebp+arg_0]
.text$mn:00007564                 mov     [ebp+arg_4], edx
.text$mn:00007567
.text$mn:00007567 loc_7567:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+35j
.text$mn:00007567                 mov     ecx, [ebp+arg_8]
.text$mn:0000756A                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:0000756F                 sub     eax, [ebp+arg_C]
.text$mn:00007572                 mov     [ebp+var_10], eax
.text$mn:00007575                 mov     eax, [ebp+var_10]
.text$mn:00007578                 cmp     eax, [ebp+arg_10]
.text$mn:0000757B                 jnb     short loc_7583
.text$mn:0000757D                 mov     ecx, [ebp+var_10]
.text$mn:00007580                 mov     [ebp+arg_10], ecx
.text$mn:00007583
.text$mn:00007583 loc_7583:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+57j
.text$mn:00007583                 or      edx, 0FFFFFFFFh
.text$mn:00007586                 sub     edx, [ebp+arg_10]
.text$mn:00007589                 mov     eax, [ebp+var_4]
.text$mn:0000758C                 mov     ecx, [eax+14h]
.text$mn:0000758F                 sub     ecx, [ebp+arg_4]
.text$mn:00007592                 cmp     edx, ecx
.text$mn:00007594                 ja      short loc_759E
.text$mn:00007596                 mov     ecx, [ebp+var_4]
.text$mn:00007599                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000759E
.text$mn:0000759E loc_759E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+70j
.text$mn:0000759E                 mov     edx, [ebp+var_4]
.text$mn:000075A1                 mov     eax, [edx+14h]
.text$mn:000075A4                 sub     eax, [ebp+arg_4]
.text$mn:000075A7                 sub     eax, [ebp+arg_0]
.text$mn:000075AA                 mov     [ebp+var_8], eax
.text$mn:000075AD                 mov     ecx, [ebp+var_4]
.text$mn:000075B0                 mov     edx, [ecx+14h]
.text$mn:000075B3                 add     edx, [ebp+arg_10]
.text$mn:000075B6                 sub     edx, [ebp+arg_4]
.text$mn:000075B9                 mov     [ebp+var_C], edx
.text$mn:000075BC                 mov     eax, [ebp+var_4]
.text$mn:000075BF                 mov     ecx, [eax+14h]
.text$mn:000075C2                 cmp     ecx, [ebp+var_C]
.text$mn:000075C5                 jnb     short loc_75D5
.text$mn:000075C7                 push    0
.text$mn:000075C9                 mov     edx, [ebp+var_C]
.text$mn:000075CC                 push    edx
.text$mn:000075CD                 mov     ecx, [ebp+var_4]
.text$mn:000075D0                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:000075D5
.text$mn:000075D5 loc_75D5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+A1j
.text$mn:000075D5                 mov     eax, [ebp+var_4]
.text$mn:000075D8                 cmp     eax, [ebp+arg_8]
.text$mn:000075DB                 jz      short loc_7642
.text$mn:000075DD                 mov     ecx, [ebp+var_8]
.text$mn:000075E0                 push    ecx             ; int
.text$mn:000075E1                 mov     ecx, [ebp+var_4]
.text$mn:000075E4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000075E9                 mov     edx, [ebp+arg_0]
.text$mn:000075EC                 lea     eax, [eax+edx*2]
.text$mn:000075EF                 mov     ecx, [ebp+arg_4]
.text$mn:000075F2                 lea     edx, [eax+ecx*2]
.text$mn:000075F5                 push    edx             ; Src
.text$mn:000075F6                 mov     ecx, [ebp+var_4]
.text$mn:000075F9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000075FE                 mov     ecx, [ebp+arg_0]
.text$mn:00007601                 lea     edx, [eax+ecx*2]
.text$mn:00007604                 mov     eax, [ebp+arg_10]
.text$mn:00007607                 lea     ecx, [edx+eax*2]
.text$mn:0000760A                 push    ecx             ; Dst
.text$mn:0000760B                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00007610                 add     esp, 0Ch
.text$mn:00007613                 mov     edx, [ebp+arg_10]
.text$mn:00007616                 push    edx             ; int
.text$mn:00007617                 mov     ecx, [ebp+arg_8]
.text$mn:0000761A                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000761F                 mov     ecx, [ebp+arg_C]
.text$mn:00007622                 lea     edx, [eax+ecx*2]
.text$mn:00007625                 push    edx             ; Src
.text$mn:00007626                 mov     ecx, [ebp+var_4]
.text$mn:00007629                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000762E                 mov     ecx, [ebp+arg_0]
.text$mn:00007631                 lea     edx, [eax+ecx*2]
.text$mn:00007634                 push    edx             ; Dst
.text$mn:00007635                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:0000763A                 add     esp, 0Ch
.text$mn:0000763D                 jmp     loc_782B
.text$mn:00007642 ; ---------------------------------------------------------------------------
.text$mn:00007642
.text$mn:00007642 loc_7642:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+B7j
.text$mn:00007642                 mov     eax, [ebp+arg_10]
.text$mn:00007645                 cmp     eax, [ebp+arg_4]
.text$mn:00007648                 ja      short loc_76AF
.text$mn:0000764A                 mov     ecx, [ebp+arg_10]
.text$mn:0000764D                 push    ecx             ; int
.text$mn:0000764E                 mov     ecx, [ebp+var_4]
.text$mn:00007651                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007656                 mov     edx, [ebp+arg_C]
.text$mn:00007659                 lea     eax, [eax+edx*2]
.text$mn:0000765C                 push    eax             ; Src
.text$mn:0000765D                 mov     ecx, [ebp+var_4]
.text$mn:00007660                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007665                 mov     ecx, [ebp+arg_0]
.text$mn:00007668                 lea     edx, [eax+ecx*2]
.text$mn:0000766B                 push    edx             ; Dst
.text$mn:0000766C                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00007671                 add     esp, 0Ch
.text$mn:00007674                 mov     eax, [ebp+var_8]
.text$mn:00007677                 push    eax             ; int
.text$mn:00007678                 mov     ecx, [ebp+var_4]
.text$mn:0000767B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007680                 mov     ecx, [ebp+arg_0]
.text$mn:00007683                 lea     edx, [eax+ecx*2]
.text$mn:00007686                 mov     eax, [ebp+arg_4]
.text$mn:00007689                 lea     ecx, [edx+eax*2]
.text$mn:0000768C                 push    ecx             ; Src
.text$mn:0000768D                 mov     ecx, [ebp+var_4]
.text$mn:00007690                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007695                 mov     edx, [ebp+arg_0]
.text$mn:00007698                 lea     eax, [eax+edx*2]
.text$mn:0000769B                 mov     ecx, [ebp+arg_10]
.text$mn:0000769E                 lea     edx, [eax+ecx*2]
.text$mn:000076A1                 push    edx             ; Dst
.text$mn:000076A2                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000076A7                 add     esp, 0Ch
.text$mn:000076AA                 jmp     loc_782B
.text$mn:000076AF ; ---------------------------------------------------------------------------
.text$mn:000076AF
.text$mn:000076AF loc_76AF:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+124j
.text$mn:000076AF                 mov     eax, [ebp+arg_C]
.text$mn:000076B2                 cmp     eax, [ebp+arg_0]
.text$mn:000076B5                 ja      short loc_771C
.text$mn:000076B7                 mov     ecx, [ebp+var_8]
.text$mn:000076BA                 push    ecx             ; int
.text$mn:000076BB                 mov     ecx, [ebp+var_4]
.text$mn:000076BE                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000076C3                 mov     edx, [ebp+arg_0]
.text$mn:000076C6                 lea     eax, [eax+edx*2]
.text$mn:000076C9                 mov     ecx, [ebp+arg_4]
.text$mn:000076CC                 lea     edx, [eax+ecx*2]
.text$mn:000076CF                 push    edx             ; Src
.text$mn:000076D0                 mov     ecx, [ebp+var_4]
.text$mn:000076D3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000076D8                 mov     ecx, [ebp+arg_0]
.text$mn:000076DB                 lea     edx, [eax+ecx*2]
.text$mn:000076DE                 mov     eax, [ebp+arg_10]
.text$mn:000076E1                 lea     ecx, [edx+eax*2]
.text$mn:000076E4                 push    ecx             ; Dst
.text$mn:000076E5                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000076EA                 add     esp, 0Ch
.text$mn:000076ED                 mov     edx, [ebp+arg_10]
.text$mn:000076F0                 push    edx             ; int
.text$mn:000076F1                 mov     ecx, [ebp+var_4]
.text$mn:000076F4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000076F9                 mov     ecx, [ebp+arg_C]
.text$mn:000076FC                 lea     edx, [eax+ecx*2]
.text$mn:000076FF                 push    edx             ; Src
.text$mn:00007700                 mov     ecx, [ebp+var_4]
.text$mn:00007703                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007708                 mov     ecx, [ebp+arg_0]
.text$mn:0000770B                 lea     edx, [eax+ecx*2]
.text$mn:0000770E                 push    edx             ; Dst
.text$mn:0000770F                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00007714                 add     esp, 0Ch
.text$mn:00007717                 jmp     loc_782B
.text$mn:0000771C ; ---------------------------------------------------------------------------
.text$mn:0000771C
.text$mn:0000771C loc_771C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+191j
.text$mn:0000771C                 mov     eax, [ebp+arg_0]
.text$mn:0000771F                 add     eax, [ebp+arg_4]
.text$mn:00007722                 cmp     eax, [ebp+arg_C]
.text$mn:00007725                 ja      short loc_7792
.text$mn:00007727                 mov     ecx, [ebp+var_8]
.text$mn:0000772A                 push    ecx             ; int
.text$mn:0000772B                 mov     ecx, [ebp+var_4]
.text$mn:0000772E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007733                 mov     edx, [ebp+arg_0]
.text$mn:00007736                 lea     eax, [eax+edx*2]
.text$mn:00007739                 mov     ecx, [ebp+arg_4]
.text$mn:0000773C                 lea     edx, [eax+ecx*2]
.text$mn:0000773F                 push    edx             ; Src
.text$mn:00007740                 mov     ecx, [ebp+var_4]
.text$mn:00007743                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007748                 mov     ecx, [ebp+arg_0]
.text$mn:0000774B                 lea     edx, [eax+ecx*2]
.text$mn:0000774E                 mov     eax, [ebp+arg_10]
.text$mn:00007751                 lea     ecx, [edx+eax*2]
.text$mn:00007754                 push    ecx             ; Dst
.text$mn:00007755                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000775A                 add     esp, 0Ch
.text$mn:0000775D                 mov     edx, [ebp+arg_10]
.text$mn:00007760                 push    edx             ; int
.text$mn:00007761                 mov     ecx, [ebp+var_4]
.text$mn:00007764                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007769                 mov     ecx, [ebp+arg_C]
.text$mn:0000776C                 add     ecx, [ebp+arg_10]
.text$mn:0000776F                 sub     ecx, [ebp+arg_4]
.text$mn:00007772                 lea     edx, [eax+ecx*2]
.text$mn:00007775                 push    edx             ; Src
.text$mn:00007776                 mov     ecx, [ebp+var_4]
.text$mn:00007779                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000777E                 mov     ecx, [ebp+arg_0]
.text$mn:00007781                 lea     edx, [eax+ecx*2]
.text$mn:00007784                 push    edx             ; Dst
.text$mn:00007785                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:0000778A                 add     esp, 0Ch
.text$mn:0000778D                 jmp     loc_782B
.text$mn:00007792 ; ---------------------------------------------------------------------------
.text$mn:00007792
.text$mn:00007792 loc_7792:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+201j
.text$mn:00007792                 mov     eax, [ebp+arg_4]
.text$mn:00007795                 push    eax             ; int
.text$mn:00007796                 mov     ecx, [ebp+var_4]
.text$mn:00007799                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:0000779E                 mov     ecx, [ebp+arg_C]
.text$mn:000077A1                 lea     edx, [eax+ecx*2]
.text$mn:000077A4                 push    edx             ; Src
.text$mn:000077A5                 mov     ecx, [ebp+var_4]
.text$mn:000077A8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000077AD                 mov     ecx, [ebp+arg_0]
.text$mn:000077B0                 lea     edx, [eax+ecx*2]
.text$mn:000077B3                 push    edx             ; Dst
.text$mn:000077B4                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000077B9                 add     esp, 0Ch
.text$mn:000077BC                 mov     eax, [ebp+var_8]
.text$mn:000077BF                 push    eax             ; int
.text$mn:000077C0                 mov     ecx, [ebp+var_4]
.text$mn:000077C3                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000077C8                 mov     ecx, [ebp+arg_0]
.text$mn:000077CB                 lea     edx, [eax+ecx*2]
.text$mn:000077CE                 mov     eax, [ebp+arg_4]
.text$mn:000077D1                 lea     ecx, [edx+eax*2]
.text$mn:000077D4                 push    ecx             ; Src
.text$mn:000077D5                 mov     ecx, [ebp+var_4]
.text$mn:000077D8                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000077DD                 mov     edx, [ebp+arg_0]
.text$mn:000077E0                 lea     eax, [eax+edx*2]
.text$mn:000077E3                 mov     ecx, [ebp+arg_10]
.text$mn:000077E6                 lea     edx, [eax+ecx*2]
.text$mn:000077E9                 push    edx             ; Dst
.text$mn:000077EA                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000077EF                 add     esp, 0Ch
.text$mn:000077F2                 mov     eax, [ebp+arg_10]
.text$mn:000077F5                 sub     eax, [ebp+arg_4]
.text$mn:000077F8                 push    eax             ; int
.text$mn:000077F9                 mov     ecx, [ebp+var_4]
.text$mn:000077FC                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007801                 mov     ecx, [ebp+arg_C]
.text$mn:00007804                 lea     edx, [eax+ecx*2]
.text$mn:00007807                 mov     eax, [ebp+arg_10]
.text$mn:0000780A                 lea     ecx, [edx+eax*2]
.text$mn:0000780D                 push    ecx             ; Src
.text$mn:0000780E                 mov     ecx, [ebp+var_4]
.text$mn:00007811                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007816                 mov     edx, [ebp+arg_0]
.text$mn:00007819                 lea     eax, [eax+edx*2]
.text$mn:0000781C                 mov     ecx, [ebp+arg_4]
.text$mn:0000781F                 lea     edx, [eax+ecx*2]
.text$mn:00007822                 push    edx             ; Dst
.text$mn:00007823                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00007828                 add     esp, 0Ch
.text$mn:0000782B
.text$mn:0000782B loc_782B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+119j
.text$mn:0000782B                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+186j ...
.text$mn:0000782B                 mov     eax, [ebp+var_C]
.text$mn:0000782E                 push    eax
.text$mn:0000782F                 mov     ecx, [ebp+var_4]
.text$mn:00007832                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00007837                 mov     eax, [ebp+var_4]
.text$mn:0000783A                 mov     esp, ebp
.text$mn:0000783C                 pop     ebp
.text$mn:0000783D                 retn    14h
.text$mn:0000783D ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z endp
.text$mn:0000783D
.text$mn:0000783D _text$mn        ends
.text$mn:0000783D
.text$mn:00007840 ; ===========================================================================
.text$mn:00007840
.text$mn:00007840 ; Segment type: Pure code
.text$mn:00007840 ; Segment permissions: Read/Execute
.text$mn:00007840 _text$mn        segment para public 'CODE' use32
.text$mn:00007840                 assume cs:_text$mn
.text$mn:00007840                 ;org 7840h
.text$mn:00007840 ; COMDAT (pick any)
.text$mn:00007840                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007840
.text$mn:00007840 ; =============== S U B R O U T I N E =======================================
.text$mn:00007840
.text$mn:00007840 ; Attributes: bp-based frame
.text$mn:00007840
.text$mn:00007840 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(int, int, void *Src, int)
.text$mn:00007840                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z
.text$mn:00007840 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z proc near
.text$mn:00007840                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+201p
.text$mn:00007840
.text$mn:00007840 var_C           = dword ptr -0Ch
.text$mn:00007840 var_8           = dword ptr -8
.text$mn:00007840 var_4           = dword ptr -4
.text$mn:00007840 arg_0           = dword ptr  8
.text$mn:00007840 arg_4           = dword ptr  0Ch
.text$mn:00007840 Src             = dword ptr  10h
.text$mn:00007840 arg_C           = dword ptr  14h
.text$mn:00007840
.text$mn:00007840                 push    ebp
.text$mn:00007841                 mov     ebp, esp
.text$mn:00007843                 sub     esp, 0Ch
.text$mn:00007846                 mov     [ebp+var_4], ecx
.text$mn:00007849                 cmp     [ebp+arg_C], 0
.text$mn:0000784D                 jz      short loc_7865
.text$mn:0000784F                 push    5A9h            ; unsigned int
.text$mn:00007854                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007859                 mov     eax, [ebp+Src]
.text$mn:0000785C                 push    eax             ; int
.text$mn:0000785D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00007862                 add     esp, 0Ch
.text$mn:00007865
.text$mn:00007865 loc_7865:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+Dj
.text$mn:00007865                 mov     ecx, [ebp+Src]
.text$mn:00007868                 push    ecx
.text$mn:00007869                 mov     ecx, [ebp+var_4]
.text$mn:0000786C                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00007871                 movzx   edx, al
.text$mn:00007874                 test    edx, edx
.text$mn:00007876                 jz      short loc_78A5
.text$mn:00007878                 mov     eax, [ebp+arg_C]
.text$mn:0000787B                 push    eax
.text$mn:0000787C                 mov     ecx, [ebp+var_4]
.text$mn:0000787F                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007884                 mov     ecx, [ebp+Src]
.text$mn:00007887                 sub     ecx, eax
.text$mn:00007889                 sar     ecx, 1
.text$mn:0000788B                 push    ecx
.text$mn:0000788C                 mov     edx, [ebp+var_4]
.text$mn:0000788F                 push    edx
.text$mn:00007890                 mov     eax, [ebp+arg_4]
.text$mn:00007893                 push    eax
.text$mn:00007894                 mov     ecx, [ebp+arg_0]
.text$mn:00007897                 push    ecx
.text$mn:00007898                 mov     ecx, [ebp+var_4]
.text$mn:0000789B                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:000078A0                 jmp     loc_79DA
.text$mn:000078A5 ; ---------------------------------------------------------------------------
.text$mn:000078A5
.text$mn:000078A5 loc_78A5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+36j
.text$mn:000078A5                 mov     edx, [ebp+var_4]
.text$mn:000078A8                 mov     eax, [edx+14h]
.text$mn:000078AB                 cmp     eax, [ebp+arg_0]
.text$mn:000078AE                 jnb     short loc_78B8
.text$mn:000078B0                 mov     ecx, [ebp+var_4]
.text$mn:000078B3                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:000078B8
.text$mn:000078B8 loc_78B8:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+6Ej
.text$mn:000078B8                 mov     ecx, [ebp+var_4]
.text$mn:000078BB                 mov     edx, [ecx+14h]
.text$mn:000078BE                 sub     edx, [ebp+arg_0]
.text$mn:000078C1                 cmp     edx, [ebp+arg_4]
.text$mn:000078C4                 jnb     short loc_78D2
.text$mn:000078C6                 mov     eax, [ebp+var_4]
.text$mn:000078C9                 mov     ecx, [eax+14h]
.text$mn:000078CC                 sub     ecx, [ebp+arg_0]
.text$mn:000078CF                 mov     [ebp+arg_4], ecx
.text$mn:000078D2
.text$mn:000078D2 loc_78D2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+84j
.text$mn:000078D2                 or      edx, 0FFFFFFFFh
.text$mn:000078D5                 sub     edx, [ebp+arg_C]
.text$mn:000078D8                 mov     eax, [ebp+var_4]
.text$mn:000078DB                 mov     ecx, [eax+14h]
.text$mn:000078DE                 sub     ecx, [ebp+arg_4]
.text$mn:000078E1                 cmp     edx, ecx
.text$mn:000078E3                 ja      short loc_78ED
.text$mn:000078E5                 mov     ecx, [ebp+var_4]
.text$mn:000078E8                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:000078ED
.text$mn:000078ED loc_78ED:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+A3j
.text$mn:000078ED                 mov     edx, [ebp+var_4]
.text$mn:000078F0                 mov     eax, [edx+14h]
.text$mn:000078F3                 sub     eax, [ebp+arg_4]
.text$mn:000078F6                 sub     eax, [ebp+arg_0]
.text$mn:000078F9                 mov     [ebp+var_8], eax
.text$mn:000078FC                 mov     ecx, [ebp+arg_C]
.text$mn:000078FF                 cmp     ecx, [ebp+arg_4]
.text$mn:00007902                 jnb     short loc_793A
.text$mn:00007904                 mov     edx, [ebp+var_8]
.text$mn:00007907                 push    edx             ; int
.text$mn:00007908                 mov     ecx, [ebp+var_4]
.text$mn:0000790B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007910                 mov     ecx, [ebp+arg_0]
.text$mn:00007913                 lea     edx, [eax+ecx*2]
.text$mn:00007916                 mov     eax, [ebp+arg_4]
.text$mn:00007919                 lea     ecx, [edx+eax*2]
.text$mn:0000791C                 push    ecx             ; Src
.text$mn:0000791D                 mov     ecx, [ebp+var_4]
.text$mn:00007920                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007925                 mov     edx, [ebp+arg_0]
.text$mn:00007928                 lea     eax, [eax+edx*2]
.text$mn:0000792B                 mov     ecx, [ebp+arg_C]
.text$mn:0000792E                 lea     edx, [eax+ecx*2]
.text$mn:00007931                 push    edx             ; Dst
.text$mn:00007932                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:00007937                 add     esp, 0Ch
.text$mn:0000793A
.text$mn:0000793A loc_793A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+C2j
.text$mn:0000793A                 cmp     [ebp+arg_C], 0
.text$mn:0000793E                 ja      short loc_794A
.text$mn:00007940                 cmp     [ebp+arg_4], 0
.text$mn:00007944                 jbe     loc_79D7
.text$mn:0000794A
.text$mn:0000794A loc_794A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+FEj
.text$mn:0000794A                 mov     eax, [ebp+var_4]
.text$mn:0000794D                 mov     ecx, [eax+14h]
.text$mn:00007950                 add     ecx, [ebp+arg_C]
.text$mn:00007953                 sub     ecx, [ebp+arg_4]
.text$mn:00007956                 mov     [ebp+var_C], ecx
.text$mn:00007959                 push    0
.text$mn:0000795B                 mov     edx, [ebp+var_C]
.text$mn:0000795E                 push    edx
.text$mn:0000795F                 mov     ecx, [ebp+var_4]
.text$mn:00007962                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00007967                 movzx   eax, al
.text$mn:0000796A                 test    eax, eax
.text$mn:0000796C                 jz      short loc_79D7
.text$mn:0000796E                 mov     ecx, [ebp+arg_4]
.text$mn:00007971                 cmp     ecx, [ebp+arg_C]
.text$mn:00007974                 jnb     short loc_79AC
.text$mn:00007976                 mov     edx, [ebp+var_8]
.text$mn:00007979                 push    edx             ; int
.text$mn:0000797A                 mov     ecx, [ebp+var_4]
.text$mn:0000797D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007982                 mov     ecx, [ebp+arg_0]
.text$mn:00007985                 lea     edx, [eax+ecx*2]
.text$mn:00007988                 mov     eax, [ebp+arg_4]
.text$mn:0000798B                 lea     ecx, [edx+eax*2]
.text$mn:0000798E                 push    ecx             ; Src
.text$mn:0000798F                 mov     ecx, [ebp+var_4]
.text$mn:00007992                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00007997                 mov     edx, [ebp+arg_0]
.text$mn:0000799A                 lea     eax, [eax+edx*2]
.text$mn:0000799D                 mov     ecx, [ebp+arg_C]
.text$mn:000079A0                 lea     edx, [eax+ecx*2]
.text$mn:000079A3                 push    edx             ; Dst
.text$mn:000079A4                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000079A9                 add     esp, 0Ch
.text$mn:000079AC
.text$mn:000079AC loc_79AC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+134j
.text$mn:000079AC                 mov     eax, [ebp+arg_C]
.text$mn:000079AF                 push    eax             ; int
.text$mn:000079B0                 mov     ecx, [ebp+Src]
.text$mn:000079B3                 push    ecx             ; Src
.text$mn:000079B4                 mov     ecx, [ebp+var_4]
.text$mn:000079B7                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000079BC                 mov     edx, [ebp+arg_0]
.text$mn:000079BF                 lea     eax, [eax+edx*2]
.text$mn:000079C2                 push    eax             ; Dst
.text$mn:000079C3                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000079C8                 add     esp, 0Ch
.text$mn:000079CB                 mov     ecx, [ebp+var_C]
.text$mn:000079CE                 push    ecx
.text$mn:000079CF                 mov     ecx, [ebp+var_4]
.text$mn:000079D2                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000079D7
.text$mn:000079D7 loc_79D7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+104j
.text$mn:000079D7                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+12Cj
.text$mn:000079D7                 mov     eax, [ebp+var_4]
.text$mn:000079DA
.text$mn:000079DA loc_79DA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)+60j
.text$mn:000079DA                 mov     esp, ebp
.text$mn:000079DC                 pop     ebp
.text$mn:000079DD                 retn    10h
.text$mn:000079DD ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z endp
.text$mn:000079DD
.text$mn:000079DD _text$mn        ends
.text$mn:000079DD
.text$mn:000079E0 ; ===========================================================================
.text$mn:000079E0
.text$mn:000079E0 ; Segment type: Pure code
.text$mn:000079E0 ; Segment permissions: Read/Execute
.text$mn:000079E0 _text$mn        segment para public 'CODE' use32
.text$mn:000079E0                 assume cs:_text$mn
.text$mn:000079E0                 ;org 79E0h
.text$mn:000079E0 ; COMDAT (pick any)
.text$mn:000079E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000079E0
.text$mn:000079E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000079E0
.text$mn:000079E0 ; Attributes: bp-based frame
.text$mn:000079E0
.text$mn:000079E0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::replace(class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_const_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>, class std::_String_iterator<class std::_String_val<struct std::_Simple_types<wchar_t>>>)
.text$mn:000079E0                 public ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.text$mn:000079E0 ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z proc near
.text$mn:000079E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>>(std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+E0p
.text$mn:000079E0
.text$mn:000079E0 var_AC          = byte ptr -0ACh
.text$mn:000079E0 var_A0          = byte ptr -0A0h
.text$mn:000079E0 var_94          = dword ptr -94h
.text$mn:000079E0 var_90          = dword ptr -90h
.text$mn:000079E0 var_8C          = dword ptr -8Ch
.text$mn:000079E0 var_88          = dword ptr -88h
.text$mn:000079E0 var_84          = dword ptr -84h
.text$mn:000079E0 var_80          = dword ptr -80h
.text$mn:000079E0 var_7C          = dword ptr -7Ch
.text$mn:000079E0 var_78          = dword ptr -78h
.text$mn:000079E0 var_74          = dword ptr -74h
.text$mn:000079E0 var_70          = dword ptr -70h
.text$mn:000079E0 var_6C          = dword ptr -6Ch
.text$mn:000079E0 var_68          = dword ptr -68h
.text$mn:000079E0 var_64          = dword ptr -64h
.text$mn:000079E0 var_60          = dword ptr -60h
.text$mn:000079E0 var_5C          = dword ptr -5Ch
.text$mn:000079E0 var_58          = dword ptr -58h
.text$mn:000079E0 var_54          = dword ptr -54h
.text$mn:000079E0 var_50          = dword ptr -50h
.text$mn:000079E0 var_4C          = dword ptr -4Ch
.text$mn:000079E0 var_48          = dword ptr -48h
.text$mn:000079E0 var_44          = dword ptr -44h
.text$mn:000079E0 var_40          = dword ptr -40h
.text$mn:000079E0 var_3C          = dword ptr -3Ch
.text$mn:000079E0 var_38          = dword ptr -38h
.text$mn:000079E0 var_34          = dword ptr -34h
.text$mn:000079E0 var_30          = dword ptr -30h
.text$mn:000079E0 var_2C          = dword ptr -2Ch
.text$mn:000079E0 var_28          = dword ptr -28h
.text$mn:000079E0 var_24          = dword ptr -24h
.text$mn:000079E0 var_20          = dword ptr -20h
.text$mn:000079E0 var_1C          = dword ptr -1Ch
.text$mn:000079E0 var_18          = dword ptr -18h
.text$mn:000079E0 var_14          = dword ptr -14h
.text$mn:000079E0 var_10          = dword ptr -10h
.text$mn:000079E0 var_C           = dword ptr -0Ch
.text$mn:000079E0 var_4           = dword ptr -4
.text$mn:000079E0 arg_0           = byte ptr  8
.text$mn:000079E0 arg_C           = byte ptr  14h
.text$mn:000079E0 arg_18          = byte ptr  20h
.text$mn:000079E0 arg_24          = byte ptr  2Ch
.text$mn:000079E0
.text$mn:000079E0                 push    ebp
.text$mn:000079E1                 mov     ebp, esp
.text$mn:000079E3                 push    0FFFFFFFFh
.text$mn:000079E5                 push    offset __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.text$mn:000079EA                 mov     eax, large fs:0
.text$mn:000079F0                 push    eax
.text$mn:000079F1                 sub     esp, 0A0h
.text$mn:000079F7                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000079FC                 xor     eax, ebp
.text$mn:000079FE                 push    eax
.text$mn:000079FF                 lea     eax, [ebp+var_C]
.text$mn:00007A02                 mov     large fs:0, eax
.text$mn:00007A08                 mov     [ebp+var_10], ecx
.text$mn:00007A0B                 mov     [ebp+var_4], 3
.text$mn:00007A12                 lea     eax, [ebp+arg_24]
.text$mn:00007A15                 push    eax             ; std::_Iterator_base12 *
.text$mn:00007A16                 lea     ecx, [ebp+arg_18]
.text$mn:00007A19                 call    ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator==(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007A1E                 movzx   ecx, al
.text$mn:00007A21                 test    ecx, ecx
.text$mn:00007A23                 jz      loc_7B05
.text$mn:00007A29                 sub     esp, 0Ch
.text$mn:00007A2C                 mov     ecx, esp
.text$mn:00007A2E                 mov     [ebp+var_58], esp
.text$mn:00007A31                 lea     edx, [ebp+arg_0]
.text$mn:00007A34                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007A35                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007A3A                 mov     [ebp+var_54], eax
.text$mn:00007A3D                 mov     eax, [ebp+var_54]
.text$mn:00007A40                 mov     [ebp+var_60], eax
.text$mn:00007A43                 mov     byte ptr [ebp+var_4], 4
.text$mn:00007A47                 sub     esp, 0Ch
.text$mn:00007A4A                 mov     ecx, esp
.text$mn:00007A4C                 mov     [ebp+var_80], esp
.text$mn:00007A4F                 lea     edx, [ebp+arg_C]
.text$mn:00007A52                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007A53                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007A58                 mov     [ebp+var_38], eax
.text$mn:00007A5B                 mov     eax, [ebp+var_38]
.text$mn:00007A5E                 mov     [ebp+var_68], eax
.text$mn:00007A61                 mov     byte ptr [ebp+var_4], 5
.text$mn:00007A65                 mov     byte ptr [ebp+var_4], 3
.text$mn:00007A69                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00007A6E                 add     esp, 18h
.text$mn:00007A71                 mov     [ebp+var_20], eax
.text$mn:00007A74                 mov     ecx, [ebp+var_20]
.text$mn:00007A77                 push    ecx
.text$mn:00007A78                 lea     edx, [ebp+var_A0]
.text$mn:00007A7E                 push    edx
.text$mn:00007A7F                 mov     ecx, [ebp+var_10]
.text$mn:00007A82                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00007A87                 mov     [ebp+var_48], eax
.text$mn:00007A8A                 mov     eax, [ebp+var_48]
.text$mn:00007A8D                 mov     [ebp+var_28], eax
.text$mn:00007A90                 mov     byte ptr [ebp+var_4], 6
.text$mn:00007A94                 sub     esp, 0Ch
.text$mn:00007A97                 mov     ecx, esp
.text$mn:00007A99                 mov     [ebp+var_90], esp
.text$mn:00007A9F                 mov     edx, [ebp+var_28]
.text$mn:00007AA2                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007AA3                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007AA8                 mov     [ebp+var_40], eax
.text$mn:00007AAB                 mov     eax, [ebp+var_40]
.text$mn:00007AAE                 mov     [ebp+var_70], eax
.text$mn:00007AB1                 mov     byte ptr [ebp+var_4], 7
.text$mn:00007AB5                 sub     esp, 0Ch
.text$mn:00007AB8                 mov     ecx, esp
.text$mn:00007ABA                 mov     [ebp+var_88], esp
.text$mn:00007AC0                 lea     edx, [ebp+arg_0]
.text$mn:00007AC3                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007AC4                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007AC9                 mov     [ebp+var_30], eax
.text$mn:00007ACC                 mov     eax, [ebp+var_30]
.text$mn:00007ACF                 mov     [ebp+var_78], eax
.text$mn:00007AD2                 mov     byte ptr [ebp+var_4], 8
.text$mn:00007AD6                 mov     byte ptr [ebp+var_4], 6
.text$mn:00007ADA                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00007ADF                 add     esp, 18h
.text$mn:00007AE2                 mov     [ebp+var_50], eax
.text$mn:00007AE5                 mov     ecx, [ebp+var_50]
.text$mn:00007AE8                 push    ecx
.text$mn:00007AE9                 mov     ecx, [ebp+var_10]
.text$mn:00007AEC                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00007AF1                 mov     byte ptr [ebp+var_4], 3
.text$mn:00007AF5                 lea     ecx, [ebp+var_A0]
.text$mn:00007AFB                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007B00                 jmp     loc_7BF5
.text$mn:00007B05 ; ---------------------------------------------------------------------------
.text$mn:00007B05
.text$mn:00007B05 loc_7B05:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+43j
.text$mn:00007B05                 lea     edx, [ebp+arg_18]
.text$mn:00007B08                 push    edx             ; std::_Iterator_base12 *
.text$mn:00007B09                 lea     ecx, [ebp+arg_24]
.text$mn:00007B0C                 call    ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator-(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007B11                 push    eax             ; int
.text$mn:00007B12                 lea     ecx, [ebp+arg_18]
.text$mn:00007B15                 call    ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEAA_WXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)
.text$mn:00007B1A                 push    eax             ; Src
.text$mn:00007B1B                 sub     esp, 0Ch
.text$mn:00007B1E                 mov     ecx, esp
.text$mn:00007B20                 mov     [ebp+var_94], esp
.text$mn:00007B26                 lea     eax, [ebp+arg_0]
.text$mn:00007B29                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00007B2A                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007B2F                 mov     [ebp+var_18], eax
.text$mn:00007B32                 mov     ecx, [ebp+var_18]
.text$mn:00007B35                 mov     [ebp+var_5C], ecx
.text$mn:00007B38                 mov     byte ptr [ebp+var_4], 9
.text$mn:00007B3C                 sub     esp, 0Ch
.text$mn:00007B3F                 mov     ecx, esp
.text$mn:00007B41                 mov     [ebp+var_64], esp
.text$mn:00007B44                 lea     edx, [ebp+arg_C]
.text$mn:00007B47                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007B48                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007B4D                 mov     [ebp+var_1C], eax
.text$mn:00007B50                 mov     eax, [ebp+var_1C]
.text$mn:00007B53                 mov     [ebp+var_6C], eax
.text$mn:00007B56                 mov     byte ptr [ebp+var_4], 0Ah
.text$mn:00007B5A                 mov     byte ptr [ebp+var_4], 3
.text$mn:00007B5E                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00007B63                 add     esp, 18h
.text$mn:00007B66                 mov     [ebp+var_24], eax
.text$mn:00007B69                 mov     ecx, [ebp+var_24]
.text$mn:00007B6C                 push    ecx             ; int
.text$mn:00007B6D                 lea     edx, [ebp+var_AC]
.text$mn:00007B73                 push    edx
.text$mn:00007B74                 mov     ecx, [ebp+var_10]
.text$mn:00007B77                 call    ?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::begin(void)
.text$mn:00007B7C                 mov     [ebp+var_2C], eax
.text$mn:00007B7F                 mov     eax, [ebp+var_2C]
.text$mn:00007B82                 mov     [ebp+var_34], eax
.text$mn:00007B85                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00007B89                 sub     esp, 0Ch
.text$mn:00007B8C                 mov     ecx, esp
.text$mn:00007B8E                 mov     [ebp+var_74], esp
.text$mn:00007B91                 mov     edx, [ebp+var_34]
.text$mn:00007B94                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007B95                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007B9A                 mov     [ebp+var_3C], eax
.text$mn:00007B9D                 mov     eax, [ebp+var_3C]
.text$mn:00007BA0                 mov     [ebp+var_7C], eax
.text$mn:00007BA3                 mov     byte ptr [ebp+var_4], 0Ch
.text$mn:00007BA7                 sub     esp, 0Ch
.text$mn:00007BAA                 mov     ecx, esp
.text$mn:00007BAC                 mov     [ebp+var_84], esp
.text$mn:00007BB2                 lea     edx, [ebp+arg_0]
.text$mn:00007BB5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00007BB6                 call    ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)
.text$mn:00007BBB                 mov     [ebp+var_44], eax
.text$mn:00007BBE                 mov     eax, [ebp+var_44]
.text$mn:00007BC1                 mov     [ebp+var_8C], eax
.text$mn:00007BC7                 mov     byte ptr [ebp+var_4], 0Dh
.text$mn:00007BCB                 mov     byte ptr [ebp+var_4], 0Bh
.text$mn:00007BCF                 call    ?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Pdif(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)
.text$mn:00007BD4                 add     esp, 18h
.text$mn:00007BD7                 mov     [ebp+var_4C], eax
.text$mn:00007BDA                 mov     ecx, [ebp+var_4C]
.text$mn:00007BDD                 push    ecx             ; int
.text$mn:00007BDE                 mov     ecx, [ebp+var_10]
.text$mn:00007BE1                 call    ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@IIPB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(uint,uint,wchar_t const *,uint)
.text$mn:00007BE6                 mov     byte ptr [ebp+var_4], 3
.text$mn:00007BEA                 lea     ecx, [ebp+var_AC]
.text$mn:00007BF0                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007BF5
.text$mn:00007BF5 loc_7BF5:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+120j
.text$mn:00007BF5                 mov     edx, [ebp+var_10]
.text$mn:00007BF8                 mov     [ebp+var_14], edx
.text$mn:00007BFB                 mov     byte ptr [ebp+var_4], 2
.text$mn:00007BFF                 lea     ecx, [ebp+arg_0]
.text$mn:00007C02                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007C07                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007C0B                 lea     ecx, [ebp+arg_C]
.text$mn:00007C0E                 call    ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007C13                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007C17                 lea     ecx, [ebp+arg_18]
.text$mn:00007C1A                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007C1F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007C26                 lea     ecx, [ebp+arg_24]
.text$mn:00007C29                 call    ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$mn:00007C2E                 mov     eax, [ebp+var_14]
.text$mn:00007C31                 mov     ecx, [ebp+var_C]
.text$mn:00007C34                 mov     large fs:0, ecx
.text$mn:00007C3B                 pop     ecx
.text$mn:00007C3C                 mov     esp, ebp
.text$mn:00007C3E                 pop     ebp
.text$mn:00007C3F                 retn    30h
.text$mn:00007C3F ?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z endp
.text$mn:00007C3F
.text$mn:00007C3F ; ---------------------------------------------------------------------------
.text$mn:00007C42                 align 4
.text$mn:00007C42 _text$mn        ends
.text$mn:00007C42
.text$x:00007C44 ; ===========================================================================
.text$x:00007C44
.text$x:00007C44 ; Segment type: Pure code
.text$x:00007C44 ; Segment permissions: Read/Execute
.text$x:00007C44 _text$x         segment para public 'CODE' use32
.text$x:00007C44                 assume cs:_text$x
.text$x:00007C44                 ;org 7C44h
.text$x:00007C44 ; COMDAT (pick associative to section at 79E0)
.text$x:00007C44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007C44
.text$x:00007C44 ; =============== S U B R O U T I N E =======================================
.text$x:00007C44
.text$x:00007C44
.text$x:00007C44 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$0 proc near
.text$x:00007C44                                         ; DATA XREF: .xdata$x:00008610o
.text$x:00007C44                 lea     ecx, [ebp+2Ch]
.text$x:00007C47                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C47 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$0 endp
.text$x:00007C47
.text$x:00007C4C
.text$x:00007C4C ; =============== S U B R O U T I N E =======================================
.text$x:00007C4C
.text$x:00007C4C
.text$x:00007C4C __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$1 proc near
.text$x:00007C4C                                         ; DATA XREF: .xdata$x:00008618o
.text$x:00007C4C                 lea     ecx, [ebp+20h]
.text$x:00007C4F                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C4F __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$1 endp
.text$x:00007C4F
.text$x:00007C54
.text$x:00007C54 ; =============== S U B R O U T I N E =======================================
.text$x:00007C54
.text$x:00007C54
.text$x:00007C54 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$2 proc near
.text$x:00007C54                                         ; DATA XREF: .xdata$x:00008620o
.text$x:00007C54                 lea     ecx, [ebp+14h]
.text$x:00007C57                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C57 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$2 endp
.text$x:00007C57
.text$x:00007C5C
.text$x:00007C5C ; =============== S U B R O U T I N E =======================================
.text$x:00007C5C
.text$x:00007C5C
.text$x:00007C5C __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$3 proc near
.text$x:00007C5C                                         ; DATA XREF: .xdata$x:00008628o
.text$x:00007C5C                 lea     ecx, [ebp+8]
.text$x:00007C5F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C5F __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$3 endp
.text$x:00007C5F
.text$x:00007C64
.text$x:00007C64 ; =============== S U B R O U T I N E =======================================
.text$x:00007C64
.text$x:00007C64
.text$x:00007C64 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$4 proc near
.text$x:00007C64                                         ; DATA XREF: .xdata$x:00008630o
.text$x:00007C64                 mov     ecx, [ebp-58h]
.text$x:00007C67                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C67 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$4 endp
.text$x:00007C67
.text$x:00007C6C
.text$x:00007C6C ; =============== S U B R O U T I N E =======================================
.text$x:00007C6C
.text$x:00007C6C
.text$x:00007C6C __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$5 proc near
.text$x:00007C6C                                         ; DATA XREF: .xdata$x:00008638o
.text$x:00007C6C                 mov     ecx, [ebp-80h]
.text$x:00007C6F                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C6F __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$5 endp
.text$x:00007C6F
.text$x:00007C74
.text$x:00007C74 ; =============== S U B R O U T I N E =======================================
.text$x:00007C74
.text$x:00007C74
.text$x:00007C74 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$6 proc near
.text$x:00007C74                                         ; DATA XREF: .xdata$x:00008640o
.text$x:00007C74                 lea     ecx, [ebp-0A0h]
.text$x:00007C7A                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C7A __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$6 endp
.text$x:00007C7A
.text$x:00007C7F
.text$x:00007C7F ; =============== S U B R O U T I N E =======================================
.text$x:00007C7F
.text$x:00007C7F
.text$x:00007C7F __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$7 proc near
.text$x:00007C7F                                         ; DATA XREF: .xdata$x:00008648o
.text$x:00007C7F                 mov     ecx, [ebp-90h]
.text$x:00007C85                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C85 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$7 endp
.text$x:00007C85
.text$x:00007C8A
.text$x:00007C8A ; =============== S U B R O U T I N E =======================================
.text$x:00007C8A
.text$x:00007C8A
.text$x:00007C8A __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$8 proc near
.text$x:00007C8A                                         ; DATA XREF: .xdata$x:00008650o
.text$x:00007C8A                 mov     ecx, [ebp-88h]
.text$x:00007C90                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C90 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$8 endp
.text$x:00007C90
.text$x:00007C95
.text$x:00007C95 ; =============== S U B R O U T I N E =======================================
.text$x:00007C95
.text$x:00007C95
.text$x:00007C95 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$9 proc near
.text$x:00007C95                                         ; DATA XREF: .xdata$x:00008658o
.text$x:00007C95                 mov     ecx, [ebp-94h]
.text$x:00007C9B                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007C9B __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$9 endp
.text$x:00007C9B
.text$x:00007CA0
.text$x:00007CA0 ; =============== S U B R O U T I N E =======================================
.text$x:00007CA0
.text$x:00007CA0
.text$x:00007CA0 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$10 proc near
.text$x:00007CA0                                         ; DATA XREF: .xdata$x:00008660o
.text$x:00007CA0                 mov     ecx, [ebp-64h]
.text$x:00007CA3                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007CA3 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$10 endp
.text$x:00007CA3
.text$x:00007CA8
.text$x:00007CA8 ; =============== S U B R O U T I N E =======================================
.text$x:00007CA8
.text$x:00007CA8
.text$x:00007CA8 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$11 proc near
.text$x:00007CA8                                         ; DATA XREF: .xdata$x:00008668o
.text$x:00007CA8                 lea     ecx, [ebp-0ACh]
.text$x:00007CAE                 jmp     ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007CAE __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$11 endp
.text$x:00007CAE
.text$x:00007CB3
.text$x:00007CB3 ; =============== S U B R O U T I N E =======================================
.text$x:00007CB3
.text$x:00007CB3
.text$x:00007CB3 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$12 proc near
.text$x:00007CB3                                         ; DATA XREF: .xdata$x:00008670o
.text$x:00007CB3                 mov     ecx, [ebp-74h]
.text$x:00007CB6                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007CB6 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$12 endp
.text$x:00007CB6
.text$x:00007CBB
.text$x:00007CBB ; =============== S U B R O U T I N E =======================================
.text$x:00007CBB
.text$x:00007CBB
.text$x:00007CBB __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$13 proc near
.text$x:00007CBB                                         ; DATA XREF: .xdata$x:00008678o
.text$x:00007CBB                 mov     ecx, [ebp-84h]
.text$x:00007CC1                 jmp     ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::~_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>(void)
.text$x:00007CC1 __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$13 endp
.text$x:00007CC1
.text$x:00007CC6
.text$x:00007CC6 ; =============== S U B R O U T I N E =======================================
.text$x:00007CC6
.text$x:00007CC6
.text$x:00007CC6 __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z proc near
.text$x:00007CC6                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::replace(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>,std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t>>>)+5o
.text$x:00007CC6
.text$x:00007CC6 arg_4           = dword ptr  8
.text$x:00007CC6
.text$x:00007CC6                 mov     edx, [esp+arg_4]
.text$x:00007CCA                 lea     eax, [edx+0Ch]
.text$x:00007CCD                 mov     ecx, [edx-0A4h]
.text$x:00007CD3                 xor     ecx, eax
.text$x:00007CD5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007CDA                 mov     eax, offset __ehfuncinfo$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.text$x:00007CDF                 jmp     ___CxxFrameHandler3
.text$x:00007CDF __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z endp
.text$x:00007CDF
.text$x:00007CDF _text$x         ends
.text$x:00007CDF
.text$mn:00007CE4 ; ===========================================================================
.text$mn:00007CE4
.text$mn:00007CE4 ; Segment type: Pure code
.text$mn:00007CE4 ; Segment permissions: Read/Execute
.text$mn:00007CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00007CE4                 assume cs:_text$mn
.text$mn:00007CE4                 ;org 7CE4h
.text$mn:00007CE4 ; COMDAT (pick any)
.text$mn:00007CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CE4
.text$mn:00007CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CE4
.text$mn:00007CE4 ; Attributes: bp-based frame
.text$mn:00007CE4
.text$mn:00007CE4 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::reserve(unsigned int)
.text$mn:00007CE4                 public ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00007CE4 ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00007CE4                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Bp
.text$mn:00007CE4
.text$mn:00007CE4 var_8           = dword ptr -8
.text$mn:00007CE4 var_4           = dword ptr -4
.text$mn:00007CE4 arg_0           = dword ptr  8
.text$mn:00007CE4
.text$mn:00007CE4                 push    ebp
.text$mn:00007CE5                 mov     ebp, esp
.text$mn:00007CE7                 sub     esp, 8
.text$mn:00007CEA                 mov     [ebp+var_4], ecx
.text$mn:00007CED                 mov     eax, [ebp+var_4]
.text$mn:00007CF0                 mov     ecx, [eax+14h]
.text$mn:00007CF3                 cmp     ecx, [ebp+arg_0]
.text$mn:00007CF6                 ja      short loc_7D2D
.text$mn:00007CF8                 mov     edx, [ebp+var_4]
.text$mn:00007CFB                 mov     eax, [edx+18h]
.text$mn:00007CFE                 cmp     eax, [ebp+arg_0]
.text$mn:00007D01                 jz      short loc_7D2D
.text$mn:00007D03                 mov     ecx, [ebp+var_4]
.text$mn:00007D06                 mov     edx, [ecx+14h]
.text$mn:00007D09                 mov     [ebp+var_8], edx
.text$mn:00007D0C                 push    1
.text$mn:00007D0E                 mov     eax, [ebp+arg_0]
.text$mn:00007D11                 push    eax
.text$mn:00007D12                 mov     ecx, [ebp+var_4]
.text$mn:00007D15                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00007D1A                 movzx   ecx, al
.text$mn:00007D1D                 test    ecx, ecx
.text$mn:00007D1F                 jz      short loc_7D2D
.text$mn:00007D21                 mov     edx, [ebp+var_8]
.text$mn:00007D24                 push    edx
.text$mn:00007D25                 mov     ecx, [ebp+var_4]
.text$mn:00007D28                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00007D2D
.text$mn:00007D2D loc_7D2D:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::reserve(uint)+12j
.text$mn:00007D2D                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::reserve(uint)+1Dj ...
.text$mn:00007D2D                 mov     esp, ebp
.text$mn:00007D2F                 pop     ebp
.text$mn:00007D30                 retn    4
.text$mn:00007D30 ?reserve@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:00007D30
.text$mn:00007D30 ; ---------------------------------------------------------------------------
.text$mn:00007D33                 align 4
.text$mn:00007D33 _text$mn        ends
.text$mn:00007D33
.text$mn:00007D34 ; ===========================================================================
.text$mn:00007D34
.text$mn:00007D34 ; Segment type: Pure code
.text$mn:00007D34 ; Segment permissions: Read/Execute
.text$mn:00007D34 _text$mn        segment para public 'CODE' use32
.text$mn:00007D34                 assume cs:_text$mn
.text$mn:00007D34                 ;org 7D34h
.text$mn:00007D34 ; COMDAT (pick any)
.text$mn:00007D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D34
.text$mn:00007D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D34
.text$mn:00007D34 ; Attributes: bp-based frame
.text$mn:00007D34
.text$mn:00007D34 ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::select_on_container_copy_construction(void)const
.text$mn:00007D34                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ
.text$mn:00007D34 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00007D34                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+3Ap
.text$mn:00007D34
.text$mn:00007D34 var_8           = dword ptr -8
.text$mn:00007D34 var_1           = byte ptr -1
.text$mn:00007D34 arg_0           = dword ptr  8
.text$mn:00007D34
.text$mn:00007D34                 push    ebp
.text$mn:00007D35                 mov     ebp, esp
.text$mn:00007D37                 sub     esp, 8
.text$mn:00007D3A                 mov     [ebp+var_8], ecx
.text$mn:00007D3D                 mov     eax, [ebp+var_8]
.text$mn:00007D40                 push    eax
.text$mn:00007D41                 lea     ecx, [ebp+var_1]
.text$mn:00007D44                 push    ecx
.text$mn:00007D45                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z ; std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)
.text$mn:00007D4A                 add     esp, 8
.text$mn:00007D4D                 push    eax
.text$mn:00007D4E                 mov     ecx, [ebp+arg_0]
.text$mn:00007D51                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(std::allocator<wchar_t> const &)
.text$mn:00007D56                 mov     eax, [ebp+arg_0]
.text$mn:00007D59                 mov     esp, ebp
.text$mn:00007D5B                 pop     ebp
.text$mn:00007D5C                 retn    4
.text$mn:00007D5C ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBE?AU12@XZ endp
.text$mn:00007D5C
.text$mn:00007D5C ; ---------------------------------------------------------------------------
.text$mn:00007D5F                 align 10h
.text$mn:00007D5F _text$mn        ends
.text$mn:00007D5F
.text$mn:00007D60 ; ===========================================================================
.text$mn:00007D60
.text$mn:00007D60 ; Segment type: Pure code
.text$mn:00007D60 ; Segment permissions: Read/Execute
.text$mn:00007D60 _text$mn        segment para public 'CODE' use32
.text$mn:00007D60                 assume cs:_text$mn
.text$mn:00007D60                 ;org 7D60h
.text$mn:00007D60 ; COMDAT (pick any)
.text$mn:00007D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D60
.text$mn:00007D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D60
.text$mn:00007D60 ; Attributes: bp-based frame
.text$mn:00007D60
.text$mn:00007D60 ; public: class std::allocator<wchar_t> __thiscall std::allocator<wchar_t>::select_on_container_copy_construction(void)const
.text$mn:00007D60                 public ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ
.text$mn:00007D60 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ proc near
.text$mn:00007D60                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::select_on_container_copy_construction(std::allocator<wchar_t> const &)+Ap
.text$mn:00007D60
.text$mn:00007D60 var_4           = dword ptr -4
.text$mn:00007D60 arg_0           = dword ptr  8
.text$mn:00007D60
.text$mn:00007D60                 push    ebp
.text$mn:00007D61                 mov     ebp, esp
.text$mn:00007D63                 push    ecx
.text$mn:00007D64                 mov     [ebp+var_4], ecx
.text$mn:00007D67                 mov     eax, [ebp+var_4]
.text$mn:00007D6A                 push    eax
.text$mn:00007D6B                 mov     ecx, [ebp+arg_0]
.text$mn:00007D6E                 call    ??0?$allocator@_W@std@@QAE@ABV01@@Z ; std::allocator<wchar_t>::allocator<wchar_t>(std::allocator<wchar_t> const &)
.text$mn:00007D73                 mov     eax, [ebp+arg_0]
.text$mn:00007D76                 mov     esp, ebp
.text$mn:00007D78                 pop     ebp
.text$mn:00007D79                 retn    4
.text$mn:00007D79 ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ endp
.text$mn:00007D79
.text$mn:00007D79 _text$mn        ends
.text$mn:00007D79
.text$mn:00007D7C ; ===========================================================================
.text$mn:00007D7C
.text$mn:00007D7C ; Segment type: Pure code
.text$mn:00007D7C ; Segment permissions: Read/Execute
.text$mn:00007D7C _text$mn        segment para public 'CODE' use32
.text$mn:00007D7C                 assume cs:_text$mn
.text$mn:00007D7C                 ;org 7D7Ch
.text$mn:00007D7C ; COMDAT (pick any)
.text$mn:00007D7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D7C
.text$mn:00007D7C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D7C
.text$mn:00007D7C ; Attributes: bp-based frame
.text$mn:00007D7C
.text$mn:00007D7C ; public: static class std::allocator<wchar_t> __cdecl std::allocator_traits<class std::allocator<wchar_t>>::select_on_container_copy_construction(class std::allocator<wchar_t> const &)
.text$mn:00007D7C                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z
.text$mn:00007D7C ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z proc near
.text$mn:00007D7C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::select_on_container_copy_construction(void)+11p
.text$mn:00007D7C
.text$mn:00007D7C arg_0           = dword ptr  8
.text$mn:00007D7C arg_4           = dword ptr  0Ch
.text$mn:00007D7C
.text$mn:00007D7C                 push    ebp
.text$mn:00007D7D                 mov     ebp, esp
.text$mn:00007D7F                 mov     eax, [ebp+arg_0]
.text$mn:00007D82                 push    eax
.text$mn:00007D83                 mov     ecx, [ebp+arg_4]
.text$mn:00007D86                 call    ?select_on_container_copy_construction@?$allocator@_W@std@@QBE?AV12@XZ ; std::allocator<wchar_t>::select_on_container_copy_construction(void)
.text$mn:00007D8B                 mov     eax, [ebp+arg_0]
.text$mn:00007D8E                 pop     ebp
.text$mn:00007D8F                 retn
.text$mn:00007D8F ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@ABV32@@Z endp
.text$mn:00007D8F
.text$mn:00007D8F _text$mn        ends
.text$mn:00007D8F
.text$mn:00007D90 ; ===========================================================================
.text$mn:00007D90
.text$mn:00007D90 ; Segment type: Pure code
.text$mn:00007D90 ; Segment permissions: Read/Execute
.text$mn:00007D90 _text$mn        segment para public 'CODE' use32
.text$mn:00007D90                 assume cs:_text$mn
.text$mn:00007D90                 ;org 7D90h
.text$mn:00007D90 ; COMDAT (pick any)
.text$mn:00007D90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D90
.text$mn:00007D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00007D90
.text$mn:00007D90 ; Attributes: bp-based frame
.text$mn:00007D90
.text$mn:00007D90 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00007D90                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00007D90 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00007D90                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00007D90                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00007D90
.text$mn:00007D90 var_4           = dword ptr -4
.text$mn:00007D90
.text$mn:00007D90                 push    ebp
.text$mn:00007D91                 mov     ebp, esp
.text$mn:00007D93                 push    ecx
.text$mn:00007D94                 mov     [ebp+var_4], ecx
.text$mn:00007D97                 mov     eax, [ebp+var_4]
.text$mn:00007D9A                 mov     eax, [eax+14h]
.text$mn:00007D9D                 mov     esp, ebp
.text$mn:00007D9F                 pop     ebp
.text$mn:00007DA0                 retn
.text$mn:00007DA0 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00007DA0
.text$mn:00007DA0 ; ---------------------------------------------------------------------------
.text$mn:00007DA1                 align 4
.text$mn:00007DA1 _text$mn        ends
.text$mn:00007DA1
.text$mn:00007DA4 ; ===========================================================================
.text$mn:00007DA4
.text$mn:00007DA4 ; Segment type: Pure code
.text$mn:00007DA4 ; Segment permissions: Read/Execute
.text$mn:00007DA4 _text$mn        segment para public 'CODE' use32
.text$mn:00007DA4                 assume cs:_text$mn
.text$mn:00007DA4                 ;org 7DA4h
.text$mn:00007DA4 ; COMDAT (pick any)
.text$mn:00007DA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DA4
.text$mn:00007DA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DA4
.text$mn:00007DA4 ; Attributes: bp-based frame
.text$mn:00007DA4
.text$mn:00007DA4 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00007DA4                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00007DA4 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00007DA4                                         ; CODE XREF: std::operator+<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *,std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+50p
.text$mn:00007DA4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp ...
.text$mn:00007DA4
.text$mn:00007DA4 var_4           = dword ptr -4
.text$mn:00007DA4
.text$mn:00007DA4                 push    ebp
.text$mn:00007DA5                 mov     ebp, esp
.text$mn:00007DA7                 push    ecx
.text$mn:00007DA8                 mov     [ebp+var_4], ecx
.text$mn:00007DAB                 mov     eax, [ebp+var_4]
.text$mn:00007DAE                 mov     eax, [eax+14h]
.text$mn:00007DB1                 mov     esp, ebp
.text$mn:00007DB3                 pop     ebp
.text$mn:00007DB4                 retn
.text$mn:00007DB4 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00007DB4
.text$mn:00007DB4 ; ---------------------------------------------------------------------------
.text$mn:00007DB5                 align 4
.text$mn:00007DB5 _text$mn        ends
.text$mn:00007DB5
.text$mn:00007DB8 ; ===========================================================================
.text$mn:00007DB8
.text$mn:00007DB8 ; Segment type: Pure code
.text$mn:00007DB8 ; Segment permissions: Read/Execute
.text$mn:00007DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00007DB8                 assume cs:_text$mn
.text$mn:00007DB8                 ;org 7DB8h
.text$mn:00007DB8 ; COMDAT (pick any)
.text$mn:00007DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DB8
.text$mn:00007DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DB8
.text$mn:00007DB8 ; Attributes: bp-based frame
.text$mn:00007DB8
.text$mn:00007DB8 ; public: unsigned int __thiscall std::vector<class UserCommand, class std::allocator<class UserCommand>>::size(void)const
.text$mn:00007DB8                 public ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ
.text$mn:00007DB8 ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ proc near
.text$mn:00007DB8                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+15Fp
.text$mn:00007DB8                                         ; std::vector<UserCommand,std::allocator<UserCommand>>::_Reallocate(uint)+A9p ...
.text$mn:00007DB8
.text$mn:00007DB8 var_4           = dword ptr -4
.text$mn:00007DB8
.text$mn:00007DB8                 push    ebp
.text$mn:00007DB9                 mov     ebp, esp
.text$mn:00007DBB                 push    ecx
.text$mn:00007DBC                 mov     [ebp+var_4], ecx
.text$mn:00007DBF                 mov     eax, [ebp+var_4]
.text$mn:00007DC2                 mov     ecx, [ebp+var_4]
.text$mn:00007DC5                 mov     eax, [eax+8]
.text$mn:00007DC8                 sub     eax, [ecx+4]
.text$mn:00007DCB                 cdq
.text$mn:00007DCC                 mov     ecx, 148h
.text$mn:00007DD1                 idiv    ecx
.text$mn:00007DD3                 mov     esp, ebp
.text$mn:00007DD5                 pop     ebp
.text$mn:00007DD6                 retn
.text$mn:00007DD6 ?size@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@QBEIXZ endp
.text$mn:00007DD6
.text$mn:00007DD6 ; ---------------------------------------------------------------------------
.text$mn:00007DD7                 align 4
.text$mn:00007DD7 _text$mn        ends
.text$mn:00007DD7
.text$mn:00007DD8 ; ===========================================================================
.text$mn:00007DD8
.text$mn:00007DD8 ; Segment type: Pure code
.text$mn:00007DD8 ; Segment permissions: Read/Execute
.text$mn:00007DD8 _text$mn        segment para public 'CODE' use32
.text$mn:00007DD8                 assume cs:_text$mn
.text$mn:00007DD8                 ;org 7DD8h
.text$mn:00007DD8 ; COMDAT (pick any)
.text$mn:00007DD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DD8
.text$mn:00007DD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DD8
.text$mn:00007DD8 ; Attributes: bp-based frame
.text$mn:00007DD8
.text$mn:00007DD8 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00007DD8                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00007DD8 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00007DD8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_68E4p
.text$mn:00007DD8                 push    ebp
.text$mn:00007DD9                 mov     ebp, esp
.text$mn:00007DDB                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00007DE0                 pop     ebp
.text$mn:00007DE1                 retn
.text$mn:00007DE1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00007DE1
.text$mn:00007DE1 ; ---------------------------------------------------------------------------
.text$mn:00007DE2                 align 4
.text$mn:00007DE2 _text$mn        ends
.text$mn:00007DE2
.text$mn:00007DE4 ; ===========================================================================
.text$mn:00007DE4
.text$mn:00007DE4 ; Segment type: Pure code
.text$mn:00007DE4 ; Segment permissions: Read/Execute
.text$mn:00007DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00007DE4                 assume cs:_text$mn
.text$mn:00007DE4                 ;org 7DE4h
.text$mn:00007DE4 ; COMDAT (pick any)
.text$mn:00007DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007DE4
.text$mn:00007DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007DE4
.text$mn:00007DE4 ; Attributes: bp-based frame
.text$mn:00007DE4
.text$mn:00007DE4 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall Shortcut::toMenuItemString(void)const
.text$mn:00007DE4                 public ?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$mn:00007DE4 ?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ proc near
.text$mn:00007DE4                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+28Fp
.text$mn:00007DE4
.text$mn:00007DE4 var_58          = dword ptr -58h
.text$mn:00007DE4 var_54          = dword ptr -54h
.text$mn:00007DE4 var_50          = dword ptr -50h
.text$mn:00007DE4 var_4C          = dword ptr -4Ch
.text$mn:00007DE4 var_48          = byte ptr -48h
.text$mn:00007DE4 var_2C          = byte ptr -2Ch
.text$mn:00007DE4 var_10          = dword ptr -10h
.text$mn:00007DE4 var_C           = dword ptr -0Ch
.text$mn:00007DE4 var_4           = dword ptr -4
.text$mn:00007DE4 arg_0           = dword ptr  8
.text$mn:00007DE4
.text$mn:00007DE4                 push    ebp
.text$mn:00007DE5                 mov     ebp, esp
.text$mn:00007DE7                 push    0FFFFFFFFh
.text$mn:00007DE9                 push    offset __ehhandler$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$mn:00007DEE                 mov     eax, large fs:0
.text$mn:00007DF4                 push    eax
.text$mn:00007DF5                 sub     esp, 4Ch
.text$mn:00007DF8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007DFD                 xor     eax, ebp
.text$mn:00007DFF                 mov     [ebp+var_10], eax
.text$mn:00007E02                 push    eax
.text$mn:00007E03                 lea     eax, [ebp+var_C]
.text$mn:00007E06                 mov     large fs:0, eax
.text$mn:00007E0C                 mov     [ebp+var_4C], ecx
.text$mn:00007E0F                 mov     [ebp+var_50], 0
.text$mn:00007E16                 mov     eax, [ebp+var_4C]
.text$mn:00007E19                 add     eax, 0A6h ; 'ª'
.text$mn:00007E1E                 push    eax             ; Str
.text$mn:00007E1F                 lea     ecx, [ebp+var_2C]
.text$mn:00007E22                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00007E27                 mov     [ebp+var_4], 1
.text$mn:00007E2E                 mov     ecx, [ebp+var_4C]
.text$mn:00007E31                 mov     edx, [ecx]
.text$mn:00007E33                 mov     ecx, [ebp+var_4C]
.text$mn:00007E36                 mov     eax, [edx+44h]
.text$mn:00007E39                 call    eax
.text$mn:00007E3B                 movzx   ecx, al
.text$mn:00007E3E                 test    ecx, ecx
.text$mn:00007E40                 jz      short loc_7E85
.text$mn:00007E42                 push    offset ??_C@_13KDLDGPGJ@?$AA?7?$AA?$AA@ ; Str
.text$mn:00007E47                 lea     ecx, [ebp+var_2C]
.text$mn:00007E4A                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(wchar_t const *)
.text$mn:00007E4F                 lea     edx, [ebp+var_48]
.text$mn:00007E52                 push    edx
.text$mn:00007E53                 mov     eax, [ebp+var_4C]
.text$mn:00007E56                 mov     edx, [eax]
.text$mn:00007E58                 mov     ecx, [ebp+var_4C]
.text$mn:00007E5B                 mov     eax, [edx+48h]
.text$mn:00007E5E                 call    eax
.text$mn:00007E60                 mov     [ebp+var_54], eax
.text$mn:00007E63                 mov     ecx, [ebp+var_54]
.text$mn:00007E66                 mov     [ebp+var_58], ecx
.text$mn:00007E69                 mov     byte ptr [ebp+var_4], 2
.text$mn:00007E6D                 mov     edx, [ebp+var_58]
.text$mn:00007E70                 push    edx
.text$mn:00007E71                 lea     ecx, [ebp+var_2C]
.text$mn:00007E74                 call    ??Y?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::operator+=(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)
.text$mn:00007E79                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007E7D                 lea     ecx, [ebp+var_48]
.text$mn:00007E80                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00007E85
.text$mn:00007E85 loc_7E85:                               ; CODE XREF: Shortcut::toMenuItemString(void)+5Cj
.text$mn:00007E85                 lea     eax, [ebp+var_2C]
.text$mn:00007E88                 push    eax
.text$mn:00007E89                 mov     ecx, [ebp+arg_0]
.text$mn:00007E8C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> &&)
.text$mn:00007E91                 mov     ecx, [ebp+var_50]
.text$mn:00007E94                 or      ecx, 1
.text$mn:00007E97                 mov     [ebp+var_50], ecx
.text$mn:00007E9A                 mov     byte ptr [ebp+var_4], 0
.text$mn:00007E9E                 lea     ecx, [ebp+var_2C]
.text$mn:00007EA1                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00007EA6                 mov     eax, [ebp+arg_0]
.text$mn:00007EA9                 mov     ecx, [ebp+var_C]
.text$mn:00007EAC                 mov     large fs:0, ecx
.text$mn:00007EB3                 pop     ecx
.text$mn:00007EB4                 mov     ecx, [ebp+var_10]
.text$mn:00007EB7                 xor     ecx, ebp
.text$mn:00007EB9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00007EBE                 mov     esp, ebp
.text$mn:00007EC0                 pop     ebp
.text$mn:00007EC1                 retn    4
.text$mn:00007EC1 ?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ endp
.text$mn:00007EC1
.text$mn:00007EC1 _text$mn        ends
.text$mn:00007EC1
.text$x:00007EC4 ; ===========================================================================
.text$x:00007EC4
.text$x:00007EC4 ; Segment type: Pure code
.text$x:00007EC4 ; Segment permissions: Read/Execute
.text$x:00007EC4 _text$x         segment para public 'CODE' use32
.text$x:00007EC4                 assume cs:_text$x
.text$x:00007EC4                 ;org 7EC4h
.text$x:00007EC4 ; COMDAT (pick associative to section at 7DE4)
.text$x:00007EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007EC4
.text$x:00007EC4 ; =============== S U B R O U T I N E =======================================
.text$x:00007EC4
.text$x:00007EC4
.text$x:00007EC4 __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0 proc near
.text$x:00007EC4                                         ; DATA XREF: .xdata$x:0000885Co
.text$x:00007EC4                 lea     ecx, [ebp-2Ch]
.text$x:00007EC7                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00007EC7 __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0 endp
.text$x:00007EC7
.text$x:00007ECC
.text$x:00007ECC ; =============== S U B R O U T I N E =======================================
.text$x:00007ECC
.text$x:00007ECC
.text$x:00007ECC __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$1 proc near
.text$x:00007ECC                                         ; DATA XREF: .xdata$x:00008864o
.text$x:00007ECC                 lea     ecx, [ebp-48h]
.text$x:00007ECF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00007ECF __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$1 endp
.text$x:00007ECF
.text$x:00007ED4
.text$x:00007ED4 ; =============== S U B R O U T I N E =======================================
.text$x:00007ED4
.text$x:00007ED4
.text$x:00007ED4 __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$2 proc near
.text$x:00007ED4                                         ; DATA XREF: .xdata$x:00008854o
.text$x:00007ED4                 mov     eax, [ebp-50h]
.text$x:00007ED7                 and     eax, 1
.text$x:00007EDA                 jz      $LN7
.text$x:00007EE0                 and     dword ptr [ebp-50h], 0FFFFFFFEh
.text$x:00007EE4                 mov     ecx, [ebp+8]
.text$x:00007EE7                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00007EEC ; ---------------------------------------------------------------------------
.text$x:00007EEC
.text$x:00007EEC $LN7:                                   ; CODE XREF: __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$2+6j
.text$x:00007EEC                 retn
.text$x:00007EEC __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$2 endp
.text$x:00007EEC
.text$x:00007EED
.text$x:00007EED ; =============== S U B R O U T I N E =======================================
.text$x:00007EED
.text$x:00007EED
.text$x:00007EED __ehhandler$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ proc near
.text$x:00007EED                                         ; DATA XREF: Shortcut::toMenuItemString(void)+5o
.text$x:00007EED
.text$x:00007EED arg_4           = dword ptr  8
.text$x:00007EED
.text$x:00007EED                 mov     edx, [esp+arg_4]
.text$x:00007EF1                 lea     eax, [edx+0Ch]
.text$x:00007EF4                 mov     ecx, [edx-50h]
.text$x:00007EF7                 xor     ecx, eax
.text$x:00007EF9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007EFE                 mov     ecx, [edx-4]
.text$x:00007F01                 xor     ecx, eax
.text$x:00007F03                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007F08                 mov     eax, offset __ehfuncinfo$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.text$x:00007F0D                 jmp     ___CxxFrameHandler3
.text$x:00007F0D __ehhandler$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ endp
.text$x:00007F0D
.text$x:00007F0D ; ---------------------------------------------------------------------------
.text$x:00007F12                 align 4
.text$x:00007F12 _text$x         ends
.text$x:00007F12
.text$mn:00007F14 ; ===========================================================================
.text$mn:00007F14
.text$mn:00007F14 ; Segment type: Pure code
.text$mn:00007F14 ; Segment permissions: Read/Execute
.text$mn:00007F14 _text$mn        segment para public 'CODE' use32
.text$mn:00007F14                 assume cs:_text$mn
.text$mn:00007F14                 ;org 7F14h
.text$mn:00007F14 ; COMDAT (pick any)
.text$mn:00007F14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F14
.text$mn:00007F14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F14
.text$mn:00007F14 ; Attributes: bp-based frame
.text$mn:00007F14
.text$mn:00007F14 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00007F14                 public ?value@error_code@std@@QBEHXZ
.text$mn:00007F14 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00007F14
.text$mn:00007F14 var_4           = dword ptr -4
.text$mn:00007F14
.text$mn:00007F14                 push    ebp
.text$mn:00007F15                 mov     ebp, esp
.text$mn:00007F17                 push    ecx
.text$mn:00007F18                 mov     [ebp+var_4], ecx
.text$mn:00007F1B                 mov     eax, [ebp+var_4]
.text$mn:00007F1E                 mov     eax, [eax]
.text$mn:00007F20                 mov     esp, ebp
.text$mn:00007F22                 pop     ebp
.text$mn:00007F23                 retn
.text$mn:00007F23 ?value@error_code@std@@QBEHXZ endp
.text$mn:00007F23
.text$mn:00007F23 _text$mn        ends
.text$mn:00007F23
.text$mn:00007F24 ; ===========================================================================
.text$mn:00007F24
.text$mn:00007F24 ; Segment type: Pure code
.text$mn:00007F24 ; Segment permissions: Read/Execute
.text$mn:00007F24 _text$mn        segment para public 'CODE' use32
.text$mn:00007F24                 assume cs:_text$mn
.text$mn:00007F24                 ;org 7F24h
.text$mn:00007F24 ; COMDAT (pick any)
.text$mn:00007F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F24
.text$mn:00007F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F24
.text$mn:00007F24 ; Attributes: bp-based frame
.text$mn:00007F24
.text$mn:00007F24 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00007F24                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00007F24 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00007F24                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00007F24                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00007F24
.text$mn:00007F24 var_4           = dword ptr -4
.text$mn:00007F24
.text$mn:00007F24                 push    ebp
.text$mn:00007F25                 mov     ebp, esp
.text$mn:00007F27                 push    ecx
.text$mn:00007F28                 mov     [ebp+var_4], ecx
.text$mn:00007F2B                 mov     eax, [ebp+var_4]
.text$mn:00007F2E                 mov     eax, [eax]
.text$mn:00007F30                 mov     esp, ebp
.text$mn:00007F32                 pop     ebp
.text$mn:00007F33                 retn
.text$mn:00007F33 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00007F33
.text$mn:00007F33 _text$mn        ends
.text$mn:00007F33
.text$mn:00007F34 ; ===========================================================================
.text$mn:00007F34
.text$mn:00007F34 ; Segment type: Pure code
.text$mn:00007F34 ; Segment permissions: Read/Execute
.text$mn:00007F34 _text$mn        segment para public 'CODE' use32
.text$mn:00007F34                 assume cs:_text$mn
.text$mn:00007F34                 ;org 7F34h
.text$mn:00007F34 ; COMDAT (pick any)
.text$mn:00007F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F34
.text$mn:00007F34 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F34
.text$mn:00007F34 ; Attributes: bp-based frame
.text$mn:00007F34
.text$mn:00007F34                 public _hypot
.text$mn:00007F34 _hypot          proc near
.text$mn:00007F34
.text$mn:00007F34 var_10          = qword ptr -10h
.text$mn:00007F34 var_8           = qword ptr -8
.text$mn:00007F34 arg_0           = qword ptr  8
.text$mn:00007F34 arg_8           = qword ptr  10h
.text$mn:00007F34
.text$mn:00007F34                 push    ebp
.text$mn:00007F35                 mov     ebp, esp
.text$mn:00007F37                 sub     esp, 8
.text$mn:00007F3A                 movsd   xmm0, [ebp+arg_8]
.text$mn:00007F3F                 movsd   [esp+8+var_8], xmm0
.text$mn:00007F44                 sub     esp, 8
.text$mn:00007F47                 movsd   xmm0, [ebp+arg_0]
.text$mn:00007F4C                 movsd   [esp+10h+var_10], xmm0
.text$mn:00007F51                 call    __hypot
.text$mn:00007F56                 add     esp, 10h
.text$mn:00007F59                 pop     ebp
.text$mn:00007F5A                 retn
.text$mn:00007F5A _hypot          endp
.text$mn:00007F5A
.text$mn:00007F5A ; ---------------------------------------------------------------------------
.text$mn:00007F5B                 align 4
.text$mn:00007F5B _text$mn        ends
.text$mn:00007F5B
.text$mn:00007F5C ; ===========================================================================
.text$mn:00007F5C
.text$mn:00007F5C ; Segment type: Pure code
.text$mn:00007F5C ; Segment permissions: Read/Execute
.text$mn:00007F5C _text$mn        segment para public 'CODE' use32
.text$mn:00007F5C                 assume cs:_text$mn
.text$mn:00007F5C                 ;org 7F5Ch
.text$mn:00007F5C ; COMDAT (pick any)
.text$mn:00007F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F5C
.text$mn:00007F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00007F5C
.text$mn:00007F5C ; Attributes: bp-based frame
.text$mn:00007F5C
.text$mn:00007F5C                 public _wmemcmp
.text$mn:00007F5C _wmemcmp        proc near               ; CODE XREF: std::char_traits<wchar_t>::compare(wchar_t const *,wchar_t const *,uint)+1Fp
.text$mn:00007F5C
.text$mn:00007F5C var_4           = dword ptr -4
.text$mn:00007F5C arg_0           = dword ptr  8
.text$mn:00007F5C arg_4           = dword ptr  0Ch
.text$mn:00007F5C arg_8           = dword ptr  10h
.text$mn:00007F5C
.text$mn:00007F5C                 push    ebp
.text$mn:00007F5D                 mov     ebp, esp
.text$mn:00007F5F                 push    ecx
.text$mn:00007F60                 jmp     short loc_7F7D
.text$mn:00007F62 ; ---------------------------------------------------------------------------
.text$mn:00007F62
.text$mn:00007F62 loc_7F62:                               ; CODE XREF: _wmemcmp:loc_7FB8j
.text$mn:00007F62                 mov     eax, [ebp+arg_0]
.text$mn:00007F65                 add     eax, 2
.text$mn:00007F68                 mov     [ebp+arg_0], eax
.text$mn:00007F6B                 mov     ecx, [ebp+arg_4]
.text$mn:00007F6E                 add     ecx, 2
.text$mn:00007F71                 mov     [ebp+arg_4], ecx
.text$mn:00007F74                 mov     edx, [ebp+arg_8]
.text$mn:00007F77                 sub     edx, 1
.text$mn:00007F7A                 mov     [ebp+arg_8], edx
.text$mn:00007F7D
.text$mn:00007F7D loc_7F7D:                               ; CODE XREF: _wmemcmp+4j
.text$mn:00007F7D                 cmp     [ebp+arg_8], 0
.text$mn:00007F81                 jbe     short loc_7FBA
.text$mn:00007F83                 mov     eax, [ebp+arg_0]
.text$mn:00007F86                 movzx   ecx, word ptr [eax]
.text$mn:00007F89                 mov     edx, [ebp+arg_4]
.text$mn:00007F8C                 movzx   eax, word ptr [edx]
.text$mn:00007F8F                 cmp     ecx, eax
.text$mn:00007F91                 jz      short loc_7FB8
.text$mn:00007F93                 mov     ecx, [ebp+arg_0]
.text$mn:00007F96                 movzx   edx, word ptr [ecx]
.text$mn:00007F99                 mov     eax, [ebp+arg_4]
.text$mn:00007F9C                 movzx   ecx, word ptr [eax]
.text$mn:00007F9F                 cmp     edx, ecx
.text$mn:00007FA1                 jge     short loc_7FAC
.text$mn:00007FA3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007FAA                 jmp     short loc_7FB3
.text$mn:00007FAC ; ---------------------------------------------------------------------------
.text$mn:00007FAC
.text$mn:00007FAC loc_7FAC:                               ; CODE XREF: _wmemcmp+45j
.text$mn:00007FAC                 mov     [ebp+var_4], 1
.text$mn:00007FB3
.text$mn:00007FB3 loc_7FB3:                               ; CODE XREF: _wmemcmp+4Ej
.text$mn:00007FB3                 mov     eax, [ebp+var_4]
.text$mn:00007FB6                 jmp     short loc_7FBC
.text$mn:00007FB8 ; ---------------------------------------------------------------------------
.text$mn:00007FB8
.text$mn:00007FB8 loc_7FB8:                               ; CODE XREF: _wmemcmp+35j
.text$mn:00007FB8                 jmp     short loc_7F62
.text$mn:00007FBA ; ---------------------------------------------------------------------------
.text$mn:00007FBA
.text$mn:00007FBA loc_7FBA:                               ; CODE XREF: _wmemcmp+25j
.text$mn:00007FBA                 xor     eax, eax
.text$mn:00007FBC
.text$mn:00007FBC loc_7FBC:                               ; CODE XREF: _wmemcmp+5Aj
.text$mn:00007FBC                 mov     esp, ebp
.text$mn:00007FBE                 pop     ebp
.text$mn:00007FBF                 retn
.text$mn:00007FBF _wmemcmp        endp
.text$mn:00007FBF
.text$mn:00007FBF _text$mn        ends
.text$mn:00007FBF
.text$mn:00007FC0 ; ===========================================================================
.text$mn:00007FC0
.text$mn:00007FC0 ; Segment type: Pure code
.text$mn:00007FC0 ; Segment permissions: Read/Execute
.text$mn:00007FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00007FC0                 assume cs:_text$mn
.text$mn:00007FC0                 ;org 7FC0h
.text$mn:00007FC0 ; COMDAT (pick any)
.text$mn:00007FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FC0
.text$mn:00007FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FC0
.text$mn:00007FC0 ; Attributes: bp-based frame
.text$mn:00007FC0
.text$mn:00007FC0 ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:00007FC0                 public _wmemcpy
.text$mn:00007FC0 _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00007FC0
.text$mn:00007FC0 Dst             = dword ptr  8
.text$mn:00007FC0 Src             = dword ptr  0Ch
.text$mn:00007FC0 arg_8           = dword ptr  10h
.text$mn:00007FC0
.text$mn:00007FC0                 push    ebp
.text$mn:00007FC1                 mov     ebp, esp
.text$mn:00007FC3                 mov     eax, [ebp+arg_8]
.text$mn:00007FC6                 shl     eax, 1
.text$mn:00007FC8                 push    eax             ; Size
.text$mn:00007FC9                 mov     ecx, [ebp+Src]
.text$mn:00007FCC                 push    ecx             ; Src
.text$mn:00007FCD                 mov     edx, [ebp+Dst]
.text$mn:00007FD0                 push    edx             ; Dst
.text$mn:00007FD1                 call    _memcpy
.text$mn:00007FD6                 add     esp, 0Ch
.text$mn:00007FD9                 pop     ebp
.text$mn:00007FDA                 retn
.text$mn:00007FDA _wmemcpy        endp
.text$mn:00007FDA
.text$mn:00007FDA ; ---------------------------------------------------------------------------
.text$mn:00007FDB                 align 4
.text$mn:00007FDB _text$mn        ends
.text$mn:00007FDB
.text$mn:00007FDC ; ===========================================================================
.text$mn:00007FDC
.text$mn:00007FDC ; Segment type: Pure code
.text$mn:00007FDC ; Segment permissions: Read/Execute
.text$mn:00007FDC _text$mn        segment para public 'CODE' use32
.text$mn:00007FDC                 assume cs:_text$mn
.text$mn:00007FDC                 ;org 7FDCh
.text$mn:00007FDC ; COMDAT (pick any)
.text$mn:00007FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FDC
.text$mn:00007FDC ; =============== S U B R O U T I N E =======================================
.text$mn:00007FDC
.text$mn:00007FDC ; Attributes: bp-based frame
.text$mn:00007FDC
.text$mn:00007FDC ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00007FDC                 public _wmemmove
.text$mn:00007FDC _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00007FDC
.text$mn:00007FDC Dst             = dword ptr  8
.text$mn:00007FDC Src             = dword ptr  0Ch
.text$mn:00007FDC arg_8           = dword ptr  10h
.text$mn:00007FDC
.text$mn:00007FDC                 push    ebp
.text$mn:00007FDD                 mov     ebp, esp
.text$mn:00007FDF                 mov     eax, [ebp+arg_8]
.text$mn:00007FE2                 shl     eax, 1
.text$mn:00007FE4                 push    eax             ; Size
.text$mn:00007FE5                 mov     ecx, [ebp+Src]
.text$mn:00007FE8                 push    ecx             ; Src
.text$mn:00007FE9                 mov     edx, [ebp+Dst]
.text$mn:00007FEC                 push    edx             ; Dst
.text$mn:00007FED                 call    _memmove
.text$mn:00007FF2                 add     esp, 0Ch
.text$mn:00007FF5                 pop     ebp
.text$mn:00007FF6                 retn
.text$mn:00007FF6 _wmemmove       endp
.text$mn:00007FF6
.text$mn:00007FF6 ; ---------------------------------------------------------------------------
.text$mn:00007FF7                 align 4
.text$mn:00007FF7 _text$mn        ends
.text$mn:00007FF7
.xdata$x:00007FF8 ; ===========================================================================
.xdata$x:00007FF8
.xdata$x:00007FF8 ; Segment type: Pure data
.xdata$x:00007FF8 ; Segment permissions: Read
.xdata$x:00007FF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00007FF8                 assume cs:_xdata$x
.xdata$x:00007FF8                 ;org 7FF8h
.xdata$x:00007FF8 ; COMDAT (pick associative to section at 38A8)
.xdata$x:00007FF8 __unwindtable$??0StaticDialog@@QAE@XZ db 0FFh
.xdata$x:00007FF8                                         ; DATA XREF: .xdata$x:00008008o
.xdata$x:00007FF9                 db 0FFh
.xdata$x:00007FFA                 db 0FFh
.xdata$x:00007FFB                 db 0FFh
.xdata$x:00007FFC                 dd offset __unwindfunclet$??0StaticDialog@@QAE@XZ$0
.xdata$x:00008000 __ehfuncinfo$??0StaticDialog@@QAE@XZ db  22h ; "
.xdata$x:00008000                                         ; DATA XREF: __ehhandler$??0StaticDialog@@QAE@XZ+11o
.xdata$x:00008001                 db    5
.xdata$x:00008002                 db  93h ; ô
.xdata$x:00008003                 db  19h
.xdata$x:00008004                 db    1
.xdata$x:00008005                 db    0
.xdata$x:00008006                 db    0
.xdata$x:00008007                 db    0
.xdata$x:00008008                 dd offset __unwindtable$??0StaticDialog@@QAE@XZ
.xdata$x:0000800C                 db    0
.xdata$x:0000800D                 db    0
.xdata$x:0000800E                 db    0
.xdata$x:0000800F                 db    0
.xdata$x:00008010                 db    0
.xdata$x:00008011                 db    0
.xdata$x:00008012                 db    0
.xdata$x:00008013                 db    0
.xdata$x:00008014                 db    0
.xdata$x:00008015                 db    0
.xdata$x:00008016                 db    0
.xdata$x:00008017                 db    0
.xdata$x:00008018                 db    0
.xdata$x:00008019                 db    0
.xdata$x:0000801A                 db    0
.xdata$x:0000801B                 db    0
.xdata$x:0000801C                 db    0
.xdata$x:0000801D                 db    0
.xdata$x:0000801E                 db    0
.xdata$x:0000801F                 db    0
.xdata$x:00008020                 db    0
.xdata$x:00008021                 db    0
.xdata$x:00008022                 db    0
.xdata$x:00008023                 db    0
.xdata$x:00008023 _xdata$x        ends
.xdata$x:00008023
.xdata$x:00008024 ; ===========================================================================
.xdata$x:00008024
.xdata$x:00008024 ; Segment type: Pure data
.xdata$x:00008024 ; Segment permissions: Read
.xdata$x:00008024 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008024                 assume cs:_xdata$x
.xdata$x:00008024                 ;org 8024h
.xdata$x:00008024 ; COMDAT (pick associative to section at 4268)
.xdata$x:00008024 __unwindtable$??1StaticDialog@@UAE@XZ db 0FFh
.xdata$x:00008024                                         ; DATA XREF: .xdata$x:00008034o
.xdata$x:00008025                 db 0FFh
.xdata$x:00008026                 db 0FFh
.xdata$x:00008027                 db 0FFh
.xdata$x:00008028                 dd offset __unwindfunclet$??1StaticDialog@@UAE@XZ$0
.xdata$x:0000802C __ehfuncinfo$??1StaticDialog@@UAE@XZ db  22h ; "
.xdata$x:0000802C                                         ; DATA XREF: __ehhandler$??1StaticDialog@@UAE@XZ+11o
.xdata$x:0000802D                 db    5
.xdata$x:0000802E                 db  93h ; ô
.xdata$x:0000802F                 db  19h
.xdata$x:00008030                 db    1
.xdata$x:00008031                 db    0
.xdata$x:00008032                 db    0
.xdata$x:00008033                 db    0
.xdata$x:00008034                 dd offset __unwindtable$??1StaticDialog@@UAE@XZ
.xdata$x:00008038                 db    0
.xdata$x:00008039                 db    0
.xdata$x:0000803A                 db    0
.xdata$x:0000803B                 db    0
.xdata$x:0000803C                 db    0
.xdata$x:0000803D                 db    0
.xdata$x:0000803E                 db    0
.xdata$x:0000803F                 db    0
.xdata$x:00008040                 db    0
.xdata$x:00008041                 db    0
.xdata$x:00008042                 db    0
.xdata$x:00008043                 db    0
.xdata$x:00008044                 db    0
.xdata$x:00008045                 db    0
.xdata$x:00008046                 db    0
.xdata$x:00008047                 db    0
.xdata$x:00008048                 db    0
.xdata$x:00008049                 db    0
.xdata$x:0000804A                 db    0
.xdata$x:0000804B                 db    0
.xdata$x:0000804C                 db    0
.xdata$x:0000804D                 db    0
.xdata$x:0000804E                 db    0
.xdata$x:0000804F                 db    0
.xdata$x:0000804F _xdata$x        ends
.xdata$x:0000804F
.xdata$x:00008050 ; ===========================================================================
.xdata$x:00008050
.xdata$x:00008050 ; Segment type: Pure data
.xdata$x:00008050 ; Segment permissions: Read
.xdata$x:00008050 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008050                 assume cs:_xdata$x
.xdata$x:00008050                 ;org 8050h
.xdata$x:00008050 ; COMDAT (pick associative to section at 5850)
.xdata$x:00008050 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00008050                                         ; DATA XREF: .xdata$x:00008060o
.xdata$x:00008051                 db 0FFh
.xdata$x:00008052                 db 0FFh
.xdata$x:00008053                 db 0FFh
.xdata$x:00008054                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00008058 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00008058                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00008059                 db    5
.xdata$x:0000805A                 db  93h ; ô
.xdata$x:0000805B                 db  19h
.xdata$x:0000805C                 db    1
.xdata$x:0000805D                 db    0
.xdata$x:0000805E                 db    0
.xdata$x:0000805F                 db    0
.xdata$x:00008060                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00008064                 db    0
.xdata$x:00008065                 db    0
.xdata$x:00008066                 db    0
.xdata$x:00008067                 db    0
.xdata$x:00008068                 db    0
.xdata$x:00008069                 db    0
.xdata$x:0000806A                 db    0
.xdata$x:0000806B                 db    0
.xdata$x:0000806C                 db    0
.xdata$x:0000806D                 db    0
.xdata$x:0000806E                 db    0
.xdata$x:0000806F                 db    0
.xdata$x:00008070                 db    0
.xdata$x:00008071                 db    0
.xdata$x:00008072                 db    0
.xdata$x:00008073                 db    0
.xdata$x:00008074                 db    0
.xdata$x:00008075                 db    0
.xdata$x:00008076                 db    0
.xdata$x:00008077                 db    0
.xdata$x:00008078                 db    0
.xdata$x:00008079                 db    0
.xdata$x:0000807A                 db    0
.xdata$x:0000807B                 db    0
.xdata$x:0000807B _xdata$x        ends
.xdata$x:0000807B
.xdata$x:0000807C ; ===========================================================================
.xdata$x:0000807C
.xdata$x:0000807C ; Segment type: Pure data
.xdata$x:0000807C ; Segment permissions: Read
.xdata$x:0000807C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000807C                 assume cs:_xdata$x
.xdata$x:0000807C                 ;org 807Ch
.xdata$x:0000807C ; COMDAT (pick associative to section at 4700)
.xdata$x:0000807C __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:0000807C                                         ; DATA XREF: .xdata$x:0000808Co
.xdata$x:0000807D                 db 0FFh
.xdata$x:0000807E                 db 0FFh
.xdata$x:0000807F                 db 0FFh
.xdata$x:00008080                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00008084 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00008084                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00008085                 db    5
.xdata$x:00008086                 db  93h ; ô
.xdata$x:00008087                 db  19h
.xdata$x:00008088                 db    1
.xdata$x:00008089                 db    0
.xdata$x:0000808A                 db    0
.xdata$x:0000808B                 db    0
.xdata$x:0000808C                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00008090                 db    0
.xdata$x:00008091                 db    0
.xdata$x:00008092                 db    0
.xdata$x:00008093                 db    0
.xdata$x:00008094                 db    0
.xdata$x:00008095                 db    0
.xdata$x:00008096                 db    0
.xdata$x:00008097                 db    0
.xdata$x:00008098                 db    0
.xdata$x:00008099                 db    0
.xdata$x:0000809A                 db    0
.xdata$x:0000809B                 db    0
.xdata$x:0000809C                 db    0
.xdata$x:0000809D                 db    0
.xdata$x:0000809E                 db    0
.xdata$x:0000809F                 db    0
.xdata$x:000080A0                 db    0
.xdata$x:000080A1                 db    0
.xdata$x:000080A2                 db    0
.xdata$x:000080A3                 db    0
.xdata$x:000080A4                 db    0
.xdata$x:000080A5                 db    0
.xdata$x:000080A6                 db    0
.xdata$x:000080A7                 db    0
.xdata$x:000080A7 _xdata$x        ends
.xdata$x:000080A7
.xdata$x:000080A8 ; ===========================================================================
.xdata$x:000080A8
.xdata$x:000080A8 ; Segment type: Pure data
.xdata$x:000080A8 ; Segment permissions: Read
.xdata$x:000080A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000080A8                 assume cs:_xdata$x
.xdata$x:000080A8                 ;org 80A8h
.xdata$x:000080A8 ; COMDAT (pick associative to section at 44A4)
.xdata$x:000080A8 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:000080A8                                         ; DATA XREF: .xdata$x:000080B8o
.xdata$x:000080A9                 db 0FFh
.xdata$x:000080AA                 db 0FFh
.xdata$x:000080AB                 db 0FFh
.xdata$x:000080AC                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:000080B0 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:000080B0                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:000080B1                 db    5
.xdata$x:000080B2                 db  93h ; ô
.xdata$x:000080B3                 db  19h
.xdata$x:000080B4                 db    1
.xdata$x:000080B5                 db    0
.xdata$x:000080B6                 db    0
.xdata$x:000080B7                 db    0
.xdata$x:000080B8                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:000080BC                 db    0
.xdata$x:000080BD                 db    0
.xdata$x:000080BE                 db    0
.xdata$x:000080BF                 db    0
.xdata$x:000080C0                 db    0
.xdata$x:000080C1                 db    0
.xdata$x:000080C2                 db    0
.xdata$x:000080C3                 db    0
.xdata$x:000080C4                 db    0
.xdata$x:000080C5                 db    0
.xdata$x:000080C6                 db    0
.xdata$x:000080C7                 db    0
.xdata$x:000080C8                 db    0
.xdata$x:000080C9                 db    0
.xdata$x:000080CA                 db    0
.xdata$x:000080CB                 db    0
.xdata$x:000080CC                 db    0
.xdata$x:000080CD                 db    0
.xdata$x:000080CE                 db    0
.xdata$x:000080CF                 db    0
.xdata$x:000080D0                 db    0
.xdata$x:000080D1                 db    0
.xdata$x:000080D2                 db    0
.xdata$x:000080D3                 db    0
.xdata$x:000080D3 _xdata$x        ends
.xdata$x:000080D3
.xdata$x:000080D4 ; ===========================================================================
.xdata$x:000080D4
.xdata$x:000080D4 ; Segment type: Pure data
.xdata$x:000080D4 ; Segment permissions: Read
.xdata$x:000080D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000080D4                 assume cs:_xdata$x
.xdata$x:000080D4                 ;org 80D4h
.xdata$x:000080D4 ; COMDAT (pick associative to section at 4CEC)
.xdata$x:000080D4 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:000080D4                                         ; DATA XREF: .xdata$x:000080ECo
.xdata$x:000080D5                 db 0FFh
.xdata$x:000080D6                 db 0FFh
.xdata$x:000080D7                 db 0FFh
.xdata$x:000080D8                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:000080DC                 db 0FFh
.xdata$x:000080DD                 db 0FFh
.xdata$x:000080DE                 db 0FFh
.xdata$x:000080DF                 db 0FFh
.xdata$x:000080E0                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:000080E4 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:000080E4                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:000080E5                 db    5
.xdata$x:000080E6                 db  93h ; ô
.xdata$x:000080E7                 db  19h
.xdata$x:000080E8                 db    2
.xdata$x:000080E9                 db    0
.xdata$x:000080EA                 db    0
.xdata$x:000080EB                 db    0
.xdata$x:000080EC                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:000080F0                 db    0
.xdata$x:000080F1                 db    0
.xdata$x:000080F2                 db    0
.xdata$x:000080F3                 db    0
.xdata$x:000080F4                 db    0
.xdata$x:000080F5                 db    0
.xdata$x:000080F6                 db    0
.xdata$x:000080F7                 db    0
.xdata$x:000080F8                 db    0
.xdata$x:000080F9                 db    0
.xdata$x:000080FA                 db    0
.xdata$x:000080FB                 db    0
.xdata$x:000080FC                 db    0
.xdata$x:000080FD                 db    0
.xdata$x:000080FE                 db    0
.xdata$x:000080FF                 db    0
.xdata$x:00008100                 db    0
.xdata$x:00008101                 db    0
.xdata$x:00008102                 db    0
.xdata$x:00008103                 db    0
.xdata$x:00008104                 db    0
.xdata$x:00008105                 db    0
.xdata$x:00008106                 db    0
.xdata$x:00008107                 db    0
.xdata$x:00008107 _xdata$x        ends
.xdata$x:00008107
.xdata$x:00008108 ; ===========================================================================
.xdata$x:00008108
.xdata$x:00008108 ; Segment type: Pure data
.xdata$x:00008108 ; Segment permissions: Read
.xdata$x:00008108 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008108                 assume cs:_xdata$x
.xdata$x:00008108                 ;org 8108h
.xdata$x:00008108 ; COMDAT (pick associative to section at 3148)
.xdata$x:00008108 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008108                                         ; DATA XREF: .xdata$x:00008118o
.xdata$x:00008109                 db 0FFh
.xdata$x:0000810A                 db 0FFh
.xdata$x:0000810B                 db 0FFh
.xdata$x:0000810C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00008110 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008110                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00008111                 db    5
.xdata$x:00008112                 db  93h ; ô
.xdata$x:00008113                 db  19h
.xdata$x:00008114                 db    1
.xdata$x:00008115                 db    0
.xdata$x:00008116                 db    0
.xdata$x:00008117                 db    0
.xdata$x:00008118                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:0000811C                 db    0
.xdata$x:0000811D                 db    0
.xdata$x:0000811E                 db    0
.xdata$x:0000811F                 db    0
.xdata$x:00008120                 db    0
.xdata$x:00008121                 db    0
.xdata$x:00008122                 db    0
.xdata$x:00008123                 db    0
.xdata$x:00008124                 db    0
.xdata$x:00008125                 db    0
.xdata$x:00008126                 db    0
.xdata$x:00008127                 db    0
.xdata$x:00008128                 db    0
.xdata$x:00008129                 db    0
.xdata$x:0000812A                 db    0
.xdata$x:0000812B                 db    0
.xdata$x:0000812C                 db    0
.xdata$x:0000812D                 db    0
.xdata$x:0000812E                 db    0
.xdata$x:0000812F                 db    0
.xdata$x:00008130                 db    0
.xdata$x:00008131                 db    0
.xdata$x:00008132                 db    0
.xdata$x:00008133                 db    0
.xdata$x:00008133 _xdata$x        ends
.xdata$x:00008133
.xdata$x:00008134 ; ===========================================================================
.xdata$x:00008134
.xdata$x:00008134 ; Segment type: Pure data
.xdata$x:00008134 ; Segment permissions: Read
.xdata$x:00008134 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008134                 assume cs:_xdata$x
.xdata$x:00008134                 ;org 8134h
.xdata$x:00008134 ; COMDAT (pick associative to section at 3FB0)
.xdata$x:00008134 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008134                                         ; DATA XREF: .xdata$x:00008144o
.xdata$x:00008135                 db 0FFh
.xdata$x:00008136                 db 0FFh
.xdata$x:00008137                 db 0FFh
.xdata$x:00008138                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:0000813C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000813C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:0000813D                 db    5
.xdata$x:0000813E                 db  93h ; ô
.xdata$x:0000813F                 db  19h
.xdata$x:00008140                 db    1
.xdata$x:00008141                 db    0
.xdata$x:00008142                 db    0
.xdata$x:00008143                 db    0
.xdata$x:00008144                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00008148                 align 20h
.xdata$x:00008148 _xdata$x        ends
.xdata$x:00008148
.xdata$x:00008160 ; ===========================================================================
.xdata$x:00008160
.xdata$x:00008160 ; Segment type: Pure data
.xdata$x:00008160 ; Segment permissions: Read
.xdata$x:00008160 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008160                 assume cs:_xdata$x
.xdata$x:00008160                 ;org 8160h
.xdata$x:00008160 ; COMDAT (pick associative to section at 2E4C)
.xdata$x:00008160 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00008160                                         ; DATA XREF: .xdata$x:00008170o
.xdata$x:00008161                 db 0FFh
.xdata$x:00008162                 db 0FFh
.xdata$x:00008163                 db 0FFh
.xdata$x:00008164                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00008168 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00008168                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00008169                 db    5
.xdata$x:0000816A                 db  93h ; ô
.xdata$x:0000816B                 db  19h
.xdata$x:0000816C                 db    1
.xdata$x:0000816D                 db    0
.xdata$x:0000816E                 db    0
.xdata$x:0000816F                 db    0
.xdata$x:00008170                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00008174                 db    0
.xdata$x:00008175                 db    0
.xdata$x:00008176                 db    0
.xdata$x:00008177                 db    0
.xdata$x:00008178                 db    0
.xdata$x:00008179                 db    0
.xdata$x:0000817A                 db    0
.xdata$x:0000817B                 db    0
.xdata$x:0000817C                 db    0
.xdata$x:0000817D                 db    0
.xdata$x:0000817E                 db    0
.xdata$x:0000817F                 db    0
.xdata$x:00008180                 db    0
.xdata$x:00008181                 db    0
.xdata$x:00008182                 db    0
.xdata$x:00008183                 db    0
.xdata$x:00008184                 db    0
.xdata$x:00008185                 db    0
.xdata$x:00008186                 db    0
.xdata$x:00008187                 db    0
.xdata$x:00008188                 db    0
.xdata$x:00008189                 db    0
.xdata$x:0000818A                 db    0
.xdata$x:0000818B                 db    0
.xdata$x:0000818B _xdata$x        ends
.xdata$x:0000818B
.xdata$x:0000818C ; ===========================================================================
.xdata$x:0000818C
.xdata$x:0000818C ; Segment type: Pure data
.xdata$x:0000818C ; Segment permissions: Read
.xdata$x:0000818C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000818C                 assume cs:_xdata$x
.xdata$x:0000818C                 ;org 818Ch
.xdata$x:0000818C ; COMDAT (pick associative to section at 3DE0)
.xdata$x:0000818C __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000818C                                         ; DATA XREF: .xdata$x:0000819Co
.xdata$x:0000818D                 db 0FFh
.xdata$x:0000818E                 db 0FFh
.xdata$x:0000818F                 db 0FFh
.xdata$x:00008190                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00008194 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008194                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00008195                 db    5
.xdata$x:00008196                 db  93h ; ô
.xdata$x:00008197                 db  19h
.xdata$x:00008198                 db    1
.xdata$x:00008199                 db    0
.xdata$x:0000819A                 db    0
.xdata$x:0000819B                 db    0
.xdata$x:0000819C                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:000081A0                 db    0
.xdata$x:000081A1                 db    0
.xdata$x:000081A2                 db    0
.xdata$x:000081A3                 db    0
.xdata$x:000081A4                 db    0
.xdata$x:000081A5                 db    0
.xdata$x:000081A6                 db    0
.xdata$x:000081A7                 db    0
.xdata$x:000081A8                 db    0
.xdata$x:000081A9                 db    0
.xdata$x:000081AA                 db    0
.xdata$x:000081AB                 db    0
.xdata$x:000081AC                 db    0
.xdata$x:000081AD                 db    0
.xdata$x:000081AE                 db    0
.xdata$x:000081AF                 db    0
.xdata$x:000081B0                 db    0
.xdata$x:000081B1                 db    0
.xdata$x:000081B2                 db    0
.xdata$x:000081B3                 db    0
.xdata$x:000081B4                 db    0
.xdata$x:000081B5                 db    0
.xdata$x:000081B6                 db    0
.xdata$x:000081B7                 db    0
.xdata$x:000081B7 _xdata$x        ends
.xdata$x:000081B7
.xdata$x:000081B8 ; ===========================================================================
.xdata$x:000081B8
.xdata$x:000081B8 ; Segment type: Pure data
.xdata$x:000081B8 ; Segment permissions: Read
.xdata$x:000081B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000081B8                 assume cs:_xdata$x
.xdata$x:000081B8                 ;org 81B8h
.xdata$x:000081B8 ; COMDAT (pick associative to section at 330C)
.xdata$x:000081B8 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:000081B8                                         ; DATA XREF: .xdata$x:000081C8o
.xdata$x:000081B9                 db 0FFh
.xdata$x:000081BA                 db 0FFh
.xdata$x:000081BB                 db 0FFh
.xdata$x:000081BC                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:000081C0 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:000081C0                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:000081C1                 db    5
.xdata$x:000081C2                 db  93h ; ô
.xdata$x:000081C3                 db  19h
.xdata$x:000081C4                 db    1
.xdata$x:000081C5                 db    0
.xdata$x:000081C6                 db    0
.xdata$x:000081C7                 db    0
.xdata$x:000081C8                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:000081CC                 db    0
.xdata$x:000081CD                 db    0
.xdata$x:000081CE                 db    0
.xdata$x:000081CF                 db    0
.xdata$x:000081D0                 db    0
.xdata$x:000081D1                 db    0
.xdata$x:000081D2                 db    0
.xdata$x:000081D3                 db    0
.xdata$x:000081D4                 db    0
.xdata$x:000081D5                 db    0
.xdata$x:000081D6                 db    0
.xdata$x:000081D7                 db    0
.xdata$x:000081D8                 db    0
.xdata$x:000081D9                 db    0
.xdata$x:000081DA                 db    0
.xdata$x:000081DB                 db    0
.xdata$x:000081DC                 db    0
.xdata$x:000081DD                 db    0
.xdata$x:000081DE                 db    0
.xdata$x:000081DF                 db    0
.xdata$x:000081E0                 db    0
.xdata$x:000081E1                 db    0
.xdata$x:000081E2                 db    0
.xdata$x:000081E3                 db    0
.xdata$x:000081E3 _xdata$x        ends
.xdata$x:000081E3
.xdata$x:000081E4 ; ===========================================================================
.xdata$x:000081E4
.xdata$x:000081E4 ; Segment type: Pure data
.xdata$x:000081E4 ; Segment permissions: Read
.xdata$x:000081E4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000081E4                 assume cs:_xdata$x
.xdata$x:000081E4                 ;org 81E4h
.xdata$x:000081E4 ; COMDAT (pick associative to section at 4090)
.xdata$x:000081E4 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:000081E4                                         ; DATA XREF: .xdata$x:000081F4o
.xdata$x:000081E5                 db 0FFh
.xdata$x:000081E6                 db 0FFh
.xdata$x:000081E7                 db 0FFh
.xdata$x:000081E8                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:000081EC __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000081EC                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:000081ED                 db    5
.xdata$x:000081EE                 db  93h ; ô
.xdata$x:000081EF                 db  19h
.xdata$x:000081F0                 db    1
.xdata$x:000081F1                 db    0
.xdata$x:000081F2                 db    0
.xdata$x:000081F3                 db    0
.xdata$x:000081F4                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000081F8                 db    0
.xdata$x:000081F9                 db    0
.xdata$x:000081FA                 db    0
.xdata$x:000081FB                 db    0
.xdata$x:000081FC                 db    0
.xdata$x:000081FD                 db    0
.xdata$x:000081FE                 db    0
.xdata$x:000081FF                 db    0
.xdata$x:00008200                 db    0
.xdata$x:00008201                 db    0
.xdata$x:00008202                 db    0
.xdata$x:00008203                 db    0
.xdata$x:00008204                 db    0
.xdata$x:00008205                 db    0
.xdata$x:00008206                 db    0
.xdata$x:00008207                 db    0
.xdata$x:00008208                 db    0
.xdata$x:00008209                 db    0
.xdata$x:0000820A                 db    0
.xdata$x:0000820B                 db    0
.xdata$x:0000820C                 db    0
.xdata$x:0000820D                 db    0
.xdata$x:0000820E                 db    0
.xdata$x:0000820F                 db    0
.xdata$x:0000820F _xdata$x        ends
.xdata$x:0000820F
.xdata$x:00008210 ; ===========================================================================
.xdata$x:00008210
.xdata$x:00008210 ; Segment type: Pure data
.xdata$x:00008210 ; Segment permissions: Read
.xdata$x:00008210 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008210                 assume cs:_xdata$x
.xdata$x:00008210                 ;org 8210h
.xdata$x:00008210 ; COMDAT (pick associative to section at 4FB4)
.xdata$x:00008210 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00008210                                         ; DATA XREF: .xdata$x:00008298o
.xdata$x:00008211                 db    0
.xdata$x:00008212                 db    0
.xdata$x:00008213                 db    0
.xdata$x:00008214                 db    0
.xdata$x:00008215                 db    0
.xdata$x:00008216                 db    0
.xdata$x:00008217                 db    0
.xdata$x:00008218                 db    0
.xdata$x:00008219                 db    0
.xdata$x:0000821A                 db    0
.xdata$x:0000821B                 db    0
.xdata$x:0000821C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00008220 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00008220                                         ; DATA XREF: .xdata$x:00008284o
.xdata$x:00008221                 db    0
.xdata$x:00008222                 db    0
.xdata$x:00008223                 db    0
.xdata$x:00008224                 db    0
.xdata$x:00008225                 db    0
.xdata$x:00008226                 db    0
.xdata$x:00008227                 db    0
.xdata$x:00008228                 db    0
.xdata$x:00008229                 db    0
.xdata$x:0000822A                 db    0
.xdata$x:0000822B                 db    0
.xdata$x:0000822C                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00008230 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00008230                                         ; DATA XREF: .xdata$x:00008258o
.xdata$x:00008231                 db 0FFh
.xdata$x:00008232                 db 0FFh
.xdata$x:00008233                 db 0FFh
.xdata$x:00008234                 db    0
.xdata$x:00008235                 db    0
.xdata$x:00008236                 db    0
.xdata$x:00008237                 db    0
.xdata$x:00008238                 db 0FFh
.xdata$x:00008239                 db 0FFh
.xdata$x:0000823A                 db 0FFh
.xdata$x:0000823B                 db 0FFh
.xdata$x:0000823C                 db    0
.xdata$x:0000823D                 db    0
.xdata$x:0000823E                 db    0
.xdata$x:0000823F                 db    0
.xdata$x:00008240                 db    1
.xdata$x:00008241                 db    0
.xdata$x:00008242                 db    0
.xdata$x:00008243                 db    0
.xdata$x:00008244                 db    0
.xdata$x:00008245                 db    0
.xdata$x:00008246                 db    0
.xdata$x:00008247                 db    0
.xdata$x:00008248                 db    1
.xdata$x:00008249                 db    0
.xdata$x:0000824A                 db    0
.xdata$x:0000824B                 db    0
.xdata$x:0000824C                 db    0
.xdata$x:0000824D                 db    0
.xdata$x:0000824E                 db    0
.xdata$x:0000824F                 db    0
.xdata$x:00008250 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00008250                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00008251                 db    5
.xdata$x:00008252                 db  93h ; ô
.xdata$x:00008253                 db  19h
.xdata$x:00008254                 db    4
.xdata$x:00008255                 db    0
.xdata$x:00008256                 db    0
.xdata$x:00008257                 db    0
.xdata$x:00008258                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000825C                 db    2
.xdata$x:0000825D                 db    0
.xdata$x:0000825E                 db    0
.xdata$x:0000825F                 db    0
.xdata$x:00008260                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00008264                 db    0
.xdata$x:00008265                 db    0
.xdata$x:00008266                 db    0
.xdata$x:00008267                 db    0
.xdata$x:00008268                 db    0
.xdata$x:00008269                 db    0
.xdata$x:0000826A                 db    0
.xdata$x:0000826B                 db    0
.xdata$x:0000826C                 db    0
.xdata$x:0000826D                 db    0
.xdata$x:0000826E                 db    0
.xdata$x:0000826F                 db    0
.xdata$x:00008270                 db    0
.xdata$x:00008271                 db    0
.xdata$x:00008272                 db    0
.xdata$x:00008273                 db    0
.xdata$x:00008274 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00008274                                         ; DATA XREF: .xdata$x:00008260o
.xdata$x:00008275                 db    0
.xdata$x:00008276                 db    0
.xdata$x:00008277                 db    0
.xdata$x:00008278                 db    2
.xdata$x:00008279                 db    0
.xdata$x:0000827A                 db    0
.xdata$x:0000827B                 db    0
.xdata$x:0000827C                 db    3
.xdata$x:0000827D                 db    0
.xdata$x:0000827E                 db    0
.xdata$x:0000827F                 db    0
.xdata$x:00008280                 db    1
.xdata$x:00008281                 db    0
.xdata$x:00008282                 db    0
.xdata$x:00008283                 db    0
.xdata$x:00008284                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00008288                 align 10h
.xdata$x:00008290                 db    3
.xdata$x:00008291                 db    0
.xdata$x:00008292                 db    0
.xdata$x:00008293                 db    0
.xdata$x:00008294                 db    1
.xdata$x:00008295                 db    0
.xdata$x:00008296                 db    0
.xdata$x:00008297                 db    0
.xdata$x:00008298                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00008298 _xdata$x        ends
.xdata$x:00008298
.xdata$x:0000829C ; ===========================================================================
.xdata$x:0000829C
.xdata$x:0000829C ; Segment type: Pure data
.xdata$x:0000829C ; Segment permissions: Read
.xdata$x:0000829C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000829C                 assume cs:_xdata$x
.xdata$x:0000829C                 ;org 829Ch
.xdata$x:0000829C ; COMDAT (pick associative to section at 3B44)
.xdata$x:0000829C __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000829C                                         ; DATA XREF: .xdata$x:000082ACo
.xdata$x:0000829D                 db 0FFh
.xdata$x:0000829E                 db 0FFh
.xdata$x:0000829F                 db 0FFh
.xdata$x:000082A0                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000082A4 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000082A4                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000082A5                 db    5
.xdata$x:000082A6                 db  93h ; ô
.xdata$x:000082A7                 db  19h
.xdata$x:000082A8                 db    1
.xdata$x:000082A9                 db    0
.xdata$x:000082AA                 db    0
.xdata$x:000082AB                 db    0
.xdata$x:000082AC                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000082B0                 db    0
.xdata$x:000082B1                 db    0
.xdata$x:000082B2                 db    0
.xdata$x:000082B3                 db    0
.xdata$x:000082B4                 db    0
.xdata$x:000082B5                 db    0
.xdata$x:000082B6                 db    0
.xdata$x:000082B7                 db    0
.xdata$x:000082B8                 db    0
.xdata$x:000082B9                 db    0
.xdata$x:000082BA                 db    0
.xdata$x:000082BB                 db    0
.xdata$x:000082BC                 db    0
.xdata$x:000082BD                 db    0
.xdata$x:000082BE                 db    0
.xdata$x:000082BF                 db    0
.xdata$x:000082C0                 db    0
.xdata$x:000082C1                 db    0
.xdata$x:000082C2                 db    0
.xdata$x:000082C3                 db    0
.xdata$x:000082C4                 db    0
.xdata$x:000082C5                 db    0
.xdata$x:000082C6                 db    0
.xdata$x:000082C7                 db    0
.xdata$x:000082C7 _xdata$x        ends
.xdata$x:000082C7
.xdata$x:000082C8 ; ===========================================================================
.xdata$x:000082C8
.xdata$x:000082C8 ; Segment type: Pure data
.xdata$x:000082C8 ; Segment permissions: Read
.xdata$x:000082C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000082C8                 assume cs:_xdata$x
.xdata$x:000082C8                 ;org 82C8h
.xdata$x:000082C8 ; COMDAT (pick associative to section at 707C)
.xdata$x:000082C8 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000082C8                                         ; DATA XREF: .xdata$x:000082D8o
.xdata$x:000082C9                 db 0FFh
.xdata$x:000082CA                 db 0FFh
.xdata$x:000082CB                 db 0FFh
.xdata$x:000082CC                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000082D0 __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000082D0                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000082D1                 db    5
.xdata$x:000082D2                 db  93h ; ô
.xdata$x:000082D3                 db  19h
.xdata$x:000082D4                 db    1
.xdata$x:000082D5                 db    0
.xdata$x:000082D6                 db    0
.xdata$x:000082D7                 db    0
.xdata$x:000082D8                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000082DC                 db    0
.xdata$x:000082DD                 db    0
.xdata$x:000082DE                 db    0
.xdata$x:000082DF                 db    0
.xdata$x:000082E0                 db    0
.xdata$x:000082E1                 db    0
.xdata$x:000082E2                 db    0
.xdata$x:000082E3                 db    0
.xdata$x:000082E4                 db    0
.xdata$x:000082E5                 db    0
.xdata$x:000082E6                 db    0
.xdata$x:000082E7                 db    0
.xdata$x:000082E8                 db    0
.xdata$x:000082E9                 db    0
.xdata$x:000082EA                 db    0
.xdata$x:000082EB                 db    0
.xdata$x:000082EC                 db    0
.xdata$x:000082ED                 db    0
.xdata$x:000082EE                 db    0
.xdata$x:000082EF                 db    0
.xdata$x:000082F0                 db    0
.xdata$x:000082F1                 db    0
.xdata$x:000082F2                 db    0
.xdata$x:000082F3                 db    0
.xdata$x:000082F3 _xdata$x        ends
.xdata$x:000082F3
.xdata$x:000082F4 ; ===========================================================================
.xdata$x:000082F4
.xdata$x:000082F4 ; Segment type: Pure data
.xdata$x:000082F4 ; Segment permissions: Read
.xdata$x:000082F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000082F4                 assume cs:_xdata$x
.xdata$x:000082F4                 ;org 82F4h
.xdata$x:000082F4 ; COMDAT (pick associative to section at 43C4)
.xdata$x:000082F4 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000082F4                                         ; DATA XREF: .xdata$x:00008304o
.xdata$x:000082F5                 db 0FFh
.xdata$x:000082F6                 db 0FFh
.xdata$x:000082F7                 db 0FFh
.xdata$x:000082F8                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:000082FC __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000082FC                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:000082FD                 db    5
.xdata$x:000082FE                 db  93h ; ô
.xdata$x:000082FF                 db  19h
.xdata$x:00008300                 db    1
.xdata$x:00008301                 db    0
.xdata$x:00008302                 db    0
.xdata$x:00008303                 db    0
.xdata$x:00008304                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00008308                 align 20h
.xdata$x:00008308 _xdata$x        ends
.xdata$x:00008308
.xdata$x:00008320 ; ===========================================================================
.xdata$x:00008320
.xdata$x:00008320 ; Segment type: Pure data
.xdata$x:00008320 ; Segment permissions: Read
.xdata$x:00008320 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008320                 assume cs:_xdata$x
.xdata$x:00008320                 ;org 8320h
.xdata$x:00008320 ; COMDAT (pick associative to section at 3BD0)
.xdata$x:00008320 __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00008320                                         ; DATA XREF: .xdata$x:00008330o
.xdata$x:00008321                 db 0FFh
.xdata$x:00008322                 db 0FFh
.xdata$x:00008323                 db 0FFh
.xdata$x:00008324                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00008328 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00008328                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00008329                 db    5
.xdata$x:0000832A                 db  93h ; ô
.xdata$x:0000832B                 db  19h
.xdata$x:0000832C                 db    1
.xdata$x:0000832D                 db    0
.xdata$x:0000832E                 db    0
.xdata$x:0000832F                 db    0
.xdata$x:00008330                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00008334                 db    0
.xdata$x:00008335                 db    0
.xdata$x:00008336                 db    0
.xdata$x:00008337                 db    0
.xdata$x:00008338                 db    0
.xdata$x:00008339                 db    0
.xdata$x:0000833A                 db    0
.xdata$x:0000833B                 db    0
.xdata$x:0000833C                 db    0
.xdata$x:0000833D                 db    0
.xdata$x:0000833E                 db    0
.xdata$x:0000833F                 db    0
.xdata$x:00008340                 db    0
.xdata$x:00008341                 db    0
.xdata$x:00008342                 db    0
.xdata$x:00008343                 db    0
.xdata$x:00008344                 db    0
.xdata$x:00008345                 db    0
.xdata$x:00008346                 db    0
.xdata$x:00008347                 db    0
.xdata$x:00008348                 db    0
.xdata$x:00008349                 db    0
.xdata$x:0000834A                 db    0
.xdata$x:0000834B                 db    0
.xdata$x:0000834B _xdata$x        ends
.xdata$x:0000834B
.xdata$x:0000834C ; ===========================================================================
.xdata$x:0000834C
.xdata$x:0000834C ; Segment type: Pure data
.xdata$x:0000834C ; Segment permissions: Read
.xdata$x:0000834C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000834C                 assume cs:_xdata$x
.xdata$x:0000834C                 ;org 834Ch
.xdata$x:0000834C ; COMDAT (pick associative to section at 7134)
.xdata$x:0000834C __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000834C                                         ; DATA XREF: .xdata$x:0000835Co
.xdata$x:0000834D                 db 0FFh
.xdata$x:0000834E                 db 0FFh
.xdata$x:0000834F                 db 0FFh
.xdata$x:00008350                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00008354 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00008354                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00008355                 db    5
.xdata$x:00008356                 db  93h ; ô
.xdata$x:00008357                 db  19h
.xdata$x:00008358                 db    1
.xdata$x:00008359                 db    0
.xdata$x:0000835A                 db    0
.xdata$x:0000835B                 db    0
.xdata$x:0000835C                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00008360                 db    0
.xdata$x:00008361                 db    0
.xdata$x:00008362                 db    0
.xdata$x:00008363                 db    0
.xdata$x:00008364                 db    0
.xdata$x:00008365                 db    0
.xdata$x:00008366                 db    0
.xdata$x:00008367                 db    0
.xdata$x:00008368                 db    0
.xdata$x:00008369                 db    0
.xdata$x:0000836A                 db    0
.xdata$x:0000836B                 db    0
.xdata$x:0000836C                 db    0
.xdata$x:0000836D                 db    0
.xdata$x:0000836E                 db    0
.xdata$x:0000836F                 db    0
.xdata$x:00008370                 db    0
.xdata$x:00008371                 db    0
.xdata$x:00008372                 db    0
.xdata$x:00008373                 db    0
.xdata$x:00008374                 db    0
.xdata$x:00008375                 db    0
.xdata$x:00008376                 db    0
.xdata$x:00008377                 db    0
.xdata$x:00008377 _xdata$x        ends
.xdata$x:00008377
.xdata$x:00008378 ; ===========================================================================
.xdata$x:00008378
.xdata$x:00008378 ; Segment type: Pure data
.xdata$x:00008378 ; Segment permissions: Read
.xdata$x:00008378 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008378                 assume cs:_xdata$x
.xdata$x:00008378                 ;org 8378h
.xdata$x:00008378 ; COMDAT (pick associative to section at 4434)
.xdata$x:00008378 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00008378                                         ; DATA XREF: .xdata$x:00008388o
.xdata$x:00008379                 db 0FFh
.xdata$x:0000837A                 db 0FFh
.xdata$x:0000837B                 db 0FFh
.xdata$x:0000837C                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00008380 __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00008380                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00008381                 db    5
.xdata$x:00008382                 db  93h ; ô
.xdata$x:00008383                 db  19h
.xdata$x:00008384                 db    1
.xdata$x:00008385                 db    0
.xdata$x:00008386                 db    0
.xdata$x:00008387                 db    0
.xdata$x:00008388                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:0000838C                 db    0
.xdata$x:0000838D                 db    0
.xdata$x:0000838E                 db    0
.xdata$x:0000838F                 db    0
.xdata$x:00008390                 db    0
.xdata$x:00008391                 db    0
.xdata$x:00008392                 db    0
.xdata$x:00008393                 db    0
.xdata$x:00008394                 db    0
.xdata$x:00008395                 db    0
.xdata$x:00008396                 db    0
.xdata$x:00008397                 db    0
.xdata$x:00008398                 db    0
.xdata$x:00008399                 db    0
.xdata$x:0000839A                 db    0
.xdata$x:0000839B                 db    0
.xdata$x:0000839C                 db    0
.xdata$x:0000839D                 db    0
.xdata$x:0000839E                 db    0
.xdata$x:0000839F                 db    0
.xdata$x:000083A0                 db    0
.xdata$x:000083A1                 db    0
.xdata$x:000083A2                 db    0
.xdata$x:000083A3                 db    0
.xdata$x:000083A3 _xdata$x        ends
.xdata$x:000083A3
.xdata$x:000083A4 ; ===========================================================================
.xdata$x:000083A4
.xdata$x:000083A4 ; Segment type: Pure data
.xdata$x:000083A4 ; Segment permissions: Read
.xdata$x:000083A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083A4                 assume cs:_xdata$x
.xdata$x:000083A4                 ;org 83A4h
.xdata$x:000083A4 ; COMDAT (pick associative to section at 3CA0)
.xdata$x:000083A4 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000083A4                                         ; DATA XREF: .xdata$x:000083B4o
.xdata$x:000083A5                 db 0FFh
.xdata$x:000083A6                 db 0FFh
.xdata$x:000083A7                 db 0FFh
.xdata$x:000083A8                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000083AC __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000083AC                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000083AD                 db    5
.xdata$x:000083AE                 db  93h ; ô
.xdata$x:000083AF                 db  19h
.xdata$x:000083B0                 db    1
.xdata$x:000083B1                 db    0
.xdata$x:000083B2                 db    0
.xdata$x:000083B3                 db    0
.xdata$x:000083B4                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000083B8                 db    0
.xdata$x:000083B9                 db    0
.xdata$x:000083BA                 db    0
.xdata$x:000083BB                 db    0
.xdata$x:000083BC                 db    0
.xdata$x:000083BD                 db    0
.xdata$x:000083BE                 db    0
.xdata$x:000083BF                 db    0
.xdata$x:000083C0                 db    0
.xdata$x:000083C1                 db    0
.xdata$x:000083C2                 db    0
.xdata$x:000083C3                 db    0
.xdata$x:000083C4                 db    0
.xdata$x:000083C5                 db    0
.xdata$x:000083C6                 db    0
.xdata$x:000083C7                 db    0
.xdata$x:000083C8                 db    0
.xdata$x:000083C9                 db    0
.xdata$x:000083CA                 db    0
.xdata$x:000083CB                 db    0
.xdata$x:000083CC                 db    0
.xdata$x:000083CD                 db    0
.xdata$x:000083CE                 db    0
.xdata$x:000083CF                 db    0
.xdata$x:000083CF _xdata$x        ends
.xdata$x:000083CF
.xdata$x:000083D0 ; ===========================================================================
.xdata$x:000083D0
.xdata$x:000083D0 ; Segment type: Pure data
.xdata$x:000083D0 ; Segment permissions: Read
.xdata$x:000083D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083D0                 assume cs:_xdata$x
.xdata$x:000083D0                 ;org 83D0h
.xdata$x:000083D0 ; COMDAT (pick associative to section at 71F8)
.xdata$x:000083D0 __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000083D0                                         ; DATA XREF: .xdata$x:000083E0o
.xdata$x:000083D1                 db 0FFh
.xdata$x:000083D2                 db 0FFh
.xdata$x:000083D3                 db 0FFh
.xdata$x:000083D4                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000083D8 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000083D8                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000083D9                 db    5
.xdata$x:000083DA                 db  93h ; ô
.xdata$x:000083DB                 db  19h
.xdata$x:000083DC                 db    1
.xdata$x:000083DD                 db    0
.xdata$x:000083DE                 db    0
.xdata$x:000083DF                 db    0
.xdata$x:000083E0                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000083E4                 db    0
.xdata$x:000083E5                 db    0
.xdata$x:000083E6                 db    0
.xdata$x:000083E7                 db    0
.xdata$x:000083E8                 db    0
.xdata$x:000083E9                 db    0
.xdata$x:000083EA                 db    0
.xdata$x:000083EB                 db    0
.xdata$x:000083EC                 db    0
.xdata$x:000083ED                 db    0
.xdata$x:000083EE                 db    0
.xdata$x:000083EF                 db    0
.xdata$x:000083F0                 db    0
.xdata$x:000083F1                 db    0
.xdata$x:000083F2                 db    0
.xdata$x:000083F3                 db    0
.xdata$x:000083F4                 db    0
.xdata$x:000083F5                 db    0
.xdata$x:000083F6                 db    0
.xdata$x:000083F7                 db    0
.xdata$x:000083F8                 db    0
.xdata$x:000083F9                 db    0
.xdata$x:000083FA                 db    0
.xdata$x:000083FB                 db    0
.xdata$x:000083FB _xdata$x        ends
.xdata$x:000083FB
.xdata$x:000083FC ; ===========================================================================
.xdata$x:000083FC
.xdata$x:000083FC ; Segment type: Pure data
.xdata$x:000083FC ; Segment permissions: Read
.xdata$x:000083FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000083FC                 assume cs:_xdata$x
.xdata$x:000083FC                 ;org 83FCh
.xdata$x:000083FC ; COMDAT (pick associative to section at 4528)
.xdata$x:000083FC __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000083FC                                         ; DATA XREF: .xdata$x:0000840Co
.xdata$x:000083FD                 db 0FFh
.xdata$x:000083FE                 db 0FFh
.xdata$x:000083FF                 db 0FFh
.xdata$x:00008400                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00008404 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00008404                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00008405                 db    5
.xdata$x:00008406                 db  93h ; ô
.xdata$x:00008407                 db  19h
.xdata$x:00008408                 db    1
.xdata$x:00008409                 db    0
.xdata$x:0000840A                 db    0
.xdata$x:0000840B                 db    0
.xdata$x:0000840C                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00008410                 db    0
.xdata$x:00008411                 db    0
.xdata$x:00008412                 db    0
.xdata$x:00008413                 db    0
.xdata$x:00008414                 db    0
.xdata$x:00008415                 db    0
.xdata$x:00008416                 db    0
.xdata$x:00008417                 db    0
.xdata$x:00008418                 db    0
.xdata$x:00008419                 db    0
.xdata$x:0000841A                 db    0
.xdata$x:0000841B                 db    0
.xdata$x:0000841C                 db    0
.xdata$x:0000841D                 db    0
.xdata$x:0000841E                 db    0
.xdata$x:0000841F                 db    0
.xdata$x:00008420                 db    0
.xdata$x:00008421                 db    0
.xdata$x:00008422                 db    0
.xdata$x:00008423                 db    0
.xdata$x:00008424                 db    0
.xdata$x:00008425                 db    0
.xdata$x:00008426                 db    0
.xdata$x:00008427                 db    0
.xdata$x:00008427 _xdata$x        ends
.xdata$x:00008427
.xdata$x:00008428 ; ===========================================================================
.xdata$x:00008428
.xdata$x:00008428 ; Segment type: Pure data
.xdata$x:00008428 ; Segment permissions: Read
.xdata$x:00008428 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008428                 assume cs:_xdata$x
.xdata$x:00008428                 ;org 8428h
.xdata$x:00008428 ; COMDAT (pick associative to section at 31D0)
.xdata$x:00008428 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008428                                         ; DATA XREF: .xdata$x:00008438o
.xdata$x:00008429                 db 0FFh
.xdata$x:0000842A                 db 0FFh
.xdata$x:0000842B                 db 0FFh
.xdata$x:0000842C                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00008430 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008430                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00008431                 db    5
.xdata$x:00008432                 db  93h ; ô
.xdata$x:00008433                 db  19h
.xdata$x:00008434                 db    1
.xdata$x:00008435                 db    0
.xdata$x:00008436                 db    0
.xdata$x:00008437                 db    0
.xdata$x:00008438                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:0000843C                 db    0
.xdata$x:0000843D                 db    0
.xdata$x:0000843E                 db    0
.xdata$x:0000843F                 db    0
.xdata$x:00008440                 db    0
.xdata$x:00008441                 db    0
.xdata$x:00008442                 db    0
.xdata$x:00008443                 db    0
.xdata$x:00008444                 db    0
.xdata$x:00008445                 db    0
.xdata$x:00008446                 db    0
.xdata$x:00008447                 db    0
.xdata$x:00008448                 db    0
.xdata$x:00008449                 db    0
.xdata$x:0000844A                 db    0
.xdata$x:0000844B                 db    0
.xdata$x:0000844C                 db    0
.xdata$x:0000844D                 db    0
.xdata$x:0000844E                 db    0
.xdata$x:0000844F                 db    0
.xdata$x:00008450                 db    0
.xdata$x:00008451                 db    0
.xdata$x:00008452                 db    0
.xdata$x:00008453                 db    0
.xdata$x:00008453 _xdata$x        ends
.xdata$x:00008453
.xdata$x:00008454 ; ===========================================================================
.xdata$x:00008454
.xdata$x:00008454 ; Segment type: Pure data
.xdata$x:00008454 ; Segment permissions: Read
.xdata$x:00008454 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008454                 assume cs:_xdata$x
.xdata$x:00008454                 ;org 8454h
.xdata$x:00008454 ; COMDAT (pick associative to section at 4020)
.xdata$x:00008454 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008454                                         ; DATA XREF: .xdata$x:00008464o
.xdata$x:00008455                 db 0FFh
.xdata$x:00008456                 db 0FFh
.xdata$x:00008457                 db 0FFh
.xdata$x:00008458                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:0000845C __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000845C                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:0000845D                 db    5
.xdata$x:0000845E                 db  93h ; ô
.xdata$x:0000845F                 db  19h
.xdata$x:00008460                 db    1
.xdata$x:00008461                 db    0
.xdata$x:00008462                 db    0
.xdata$x:00008463                 db    0
.xdata$x:00008464                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00008468                 align 20h
.xdata$x:00008468 _xdata$x        ends
.xdata$x:00008468
.xdata$x:00008480 ; ===========================================================================
.xdata$x:00008480
.xdata$x:00008480 ; Segment type: Pure data
.xdata$x:00008480 ; Segment permissions: Read
.xdata$x:00008480 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008480                 assume cs:_xdata$x
.xdata$x:00008480                 ;org 8480h
.xdata$x:00008480 ; COMDAT (pick associative to section at 2EC8)
.xdata$x:00008480 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:00008480                                         ; DATA XREF: .xdata$x:00008490o
.xdata$x:00008481                 db 0FFh
.xdata$x:00008482                 db 0FFh
.xdata$x:00008483                 db 0FFh
.xdata$x:00008484                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:00008488 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:00008488                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:00008489                 db    5
.xdata$x:0000848A                 db  93h ; ô
.xdata$x:0000848B                 db  19h
.xdata$x:0000848C                 db    1
.xdata$x:0000848D                 db    0
.xdata$x:0000848E                 db    0
.xdata$x:0000848F                 db    0
.xdata$x:00008490                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:00008494                 db    0
.xdata$x:00008495                 db    0
.xdata$x:00008496                 db    0
.xdata$x:00008497                 db    0
.xdata$x:00008498                 db    0
.xdata$x:00008499                 db    0
.xdata$x:0000849A                 db    0
.xdata$x:0000849B                 db    0
.xdata$x:0000849C                 db    0
.xdata$x:0000849D                 db    0
.xdata$x:0000849E                 db    0
.xdata$x:0000849F                 db    0
.xdata$x:000084A0                 db    0
.xdata$x:000084A1                 db    0
.xdata$x:000084A2                 db    0
.xdata$x:000084A3                 db    0
.xdata$x:000084A4                 db    0
.xdata$x:000084A5                 db    0
.xdata$x:000084A6                 db    0
.xdata$x:000084A7                 db    0
.xdata$x:000084A8                 db    0
.xdata$x:000084A9                 db    0
.xdata$x:000084AA                 db    0
.xdata$x:000084AB                 db    0
.xdata$x:000084AB _xdata$x        ends
.xdata$x:000084AB
.xdata$x:000084AC ; ===========================================================================
.xdata$x:000084AC
.xdata$x:000084AC ; Segment type: Pure data
.xdata$x:000084AC ; Segment permissions: Read
.xdata$x:000084AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000084AC                 assume cs:_xdata$x
.xdata$x:000084AC                 ;org 84ACh
.xdata$x:000084AC ; COMDAT (pick associative to section at 3E58)
.xdata$x:000084AC __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000084AC                                         ; DATA XREF: .xdata$x:000084BCo
.xdata$x:000084AD                 db 0FFh
.xdata$x:000084AE                 db 0FFh
.xdata$x:000084AF                 db 0FFh
.xdata$x:000084B0                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000084B4 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000084B4                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000084B5                 db    5
.xdata$x:000084B6                 db  93h ; ô
.xdata$x:000084B7                 db  19h
.xdata$x:000084B8                 db    1
.xdata$x:000084B9                 db    0
.xdata$x:000084BA                 db    0
.xdata$x:000084BB                 db    0
.xdata$x:000084BC                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:000084C0                 db    0
.xdata$x:000084C1                 db    0
.xdata$x:000084C2                 db    0
.xdata$x:000084C3                 db    0
.xdata$x:000084C4                 db    0
.xdata$x:000084C5                 db    0
.xdata$x:000084C6                 db    0
.xdata$x:000084C7                 db    0
.xdata$x:000084C8                 db    0
.xdata$x:000084C9                 db    0
.xdata$x:000084CA                 db    0
.xdata$x:000084CB                 db    0
.xdata$x:000084CC                 db    0
.xdata$x:000084CD                 db    0
.xdata$x:000084CE                 db    0
.xdata$x:000084CF                 db    0
.xdata$x:000084D0                 db    0
.xdata$x:000084D1                 db    0
.xdata$x:000084D2                 db    0
.xdata$x:000084D3                 db    0
.xdata$x:000084D4                 db    0
.xdata$x:000084D5                 db    0
.xdata$x:000084D6                 db    0
.xdata$x:000084D7                 db    0
.xdata$x:000084D7 _xdata$x        ends
.xdata$x:000084D7
.xdata$x:000084D8 ; ===========================================================================
.xdata$x:000084D8
.xdata$x:000084D8 ; Segment type: Pure data
.xdata$x:000084D8 ; Segment permissions: Read
.xdata$x:000084D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000084D8                 assume cs:_xdata$x
.xdata$x:000084D8                 ;org 84D8h
.xdata$x:000084D8 ; COMDAT (pick associative to section at 3448)
.xdata$x:000084D8 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000084D8                                         ; DATA XREF: .xdata$x:000084E8o
.xdata$x:000084D9                 db 0FFh
.xdata$x:000084DA                 db 0FFh
.xdata$x:000084DB                 db 0FFh
.xdata$x:000084DC                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z$0
.xdata$x:000084E0 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000084E0                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z+11o
.xdata$x:000084E1                 db    5
.xdata$x:000084E2                 db  93h ; ô
.xdata$x:000084E3                 db  19h
.xdata$x:000084E4                 db    1
.xdata$x:000084E5                 db    0
.xdata$x:000084E6                 db    0
.xdata$x:000084E7                 db    0
.xdata$x:000084E8                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@ABV01@@Z
.xdata$x:000084EC                 db    0
.xdata$x:000084ED                 db    0
.xdata$x:000084EE                 db    0
.xdata$x:000084EF                 db    0
.xdata$x:000084F0                 db    0
.xdata$x:000084F1                 db    0
.xdata$x:000084F2                 db    0
.xdata$x:000084F3                 db    0
.xdata$x:000084F4                 db    0
.xdata$x:000084F5                 db    0
.xdata$x:000084F6                 db    0
.xdata$x:000084F7                 db    0
.xdata$x:000084F8                 db    0
.xdata$x:000084F9                 db    0
.xdata$x:000084FA                 db    0
.xdata$x:000084FB                 db    0
.xdata$x:000084FC                 db    0
.xdata$x:000084FD                 db    0
.xdata$x:000084FE                 db    0
.xdata$x:000084FF                 db    0
.xdata$x:00008500                 db    0
.xdata$x:00008501                 db    0
.xdata$x:00008502                 db    0
.xdata$x:00008503                 db    0
.xdata$x:00008503 _xdata$x        ends
.xdata$x:00008503
.xdata$x:00008504 ; ===========================================================================
.xdata$x:00008504
.xdata$x:00008504 ; Segment type: Pure data
.xdata$x:00008504 ; Segment permissions: Read
.xdata$x:00008504 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008504                 assume cs:_xdata$x
.xdata$x:00008504                 ;org 8504h
.xdata$x:00008504 ; COMDAT (pick associative to section at 3590)
.xdata$x:00008504 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00008504                                         ; DATA XREF: .xdata$x:00008514o
.xdata$x:00008505                 db 0FFh
.xdata$x:00008506                 db 0FFh
.xdata$x:00008507                 db 0FFh
.xdata$x:00008508                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:0000850C __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:0000850C                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:0000850D                 db    5
.xdata$x:0000850E                 db  93h ; ô
.xdata$x:0000850F                 db  19h
.xdata$x:00008510                 db    1
.xdata$x:00008511                 db    0
.xdata$x:00008512                 db    0
.xdata$x:00008513                 db    0
.xdata$x:00008514                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00008518                 db    0
.xdata$x:00008519                 db    0
.xdata$x:0000851A                 db    0
.xdata$x:0000851B                 db    0
.xdata$x:0000851C                 db    0
.xdata$x:0000851D                 db    0
.xdata$x:0000851E                 db    0
.xdata$x:0000851F                 db    0
.xdata$x:00008520                 db    0
.xdata$x:00008521                 db    0
.xdata$x:00008522                 db    0
.xdata$x:00008523                 db    0
.xdata$x:00008524                 db    0
.xdata$x:00008525                 db    0
.xdata$x:00008526                 db    0
.xdata$x:00008527                 db    0
.xdata$x:00008528                 db    0
.xdata$x:00008529                 db    0
.xdata$x:0000852A                 db    0
.xdata$x:0000852B                 db    0
.xdata$x:0000852C                 db    0
.xdata$x:0000852D                 db    0
.xdata$x:0000852E                 db    0
.xdata$x:0000852F                 db    0
.xdata$x:0000852F _xdata$x        ends
.xdata$x:0000852F
.xdata$x:00008530 ; ===========================================================================
.xdata$x:00008530
.xdata$x:00008530 ; Segment type: Pure data
.xdata$x:00008530 ; Segment permissions: Read
.xdata$x:00008530 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008530                 assume cs:_xdata$x
.xdata$x:00008530                 ;org 8530h
.xdata$x:00008530 ; COMDAT (pick associative to section at 34F8)
.xdata$x:00008530 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:00008530                                         ; DATA XREF: .xdata$x:00008540o
.xdata$x:00008531                 db 0FFh
.xdata$x:00008532                 db 0FFh
.xdata$x:00008533                 db 0FFh
.xdata$x:00008534                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00008538 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00008538                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00008539                 db    5
.xdata$x:0000853A                 db  93h ; ô
.xdata$x:0000853B                 db  19h
.xdata$x:0000853C                 db    1
.xdata$x:0000853D                 db    0
.xdata$x:0000853E                 db    0
.xdata$x:0000853F                 db    0
.xdata$x:00008540                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:00008544                 db    0
.xdata$x:00008545                 db    0
.xdata$x:00008546                 db    0
.xdata$x:00008547                 db    0
.xdata$x:00008548                 db    0
.xdata$x:00008549                 db    0
.xdata$x:0000854A                 db    0
.xdata$x:0000854B                 db    0
.xdata$x:0000854C                 db    0
.xdata$x:0000854D                 db    0
.xdata$x:0000854E                 db    0
.xdata$x:0000854F                 db    0
.xdata$x:00008550                 db    0
.xdata$x:00008551                 db    0
.xdata$x:00008552                 db    0
.xdata$x:00008553                 db    0
.xdata$x:00008554                 db    0
.xdata$x:00008555                 db    0
.xdata$x:00008556                 db    0
.xdata$x:00008557                 db    0
.xdata$x:00008558                 db    0
.xdata$x:00008559                 db    0
.xdata$x:0000855A                 db    0
.xdata$x:0000855B                 db    0
.xdata$x:0000855B _xdata$x        ends
.xdata$x:0000855B
.xdata$x:0000855C ; ===========================================================================
.xdata$x:0000855C
.xdata$x:0000855C ; Segment type: Pure data
.xdata$x:0000855C ; Segment permissions: Read
.xdata$x:0000855C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000855C                 assume cs:_xdata$x
.xdata$x:0000855C                 ;org 855Ch
.xdata$x:0000855C ; COMDAT (pick associative to section at 33A4)
.xdata$x:0000855C __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:0000855C                                         ; DATA XREF: .xdata$x:0000856Co
.xdata$x:0000855D                 db 0FFh
.xdata$x:0000855E                 db 0FFh
.xdata$x:0000855F                 db 0FFh
.xdata$x:00008560                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z$0
.xdata$x:00008564 __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:00008564                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:00008565                 db    5
.xdata$x:00008566                 db  93h ; ô
.xdata$x:00008567                 db  19h
.xdata$x:00008568                 db    1
.xdata$x:00008569                 db    0
.xdata$x:0000856A                 db    0
.xdata$x:0000856B                 db    0
.xdata$x:0000856C                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@$$QAV01@@Z
.xdata$x:00008570                 db    0
.xdata$x:00008571                 db    0
.xdata$x:00008572                 db    0
.xdata$x:00008573                 db    0
.xdata$x:00008574                 db    0
.xdata$x:00008575                 db    0
.xdata$x:00008576                 db    0
.xdata$x:00008577                 db    0
.xdata$x:00008578                 db    0
.xdata$x:00008579                 db    0
.xdata$x:0000857A                 db    0
.xdata$x:0000857B                 db    0
.xdata$x:0000857C                 db    0
.xdata$x:0000857D                 db    0
.xdata$x:0000857E                 db    0
.xdata$x:0000857F                 db    0
.xdata$x:00008580                 db    0
.xdata$x:00008581                 db    0
.xdata$x:00008582                 db    0
.xdata$x:00008583                 db    0
.xdata$x:00008584                 db    0
.xdata$x:00008585                 db    0
.xdata$x:00008586                 db    0
.xdata$x:00008587                 db    0
.xdata$x:00008587 _xdata$x        ends
.xdata$x:00008587
.xdata$x:00008588 ; ===========================================================================
.xdata$x:00008588
.xdata$x:00008588 ; Segment type: Pure data
.xdata$x:00008588 ; Segment permissions: Read
.xdata$x:00008588 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008588                 assume cs:_xdata$x
.xdata$x:00008588                 ;org 8588h
.xdata$x:00008588 ; COMDAT (pick associative to section at 45BC)
.xdata$x:00008588 __unwindtable$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z db 0FFh
.xdata$x:00008588                                         ; DATA XREF: .xdata$x:000085A0o
.xdata$x:00008589                 db 0FFh
.xdata$x:0000858A                 db 0FFh
.xdata$x:0000858B                 db 0FFh
.xdata$x:0000858C                 dd offset __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$0
.xdata$x:00008590                 db    0
.xdata$x:00008591                 db    0
.xdata$x:00008592                 db    0
.xdata$x:00008593                 db    0
.xdata$x:00008594                 dd offset __unwindfunclet$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z$1
.xdata$x:00008598 __ehfuncinfo$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z db  22h ; "
.xdata$x:00008598                                         ; DATA XREF: __ehhandler$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z+11o
.xdata$x:00008599                 db    5
.xdata$x:0000859A                 db  93h ; ô
.xdata$x:0000859B                 db  19h
.xdata$x:0000859C                 db    2
.xdata$x:0000859D                 db    0
.xdata$x:0000859E                 db    0
.xdata$x:0000859F                 db    0
.xdata$x:000085A0                 dd offset __unwindtable$??4?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@$$QAV01@@Z
.xdata$x:000085A4                 db    0
.xdata$x:000085A5                 db    0
.xdata$x:000085A6                 db    0
.xdata$x:000085A7                 db    0
.xdata$x:000085A8                 db    0
.xdata$x:000085A9                 db    0
.xdata$x:000085AA                 db    0
.xdata$x:000085AB                 db    0
.xdata$x:000085AC                 db    0
.xdata$x:000085AD                 db    0
.xdata$x:000085AE                 db    0
.xdata$x:000085AF                 db    0
.xdata$x:000085B0                 db    0
.xdata$x:000085B1                 db    0
.xdata$x:000085B2                 db    0
.xdata$x:000085B3                 db    0
.xdata$x:000085B4                 db    0
.xdata$x:000085B5                 db    0
.xdata$x:000085B6                 db    0
.xdata$x:000085B7                 db    0
.xdata$x:000085B8                 db    0
.xdata$x:000085B9                 db    0
.xdata$x:000085BA                 db    0
.xdata$x:000085BB                 db    0
.xdata$x:000085BB _xdata$x        ends
.xdata$x:000085BB
.xdata$x:000085BC ; ===========================================================================
.xdata$x:000085BC
.xdata$x:000085BC ; Segment type: Pure data
.xdata$x:000085BC ; Segment permissions: Read
.xdata$x:000085BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000085BC                 assume cs:_xdata$x
.xdata$x:000085BC                 ;org 85BCh
.xdata$x:000085BC ; COMDAT (pick associative to section at 410C)
.xdata$x:000085BC __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:000085BC                                         ; DATA XREF: .xdata$x:000085CCo
.xdata$x:000085BD                 db 0FFh
.xdata$x:000085BE                 db 0FFh
.xdata$x:000085BF                 db 0FFh
.xdata$x:000085C0                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:000085C4 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000085C4                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:000085C5                 db    5
.xdata$x:000085C6                 db  93h ; ô
.xdata$x:000085C7                 db  19h
.xdata$x:000085C8                 db    1
.xdata$x:000085C9                 db    0
.xdata$x:000085CA                 db    0
.xdata$x:000085CB                 db    0
.xdata$x:000085CC                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:000085D0                 db    0
.xdata$x:000085D1                 db    0
.xdata$x:000085D2                 db    0
.xdata$x:000085D3                 db    0
.xdata$x:000085D4                 db    0
.xdata$x:000085D5                 db    0
.xdata$x:000085D6                 db    0
.xdata$x:000085D7                 db    0
.xdata$x:000085D8                 db    0
.xdata$x:000085D9                 db    0
.xdata$x:000085DA                 db    0
.xdata$x:000085DB                 db    0
.xdata$x:000085DC                 db    0
.xdata$x:000085DD                 db    0
.xdata$x:000085DE                 db    0
.xdata$x:000085DF                 db    0
.xdata$x:000085E0                 db    0
.xdata$x:000085E1                 db    0
.xdata$x:000085E2                 db    0
.xdata$x:000085E3                 db    0
.xdata$x:000085E4                 db    0
.xdata$x:000085E5                 db    0
.xdata$x:000085E6                 db    0
.xdata$x:000085E7                 db    0
.xdata$x:000085E7 _xdata$x        ends
.xdata$x:000085E7
.xdata$x:000085E8 ; ===========================================================================
.xdata$x:000085E8
.xdata$x:000085E8 ; Segment type: Pure data
.xdata$x:000085E8 ; Segment permissions: Read
.xdata$x:000085E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000085E8                 assume cs:_xdata$x
.xdata$x:000085E8                 ;org 85E8h
.xdata$x:000085E8 ; COMDAT (pick associative to section at 79E0)
.xdata$x:000085E8 __ehfuncinfo$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z db  22h ; "
.xdata$x:000085E8                                         ; DATA XREF: __ehhandler$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z+14o
.xdata$x:000085E9                 db    5
.xdata$x:000085EA                 db  93h ; ô
.xdata$x:000085EB                 db  19h
.xdata$x:000085EC                 db  0Eh
.xdata$x:000085ED                 db    0
.xdata$x:000085EE                 db    0
.xdata$x:000085EF                 db    0
.xdata$x:000085F0                 dd offset __unwindtable$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z
.xdata$x:000085F4                 db    0
.xdata$x:000085F5                 db    0
.xdata$x:000085F6                 db    0
.xdata$x:000085F7                 db    0
.xdata$x:000085F8                 db    0
.xdata$x:000085F9                 db    0
.xdata$x:000085FA                 db    0
.xdata$x:000085FB                 db    0
.xdata$x:000085FC                 db    0
.xdata$x:000085FD                 db    0
.xdata$x:000085FE                 db    0
.xdata$x:000085FF                 db    0
.xdata$x:00008600                 db    0
.xdata$x:00008601                 db    0
.xdata$x:00008602                 db    0
.xdata$x:00008603                 db    0
.xdata$x:00008604                 db    0
.xdata$x:00008605                 db    0
.xdata$x:00008606                 db    0
.xdata$x:00008607                 db    0
.xdata$x:00008608                 db    0
.xdata$x:00008609                 db    0
.xdata$x:0000860A                 db    0
.xdata$x:0000860B                 db    0
.xdata$x:0000860C __unwindtable$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z db 0FFh
.xdata$x:0000860C                                         ; DATA XREF: .xdata$x:000085F0o
.xdata$x:0000860D                 db 0FFh
.xdata$x:0000860E                 db 0FFh
.xdata$x:0000860F                 db 0FFh
.xdata$x:00008610                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$0
.xdata$x:00008614                 align 8
.xdata$x:00008618                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$1
.xdata$x:0000861C                 db    1
.xdata$x:0000861D                 db    0
.xdata$x:0000861E                 db    0
.xdata$x:0000861F                 db    0
.xdata$x:00008620                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$2
.xdata$x:00008624                 db    2
.xdata$x:00008625                 db    0
.xdata$x:00008626                 db    0
.xdata$x:00008627                 db    0
.xdata$x:00008628                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$3
.xdata$x:0000862C                 db    3
.xdata$x:0000862D                 db    0
.xdata$x:0000862E                 db    0
.xdata$x:0000862F                 db    0
.xdata$x:00008630                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$4
.xdata$x:00008634                 db    4
.xdata$x:00008635                 db    0
.xdata$x:00008636                 db    0
.xdata$x:00008637                 db    0
.xdata$x:00008638                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$5
.xdata$x:0000863C                 db    3
.xdata$x:0000863D                 db    0
.xdata$x:0000863E                 db    0
.xdata$x:0000863F                 db    0
.xdata$x:00008640                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$6
.xdata$x:00008644                 db    6
.xdata$x:00008645                 db    0
.xdata$x:00008646                 db    0
.xdata$x:00008647                 db    0
.xdata$x:00008648                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$7
.xdata$x:0000864C                 db    7
.xdata$x:0000864D                 db    0
.xdata$x:0000864E                 db    0
.xdata$x:0000864F                 db    0
.xdata$x:00008650                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$8
.xdata$x:00008654                 db    3
.xdata$x:00008655                 db    0
.xdata$x:00008656                 db    0
.xdata$x:00008657                 db    0
.xdata$x:00008658                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$9
.xdata$x:0000865C                 db    9
.xdata$x:0000865D                 db    0
.xdata$x:0000865E                 db    0
.xdata$x:0000865F                 db    0
.xdata$x:00008660                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$10
.xdata$x:00008664                 db    3
.xdata$x:00008665                 db    0
.xdata$x:00008666                 db    0
.xdata$x:00008667                 db    0
.xdata$x:00008668                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$11
.xdata$x:0000866C                 db  0Bh
.xdata$x:0000866D                 db    0
.xdata$x:0000866E                 db    0
.xdata$x:0000866F                 db    0
.xdata$x:00008670                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$12
.xdata$x:00008674                 db  0Ch
.xdata$x:00008675                 db    0
.xdata$x:00008676                 db    0
.xdata$x:00008677                 db    0
.xdata$x:00008678                 dd offset __unwindfunclet$?replace@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@1@Z$13
.xdata$x:00008678 _xdata$x        ends
.xdata$x:00008678
.xdata$x:0000867C ; ===========================================================================
.xdata$x:0000867C
.xdata$x:0000867C ; Segment type: Pure data
.xdata$x:0000867C ; Segment permissions: Read
.xdata$x:0000867C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000867C                 assume cs:_xdata$x
.xdata$x:0000867C                 ;org 867Ch
.xdata$x:0000867C ; COMDAT (pick associative to section at 648C)
.xdata$x:0000867C __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000867C                                         ; DATA XREF: .xdata$x:0000868Co
.xdata$x:0000867D                 db 0FFh
.xdata$x:0000867E                 db 0FFh
.xdata$x:0000867F                 db 0FFh
.xdata$x:00008680                 dd offset __unwindfunclet$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:00008684 __ehfuncinfo$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00008684                                         ; DATA XREF: __ehhandler$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:00008685                 db    5
.xdata$x:00008686                 db  93h ; ô
.xdata$x:00008687                 db  19h
.xdata$x:00008688                 db    1
.xdata$x:00008689                 db    0
.xdata$x:0000868A                 db    0
.xdata$x:0000868B                 db    0
.xdata$x:0000868C                 dd offset __unwindtable$?begin@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:00008690                 db    0
.xdata$x:00008691                 db    0
.xdata$x:00008692                 db    0
.xdata$x:00008693                 db    0
.xdata$x:00008694                 db    0
.xdata$x:00008695                 db    0
.xdata$x:00008696                 db    0
.xdata$x:00008697                 db    0
.xdata$x:00008698                 db    0
.xdata$x:00008699                 db    0
.xdata$x:0000869A                 db    0
.xdata$x:0000869B                 db    0
.xdata$x:0000869C                 db    0
.xdata$x:0000869D                 db    0
.xdata$x:0000869E                 db    0
.xdata$x:0000869F                 db    0
.xdata$x:000086A0                 db    0
.xdata$x:000086A1                 db    0
.xdata$x:000086A2                 db    0
.xdata$x:000086A3                 db    0
.xdata$x:000086A4                 db    0
.xdata$x:000086A5                 db    0
.xdata$x:000086A6                 db    0
.xdata$x:000086A7                 db    0
.xdata$x:000086A7 _xdata$x        ends
.xdata$x:000086A7
.xdata$x:000086A8 ; ===========================================================================
.xdata$x:000086A8
.xdata$x:000086A8 ; Segment type: Pure data
.xdata$x:000086A8 ; Segment permissions: Read
.xdata$x:000086A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000086A8                 assume cs:_xdata$x
.xdata$x:000086A8                 ;org 86A8h
.xdata$x:000086A8 ; COMDAT (pick associative to section at 69BC)
.xdata$x:000086A8 __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db 0FFh
.xdata$x:000086A8                                         ; DATA XREF: .xdata$x:000086B8o
.xdata$x:000086A9                 db 0FFh
.xdata$x:000086AA                 db 0FFh
.xdata$x:000086AB                 db 0FFh
.xdata$x:000086AC                 dd offset __unwindfunclet$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ$0
.xdata$x:000086B0 __ehfuncinfo$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000086B0                                         ; DATA XREF: __ehhandler$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ+11o
.xdata$x:000086B1                 db    5
.xdata$x:000086B2                 db  93h ; ô
.xdata$x:000086B3                 db  19h
.xdata$x:000086B4                 db    1
.xdata$x:000086B5                 db    0
.xdata$x:000086B6                 db    0
.xdata$x:000086B7                 db    0
.xdata$x:000086B8                 dd offset __unwindtable$?end@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@XZ
.xdata$x:000086BC                 db    0
.xdata$x:000086BD                 db    0
.xdata$x:000086BE                 db    0
.xdata$x:000086BF                 db    0
.xdata$x:000086C0                 db    0
.xdata$x:000086C1                 db    0
.xdata$x:000086C2                 db    0
.xdata$x:000086C3                 db    0
.xdata$x:000086C4                 db    0
.xdata$x:000086C5                 db    0
.xdata$x:000086C6                 db    0
.xdata$x:000086C7                 db    0
.xdata$x:000086C8                 db    0
.xdata$x:000086C9                 db    0
.xdata$x:000086CA                 db    0
.xdata$x:000086CB                 db    0
.xdata$x:000086CC                 db    0
.xdata$x:000086CD                 db    0
.xdata$x:000086CE                 db    0
.xdata$x:000086CF                 db    0
.xdata$x:000086D0                 db    0
.xdata$x:000086D1                 db    0
.xdata$x:000086D2                 db    0
.xdata$x:000086D3                 db    0
.xdata$x:000086D3 _xdata$x        ends
.xdata$x:000086D3
.xdata$x:000086D4 ; ===========================================================================
.xdata$x:000086D4
.xdata$x:000086D4 ; Segment type: Pure data
.xdata$x:000086D4 ; Segment permissions: Read
.xdata$x:000086D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000086D4                 assume cs:_xdata$x
.xdata$x:000086D4                 ;org 86D4h
.xdata$x:000086D4 ; COMDAT (pick associative to section at 5174)
.xdata$x:000086D4 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000086D4                                         ; DATA XREF: .xdata$x:0000875Co
.xdata$x:000086D5                 db    0
.xdata$x:000086D6                 db    0
.xdata$x:000086D7                 db    0
.xdata$x:000086D8                 db    0
.xdata$x:000086D9                 db    0
.xdata$x:000086DA                 db    0
.xdata$x:000086DB                 db    0
.xdata$x:000086DC                 db    0
.xdata$x:000086DD                 db    0
.xdata$x:000086DE                 db    0
.xdata$x:000086DF                 db    0
.xdata$x:000086E0                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:000086E4 __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000086E4                                         ; DATA XREF: .xdata$x:00008748o
.xdata$x:000086E5                 db    0
.xdata$x:000086E6                 db    0
.xdata$x:000086E7                 db    0
.xdata$x:000086E8                 db    0
.xdata$x:000086E9                 db    0
.xdata$x:000086EA                 db    0
.xdata$x:000086EB                 db    0
.xdata$x:000086EC                 db    0
.xdata$x:000086ED                 db    0
.xdata$x:000086EE                 db    0
.xdata$x:000086EF                 db    0
.xdata$x:000086F0                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:000086F4 __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000086F4                                         ; DATA XREF: .xdata$x:0000871Co
.xdata$x:000086F5                 db 0FFh
.xdata$x:000086F6                 db 0FFh
.xdata$x:000086F7                 db 0FFh
.xdata$x:000086F8                 db    0
.xdata$x:000086F9                 db    0
.xdata$x:000086FA                 db    0
.xdata$x:000086FB                 db    0
.xdata$x:000086FC                 db 0FFh
.xdata$x:000086FD                 db 0FFh
.xdata$x:000086FE                 db 0FFh
.xdata$x:000086FF                 db 0FFh
.xdata$x:00008700                 db    0
.xdata$x:00008701                 db    0
.xdata$x:00008702                 db    0
.xdata$x:00008703                 db    0
.xdata$x:00008704                 db    1
.xdata$x:00008705                 db    0
.xdata$x:00008706                 db    0
.xdata$x:00008707                 db    0
.xdata$x:00008708                 db    0
.xdata$x:00008709                 db    0
.xdata$x:0000870A                 db    0
.xdata$x:0000870B                 db    0
.xdata$x:0000870C                 db    1
.xdata$x:0000870D                 db    0
.xdata$x:0000870E                 db    0
.xdata$x:0000870F                 db    0
.xdata$x:00008710                 db    0
.xdata$x:00008711                 db    0
.xdata$x:00008712                 db    0
.xdata$x:00008713                 db    0
.xdata$x:00008714 __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00008714                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00008715                 db    5
.xdata$x:00008716                 db  93h ; ô
.xdata$x:00008717                 db  19h
.xdata$x:00008718                 db    4
.xdata$x:00008719                 db    0
.xdata$x:0000871A                 db    0
.xdata$x:0000871B                 db    0
.xdata$x:0000871C                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00008720                 db    2
.xdata$x:00008721                 db    0
.xdata$x:00008722                 db    0
.xdata$x:00008723                 db    0
.xdata$x:00008724                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00008728                 db    0
.xdata$x:00008729                 db    0
.xdata$x:0000872A                 db    0
.xdata$x:0000872B                 db    0
.xdata$x:0000872C                 db    0
.xdata$x:0000872D                 db    0
.xdata$x:0000872E                 db    0
.xdata$x:0000872F                 db    0
.xdata$x:00008730                 db    0
.xdata$x:00008731                 db    0
.xdata$x:00008732                 db    0
.xdata$x:00008733                 db    0
.xdata$x:00008734                 db    0
.xdata$x:00008735                 db    0
.xdata$x:00008736                 db    0
.xdata$x:00008737                 db    0
.xdata$x:00008738 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00008738                                         ; DATA XREF: .xdata$x:00008724o
.xdata$x:00008739                 db    0
.xdata$x:0000873A                 db    0
.xdata$x:0000873B                 db    0
.xdata$x:0000873C                 db    2
.xdata$x:0000873D                 db    0
.xdata$x:0000873E                 db    0
.xdata$x:0000873F                 db    0
.xdata$x:00008740                 db    3
.xdata$x:00008741                 db    0
.xdata$x:00008742                 db    0
.xdata$x:00008743                 db    0
.xdata$x:00008744                 db    1
.xdata$x:00008745                 db    0
.xdata$x:00008746                 db    0
.xdata$x:00008747                 db    0
.xdata$x:00008748                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:0000874C                 db    0
.xdata$x:0000874D                 db    0
.xdata$x:0000874E                 db    0
.xdata$x:0000874F                 db    0
.xdata$x:00008750                 db    0
.xdata$x:00008751                 db    0
.xdata$x:00008752                 db    0
.xdata$x:00008753                 db    0
.xdata$x:00008754                 db    3
.xdata$x:00008755                 db    0
.xdata$x:00008756                 db    0
.xdata$x:00008757                 db    0
.xdata$x:00008758                 db    1
.xdata$x:00008759                 db    0
.xdata$x:0000875A                 db    0
.xdata$x:0000875B                 db    0
.xdata$x:0000875C                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:0000875C _xdata$x        ends
.xdata$x:0000875C
.xdata$x:00008760 ; ===========================================================================
.xdata$x:00008760
.xdata$x:00008760 ; Segment type: Pure data
.xdata$x:00008760 ; Segment permissions: Read
.xdata$x:00008760 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008760                 assume cs:_xdata$x
.xdata$x:00008760                 ;org 8760h
.xdata$x:00008760 ; COMDAT (pick associative to section at 5A60)
.xdata$x:00008760 __unwindtable$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z db 0FFh
.xdata$x:00008760                                         ; DATA XREF: .xdata$x:00008778o
.xdata$x:00008761                 db 0FFh
.xdata$x:00008762                 db 0FFh
.xdata$x:00008763                 db 0FFh
.xdata$x:00008764                 dd offset __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$0
.xdata$x:00008768                 db    0
.xdata$x:00008769                 db    0
.xdata$x:0000876A                 db    0
.xdata$x:0000876B                 db    0
.xdata$x:0000876C                 dd offset __unwindfunclet$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z$1
.xdata$x:00008770 __ehfuncinfo$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z db  22h ; "
.xdata$x:00008770                                         ; DATA XREF: __ehhandler$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z+11o
.xdata$x:00008771                 db    5
.xdata$x:00008772                 db  93h ; ô
.xdata$x:00008773                 db  19h
.xdata$x:00008774                 db    2
.xdata$x:00008775                 db    0
.xdata$x:00008776                 db    0
.xdata$x:00008777                 db    0
.xdata$x:00008778                 dd offset __unwindtable$?_Pdif@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@SAIV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@2@0@Z
.xdata$x:0000877C                 db    0
.xdata$x:0000877D                 db    0
.xdata$x:0000877E                 db    0
.xdata$x:0000877F                 db    0
.xdata$x:00008780                 db    0
.xdata$x:00008781                 db    0
.xdata$x:00008782                 db    0
.xdata$x:00008783                 db    0
.xdata$x:00008784                 db    0
.xdata$x:00008785                 db    0
.xdata$x:00008786                 db    0
.xdata$x:00008787                 db    0
.xdata$x:00008788                 db    0
.xdata$x:00008789                 db    0
.xdata$x:0000878A                 db    0
.xdata$x:0000878B                 db    0
.xdata$x:0000878C                 db    0
.xdata$x:0000878D                 db    0
.xdata$x:0000878E                 db    0
.xdata$x:0000878F                 db    0
.xdata$x:00008790                 db    0
.xdata$x:00008791                 db    0
.xdata$x:00008792                 db    0
.xdata$x:00008793                 db    0
.xdata$x:00008793 _xdata$x        ends
.xdata$x:00008793
.xdata$x:00008794 ; ===========================================================================
.xdata$x:00008794
.xdata$x:00008794 ; Segment type: Pure data
.xdata$x:00008794 ; Segment permissions: Read
.xdata$x:00008794 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008794                 assume cs:_xdata$x
.xdata$x:00008794                 ;org 8794h
.xdata$x:00008794 __ehfuncinfo$?run_dlgProc@RunDlg@@MAGHIIJ@Z db  22h ; "
.xdata$x:00008794                                         ; DATA XREF: __ehhandler$?run_dlgProc@RunDlg@@MAGHIIJ@Z+1Eo
.xdata$x:00008795                 db    5
.xdata$x:00008796                 db  93h ; ô
.xdata$x:00008797                 db  19h
.xdata$x:00008798                 db    8
.xdata$x:00008799                 db    0
.xdata$x:0000879A                 db    0
.xdata$x:0000879B                 db    0
.xdata$x:0000879C                 dd offset __unwindtable$?run_dlgProc@RunDlg@@MAGHIIJ@Z
.xdata$x:000087A0                 db    0
.xdata$x:000087A1                 db    0
.xdata$x:000087A2                 db    0
.xdata$x:000087A3                 db    0
.xdata$x:000087A4                 db    0
.xdata$x:000087A5                 db    0
.xdata$x:000087A6                 db    0
.xdata$x:000087A7                 db    0
.xdata$x:000087A8                 db    0
.xdata$x:000087A9                 db    0
.xdata$x:000087AA                 db    0
.xdata$x:000087AB                 db    0
.xdata$x:000087AC                 db    0
.xdata$x:000087AD                 db    0
.xdata$x:000087AE                 db    0
.xdata$x:000087AF                 db    0
.xdata$x:000087B0                 db    0
.xdata$x:000087B1                 db    0
.xdata$x:000087B2                 db    0
.xdata$x:000087B3                 db    0
.xdata$x:000087B4                 db    0
.xdata$x:000087B5                 db    0
.xdata$x:000087B6                 db    0
.xdata$x:000087B7                 db    0
.xdata$x:000087B8 __unwindtable$?run_dlgProc@RunDlg@@MAGHIIJ@Z db 0FFh
.xdata$x:000087B8                                         ; DATA XREF: .xdata$x:0000879Co
.xdata$x:000087B9                 db 0FFh
.xdata$x:000087BA                 db 0FFh
.xdata$x:000087BB                 db 0FFh
.xdata$x:000087BC                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$0
.xdata$x:000087C0                 db 0FFh
.xdata$x:000087C1                 db 0FFh
.xdata$x:000087C2                 db 0FFh
.xdata$x:000087C3                 db 0FFh
.xdata$x:000087C4                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$1
.xdata$x:000087C8                 db    1
.xdata$x:000087C9                 db    0
.xdata$x:000087CA                 db    0
.xdata$x:000087CB                 db    0
.xdata$x:000087CC                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$2
.xdata$x:000087D0                 db    1
.xdata$x:000087D1                 db    0
.xdata$x:000087D2                 db    0
.xdata$x:000087D3                 db    0
.xdata$x:000087D4                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$3
.xdata$x:000087D8                 db 0FFh
.xdata$x:000087D9                 db 0FFh
.xdata$x:000087DA                 db 0FFh
.xdata$x:000087DB                 db 0FFh
.xdata$x:000087DC                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$4
.xdata$x:000087E0                 db    4
.xdata$x:000087E1                 db    0
.xdata$x:000087E2                 db    0
.xdata$x:000087E3                 db    0
.xdata$x:000087E4                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$5
.xdata$x:000087E8                 db    5
.xdata$x:000087E9                 db    0
.xdata$x:000087EA                 db    0
.xdata$x:000087EB                 db    0
.xdata$x:000087EC                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$6
.xdata$x:000087F0                 db    6
.xdata$x:000087F1                 db    0
.xdata$x:000087F2                 db    0
.xdata$x:000087F3                 db    0
.xdata$x:000087F4                 dd offset __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$7
.xdata$x:000087F4 _xdata$x        ends
.xdata$x:000087F4
.xdata$x:000087F8 ; ===========================================================================
.xdata$x:000087F8
.xdata$x:000087F8 ; Segment type: Pure data
.xdata$x:000087F8 ; Segment permissions: Read
.xdata$x:000087F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000087F8                 assume cs:_xdata$x
.xdata$x:000087F8                 ;org 87F8h
.xdata$x:000087F8 ; COMDAT (pick associative to section at 37FC)
.xdata$x:000087F8 __unwindtable$??0Shortcut@@QAE@XZ db 0FFh ; DATA XREF: .xdata$x:00008808o
.xdata$x:000087F9                 db 0FFh
.xdata$x:000087FA                 db 0FFh
.xdata$x:000087FB                 db 0FFh
.xdata$x:000087FC                 dd offset __unwindfunclet$??0Shortcut@@QAE@XZ$0
.xdata$x:00008800 __ehfuncinfo$??0Shortcut@@QAE@XZ db  22h ; "
.xdata$x:00008800                                         ; DATA XREF: __ehhandler$??0Shortcut@@QAE@XZ+11o
.xdata$x:00008801                 db    5
.xdata$x:00008802                 db  93h ; ô
.xdata$x:00008803                 db  19h
.xdata$x:00008804                 db    1
.xdata$x:00008805                 db    0
.xdata$x:00008806                 db    0
.xdata$x:00008807                 db    0
.xdata$x:00008808                 dd offset __unwindtable$??0Shortcut@@QAE@XZ
.xdata$x:0000880C                 db    0
.xdata$x:0000880D                 db    0
.xdata$x:0000880E                 db    0
.xdata$x:0000880F                 db    0
.xdata$x:00008810                 db    0
.xdata$x:00008811                 db    0
.xdata$x:00008812                 db    0
.xdata$x:00008813                 db    0
.xdata$x:00008814                 db    0
.xdata$x:00008815                 db    0
.xdata$x:00008816                 db    0
.xdata$x:00008817                 db    0
.xdata$x:00008818                 db    0
.xdata$x:00008819                 db    0
.xdata$x:0000881A                 db    0
.xdata$x:0000881B                 db    0
.xdata$x:0000881C                 db    0
.xdata$x:0000881D                 db    0
.xdata$x:0000881E                 db    0
.xdata$x:0000881F                 db    0
.xdata$x:00008820                 db    0
.xdata$x:00008821                 db    0
.xdata$x:00008822                 db    0
.xdata$x:00008823                 db    0
.xdata$x:00008823 _xdata$x        ends
.xdata$x:00008823
.xdata$x:00008824 ; ===========================================================================
.xdata$x:00008824
.xdata$x:00008824 ; Segment type: Pure data
.xdata$x:00008824 ; Segment permissions: Read
.xdata$x:00008824 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008824                 assume cs:_xdata$x
.xdata$x:00008824                 ;org 8824h
.xdata$x:00008824 ; COMDAT (pick associative to section at 3754)
.xdata$x:00008824 __unwindtable$??0Shortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:00008824                                         ; DATA XREF: .xdata$x:00008834o
.xdata$x:00008825                 db 0FFh
.xdata$x:00008826                 db 0FFh
.xdata$x:00008827                 db 0FFh
.xdata$x:00008828                 dd offset __unwindfunclet$??0Shortcut@@QAE@ABV0@@Z$0
.xdata$x:0000882C __ehfuncinfo$??0Shortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:0000882C                                         ; DATA XREF: __ehhandler$??0Shortcut@@QAE@ABV0@@Z+11o
.xdata$x:0000882D                 db    5
.xdata$x:0000882E                 db  93h ; ô
.xdata$x:0000882F                 db  19h
.xdata$x:00008830                 db    1
.xdata$x:00008831                 db    0
.xdata$x:00008832                 db    0
.xdata$x:00008833                 db    0
.xdata$x:00008834                 dd offset __unwindtable$??0Shortcut@@QAE@ABV0@@Z
.xdata$x:00008838                 db    0
.xdata$x:00008839                 db    0
.xdata$x:0000883A                 db    0
.xdata$x:0000883B                 db    0
.xdata$x:0000883C                 db    0
.xdata$x:0000883D                 db    0
.xdata$x:0000883E                 db    0
.xdata$x:0000883F                 db    0
.xdata$x:00008840                 db    0
.xdata$x:00008841                 db    0
.xdata$x:00008842                 db    0
.xdata$x:00008843                 db    0
.xdata$x:00008844                 db    0
.xdata$x:00008845                 db    0
.xdata$x:00008846                 db    0
.xdata$x:00008847                 db    0
.xdata$x:00008848                 db    0
.xdata$x:00008849                 db    0
.xdata$x:0000884A                 db    0
.xdata$x:0000884B                 db    0
.xdata$x:0000884C                 db    0
.xdata$x:0000884D                 db    0
.xdata$x:0000884E                 db    0
.xdata$x:0000884F                 db    0
.xdata$x:0000884F _xdata$x        ends
.xdata$x:0000884F
.xdata$x:00008850 ; ===========================================================================
.xdata$x:00008850
.xdata$x:00008850 ; Segment type: Pure data
.xdata$x:00008850 ; Segment permissions: Read
.xdata$x:00008850 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008850                 assume cs:_xdata$x
.xdata$x:00008850                 ;org 8850h
.xdata$x:00008850 ; COMDAT (pick associative to section at 7DE4)
.xdata$x:00008850 __unwindtable$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ db 0FFh
.xdata$x:00008850                                         ; DATA XREF: .xdata$x:00008870o
.xdata$x:00008851                 db 0FFh
.xdata$x:00008852                 db 0FFh
.xdata$x:00008853                 db 0FFh
.xdata$x:00008854                 dd offset __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$2
.xdata$x:00008858                 db    0
.xdata$x:00008859                 db    0
.xdata$x:0000885A                 db    0
.xdata$x:0000885B                 db    0
.xdata$x:0000885C                 dd offset __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$0
.xdata$x:00008860                 db    1
.xdata$x:00008861                 db    0
.xdata$x:00008862                 db    0
.xdata$x:00008863                 db    0
.xdata$x:00008864                 dd offset __unwindfunclet$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ$1
.xdata$x:00008868 __ehfuncinfo$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ db  22h ; "
.xdata$x:00008868                                         ; DATA XREF: __ehhandler$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ+1Bo
.xdata$x:00008869                 db    5
.xdata$x:0000886A                 db  93h ; ô
.xdata$x:0000886B                 db  19h
.xdata$x:0000886C                 db    3
.xdata$x:0000886D                 db    0
.xdata$x:0000886E                 db    0
.xdata$x:0000886F                 db    0
.xdata$x:00008870                 dd offset __unwindtable$?toMenuItemString@Shortcut@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ
.xdata$x:00008874                 db    0
.xdata$x:00008875                 db    0
.xdata$x:00008876                 db    0
.xdata$x:00008877                 db    0
.xdata$x:00008878                 db    0
.xdata$x:00008879                 db    0
.xdata$x:0000887A                 db    0
.xdata$x:0000887B                 db    0
.xdata$x:0000887C                 db    0
.xdata$x:0000887D                 db    0
.xdata$x:0000887E                 db    0
.xdata$x:0000887F                 db    0
.xdata$x:00008880                 db    0
.xdata$x:00008881                 db    0
.xdata$x:00008882                 db    0
.xdata$x:00008883                 db    0
.xdata$x:00008884                 db    0
.xdata$x:00008885                 db    0
.xdata$x:00008886                 db    0
.xdata$x:00008887                 db    0
.xdata$x:00008888                 db    0
.xdata$x:00008889                 db    0
.xdata$x:0000888A                 db    0
.xdata$x:0000888B                 db    0
.xdata$x:0000888B _xdata$x        ends
.xdata$x:0000888B
.xdata$x:0000888C ; ===========================================================================
.xdata$x:0000888C
.xdata$x:0000888C ; Segment type: Pure data
.xdata$x:0000888C ; Segment permissions: Read
.xdata$x:0000888C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000888C                 assume cs:_xdata$x
.xdata$x:0000888C                 ;org 888Ch
.xdata$x:0000888C ; COMDAT (pick associative to section at 41F8)
.xdata$x:0000888C __unwindtable$??1Shortcut@@UAE@XZ db 0FFh ; DATA XREF: .xdata$x:0000889Co
.xdata$x:0000888D                 db 0FFh
.xdata$x:0000888E                 db 0FFh
.xdata$x:0000888F                 db 0FFh
.xdata$x:00008890                 dd offset __unwindfunclet$??1Shortcut@@UAE@XZ$0
.xdata$x:00008894 __ehfuncinfo$??1Shortcut@@UAE@XZ db  22h ; "
.xdata$x:00008894                                         ; DATA XREF: __ehhandler$??1Shortcut@@UAE@XZ+11o
.xdata$x:00008895                 db    5
.xdata$x:00008896                 db  93h ; ô
.xdata$x:00008897                 db  19h
.xdata$x:00008898                 db    1
.xdata$x:00008899                 db    0
.xdata$x:0000889A                 db    0
.xdata$x:0000889B                 db    0
.xdata$x:0000889C                 dd offset __unwindtable$??1Shortcut@@UAE@XZ
.xdata$x:000088A0                 db    0
.xdata$x:000088A1                 db    0
.xdata$x:000088A2                 db    0
.xdata$x:000088A3                 db    0
.xdata$x:000088A4                 db    0
.xdata$x:000088A5                 db    0
.xdata$x:000088A6                 db    0
.xdata$x:000088A7                 db    0
.xdata$x:000088A8                 db    0
.xdata$x:000088A9                 db    0
.xdata$x:000088AA                 db    0
.xdata$x:000088AB                 db    0
.xdata$x:000088AC                 db    0
.xdata$x:000088AD                 db    0
.xdata$x:000088AE                 db    0
.xdata$x:000088AF                 db    0
.xdata$x:000088B0                 db    0
.xdata$x:000088B1                 db    0
.xdata$x:000088B2                 db    0
.xdata$x:000088B3                 db    0
.xdata$x:000088B4                 db    0
.xdata$x:000088B5                 db    0
.xdata$x:000088B6                 db    0
.xdata$x:000088B7                 db    0
.xdata$x:000088B7 _xdata$x        ends
.xdata$x:000088B7
.xdata$x:000088B8 ; ===========================================================================
.xdata$x:000088B8
.xdata$x:000088B8 ; Segment type: Pure data
.xdata$x:000088B8 ; Segment permissions: Read
.xdata$x:000088B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000088B8                 assume cs:_xdata$x
.xdata$x:000088B8                 ;org 88B8h
.xdata$x:000088B8 ; COMDAT (pick associative to section at 36B0)
.xdata$x:000088B8 __unwindtable$??0CommandShortcut@@QAE@VShortcut@@J@Z db 0FFh
.xdata$x:000088B8                                         ; DATA XREF: .xdata$x:000088D0o
.xdata$x:000088B9                 db 0FFh
.xdata$x:000088BA                 db 0FFh
.xdata$x:000088BB                 db 0FFh
.xdata$x:000088BC                 dd offset __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$0
.xdata$x:000088C0                 db    0
.xdata$x:000088C1                 db    0
.xdata$x:000088C2                 db    0
.xdata$x:000088C3                 db    0
.xdata$x:000088C4                 dd offset __unwindfunclet$??0CommandShortcut@@QAE@VShortcut@@J@Z$1
.xdata$x:000088C8 __ehfuncinfo$??0CommandShortcut@@QAE@VShortcut@@J@Z db  22h ; "
.xdata$x:000088C8                                         ; DATA XREF: __ehhandler$??0CommandShortcut@@QAE@VShortcut@@J@Z+11o
.xdata$x:000088C9                 db    5
.xdata$x:000088CA                 db  93h ; ô
.xdata$x:000088CB                 db  19h
.xdata$x:000088CC                 db    2
.xdata$x:000088CD                 db    0
.xdata$x:000088CE                 db    0
.xdata$x:000088CF                 db    0
.xdata$x:000088D0                 dd offset __unwindtable$??0CommandShortcut@@QAE@VShortcut@@J@Z
.xdata$x:000088D4                 db    0
.xdata$x:000088D5                 db    0
.xdata$x:000088D6                 db    0
.xdata$x:000088D7                 db    0
.xdata$x:000088D8                 db    0
.xdata$x:000088D9                 db    0
.xdata$x:000088DA                 db    0
.xdata$x:000088DB                 db    0
.xdata$x:000088DC                 db    0
.xdata$x:000088DD                 db    0
.xdata$x:000088DE                 db    0
.xdata$x:000088DF                 db    0
.xdata$x:000088E0                 db    0
.xdata$x:000088E1                 db    0
.xdata$x:000088E2                 db    0
.xdata$x:000088E3                 db    0
.xdata$x:000088E4                 db    0
.xdata$x:000088E5                 db    0
.xdata$x:000088E6                 db    0
.xdata$x:000088E7                 db    0
.xdata$x:000088E8                 db    0
.xdata$x:000088E9                 db    0
.xdata$x:000088EA                 db    0
.xdata$x:000088EB                 db    0
.xdata$x:000088EB _xdata$x        ends
.xdata$x:000088EB
.xdata$x:000088EC ; ===========================================================================
.xdata$x:000088EC
.xdata$x:000088EC ; Segment type: Pure data
.xdata$x:000088EC ; Segment permissions: Read
.xdata$x:000088EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000088EC                 assume cs:_xdata$x
.xdata$x:000088EC                 ;org 88ECh
.xdata$x:000088EC ; COMDAT (pick associative to section at 4188)
.xdata$x:000088EC __unwindtable$??1CommandShortcut@@UAE@XZ db 0FFh
.xdata$x:000088EC                                         ; DATA XREF: .xdata$x:000088FCo
.xdata$x:000088ED                 db 0FFh
.xdata$x:000088EE                 db 0FFh
.xdata$x:000088EF                 db 0FFh
.xdata$x:000088F0                 dd offset __unwindfunclet$??1CommandShortcut@@UAE@XZ$0
.xdata$x:000088F4 __ehfuncinfo$??1CommandShortcut@@UAE@XZ db  22h ; "
.xdata$x:000088F4                                         ; DATA XREF: __ehhandler$??1CommandShortcut@@UAE@XZ+11o
.xdata$x:000088F5                 db    5
.xdata$x:000088F6                 db  93h ; ô
.xdata$x:000088F7                 db  19h
.xdata$x:000088F8                 db    1
.xdata$x:000088F9                 db    0
.xdata$x:000088FA                 db    0
.xdata$x:000088FB                 db    0
.xdata$x:000088FC                 dd offset __unwindtable$??1CommandShortcut@@UAE@XZ
.xdata$x:00008900                 db    0
.xdata$x:00008901                 db    0
.xdata$x:00008902                 db    0
.xdata$x:00008903                 db    0
.xdata$x:00008904                 db    0
.xdata$x:00008905                 db    0
.xdata$x:00008906                 db    0
.xdata$x:00008907                 db    0
.xdata$x:00008908                 db    0
.xdata$x:00008909                 db    0
.xdata$x:0000890A                 db    0
.xdata$x:0000890B                 db    0
.xdata$x:0000890C                 db    0
.xdata$x:0000890D                 db    0
.xdata$x:0000890E                 db    0
.xdata$x:0000890F                 db    0
.xdata$x:00008910                 db    0
.xdata$x:00008911                 db    0
.xdata$x:00008912                 db    0
.xdata$x:00008913                 db    0
.xdata$x:00008914                 db    0
.xdata$x:00008915                 db    0
.xdata$x:00008916                 db    0
.xdata$x:00008917                 db    0
.xdata$x:00008917 _xdata$x        ends
.xdata$x:00008917
.xdata$x:00008918 ; ===========================================================================
.xdata$x:00008918
.xdata$x:00008918 ; Segment type: Pure data
.xdata$x:00008918 ; Segment permissions: Read
.xdata$x:00008918 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008918                 assume cs:_xdata$x
.xdata$x:00008918                 ;org 8918h
.xdata$x:00008918 ; COMDAT (pick associative to section at 361C)
.xdata$x:00008918 __unwindtable$??0CommandShortcut@@QAE@ABV0@@Z db 0FFh
.xdata$x:00008918                                         ; DATA XREF: .xdata$x:00008928o
.xdata$x:00008919                 db 0FFh
.xdata$x:0000891A                 db 0FFh
.xdata$x:0000891B                 db 0FFh
.xdata$x:0000891C                 dd offset __unwindfunclet$??0CommandShortcut@@QAE@ABV0@@Z$0
.xdata$x:00008920 __ehfuncinfo$??0CommandShortcut@@QAE@ABV0@@Z db  22h ; "
.xdata$x:00008920                                         ; DATA XREF: __ehhandler$??0CommandShortcut@@QAE@ABV0@@Z+11o
.xdata$x:00008921                 db    5
.xdata$x:00008922                 db  93h ; ô
.xdata$x:00008923                 db  19h
.xdata$x:00008924                 db    1
.xdata$x:00008925                 db    0
.xdata$x:00008926                 db    0
.xdata$x:00008927                 db    0
.xdata$x:00008928                 dd offset __unwindtable$??0CommandShortcut@@QAE@ABV0@@Z
.xdata$x:0000892C                 db    0
.xdata$x:0000892D                 db    0
.xdata$x:0000892E                 db    0
.xdata$x:0000892F                 db    0
.xdata$x:00008930                 db    0
.xdata$x:00008931                 db    0
.xdata$x:00008932                 db    0
.xdata$x:00008933                 db    0
.xdata$x:00008934                 db    0
.xdata$x:00008935                 db    0
.xdata$x:00008936                 db    0
.xdata$x:00008937                 db    0
.xdata$x:00008938                 db    0
.xdata$x:00008939                 db    0
.xdata$x:0000893A                 db    0
.xdata$x:0000893B                 db    0
.xdata$x:0000893C                 db    0
.xdata$x:0000893D                 db    0
.xdata$x:0000893E                 db    0
.xdata$x:0000893F                 db    0
.xdata$x:00008940                 db    0
.xdata$x:00008941                 db    0
.xdata$x:00008942                 db    0
.xdata$x:00008943                 db    0
.xdata$x:00008943 _xdata$x        ends
.xdata$x:00008943
.xdata$x:00008944 ; ===========================================================================
.xdata$x:00008944
.xdata$x:00008944 ; Segment type: Pure data
.xdata$x:00008944 ; Segment permissions: Read
.xdata$x:00008944 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008944                 assume cs:_xdata$x
.xdata$x:00008944                 ;org 8944h
.xdata$x:00008944 ; COMDAT (pick associative to section at 39D4)
.xdata$x:00008944 __unwindtable$??0UserCommand@@QAE@VShortcut@@PB_WH@Z db 0FFh
.xdata$x:00008944                                         ; DATA XREF: .xdata$x:0000896Co
.xdata$x:00008945                 db 0FFh
.xdata$x:00008946                 db 0FFh
.xdata$x:00008947                 db 0FFh
.xdata$x:00008948                 dd offset __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$0
.xdata$x:0000894C                 align 10h
.xdata$x:00008950                 dd offset __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$1
.xdata$x:00008954                 align 8
.xdata$x:00008958                 dd offset __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$2
.xdata$x:0000895C                 db    2
.xdata$x:0000895D                 db    0
.xdata$x:0000895E                 db    0
.xdata$x:0000895F                 db    0
.xdata$x:00008960                 dd offset __unwindfunclet$??0UserCommand@@QAE@VShortcut@@PB_WH@Z$3
.xdata$x:00008964 __ehfuncinfo$??0UserCommand@@QAE@VShortcut@@PB_WH@Z db  22h ; "
.xdata$x:00008964                                         ; DATA XREF: __ehhandler$??0UserCommand@@QAE@VShortcut@@PB_WH@Z+11o
.xdata$x:00008965                 db    5
.xdata$x:00008966                 db  93h ; ô
.xdata$x:00008967                 db  19h
.xdata$x:00008968                 db    4
.xdata$x:00008969                 db    0
.xdata$x:0000896A                 db    0
.xdata$x:0000896B                 db    0
.xdata$x:0000896C                 dd offset __unwindtable$??0UserCommand@@QAE@VShortcut@@PB_WH@Z
.xdata$x:00008970                 db    0
.xdata$x:00008971                 db    0
.xdata$x:00008972                 db    0
.xdata$x:00008973                 db    0
.xdata$x:00008974                 db    0
.xdata$x:00008975                 db    0
.xdata$x:00008976                 db    0
.xdata$x:00008977                 db    0
.xdata$x:00008978                 db    0
.xdata$x:00008979                 db    0
.xdata$x:0000897A                 db    0
.xdata$x:0000897B                 db    0
.xdata$x:0000897C                 db    0
.xdata$x:0000897D                 db    0
.xdata$x:0000897E                 db    0
.xdata$x:0000897F                 db    0
.xdata$x:00008980                 db    0
.xdata$x:00008981                 db    0
.xdata$x:00008982                 db    0
.xdata$x:00008983                 db    0
.xdata$x:00008984                 db    0
.xdata$x:00008985                 db    0
.xdata$x:00008986                 db    0
.xdata$x:00008987                 db    0
.xdata$x:00008987 _xdata$x        ends
.xdata$x:00008987
.xdata$x:00008988 ; ===========================================================================
.xdata$x:00008988
.xdata$x:00008988 ; Segment type: Pure data
.xdata$x:00008988 ; Segment permissions: Read
.xdata$x:00008988 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008988                 assume cs:_xdata$x
.xdata$x:00008988                 ;org 8988h
.xdata$x:00008988 ; COMDAT (pick associative to section at 4308)
.xdata$x:00008988 __unwindtable$??1UserCommand@@UAE@XZ db 0FFh
.xdata$x:00008988                                         ; DATA XREF: .xdata$x:000089A0o
.xdata$x:00008989                 db 0FFh
.xdata$x:0000898A                 db 0FFh
.xdata$x:0000898B                 db 0FFh
.xdata$x:0000898C                 dd offset __unwindfunclet$??1UserCommand@@UAE@XZ$0
.xdata$x:00008990                 db    0
.xdata$x:00008991                 db    0
.xdata$x:00008992                 db    0
.xdata$x:00008993                 db    0
.xdata$x:00008994                 dd offset __unwindfunclet$??1UserCommand@@UAE@XZ$1
.xdata$x:00008998 __ehfuncinfo$??1UserCommand@@UAE@XZ db  22h ; "
.xdata$x:00008998                                         ; DATA XREF: __ehhandler$??1UserCommand@@UAE@XZ+11o
.xdata$x:00008999                 db    5
.xdata$x:0000899A                 db  93h ; ô
.xdata$x:0000899B                 db  19h
.xdata$x:0000899C                 db    2
.xdata$x:0000899D                 db    0
.xdata$x:0000899E                 db    0
.xdata$x:0000899F                 db    0
.xdata$x:000089A0                 dd offset __unwindtable$??1UserCommand@@UAE@XZ
.xdata$x:000089A4                 db    0
.xdata$x:000089A5                 db    0
.xdata$x:000089A6                 db    0
.xdata$x:000089A7                 db    0
.xdata$x:000089A8                 db    0
.xdata$x:000089A9                 db    0
.xdata$x:000089AA                 db    0
.xdata$x:000089AB                 db    0
.xdata$x:000089AC                 db    0
.xdata$x:000089AD                 db    0
.xdata$x:000089AE                 db    0
.xdata$x:000089AF                 db    0
.xdata$x:000089B0                 db    0
.xdata$x:000089B1                 db    0
.xdata$x:000089B2                 db    0
.xdata$x:000089B3                 db    0
.xdata$x:000089B4                 db    0
.xdata$x:000089B5                 db    0
.xdata$x:000089B6                 db    0
.xdata$x:000089B7                 db    0
.xdata$x:000089B8                 db    0
.xdata$x:000089B9                 db    0
.xdata$x:000089BA                 db    0
.xdata$x:000089BB                 db    0
.xdata$x:000089BB _xdata$x        ends
.xdata$x:000089BB
.xdata$x:000089BC ; ===========================================================================
.xdata$x:000089BC
.xdata$x:000089BC ; Segment type: Pure data
.xdata$x:000089BC ; Segment permissions: Read
.xdata$x:000089BC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000089BC                 assume cs:_xdata$x
.xdata$x:000089BC                 ;org 89BCh
.xdata$x:000089BC ; COMDAT (pick associative to section at 3924)
.xdata$x:000089BC __unwindtable$??0UserCommand@@QAE@ABV0@@Z db 0FFh
.xdata$x:000089BC                                         ; DATA XREF: .xdata$x:000089D4o
.xdata$x:000089BD                 db 0FFh
.xdata$x:000089BE                 db 0FFh
.xdata$x:000089BF                 db 0FFh
.xdata$x:000089C0                 dd offset __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$0
.xdata$x:000089C4                 align 8
.xdata$x:000089C8                 dd offset __unwindfunclet$??0UserCommand@@QAE@ABV0@@Z$1
.xdata$x:000089CC __ehfuncinfo$??0UserCommand@@QAE@ABV0@@Z db  22h ; "
.xdata$x:000089CC                                         ; DATA XREF: __ehhandler$??0UserCommand@@QAE@ABV0@@Z+11o
.xdata$x:000089CD                 db    5
.xdata$x:000089CE                 db  93h ; ô
.xdata$x:000089CF                 db  19h
.xdata$x:000089D0                 db    2
.xdata$x:000089D1                 db    0
.xdata$x:000089D2                 db    0
.xdata$x:000089D3                 db    0
.xdata$x:000089D4                 dd offset __unwindtable$??0UserCommand@@QAE@ABV0@@Z
.xdata$x:000089D8                 db    0
.xdata$x:000089D9                 db    0
.xdata$x:000089DA                 db    0
.xdata$x:000089DB                 db    0
.xdata$x:000089DC                 db    0
.xdata$x:000089DD                 db    0
.xdata$x:000089DE                 db    0
.xdata$x:000089DF                 db    0
.xdata$x:000089E0                 db    0
.xdata$x:000089E1                 db    0
.xdata$x:000089E2                 db    0
.xdata$x:000089E3                 db    0
.xdata$x:000089E4                 db    0
.xdata$x:000089E5                 db    0
.xdata$x:000089E6                 db    0
.xdata$x:000089E7                 db    0
.xdata$x:000089E8                 db    0
.xdata$x:000089E9                 db    0
.xdata$x:000089EA                 db    0
.xdata$x:000089EB                 db    0
.xdata$x:000089EC                 db    0
.xdata$x:000089ED                 db    0
.xdata$x:000089EE                 db    0
.xdata$x:000089EF                 db    0
.xdata$x:000089EF _xdata$x        ends
.xdata$x:000089EF
.xdata$x:000089F0 ; ===========================================================================
.xdata$x:000089F0
.xdata$x:000089F0 ; Segment type: Pure data
.xdata$x:000089F0 ; Segment permissions: Read
.xdata$x:000089F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000089F0                 assume cs:_xdata$x
.xdata$x:000089F0                 ;org 89F0h
.xdata$x:000089F0 ; COMDAT (pick associative to section at 66D8)
.xdata$x:000089F0 __unwindtable$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z db 0FFh
.xdata$x:000089F0                                         ; DATA XREF: .xdata$x:00008A00o
.xdata$x:000089F1                 db 0FFh
.xdata$x:000089F2                 db 0FFh
.xdata$x:000089F3                 db 0FFh
.xdata$x:000089F4                 dd offset __unwindfunclet$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z$0
.xdata$x:000089F8 __ehfuncinfo$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z db  22h ; "
.xdata$x:000089F8                                         ; DATA XREF: __ehhandler$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z+11o
.xdata$x:000089F9                 db    5
.xdata$x:000089FA                 db  93h ; ô
.xdata$x:000089FB                 db  19h
.xdata$x:000089FC                 db    1
.xdata$x:000089FD                 db    0
.xdata$x:000089FE                 db    0
.xdata$x:000089FF                 db    0
.xdata$x:00008A00                 dd offset __unwindtable$?construct@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@ABV3@@Z
.xdata$x:00008A04                 db    0
.xdata$x:00008A05                 db    0
.xdata$x:00008A06                 db    0
.xdata$x:00008A07                 db    0
.xdata$x:00008A08                 db    0
.xdata$x:00008A09                 db    0
.xdata$x:00008A0A                 db    0
.xdata$x:00008A0B                 db    0
.xdata$x:00008A0C                 db    0
.xdata$x:00008A0D                 db    0
.xdata$x:00008A0E                 db    0
.xdata$x:00008A0F                 db    0
.xdata$x:00008A10                 db    0
.xdata$x:00008A11                 db    0
.xdata$x:00008A12                 db    0
.xdata$x:00008A13                 db    0
.xdata$x:00008A14                 db    0
.xdata$x:00008A15                 db    0
.xdata$x:00008A16                 db    0
.xdata$x:00008A17                 db    0
.xdata$x:00008A18                 db    0
.xdata$x:00008A19                 db    0
.xdata$x:00008A1A                 db    0
.xdata$x:00008A1B                 db    0
.xdata$x:00008A1B _xdata$x        ends
.xdata$x:00008A1B
.xdata$x:00008A1C ; ===========================================================================
.xdata$x:00008A1C
.xdata$x:00008A1C ; Segment type: Pure data
.xdata$x:00008A1C ; Segment permissions: Read
.xdata$x:00008A1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008A1C                 assume cs:_xdata$x
.xdata$x:00008A1C                 ;org 8A1Ch
.xdata$x:00008A1C ; COMDAT (pick associative to section at 5B0C)
.xdata$x:00008A1C __catchsym$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00008A1C                                         ; DATA XREF: .xdata$x:00008A4Co
.xdata$x:00008A1D                 db    0
.xdata$x:00008A1E                 db    0
.xdata$x:00008A1F                 db    0
.xdata$x:00008A20                 db    0
.xdata$x:00008A21                 db    0
.xdata$x:00008A22                 db    0
.xdata$x:00008A23                 db    0
.xdata$x:00008A24                 db    0
.xdata$x:00008A25                 db    0
.xdata$x:00008A26                 db    0
.xdata$x:00008A27                 db    0
.xdata$x:00008A28                 dd offset __catch$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z$0
.xdata$x:00008A2C __unwindtable$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00008A2C                                         ; DATA XREF: .xdata$x:00008A58o
.xdata$x:00008A2D                 db 0FFh
.xdata$x:00008A2E                 db 0FFh
.xdata$x:00008A2F                 db 0FFh
.xdata$x:00008A30                 db    0
.xdata$x:00008A31                 db    0
.xdata$x:00008A32                 db    0
.xdata$x:00008A33                 db    0
.xdata$x:00008A34                 db 0FFh
.xdata$x:00008A35                 db 0FFh
.xdata$x:00008A36                 db 0FFh
.xdata$x:00008A37                 db 0FFh
.xdata$x:00008A38                 db    0
.xdata$x:00008A39                 db    0
.xdata$x:00008A3A                 db    0
.xdata$x:00008A3B                 db    0
.xdata$x:00008A3C __tryblocktable$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z db    0
.xdata$x:00008A3C                                         ; DATA XREF: .xdata$x:00008A60o
.xdata$x:00008A3D                 db    0
.xdata$x:00008A3E                 db    0
.xdata$x:00008A3F                 db    0
.xdata$x:00008A40                 db    0
.xdata$x:00008A41                 db    0
.xdata$x:00008A42                 db    0
.xdata$x:00008A43                 db    0
.xdata$x:00008A44                 db    1
.xdata$x:00008A45                 db    0
.xdata$x:00008A46                 db    0
.xdata$x:00008A47                 db    0
.xdata$x:00008A48                 db    1
.xdata$x:00008A49                 db    0
.xdata$x:00008A4A                 db    0
.xdata$x:00008A4B                 db    0
.xdata$x:00008A4C                 dd offset __catchsym$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z$2
.xdata$x:00008A50 __ehfuncinfo$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:00008A50                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z+11o
.xdata$x:00008A51                 db    5
.xdata$x:00008A52                 db  93h ; ô
.xdata$x:00008A53                 db  19h
.xdata$x:00008A54                 db    2
.xdata$x:00008A55                 db    0
.xdata$x:00008A56                 db    0
.xdata$x:00008A57                 db    0
.xdata$x:00008A58                 dd offset __unwindtable$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.xdata$x:00008A5C                 db    1
.xdata$x:00008A5D                 db    0
.xdata$x:00008A5E                 db    0
.xdata$x:00008A5F                 db    0
.xdata$x:00008A60                 dd offset __tryblocktable$?_Reallocate@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IAEXI@Z
.xdata$x:00008A64                 db    0
.xdata$x:00008A65                 db    0
.xdata$x:00008A66                 db    0
.xdata$x:00008A67                 db    0
.xdata$x:00008A68                 db    0
.xdata$x:00008A69                 db    0
.xdata$x:00008A6A                 db    0
.xdata$x:00008A6B                 db    0
.xdata$x:00008A6C                 db    0
.xdata$x:00008A6D                 db    0
.xdata$x:00008A6E                 db    0
.xdata$x:00008A6F                 db    0
.xdata$x:00008A70                 db    0
.xdata$x:00008A71                 db    0
.xdata$x:00008A72                 db    0
.xdata$x:00008A73                 db    0
.xdata$x:00008A73 _xdata$x        ends
.xdata$x:00008A73
.xdata$x:00008A74 ; ===========================================================================
.xdata$x:00008A74
.xdata$x:00008A74 ; Segment type: Pure data
.xdata$x:00008A74 ; Segment permissions: Read
.xdata$x:00008A74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008A74                 assume cs:_xdata$x
.xdata$x:00008A74                 ;org 8A74h
.xdata$x:00008A74 ; COMDAT (pick associative to section at 5984)
.xdata$x:00008A74 __unwindtable$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z db 0FFh
.xdata$x:00008A74                                         ; DATA XREF: .xdata$x:00008A84o
.xdata$x:00008A75                 db 0FFh
.xdata$x:00008A76                 db 0FFh
.xdata$x:00008A77                 db 0FFh
.xdata$x:00008A78                 dd offset __unwindfunclet$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z$0
.xdata$x:00008A7C __ehfuncinfo$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z db  22h ; "
.xdata$x:00008A7C                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z+11o
.xdata$x:00008A7D                 db    5
.xdata$x:00008A7E                 db  93h ; ô
.xdata$x:00008A7F                 db  19h
.xdata$x:00008A80                 db    1
.xdata$x:00008A81                 db    0
.xdata$x:00008A82                 db    0
.xdata$x:00008A83                 db    0
.xdata$x:00008A84                 dd offset __unwindtable$?_Orphan_range@?$vector@VUserCommand@@V?$allocator@VUserCommand@@@std@@@std@@IBEXPAVUserCommand@@0@Z
.xdata$x:00008A88                 align 20h
.xdata$x:00008A88 _xdata$x        ends
.xdata$x:00008A88
.xdata$x:00008AA0 ; ===========================================================================
.xdata$x:00008AA0
.xdata$x:00008AA0 ; Segment type: Pure data
.xdata$x:00008AA0 ; Segment permissions: Read
.xdata$x:00008AA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008AA0                 assume cs:_xdata$x
.xdata$x:00008AA0                 ;org 8AA0h
.xdata$x:00008AA0 ; COMDAT (pick associative to section at 202C)
.xdata$x:00008AA0 __unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z db 0FFh
.xdata$x:00008AA0                                         ; DATA XREF: .xdata$x:00008AB8o
.xdata$x:00008AA1                 db 0FFh
.xdata$x:00008AA2                 db 0FFh
.xdata$x:00008AA3                 db 0FFh
.xdata$x:00008AA4                 dd offset __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$1
.xdata$x:00008AA8                 db    0
.xdata$x:00008AA9                 db    0
.xdata$x:00008AAA                 db    0
.xdata$x:00008AAB                 db    0
.xdata$x:00008AAC                 dd offset __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z$0
.xdata$x:00008AB0 __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z db  22h ; "
.xdata$x:00008AB0                                         ; DATA XREF: __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z+1Bo
.xdata$x:00008AB1                 db    5
.xdata$x:00008AB2                 db  93h ; ô
.xdata$x:00008AB3                 db  19h
.xdata$x:00008AB4                 db    2
.xdata$x:00008AB5                 db    0
.xdata$x:00008AB6                 db    0
.xdata$x:00008AB7                 db    0
.xdata$x:00008AB8                 dd offset __unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@PB_WABV10@@Z
.xdata$x:00008ABC                 db    0
.xdata$x:00008ABD                 db    0
.xdata$x:00008ABE                 db    0
.xdata$x:00008ABF                 db    0
.xdata$x:00008AC0                 db    0
.xdata$x:00008AC1                 db    0
.xdata$x:00008AC2                 db    0
.xdata$x:00008AC3                 db    0
.xdata$x:00008AC4                 db    0
.xdata$x:00008AC5                 db    0
.xdata$x:00008AC6                 db    0
.xdata$x:00008AC7                 db    0
.xdata$x:00008AC8                 db    0
.xdata$x:00008AC9                 db    0
.xdata$x:00008ACA                 db    0
.xdata$x:00008ACB                 db    0
.xdata$x:00008ACC                 db    0
.xdata$x:00008ACD                 db    0
.xdata$x:00008ACE                 db    0
.xdata$x:00008ACF                 db    0
.xdata$x:00008AD0                 db    0
.xdata$x:00008AD1                 db    0
.xdata$x:00008AD2                 db    0
.xdata$x:00008AD3                 db    0
.xdata$x:00008AD3 _xdata$x        ends
.xdata$x:00008AD3
.xdata$x:00008AD4 ; ===========================================================================
.xdata$x:00008AD4
.xdata$x:00008AD4 ; Segment type: Pure data
.xdata$x:00008AD4 ; Segment permissions: Read
.xdata$x:00008AD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008AD4                 assume cs:_xdata$x
.xdata$x:00008AD4                 ;org 8AD4h
.xdata$x:00008AD4 ; COMDAT (pick associative to section at 1F8C)
.xdata$x:00008AD4 __unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z db 0FFh
.xdata$x:00008AD4                                         ; DATA XREF: .xdata$x:00008AE4o
.xdata$x:00008AD5                 db 0FFh
.xdata$x:00008AD6                 db 0FFh
.xdata$x:00008AD7                 db 0FFh
.xdata$x:00008AD8                 dd offset __unwindfunclet$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z$0
.xdata$x:00008ADC __ehfuncinfo$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z db  22h ; "
.xdata$x:00008ADC                                         ; DATA XREF: __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z+11o
.xdata$x:00008ADD                 db    5
.xdata$x:00008ADE                 db  93h ; ô
.xdata$x:00008ADF                 db  19h
.xdata$x:00008AE0                 db    1
.xdata$x:00008AE1                 db    0
.xdata$x:00008AE2                 db    0
.xdata$x:00008AE3                 db    0
.xdata$x:00008AE4                 dd offset __unwindtable$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z
.xdata$x:00008AE8                 align 20h
.xdata$x:00008AE8 _xdata$x        ends
.xdata$x:00008AE8
.xdata$x:00008B00 ; ===========================================================================
.xdata$x:00008B00
.xdata$x:00008B00 ; Segment type: Pure data
.xdata$x:00008B00 ; Segment permissions: Read
.xdata$x:00008B00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B00                 assume cs:_xdata$x
.xdata$x:00008B00                 ;org 8B00h
.xdata$x:00008B00 ; COMDAT (pick associative to section at 2DD8)
.xdata$x:00008B00 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00008B00                                         ; DATA XREF: .xdata$x:00008B10o
.xdata$x:00008B01                 db 0FFh
.xdata$x:00008B02                 db 0FFh
.xdata$x:00008B03                 db 0FFh
.xdata$x:00008B04                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00008B08 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00008B08                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00008B09                 db    5
.xdata$x:00008B0A                 db  93h ; ô
.xdata$x:00008B0B                 db  19h
.xdata$x:00008B0C                 db    1
.xdata$x:00008B0D                 db    0
.xdata$x:00008B0E                 db    0
.xdata$x:00008B0F                 db    0
.xdata$x:00008B10                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00008B14                 db    0
.xdata$x:00008B15                 db    0
.xdata$x:00008B16                 db    0
.xdata$x:00008B17                 db    0
.xdata$x:00008B18                 db    0
.xdata$x:00008B19                 db    0
.xdata$x:00008B1A                 db    0
.xdata$x:00008B1B                 db    0
.xdata$x:00008B1C                 db    0
.xdata$x:00008B1D                 db    0
.xdata$x:00008B1E                 db    0
.xdata$x:00008B1F                 db    0
.xdata$x:00008B20                 db    0
.xdata$x:00008B21                 db    0
.xdata$x:00008B22                 db    0
.xdata$x:00008B23                 db    0
.xdata$x:00008B24                 db    0
.xdata$x:00008B25                 db    0
.xdata$x:00008B26                 db    0
.xdata$x:00008B27                 db    0
.xdata$x:00008B28                 db    0
.xdata$x:00008B29                 db    0
.xdata$x:00008B2A                 db    0
.xdata$x:00008B2B                 db    0
.xdata$x:00008B2B _xdata$x        ends
.xdata$x:00008B2B
.xdata$x:00008B2C ; ===========================================================================
.xdata$x:00008B2C
.xdata$x:00008B2C ; Segment type: Pure data
.xdata$x:00008B2C ; Segment permissions: Read
.xdata$x:00008B2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B2C                 assume cs:_xdata$x
.xdata$x:00008B2C                 ;org 8B2Ch
.xdata$x:00008B2C ; COMDAT (pick associative to section at 3D70)
.xdata$x:00008B2C __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00008B2C                                         ; DATA XREF: .xdata$x:00008B3Co
.xdata$x:00008B2D                 db 0FFh
.xdata$x:00008B2E                 db 0FFh
.xdata$x:00008B2F                 db 0FFh
.xdata$x:00008B30                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00008B34 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00008B34                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00008B35                 db    5
.xdata$x:00008B36                 db  93h ; ô
.xdata$x:00008B37                 db  19h
.xdata$x:00008B38                 db    1
.xdata$x:00008B39                 db    0
.xdata$x:00008B3A                 db    0
.xdata$x:00008B3B                 db    0
.xdata$x:00008B3C                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00008B40                 db    0
.xdata$x:00008B41                 db    0
.xdata$x:00008B42                 db    0
.xdata$x:00008B43                 db    0
.xdata$x:00008B44                 db    0
.xdata$x:00008B45                 db    0
.xdata$x:00008B46                 db    0
.xdata$x:00008B47                 db    0
.xdata$x:00008B48                 db    0
.xdata$x:00008B49                 db    0
.xdata$x:00008B4A                 db    0
.xdata$x:00008B4B                 db    0
.xdata$x:00008B4C                 db    0
.xdata$x:00008B4D                 db    0
.xdata$x:00008B4E                 db    0
.xdata$x:00008B4F                 db    0
.xdata$x:00008B50                 db    0
.xdata$x:00008B51                 db    0
.xdata$x:00008B52                 db    0
.xdata$x:00008B53                 db    0
.xdata$x:00008B54                 db    0
.xdata$x:00008B55                 db    0
.xdata$x:00008B56                 db    0
.xdata$x:00008B57                 db    0
.xdata$x:00008B57 _xdata$x        ends
.xdata$x:00008B57
.xdata$x:00008B58 ; ===========================================================================
.xdata$x:00008B58
.xdata$x:00008B58 ; Segment type: Pure data
.xdata$x:00008B58 ; Segment permissions: Read
.xdata$x:00008B58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B58                 assume cs:_xdata$x
.xdata$x:00008B58                 ;org 8B58h
.xdata$x:00008B58 ; COMDAT (pick associative to section at 2D60)
.xdata$x:00008B58 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00008B58                                         ; DATA XREF: .xdata$x:00008B68o
.xdata$x:00008B59                 db 0FFh
.xdata$x:00008B5A                 db 0FFh
.xdata$x:00008B5B                 db 0FFh
.xdata$x:00008B5C                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00008B60 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00008B60                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00008B61                 db    5
.xdata$x:00008B62                 db  93h ; ô
.xdata$x:00008B63                 db  19h
.xdata$x:00008B64                 db    1
.xdata$x:00008B65                 db    0
.xdata$x:00008B66                 db    0
.xdata$x:00008B67                 db    0
.xdata$x:00008B68                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@_WHPB_WAB_WU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00008B6C                 db    0
.xdata$x:00008B6D                 db    0
.xdata$x:00008B6E                 db    0
.xdata$x:00008B6F                 db    0
.xdata$x:00008B70                 db    0
.xdata$x:00008B71                 db    0
.xdata$x:00008B72                 db    0
.xdata$x:00008B73                 db    0
.xdata$x:00008B74                 db    0
.xdata$x:00008B75                 db    0
.xdata$x:00008B76                 db    0
.xdata$x:00008B77                 db    0
.xdata$x:00008B78                 db    0
.xdata$x:00008B79                 db    0
.xdata$x:00008B7A                 db    0
.xdata$x:00008B7B                 db    0
.xdata$x:00008B7C                 db    0
.xdata$x:00008B7D                 db    0
.xdata$x:00008B7E                 db    0
.xdata$x:00008B7F                 db    0
.xdata$x:00008B80                 db    0
.xdata$x:00008B81                 db    0
.xdata$x:00008B82                 db    0
.xdata$x:00008B83                 db    0
.xdata$x:00008B83 _xdata$x        ends
.xdata$x:00008B83
.xdata$x:00008B84 ; ===========================================================================
.xdata$x:00008B84
.xdata$x:00008B84 ; Segment type: Pure data
.xdata$x:00008B84 ; Segment permissions: Read
.xdata$x:00008B84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008B84                 assume cs:_xdata$x
.xdata$x:00008B84                 ;org 8B84h
.xdata$x:00008B84 ; COMDAT (pick associative to section at 2FC8)
.xdata$x:00008B84 __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00008B84                                         ; DATA XREF: .xdata$x:00008B94o
.xdata$x:00008B85                 db 0FFh
.xdata$x:00008B86                 db 0FFh
.xdata$x:00008B87                 db 0FFh
.xdata$x:00008B88                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z$0
.xdata$x:00008B8C __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00008B8C                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z+11o
.xdata$x:00008B8D                 db    5
.xdata$x:00008B8E                 db  93h ; ô
.xdata$x:00008B8F                 db  19h
.xdata$x:00008B90                 db    1
.xdata$x:00008B91                 db    0
.xdata$x:00008B92                 db    0
.xdata$x:00008B93                 db    0
.xdata$x:00008B94                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PB_WPBU_Container_base12@1@@Z
.xdata$x:00008B98                 db    0
.xdata$x:00008B99                 db    0
.xdata$x:00008B9A                 db    0
.xdata$x:00008B9B                 db    0
.xdata$x:00008B9C                 db    0
.xdata$x:00008B9D                 db    0
.xdata$x:00008B9E                 db    0
.xdata$x:00008B9F                 db    0
.xdata$x:00008BA0                 db    0
.xdata$x:00008BA1                 db    0
.xdata$x:00008BA2                 db    0
.xdata$x:00008BA3                 db    0
.xdata$x:00008BA4                 db    0
.xdata$x:00008BA5                 db    0
.xdata$x:00008BA6                 db    0
.xdata$x:00008BA7                 db    0
.xdata$x:00008BA8                 db    0
.xdata$x:00008BA9                 db    0
.xdata$x:00008BAA                 db    0
.xdata$x:00008BAB                 db    0
.xdata$x:00008BAC                 db    0
.xdata$x:00008BAD                 db    0
.xdata$x:00008BAE                 db    0
.xdata$x:00008BAF                 db    0
.xdata$x:00008BAF _xdata$x        ends
.xdata$x:00008BAF
.xdata$x:00008BB0 ; ===========================================================================
.xdata$x:00008BB0
.xdata$x:00008BB0 ; Segment type: Pure data
.xdata$x:00008BB0 ; Segment permissions: Read
.xdata$x:00008BB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008BB0                 assume cs:_xdata$x
.xdata$x:00008BB0                 ;org 8BB0h
.xdata$x:00008BB0 ; COMDAT (pick associative to section at 3ED0)
.xdata$x:00008BB0 __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008BB0                                         ; DATA XREF: .xdata$x:00008BC0o
.xdata$x:00008BB1                 db 0FFh
.xdata$x:00008BB2                 db 0FFh
.xdata$x:00008BB3                 db 0FFh
.xdata$x:00008BB4                 dd offset __unwindfunclet$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00008BB8 __ehfuncinfo$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008BB8                                         ; DATA XREF: __ehhandler$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00008BB9                 db    5
.xdata$x:00008BBA                 db  93h ; ô
.xdata$x:00008BBB                 db  19h
.xdata$x:00008BBC                 db    1
.xdata$x:00008BBD                 db    0
.xdata$x:00008BBE                 db    0
.xdata$x:00008BBF                 db    0
.xdata$x:00008BC0                 dd offset __unwindtable$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00008BC4                 db    0
.xdata$x:00008BC5                 db    0
.xdata$x:00008BC6                 db    0
.xdata$x:00008BC7                 db    0
.xdata$x:00008BC8                 db    0
.xdata$x:00008BC9                 db    0
.xdata$x:00008BCA                 db    0
.xdata$x:00008BCB                 db    0
.xdata$x:00008BCC                 db    0
.xdata$x:00008BCD                 db    0
.xdata$x:00008BCE                 db    0
.xdata$x:00008BCF                 db    0
.xdata$x:00008BD0                 db    0
.xdata$x:00008BD1                 db    0
.xdata$x:00008BD2                 db    0
.xdata$x:00008BD3                 db    0
.xdata$x:00008BD4                 db    0
.xdata$x:00008BD5                 db    0
.xdata$x:00008BD6                 db    0
.xdata$x:00008BD7                 db    0
.xdata$x:00008BD8                 db    0
.xdata$x:00008BD9                 db    0
.xdata$x:00008BDA                 db    0
.xdata$x:00008BDB                 db    0
.xdata$x:00008BDB _xdata$x        ends
.xdata$x:00008BDB
.xdata$x:00008BDC ; ===========================================================================
.xdata$x:00008BDC
.xdata$x:00008BDC ; Segment type: Pure data
.xdata$x:00008BDC ; Segment permissions: Read
.xdata$x:00008BDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008BDC                 assume cs:_xdata$x
.xdata$x:00008BDC                 ;org 8BDCh
.xdata$x:00008BDC ; COMDAT (pick associative to section at 2F44)
.xdata$x:00008BDC __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00008BDC                                         ; DATA XREF: .xdata$x:00008BECo
.xdata$x:00008BDD                 db 0FFh
.xdata$x:00008BDE                 db 0FFh
.xdata$x:00008BDF                 db 0FFh
.xdata$x:00008BE0                 dd offset __unwindfunclet$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00008BE4 __ehfuncinfo$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00008BE4                                         ; DATA XREF: __ehhandler$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00008BE5                 db    5
.xdata$x:00008BE6                 db  93h ; ô
.xdata$x:00008BE7                 db  19h
.xdata$x:00008BE8                 db    1
.xdata$x:00008BE9                 db    0
.xdata$x:00008BEA                 db    0
.xdata$x:00008BEB                 db    0
.xdata$x:00008BEC                 dd offset __unwindtable$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00008BF0                 db    0
.xdata$x:00008BF1                 db    0
.xdata$x:00008BF2                 db    0
.xdata$x:00008BF3                 db    0
.xdata$x:00008BF4                 db    0
.xdata$x:00008BF5                 db    0
.xdata$x:00008BF6                 db    0
.xdata$x:00008BF7                 db    0
.xdata$x:00008BF8                 db    0
.xdata$x:00008BF9                 db    0
.xdata$x:00008BFA                 db    0
.xdata$x:00008BFB                 db    0
.xdata$x:00008BFC                 db    0
.xdata$x:00008BFD                 db    0
.xdata$x:00008BFE                 db    0
.xdata$x:00008BFF                 db    0
.xdata$x:00008C00                 db    0
.xdata$x:00008C01                 db    0
.xdata$x:00008C02                 db    0
.xdata$x:00008C03                 db    0
.xdata$x:00008C04                 db    0
.xdata$x:00008C05                 db    0
.xdata$x:00008C06                 db    0
.xdata$x:00008C07                 db    0
.xdata$x:00008C07 _xdata$x        ends
.xdata$x:00008C07
.xdata$x:00008C08 ; ===========================================================================
.xdata$x:00008C08
.xdata$x:00008C08 ; Segment type: Pure data
.xdata$x:00008C08 ; Segment permissions: Read
.xdata$x:00008C08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C08                 assume cs:_xdata$x
.xdata$x:00008C08                 ;org 8C08h
.xdata$x:00008C08 ; COMDAT (pick associative to section at 30CC)
.xdata$x:00008C08 __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00008C08                                         ; DATA XREF: .xdata$x:00008C18o
.xdata$x:00008C09                 db 0FFh
.xdata$x:00008C0A                 db 0FFh
.xdata$x:00008C0B                 db 0FFh
.xdata$x:00008C0C                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z$0
.xdata$x:00008C10 __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00008C10                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z+11o
.xdata$x:00008C11                 db    5
.xdata$x:00008C12                 db  93h ; ô
.xdata$x:00008C13                 db  19h
.xdata$x:00008C14                 db    1
.xdata$x:00008C15                 db    0
.xdata$x:00008C16                 db    0
.xdata$x:00008C17                 db    0
.xdata$x:00008C18                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@PA_WPBU_Container_base12@1@@Z
.xdata$x:00008C1C                 db    0
.xdata$x:00008C1D                 db    0
.xdata$x:00008C1E                 db    0
.xdata$x:00008C1F                 db    0
.xdata$x:00008C20                 db    0
.xdata$x:00008C21                 db    0
.xdata$x:00008C22                 db    0
.xdata$x:00008C23                 db    0
.xdata$x:00008C24                 db    0
.xdata$x:00008C25                 db    0
.xdata$x:00008C26                 db    0
.xdata$x:00008C27                 db    0
.xdata$x:00008C28                 db    0
.xdata$x:00008C29                 db    0
.xdata$x:00008C2A                 db    0
.xdata$x:00008C2B                 db    0
.xdata$x:00008C2C                 db    0
.xdata$x:00008C2D                 db    0
.xdata$x:00008C2E                 db    0
.xdata$x:00008C2F                 db    0
.xdata$x:00008C30                 db    0
.xdata$x:00008C31                 db    0
.xdata$x:00008C32                 db    0
.xdata$x:00008C33                 db    0
.xdata$x:00008C33 _xdata$x        ends
.xdata$x:00008C33
.xdata$x:00008C34 ; ===========================================================================
.xdata$x:00008C34
.xdata$x:00008C34 ; Segment type: Pure data
.xdata$x:00008C34 ; Segment permissions: Read
.xdata$x:00008C34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C34                 assume cs:_xdata$x
.xdata$x:00008C34                 ;org 8C34h
.xdata$x:00008C34 ; COMDAT (pick associative to section at 4978)
.xdata$x:00008C34 __unwindtable$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db 0FFh
.xdata$x:00008C34                                         ; DATA XREF: .xdata$x:00008C44o
.xdata$x:00008C35                 db 0FFh
.xdata$x:00008C36                 db 0FFh
.xdata$x:00008C37                 db 0FFh
.xdata$x:00008C38                 dd offset __unwindfunclet$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z$0
.xdata$x:00008C3C __ehfuncinfo$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z db  22h ; "
.xdata$x:00008C3C                                         ; DATA XREF: __ehhandler$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z+11o
.xdata$x:00008C3D                 db    5
.xdata$x:00008C3E                 db  93h ; ô
.xdata$x:00008C3F                 db  19h
.xdata$x:00008C40                 db    1
.xdata$x:00008C41                 db    0
.xdata$x:00008C42                 db    0
.xdata$x:00008C43                 db    0
.xdata$x:00008C44                 dd offset __unwindtable$??G?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@@Z
.xdata$x:00008C48                 align 20h
.xdata$x:00008C48 _xdata$x        ends
.xdata$x:00008C48
.xdata$x:00008C60 ; ===========================================================================
.xdata$x:00008C60
.xdata$x:00008C60 ; Segment type: Pure data
.xdata$x:00008C60 ; Segment permissions: Read
.xdata$x:00008C60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C60                 assume cs:_xdata$x
.xdata$x:00008C60                 ;org 8C60h
.xdata$x:00008C60 ; COMDAT (pick associative to section at 3F40)
.xdata$x:00008C60 __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008C60                                         ; DATA XREF: .xdata$x:00008C70o
.xdata$x:00008C61                 db 0FFh
.xdata$x:00008C62                 db 0FFh
.xdata$x:00008C63                 db 0FFh
.xdata$x:00008C64                 dd offset __unwindfunclet$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00008C68 __ehfuncinfo$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008C68                                         ; DATA XREF: __ehhandler$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00008C69                 db    5
.xdata$x:00008C6A                 db  93h ; ô
.xdata$x:00008C6B                 db  19h
.xdata$x:00008C6C                 db    1
.xdata$x:00008C6D                 db    0
.xdata$x:00008C6E                 db    0
.xdata$x:00008C6F                 db    0
.xdata$x:00008C70                 dd offset __unwindtable$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00008C74                 db    0
.xdata$x:00008C75                 db    0
.xdata$x:00008C76                 db    0
.xdata$x:00008C77                 db    0
.xdata$x:00008C78                 db    0
.xdata$x:00008C79                 db    0
.xdata$x:00008C7A                 db    0
.xdata$x:00008C7B                 db    0
.xdata$x:00008C7C                 db    0
.xdata$x:00008C7D                 db    0
.xdata$x:00008C7E                 db    0
.xdata$x:00008C7F                 db    0
.xdata$x:00008C80                 db    0
.xdata$x:00008C81                 db    0
.xdata$x:00008C82                 db    0
.xdata$x:00008C83                 db    0
.xdata$x:00008C84                 db    0
.xdata$x:00008C85                 db    0
.xdata$x:00008C86                 db    0
.xdata$x:00008C87                 db    0
.xdata$x:00008C88                 db    0
.xdata$x:00008C89                 db    0
.xdata$x:00008C8A                 db    0
.xdata$x:00008C8B                 db    0
.xdata$x:00008C8B _xdata$x        ends
.xdata$x:00008C8B
.xdata$x:00008C8C ; ===========================================================================
.xdata$x:00008C8C
.xdata$x:00008C8C ; Segment type: Pure data
.xdata$x:00008C8C ; Segment permissions: Read
.xdata$x:00008C8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008C8C                 assume cs:_xdata$x
.xdata$x:00008C8C                 ;org 8C8Ch
.xdata$x:00008C8C ; COMDAT (pick associative to section at 3054)
.xdata$x:00008C8C __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00008C8C                                         ; DATA XREF: .xdata$x:00008C9Co
.xdata$x:00008C8D                 db 0FFh
.xdata$x:00008C8E                 db 0FFh
.xdata$x:00008C8F                 db 0FFh
.xdata$x:00008C90                 dd offset __unwindfunclet$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00008C94 __ehfuncinfo$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00008C94                                         ; DATA XREF: __ehhandler$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00008C95                 db    5
.xdata$x:00008C96                 db  93h ; ô
.xdata$x:00008C97                 db  19h
.xdata$x:00008C98                 db    1
.xdata$x:00008C99                 db    0
.xdata$x:00008C9A                 db    0
.xdata$x:00008C9B                 db    0
.xdata$x:00008C9C                 dd offset __unwindtable$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00008CA0                 db    0
.xdata$x:00008CA1                 db    0
.xdata$x:00008CA2                 db    0
.xdata$x:00008CA3                 db    0
.xdata$x:00008CA4                 db    0
.xdata$x:00008CA5                 db    0
.xdata$x:00008CA6                 db    0
.xdata$x:00008CA7                 db    0
.xdata$x:00008CA8                 db    0
.xdata$x:00008CA9                 db    0
.xdata$x:00008CAA                 db    0
.xdata$x:00008CAB                 db    0
.xdata$x:00008CAC                 db    0
.xdata$x:00008CAD                 db    0
.xdata$x:00008CAE                 db    0
.xdata$x:00008CAF                 db    0
.xdata$x:00008CB0                 db    0
.xdata$x:00008CB1                 db    0
.xdata$x:00008CB2                 db    0
.xdata$x:00008CB3                 db    0
.xdata$x:00008CB4                 db    0
.xdata$x:00008CB5                 db    0
.xdata$x:00008CB6                 db    0
.xdata$x:00008CB7                 db    0
.xdata$x:00008CB7 _xdata$x        ends
.xdata$x:00008CB7
.xdata$x:00008CB8 ; ===========================================================================
.xdata$x:00008CB8
.xdata$x:00008CB8 ; Segment type: Pure data
.xdata$x:00008CB8 ; Segment permissions: Read
.xdata$x:00008CB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008CB8                 assume cs:_xdata$x
.xdata$x:00008CB8                 ;org 8CB8h
.xdata$x:00008CB8 ; COMDAT (pick associative to section at 25A0)
.xdata$x:00008CB8 __ehfuncinfo$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:00008CB8                                         ; DATA XREF: __ehhandler$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z+11o
.xdata$x:00008CB9                 db    5
.xdata$x:00008CBA                 db  93h ; ô
.xdata$x:00008CBB                 db  19h
.xdata$x:00008CBC                 db  0Ah
.xdata$x:00008CBD                 db    0
.xdata$x:00008CBE                 db    0
.xdata$x:00008CBF                 db    0
.xdata$x:00008CC0                 dd offset __unwindtable$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z
.xdata$x:00008CC4                 db    0
.xdata$x:00008CC5                 db    0
.xdata$x:00008CC6                 db    0
.xdata$x:00008CC7                 db    0
.xdata$x:00008CC8                 db    0
.xdata$x:00008CC9                 db    0
.xdata$x:00008CCA                 db    0
.xdata$x:00008CCB                 db    0
.xdata$x:00008CCC                 db    0
.xdata$x:00008CCD                 db    0
.xdata$x:00008CCE                 db    0
.xdata$x:00008CCF                 db    0
.xdata$x:00008CD0                 db    0
.xdata$x:00008CD1                 db    0
.xdata$x:00008CD2                 db    0
.xdata$x:00008CD3                 db    0
.xdata$x:00008CD4                 db    0
.xdata$x:00008CD5                 db    0
.xdata$x:00008CD6                 db    0
.xdata$x:00008CD7                 db    0
.xdata$x:00008CD8                 db    0
.xdata$x:00008CD9                 db    0
.xdata$x:00008CDA                 db    0
.xdata$x:00008CDB                 db    0
.xdata$x:00008CDC __unwindtable$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z db 0FFh
.xdata$x:00008CDC                                         ; DATA XREF: .xdata$x:00008CC0o
.xdata$x:00008CDD                 db 0FFh
.xdata$x:00008CDE                 db 0FFh
.xdata$x:00008CDF                 db 0FFh
.xdata$x:00008CE0                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$0
.xdata$x:00008CE4                 align 8
.xdata$x:00008CE8                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$1
.xdata$x:00008CEC                 db    1
.xdata$x:00008CED                 db    0
.xdata$x:00008CEE                 db    0
.xdata$x:00008CEF                 db    0
.xdata$x:00008CF0                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$2
.xdata$x:00008CF4                 db    2
.xdata$x:00008CF5                 db    0
.xdata$x:00008CF6                 db    0
.xdata$x:00008CF7                 db    0
.xdata$x:00008CF8                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$3
.xdata$x:00008CFC                 db    3
.xdata$x:00008CFD                 db    0
.xdata$x:00008CFE                 db    0
.xdata$x:00008CFF                 db    0
.xdata$x:00008D00                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4
.xdata$x:00008D04                 db    4
.xdata$x:00008D05                 db    0
.xdata$x:00008D06                 db    0
.xdata$x:00008D07                 db    0
.xdata$x:00008D08                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$5
.xdata$x:00008D0C                 db    5
.xdata$x:00008D0D                 db    0
.xdata$x:00008D0E                 db    0
.xdata$x:00008D0F                 db    0
.xdata$x:00008D10                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6
.xdata$x:00008D14                 db    6
.xdata$x:00008D15                 db    0
.xdata$x:00008D16                 db    0
.xdata$x:00008D17                 db    0
.xdata$x:00008D18                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$7
.xdata$x:00008D1C                 db    1
.xdata$x:00008D1D                 db    0
.xdata$x:00008D1E                 db    0
.xdata$x:00008D1F                 db    0
.xdata$x:00008D20                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$4
.xdata$x:00008D24                 db    8
.xdata$x:00008D25                 db    0
.xdata$x:00008D26                 db    0
.xdata$x:00008D27                 db    0
.xdata$x:00008D28                 dd offset __unwindfunclet$??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@1@0@Z$6
.xdata$x:00008D28 _xdata$x        ends
.xdata$x:00008D28
.xdata$x:00008D2C ; ===========================================================================
.xdata$x:00008D2C
.xdata$x:00008D2C ; Segment type: Pure data
.xdata$x:00008D2C ; Segment permissions: Read
.xdata$x:00008D2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008D2C                 assume cs:_xdata$x
.xdata$x:00008D2C                 ;org 8D2Ch
.xdata$x:00008D2C ; COMDAT (pick associative to section at 2934)
.xdata$x:00008D2C __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00008D2C                                         ; DATA XREF: .xdata$x:00008D3Co
.xdata$x:00008D2D                 db 0FFh
.xdata$x:00008D2E                 db 0FFh
.xdata$x:00008D2F                 db 0FFh
.xdata$x:00008D30                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00008D34 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00008D34                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00008D35                 db    5
.xdata$x:00008D36                 db  93h ; ô
.xdata$x:00008D37                 db  19h
.xdata$x:00008D38                 db    1
.xdata$x:00008D39                 db    0
.xdata$x:00008D3A                 db    0
.xdata$x:00008D3B                 db    0
.xdata$x:00008D3C                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00008D40                 db    0
.xdata$x:00008D41                 db    0
.xdata$x:00008D42                 db    0
.xdata$x:00008D43                 db    0
.xdata$x:00008D44                 db    0
.xdata$x:00008D45                 db    0
.xdata$x:00008D46                 db    0
.xdata$x:00008D47                 db    0
.xdata$x:00008D48                 db    0
.xdata$x:00008D49                 db    0
.xdata$x:00008D4A                 db    0
.xdata$x:00008D4B                 db    0
.xdata$x:00008D4C                 db    0
.xdata$x:00008D4D                 db    0
.xdata$x:00008D4E                 db    0
.xdata$x:00008D4F                 db    0
.xdata$x:00008D50                 db    0
.xdata$x:00008D51                 db    0
.xdata$x:00008D52                 db    0
.xdata$x:00008D53                 db    0
.xdata$x:00008D54                 db    0
.xdata$x:00008D55                 db    0
.xdata$x:00008D56                 db    0
.xdata$x:00008D57                 db    0
.xdata$x:00008D57 _xdata$x        ends
.xdata$x:00008D57
.xdata$x:00008D58 ; ===========================================================================
.xdata$x:00008D58
.xdata$x:00008D58 ; Segment type: Pure data
.xdata$x:00008D58 ; Segment permissions: Read
.xdata$x:00008D58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008D58                 assume cs:_xdata$x
.xdata$x:00008D58                 ;org 8D58h
.xdata$x:00008D58 ; COMDAT (pick associative to section at 2A18)
.xdata$x:00008D58 __unwindtable$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z db 0FFh
.xdata$x:00008D58                                         ; DATA XREF: .xdata$x:00008D68o
.xdata$x:00008D59                 db 0FFh
.xdata$x:00008D5A                 db 0FFh
.xdata$x:00008D5B                 db 0FFh
.xdata$x:00008D5C                 dd offset __unwindfunclet$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z$0
.xdata$x:00008D60 __ehfuncinfo$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z db  22h ; "
.xdata$x:00008D60                                         ; DATA XREF: __ehhandler$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z+11o
.xdata$x:00008D61                 db    5
.xdata$x:00008D62                 db  93h ; ô
.xdata$x:00008D63                 db  19h
.xdata$x:00008D64                 db    1
.xdata$x:00008D65                 db    0
.xdata$x:00008D66                 db    0
.xdata$x:00008D67                 db    0
.xdata$x:00008D68                 dd offset __unwindtable$??$construct@VUserCommand@@AAV1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@AAV2@@Z
.xdata$x:00008D6C                 db    0
.xdata$x:00008D6D                 db    0
.xdata$x:00008D6E                 db    0
.xdata$x:00008D6F                 db    0
.xdata$x:00008D70                 db    0
.xdata$x:00008D71                 db    0
.xdata$x:00008D72                 db    0
.xdata$x:00008D73                 db    0
.xdata$x:00008D74                 db    0
.xdata$x:00008D75                 db    0
.xdata$x:00008D76                 db    0
.xdata$x:00008D77                 db    0
.xdata$x:00008D78                 db    0
.xdata$x:00008D79                 db    0
.xdata$x:00008D7A                 db    0
.xdata$x:00008D7B                 db    0
.xdata$x:00008D7C                 db    0
.xdata$x:00008D7D                 db    0
.xdata$x:00008D7E                 db    0
.xdata$x:00008D7F                 db    0
.xdata$x:00008D80                 db    0
.xdata$x:00008D81                 db    0
.xdata$x:00008D82                 db    0
.xdata$x:00008D83                 db    0
.xdata$x:00008D83 _xdata$x        ends
.xdata$x:00008D83
.xdata$x:00008D84 ; ===========================================================================
.xdata$x:00008D84
.xdata$x:00008D84 ; Segment type: Pure data
.xdata$x:00008D84 ; Segment permissions: Read
.xdata$x:00008D84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008D84                 assume cs:_xdata$x
.xdata$x:00008D84                 ;org 8D84h
.xdata$x:00008D84 ; COMDAT (pick associative to section at 2760)
.xdata$x:00008D84 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00008D84                                         ; DATA XREF: .xdata$x:00008D94o
.xdata$x:00008D85                 db 0FFh
.xdata$x:00008D86                 db 0FFh
.xdata$x:00008D87                 db 0FFh
.xdata$x:00008D88                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00008D8C __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00008D8C                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00008D8D                 db    5
.xdata$x:00008D8E                 db  93h ; ô
.xdata$x:00008D8F                 db  19h
.xdata$x:00008D90                 db    1
.xdata$x:00008D91                 db    0
.xdata$x:00008D92                 db    0
.xdata$x:00008D93                 db    0
.xdata$x:00008D94                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00008D98                 db    0
.xdata$x:00008D99                 db    0
.xdata$x:00008D9A                 db    0
.xdata$x:00008D9B                 db    0
.xdata$x:00008D9C                 db    0
.xdata$x:00008D9D                 db    0
.xdata$x:00008D9E                 db    0
.xdata$x:00008D9F                 db    0
.xdata$x:00008DA0                 db    0
.xdata$x:00008DA1                 db    0
.xdata$x:00008DA2                 db    0
.xdata$x:00008DA3                 db    0
.xdata$x:00008DA4                 db    0
.xdata$x:00008DA5                 db    0
.xdata$x:00008DA6                 db    0
.xdata$x:00008DA7                 db    0
.xdata$x:00008DA8                 db    0
.xdata$x:00008DA9                 db    0
.xdata$x:00008DAA                 db    0
.xdata$x:00008DAB                 db    0
.xdata$x:00008DAC                 db    0
.xdata$x:00008DAD                 db    0
.xdata$x:00008DAE                 db    0
.xdata$x:00008DAF                 db    0
.xdata$x:00008DAF _xdata$x        ends
.xdata$x:00008DAF
.xdata$x:00008DB0 ; ===========================================================================
.xdata$x:00008DB0
.xdata$x:00008DB0 ; Segment type: Pure data
.xdata$x:00008DB0 ; Segment permissions: Read
.xdata$x:00008DB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008DB0                 assume cs:_xdata$x
.xdata$x:00008DB0                 ;org 8DB0h
.xdata$x:00008DB0 ; COMDAT (pick associative to section at 2860)
.xdata$x:00008DB0 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00008DB0                                         ; DATA XREF: .xdata$x:00008DC0o
.xdata$x:00008DB1                 db 0FFh
.xdata$x:00008DB2                 db 0FFh
.xdata$x:00008DB3                 db 0FFh
.xdata$x:00008DB4                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00008DB8 __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00008DB8                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00008DB9                 db    5
.xdata$x:00008DBA                 db  93h ; ô
.xdata$x:00008DBB                 db  19h
.xdata$x:00008DBC                 db    1
.xdata$x:00008DBD                 db    0
.xdata$x:00008DBE                 db    0
.xdata$x:00008DBF                 db    0
.xdata$x:00008DC0                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00008DC4                 db    0
.xdata$x:00008DC5                 db    0
.xdata$x:00008DC6                 db    0
.xdata$x:00008DC7                 db    0
.xdata$x:00008DC8                 db    0
.xdata$x:00008DC9                 db    0
.xdata$x:00008DCA                 db    0
.xdata$x:00008DCB                 db    0
.xdata$x:00008DCC                 db    0
.xdata$x:00008DCD                 db    0
.xdata$x:00008DCE                 db    0
.xdata$x:00008DCF                 db    0
.xdata$x:00008DD0                 db    0
.xdata$x:00008DD1                 db    0
.xdata$x:00008DD2                 db    0
.xdata$x:00008DD3                 db    0
.xdata$x:00008DD4                 db    0
.xdata$x:00008DD5                 db    0
.xdata$x:00008DD6                 db    0
.xdata$x:00008DD7                 db    0
.xdata$x:00008DD8                 db    0
.xdata$x:00008DD9                 db    0
.xdata$x:00008DDA                 db    0
.xdata$x:00008DDB                 db    0
.xdata$x:00008DDB _xdata$x        ends
.xdata$x:00008DDB
.xdata$x:00008DDC ; ===========================================================================
.xdata$x:00008DDC
.xdata$x:00008DDC ; Segment type: Pure data
.xdata$x:00008DDC ; Segment permissions: Read
.xdata$x:00008DDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008DDC                 assume cs:_xdata$x
.xdata$x:00008DDC                 ;org 8DDCh
.xdata$x:00008DDC ; COMDAT (pick associative to section at 2428)
.xdata$x:00008DDC __catchsym$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:00008DDC                                         ; DATA XREF: .xdata$x:00008E0Co
.xdata$x:00008DDD                 db    0
.xdata$x:00008DDE                 db    0
.xdata$x:00008DDF                 db    0
.xdata$x:00008DE0                 db    0
.xdata$x:00008DE1                 db    0
.xdata$x:00008DE2                 db    0
.xdata$x:00008DE3                 db    0
.xdata$x:00008DE4                 db    0
.xdata$x:00008DE5                 db    0
.xdata$x:00008DE6                 db    0
.xdata$x:00008DE7                 db    0
.xdata$x:00008DE8                 dd offset __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:00008DEC __unwindtable$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:00008DEC                                         ; DATA XREF: .xdata$x:00008E18o
.xdata$x:00008DED                 db 0FFh
.xdata$x:00008DEE                 db 0FFh
.xdata$x:00008DEF                 db 0FFh
.xdata$x:00008DF0                 db    0
.xdata$x:00008DF1                 db    0
.xdata$x:00008DF2                 db    0
.xdata$x:00008DF3                 db    0
.xdata$x:00008DF4                 db 0FFh
.xdata$x:00008DF5                 db 0FFh
.xdata$x:00008DF6                 db 0FFh
.xdata$x:00008DF7                 db 0FFh
.xdata$x:00008DF8                 db    0
.xdata$x:00008DF9                 db    0
.xdata$x:00008DFA                 db    0
.xdata$x:00008DFB                 db    0
.xdata$x:00008DFC __tryblocktable$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:00008DFC                                         ; DATA XREF: .xdata$x:00008E20o
.xdata$x:00008DFD                 db    0
.xdata$x:00008DFE                 db    0
.xdata$x:00008DFF                 db    0
.xdata$x:00008E00                 db    0
.xdata$x:00008E01                 db    0
.xdata$x:00008E02                 db    0
.xdata$x:00008E03                 db    0
.xdata$x:00008E04                 db    1
.xdata$x:00008E05                 db    0
.xdata$x:00008E06                 db    0
.xdata$x:00008E07                 db    0
.xdata$x:00008E08                 db    1
.xdata$x:00008E09                 db    0
.xdata$x:00008E0A                 db    0
.xdata$x:00008E0B                 db    0
.xdata$x:00008E0C                 dd offset __catchsym$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00008E10 __ehfuncinfo$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00008E10                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00008E11                 db    5
.xdata$x:00008E12                 db  93h ; ô
.xdata$x:00008E13                 db  19h
.xdata$x:00008E14                 db    2
.xdata$x:00008E15                 db    0
.xdata$x:00008E16                 db    0
.xdata$x:00008E17                 db    0
.xdata$x:00008E18                 dd offset __unwindtable$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00008E1C                 db    1
.xdata$x:00008E1D                 db    0
.xdata$x:00008E1E                 db    0
.xdata$x:00008E1F                 db    0
.xdata$x:00008E20                 dd offset __tryblocktable$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00008E24                 db    0
.xdata$x:00008E25                 db    0
.xdata$x:00008E26                 db    0
.xdata$x:00008E27                 db    0
.xdata$x:00008E28                 db    0
.xdata$x:00008E29                 db    0
.xdata$x:00008E2A                 db    0
.xdata$x:00008E2B                 db    0
.xdata$x:00008E2C                 db    0
.xdata$x:00008E2D                 db    0
.xdata$x:00008E2E                 db    0
.xdata$x:00008E2F                 db    0
.xdata$x:00008E30                 db    0
.xdata$x:00008E31                 db    0
.xdata$x:00008E32                 db    0
.xdata$x:00008E33                 db    0
.xdata$x:00008E33 _xdata$x        ends
.xdata$x:00008E33
.xdata$x:00008E34 ; ===========================================================================
.xdata$x:00008E34
.xdata$x:00008E34 ; Segment type: Pure data
.xdata$x:00008E34 ; Segment permissions: Read
.xdata$x:00008E34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008E34                 assume cs:_xdata$x
.xdata$x:00008E34                 ;org 8E34h
.xdata$x:00008E34 ; COMDAT (pick associative to section at 2B64)
.xdata$x:00008E34 __unwindtable$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z db 0FFh
.xdata$x:00008E34                                         ; DATA XREF: .xdata$x:00008E44o
.xdata$x:00008E35                 db 0FFh
.xdata$x:00008E36                 db 0FFh
.xdata$x:00008E37                 db 0FFh
.xdata$x:00008E38                 dd offset __unwindfunclet$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z$0
.xdata$x:00008E3C __ehfuncinfo$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z db  22h ; "
.xdata$x:00008E3C                                         ; DATA XREF: __ehhandler$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z+11o
.xdata$x:00008E3D                 db    5
.xdata$x:00008E3E                 db  93h ; ô
.xdata$x:00008E3F                 db  19h
.xdata$x:00008E40                 db    1
.xdata$x:00008E41                 db    0
.xdata$x:00008E42                 db    0
.xdata$x:00008E43                 db    0
.xdata$x:00008E44                 dd offset __unwindtable$??$construct@VUserCommand@@V1@@?$allocator@VUserCommand@@@std@@QAEXPAVUserCommand@@$$QAV2@@Z
.xdata$x:00008E48                 align 20h
.xdata$x:00008E48 _xdata$x        ends
.xdata$x:00008E48
.rdata:00008E60 ; ===========================================================================
.rdata:00008E60
.rdata:00008E60 ; Segment type: Pure data
.rdata:00008E60 ; Segment permissions: Read
.rdata:00008E60 _rdata          segment dword public 'DATA' use32
.rdata:00008E60                 assume cs:_rdata
.rdata:00008E60                 ;org 8E60h
.rdata:00008E60 ; COMDAT (pick largest)
.rdata:00008E60                 dd offset ??_R4Window@@6B@ ; const Window::`RTTI Complete Object Locator'
.rdata:00008E64                 public ??_7Window@@6B@
.rdata:00008E64 ; const Window::`vftable'
.rdata:00008E64 ??_7Window@@6B@ dd offset ??_EWindow@@UAEPAXI@Z
.rdata:00008E64                                         ; DATA XREF: Window::Window(void)+Ao
.rdata:00008E64                                         ; Window::~Window(void)+Ao
.rdata:00008E64                                         ; Window::`vector deleting destructor'(uint)
.rdata:00008E68                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00008E6C                 dd offset __purecall
.rdata:00008E70                 dd offset ?display@Window@@UBEX_N@Z ; Window::display(bool)
.rdata:00008E74                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00008E78                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00008E7C                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00008E80                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00008E84                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00008E88                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00008E8C                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00008E90                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00008E90 _rdata          ends
.rdata:00008E90
.rdata:00008E94 ; ===========================================================================
.rdata:00008E94
.rdata:00008E94 ; Segment type: Pure data
.rdata:00008E94 ; Segment permissions: Read
.rdata:00008E94 _rdata          segment dword public 'DATA' use32
.rdata:00008E94                 assume cs:_rdata
.rdata:00008E94                 ;org 8E94h
.rdata:00008E94 ; COMDAT (pick largest)
.rdata:00008E94                 dd offset ??_R4StaticDialog@@6B@ ; const StaticDialog::`RTTI Complete Object Locator'
.rdata:00008E98                 public ??_7StaticDialog@@6B@
.rdata:00008E98 ; const StaticDialog::`vftable'
.rdata:00008E98 ??_7StaticDialog@@6B@ dd offset ??_EStaticDialog@@UAEPAXI@Z
.rdata:00008E98                                         ; DATA XREF: StaticDialog::StaticDialog(void)+38o
.rdata:00008E98                                         ; StaticDialog::~StaticDialog(void)+29o
.rdata:00008E98                                         ; StaticDialog::`vector deleting destructor'(uint)
.rdata:00008E9C                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00008EA0                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:00008EA4                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:00008EA8                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00008EAC                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00008EB0                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00008EB4                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00008EB8                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00008EBC                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00008EC0                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00008EC4                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00008EC8                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:00008ECC                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:00008ED0                 dd offset __purecall
.rdata:00008ED0 _rdata          ends
.rdata:00008ED0
.bss:00008ED4 ; ===========================================================================
.bss:00008ED4
.bss:00008ED4 ; Segment type: Uninitialized
.bss:00008ED4 ; Segment permissions: Read/Write
.bss:00008ED4 _bss            segment byte public 'BSS' use32
.bss:00008ED4                 assume cs:_bss
.bss:00008ED4                 ;org 8ED4h
.bss:00008ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00008ED4 __Tuple_alloc   db    ? ;
.bss:00008ED5 ; std::_Ignore ignore
.bss:00008ED5 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00008ED6 _allocator_arg  db    ? ;
.bss:00008ED7 _piecewise_construct db    ? ;
.bss:00008ED7 _bss            ends
.bss:00008ED7
.rdata:00008ED8 ; ===========================================================================
.rdata:00008ED8
.rdata:00008ED8 ; Segment type: Pure data
.rdata:00008ED8 ; Segment permissions: Read
.rdata:00008ED8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00008ED8 _rdata          segment para public 'DATA' use32
.rdata:00008ED8                 assume cs:_rdata
.rdata:00008ED8                 ;org 8ED8h
.rdata:00008ED8 ; COMDAT (pick any)
.rdata:00008ED8                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00008ED8 ; wchar_t `string'
.rdata:00008ED8 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00008ED8                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:00008ED8                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00008ED8                 unicode 0, <clude\xutility>,0
.rdata:00008ED8 _rdata          ends
.rdata:00008ED8
.rdata:00008F68 ; ===========================================================================
.rdata:00008F68
.rdata:00008F68 ; Segment type: Pure data
.rdata:00008F68 ; Segment permissions: Read
.rdata:00008F68 _rdata          segment dword public 'DATA' use32
.rdata:00008F68                 assume cs:_rdata
.rdata:00008F68                 ;org 8F68h
.rdata:00008F68 ; COMDAT (pick any)
.rdata:00008F68                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:00008F68 ; wchar_t `string'
.rdata:00008F68 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:00008F68                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:00008F68                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:00008F9A                 align 4
.rdata:00008F9A _rdata          ends
.rdata:00008F9A
.rdata:00008F9C ; ===========================================================================
.rdata:00008F9C
.rdata:00008F9C ; Segment type: Pure data
.rdata:00008F9C ; Segment permissions: Read
.rdata:00008F9C _rdata          segment dword public 'DATA' use32
.rdata:00008F9C                 assume cs:_rdata
.rdata:00008F9C                 ;org 8F9Ch
.rdata:00008F9C ; COMDAT (pick largest)
.rdata:00008F9C                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00008FA0                 public ??_7error_category@std@@6B@
.rdata:00008FA0 ; const std::error_category::`vftable'
.rdata:00008FA0 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00008FA0                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00008FA0                                         ; std::error_category::~error_category(void)+Ao
.rdata:00008FA0                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00008FA4                 dd offset __purecall
.rdata:00008FA8                 dd offset __purecall
.rdata:00008FAC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00008FB0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00008FB4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00008FB4 _rdata          ends
.rdata:00008FB4
.rdata:00008FB8 ; ===========================================================================
.rdata:00008FB8
.rdata:00008FB8 ; Segment type: Pure data
.rdata:00008FB8 ; Segment permissions: Read
.rdata:00008FB8 _rdata          segment dword public 'DATA' use32
.rdata:00008FB8                 assume cs:_rdata
.rdata:00008FB8                 ;org 8FB8h
.rdata:00008FB8 ; COMDAT (pick largest)
.rdata:00008FB8                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00008FBC                 public ??_7_Generic_error_category@std@@6B@
.rdata:00008FBC ; const std::_Generic_error_category::`vftable'
.rdata:00008FBC ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00008FBC                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00008FBC                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00008FC0                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00008FC4                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00008FC8                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00008FCC                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00008FD0                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00008FD0 _rdata          ends
.rdata:00008FD0
.rdata:00008FD4 ; ===========================================================================
.rdata:00008FD4
.rdata:00008FD4 ; Segment type: Pure data
.rdata:00008FD4 ; Segment permissions: Read
.rdata:00008FD4 _rdata          segment dword public 'DATA' use32
.rdata:00008FD4                 assume cs:_rdata
.rdata:00008FD4                 ;org 8FD4h
.rdata:00008FD4 ; COMDAT (pick any)
.rdata:00008FD4                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00008FD4 ; `string'
.rdata:00008FD4 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00008FD4                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00008FD4 _rdata          ends
.rdata:00008FD4
.rdata:00008FDC ; ===========================================================================
.rdata:00008FDC
.rdata:00008FDC ; Segment type: Pure data
.rdata:00008FDC ; Segment permissions: Read
.rdata:00008FDC _rdata          segment dword public 'DATA' use32
.rdata:00008FDC                 assume cs:_rdata
.rdata:00008FDC                 ;org 8FDCh
.rdata:00008FDC ; COMDAT (pick any)
.rdata:00008FDC                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00008FDC ; `string'
.rdata:00008FDC ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00008FDC                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_70C8o
.rdata:00008FDC                                         ; std::_System_error_category::message(int):loc_7244o
.rdata:00008FEA                 align 4
.rdata:00008FEA _rdata          ends
.rdata:00008FEA
.rdata:00008FEC ; ===========================================================================
.rdata:00008FEC
.rdata:00008FEC ; Segment type: Pure data
.rdata:00008FEC ; Segment permissions: Read
.rdata:00008FEC _rdata          segment dword public 'DATA' use32
.rdata:00008FEC                 assume cs:_rdata
.rdata:00008FEC                 ;org 8FECh
.rdata:00008FEC ; COMDAT (pick largest)
.rdata:00008FEC                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00008FF0                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00008FF0 ; const std::_Iostream_error_category::`vftable'
.rdata:00008FF0 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00008FF0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00008FF0                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00008FF4                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00008FF8                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00008FFC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00009000                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00009004                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00009004 _rdata          ends
.rdata:00009004
.rdata:00009008 ; ===========================================================================
.rdata:00009008
.rdata:00009008 ; Segment type: Pure data
.rdata:00009008 ; Segment permissions: Read
.rdata:00009008 _rdata          segment dword public 'DATA' use32
.rdata:00009008                 assume cs:_rdata
.rdata:00009008                 ;org 9008h
.rdata:00009008 ; COMDAT (pick any)
.rdata:00009008                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00009008 ; `string'
.rdata:00009008 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00009008                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00009011                 align 4
.rdata:00009011 _rdata          ends
.rdata:00009011
.rdata:00009014 ; ===========================================================================
.rdata:00009014
.rdata:00009014 ; Segment type: Pure data
.rdata:00009014 ; Segment permissions: Read
.rdata:00009014 _rdata          segment dword public 'DATA' use32
.rdata:00009014                 assume cs:_rdata
.rdata:00009014                 ;org 9014h
.rdata:00009014 ; COMDAT (pick any)
.rdata:00009014                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00009014 ; char `string'[]
.rdata:00009014 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00009014                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000902A                 align 4
.rdata:0000902A _rdata          ends
.rdata:0000902A
.rdata:0000902C ; ===========================================================================
.rdata:0000902C
.rdata:0000902C ; Segment type: Pure data
.rdata:0000902C ; Segment permissions: Read
.rdata:0000902C _rdata          segment dword public 'DATA' use32
.rdata:0000902C                 assume cs:_rdata
.rdata:0000902C                 ;org 902Ch
.rdata:0000902C ; COMDAT (pick largest)
.rdata:0000902C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00009030                 public ??_7_System_error_category@std@@6B@
.rdata:00009030 ; const std::_System_error_category::`vftable'
.rdata:00009030 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00009030                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00009030                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00009034                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00009038                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000903C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00009040                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00009044                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00009044 _rdata          ends
.rdata:00009044
.rdata:00009048 ; ===========================================================================
.rdata:00009048
.rdata:00009048 ; Segment type: Pure data
.rdata:00009048 ; Segment permissions: Read
.rdata:00009048 _rdata          segment dword public 'DATA' use32
.rdata:00009048                 assume cs:_rdata
.rdata:00009048                 ;org 9048h
.rdata:00009048 ; COMDAT (pick any)
.rdata:00009048                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00009048 ; `string'
.rdata:00009048 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00009048                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000904F                 align 10h
.rdata:0000904F _rdata          ends
.rdata:0000904F
.bss:00009050 ; ===========================================================================
.bss:00009050
.bss:00009050 ; Segment type: Uninitialized
.bss:00009050 ; Segment permissions: Read/Write
.bss:00009050 _bss            segment dword public 'BSS' use32
.bss:00009050                 assume cs:_bss
.bss:00009050                 ;org 9050h
.bss:00009050 ; COMDAT (pick any)
.bss:00009050                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009050                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00009050 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00009050 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00009050                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00009050                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00009051                 db    ? ;
.bss:00009052                 db    ? ;
.bss:00009053                 db    ? ;
.bss:00009053 _bss            ends
.bss:00009053
.bss:00009054 ; ===========================================================================
.bss:00009054
.bss:00009054 ; Segment type: Uninitialized
.bss:00009054 ; Segment permissions: Read/Write
.bss:00009054 _bss            segment dword public 'BSS' use32
.bss:00009054                 assume cs:_bss
.bss:00009054                 ;org 9054h
.bss:00009054 ; COMDAT (pick any)
.bss:00009054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009054                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00009054 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00009054 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00009054                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00009054                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00009055                 db    ? ;
.bss:00009056                 db    ? ;
.bss:00009057                 db    ? ;
.bss:00009057 _bss            ends
.bss:00009057
.bss:00009058 ; ===========================================================================
.bss:00009058
.bss:00009058 ; Segment type: Uninitialized
.bss:00009058 ; Segment permissions: Read/Write
.bss:00009058 _bss            segment dword public 'BSS' use32
.bss:00009058                 assume cs:_bss
.bss:00009058                 ;org 9058h
.bss:00009058 ; COMDAT (pick any)
.bss:00009058                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009058                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00009058 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00009058 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00009058                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00009058                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00009059                 db    ? ;
.bss:0000905A                 db    ? ;
.bss:0000905B                 db    ? ;
.bss:0000905B _bss            ends
.bss:0000905B
.rdata:0000905C ; ===========================================================================
.rdata:0000905C
.rdata:0000905C ; Segment type: Pure data
.rdata:0000905C ; Segment permissions: Read
.rdata:0000905C _rdata          segment dword public 'DATA' use32
.rdata:0000905C                 assume cs:_rdata
.rdata:0000905C                 ;org 905Ch
.rdata:0000905C ; COMDAT (pick any)
.rdata:0000905C                 public ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB
.rdata:0000905C ; public: static unsigned int const std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::npos
.rdata:0000905C ?npos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@2IB dd 0FFFFFFFFh
.rdata:0000905C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+5Br
.rdata:0000905C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::append(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &)+7r ...
.rdata:0000905C _rdata          ends
.rdata:0000905C
.bss:00009060 ; ===========================================================================
.bss:00009060
.bss:00009060 ; Segment type: Uninitialized
.bss:00009060 ; Segment permissions: Read/Write
.bss:00009060 _bss            segment dword public 'BSS' use32
.bss:00009060                 assume cs:_bss
.bss:00009060                 ;org 9060h
.bss:00009060 ; COMDAT (pick any)
.bss:00009060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009060                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00009060 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00009060 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00009060                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00009061                 db    ? ;
.bss:00009062                 db    ? ;
.bss:00009063                 db    ? ;
.bss:00009063 _bss            ends
.bss:00009063
.bss:00009064 ; ===========================================================================
.bss:00009064
.bss:00009064 ; Segment type: Uninitialized
.bss:00009064 ; Segment permissions: Read/Write
.bss:00009064 _bss            segment dword public 'BSS' use32
.bss:00009064                 assume cs:_bss
.bss:00009064                 ;org 9064h
.bss:00009064 ; COMDAT (pick any)
.bss:00009064                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00009064                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00009064 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00009064 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00009064                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00009065                 db    ? ;
.bss:00009066                 db    ? ;
.bss:00009067                 db    ? ;
.bss:00009067 _bss            ends
.bss:00009067
.rdata:00009068 ; ===========================================================================
.rdata:00009068
.rdata:00009068 ; Segment type: Pure data
.rdata:00009068 ; Segment permissions: Read
.rdata:00009068 _rdata          segment dword public 'DATA' use32
.rdata:00009068                 assume cs:_rdata
.rdata:00009068                 ;org 9068h
.rdata:00009068 ; COMDAT (pick largest)
.rdata:00009068                 dd offset ??_R4Shortcut@@6B@ ; const Shortcut::`RTTI Complete Object Locator'
.rdata:0000906C                 public ??_7Shortcut@@6B@
.rdata:0000906C ; const Shortcut::`vftable'
.rdata:0000906C ??_7Shortcut@@6B@ dd offset ??_EShortcut@@UAEPAXI@Z
.rdata:0000906C                                         ; DATA XREF: Shortcut::Shortcut(Shortcut const &)+38o
.rdata:0000906C                                         ; Shortcut::Shortcut(void)+38o
.rdata:0000906C                                         ; Shortcut::`vector deleting destructor'(uint)
.rdata:00009070                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:00009074                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:00009078                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:0000907C                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00009080                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:00009084                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00009088                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:0000908C                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00009090                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:00009094                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00009098                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:0000909C                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:000090A0                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:000090A4                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:000090A8                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:000090AC                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:000090B0                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:000090B4                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:000090B4 _rdata          ends
.rdata:000090B4
.rdata:000090B8 ; ===========================================================================
.rdata:000090B8
.rdata:000090B8 ; Segment type: Pure data
.rdata:000090B8 ; Segment permissions: Read
.rdata:000090B8 _rdata          segment dword public 'DATA' use32
.rdata:000090B8                 assume cs:_rdata
.rdata:000090B8                 ;org 90B8h
.rdata:000090B8 ; COMDAT (pick any)
.rdata:000090B8                 public ??_C@_11LOCGONAA@?$AA?$AA@
.rdata:000090B8 ; wchar_t `string'
.rdata:000090B8 ??_C@_11LOCGONAA@?$AA?$AA@ dw 0         ; DATA XREF: Shortcut::Shortcut(void)+45o
.rdata:000090BA                 align 4
.rdata:000090BA _rdata          ends
.rdata:000090BA
.rdata:000090BC ; ===========================================================================
.rdata:000090BC
.rdata:000090BC ; Segment type: Pure data
.rdata:000090BC ; Segment permissions: Read
.rdata:000090BC _rdata          segment dword public 'DATA' use32
.rdata:000090BC                 assume cs:_rdata
.rdata:000090BC                 ;org 90BCh
.rdata:000090BC ; COMDAT (pick any)
.rdata:000090BC                 public ??_C@_13KDLDGPGJ@?$AA?7?$AA?$AA@
.rdata:000090BC ; wchar_t `string'
.rdata:000090BC ??_C@_13KDLDGPGJ@?$AA?7?$AA?$AA@ dw 9   ; DATA XREF: Shortcut::toMenuItemString(void)+5Eo
.rdata:000090BE                 db    0
.rdata:000090BF                 db    0
.rdata:000090BF _rdata          ends
.rdata:000090BF
.rdata:000090C0 ; ===========================================================================
.rdata:000090C0
.rdata:000090C0 ; Segment type: Pure data
.rdata:000090C0 ; Segment permissions: Read
.rdata:000090C0 _rdata          segment dword public 'DATA' use32
.rdata:000090C0                 assume cs:_rdata
.rdata:000090C0                 ;org 90C0h
.rdata:000090C0 ; COMDAT (pick largest)
.rdata:000090C0                 dd offset ??_R4CommandShortcut@@6B@ ; const CommandShortcut::`RTTI Complete Object Locator'
.rdata:000090C4                 public ??_7CommandShortcut@@6B@
.rdata:000090C4 ; const CommandShortcut::`vftable'
.rdata:000090C4 ??_7CommandShortcut@@6B@ dd offset ??_ECommandShortcut@@UAEPAXI@Z
.rdata:000090C4                                         ; DATA XREF: CommandShortcut::CommandShortcut(CommandShortcut const &)+3Co
.rdata:000090C4                                         ; CommandShortcut::CommandShortcut(Shortcut,long)+40o
.rdata:000090C4                                         ; CommandShortcut::`vector deleting destructor'(uint)
.rdata:000090C8                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:000090CC                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:000090D0                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:000090D4                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:000090D8                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:000090DC                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:000090E0                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:000090E4                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:000090E8                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:000090EC                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:000090F0                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:000090F4                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:000090F8                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:000090FC                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:00009100                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:00009104                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:00009108                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000910C                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000910C _rdata          ends
.rdata:0000910C
.rdata:00009110 ; ===========================================================================
.rdata:00009110
.rdata:00009110 ; Segment type: Pure data
.rdata:00009110 ; Segment permissions: Read
.rdata:00009110 _rdata          segment dword public 'DATA' use32
.rdata:00009110                 assume cs:_rdata
.rdata:00009110                 ;org 9110h
.rdata:00009110 ; COMDAT (pick largest)
.rdata:00009110                 dd offset ??_R4UserCommand@@6B@ ; const UserCommand::`RTTI Complete Object Locator'
.rdata:00009114                 public ??_7UserCommand@@6B@
.rdata:00009114 ; const UserCommand::`vftable'
.rdata:00009114 ??_7UserCommand@@6B@ dd offset ??_EUserCommand@@UAEPAXI@Z
.rdata:00009114                                         ; DATA XREF: UserCommand::UserCommand(UserCommand const &)+3Co
.rdata:00009114                                         ; UserCommand::UserCommand(Shortcut,wchar_t const *,int)+6Do
.rdata:00009114                                         ; UserCommand::`vector deleting destructor'(uint)
.rdata:00009118                 dd offset ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.rdata:0000911C                 dd offset ?destroy@StaticDialog@@UAEXXZ ; StaticDialog::destroy(void)
.rdata:00009120                 dd offset ?display@StaticDialog@@UBEX_N@Z ; StaticDialog::display(bool)
.rdata:00009124                 dd offset ?reSizeTo@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeTo(tagRECT &)
.rdata:00009128                 dd offset ?reSizeToWH@Window@@UAEXAAUtagRECT@@@Z ; Window::reSizeToWH(tagRECT &)
.rdata:0000912C                 dd offset ?redraw@Window@@UBEX_N@Z ; Window::redraw(bool)
.rdata:00009130                 dd offset ?getClientRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getClientRect(tagRECT &)
.rdata:00009134                 dd offset ?getWindowRect@Window@@UBEXAAUtagRECT@@@Z ; Window::getWindowRect(tagRECT &)
.rdata:00009138                 dd offset ?getWidth@Window@@UBEHXZ ; Window::getWidth(void)
.rdata:0000913C                 dd offset ?getHeight@Window@@UBEHXZ ; Window::getHeight(void)
.rdata:00009140                 dd offset ?isVisible@Window@@UBE_NXZ ; Window::isVisible(void)
.rdata:00009144                 dd offset ?create@StaticDialog@@UAEXH_N0@Z ; StaticDialog::create(int,bool,bool)
.rdata:00009148                 dd offset ?isCreated@StaticDialog@@UBE_NXZ ; StaticDialog::isCreated(void)
.rdata:0000914C                 dd offset ?run_dlgProc@Shortcut@@MAGHIIJ@Z ; Shortcut::run_dlgProc(uint,uint,long)
.rdata:00009150                 dd offset ?doDialog@Shortcut@@UAEHXZ ; Shortcut::doDialog(void)
.rdata:00009154                 dd offset ?isValid@Shortcut@@UBE_NXZ ; Shortcut::isValid(void)
.rdata:00009158                 dd offset ?isEnabled@Shortcut@@UBE_NXZ ; Shortcut::isEnabled(void)
.rdata:0000915C                 dd offset ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ ; Shortcut::toString(void)
.rdata:0000915C _rdata          ends
.rdata:0000915C
.rdata:00009160 ; ===========================================================================
.rdata:00009160
.rdata:00009160 ; Segment type: Pure data
.rdata:00009160 ; Segment permissions: Read
.rdata:00009160 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00009160 _rdata          segment para public 'DATA' use32
.rdata:00009160                 assume cs:_rdata
.rdata:00009160                 ;org 9160h
.rdata:00009160 ; COMDAT (pick any)
.rdata:00009160                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00009160 ; wchar_t `string'
.rdata:00009160 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00009160                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+5Do
.rdata:00009160                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+8Ao ...
.rdata:00009160                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00009160                 unicode 0, <clude\xstring>,0
.rdata:000091EE                 align 10h
.rdata:000091EE _rdata          ends
.rdata:000091EE
.bss:000091F0 ; ===========================================================================
.bss:000091F0
.bss:000091F0 ; Segment type: Uninitialized
.bss:000091F0 ; Segment permissions: Read/Write
.bss:000091F0 _bss            segment dword public 'BSS' use32
.bss:000091F0                 assume cs:_bss
.bss:000091F0                 ;org 91F0h
.bss:000091F0 ; COMDAT (pick any)
.bss:000091F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000091F0                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:000091F0 ; std::locale::id std::numpunct<char>::id
.bss:000091F0 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:000091F0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:000091F1                 db    ? ;
.bss:000091F2                 db    ? ;
.bss:000091F3                 db    ? ;
.bss:000091F3 _bss            ends
.bss:000091F3
.bss:000091F4 ; ===========================================================================
.bss:000091F4
.bss:000091F4 ; Segment type: Uninitialized
.bss:000091F4 ; Segment permissions: Read/Write
.bss:000091F4 _bss            segment dword public 'BSS' use32
.bss:000091F4                 assume cs:_bss
.bss:000091F4                 ;org 91F4h
.bss:000091F4 ; COMDAT (pick any)
.bss:000091F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000091F4                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:000091F4 ; std::locale::id std::numpunct<wchar_t>::id
.bss:000091F4 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:000091F4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:000091F5                 db    ? ;
.bss:000091F6                 db    ? ;
.bss:000091F7                 db    ? ;
.bss:000091F7 _bss            ends
.bss:000091F7
.rdata:000091F8 ; ===========================================================================
.rdata:000091F8
.rdata:000091F8 ; Segment type: Pure data
.rdata:000091F8 ; Segment permissions: Read
.rdata:000091F8 _rdata          segment dword public 'DATA' use32
.rdata:000091F8                 assume cs:_rdata
.rdata:000091F8                 ;org 91F8h
.rdata:000091F8 ; COMDAT (pick any)
.rdata:000091F8                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:000091F8 ; `string'
.rdata:000091F8 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:000091F8                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+6Fo
.rdata:000091F8 _rdata          ends
.rdata:000091F8
.rdata:0000921C ; ===========================================================================
.rdata:0000921C
.rdata:0000921C ; Segment type: Pure data
.rdata:0000921C ; Segment permissions: Read
.rdata:0000921C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000921C _rdata          segment para public 'DATA' use32
.rdata:0000921C                 assume cs:_rdata
.rdata:0000921C                 ;org 921Ch
.rdata:0000921C ; COMDAT (pick any)
.rdata:0000921C                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000921C ; `string'
.rdata:0000921C ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000921C                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void):loc_48F0o
.rdata:0000921C                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:00009272                 align 4
.rdata:00009272 _rdata          ends
.rdata:00009272
.rdata:00009274 ; ===========================================================================
.rdata:00009274
.rdata:00009274 ; Segment type: Pure data
.rdata:00009274 ; Segment permissions: Read
.rdata:00009274 _rdata          segment dword public 'DATA' use32
.rdata:00009274                 assume cs:_rdata
.rdata:00009274                 ;org 9274h
.rdata:00009274 ; COMDAT (pick any)
.rdata:00009274                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:00009274 ; `string'
.rdata:00009274 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:00009274                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+81o
.rdata:00009274                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+53o
.rdata:00009274                 unicode 0, <%s>,0
.rdata:0000927A                 align 4
.rdata:0000927A _rdata          ends
.rdata:0000927A
.rdata:0000927C ; ===========================================================================
.rdata:0000927C
.rdata:0000927C ; Segment type: Pure data
.rdata:0000927C ; Segment permissions: Read
.rdata:0000927C _rdata          segment dword public 'DATA' use32
.rdata:0000927C                 assume cs:_rdata
.rdata:0000927C                 ;org 927Ch
.rdata:0000927C ; COMDAT (pick any)
.rdata:0000927C                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000927C ; `string'
.rdata:0000927C ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000927C                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+ADo
.rdata:0000927C                 unicode 0, <"out of range">,0
.rdata:0000929A                 align 4
.rdata:0000929A _rdata          ends
.rdata:0000929A
.rdata:0000929C ; ===========================================================================
.rdata:0000929C
.rdata:0000929C ; Segment type: Pure data
.rdata:0000929C ; Segment permissions: Read
.rdata:0000929C _rdata          segment dword public 'DATA' use32
.rdata:0000929C                 assume cs:_rdata
.rdata:0000929C                 ;org 929Ch
.rdata:0000929C ; COMDAT (pick any)
.rdata:0000929C                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:0000929C ; `string'
.rdata:0000929C ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:0000929C                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+41o
.rdata:0000929C _rdata          ends
.rdata:0000929C
.rdata:000092C4 ; ===========================================================================
.rdata:000092C4
.rdata:000092C4 ; Segment type: Pure data
.rdata:000092C4 ; Segment permissions: Read
.rdata:000092C4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000092C4 _rdata          segment para public 'DATA' use32
.rdata:000092C4                 assume cs:_rdata
.rdata:000092C4                 ;org 92C4h
.rdata:000092C4 ; COMDAT (pick any)
.rdata:000092C4                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:000092C4 ; `string'
.rdata:000092C4 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:000092C4                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &):loc_4F66o
.rdata:000092C4                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:00009322                 align 4
.rdata:00009322 _rdata          ends
.rdata:00009322
.rdata:00009324 ; ===========================================================================
.rdata:00009324
.rdata:00009324 ; Segment type: Pure data
.rdata:00009324 ; Segment permissions: Read
.rdata:00009324 _rdata          segment dword public 'DATA' use32
.rdata:00009324                 assume cs:_rdata
.rdata:00009324                 ;org 9324h
.rdata:00009324 ; COMDAT (pick any)
.rdata:00009324                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:00009324 ; `string'
.rdata:00009324 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:00009324                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+85o
.rdata:00009324                 unicode 0, <"invalid argument">,0
.rdata:0000934A                 align 4
.rdata:0000934A _rdata          ends
.rdata:0000934A
.rdata:0000934C ; ===========================================================================
.rdata:0000934C
.rdata:0000934C ; Segment type: Pure data
.rdata:0000934C ; Segment permissions: Read
.rdata:0000934C _rdata          segment dword public 'DATA' use32
.rdata:0000934C                 assume cs:_rdata
.rdata:0000934C                 ;org 934Ch
.rdata:0000934C ; COMDAT (pick any)
.rdata:0000934C                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000934C ; char `string'[]
.rdata:0000934C ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000934C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000934C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:0000934C _rdata          ends
.rdata:0000934C
.rdata:0000935C ; ===========================================================================
.rdata:0000935C
.rdata:0000935C ; Segment type: Pure data
.rdata:0000935C ; Segment permissions: Read
.rdata:0000935C _rdata          segment dword public 'DATA' use32
.rdata:0000935C                 assume cs:_rdata
.rdata:0000935C                 ;org 935Ch
.rdata:0000935C ; COMDAT (pick any)
.rdata:0000935C                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000935C ; char `string'[]
.rdata:0000935C ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000935C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000935C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:0000935C _rdata          ends
.rdata:0000935C
.rdata:00009374 ; ===========================================================================
.rdata:00009374
.rdata:00009374 ; Segment type: Pure data
.rdata:00009374 ; Segment permissions: Read
.rdata:00009374 _rdata          segment dword public 'DATA' use32
.rdata:00009374                 assume cs:_rdata
.rdata:00009374                 ;org 9374h
.rdata:00009374 ; COMDAT (pick any)
.rdata:00009374                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:00009374 ; char `string'[]
.rdata:00009374 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:00009374                                         ; DATA XREF: std::vector<UserCommand,std::allocator<UserCommand>>::_Xlen(void)+7o
.rdata:00009387                 align 4
.rdata:00009387 _rdata          ends
.rdata:00009387
.rdata:00009388 ; ===========================================================================
.rdata:00009388
.rdata:00009388 ; Segment type: Pure data
.rdata:00009388 ; Segment permissions: Read
.rdata:00009388 _rdata          segment dword public 'DATA' use32
.rdata:00009388                 assume cs:_rdata
.rdata:00009388                 ;org 9388h
.rdata:00009388 ; COMDAT (pick any)
.rdata:00009388                 public ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:00009388 ; wchar_t `string'
.rdata:00009388 ??_C@_1DM@KDEKGMPF@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:00009388                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+34o
.rdata:00009388                 unicode 0, <string iterators incompatible>,0
.rdata:00009388 _rdata          ends
.rdata:00009388
.rdata:000093C4 ; ===========================================================================
.rdata:000093C4
.rdata:000093C4 ; Segment type: Pure data
.rdata:000093C4 ; Segment permissions: Read
.rdata:000093C4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000093C4 _rdata          segment para public 'DATA' use32
.rdata:000093C4                 assume cs:_rdata
.rdata:000093C4                 ;org 93C4h
.rdata:000093C4 ; COMDAT (pick any)
.rdata:000093C4                 public ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:000093C4 ; `string'
.rdata:000093C4 ??_C@_1MG@CLNEOJNJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:000093C4                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+80o
.rdata:000093C4                 unicode 0, <std::_String_const_iterator>
.rdata:000093C4                 dw 3Ch
.rdata:000093C4                 unicode 0, <class std::_String_val>
.rdata:000093C4                 dw 3Ch
.rdata:000093C4                 unicode 0, <struct std::_Simple_types>
.rdata:000093C4                 dw 3Ch
.rdata:000093C4                 unicode 0, <wchar_t>
.rdata:000093C4                 dw 3Eh
.rdata:000093C4                 unicode 0, < >
.rdata:000093C4                 dw 3Eh
.rdata:000093C4                 unicode 0, < >
.rdata:000093C4                 dw 3Eh
.rdata:000093C4                 unicode 0, <::_Compat>,0
.rdata:0000948A                 align 4
.rdata:0000948A _rdata          ends
.rdata:0000948A
.rdata:0000948C ; ===========================================================================
.rdata:0000948C
.rdata:0000948C ; Segment type: Pure data
.rdata:0000948C ; Segment permissions: Read
.rdata:0000948C _rdata          segment dword public 'DATA' use32
.rdata:0000948C                 assume cs:_rdata
.rdata:0000948C                 ;org 948Ch
.rdata:0000948C ; COMDAT (pick any)
.rdata:0000948C                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000948C ; wchar_t `string'
.rdata:0000948C ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000948C                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000948C                                         ; std::_Debug_pointer<UserCommand>(UserCommand *,wchar_t const *,uint)+11o ...
.rdata:0000948C                 unicode 0, <invalid null pointer>,0
.rdata:000094B6                 align 4
.rdata:000094B6 _rdata          ends
.rdata:000094B6
.rdata:000094B8 ; ===========================================================================
.rdata:000094B8
.rdata:000094B8 ; Segment type: Pure data
.rdata:000094B8 ; Segment permissions: Read
.rdata:000094B8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000094B8 _rdata          segment para public 'DATA' use32
.rdata:000094B8                 assume cs:_rdata
.rdata:000094B8                 ;org 94B8h
.rdata:000094B8 ; COMDAT (pick any)
.rdata:000094B8                 public ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:000094B8 ; wchar_t `string'
.rdata:000094B8 ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:000094B8                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+62o
.rdata:000094B8                 unicode 0, <string iterator not dereferencable>,0
.rdata:000094FE                 align 10h
.rdata:000094FE _rdata          ends
.rdata:000094FE
.rdata:00009500 ; ===========================================================================
.rdata:00009500
.rdata:00009500 ; Segment type: Pure data
.rdata:00009500 ; Segment permissions: Read
.rdata:00009500 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00009500 _rdata          segment para public 'DATA' use32
.rdata:00009500                 assume cs:_rdata
.rdata:00009500                 ;org 9500h
.rdata:00009500 ; COMDAT (pick any)
.rdata:00009500                 public ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:00009500 ; `string'
.rdata:00009500 ??_C@_1MM@BFHGHMKD@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:00009500                                         ; DATA XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+A8o
.rdata:00009500                 unicode 0, <std::_String_const_iterator>
.rdata:00009500                 dw 3Ch
.rdata:00009500                 unicode 0, <class std::_String_val>
.rdata:00009500                 dw 3Ch
.rdata:00009500                 unicode 0, <struct std::_Simple_types>
.rdata:00009500                 dw 3Ch
.rdata:00009500                 unicode 0, <wchar_t>
.rdata:00009500                 dw 3Eh
.rdata:00009500                 unicode 0, < >
.rdata:00009500                 dw 3Eh
.rdata:00009500                 unicode 0, < >
.rdata:00009500                 dw 3Eh
.rdata:00009500                 unicode 0, <::operator *>,0
.rdata:00009500 _rdata          ends
.rdata:00009500
.rdata:000095CC ; ===========================================================================
.rdata:000095CC
.rdata:000095CC ; Segment type: Pure data
.rdata:000095CC ; Segment permissions: Read
.rdata:000095CC _rdata          segment dword public 'DATA' use32
.rdata:000095CC                 assume cs:_rdata
.rdata:000095CC                 ;org 95CCh
.rdata:000095CC ; COMDAT (pick any)
.rdata:000095CC                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:000095CC ; wchar_t `string'
.rdata:000095CC ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:000095CC                                         ; DATA XREF: std::_Debug_range2<UserCommand *>(UserCommand *,UserCommand *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:000095CC                 unicode 0, <invalid iterator range>,0
.rdata:000095FA                 align 4
.rdata:000095FA _rdata          ends
.rdata:000095FA
.rdata:000095FC ; ===========================================================================
.rdata:000095FC
.rdata:000095FC ; Segment type: Pure data
.rdata:000095FC ; Segment permissions: Read
.rdata:000095FC ; Segment alignment 'qword' can not be represented in assembly
.rdata:000095FC _rdata          segment para public 'DATA' use32
.rdata:000095FC                 assume cs:_rdata
.rdata:000095FC                 ;org 95FCh
.rdata:000095FC ; COMDAT (pick any)
.rdata:000095FC                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000095FC ; wchar_t `string'
.rdata:000095FC ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000095FC                                         ; DATA XREF: std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+2Fo
.rdata:000095FC                                         ; std::_Uninit_move<UserCommand *,UserCommand *,std::allocator<UserCommand>,UserCommand>(UserCommand *,UserCommand *,UserCommand *,std::_Wrap_alloc<std::allocator<UserCommand>> &,UserCommand *,std::_Nonscalar_ptr_iterator_tag)+49o
.rdata:000095FC                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000095FC                 unicode 0, <clude\xmemory>,0
.rdata:0000968A                 align 4
.rdata:0000968A _rdata          ends
.rdata:0000968A
.rdata$r:0000968C ; ===========================================================================
.rdata$r:0000968C
.rdata$r:0000968C ; Segment type: Pure data
.rdata$r:0000968C ; Segment permissions: Read
.rdata$r:0000968C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000968C                 assume cs:_rdata$r
.rdata$r:0000968C                 ;org 968Ch
.rdata$r:0000968C ; COMDAT (pick any)
.rdata$r:0000968C                 public ??_R4Window@@6B@
.rdata$r:0000968C ; const Window::`RTTI Complete Object Locator'
.rdata$r:0000968C ??_R4Window@@6B@ db    0                ; DATA XREF: .rdata:00008E60o
.rdata$r:0000968D                 db    0
.rdata$r:0000968E                 db    0
.rdata$r:0000968F                 db    0
.rdata$r:00009690                 db    0
.rdata$r:00009691                 db    0
.rdata$r:00009692                 db    0
.rdata$r:00009693                 db    0
.rdata$r:00009694                 db    0
.rdata$r:00009695                 db    0
.rdata$r:00009696                 db    0
.rdata$r:00009697                 db    0
.rdata$r:00009698                 dd offset ??_R0?AVWindow@@@8 ; Window `RTTI Type Descriptor'
.rdata$r:0000969C                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000969C _rdata$r        ends
.rdata$r:0000969C
.data$r:000096A0 ; ===========================================================================
.data$r:000096A0
.data$r:000096A0 ; Segment type: Pure data
.data$r:000096A0 ; Segment permissions: Read/Write
.data$r:000096A0 _data$r         segment dword public 'DATA' use32
.data$r:000096A0                 assume cs:_data$r
.data$r:000096A0                 ;org 96A0h
.data$r:000096A0 ; COMDAT (pick any)
.data$r:000096A0                 public ??_R0?AVWindow@@@8
.data$r:000096A0 ; class Window `RTTI Type Descriptor'
.data$r:000096A0 ??_R0?AVWindow@@@8 dd offset ??_7type_info@@6B@
.data$r:000096A0                                         ; DATA XREF: .rdata$r:00009698o
.data$r:000096A0                                         ; .rdata$r:Window::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000096A0                                         ; const type_info::`vftable'
.data$r:000096A4                 align 8
.data$r:000096A8 a_?avwindow@@   db '.?AVWindow@@',0
.data$r:000096B5                 align 4
.data$r:000096B5 _data$r         ends
.data$r:000096B5
.rdata$r:000096B8 ; ===========================================================================
.rdata$r:000096B8
.rdata$r:000096B8 ; Segment type: Pure data
.rdata$r:000096B8 ; Segment permissions: Read
.rdata$r:000096B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096B8                 assume cs:_rdata$r
.rdata$r:000096B8                 ;org 96B8h
.rdata$r:000096B8 ; COMDAT (pick any)
.rdata$r:000096B8                 public ??_R3Window@@8
.rdata$r:000096B8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:000096B8 ??_R3Window@@8  db    0                 ; DATA XREF: .rdata$r:0000969Co
.rdata$r:000096B8                                         ; .rdata$r:000096E8o
.rdata$r:000096B9                 db    0
.rdata$r:000096BA                 db    0
.rdata$r:000096BB                 db    0
.rdata$r:000096BC                 db    0
.rdata$r:000096BD                 db    0
.rdata$r:000096BE                 db    0
.rdata$r:000096BF                 db    0
.rdata$r:000096C0                 db    1
.rdata$r:000096C1                 db    0
.rdata$r:000096C2                 db    0
.rdata$r:000096C3                 db    0
.rdata$r:000096C4                 dd offset ??_R2Window@@8 ; Window::`RTTI Base Class Array'
.rdata$r:000096C4 _rdata$r        ends
.rdata$r:000096C4
.rdata$r:000096C8 ; ===========================================================================
.rdata$r:000096C8
.rdata$r:000096C8 ; Segment type: Pure data
.rdata$r:000096C8 ; Segment permissions: Read
.rdata$r:000096C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096C8                 assume cs:_rdata$r
.rdata$r:000096C8                 ;org 96C8h
.rdata$r:000096C8 ; COMDAT (pick any)
.rdata$r:000096C8                 public ??_R2Window@@8
.rdata$r:000096C8 ; Window::`RTTI Base Class Array'
.rdata$r:000096C8 ??_R2Window@@8  dd offset ??_R1A@?0A@EA@Window@@8
.rdata$r:000096C8                                         ; DATA XREF: .rdata$r:000096C4o
.rdata$r:000096C8                                         ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000096CC                 db    0
.rdata$r:000096CD                 align 10h
.rdata$r:000096CD _rdata$r        ends
.rdata$r:000096CD
.rdata$r:000096D0 ; ===========================================================================
.rdata$r:000096D0
.rdata$r:000096D0 ; Segment type: Pure data
.rdata$r:000096D0 ; Segment permissions: Read
.rdata$r:000096D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096D0                 assume cs:_rdata$r
.rdata$r:000096D0                 ;org 96D0h
.rdata$r:000096D0 ; COMDAT (pick any)
.rdata$r:000096D0                 public ??_R1A@?0A@EA@Window@@8
.rdata$r:000096D0 ; Window::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000096D0 ??_R1A@?0A@EA@Window@@8 dd offset ??_R0?AVWindow@@@8
.rdata$r:000096D0                                         ; DATA XREF: .rdata$r:Window::`RTTI Base Class Array'o
.rdata$r:000096D0                                         ; .rdata$r:00009730o ...
.rdata$r:000096D0                                         ; Window `RTTI Type Descriptor'
.rdata$r:000096D4                 db    0
.rdata$r:000096D5                 db    0
.rdata$r:000096D6                 db    0
.rdata$r:000096D7                 db    0
.rdata$r:000096D8                 db    0
.rdata$r:000096D9                 db    0
.rdata$r:000096DA                 db    0
.rdata$r:000096DB                 db    0
.rdata$r:000096DC                 db 0FFh
.rdata$r:000096DD                 db 0FFh
.rdata$r:000096DE                 db 0FFh
.rdata$r:000096DF                 db 0FFh
.rdata$r:000096E0                 db    0
.rdata$r:000096E1                 db    0
.rdata$r:000096E2                 db    0
.rdata$r:000096E3                 db    0
.rdata$r:000096E4                 db  40h ; @
.rdata$r:000096E5                 db    0
.rdata$r:000096E6                 db    0
.rdata$r:000096E7                 db    0
.rdata$r:000096E8                 dd offset ??_R3Window@@8 ; Window::`RTTI Class Hierarchy Descriptor'
.rdata$r:000096E8 _rdata$r        ends
.rdata$r:000096E8
.rdata$r:000096EC ; ===========================================================================
.rdata$r:000096EC
.rdata$r:000096EC ; Segment type: Pure data
.rdata$r:000096EC ; Segment permissions: Read
.rdata$r:000096EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000096EC                 assume cs:_rdata$r
.rdata$r:000096EC                 ;org 96ECh
.rdata$r:000096EC ; COMDAT (pick any)
.rdata$r:000096EC                 public ??_R4StaticDialog@@6B@
.rdata$r:000096EC ; const StaticDialog::`RTTI Complete Object Locator'
.rdata$r:000096EC ??_R4StaticDialog@@6B@ db    0          ; DATA XREF: .rdata:00008E94o
.rdata$r:000096ED                 db    0
.rdata$r:000096EE                 db    0
.rdata$r:000096EF                 db    0
.rdata$r:000096F0                 db    0
.rdata$r:000096F1                 db    0
.rdata$r:000096F2                 db    0
.rdata$r:000096F3                 db    0
.rdata$r:000096F4                 db    0
.rdata$r:000096F5                 db    0
.rdata$r:000096F6                 db    0
.rdata$r:000096F7                 db    0
.rdata$r:000096F8                 dd offset ??_R0?AVStaticDialog@@@8 ; StaticDialog `RTTI Type Descriptor'
.rdata$r:000096FC                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:000096FC _rdata$r        ends
.rdata$r:000096FC
.data$r:00009700 ; ===========================================================================
.data$r:00009700
.data$r:00009700 ; Segment type: Pure data
.data$r:00009700 ; Segment permissions: Read/Write
.data$r:00009700 _data$r         segment dword public 'DATA' use32
.data$r:00009700                 assume cs:_data$r
.data$r:00009700                 ;org 9700h
.data$r:00009700 ; COMDAT (pick any)
.data$r:00009700                 public ??_R0?AVStaticDialog@@@8
.data$r:00009700 ; class StaticDialog `RTTI Type Descriptor'
.data$r:00009700 ??_R0?AVStaticDialog@@@8 dd offset ??_7type_info@@6B@
.data$r:00009700                                         ; DATA XREF: .rdata$r:000096F8o
.data$r:00009700                                         ; .rdata$r:StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009700                                         ; const type_info::`vftable'
.data$r:00009704                 align 8
.data$r:00009708 a_?avstaticdial db '.?AVStaticDialog@@',0
.data$r:0000971B                 align 4
.data$r:0000971B _data$r         ends
.data$r:0000971B
.rdata$r:0000971C ; ===========================================================================
.rdata$r:0000971C
.rdata$r:0000971C ; Segment type: Pure data
.rdata$r:0000971C ; Segment permissions: Read
.rdata$r:0000971C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000971C                 assume cs:_rdata$r
.rdata$r:0000971C                 ;org 971Ch
.rdata$r:0000971C ; COMDAT (pick any)
.rdata$r:0000971C                 public ??_R3StaticDialog@@8
.rdata$r:0000971C ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000971C ??_R3StaticDialog@@8 db    0            ; DATA XREF: .rdata$r:000096FCo
.rdata$r:0000971C                                         ; .rdata$r:00009750o
.rdata$r:0000971D                 db    0
.rdata$r:0000971E                 db    0
.rdata$r:0000971F                 db    0
.rdata$r:00009720                 db    0
.rdata$r:00009721                 db    0
.rdata$r:00009722                 db    0
.rdata$r:00009723                 db    0
.rdata$r:00009724                 db    2
.rdata$r:00009725                 db    0
.rdata$r:00009726                 db    0
.rdata$r:00009727                 db    0
.rdata$r:00009728                 dd offset ??_R2StaticDialog@@8 ; StaticDialog::`RTTI Base Class Array'
.rdata$r:00009728 _rdata$r        ends
.rdata$r:00009728
.rdata$r:0000972C ; ===========================================================================
.rdata$r:0000972C
.rdata$r:0000972C ; Segment type: Pure data
.rdata$r:0000972C ; Segment permissions: Read
.rdata$r:0000972C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000972C                 assume cs:_rdata$r
.rdata$r:0000972C                 ;org 972Ch
.rdata$r:0000972C ; COMDAT (pick any)
.rdata$r:0000972C                 public ??_R2StaticDialog@@8
.rdata$r:0000972C ; StaticDialog::`RTTI Base Class Array'
.rdata$r:0000972C ??_R2StaticDialog@@8 dd offset ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:0000972C                                         ; DATA XREF: .rdata$r:00009728o
.rdata$r:0000972C                                         ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009730                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009734                 db    0
.rdata$r:00009735                 align 4
.rdata$r:00009735 _rdata$r        ends
.rdata$r:00009735
.rdata$r:00009738 ; ===========================================================================
.rdata$r:00009738
.rdata$r:00009738 ; Segment type: Pure data
.rdata$r:00009738 ; Segment permissions: Read
.rdata$r:00009738 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009738                 assume cs:_rdata$r
.rdata$r:00009738                 ;org 9738h
.rdata$r:00009738 ; COMDAT (pick any)
.rdata$r:00009738                 public ??_R1A@?0A@EA@StaticDialog@@8
.rdata$r:00009738 ; StaticDialog::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009738 ??_R1A@?0A@EA@StaticDialog@@8 dd offset ??_R0?AVStaticDialog@@@8
.rdata$r:00009738                                         ; DATA XREF: .rdata$r:StaticDialog::`RTTI Base Class Array'o
.rdata$r:00009738                                         ; .rdata$r:00009970o ...
.rdata$r:00009738                                         ; StaticDialog `RTTI Type Descriptor'
.rdata$r:0000973C                 db    1
.rdata$r:0000973D                 db    0
.rdata$r:0000973E                 db    0
.rdata$r:0000973F                 db    0
.rdata$r:00009740                 db    0
.rdata$r:00009741                 db    0
.rdata$r:00009742                 db    0
.rdata$r:00009743                 db    0
.rdata$r:00009744                 db 0FFh
.rdata$r:00009745                 db 0FFh
.rdata$r:00009746                 db 0FFh
.rdata$r:00009747                 db 0FFh
.rdata$r:00009748                 db    0
.rdata$r:00009749                 db    0
.rdata$r:0000974A                 db    0
.rdata$r:0000974B                 db    0
.rdata$r:0000974C                 db  40h ; @
.rdata$r:0000974D                 db    0
.rdata$r:0000974E                 db    0
.rdata$r:0000974F                 db    0
.rdata$r:00009750                 dd offset ??_R3StaticDialog@@8 ; StaticDialog::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009750 _rdata$r        ends
.rdata$r:00009750
.rdata$r:00009754 ; ===========================================================================
.rdata$r:00009754
.rdata$r:00009754 ; Segment type: Pure data
.rdata$r:00009754 ; Segment permissions: Read
.rdata$r:00009754 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009754                 assume cs:_rdata$r
.rdata$r:00009754                 ;org 9754h
.rdata$r:00009754 ; COMDAT (pick any)
.rdata$r:00009754                 public ??_R4error_category@std@@6B@
.rdata$r:00009754 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00009754 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00008F9Co
.rdata$r:00009755                 db    0
.rdata$r:00009756                 db    0
.rdata$r:00009757                 db    0
.rdata$r:00009758                 db    0
.rdata$r:00009759                 db    0
.rdata$r:0000975A                 db    0
.rdata$r:0000975B                 db    0
.rdata$r:0000975C                 db    0
.rdata$r:0000975D                 db    0
.rdata$r:0000975E                 db    0
.rdata$r:0000975F                 db    0
.rdata$r:00009760                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00009764                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009764 _rdata$r        ends
.rdata$r:00009764
.data$r:00009768 ; ===========================================================================
.data$r:00009768
.data$r:00009768 ; Segment type: Pure data
.data$r:00009768 ; Segment permissions: Read/Write
.data$r:00009768 _data$r         segment dword public 'DATA' use32
.data$r:00009768                 assume cs:_data$r
.data$r:00009768                 ;org 9768h
.data$r:00009768 ; COMDAT (pick any)
.data$r:00009768                 public ??_R0?AVerror_category@std@@@8
.data$r:00009768 ; class std::error_category `RTTI Type Descriptor'
.data$r:00009768 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00009768                                         ; DATA XREF: .rdata$r:00009760o
.data$r:00009768                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009768                                         ; const type_info::`vftable'
.data$r:0000976C                 align 10h
.data$r:00009770 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:00009789                 align 4
.data$r:00009789 _data$r         ends
.data$r:00009789
.rdata$r:0000978C ; ===========================================================================
.rdata$r:0000978C
.rdata$r:0000978C ; Segment type: Pure data
.rdata$r:0000978C ; Segment permissions: Read
.rdata$r:0000978C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000978C                 assume cs:_rdata$r
.rdata$r:0000978C                 ;org 978Ch
.rdata$r:0000978C ; COMDAT (pick any)
.rdata$r:0000978C                 public ??_R3error_category@std@@8
.rdata$r:0000978C ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000978C ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00009764o
.rdata$r:0000978C                                         ; .rdata$r:000097BCo
.rdata$r:0000978D                 db    0
.rdata$r:0000978E                 db    0
.rdata$r:0000978F                 db    0
.rdata$r:00009790                 db    0
.rdata$r:00009791                 db    0
.rdata$r:00009792                 db    0
.rdata$r:00009793                 db    0
.rdata$r:00009794                 db    1
.rdata$r:00009795                 db    0
.rdata$r:00009796                 db    0
.rdata$r:00009797                 db    0
.rdata$r:00009798                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00009798 _rdata$r        ends
.rdata$r:00009798
.rdata$r:0000979C ; ===========================================================================
.rdata$r:0000979C
.rdata$r:0000979C ; Segment type: Pure data
.rdata$r:0000979C ; Segment permissions: Read
.rdata$r:0000979C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000979C                 assume cs:_rdata$r
.rdata$r:0000979C                 ;org 979Ch
.rdata$r:0000979C ; COMDAT (pick any)
.rdata$r:0000979C                 public ??_R2error_category@std@@8
.rdata$r:0000979C ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000979C ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000979C                                         ; DATA XREF: .rdata$r:00009798o
.rdata$r:0000979C                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000097A0                 db    0
.rdata$r:000097A1                 align 4
.rdata$r:000097A1 _rdata$r        ends
.rdata$r:000097A1
.rdata$r:000097A4 ; ===========================================================================
.rdata$r:000097A4
.rdata$r:000097A4 ; Segment type: Pure data
.rdata$r:000097A4 ; Segment permissions: Read
.rdata$r:000097A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000097A4                 assume cs:_rdata$r
.rdata$r:000097A4                 ;org 97A4h
.rdata$r:000097A4 ; COMDAT (pick any)
.rdata$r:000097A4                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000097A4 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000097A4 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000097A4                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000097A4                                         ; .rdata$r:00009814o ...
.rdata$r:000097A4                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000097A8                 align 10h
.rdata$r:000097B0                 db 0FFh
.rdata$r:000097B1                 db 0FFh
.rdata$r:000097B2                 db 0FFh
.rdata$r:000097B3                 db 0FFh
.rdata$r:000097B4                 db    0
.rdata$r:000097B5                 db    0
.rdata$r:000097B6                 db    0
.rdata$r:000097B7                 db    0
.rdata$r:000097B8                 db  40h ; @
.rdata$r:000097B9                 db    0
.rdata$r:000097BA                 db    0
.rdata$r:000097BB                 db    0
.rdata$r:000097BC                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000097BC _rdata$r        ends
.rdata$r:000097BC
.rdata$r:000097C0 ; ===========================================================================
.rdata$r:000097C0
.rdata$r:000097C0 ; Segment type: Pure data
.rdata$r:000097C0 ; Segment permissions: Read
.rdata$r:000097C0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000097C0                 assume cs:_rdata$r
.rdata$r:000097C0                 ;org 97C0h
.rdata$r:000097C0 ; COMDAT (pick any)
.rdata$r:000097C0                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:000097C0 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:000097C0 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:000097C0                                         ; DATA XREF: .rdata:00008FB8o
.rdata$r:000097C1                 db    0
.rdata$r:000097C2                 db    0
.rdata$r:000097C3                 db    0
.rdata$r:000097C4                 db    0
.rdata$r:000097C5                 db    0
.rdata$r:000097C6                 db    0
.rdata$r:000097C7                 db    0
.rdata$r:000097C8                 db    0
.rdata$r:000097C9                 db    0
.rdata$r:000097CA                 db    0
.rdata$r:000097CB                 db    0
.rdata$r:000097CC                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:000097D0                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000097D0 _rdata$r        ends
.rdata$r:000097D0
.data$r:000097D4 ; ===========================================================================
.data$r:000097D4
.data$r:000097D4 ; Segment type: Pure data
.data$r:000097D4 ; Segment permissions: Read/Write
.data$r:000097D4 _data$r         segment dword public 'DATA' use32
.data$r:000097D4                 assume cs:_data$r
.data$r:000097D4                 ;org 97D4h
.data$r:000097D4 ; COMDAT (pick any)
.data$r:000097D4                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:000097D4 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:000097D4 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000097D4                                         ; DATA XREF: .rdata$r:000097CCo
.data$r:000097D4                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000097D4                                         ; const type_info::`vftable'
.data$r:000097D8                 db    0
.data$r:000097D9                 db    0
.data$r:000097DA                 db    0
.data$r:000097DB                 db    0
.data$r:000097DC                 db  2Eh ; .
.data$r:000097DD                 db  3Fh ; ?
.data$r:000097DE                 db  41h ; A
.data$r:000097DF                 db  56h ; V
.data$r:000097E0                 db  5Fh ; _
.data$r:000097E1                 db  47h ; G
.data$r:000097E2                 db  65h ; e
.data$r:000097E3                 db  6Eh ; n
.data$r:000097E4                 db  65h ; e
.data$r:000097E5                 db  72h ; r
.data$r:000097E6                 db  69h ; i
.data$r:000097E7                 db  63h ; c
.data$r:000097E8                 db  5Fh ; _
.data$r:000097E9                 db  65h ; e
.data$r:000097EA                 db  72h ; r
.data$r:000097EB                 db  72h ; r
.data$r:000097EC                 db  6Fh ; o
.data$r:000097ED                 db  72h ; r
.data$r:000097EE                 db  5Fh ; _
.data$r:000097EF                 db  63h ; c
.data$r:000097F0                 db  61h ; a
.data$r:000097F1                 db  74h ; t
.data$r:000097F2                 db  65h ; e
.data$r:000097F3                 db  67h ; g
.data$r:000097F4                 db  6Fh ; o
.data$r:000097F5                 db  72h ; r
.data$r:000097F6                 db  79h ; y
.data$r:000097F7                 db  40h ; @
.data$r:000097F8                 db  73h ; s
.data$r:000097F9                 db  74h ; t
.data$r:000097FA                 db  64h ; d
.data$r:000097FB                 db  40h ; @
.data$r:000097FC                 db  40h ; @
.data$r:000097FD                 db    0
.data$r:000097FE                 align 10h
.data$r:000097FE _data$r         ends
.data$r:000097FE
.rdata$r:00009800 ; ===========================================================================
.rdata$r:00009800
.rdata$r:00009800 ; Segment type: Pure data
.rdata$r:00009800 ; Segment permissions: Read
.rdata$r:00009800 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009800                 assume cs:_rdata$r
.rdata$r:00009800                 ;org 9800h
.rdata$r:00009800 ; COMDAT (pick any)
.rdata$r:00009800                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00009800 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009800 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00009800                                         ; DATA XREF: .rdata$r:000097D0o
.rdata$r:00009800                                         ; .rdata$r:00009834o
.rdata$r:00009801                 db    0
.rdata$r:00009802                 db    0
.rdata$r:00009803                 db    0
.rdata$r:00009804                 db    0
.rdata$r:00009805                 db    0
.rdata$r:00009806                 db    0
.rdata$r:00009807                 db    0
.rdata$r:00009808                 db    2
.rdata$r:00009809                 db    0
.rdata$r:0000980A                 db    0
.rdata$r:0000980B                 db    0
.rdata$r:0000980C                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000980C _rdata$r        ends
.rdata$r:0000980C
.rdata$r:00009810 ; ===========================================================================
.rdata$r:00009810
.rdata$r:00009810 ; Segment type: Pure data
.rdata$r:00009810 ; Segment permissions: Read
.rdata$r:00009810 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009810                 assume cs:_rdata$r
.rdata$r:00009810                 ;org 9810h
.rdata$r:00009810 ; COMDAT (pick any)
.rdata$r:00009810                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00009810 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00009810 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00009810                                         ; DATA XREF: .rdata$r:0000980Co
.rdata$r:00009810                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009814                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009818                 db    0
.rdata$r:00009819                 align 4
.rdata$r:00009819 _rdata$r        ends
.rdata$r:00009819
.rdata$r:0000981C ; ===========================================================================
.rdata$r:0000981C
.rdata$r:0000981C ; Segment type: Pure data
.rdata$r:0000981C ; Segment permissions: Read
.rdata$r:0000981C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000981C                 assume cs:_rdata$r
.rdata$r:0000981C                 ;org 981Ch
.rdata$r:0000981C ; COMDAT (pick any)
.rdata$r:0000981C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000981C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000981C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000981C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000981C                                         ; .rdata$r:0000988Co ...
.rdata$r:0000981C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00009820                 db    1
.rdata$r:00009821                 db    0
.rdata$r:00009822                 db    0
.rdata$r:00009823                 db    0
.rdata$r:00009824                 db    0
.rdata$r:00009825                 db    0
.rdata$r:00009826                 db    0
.rdata$r:00009827                 db    0
.rdata$r:00009828                 db 0FFh
.rdata$r:00009829                 db 0FFh
.rdata$r:0000982A                 db 0FFh
.rdata$r:0000982B                 db 0FFh
.rdata$r:0000982C                 db    0
.rdata$r:0000982D                 db    0
.rdata$r:0000982E                 db    0
.rdata$r:0000982F                 db    0
.rdata$r:00009830                 db  40h ; @
.rdata$r:00009831                 db    0
.rdata$r:00009832                 db    0
.rdata$r:00009833                 db    0
.rdata$r:00009834                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009834 _rdata$r        ends
.rdata$r:00009834
.rdata$r:00009838 ; ===========================================================================
.rdata$r:00009838
.rdata$r:00009838 ; Segment type: Pure data
.rdata$r:00009838 ; Segment permissions: Read
.rdata$r:00009838 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009838                 assume cs:_rdata$r
.rdata$r:00009838                 ;org 9838h
.rdata$r:00009838 ; COMDAT (pick any)
.rdata$r:00009838                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00009838 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00009838 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00009838                                         ; DATA XREF: .rdata:00008FECo
.rdata$r:00009839                 db    0
.rdata$r:0000983A                 db    0
.rdata$r:0000983B                 db    0
.rdata$r:0000983C                 db    0
.rdata$r:0000983D                 db    0
.rdata$r:0000983E                 db    0
.rdata$r:0000983F                 db    0
.rdata$r:00009840                 db    0
.rdata$r:00009841                 db    0
.rdata$r:00009842                 db    0
.rdata$r:00009843                 db    0
.rdata$r:00009844                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00009848                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009848 _rdata$r        ends
.rdata$r:00009848
.data$r:0000984C ; ===========================================================================
.data$r:0000984C
.data$r:0000984C ; Segment type: Pure data
.data$r:0000984C ; Segment permissions: Read/Write
.data$r:0000984C _data$r         segment dword public 'DATA' use32
.data$r:0000984C                 assume cs:_data$r
.data$r:0000984C                 ;org 984Ch
.data$r:0000984C ; COMDAT (pick any)
.data$r:0000984C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000984C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000984C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000984C                                         ; DATA XREF: .rdata$r:00009844o
.data$r:0000984C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000984C                                         ; const type_info::`vftable'
.data$r:00009850                 db    0
.data$r:00009851                 db    0
.data$r:00009852                 db    0
.data$r:00009853                 db    0
.data$r:00009854                 db  2Eh ; .
.data$r:00009855                 db  3Fh ; ?
.data$r:00009856                 db  41h ; A
.data$r:00009857                 db  56h ; V
.data$r:00009858                 db  5Fh ; _
.data$r:00009859                 db  49h ; I
.data$r:0000985A                 db  6Fh ; o
.data$r:0000985B                 db  73h ; s
.data$r:0000985C                 db  74h ; t
.data$r:0000985D                 db  72h ; r
.data$r:0000985E                 db  65h ; e
.data$r:0000985F                 db  61h ; a
.data$r:00009860                 db  6Dh ; m
.data$r:00009861                 db  5Fh ; _
.data$r:00009862                 db  65h ; e
.data$r:00009863                 db  72h ; r
.data$r:00009864                 db  72h ; r
.data$r:00009865                 db  6Fh ; o
.data$r:00009866                 db  72h ; r
.data$r:00009867                 db  5Fh ; _
.data$r:00009868                 db  63h ; c
.data$r:00009869                 db  61h ; a
.data$r:0000986A                 db  74h ; t
.data$r:0000986B                 db  65h ; e
.data$r:0000986C                 db  67h ; g
.data$r:0000986D                 db  6Fh ; o
.data$r:0000986E                 db  72h ; r
.data$r:0000986F                 db  79h ; y
.data$r:00009870                 db  40h ; @
.data$r:00009871                 db  73h ; s
.data$r:00009872                 db  74h ; t
.data$r:00009873                 db  64h ; d
.data$r:00009874                 db  40h ; @
.data$r:00009875                 db  40h ; @
.data$r:00009876                 db    0
.data$r:00009877                 align 4
.data$r:00009877 _data$r         ends
.data$r:00009877
.rdata$r:00009878 ; ===========================================================================
.rdata$r:00009878
.rdata$r:00009878 ; Segment type: Pure data
.rdata$r:00009878 ; Segment permissions: Read
.rdata$r:00009878 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009878                 assume cs:_rdata$r
.rdata$r:00009878                 ;org 9878h
.rdata$r:00009878 ; COMDAT (pick any)
.rdata$r:00009878                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:00009878 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009878 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:00009878                                         ; DATA XREF: .rdata$r:00009848o
.rdata$r:00009878                                         ; .rdata$r:000098B0o
.rdata$r:00009879                 db    0
.rdata$r:0000987A                 db    0
.rdata$r:0000987B                 db    0
.rdata$r:0000987C                 db    0
.rdata$r:0000987D                 db    0
.rdata$r:0000987E                 db    0
.rdata$r:0000987F                 db    0
.rdata$r:00009880                 db    3
.rdata$r:00009881                 db    0
.rdata$r:00009882                 db    0
.rdata$r:00009883                 db    0
.rdata$r:00009884                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00009884 _rdata$r        ends
.rdata$r:00009884
.rdata$r:00009888 ; ===========================================================================
.rdata$r:00009888
.rdata$r:00009888 ; Segment type: Pure data
.rdata$r:00009888 ; Segment permissions: Read
.rdata$r:00009888 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009888                 assume cs:_rdata$r
.rdata$r:00009888                 ;org 9888h
.rdata$r:00009888 ; COMDAT (pick any)
.rdata$r:00009888                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:00009888 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:00009888 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00009888                                         ; DATA XREF: .rdata$r:00009884o
.rdata$r:00009888                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000988C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009890                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009894                 db    0
.rdata$r:00009895                 align 4
.rdata$r:00009895 _rdata$r        ends
.rdata$r:00009895
.rdata$r:00009898 ; ===========================================================================
.rdata$r:00009898
.rdata$r:00009898 ; Segment type: Pure data
.rdata$r:00009898 ; Segment permissions: Read
.rdata$r:00009898 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009898                 assume cs:_rdata$r
.rdata$r:00009898                 ;org 9898h
.rdata$r:00009898 ; COMDAT (pick any)
.rdata$r:00009898                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:00009898 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009898 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:00009898                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:00009898                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000989C                 db    2
.rdata$r:0000989D                 db    0
.rdata$r:0000989E                 db    0
.rdata$r:0000989F                 db    0
.rdata$r:000098A0                 db    0
.rdata$r:000098A1                 db    0
.rdata$r:000098A2                 db    0
.rdata$r:000098A3                 db    0
.rdata$r:000098A4                 db 0FFh
.rdata$r:000098A5                 db 0FFh
.rdata$r:000098A6                 db 0FFh
.rdata$r:000098A7                 db 0FFh
.rdata$r:000098A8                 db    0
.rdata$r:000098A9                 db    0
.rdata$r:000098AA                 db    0
.rdata$r:000098AB                 db    0
.rdata$r:000098AC                 db  40h ; @
.rdata$r:000098AD                 db    0
.rdata$r:000098AE                 db    0
.rdata$r:000098AF                 db    0
.rdata$r:000098B0                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000098B0 _rdata$r        ends
.rdata$r:000098B0
.rdata$r:000098B4 ; ===========================================================================
.rdata$r:000098B4
.rdata$r:000098B4 ; Segment type: Pure data
.rdata$r:000098B4 ; Segment permissions: Read
.rdata$r:000098B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000098B4                 assume cs:_rdata$r
.rdata$r:000098B4                 ;org 98B4h
.rdata$r:000098B4 ; COMDAT (pick any)
.rdata$r:000098B4                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000098B4 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000098B4 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000902Co
.rdata$r:000098B5                 db    0
.rdata$r:000098B6                 db    0
.rdata$r:000098B7                 db    0
.rdata$r:000098B8                 db    0
.rdata$r:000098B9                 db    0
.rdata$r:000098BA                 db    0
.rdata$r:000098BB                 db    0
.rdata$r:000098BC                 db    0
.rdata$r:000098BD                 db    0
.rdata$r:000098BE                 db    0
.rdata$r:000098BF                 db    0
.rdata$r:000098C0                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:000098C4                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000098C4 _rdata$r        ends
.rdata$r:000098C4
.data$r:000098C8 ; ===========================================================================
.data$r:000098C8
.data$r:000098C8 ; Segment type: Pure data
.data$r:000098C8 ; Segment permissions: Read/Write
.data$r:000098C8 _data$r         segment dword public 'DATA' use32
.data$r:000098C8                 assume cs:_data$r
.data$r:000098C8                 ;org 98C8h
.data$r:000098C8 ; COMDAT (pick any)
.data$r:000098C8                 public ??_R0?AV_System_error_category@std@@@8
.data$r:000098C8 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:000098C8 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000098C8                                         ; DATA XREF: .rdata$r:000098C0o
.data$r:000098C8                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000098C8                                         ; const type_info::`vftable'
.data$r:000098CC                 align 10h
.data$r:000098D0 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:000098F1                 align 4
.data$r:000098F1 _data$r         ends
.data$r:000098F1
.rdata$r:000098F4 ; ===========================================================================
.rdata$r:000098F4
.rdata$r:000098F4 ; Segment type: Pure data
.rdata$r:000098F4 ; Segment permissions: Read
.rdata$r:000098F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000098F4                 assume cs:_rdata$r
.rdata$r:000098F4                 ;org 98F4h
.rdata$r:000098F4 ; COMDAT (pick any)
.rdata$r:000098F4                 public ??_R3_System_error_category@std@@8
.rdata$r:000098F4 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000098F4 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:000098C4o
.rdata$r:000098F4                                         ; .rdata$r:0000992Co
.rdata$r:000098F5                 db    0
.rdata$r:000098F6                 db    0
.rdata$r:000098F7                 db    0
.rdata$r:000098F8                 db    0
.rdata$r:000098F9                 db    0
.rdata$r:000098FA                 db    0
.rdata$r:000098FB                 db    0
.rdata$r:000098FC                 db    3
.rdata$r:000098FD                 db    0
.rdata$r:000098FE                 db    0
.rdata$r:000098FF                 db    0
.rdata$r:00009900                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00009900 _rdata$r        ends
.rdata$r:00009900
.rdata$r:00009904 ; ===========================================================================
.rdata$r:00009904
.rdata$r:00009904 ; Segment type: Pure data
.rdata$r:00009904 ; Segment permissions: Read
.rdata$r:00009904 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009904                 assume cs:_rdata$r
.rdata$r:00009904                 ;org 9904h
.rdata$r:00009904 ; COMDAT (pick any)
.rdata$r:00009904                 public ??_R2_System_error_category@std@@8
.rdata$r:00009904 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00009904 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00009904                                         ; DATA XREF: .rdata$r:00009900o
.rdata$r:00009904                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009908                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000990C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009910                 db    0
.rdata$r:00009911                 align 4
.rdata$r:00009911 _rdata$r        ends
.rdata$r:00009911
.rdata$r:00009914 ; ===========================================================================
.rdata$r:00009914
.rdata$r:00009914 ; Segment type: Pure data
.rdata$r:00009914 ; Segment permissions: Read
.rdata$r:00009914 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009914                 assume cs:_rdata$r
.rdata$r:00009914                 ;org 9914h
.rdata$r:00009914 ; COMDAT (pick any)
.rdata$r:00009914                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00009914 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009914 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00009914                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00009914                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00009918                 db    2
.rdata$r:00009919                 db    0
.rdata$r:0000991A                 db    0
.rdata$r:0000991B                 db    0
.rdata$r:0000991C                 db    0
.rdata$r:0000991D                 db    0
.rdata$r:0000991E                 db    0
.rdata$r:0000991F                 db    0
.rdata$r:00009920                 db 0FFh
.rdata$r:00009921                 db 0FFh
.rdata$r:00009922                 db 0FFh
.rdata$r:00009923                 db 0FFh
.rdata$r:00009924                 db    0
.rdata$r:00009925                 db    0
.rdata$r:00009926                 db    0
.rdata$r:00009927                 db    0
.rdata$r:00009928                 db  40h ; @
.rdata$r:00009929                 db    0
.rdata$r:0000992A                 db    0
.rdata$r:0000992B                 db    0
.rdata$r:0000992C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000992C _rdata$r        ends
.rdata$r:0000992C
.rdata$r:00009930 ; ===========================================================================
.rdata$r:00009930
.rdata$r:00009930 ; Segment type: Pure data
.rdata$r:00009930 ; Segment permissions: Read
.rdata$r:00009930 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009930                 assume cs:_rdata$r
.rdata$r:00009930                 ;org 9930h
.rdata$r:00009930 ; COMDAT (pick any)
.rdata$r:00009930                 public ??_R4Shortcut@@6B@
.rdata$r:00009930 ; const Shortcut::`RTTI Complete Object Locator'
.rdata$r:00009930 ??_R4Shortcut@@6B@ db    0              ; DATA XREF: .rdata:00009068o
.rdata$r:00009931                 db    0
.rdata$r:00009932                 db    0
.rdata$r:00009933                 db    0
.rdata$r:00009934                 db    0
.rdata$r:00009935                 db    0
.rdata$r:00009936                 db    0
.rdata$r:00009937                 db    0
.rdata$r:00009938                 db    0
.rdata$r:00009939                 db    0
.rdata$r:0000993A                 db    0
.rdata$r:0000993B                 db    0
.rdata$r:0000993C                 dd offset ??_R0?AVShortcut@@@8 ; Shortcut `RTTI Type Descriptor'
.rdata$r:00009940                 dd offset ??_R3Shortcut@@8 ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009940 _rdata$r        ends
.rdata$r:00009940
.data$r:00009944 ; ===========================================================================
.data$r:00009944
.data$r:00009944 ; Segment type: Pure data
.data$r:00009944 ; Segment permissions: Read/Write
.data$r:00009944 _data$r         segment dword public 'DATA' use32
.data$r:00009944                 assume cs:_data$r
.data$r:00009944                 ;org 9944h
.data$r:00009944 ; COMDAT (pick any)
.data$r:00009944                 public ??_R0?AVShortcut@@@8
.data$r:00009944 ; class Shortcut `RTTI Type Descriptor'
.data$r:00009944 ??_R0?AVShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:00009944                                         ; DATA XREF: .rdata$r:0000993Co
.data$r:00009944                                         ; .rdata$r:Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009944                                         ; const type_info::`vftable'
.data$r:00009948                 db    0
.data$r:00009949                 db    0
.data$r:0000994A                 db    0
.data$r:0000994B                 db    0
.data$r:0000994C                 db  2Eh ; .
.data$r:0000994D                 db  3Fh ; ?
.data$r:0000994E                 db  41h ; A
.data$r:0000994F                 db  56h ; V
.data$r:00009950                 db  53h ; S
.data$r:00009951                 db  68h ; h
.data$r:00009952                 db  6Fh ; o
.data$r:00009953                 db  72h ; r
.data$r:00009954                 db  74h ; t
.data$r:00009955                 db  63h ; c
.data$r:00009956                 db  75h ; u
.data$r:00009957                 db  74h ; t
.data$r:00009958                 db  40h ; @
.data$r:00009959                 db  40h ; @
.data$r:0000995A                 db    0
.data$r:0000995B                 align 4
.data$r:0000995B _data$r         ends
.data$r:0000995B
.rdata$r:0000995C ; ===========================================================================
.rdata$r:0000995C
.rdata$r:0000995C ; Segment type: Pure data
.rdata$r:0000995C ; Segment permissions: Read
.rdata$r:0000995C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000995C                 assume cs:_rdata$r
.rdata$r:0000995C                 ;org 995Ch
.rdata$r:0000995C ; COMDAT (pick any)
.rdata$r:0000995C                 public ??_R3Shortcut@@8
.rdata$r:0000995C ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000995C ??_R3Shortcut@@8 db    0                ; DATA XREF: .rdata$r:00009940o
.rdata$r:0000995C                                         ; .rdata$r:00009994o
.rdata$r:0000995D                 db    0
.rdata$r:0000995E                 db    0
.rdata$r:0000995F                 db    0
.rdata$r:00009960                 db    0
.rdata$r:00009961                 db    0
.rdata$r:00009962                 db    0
.rdata$r:00009963                 db    0
.rdata$r:00009964                 db    3
.rdata$r:00009965                 db    0
.rdata$r:00009966                 db    0
.rdata$r:00009967                 db    0
.rdata$r:00009968                 dd offset ??_R2Shortcut@@8 ; Shortcut::`RTTI Base Class Array'
.rdata$r:00009968 _rdata$r        ends
.rdata$r:00009968
.rdata$r:0000996C ; ===========================================================================
.rdata$r:0000996C
.rdata$r:0000996C ; Segment type: Pure data
.rdata$r:0000996C ; Segment permissions: Read
.rdata$r:0000996C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000996C                 assume cs:_rdata$r
.rdata$r:0000996C                 ;org 996Ch
.rdata$r:0000996C ; COMDAT (pick any)
.rdata$r:0000996C                 public ??_R2Shortcut@@8
.rdata$r:0000996C ; Shortcut::`RTTI Base Class Array'
.rdata$r:0000996C ??_R2Shortcut@@8 dd offset ??_R1A@?0A@EA@Shortcut@@8
.rdata$r:0000996C                                         ; DATA XREF: .rdata$r:00009968o
.rdata$r:0000996C                                         ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009970                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009974                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009978                 db    0
.rdata$r:00009979                 align 4
.rdata$r:00009979 _rdata$r        ends
.rdata$r:00009979
.rdata$r:0000997C ; ===========================================================================
.rdata$r:0000997C
.rdata$r:0000997C ; Segment type: Pure data
.rdata$r:0000997C ; Segment permissions: Read
.rdata$r:0000997C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000997C                 assume cs:_rdata$r
.rdata$r:0000997C                 ;org 997Ch
.rdata$r:0000997C ; COMDAT (pick any)
.rdata$r:0000997C                 public ??_R1A@?0A@EA@Shortcut@@8
.rdata$r:0000997C ; Shortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000997C ??_R1A@?0A@EA@Shortcut@@8 dd offset ??_R0?AVShortcut@@@8
.rdata$r:0000997C                                         ; DATA XREF: .rdata$r:Shortcut::`RTTI Base Class Array'o
.rdata$r:0000997C                                         ; .rdata$r:000099E0o ...
.rdata$r:0000997C                                         ; Shortcut `RTTI Type Descriptor'
.rdata$r:00009980                 db    2
.rdata$r:00009981                 db    0
.rdata$r:00009982                 db    0
.rdata$r:00009983                 db    0
.rdata$r:00009984                 db    0
.rdata$r:00009985                 db    0
.rdata$r:00009986                 db    0
.rdata$r:00009987                 db    0
.rdata$r:00009988                 db 0FFh
.rdata$r:00009989                 db 0FFh
.rdata$r:0000998A                 db 0FFh
.rdata$r:0000998B                 db 0FFh
.rdata$r:0000998C                 db    0
.rdata$r:0000998D                 db    0
.rdata$r:0000998E                 db    0
.rdata$r:0000998F                 db    0
.rdata$r:00009990                 db  40h ; @
.rdata$r:00009991                 db    0
.rdata$r:00009992                 db    0
.rdata$r:00009993                 db    0
.rdata$r:00009994                 dd offset ??_R3Shortcut@@8 ; Shortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009994 _rdata$r        ends
.rdata$r:00009994
.rdata$r:00009998 ; ===========================================================================
.rdata$r:00009998
.rdata$r:00009998 ; Segment type: Pure data
.rdata$r:00009998 ; Segment permissions: Read
.rdata$r:00009998 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009998                 assume cs:_rdata$r
.rdata$r:00009998                 ;org 9998h
.rdata$r:00009998 ; COMDAT (pick any)
.rdata$r:00009998                 public ??_R4CommandShortcut@@6B@
.rdata$r:00009998 ; const CommandShortcut::`RTTI Complete Object Locator'
.rdata$r:00009998 ??_R4CommandShortcut@@6B@ db    0       ; DATA XREF: .rdata:000090C0o
.rdata$r:00009999                 db    0
.rdata$r:0000999A                 db    0
.rdata$r:0000999B                 db    0
.rdata$r:0000999C                 db    0
.rdata$r:0000999D                 db    0
.rdata$r:0000999E                 db    0
.rdata$r:0000999F                 db    0
.rdata$r:000099A0                 db    0
.rdata$r:000099A1                 db    0
.rdata$r:000099A2                 db    0
.rdata$r:000099A3                 db    0
.rdata$r:000099A4                 dd offset ??_R0?AVCommandShortcut@@@8 ; CommandShortcut `RTTI Type Descriptor'
.rdata$r:000099A8                 dd offset ??_R3CommandShortcut@@8 ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:000099A8 _rdata$r        ends
.rdata$r:000099A8
.data$r:000099AC ; ===========================================================================
.data$r:000099AC
.data$r:000099AC ; Segment type: Pure data
.data$r:000099AC ; Segment permissions: Read/Write
.data$r:000099AC _data$r         segment dword public 'DATA' use32
.data$r:000099AC                 assume cs:_data$r
.data$r:000099AC                 ;org 99ACh
.data$r:000099AC ; COMDAT (pick any)
.data$r:000099AC                 public ??_R0?AVCommandShortcut@@@8
.data$r:000099AC ; class CommandShortcut `RTTI Type Descriptor'
.data$r:000099AC ??_R0?AVCommandShortcut@@@8 dd offset ??_7type_info@@6B@
.data$r:000099AC                                         ; DATA XREF: .rdata$r:000099A4o
.data$r:000099AC                                         ; .rdata$r:CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000099AC                                         ; const type_info::`vftable'
.data$r:000099B0                 db    0
.data$r:000099B1                 db    0
.data$r:000099B2                 db    0
.data$r:000099B3                 db    0
.data$r:000099B4                 db  2Eh ; .
.data$r:000099B5                 db  3Fh ; ?
.data$r:000099B6                 db  41h ; A
.data$r:000099B7                 db  56h ; V
.data$r:000099B8                 db  43h ; C
.data$r:000099B9                 db  6Fh ; o
.data$r:000099BA                 db  6Dh ; m
.data$r:000099BB                 db  6Dh ; m
.data$r:000099BC                 db  61h ; a
.data$r:000099BD                 db  6Eh ; n
.data$r:000099BE                 db  64h ; d
.data$r:000099BF                 db  53h ; S
.data$r:000099C0                 db  68h ; h
.data$r:000099C1                 db  6Fh ; o
.data$r:000099C2                 db  72h ; r
.data$r:000099C3                 db  74h ; t
.data$r:000099C4                 db  63h ; c
.data$r:000099C5                 db  75h ; u
.data$r:000099C6                 db  74h ; t
.data$r:000099C7                 db  40h ; @
.data$r:000099C8                 db  40h ; @
.data$r:000099C9                 db    0
.data$r:000099CA                 align 4
.data$r:000099CA _data$r         ends
.data$r:000099CA
.rdata$r:000099CC ; ===========================================================================
.rdata$r:000099CC
.rdata$r:000099CC ; Segment type: Pure data
.rdata$r:000099CC ; Segment permissions: Read
.rdata$r:000099CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000099CC                 assume cs:_rdata$r
.rdata$r:000099CC                 ;org 99CCh
.rdata$r:000099CC ; COMDAT (pick any)
.rdata$r:000099CC                 public ??_R3CommandShortcut@@8
.rdata$r:000099CC ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:000099CC ??_R3CommandShortcut@@8 db    0         ; DATA XREF: .rdata$r:000099A8o
.rdata$r:000099CC                                         ; .rdata$r:00009A08o
.rdata$r:000099CD                 db    0
.rdata$r:000099CE                 db    0
.rdata$r:000099CF                 db    0
.rdata$r:000099D0                 db    0
.rdata$r:000099D1                 db    0
.rdata$r:000099D2                 db    0
.rdata$r:000099D3                 db    0
.rdata$r:000099D4                 db    4
.rdata$r:000099D5                 db    0
.rdata$r:000099D6                 db    0
.rdata$r:000099D7                 db    0
.rdata$r:000099D8                 dd offset ??_R2CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Array'
.rdata$r:000099D8 _rdata$r        ends
.rdata$r:000099D8
.rdata$r:000099DC ; ===========================================================================
.rdata$r:000099DC
.rdata$r:000099DC ; Segment type: Pure data
.rdata$r:000099DC ; Segment permissions: Read
.rdata$r:000099DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000099DC                 assume cs:_rdata$r
.rdata$r:000099DC                 ;org 99DCh
.rdata$r:000099DC ; COMDAT (pick any)
.rdata$r:000099DC                 public ??_R2CommandShortcut@@8
.rdata$r:000099DC ; CommandShortcut::`RTTI Base Class Array'
.rdata$r:000099DC ??_R2CommandShortcut@@8 dd offset ??_R1A@?0A@EA@CommandShortcut@@8
.rdata$r:000099DC                                         ; DATA XREF: .rdata$r:000099D8o
.rdata$r:000099DC                                         ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000099E0                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000099E4                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000099E8                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000099EC                 db    0
.rdata$r:000099ED                 align 10h
.rdata$r:000099ED _rdata$r        ends
.rdata$r:000099ED
.rdata$r:000099F0 ; ===========================================================================
.rdata$r:000099F0
.rdata$r:000099F0 ; Segment type: Pure data
.rdata$r:000099F0 ; Segment permissions: Read
.rdata$r:000099F0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000099F0                 assume cs:_rdata$r
.rdata$r:000099F0                 ;org 99F0h
.rdata$r:000099F0 ; COMDAT (pick any)
.rdata$r:000099F0                 public ??_R1A@?0A@EA@CommandShortcut@@8
.rdata$r:000099F0 ; CommandShortcut::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000099F0 ??_R1A@?0A@EA@CommandShortcut@@8 dd offset ??_R0?AVCommandShortcut@@@8
.rdata$r:000099F0                                         ; DATA XREF: .rdata$r:CommandShortcut::`RTTI Base Class Array'o
.rdata$r:000099F0                                         ; .rdata$r:00009A50o
.rdata$r:000099F0                                         ; CommandShortcut `RTTI Type Descriptor'
.rdata$r:000099F4                 db    3
.rdata$r:000099F5                 db    0
.rdata$r:000099F6                 db    0
.rdata$r:000099F7                 db    0
.rdata$r:000099F8                 db    0
.rdata$r:000099F9                 db    0
.rdata$r:000099FA                 db    0
.rdata$r:000099FB                 db    0
.rdata$r:000099FC                 db 0FFh
.rdata$r:000099FD                 db 0FFh
.rdata$r:000099FE                 db 0FFh
.rdata$r:000099FF                 db 0FFh
.rdata$r:00009A00                 db    0
.rdata$r:00009A01                 db    0
.rdata$r:00009A02                 db    0
.rdata$r:00009A03                 db    0
.rdata$r:00009A04                 db  40h ; @
.rdata$r:00009A05                 db    0
.rdata$r:00009A06                 db    0
.rdata$r:00009A07                 db    0
.rdata$r:00009A08                 dd offset ??_R3CommandShortcut@@8 ; CommandShortcut::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A08 _rdata$r        ends
.rdata$r:00009A08
.rdata$r:00009A0C ; ===========================================================================
.rdata$r:00009A0C
.rdata$r:00009A0C ; Segment type: Pure data
.rdata$r:00009A0C ; Segment permissions: Read
.rdata$r:00009A0C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A0C                 assume cs:_rdata$r
.rdata$r:00009A0C                 ;org 9A0Ch
.rdata$r:00009A0C ; COMDAT (pick any)
.rdata$r:00009A0C                 public ??_R4UserCommand@@6B@
.rdata$r:00009A0C ; const UserCommand::`RTTI Complete Object Locator'
.rdata$r:00009A0C ??_R4UserCommand@@6B@ db    0           ; DATA XREF: .rdata:00009110o
.rdata$r:00009A0D                 db    0
.rdata$r:00009A0E                 db    0
.rdata$r:00009A0F                 db    0
.rdata$r:00009A10                 db    0
.rdata$r:00009A11                 db    0
.rdata$r:00009A12                 db    0
.rdata$r:00009A13                 db    0
.rdata$r:00009A14                 db    0
.rdata$r:00009A15                 db    0
.rdata$r:00009A16                 db    0
.rdata$r:00009A17                 db    0
.rdata$r:00009A18                 dd offset ??_R0?AVUserCommand@@@8 ; UserCommand `RTTI Type Descriptor'
.rdata$r:00009A1C                 dd offset ??_R3UserCommand@@8 ; UserCommand::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A1C _rdata$r        ends
.rdata$r:00009A1C
.data$r:00009A20 ; ===========================================================================
.data$r:00009A20
.data$r:00009A20 ; Segment type: Pure data
.data$r:00009A20 ; Segment permissions: Read/Write
.data$r:00009A20 _data$r         segment dword public 'DATA' use32
.data$r:00009A20                 assume cs:_data$r
.data$r:00009A20                 ;org 9A20h
.data$r:00009A20 ; COMDAT (pick any)
.data$r:00009A20                 public ??_R0?AVUserCommand@@@8
.data$r:00009A20 ; class UserCommand `RTTI Type Descriptor'
.data$r:00009A20 ??_R0?AVUserCommand@@@8 dd offset ??_7type_info@@6B@
.data$r:00009A20                                         ; DATA XREF: .rdata$r:00009A18o
.data$r:00009A20                                         ; .rdata$r:UserCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00009A20                                         ; const type_info::`vftable'
.data$r:00009A24                 align 8
.data$r:00009A28 a_?avusercomman db '.?AVUserCommand@@',0
.data$r:00009A3A                 align 4
.data$r:00009A3A _data$r         ends
.data$r:00009A3A
.rdata$r:00009A3C ; ===========================================================================
.rdata$r:00009A3C
.rdata$r:00009A3C ; Segment type: Pure data
.rdata$r:00009A3C ; Segment permissions: Read
.rdata$r:00009A3C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A3C                 assume cs:_rdata$r
.rdata$r:00009A3C                 ;org 9A3Ch
.rdata$r:00009A3C ; COMDAT (pick any)
.rdata$r:00009A3C                 public ??_R3UserCommand@@8
.rdata$r:00009A3C ; UserCommand::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A3C ??_R3UserCommand@@8 db    0             ; DATA XREF: .rdata$r:00009A1Co
.rdata$r:00009A3C                                         ; .rdata$r:00009A7Co
.rdata$r:00009A3D                 db    0
.rdata$r:00009A3E                 db    0
.rdata$r:00009A3F                 db    0
.rdata$r:00009A40                 db    0
.rdata$r:00009A41                 db    0
.rdata$r:00009A42                 db    0
.rdata$r:00009A43                 db    0
.rdata$r:00009A44                 db    5
.rdata$r:00009A45                 db    0
.rdata$r:00009A46                 db    0
.rdata$r:00009A47                 db    0
.rdata$r:00009A48                 dd offset ??_R2UserCommand@@8 ; UserCommand::`RTTI Base Class Array'
.rdata$r:00009A48 _rdata$r        ends
.rdata$r:00009A48
.rdata$r:00009A4C ; ===========================================================================
.rdata$r:00009A4C
.rdata$r:00009A4C ; Segment type: Pure data
.rdata$r:00009A4C ; Segment permissions: Read
.rdata$r:00009A4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A4C                 assume cs:_rdata$r
.rdata$r:00009A4C                 ;org 9A4Ch
.rdata$r:00009A4C ; COMDAT (pick any)
.rdata$r:00009A4C                 public ??_R2UserCommand@@8
.rdata$r:00009A4C ; UserCommand::`RTTI Base Class Array'
.rdata$r:00009A4C ??_R2UserCommand@@8 dd offset ??_R1A@?0A@EA@UserCommand@@8
.rdata$r:00009A4C                                         ; DATA XREF: .rdata$r:00009A48o
.rdata$r:00009A4C                                         ; UserCommand::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A50                 dd offset ??_R1A@?0A@EA@CommandShortcut@@8 ; CommandShortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A54                 dd offset ??_R1A@?0A@EA@Shortcut@@8 ; Shortcut::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A58                 dd offset ??_R1A@?0A@EA@StaticDialog@@8 ; StaticDialog::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A5C                 dd offset ??_R1A@?0A@EA@Window@@8 ; Window::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00009A60                 db    0
.rdata$r:00009A61                 align 4
.rdata$r:00009A61 _rdata$r        ends
.rdata$r:00009A61
.rdata$r:00009A64 ; ===========================================================================
.rdata$r:00009A64
.rdata$r:00009A64 ; Segment type: Pure data
.rdata$r:00009A64 ; Segment permissions: Read
.rdata$r:00009A64 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00009A64                 assume cs:_rdata$r
.rdata$r:00009A64                 ;org 9A64h
.rdata$r:00009A64 ; COMDAT (pick any)
.rdata$r:00009A64                 public ??_R1A@?0A@EA@UserCommand@@8
.rdata$r:00009A64 ; UserCommand::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00009A64 ??_R1A@?0A@EA@UserCommand@@8 dd offset ??_R0?AVUserCommand@@@8
.rdata$r:00009A64                                         ; DATA XREF: .rdata$r:UserCommand::`RTTI Base Class Array'o
.rdata$r:00009A64                                         ; UserCommand `RTTI Type Descriptor'
.rdata$r:00009A68                 db    4
.rdata$r:00009A69                 db    0
.rdata$r:00009A6A                 db    0
.rdata$r:00009A6B                 db    0
.rdata$r:00009A6C                 db    0
.rdata$r:00009A6D                 db    0
.rdata$r:00009A6E                 db    0
.rdata$r:00009A6F                 db    0
.rdata$r:00009A70                 db 0FFh
.rdata$r:00009A71                 db 0FFh
.rdata$r:00009A72                 db 0FFh
.rdata$r:00009A73                 db 0FFh
.rdata$r:00009A74                 db    0
.rdata$r:00009A75                 db    0
.rdata$r:00009A76                 db    0
.rdata$r:00009A77                 db    0
.rdata$r:00009A78                 db  40h ; @
.rdata$r:00009A79                 db    0
.rdata$r:00009A7A                 db    0
.rdata$r:00009A7B                 db    0
.rdata$r:00009A7C                 dd offset ??_R3UserCommand@@8 ; UserCommand::`RTTI Class Hierarchy Descriptor'
.rdata$r:00009A7C _rdata$r        ends
.rdata$r:00009A7C
.CRT$XCU:00009A80 ; ===========================================================================
.CRT$XCU:00009A80
.CRT$XCU:00009A80 ; Segment type: Pure data
.CRT$XCU:00009A80 ; Segment permissions: Read
.CRT$XCU:00009A80 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009A80                 assume cs:_CRT$XCU
.CRT$XCU:00009A80                 ;org 9A80h
.CRT$XCU:00009A80 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00009A84 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00009A88 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:00009A8C __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:00009A8C _CRT$XCU        ends
.CRT$XCU:00009A8C
.CRT$XCU:00009A90 ; ===========================================================================
.CRT$XCU:00009A90
.CRT$XCU:00009A90 ; Segment type: Pure data
.CRT$XCU:00009A90 ; Segment permissions: Read
.CRT$XCU:00009A90 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009A90                 assume cs:_CRT$XCU
.CRT$XCU:00009A90                 ;org 9A90h
.CRT$XCU:00009A90 ; COMDAT (pick associative to section at 9050)
.CRT$XCU:00009A90 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00009A90 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00009A90 _CRT$XCU        ends
.CRT$XCU:00009A90
.CRT$XCU:00009A94 ; ===========================================================================
.CRT$XCU:00009A94
.CRT$XCU:00009A94 ; Segment type: Pure data
.CRT$XCU:00009A94 ; Segment permissions: Read
.CRT$XCU:00009A94 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009A94                 assume cs:_CRT$XCU
.CRT$XCU:00009A94                 ;org 9A94h
.CRT$XCU:00009A94 ; COMDAT (pick associative to section at 9054)
.CRT$XCU:00009A94 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00009A94 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00009A94 _CRT$XCU        ends
.CRT$XCU:00009A94
.CRT$XCU:00009A98 ; ===========================================================================
.CRT$XCU:00009A98
.CRT$XCU:00009A98 ; Segment type: Pure data
.CRT$XCU:00009A98 ; Segment permissions: Read
.CRT$XCU:00009A98 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009A98                 assume cs:_CRT$XCU
.CRT$XCU:00009A98                 ;org 9A98h
.CRT$XCU:00009A98 ; COMDAT (pick associative to section at 9058)
.CRT$XCU:00009A98 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00009A98 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00009A98 _CRT$XCU        ends
.CRT$XCU:00009A98
.CRT$XCU:00009A9C ; ===========================================================================
.CRT$XCU:00009A9C
.CRT$XCU:00009A9C ; Segment type: Pure data
.CRT$XCU:00009A9C ; Segment permissions: Read
.CRT$XCU:00009A9C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009A9C                 assume cs:_CRT$XCU
.CRT$XCU:00009A9C                 ;org 9A9Ch
.CRT$XCU:00009A9C ; COMDAT (pick associative to section at 9060)
.CRT$XCU:00009A9C ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00009A9C ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00009A9C _CRT$XCU        ends
.CRT$XCU:00009A9C
.CRT$XCU:00009AA0 ; ===========================================================================
.CRT$XCU:00009AA0
.CRT$XCU:00009AA0 ; Segment type: Pure data
.CRT$XCU:00009AA0 ; Segment permissions: Read
.CRT$XCU:00009AA0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009AA0                 assume cs:_CRT$XCU
.CRT$XCU:00009AA0                 ;org 9AA0h
.CRT$XCU:00009AA0 ; COMDAT (pick associative to section at 9064)
.CRT$XCU:00009AA0 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00009AA0 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00009AA0 _CRT$XCU        ends
.CRT$XCU:00009AA0
.CRT$XCU:00009AA4 ; ===========================================================================
.CRT$XCU:00009AA4
.CRT$XCU:00009AA4 ; Segment type: Pure data
.CRT$XCU:00009AA4 ; Segment permissions: Read
.CRT$XCU:00009AA4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009AA4                 assume cs:_CRT$XCU
.CRT$XCU:00009AA4                 ;org 9AA4h
.CRT$XCU:00009AA4 ; COMDAT (pick associative to section at 91F0)
.CRT$XCU:00009AA4 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00009AA4 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00009AA4 _CRT$XCU        ends
.CRT$XCU:00009AA4
.CRT$XCU:00009AA8 ; ===========================================================================
.CRT$XCU:00009AA8
.CRT$XCU:00009AA8 ; Segment type: Pure data
.CRT$XCU:00009AA8 ; Segment permissions: Read
.CRT$XCU:00009AA8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00009AA8                 assume cs:_CRT$XCU
.CRT$XCU:00009AA8                 ;org 9AA8h
.CRT$XCU:00009AA8 ; COMDAT (pick associative to section at 91F4)
.CRT$XCU:00009AA8 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00009AA8 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00009AA8 _CRT$XCU        ends
.CRT$XCU:00009AA8
UNDEF:00009AB0 ; ===========================================================================
UNDEF:00009AB0
UNDEF:00009AB0 ; Segment type: Externs
UNDEF:00009AB0 ; UNDEF
UNDEF:00009AB0                 extrn __purecall:near   ; DATA XREF: .rdata:00008E6Co
UNDEF:00009AB0                                         ; .rdata:00008ED0o ...
UNDEF:00009AB4 ; void *__cdecl operator new(unsigned int)
UNDEF:00009AB4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:00009AB4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p ...
UNDEF:00009AB8 ; void __cdecl operator delete(void *)
UNDEF:00009AB8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: CommandShortcut::`scalar deleting destructor'(uint)+1Bp
UNDEF:00009AB8                                         ; Shortcut::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:00009ABC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:00009ABC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:00009ABC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:00009AC0                 extrn ___report_rangecheckfailure:near
UNDEF:00009AC0                                         ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *):loc_120Ep
UNDEF:00009AC0                                         ; Command::run(HWND__ *):loc_14EBp ...
UNDEF:00009AC4                 extrn __invalid_parameter:near
UNDEF:00009AC4                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+B2p
UNDEF:00009AC4                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+8Ap
UNDEF:00009AC8 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:00009AC8                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:00009AC8                                         ; _wmemcpy+11p
UNDEF:00009ACC ; size_t __cdecl strlen(const char *Str)
UNDEF:00009ACC                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:00009AD0 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:00009AD0                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:00009AD0                                         ; _wmemmove+11p
UNDEF:00009AD4 ; wchar_t *__cdecl wcschr(const wchar_t *Str, wchar_t Ch)
UNDEF:00009AD4                 extrn _wcschr:near      ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+46Cp
UNDEF:00009AD8 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:00009AD8                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:00009ADC ; DWORD __stdcall ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize)
UNDEF:00009ADC                 extrn __imp__ExpandEnvironmentStringsW@12:near
UNDEF:00009ADC                                         ; CODE XREF: Command::run(HWND__ *)+69p
UNDEF:00009ADC                                         ; Command::run(HWND__ *)+E7p
UNDEF:00009ADC                                         ; DATA XREF: ...
UNDEF:00009AE0 ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:00009AE0                 extrn __imp__lstrcmpW@8:near
UNDEF:00009AE0                                         ; CODE XREF: whichVar(wchar_t *)+Cp
UNDEF:00009AE0                                         ; whichVar(wchar_t *)+2Ep ...
UNDEF:00009AE4 ; LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2)
UNDEF:00009AE4                 extrn __imp__lstrcpyW@8:near
UNDEF:00009AE4                                         ; CODE XREF: Command::run(HWND__ *)+8Cp
UNDEF:00009AE4                                         ; Command::run(HWND__ *)+10Ap
UNDEF:00009AE4                                         ; DATA XREF: ...
UNDEF:00009AE8 ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:00009AE8                 extrn __imp__lstrlenW@4:near
UNDEF:00009AE8                                         ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+30p
UNDEF:00009AE8                                         ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+BBp ...
UNDEF:00009AEC ; int _wsprintfW(LPWSTR, LPCWSTR, ...)
UNDEF:00009AEC                 extrn __imp__wsprintfW:near
UNDEF:00009AEC                                         ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+26Dp
UNDEF:00009AEC                                         ; DATA XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+26Dr
UNDEF:00009AF0 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:00009AF0                 extrn __imp__SendMessageW@16:near
UNDEF:00009AF0                                         ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+24Ep
UNDEF:00009AF0                                         ; expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+294p ...
UNDEF:00009AF4 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:00009AF4                 extrn __imp__DestroyWindow@4:near
UNDEF:00009AF4                                         ; CODE XREF: StaticDialog::destroy(void)+29p
UNDEF:00009AF4                                         ; DATA XREF: StaticDialog::destroy(void)+29r
UNDEF:00009AF8 ; BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow)
UNDEF:00009AF8                 extrn __imp__ShowWindow@8:near
UNDEF:00009AF8                                         ; CODE XREF: Window::display(bool)+2Cp
UNDEF:00009AF8                                         ; DATA XREF: Window::display(bool)+2Cr
UNDEF:00009AFC ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:00009AFC                 extrn __imp__MoveWindow@24:near
UNDEF:00009AFC                                         ; CODE XREF: Window::reSizeTo(tagRECT &)+2Bp
UNDEF:00009AFC                                         ; Window::reSizeToWH(tagRECT &)+36p
UNDEF:00009AFC                                         ; DATA XREF: ...
UNDEF:00009B00 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:00009B00                 extrn __imp__IsWindowVisible@4:near
UNDEF:00009B00                                         ; CODE XREF: Window::getHeight(void)+2Bp
UNDEF:00009B00                                         ; Window::isVisible(void)+10p
UNDEF:00009B00                                         ; DATA XREF: ...
UNDEF:00009B04 ; INT_PTR __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam)
UNDEF:00009B04                 extrn __imp__DialogBoxParamW@20:near
UNDEF:00009B04                                         ; CODE XREF: Shortcut::doDialog(void)+23p
UNDEF:00009B04                                         ; DATA XREF: Shortcut::doDialog(void)+23r
UNDEF:00009B08 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:00009B08                 extrn __imp__GetDlgItem@8:near
UNDEF:00009B08                                         ; CODE XREF: RunDlg::doDialog(bool)+48p
UNDEF:00009B08                                         ; RunDlg::addTextToCombo(wchar_t const *)+15p ...
UNDEF:00009B0C ; UINT __stdcall GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax)
UNDEF:00009B0C                 extrn __imp__GetDlgItemTextW@16:near
UNDEF:00009B0C                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+CBp
UNDEF:00009B0C                                         ; RunDlg::run_dlgProc(uint,uint,long)+194p
UNDEF:00009B0C                                         ; DATA XREF: ...
UNDEF:00009B10 ; HWND __stdcall SetFocus(HWND hWnd)
UNDEF:00009B10                 extrn __imp__SetFocus@4:near
UNDEF:00009B10                                         ; CODE XREF: RunDlg::doDialog(bool)+4Fp
UNDEF:00009B10                                         ; DATA XREF: RunDlg::doDialog(bool)+4Fr
UNDEF:00009B14 ; HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos)
UNDEF:00009B14                 extrn __imp__GetSubMenu@8:near
UNDEF:00009B14                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+239p
UNDEF:00009B14                                         ; DATA XREF: RunDlg::run_dlgProc(uint,uint,long)+239r
UNDEF:00009B18 ; BOOL __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem)
UNDEF:00009B18                 extrn __imp__InsertMenuW@20:near
UNDEF:00009B18                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+26Ap
UNDEF:00009B18                                         ; RunDlg::run_dlgProc(uint,uint,long)+2D3p ...
UNDEF:00009B1C ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:00009B1C                 extrn __imp__UpdateWindow@4:near
UNDEF:00009B1C                                         ; CODE XREF: Window::redraw(bool)+27p
UNDEF:00009B1C                                         ; DATA XREF: Window::redraw(bool)+27r
UNDEF:00009B20 ; BOOL __stdcall InvalidateRect(HWND hWnd, const RECT *lpRect, BOOL bErase)
UNDEF:00009B20                 extrn __imp__InvalidateRect@12:near
UNDEF:00009B20                                         ; CODE XREF: Window::redraw(bool)+12p
UNDEF:00009B20                                         ; DATA XREF: Window::redraw(bool)+12r
UNDEF:00009B24 ; BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect)
UNDEF:00009B24                 extrn __imp__GetClientRect@8:near
UNDEF:00009B24                                         ; CODE XREF: Window::getClientRect(tagRECT &)+12p
UNDEF:00009B24                                         ; Window::getHeight(void)+1Ep ...
UNDEF:00009B28 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:00009B28                 extrn __imp__GetWindowRect@8:near
UNDEF:00009B28                                         ; CODE XREF: Window::getWindowRect(tagRECT &)+12p
UNDEF:00009B28                                         ; DATA XREF: Window::getWindowRect(tagRECT &)+12r
UNDEF:00009B2C ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:00009B2C                 extrn __imp__SetWindowLongW@12:near
UNDEF:00009B2C                                         ; CODE XREF: StaticDialog::~StaticDialog(void)+50p
UNDEF:00009B2C                                         ; DATA XREF: StaticDialog::~StaticDialog(void)+50r
UNDEF:00009B30 ; HINSTANCE __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd)
UNDEF:00009B30                 extrn __imp__ShellExecuteW@24:near
UNDEF:00009B30                                         ; CODE XREF: Command::run(HWND__ *)+1AEp
UNDEF:00009B30                                         ; DATA XREF: Command::run(HWND__ *)+1AEr
UNDEF:00009B34 ; public: virtual void * __thiscall Window::`vector deleting destructor'(unsigned int)
UNDEF:00009B34                 extrn ??_EWindow@@UAEPAXI@Z:near ; weak
UNDEF:00009B34                                         ; DATA XREF: .rdata:const Window::`vftable'o
UNDEF:00009B38 ; public: virtual void __thiscall StaticDialog::create(int, bool, bool)
UNDEF:00009B38                 extrn ?create@StaticDialog@@UAEXH_N0@Z:near
UNDEF:00009B38                                         ; DATA XREF: .rdata:00008EC8o
UNDEF:00009B38                                         ; .rdata:0000909Co ...
UNDEF:00009B3C ; void __thiscall StaticDialog::goToCenter(StaticDialog *__hidden this)
UNDEF:00009B3C                 extrn ?goToCenter@StaticDialog@@QAEXXZ:near
UNDEF:00009B3C                                         ; CODE XREF: RunDlg::doDialog(bool)+37p
UNDEF:00009B40 ; public: virtual void __thiscall StaticDialog::display(bool)const
UNDEF:00009B40                 extrn ?display@StaticDialog@@UBEX_N@Z:near
UNDEF:00009B40                                         ; DATA XREF: .rdata:00008EA4o
UNDEF:00009B40                                         ; .rdata:00009078o ...
UNDEF:00009B44 ; INT_PTR __stdcall StaticDialog::dlgProc(HWND, UINT, WPARAM, LPARAM)
UNDEF:00009B44                 extrn ?dlgProc@StaticDialog@@KGHPAUHWND__@@IIJ@Z:near
UNDEF:00009B44                                         ; DATA XREF: Shortcut::doDialog(void)+Bo
UNDEF:00009B48 ; public: virtual void * __thiscall StaticDialog::`vector deleting destructor'(unsigned int)
UNDEF:00009B48                 extrn ??_EStaticDialog@@UAEPAXI@Z:near ; weak
UNDEF:00009B48                                         ; DATA XREF: .rdata:const StaticDialog::`vftable'o
UNDEF:00009B4C ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00009B4C                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00009B4C                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:00009B4C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:00009B50 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00009B50                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00009B50                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:00009B50                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:00009B54                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00009B58                 extrn __CrtDbgReportW:near
UNDEF:00009B58                                         ; CODE XREF: std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::operator*(void)+91p
UNDEF:00009B58                                         ; std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>>::_Compat(std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t>>> const &)+66p
UNDEF:00009B5C ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00009B5C                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00009B5C                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00009B5C                                         ; std::_Debug_pointer<UserCommand>(UserCommand *,wchar_t const *,uint)+16p ...
UNDEF:00009B60 ; void __cdecl std::_Xbad_alloc()
UNDEF:00009B60                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00009B60                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_215Ap
UNDEF:00009B60                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_219Cp ...
UNDEF:00009B64 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00009B64                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00009B64                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00009B64                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp ...
UNDEF:00009B68 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00009B68                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00009B68                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00009B68                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00009B6C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009B6C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009B6C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00009B70 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00009B70                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00009B70                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00009B70                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00009B74 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00009B74                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00009B74                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00009B78 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009B78                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009B78                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00009B7C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009B7C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009B7C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00009B80 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00009B80                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00009B80                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00009B84 ; _DWORD __thiscall FileDialog::FileDialog(FileDialog *__hidden this, HWND, HINSTANCE)
UNDEF:00009B84                 extrn ??0FileDialog@@QAE@PAUHWND__@@PAUHINSTANCE__@@@Z:near
UNDEF:00009B84                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+3F4p
UNDEF:00009B88 ; _DWORD __thiscall FileDialog::~FileDialog(FileDialog *__hidden this)
UNDEF:00009B88                 extrn ??1FileDialog@@QAE@XZ:near
UNDEF:00009B88                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+56Fp
UNDEF:00009B88                                         ; __unwindfunclet$?run_dlgProc@RunDlg@@MAGHIIJ@Z$4+6j
UNDEF:00009B8C ; void FileDialog::setExtFilter(FileDialog *__hidden this, const wchar_t *, const wchar_t *, ...)
UNDEF:00009B8C                 extrn ?setExtFilter@FileDialog@@QAAXPB_W0ZZ:near
UNDEF:00009B8C                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+422p
UNDEF:00009B8C                                         ; RunDlg::run_dlgProc(uint,uint,long)+43Dp
UNDEF:00009B90 ; wchar_t *__thiscall FileDialog::doOpenSingleFileDlg(FileDialog *__hidden this)
UNDEF:00009B90                 extrn ?doOpenSingleFileDlg@FileDialog@@QAEPA_WXZ:near
UNDEF:00009B90                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+44Bp
UNDEF:00009B94 ; public: virtual class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall Shortcut::toString(void)const
UNDEF:00009B94                 extrn ?toString@Shortcut@@UBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@XZ:near
UNDEF:00009B94                                         ; DATA XREF: .rdata:000090B4o
UNDEF:00009B94                                         ; .rdata:0000910Co ...
UNDEF:00009B98 ; void __thiscall Shortcut::setName(Shortcut *__hidden this, const wchar_t *)
UNDEF:00009B98                 extrn ?setName@Shortcut@@QAEXPB_W@Z:near
UNDEF:00009B98                                         ; CODE XREF: Shortcut::Shortcut(Shortcut const &)+4Ap
UNDEF:00009B98                                         ; Shortcut::Shortcut(void)+4Dp
UNDEF:00009B9C ; protected: virtual int __stdcall Shortcut::run_dlgProc(unsigned int, unsigned int, long)
UNDEF:00009B9C                 extrn ?run_dlgProc@Shortcut@@MAGHIIJ@Z:near
UNDEF:00009B9C                                         ; DATA XREF: .rdata:000090A4o
UNDEF:00009B9C                                         ; .rdata:000090FCo ...
UNDEF:00009BA0 ; public: virtual void * __thiscall Shortcut::`vector deleting destructor'(unsigned int)
UNDEF:00009BA0                 extrn ??_EShortcut@@UAEPAXI@Z:near ; weak
UNDEF:00009BA0                                         ; DATA XREF: .rdata:const Shortcut::`vftable'o
UNDEF:00009BA4 ; public: virtual void * __thiscall CommandShortcut::`vector deleting destructor'(unsigned int)
UNDEF:00009BA4                 extrn ??_ECommandShortcut@@UAEPAXI@Z:near ; weak
UNDEF:00009BA4                                         ; DATA XREF: .rdata:const CommandShortcut::`vftable'o
UNDEF:00009BA8 ; public: virtual void * __thiscall UserCommand::`vector deleting destructor'(unsigned int)
UNDEF:00009BA8                 extrn ??_EUserCommand@@UAEPAXI@Z:near ; weak
UNDEF:00009BA8                                         ; DATA XREF: .rdata:const UserCommand::`vftable'o
UNDEF:00009BAC ; void __thiscall Accelerator::updateShortcuts(Accelerator *__hidden this)
UNDEF:00009BAC                 extrn ?updateShortcuts@Accelerator@@QAEXXZ:near
UNDEF:00009BAC                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+3B4p
UNDEF:00009BB0 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall NativeLangSpeaker::getNativeLangMenuString(int)
UNDEF:00009BB0                 extrn ?getNativeLangMenuString@NativeLangSpeaker@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@H@Z:near
UNDEF:00009BB0                                         ; CODE XREF: RunDlg::run_dlgProc(uint,uint,long)+339p
UNDEF:00009BB4 ; __fastcall __security_check_cookie(x)
UNDEF:00009BB4                 extrn @__security_check_cookie@4:near
UNDEF:00009BB4                                         ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+3B7p
UNDEF:00009BB4                                         ; Command::run(HWND__ *)+1C5p ...
UNDEF:00009BB8 ; __stdcall _CxxThrowException(x, x)
UNDEF:00009BB8                 extrn __CxxThrowException@8:near
UNDEF:00009BB8                                         ; CODE XREF: __catch$??$_Uninit_move@PAVUserCommand@@PAV1@V?$allocator@VUserCommand@@@std@@V1@@std@@YAPAVUserCommand@@PAV1@00AAU?$_Wrap_alloc@V?$allocator@VUserCommand@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+27p
UNDEF:00009BB8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p ...
UNDEF:00009BBC                 extrn ___CxxFrameHandler3:near
UNDEF:00009BBC                                         ; CODE XREF: __ehhandler$?run_dlgProc@RunDlg@@MAGHIIJ@Z+23j
UNDEF:00009BBC                                         ; __ehhandler$??$?H_WU?$char_traits@_W@std@@V?$allocator@_W@1@@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@0@$$QAV10@PB_W@Z+16j ...
UNDEF:00009BC0                 extrn __chkstk:near     ; CODE XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+8p
UNDEF:00009BC0                                         ; Command::run(HWND__ *)+8p ...
UNDEF:00009BC4 ; const type_info::`vftable'
UNDEF:00009BC4                 extrn ??_7type_info@@6B@:near
UNDEF:00009BC4                                         ; DATA XREF: .data$r:Window `RTTI Type Descriptor'o
UNDEF:00009BC4                                         ; .data$r:StaticDialog `RTTI Type Descriptor'o ...
UNDEF:00009BC8 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00009BC8                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00009BC8                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00009BCC                 extrn ___security_cookie:near
UNDEF:00009BCC                                         ; DATA XREF: expandNppEnvironmentStrs(wchar_t const *,wchar_t *,uint,HWND__ *)+Dr
UNDEF:00009BCC                                         ; Command::run(HWND__ *)+Dr ...
UNDEF:00009BD0                 extrn __fltused:near
UNDEF:00009BD0
UNDEF:00009BD0
UNDEF:00009BD0                 end