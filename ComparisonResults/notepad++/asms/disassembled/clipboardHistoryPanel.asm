.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 5854DEFD0B4210FFAFFE1A9C8AEB22C3
.rdata:00000000 ; Input CRC32 : C08D5DCB
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\clipboardHistoryPanel.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG154635
.rdata:00000000 $SG154635:                              ; DATA XREF: ClipboardHistoryPanel::getClipboadData(void)+E1o
.rdata:00000000                 unicode 0, <Notepad++ Binary Text Length>,0
.rdata:0000003A $SG154964       db    0                 ; DATA XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+324o
.rdata:0000003B                 db    0
.rdata:0000003C $SG146152       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000047                 align 4
.rdata:00000048 $SG146153       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000A74o
.rdata:00000054 $SG146154       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000A78o
.rdata:00000060 $SG146155       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:00000A7Co
.rdata:0000006C $SG146156       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000A80o
.rdata:00000078 $SG146157       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000A84o
.rdata:00000084 $SG146158       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000A88o
.rdata:00000090 $SG146159       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:00000A8Co
.rdata:0000009C $SG146160       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000A90o
.rdata:000000A8 $SG146161       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000A94o
.rdata:000000B4 $SG146162       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000A98o
.rdata:000000C0 $SG146163       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:00000A9Co
.rdata:000000CC $SG146164       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000AA0o
.rdata:000000D8 $SG146165       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000AA4o
.rdata:000000E4 $SG146166       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000AA8o
.rdata:000000F0 $SG146167       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:00000AACo
.rdata:000000FC $SG146168       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000AB0o
.rdata:00000108 $SG146169       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000AB4o
.rdata:00000114 $SG146170       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000AB8o
.rdata:00000120 $SG146171       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:00000ABCo
.rdata:0000012C $SG146172       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000AC0o
.rdata:00000138 $SG146173       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000AC4o
.rdata:00000144 $SG146174       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000AC8o
.rdata:00000150 $SG146175       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:00000ACCo
.rdata:0000015C $SG146176       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000AD0o
.rdata:00000168 $SG146177       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000AD4o
.rdata:00000174 $SG146178       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000AD8o
.rdata:00000180 $SG146179       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:00000ADCo
.rdata:0000018C $SG146180       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000AE0o
.rdata:00000198 $SG146181       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000AE4o
.rdata:000001A4 $SG146182       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000AE8o
.rdata:000001B0 $SG146183       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:00000AECo
.rdata:000001BC $SG146184       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000AF0o
.rdata:000001C8 $SG146185       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000AF4o
.rdata:000001D4 $SG146186       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000AF8o
.rdata:000001E0 $SG146187       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:00000AFCo
.rdata:000001EC $SG146188       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000B00o
.rdata:000001F8 $SG146189       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000B04o
.rdata:00000204 $SG146190       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000B08o
.rdata:00000210 $SG146191       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:00000B0Co
.rdata:0000021C $SG146192       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:00000B10o
.rdata:00000228 $SG146193       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:00000B14o
.rdata:00000234 $SG146194       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:00000B18o
.rdata:00000240 $SG146195       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:00000B1Co
.rdata:0000024C $SG146196       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:00000B20o
.rdata:00000258 $SG146197       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:00000B24o
.rdata:00000264 $SG146198       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:00000B28o
.rdata:00000270 $SG146199       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:00000B2Co
.rdata:0000027C $SG146200       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:00000B30o
.rdata:00000288 $SG146201       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:00000B34o
.rdata:00000294 $SG146202       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:00000B38o
.rdata:000002A0 $SG146203       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:00000B3Co
.rdata:000002AC $SG146204       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:00000B40o
.rdata:000002B8 $SG146205       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:00000B44o
.rdata:000002C4 $SG146206       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:00000B48o
.rdata:000002D0 $SG146207       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:00000B4Co
.rdata:000002DC $SG146208       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:00000B50o
.rdata:000002E8 $SG146209       db '    .+      ',0     ; DATA XREF: .data:00000B54o
.rdata:000002F5                 align 4
.rdata:000002F8 $SG146210       db '    @#$     ',0     ; DATA XREF: .data:00000B58o
.rdata:00000305                 align 4
.rdata:00000308 $SG146211       db '    %&*=    ',0     ; DATA XREF: .data:00000B5Co
.rdata:00000315                 align 4
.rdata:00000318 $SG146212       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:00000B60o
.rdata:00000325                 align 4
.rdata:00000328 $SG146213       db '    )!~{]^  ',0     ; DATA XREF: .data:00000B64o
.rdata:00000335                 align 4
.rdata:00000338 $SG146214       db '    /(_:<[} ',0     ; DATA XREF: .data:00000B68o
.rdata:00000345                 align 4
.rdata:00000348 $SG146215       db '    |123456 ',0     ; DATA XREF: .data:00000B6Co
.rdata:00000355                 align 4
.rdata:00000358 $SG146216       db '    7890abc ',0     ; DATA XREF: .data:00000B70o
.rdata:00000365                 align 4
.rdata:00000368 $SG146217       db '    defgh   ',0     ; DATA XREF: .data:00000B74o
.rdata:00000375                 align 4
.rdata:00000378 $SG146218       db '    ijkl    ',0     ; DATA XREF: .data:00000B78o
.rdata:00000385                 align 4
.rdata:00000388 $SG146219       db '    mno     ',0     ; DATA XREF: .data:00000B7Co
.rdata:00000395                 align 4
.rdata:00000398 $SG146220       db '    pq      ',0     ; DATA XREF: .data:00000B80o
.rdata:000003A5                 align 4
.rdata:000003A8 $SG146222       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000003B3                 align 4
.rdata:000003B4 $SG146223       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000B8Co
.rdata:000003C0 $SG146224       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000B90o
.rdata:000003CC $SG146225       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000B94o
.rdata:000003D8 $SG146226       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000B98o
.rdata:000003E4 $SG146227       db '#',9,'c #6397E1',0  ; DATA XREF: .data:00000B9Co
.rdata:000003F0 $SG146228       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000BA0o
.rdata:000003FC $SG146229       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000BA4o
.rdata:00000408 $SG146230       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000BA8o
.rdata:00000414 $SG146231       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:00000BACo
.rdata:00000420 $SG146232       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000BB0o
.rdata:0000042C $SG146233       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000BB4o
.rdata:00000438 $SG146234       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000BB8o
.rdata:00000444 $SG146235       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:00000BBCo
.rdata:00000450 $SG146236       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000BC0o
.rdata:0000045C $SG146237       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000BC4o
.rdata:00000468 $SG146238       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000BC8o
.rdata:00000474 $SG146239       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:00000BCCo
.rdata:00000480 $SG146240       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000BD0o
.rdata:0000048C $SG146241       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000BD4o
.rdata:00000498 $SG146242       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000BD8o
.rdata:000004A4 $SG146243       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:00000BDCo
.rdata:000004B0 $SG146244       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000BE0o
.rdata:000004BC $SG146245       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000BE4o
.rdata:000004C8 $SG146246       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000BE8o
.rdata:000004D4 $SG146247       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:00000BECo
.rdata:000004E0 $SG146248       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000BF0o
.rdata:000004EC $SG146249       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000BF4o
.rdata:000004F8 $SG146250       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000BF8o
.rdata:00000504 $SG146251       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:00000BFCo
.rdata:00000510 $SG146252       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000C00o
.rdata:0000051C $SG146253       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000C04o
.rdata:00000528 $SG146254       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000C08o
.rdata:00000534 $SG146255       db '4',9,'c #195CC6',0  ; DATA XREF: .data:00000C0Co
.rdata:00000540 $SG146256       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:00000C10o
.rdata:0000054C $SG146257       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:00000C14o
.rdata:00000558 $SG146258       db '7',9,'c #4885D6',0  ; DATA XREF: .data:00000C18o
.rdata:00000564 $SG146259       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:00000C1Co
.rdata:00000570 $SG146260       db '9',9,'c #6698DB',0  ; DATA XREF: .data:00000C20o
.rdata:0000057C $SG146261       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:00000C24o
.rdata:00000588 $SG146262       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:00000C28o
.rdata:00000594 $SG146263       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:00000C2Co
.rdata:000005A0 $SG146264       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:00000C30o
.rdata:000005AC $SG146265       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:00000C34o
.rdata:000005B8 $SG146266       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:00000C38o
.rdata:000005C4 $SG146267       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:00000C3Co
.rdata:000005D0 $SG146268       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:00000C40o
.rdata:000005DC $SG146269       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:00000C44o
.rdata:000005E8 $SG146270       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:00000C48o
.rdata:000005F4 $SG146271       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:00000C4Co
.rdata:00000600 $SG146272       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:00000C50o
.rdata:0000060C $SG146273       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:00000C54o
.rdata:00000618 $SG146274       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:00000C58o
.rdata:00000624 $SG146275       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:00000C5Co
.rdata:00000630 $SG146276       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:00000C60o
.rdata:0000063C $SG146277       db '         .+ ',0     ; DATA XREF: .data:00000C64o
.rdata:00000649                 align 4
.rdata:0000064C $SG146278       db '        @#$ ',0     ; DATA XREF: .data:00000C68o
.rdata:00000659                 align 4
.rdata:0000065C $SG146279       db '       %&*= L',0    ; DATA XREF: .data:00000C6Co
.rdata:0000066A                 align 4
.rdata:0000066C $SG146280       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000C70o
.rdata:00000679                 align 4
.rdata:0000067C $SG146281       db '     )!>~{] ',0     ; DATA XREF: .data:00000C74o
.rdata:00000689                 align 4
.rdata:0000068C $SG146282       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000C78o
.rdata:00000699                 align 4
.rdata:0000069C $SG146283       db '    (}|1234 ',0     ; DATA XREF: .data:00000C7Co
.rdata:000006A9                 align 4
.rdata:000006AC $SG146284       db '    567890a ',0     ; DATA XREF: .data:00000C80o
.rdata:000006B9                 align 4
.rdata:000006BC $SG146285       db '      bcdef ',0     ; DATA XREF: .data:00000C84o
.rdata:000006C9                 align 4
.rdata:000006CC $SG146286       db '       ghij ',0     ; DATA XREF: .data:00000C88o
.rdata:000006D9                 align 4
.rdata:000006DC $SG146287       db '        klm ',0     ; DATA XREF: .data:00000C8Co
.rdata:000006E9                 align 4
.rdata:000006EC $SG146288       db '         no ',0     ; DATA XREF: .data:00000C90o
.rdata:000006F9                 align 4
.rdata:000006FC $SG146290       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000707                 align 4
.rdata:00000708 $SG146291       db ' ',9,'c None',0     ; DATA XREF: .data:00000C9Co
.rdata:00000711                 align 4
.rdata:00000714 $SG146292       db '.',9,'c #545254',0  ; DATA XREF: .data:00000CA0o
.rdata:00000720 $SG146293       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000CA4o
.rdata:0000072C $SG146294       db '@',9,'c #646464',0  ; DATA XREF: .data:00000CA8o
.rdata:00000738 $SG146295       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:00000CACo
.rdata:00000744 $SG146296       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000CB0o
.rdata:00000750 $SG146297       db '%',9,'c #747284',0  ; DATA XREF: .data:00000CB4o
.rdata:0000075C $SG146298       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000CB8o
.rdata:00000768 $SG146299       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:00000CBCo
.rdata:00000774 $SG146300       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000CC0o
.rdata:00000780 $SG146301       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000CC4o
.rdata:0000078C $SG146302       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000CC8o
.rdata:00000798 $SG146303       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:00000CCCo
.rdata:000007A4 $SG146304       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000CD0o
.rdata:000007B0 $SG146305       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000CD4o
.rdata:000007BC $SG146306       db ')',9,'c #282668',0  ; DATA XREF: .data:00000CD8o
.rdata:000007C8 $SG146307       db '!',9,'c #24367C',0  ; DATA XREF: .data:00000CDCo
.rdata:000007D4 $SG146308       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000CE0o
.rdata:000007E0 $SG146309       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000CE4o
.rdata:000007EC $SG146310       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000CE8o
.rdata:000007F8 $SG146311       db '^',9,'c #142E7C',0  ; DATA XREF: .data:00000CECo
.rdata:00000804 $SG146312       db '/',9,'c #143789',0  ; DATA XREF: .data:00000CF0o
.rdata:00000810 $SG146313       db '(',9,'c #204990',0  ; DATA XREF: .data:00000CF4o
.rdata:0000081C $SG146314       db '_',9,'c #174091',0  ; DATA XREF: .data:00000CF8o
.rdata:00000828 $SG146315       db ':',9,'c #0C0630',0  ; DATA XREF: .data:00000CFCo
.rdata:00000834 $SG146316       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000D00o
.rdata:00000840 $SG146317       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000D04o
.rdata:0000084C $SG146318       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000D08o
.rdata:00000858 $SG146319       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:00000D0Co
.rdata:00000864 $SG146320       db '1',9,'c #141244',0  ; DATA XREF: .data:00000D10o
.rdata:00000870 $SG146321       db '2',9,'c #24428C',0  ; DATA XREF: .data:00000D14o
.rdata:0000087C $SG146322       db '3',9,'c #3462B9',0  ; DATA XREF: .data:00000D18o
.rdata:00000888 $SG146323       db '4',9,'c #4470C4',0  ; DATA XREF: .data:00000D1Co
.rdata:00000894 $SG146324       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:00000D20o
.rdata:000008A0 $SG146325       db '6',9,'c #4472CC',0  ; DATA XREF: .data:00000D24o
.rdata:000008AC $SG146326       db '7',9,'c #24224C',0  ; DATA XREF: .data:00000D28o
.rdata:000008B8 $SG146327       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:00000D2Co
.rdata:000008C4 $SG146328       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:00000D30o
.rdata:000008D0 $SG146329       db '0',9,'c #5482DF',0  ; DATA XREF: .data:00000D34o
.rdata:000008DC $SG146330       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:00000D38o
.rdata:000008E8 $SG146331       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:00000D3Co
.rdata:000008F4 $SG146332       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:00000D40o
.rdata:00000900 $SG146333       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:00000D44o
.rdata:0000090C $SG146334       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:00000D48o
.rdata:00000918 $SG146335       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:00000D4Co
.rdata:00000924 $SG146336       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:00000D50o
.rdata:00000930 $SG146337       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:00000D54o
.rdata:0000093C $SG146338       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:00000D58o
.rdata:00000948 $SG146339       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:00000D5Co
.rdata:00000954 $SG146340       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:00000D60o
.rdata:00000960 $SG146341       db 'l',9,'c #243250',0  ; DATA XREF: .data:00000D64o
.rdata:0000096C $SG146342       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:00000D68o
.rdata:00000978 $SG146343       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:00000D6Co
.rdata:00000984 $SG146344       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000D70o
.rdata:00000990 $SG146345       db '     .+.     ',0    ; DATA XREF: .data:00000D74o
.rdata:0000099E                 align 10h
.rdata:000009A0 $SG146346       db '   @##$##@   ',0    ; DATA XREF: .data:00000D78o
.rdata:000009AE                 align 10h
.rdata:000009B0 $SG146347       db '  @%&***&%@  ',0    ; DATA XREF: .data:00000D7Co
.rdata:000009BE                 align 10h
.rdata:000009C0 $SG146348       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000D80o
.rdata:000009CE                 align 10h
.rdata:000009D0 $SG146349       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:000009D0                                         ; DATA XREF: .data:00000D84o
.rdata:000009DE                 align 10h
.rdata:000009E0 $SG146350       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000D88o
.rdata:000009EE                 align 10h
.rdata:000009F0 $SG146351       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:00000D8Co
.rdata:000009FE                 align 10h
.rdata:00000A00 $SG146352       db '12[3455563[21',0    ; DATA XREF: .data:00000D90o
.rdata:00000A0E                 align 10h
.rdata:00000A10 $SG146353       db '7_365899063_7',0    ; DATA XREF: .data:00000D94o
.rdata:00000A1E                 align 10h
.rdata:00000A20 $SG146354       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000D98o
.rdata:00000A2E                 align 10h
.rdata:00000A30 $SG146355       db ' d}8efgfb83d ',0    ; DATA XREF: .data:00000D9Co
.rdata:00000A3E                 align 10h
.rdata:00000A40 $SG146356       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000DA0o
.rdata:00000A4E                 align 10h
.rdata:00000A50 $SG146357       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000DA4o
.rdata:00000A5E                 align 10h
.rdata:00000A60 $SG146358       db '     o@o     ',0    ; DATA XREF: .data:00000DA8o
.rdata:00000A6E                 align 10h
.rdata:00000A6E _rdata          ends
.rdata:00000A6E
.data:00000A70 ; ===========================================================================
.data:00000A70
.data:00000A70 ; Segment type: Pure data
.data:00000A70 ; Segment permissions: Read/Write
.data:00000A70 ; Segment alignment 'qword' can not be represented in assembly
.data:00000A70 _data           segment para public 'DATA' use32
.data:00000A70                 assume cs:_data
.data:00000A70                 ;org 0A70h
.data:00000A70 _acTop_xpm      dd offset $SG146152     ; "12 12 56 1"
.data:00000A74                 dd offset $SG146153     ; " \tc #FFFFFF"
.data:00000A78                 dd offset $SG146154     ; ".\tc #8AB2E9"
.data:00000A7C                 dd offset $SG146155     ; "+\tc #CCDCF6"
.data:00000A80                 dd offset $SG146156     ; "@\tc #80ABEA"
.data:00000A84                 dd offset $SG146157     ; "#\tc #7DA9E8"
.data:00000A88                 dd offset $SG146158     ; "$\tc #C7DAF3"
.data:00000A8C                 dd offset $SG146159     ; "%\tc #79A7E6"
.data:00000A90                 dd offset $SG146160     ; "&\tc #ADC8EF"
.data:00000A94                 dd offset $SG146161     ; "*\tc #87B0E8"
.data:00000A98                 dd offset $SG146162     ; "=\tc #BBD2F0"
.data:00000A9C                 dd offset $SG146163     ; "-\tc #6EA0E2"
.data:00000AA0                 dd offset $SG146164     ; ";\tc #A8C7EE"
.data:00000AA4                 dd offset $SG146165     ; ">\tc #A3C2ED"
.data:00000AA8                 dd offset $SG146166     ; ",\tc #75A4E3"
.data:00000AAC                 dd offset $SG146167     ; "'\tc #A7C4EB"
.data:00000AB0                 dd offset $SG146168     ; ")\tc #6297E1"
.data:00000AB4                 dd offset $SG146169     ; "!\tc #A1C1EC"
.data:00000AB8                 dd offset $SG146170     ; "~\tc #92B7E8"
.data:00000ABC                 dd offset $SG146171     ; "{\tc #99BBE9"
.data:00000AC0                 dd offset $SG146172     ; "]\tc #6197DD"
.data:00000AC4                 dd offset $SG146173     ; "^\tc #96B9E6"
.data:00000AC8                 dd offset $SG146174     ; "/\tc #538EDB"
.data:00000ACC                 dd offset $SG146175     ; "(\tc #99BBEA"
.data:00000AD0                 dd offset $SG146176     ; "_\tc #80AAE3"
.data:00000AD4                 dd offset $SG146177     ; ":\tc #81ABE3"
.data:00000AD8                 dd offset $SG146178     ; "<\tc #8AB1E4"
.data:00000ADC                 dd offset $SG146179     ; "[\tc #4B88D6"
.data:00000AE0                 dd offset $SG146180     ; "}\tc #4882D1"
.data:00000AE4                 dd offset $SG146181     ; "|\tc #4384D6"
.data:00000AE8                 dd offset $SG146182     ; "1\tc #90B5E7"
.data:00000AEC                 dd offset $SG146183     ; "2\tc #74A3E0"
.data:00000AF0                 dd offset $SG146184     ; "3\tc #77A4E0"
.data:00000AF4                 dd offset $SG146185     ; "4\tc #81ABE2"
.data:00000AF8                 dd offset $SG146186     ; "5\tc #437FD3"
.data:00000AFC                 dd offset $SG146187     ; "6\tc #7FA2DF"
.data:00000B00                 dd offset $SG146188     ; "7\tc #3577D2"
.data:00000B04                 dd offset $SG146189     ; "8\tc #87AFE4"
.data:00000B08                 dd offset $SG146190     ; "9\tc #72A1DF"
.data:00000B0C                 dd offset $SG146191     ; "0\tc #7CA9E1"
.data:00000B10                 dd offset $SG146192     ; "a\tc #3F7AD0"
.data:00000B14                 dd offset $SG146193     ; "b\tc #85A4DE"
.data:00000B18                 dd offset $SG146194     ; "c\tc #FBFCFE"
.data:00000B1C                 dd offset $SG146195     ; "d\tc #236ECD"
.data:00000B20                 dd offset $SG146196     ; "e\tc #7EA8E1"
.data:00000B24                 dd offset $SG146197     ; "f\tc #79A6E0"
.data:00000B28                 dd offset $SG146198     ; "g\tc #3D77D0"
.data:00000B2C                 dd offset $SG146199     ; "h\tc #87A4DC"
.data:00000B30                 dd offset $SG146200     ; "i\tc #1A62C9"
.data:00000B34                 dd offset $SG146201     ; "j\tc #75A3DF"
.data:00000B38                 dd offset $SG146202     ; "k\tc #3C74CF"
.data:00000B3C                 dd offset $SG146203     ; "l\tc #8DA6DE"
.data:00000B40                 dd offset $SG146204     ; "m\tc #1859C4"
.data:00000B44                 dd offset $SG146205     ; "n\tc #3B71CC"
.data:00000B48                 dd offset $SG146206     ; "o\tc #8EA5DD"
.data:00000B4C                 dd offset $SG146207     ; "p\tc #164EC0"
.data:00000B50                 dd offset $SG146208     ; "q\tc #92A7DD"
.data:00000B54                 dd offset $SG146209     ; "    .+      "
.data:00000B58                 dd offset $SG146210     ; "    @#$     "
.data:00000B5C                 dd offset $SG146211     ; "    %&*=    "
.data:00000B60                 dd offset $SG146212     ; "    -;>,'   "
.data:00000B64                 dd offset $SG146213     ; "    )!~{]^  "
.data:00000B68                 dd offset $SG146214     ; "    /(_:<[} "
.data:00000B6C                 dd offset $SG146215     ; "    |123456 "
.data:00000B70                 dd offset $SG146216     ; "    7890abc "
.data:00000B74                 dd offset $SG146217     ; "    defgh   "
.data:00000B78                 dd offset $SG146218     ; "    ijkl    "
.data:00000B7C                 dd offset $SG146219     ; "    mno     "
.data:00000B80                 dd offset $SG146220     ; "    pq      "
.data:00000B84                 align 8
.data:00000B88 _acBottom_xpm   dd offset $SG146222     ; "12 12 54 1"
.data:00000B8C                 dd offset $SG146223     ; " \tc #FFFFFF"
.data:00000B90                 dd offset $SG146224     ; ".\tc #C4D7F3"
.data:00000B94                 dd offset $SG146225     ; "+\tc #72A1E3"
.data:00000B98                 dd offset $SG146226     ; "@\tc #C1D6F2"
.data:00000B9C                 dd offset $SG146227     ; "#\tc #6397E1"
.data:00000BA0                 dd offset $SG146228     ; "$\tc #5990DD"
.data:00000BA4                 dd offset $SG146229     ; "%\tc #BBD2F0"
.data:00000BA8                 dd offset $SG146230     ; "&\tc #7AA6E5"
.data:00000BAC                 dd offset $SG146231     ; "*\tc #9ABDEA"
.data:00000BB0                 dd offset $SG146232     ; "=\tc #4A87D9"
.data:00000BB4                 dd offset $SG146233     ; "-\tc #B1CAEE"
.data:00000BB8                 dd offset $SG146234     ; ";\tc #75A4E3"
.data:00000BBC                 dd offset $SG146235     ; ">\tc #99BBE9"
.data:00000BC0                 dd offset $SG146236     ; ",\tc #95B9E8"
.data:00000BC4                 dd offset $SG146237     ; "'\tc #3A7CD4"
.data:00000BC8                 dd offset $SG146238     ; ")\tc #A9C6EC"
.data:00000BCC                 dd offset $SG146239     ; "!\tc #71A0E0"
.data:00000BD0                 dd offset $SG146240     ; "~\tc #86AFE5"
.data:00000BD4                 dd offset $SG146241     ; "{\tc #8DB2E6"
.data:00000BD8                 dd offset $SG146242     ; "]\tc #2A72CF"
.data:00000BDC                 dd offset $SG146243     ; "^\tc #73A0E0"
.data:00000BE0                 dd offset $SG146244     ; "/\tc #6B9DE0"
.data:00000BE4                 dd offset $SG146245     ; "(\tc #95B8E8"
.data:00000BE8                 dd offset $SG146246     ; "_\tc #81ABE3"
.data:00000BEC                 dd offset $SG146247     ; ":\tc #72A1DF"
.data:00000BF0                 dd offset $SG146248     ; "<\tc #83ADE3"
.data:00000BF4                 dd offset $SG146249     ; "[\tc #1B65C9"
.data:00000BF8                 dd offset $SG146250     ; "}\tc #5F95DC"
.data:00000BFC                 dd offset $SG146251     ; "|\tc #8BB3E5"
.data:00000C00                 dd offset $SG146252     ; "1\tc #77A4E0"
.data:00000C04                 dd offset $SG146253     ; "2\tc #679ADC"
.data:00000C08                 dd offset $SG146254     ; "3\tc #7AA6E1"
.data:00000C0C                 dd offset $SG146255     ; "4\tc #195CC6"
.data:00000C10                 dd offset $SG146256     ; "5\tc #FCFDFE"
.data:00000C14                 dd offset $SG146257     ; "6\tc #8DB2E4"
.data:00000C18                 dd offset $SG146258     ; "7\tc #4885D6"
.data:00000C1C                 dd offset $SG146259     ; "8\tc #7CA9E1"
.data:00000C20                 dd offset $SG146260     ; "9\tc #6698DB"
.data:00000C24                 dd offset $SG146261     ; "0\tc #71A1DE"
.data:00000C28                 dd offset $SG146262     ; "a\tc #1752C0"
.data:00000C2C                 dd offset $SG146263     ; "b\tc #88ABE0"
.data:00000C30                 dd offset $SG146264     ; "c\tc #3D77D0"
.data:00000C34                 dd offset $SG146265     ; "d\tc #6E9FDD"
.data:00000C38                 dd offset $SG146266     ; "e\tc #699BDC"
.data:00000C3C                 dd offset $SG146267     ; "f\tc #1547BD"
.data:00000C40                 dd offset $SG146268     ; "g\tc #8DA6DE"
.data:00000C44                 dd offset $SG146269     ; "h\tc #376BC9"
.data:00000C48                 dd offset $SG146270     ; "i\tc #6295DA"
.data:00000C4C                 dd offset $SG146271     ; "j\tc #1440B9"
.data:00000C50                 dd offset $SG146272     ; "k\tc #8DA0DB"
.data:00000C54                 dd offset $SG146273     ; "l\tc #315FC4"
.data:00000C58                 dd offset $SG146274     ; "m\tc #1339B7"
.data:00000C5C                 dd offset $SG146275     ; "n\tc #909FDA"
.data:00000C60                 dd offset $SG146276     ; "o\tc #1233B4"
.data:00000C64                 dd offset $SG146277     ; "         .+ "
.data:00000C68                 dd offset $SG146278     ; "        @#$ "
.data:00000C6C                 dd offset $SG146279     ; "       %&*= L"
.data:00000C70                 dd offset $SG146280     ; "      -;>,' "
.data:00000C74                 dd offset $SG146281     ; "     )!>~{] "
.data:00000C78                 dd offset $SG146282     ; "    ^/(_:<[ "
.data:00000C7C                 dd offset $SG146283     ; "    (}|1234 "
.data:00000C80                 dd offset $SG146284     ; "    567890a "
.data:00000C84                 dd offset $SG146285     ; "      bcdef "
.data:00000C88                 dd offset $SG146286     ; "       ghij "
.data:00000C8C                 dd offset $SG146287     ; "        klm "
.data:00000C90                 dd offset $SG146288     ; "         no "
.data:00000C94                 align 8
.data:00000C98 _bookmark_xpm   dd offset $SG146290     ; "13 14 54 1"
.data:00000C9C                 dd offset $SG146291     ; " \tc None"
.data:00000CA0                 dd offset $SG146292     ; ".\tc #545254"
.data:00000CA4                 dd offset $SG146293     ; "+\tc #3C3E3C"
.data:00000CA8                 dd offset $SG146294     ; "@\tc #646464"
.data:00000CAC                 dd offset $SG146295     ; "#\tc #A4A4A4"
.data:00000CB0                 dd offset $SG146296     ; "$\tc #B7B8B7"
.data:00000CB4                 dd offset $SG146297     ; "%\tc #747284"
.data:00000CB8                 dd offset $SG146298     ; "&\tc #B4B2C4"
.data:00000CBC                 dd offset $SG146299     ; "*\tc #DCD7E4"
.data:00000CC0                 dd offset $SG146300     ; "=\tc #1C1A1C"
.data:00000CC4                 dd offset $SG146301     ; "-\tc #403E58"
.data:00000CC8                 dd offset $SG146302     ; ";\tc #5C5A8C"
.data:00000CCC                 dd offset $SG146303     ; ">\tc #7C7EAC"
.data:00000CD0                 dd offset $SG146304     ; ",\tc #7C8EBC"
.data:00000CD4                 dd offset $SG146305     ; "'\tc #242644"
.data:00000CD8                 dd offset $SG146306     ; ")\tc #282668"
.data:00000CDC                 dd offset $SG146307     ; "!\tc #24367C"
.data:00000CE0                 dd offset $SG146308     ; "~\tc #244A84"
.data:00000CE4                 dd offset $SG146309     ; "{\tc #2C5098"
.data:00000CE8                 dd offset $SG146310     ; "]\tc #14162C"
.data:00000CEC                 dd offset $SG146311     ; "^\tc #142E7C"
.data:00000CF0                 dd offset $SG146312     ; "/\tc #143789"
.data:00000CF4                 dd offset $SG146313     ; "(\tc #204990"
.data:00000CF8                 dd offset $SG146314     ; "_\tc #174091"
.data:00000CFC                 dd offset $SG146315     ; ":\tc #0C0630"
.data:00000D00                 dd offset $SG146316     ; "<\tc #24327C"
.data:00000D04                 dd offset $SG146317     ; "[\tc #2450A0"
.data:00000D08                 dd offset $SG146318     ; "}\tc #345DB4"
.data:00000D0C                 dd offset $SG146319     ; "|\tc #3C68B8"
.data:00000D10                 dd offset $SG146320     ; "1\tc #141244"
.data:00000D14                 dd offset $SG146321     ; "2\tc #24428C"
.data:00000D18                 dd offset $SG146322     ; "3\tc #3462B9"
.data:00000D1C                 dd offset $SG146323     ; "4\tc #4470C4"
.data:00000D20                 dd offset $SG146324     ; "5\tc #4C7FD6"
.data:00000D24                 dd offset $SG146325     ; "6\tc #4472CC"
.data:00000D28                 dd offset $SG146326     ; "7\tc #24224C"
.data:00000D2C                 dd offset $SG146327     ; "8\tc #5C8DEC"
.data:00000D30                 dd offset $SG146328     ; "9\tc #5C94F6"
.data:00000D34                 dd offset $SG146329     ; "0\tc #5482DF"
.data:00000D38                 dd offset $SG146330     ; "a\tc #619DF7"
.data:00000D3C                 dd offset $SG146331     ; "b\tc #6CA6FC"
.data:00000D40                 dd offset $SG146332     ; "c\tc #64A2FC"
.data:00000D44                 dd offset $SG146333     ; "d\tc #1C2E5C"
.data:00000D48                 dd offset $SG146334     ; "e\tc #6CA2FC"
.data:00000D4C                 dd offset $SG146335     ; "f\tc #74B2FC"
.data:00000D50                 dd offset $SG146336     ; "g\tc #7CB8FC"
.data:00000D54                 dd offset $SG146337     ; "h\tc #1C3264"
.data:00000D58                 dd offset $SG146338     ; "i\tc #346AD4"
.data:00000D5C                 dd offset $SG146339     ; "j\tc #7CBEFC"
.data:00000D60                 dd offset $SG146340     ; "k\tc #3C72DC"
.data:00000D64                 dd offset $SG146341     ; "l\tc #243250"
.data:00000D68                 dd offset $SG146342     ; "m\tc #346AB4"
.data:00000D6C                 dd offset $SG146343     ; "n\tc #3C82DC"
.data:00000D70                 dd offset $SG146344     ; "o\tc #6C6A6C"
.data:00000D74                 dd offset $SG146345     ; "     .+.     "
.data:00000D78                 dd offset $SG146346     ; "   @##$##@   "
.data:00000D7C                 dd offset $SG146347     ; "  @%&***&%@  "
.data:00000D80                 dd offset $SG146348     ; " =-;>,,,>;-= "
.data:00000D84                 dd offset $SG146349     ; " ')!~{{{~!)' "
.data:00000D88                 dd offset $SG146350     ; "])^/({{{(_^)]"
.data:00000D8C                 dd offset $SG146351     ; ":<_[}|||}[_<:"
.data:00000D90                 dd offset $SG146352     ; "12[3455563[21"
.data:00000D94                 dd offset $SG146353     ; "7_365899063_7"
.data:00000D98                 dd offset $SG146354     ; " /|09abc904/ "
.data:00000D9C                 dd offset $SG146355     ; " d}8efgfb83d "
.data:00000DA0                 dd offset $SG146356     ; "  hiafjgakh  "
.data:00000DA4                 dd offset $SG146357     ; "   l~mnm~l   "
.data:00000DA8                 dd offset $SG146358     ; "     o@o     "
.data:00000DA8 _data           ends
.data:00000DA8
.text$mn:00000DAC ; ===========================================================================
.text$mn:00000DAC
.text$mn:00000DAC ; Segment type: Pure code
.text$mn:00000DAC ; Segment permissions: Read/Execute
.text$mn:00000DAC _text$mn        segment para public 'CODE' use32
.text$mn:00000DAC                 assume cs:_text$mn
.text$mn:00000DAC                 ;org 0DACh
.text$mn:00000DAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000DAC
.text$mn:00000DAC ; =============== S U B R O U T I N E =======================================
.text$mn:00000DAC
.text$mn:00000DAC ; Attributes: bp-based frame
.text$mn:00000DAC
.text$mn:00000DAC ; public: __thiscall ByteArray::ByteArray(class std::vector<unsigned char, class std::allocator<unsigned char>>)
.text$mn:00000DAC                 public ??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z
.text$mn:00000DAC ??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z proc near
.text$mn:00000DAC                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+2A7p
.text$mn:00000DAC
.text$mn:00000DAC var_18          = dword ptr -18h
.text$mn:00000DAC var_14          = dword ptr -14h
.text$mn:00000DAC var_10          = dword ptr -10h
.text$mn:00000DAC var_C           = dword ptr -0Ch
.text$mn:00000DAC var_4           = dword ptr -4
.text$mn:00000DAC arg_0           = byte ptr  8
.text$mn:00000DAC
.text$mn:00000DAC                 push    ebp
.text$mn:00000DAD                 mov     ebp, esp
.text$mn:00000DAF                 push    0FFFFFFFFh
.text$mn:00000DB1                 push    offset __ehhandler$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z
.text$mn:00000DB6                 mov     eax, large fs:0
.text$mn:00000DBC                 push    eax
.text$mn:00000DBD                 sub     esp, 0Ch
.text$mn:00000DC0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000DC5                 xor     eax, ebp
.text$mn:00000DC7                 push    eax
.text$mn:00000DC8                 lea     eax, [ebp+var_C]
.text$mn:00000DCB                 mov     large fs:0, eax
.text$mn:00000DD1                 mov     [ebp+var_10], ecx
.text$mn:00000DD4                 mov     [ebp+var_4], 0
.text$mn:00000DDB                 lea     ecx, [ebp+arg_0]
.text$mn:00000DDE                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00000DE3                 mov     ecx, [ebp+var_10]
.text$mn:00000DE6                 mov     [ecx+4], eax
.text$mn:00000DE9                 mov     edx, [ebp+var_10]
.text$mn:00000DEC                 cmp     dword ptr [edx+4], 0
.text$mn:00000DF0                 jnz     short loc_DFD
.text$mn:00000DF2                 mov     eax, [ebp+var_10]
.text$mn:00000DF5                 mov     dword ptr [eax], 0
.text$mn:00000DFB                 jmp     short loc_E4F
.text$mn:00000DFD ; ---------------------------------------------------------------------------
.text$mn:00000DFD
.text$mn:00000DFD loc_DFD:                                ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+44j
.text$mn:00000DFD                 mov     ecx, [ebp+var_10]
.text$mn:00000E00                 mov     edx, [ecx+4]
.text$mn:00000E03                 push    edx             ; unsigned int
.text$mn:00000E04                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00000E09                 add     esp, 4
.text$mn:00000E0C                 mov     [ebp+var_18], eax
.text$mn:00000E0F                 mov     eax, [ebp+var_10]
.text$mn:00000E12                 mov     ecx, [ebp+var_18]
.text$mn:00000E15                 mov     [eax], ecx
.text$mn:00000E17                 mov     [ebp+var_14], 0
.text$mn:00000E1E                 jmp     short loc_E29
.text$mn:00000E20 ; ---------------------------------------------------------------------------
.text$mn:00000E20
.text$mn:00000E20 loc_E20:                                ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+A1j
.text$mn:00000E20                 mov     edx, [ebp+var_14]
.text$mn:00000E23                 add     edx, 1
.text$mn:00000E26                 mov     [ebp+var_14], edx
.text$mn:00000E29
.text$mn:00000E29 loc_E29:                                ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+72j
.text$mn:00000E29                 mov     eax, [ebp+var_10]
.text$mn:00000E2C                 mov     ecx, [ebp+var_14]
.text$mn:00000E2F                 cmp     ecx, [eax+4]
.text$mn:00000E32                 jnb     short loc_E4F
.text$mn:00000E34                 mov     edx, [ebp+var_14]
.text$mn:00000E37                 push    edx
.text$mn:00000E38                 lea     ecx, [ebp+arg_0]
.text$mn:00000E3B                 call    ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<uchar,std::allocator<uchar>>::operator[](uint)
.text$mn:00000E40                 mov     ecx, [ebp+var_10]
.text$mn:00000E43                 mov     edx, [ecx]
.text$mn:00000E45                 mov     ecx, [ebp+var_14]
.text$mn:00000E48                 mov     al, [eax]
.text$mn:00000E4A                 mov     [edx+ecx], al
.text$mn:00000E4D                 jmp     short loc_E20
.text$mn:00000E4F ; ---------------------------------------------------------------------------
.text$mn:00000E4F
.text$mn:00000E4F loc_E4F:                                ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+4Fj
.text$mn:00000E4F                                         ; ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+86j
.text$mn:00000E4F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000E56                 lea     ecx, [ebp+arg_0]
.text$mn:00000E59                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:00000E5E                 mov     eax, [ebp+var_10]
.text$mn:00000E61                 mov     ecx, [ebp+var_C]
.text$mn:00000E64                 mov     large fs:0, ecx
.text$mn:00000E6B                 pop     ecx
.text$mn:00000E6C                 mov     esp, ebp
.text$mn:00000E6E                 pop     ebp
.text$mn:00000E6F                 retn    10h
.text$mn:00000E6F ??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z endp
.text$mn:00000E6F
.text$mn:00000E6F ; ---------------------------------------------------------------------------
.text$mn:00000E72                 db 0Ah dup(0CCh)
.text$mn:00000E7C
.text$mn:00000E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E7C
.text$mn:00000E7C ; Attributes: bp-based frame
.text$mn:00000E7C
.text$mn:00000E7C ; public: __thiscall StringArray::StringArray(class std::vector<unsigned char, class std::allocator<unsigned char>>, unsigned int)
.text$mn:00000E7C                 public ??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z
.text$mn:00000E7C ??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z proc near
.text$mn:00000E7C                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+1E0p
.text$mn:00000E7C                                         ; ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+CAp
.text$mn:00000E7C
.text$mn:00000E7C var_28          = dword ptr -28h
.text$mn:00000E7C var_24          = dword ptr -24h
.text$mn:00000E7C var_20          = dword ptr -20h
.text$mn:00000E7C var_1C          = dword ptr -1Ch
.text$mn:00000E7C var_18          = dword ptr -18h
.text$mn:00000E7C var_14          = dword ptr -14h
.text$mn:00000E7C var_D           = byte ptr -0Dh
.text$mn:00000E7C var_C           = dword ptr -0Ch
.text$mn:00000E7C var_4           = dword ptr -4
.text$mn:00000E7C arg_0           = byte ptr  8
.text$mn:00000E7C arg_10          = dword ptr  18h
.text$mn:00000E7C
.text$mn:00000E7C                 push    ebp
.text$mn:00000E7D                 mov     ebp, esp
.text$mn:00000E7F                 push    0FFFFFFFFh
.text$mn:00000E81                 push    offset __ehhandler$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z
.text$mn:00000E86                 mov     eax, large fs:0
.text$mn:00000E8C                 push    eax
.text$mn:00000E8D                 sub     esp, 1Ch
.text$mn:00000E90                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E95                 xor     eax, ebp
.text$mn:00000E97                 push    eax
.text$mn:00000E98                 lea     eax, [ebp+var_C]
.text$mn:00000E9B                 mov     large fs:0, eax
.text$mn:00000EA1                 mov     [ebp+var_14], ecx
.text$mn:00000EA4                 mov     [ebp+var_4], 0
.text$mn:00000EAB                 mov     ecx, [ebp+var_14] ; this
.text$mn:00000EAE                 call    ??0ByteArray@@QAE@XZ ; ByteArray::ByteArray(void)
.text$mn:00000EB3                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000EB7                 lea     ecx, [ebp+arg_0]
.text$mn:00000EBA                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00000EBF                 test    eax, eax
.text$mn:00000EC1                 jnz     short loc_ED1
.text$mn:00000EC3                 mov     eax, [ebp+var_14]
.text$mn:00000EC6                 mov     dword ptr [eax], 0
.text$mn:00000ECC                 jmp     loc_1035
.text$mn:00000ED1 ; ---------------------------------------------------------------------------
.text$mn:00000ED1
.text$mn:00000ED1 loc_ED1:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+45j
.text$mn:00000ED1                 lea     ecx, [ebp+arg_0]
.text$mn:00000ED4                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00000ED9                 cmp     eax, [ebp+arg_10]
.text$mn:00000EDC                 ja      short loc_EE7
.text$mn:00000EDE                 mov     [ebp+var_1C], 1
.text$mn:00000EE5                 jmp     short loc_EEE
.text$mn:00000EE7 ; ---------------------------------------------------------------------------
.text$mn:00000EE7
.text$mn:00000EE7 loc_EE7:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+60j
.text$mn:00000EE7                 mov     [ebp+var_1C], 0
.text$mn:00000EEE
.text$mn:00000EEE loc_EEE:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+69j
.text$mn:00000EEE                 mov     cl, byte ptr [ebp+var_1C]
.text$mn:00000EF1                 mov     [ebp+var_D], cl
.text$mn:00000EF4                 movzx   edx, [ebp+var_D]
.text$mn:00000EF8                 test    edx, edx
.text$mn:00000EFA                 jz      short loc_F09
.text$mn:00000EFC                 lea     ecx, [ebp+arg_0]
.text$mn:00000EFF                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00000F04                 mov     [ebp+var_20], eax
.text$mn:00000F07                 jmp     short loc_F0F
.text$mn:00000F09 ; ---------------------------------------------------------------------------
.text$mn:00000F09
.text$mn:00000F09 loc_F09:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+7Ej
.text$mn:00000F09                 mov     eax, [ebp+arg_10]
.text$mn:00000F0C                 mov     [ebp+var_20], eax
.text$mn:00000F0F
.text$mn:00000F0F loc_F0F:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+8Bj
.text$mn:00000F0F                 mov     ecx, [ebp+var_14]
.text$mn:00000F12                 mov     edx, [ebp+var_20]
.text$mn:00000F15                 mov     [ecx+4], edx
.text$mn:00000F18                 movzx   eax, [ebp+var_D]
.text$mn:00000F1C                 test    eax, eax
.text$mn:00000F1E                 jz      short loc_F29
.text$mn:00000F20                 mov     [ebp+var_24], 0
.text$mn:00000F27                 jmp     short loc_F30
.text$mn:00000F29 ; ---------------------------------------------------------------------------
.text$mn:00000F29
.text$mn:00000F29 loc_F29:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+A2j
.text$mn:00000F29                 mov     [ebp+var_24], 2
.text$mn:00000F30
.text$mn:00000F30 loc_F30:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+ABj
.text$mn:00000F30                 mov     ecx, [ebp+var_14]
.text$mn:00000F33                 mov     edx, [ecx+4]
.text$mn:00000F36                 add     edx, [ebp+var_24]
.text$mn:00000F39                 push    edx             ; unsigned int
.text$mn:00000F3A                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:00000F3F                 add     esp, 4
.text$mn:00000F42                 mov     [ebp+var_28], eax
.text$mn:00000F45                 mov     eax, [ebp+var_14]
.text$mn:00000F48                 mov     ecx, [ebp+var_28]
.text$mn:00000F4B                 mov     [eax], ecx
.text$mn:00000F4D                 mov     [ebp+var_18], 0
.text$mn:00000F54                 jmp     short loc_F5F
.text$mn:00000F56 ; ---------------------------------------------------------------------------
.text$mn:00000F56
.text$mn:00000F56 loc_F56:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint):loc_1007j
.text$mn:00000F56                 mov     edx, [ebp+var_18]
.text$mn:00000F59                 add     edx, 1
.text$mn:00000F5C                 mov     [ebp+var_18], edx
.text$mn:00000F5F
.text$mn:00000F5F loc_F5F:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+D8j
.text$mn:00000F5F                 mov     eax, [ebp+var_14]
.text$mn:00000F62                 mov     ecx, [ebp+var_18]
.text$mn:00000F65                 cmp     ecx, [eax+4]
.text$mn:00000F68                 jnb     loc_100C
.text$mn:00000F6E                 movzx   edx, [ebp+var_D]
.text$mn:00000F72                 test    edx, edx
.text$mn:00000F74                 jnz     short loc_FAE
.text$mn:00000F76                 mov     eax, [ebp+var_14]
.text$mn:00000F79                 mov     ecx, [eax+4]
.text$mn:00000F7C                 sub     ecx, 5
.text$mn:00000F7F                 cmp     [ebp+var_18], ecx
.text$mn:00000F82                 jz      short loc_FA0
.text$mn:00000F84                 mov     edx, [ebp+var_14]
.text$mn:00000F87                 mov     eax, [edx+4]
.text$mn:00000F8A                 sub     eax, 3
.text$mn:00000F8D                 cmp     [ebp+var_18], eax
.text$mn:00000F90                 jz      short loc_FA0
.text$mn:00000F92                 mov     ecx, [ebp+var_14]
.text$mn:00000F95                 mov     edx, [ecx+4]
.text$mn:00000F98                 sub     edx, 1
.text$mn:00000F9B                 cmp     [ebp+var_18], edx
.text$mn:00000F9E                 jnz     short loc_FAE
.text$mn:00000FA0
.text$mn:00000FA0 loc_FA0:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+106j
.text$mn:00000FA0                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+114j
.text$mn:00000FA0                 mov     eax, [ebp+var_14]
.text$mn:00000FA3                 mov     ecx, [eax]
.text$mn:00000FA5                 mov     edx, [ebp+var_18]
.text$mn:00000FA8                 mov     byte ptr [ecx+edx], 0
.text$mn:00000FAC                 jmp     short loc_1007
.text$mn:00000FAE ; ---------------------------------------------------------------------------
.text$mn:00000FAE
.text$mn:00000FAE loc_FAE:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+F8j
.text$mn:00000FAE                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+122j
.text$mn:00000FAE                 movzx   eax, [ebp+var_D]
.text$mn:00000FB2                 test    eax, eax
.text$mn:00000FB4                 jnz     short loc_FEE
.text$mn:00000FB6                 mov     ecx, [ebp+var_14]
.text$mn:00000FB9                 mov     edx, [ecx+4]
.text$mn:00000FBC                 sub     edx, 6
.text$mn:00000FBF                 cmp     [ebp+var_18], edx
.text$mn:00000FC2                 jz      short loc_FE0
.text$mn:00000FC4                 mov     eax, [ebp+var_14]
.text$mn:00000FC7                 mov     ecx, [eax+4]
.text$mn:00000FCA                 sub     ecx, 4
.text$mn:00000FCD                 cmp     [ebp+var_18], ecx
.text$mn:00000FD0                 jz      short loc_FE0
.text$mn:00000FD2                 mov     edx, [ebp+var_14]
.text$mn:00000FD5                 mov     eax, [edx+4]
.text$mn:00000FD8                 sub     eax, 2
.text$mn:00000FDB                 cmp     [ebp+var_18], eax
.text$mn:00000FDE                 jnz     short loc_FEE
.text$mn:00000FE0
.text$mn:00000FE0 loc_FE0:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+146j
.text$mn:00000FE0                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+154j
.text$mn:00000FE0                 mov     ecx, [ebp+var_14]
.text$mn:00000FE3                 mov     edx, [ecx]
.text$mn:00000FE5                 mov     eax, [ebp+var_18]
.text$mn:00000FE8                 mov     byte ptr [edx+eax], 2Eh ; '.'
.text$mn:00000FEC                 jmp     short loc_1007
.text$mn:00000FEE ; ---------------------------------------------------------------------------
.text$mn:00000FEE
.text$mn:00000FEE loc_FEE:                                ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+138j
.text$mn:00000FEE                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+162j
.text$mn:00000FEE                 mov     ecx, [ebp+var_18]
.text$mn:00000FF1                 push    ecx
.text$mn:00000FF2                 lea     ecx, [ebp+arg_0]
.text$mn:00000FF5                 call    ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<uchar,std::allocator<uchar>>::operator[](uint)
.text$mn:00000FFA                 mov     edx, [ebp+var_14]
.text$mn:00000FFD                 mov     ecx, [edx]
.text$mn:00000FFF                 mov     edx, [ebp+var_18]
.text$mn:00001002                 mov     al, [eax]
.text$mn:00001004                 mov     [ecx+edx], al
.text$mn:00001007
.text$mn:00001007 loc_1007:                               ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+130j
.text$mn:00001007                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+170j
.text$mn:00001007                 jmp     loc_F56
.text$mn:0000100C ; ---------------------------------------------------------------------------
.text$mn:0000100C
.text$mn:0000100C loc_100C:                               ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+ECj
.text$mn:0000100C                 movzx   ecx, [ebp+var_D]
.text$mn:00001010                 test    ecx, ecx
.text$mn:00001012                 jnz     short loc_1035
.text$mn:00001014                 mov     edx, [ebp+var_14]
.text$mn:00001017                 mov     eax, [edx]
.text$mn:00001019                 mov     ecx, [ebp+var_18]
.text$mn:0000101C                 mov     byte ptr [eax+ecx], 0
.text$mn:00001020                 mov     edx, [ebp+var_18]
.text$mn:00001023                 add     edx, 1
.text$mn:00001026                 mov     [ebp+var_18], edx
.text$mn:00001029                 mov     eax, [ebp+var_14]
.text$mn:0000102C                 mov     ecx, [eax]
.text$mn:0000102E                 mov     edx, [ebp+var_18]
.text$mn:00001031                 mov     byte ptr [ecx+edx], 0
.text$mn:00001035
.text$mn:00001035 loc_1035:                               ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+50j
.text$mn:00001035                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+196j
.text$mn:00001035                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000103C                 lea     ecx, [ebp+arg_0]
.text$mn:0000103F                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:00001044                 mov     eax, [ebp+var_14]
.text$mn:00001047                 mov     ecx, [ebp+var_C]
.text$mn:0000104A                 mov     large fs:0, ecx
.text$mn:00001051                 pop     ecx
.text$mn:00001052                 mov     esp, ebp
.text$mn:00001054                 pop     ebp
.text$mn:00001055                 retn    14h
.text$mn:00001055 ??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z endp
.text$mn:00001055
.text$mn:00001055 ; ---------------------------------------------------------------------------
.text$mn:00001058                 db 4 dup(0CCh)
.text$mn:0000105C
.text$mn:0000105C ; =============== S U B R O U T I N E =======================================
.text$mn:0000105C
.text$mn:0000105C ; Attributes: bp-based frame
.text$mn:0000105C
.text$mn:0000105C ; public: class std::vector<unsigned char, class std::allocator<unsigned char>> __thiscall ClipboardHistoryPanel::getClipboadData(void)
.text$mn:0000105C                 public ?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ
.text$mn:0000105C ?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ proc near
.text$mn:0000105C                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+111p
.text$mn:0000105C
.text$mn:0000105C var_4C          = byte ptr -4Ch
.text$mn:0000105C var_3C          = dword ptr -3Ch
.text$mn:0000105C var_38          = dword ptr -38h
.text$mn:0000105C lpString        = dword ptr -34h
.text$mn:0000105C var_30          = dword ptr -30h
.text$mn:0000105C var_2C          = dword ptr -2Ch
.text$mn:0000105C format          = dword ptr -28h
.text$mn:0000105C var_24          = dword ptr -24h
.text$mn:0000105C var_20          = dword ptr -20h
.text$mn:0000105C var_1C          = dword ptr -1Ch
.text$mn:0000105C hMem            = dword ptr -18h
.text$mn:0000105C var_14          = dword ptr -14h
.text$mn:0000105C var_E           = byte ptr -0Eh
.text$mn:0000105C var_D           = byte ptr -0Dh
.text$mn:0000105C var_C           = dword ptr -0Ch
.text$mn:0000105C var_4           = dword ptr -4
.text$mn:0000105C arg_0           = dword ptr  8
.text$mn:0000105C
.text$mn:0000105C                 push    ebp
.text$mn:0000105D                 mov     ebp, esp
.text$mn:0000105F                 push    0FFFFFFFFh
.text$mn:00001061                 push    offset __ehhandler$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ
.text$mn:00001066                 mov     eax, large fs:0
.text$mn:0000106C                 push    eax
.text$mn:0000106D                 sub     esp, 40h
.text$mn:00001070                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001075                 xor     eax, ebp
.text$mn:00001077                 push    eax
.text$mn:00001078                 lea     eax, [ebp+var_C]
.text$mn:0000107B                 mov     large fs:0, eax
.text$mn:00001081                 mov     [ebp+var_3C], ecx
.text$mn:00001084                 mov     [ebp+var_14], 0
.text$mn:0000108B                 lea     ecx, [ebp+var_4C]
.text$mn:0000108E                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(void)
.text$mn:00001093                 mov     [ebp+var_4], 1
.text$mn:0000109A                 push    0Dh             ; format
.text$mn:0000109C                 call    dword ptr ds:__imp__IsClipboardFormatAvailable@4 ; IsClipboardFormatAvailable(x)
.text$mn:000010A2                 test    eax, eax
.text$mn:000010A4                 jnz     short loc_10CF
.text$mn:000010A6                 lea     eax, [ebp+var_4C]
.text$mn:000010A9                 push    eax
.text$mn:000010AA                 mov     ecx, [ebp+arg_0]
.text$mn:000010AD                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:000010B2                 mov     ecx, [ebp+var_14]
.text$mn:000010B5                 or      ecx, 1
.text$mn:000010B8                 mov     [ebp+var_14], ecx
.text$mn:000010BB                 mov     byte ptr [ebp+var_4], 0
.text$mn:000010BF                 lea     ecx, [ebp+var_4C]
.text$mn:000010C2                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:000010C7                 mov     eax, [ebp+arg_0]
.text$mn:000010CA                 jmp     loc_1238
.text$mn:000010CF ; ---------------------------------------------------------------------------
.text$mn:000010CF
.text$mn:000010CF loc_10CF:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+48j
.text$mn:000010CF                 push    0               ; hWndNewOwner
.text$mn:000010D1                 call    dword ptr ds:__imp__OpenClipboard@4 ; OpenClipboard(x)
.text$mn:000010D7                 test    eax, eax
.text$mn:000010D9                 jnz     short loc_1104
.text$mn:000010DB                 lea     edx, [ebp+var_4C]
.text$mn:000010DE                 push    edx
.text$mn:000010DF                 mov     ecx, [ebp+arg_0]
.text$mn:000010E2                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:000010E7                 mov     eax, [ebp+var_14]
.text$mn:000010EA                 or      eax, 1
.text$mn:000010ED                 mov     [ebp+var_14], eax
.text$mn:000010F0                 mov     byte ptr [ebp+var_4], 0
.text$mn:000010F4                 lea     ecx, [ebp+var_4C]
.text$mn:000010F7                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:000010FC                 mov     eax, [ebp+arg_0]
.text$mn:000010FF                 jmp     loc_1238
.text$mn:00001104 ; ---------------------------------------------------------------------------
.text$mn:00001104
.text$mn:00001104 loc_1104:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+7Dj
.text$mn:00001104                 push    0Dh             ; uFormat
.text$mn:00001106                 call    dword ptr ds:__imp__GetClipboardData@4 ; GetClipboardData(x)
.text$mn:0000110C                 mov     [ebp+hMem], eax
.text$mn:0000110F                 cmp     [ebp+hMem], 0
.text$mn:00001113                 jz      loc_120E
.text$mn:00001119                 mov     ecx, [ebp+hMem]
.text$mn:0000111C                 push    ecx             ; hMem
.text$mn:0000111D                 call    dword ptr ds:__imp__GlobalLock@4 ; GlobalLock(x)
.text$mn:00001123                 mov     [ebp+var_24], eax
.text$mn:00001126                 mov     edx, [ebp+hMem]
.text$mn:00001129                 push    edx             ; hMem
.text$mn:0000112A                 call    dword ptr ds:__imp__GlobalLock@4 ; GlobalLock(x)
.text$mn:00001130                 mov     [ebp+lpString], eax
.text$mn:00001133                 cmp     [ebp+var_24], 0
.text$mn:00001137                 jz      loc_120E
.text$mn:0000113D                 push    offset $SG154635 ; "Notepad++ Binary Text Length"
.text$mn:00001142                 call    dword ptr ds:__imp__RegisterClipboardFormatW@4 ; RegisterClipboardFormatW(x)
.text$mn:00001148                 mov     [ebp+format], eax
.text$mn:0000114B                 mov     eax, [ebp+format]
.text$mn:0000114E                 push    eax             ; format
.text$mn:0000114F                 call    dword ptr ds:__imp__IsClipboardFormatAvailable@4 ; IsClipboardFormatAvailable(x)
.text$mn:00001155                 test    eax, eax
.text$mn:00001157                 jz      short loc_11C0
.text$mn:00001159                 mov     ecx, [ebp+format]
.text$mn:0000115C                 push    ecx             ; uFormat
.text$mn:0000115D                 call    dword ptr ds:__imp__GetClipboardData@4 ; GetClipboardData(x)
.text$mn:00001163                 mov     [ebp+var_2C], eax
.text$mn:00001166                 cmp     [ebp+var_2C], 0
.text$mn:0000116A                 jz      short loc_11BE
.text$mn:0000116C                 mov     edx, [ebp+var_2C]
.text$mn:0000116F                 push    edx             ; hMem
.text$mn:00001170                 call    dword ptr ds:__imp__GlobalLock@4 ; GlobalLock(x)
.text$mn:00001176                 mov     [ebp+var_30], eax
.text$mn:00001179                 cmp     [ebp+var_30], 0
.text$mn:0000117D                 jz      short loc_11BE
.text$mn:0000117F                 mov     [ebp+var_1C], 0
.text$mn:00001186                 jmp     short loc_1191
.text$mn:00001188 ; ---------------------------------------------------------------------------
.text$mn:00001188
.text$mn:00001188 loc_1188:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+156j
.text$mn:00001188                 mov     eax, [ebp+var_1C]
.text$mn:0000118B                 add     eax, 1
.text$mn:0000118E                 mov     [ebp+var_1C], eax
.text$mn:00001191
.text$mn:00001191 loc_1191:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+12Aj
.text$mn:00001191                 mov     ecx, [ebp+var_30]
.text$mn:00001194                 mov     edx, [ebp+var_1C]
.text$mn:00001197                 cmp     edx, [ecx]
.text$mn:00001199                 jnb     short loc_11B4
.text$mn:0000119B                 mov     eax, [ebp+var_24]
.text$mn:0000119E                 add     eax, [ebp+var_1C]
.text$mn:000011A1                 mov     cl, [eax]
.text$mn:000011A3                 mov     [ebp+var_D], cl
.text$mn:000011A6                 lea     edx, [ebp+var_D]
.text$mn:000011A9                 push    edx
.text$mn:000011AA                 lea     ecx, [ebp+var_4C]
.text$mn:000011AD                 call    ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)
.text$mn:000011B2                 jmp     short loc_1188
.text$mn:000011B4 ; ---------------------------------------------------------------------------
.text$mn:000011B4
.text$mn:000011B4 loc_11B4:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+13Dj
.text$mn:000011B4                 mov     eax, [ebp+hMem]
.text$mn:000011B7                 push    eax             ; hMem
.text$mn:000011B8                 call    dword ptr ds:__imp__GlobalUnlock@4 ; GlobalUnlock(x)
.text$mn:000011BE
.text$mn:000011BE loc_11BE:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+10Ej
.text$mn:000011BE                                         ; ClipboardHistoryPanel::getClipboadData(void)+121j
.text$mn:000011BE                 jmp     short loc_1204
.text$mn:000011C0 ; ---------------------------------------------------------------------------
.text$mn:000011C0
.text$mn:000011C0 loc_11C0:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+FBj
.text$mn:000011C0                 mov     ecx, [ebp+lpString]
.text$mn:000011C3                 push    ecx             ; lpString
.text$mn:000011C4                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000011CA                 lea     edx, [eax+eax+2]
.text$mn:000011CE                 mov     [ebp+var_38], edx
.text$mn:000011D1                 mov     [ebp+var_20], 0
.text$mn:000011D8                 jmp     short loc_11E3
.text$mn:000011DA ; ---------------------------------------------------------------------------
.text$mn:000011DA
.text$mn:000011DA loc_11DA:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+1A6j
.text$mn:000011DA                 mov     eax, [ebp+var_20]
.text$mn:000011DD                 add     eax, 1
.text$mn:000011E0                 mov     [ebp+var_20], eax
.text$mn:000011E3
.text$mn:000011E3 loc_11E3:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+17Cj
.text$mn:000011E3                 mov     ecx, [ebp+var_20]
.text$mn:000011E6                 cmp     ecx, [ebp+var_38]
.text$mn:000011E9                 jge     short loc_1204
.text$mn:000011EB                 mov     edx, [ebp+var_24]
.text$mn:000011EE                 add     edx, [ebp+var_20]
.text$mn:000011F1                 mov     al, [edx]
.text$mn:000011F3                 mov     [ebp+var_E], al
.text$mn:000011F6                 lea     ecx, [ebp+var_E]
.text$mn:000011F9                 push    ecx
.text$mn:000011FA                 lea     ecx, [ebp+var_4C]
.text$mn:000011FD                 call    ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z ; std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)
.text$mn:00001202                 jmp     short loc_11DA
.text$mn:00001204 ; ---------------------------------------------------------------------------
.text$mn:00001204
.text$mn:00001204 loc_1204:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void):loc_11BEj
.text$mn:00001204                                         ; ClipboardHistoryPanel::getClipboadData(void)+18Dj
.text$mn:00001204                 mov     edx, [ebp+hMem]
.text$mn:00001207                 push    edx             ; hMem
.text$mn:00001208                 call    dword ptr ds:__imp__GlobalUnlock@4 ; GlobalUnlock(x)
.text$mn:0000120E
.text$mn:0000120E loc_120E:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+B7j
.text$mn:0000120E                                         ; ClipboardHistoryPanel::getClipboadData(void)+DBj
.text$mn:0000120E                 call    dword ptr ds:__imp__CloseClipboard@0 ; CloseClipboard()
.text$mn:00001214                 lea     eax, [ebp+var_4C]
.text$mn:00001217                 push    eax
.text$mn:00001218                 mov     ecx, [ebp+arg_0]
.text$mn:0000121B                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:00001220                 mov     ecx, [ebp+var_14]
.text$mn:00001223                 or      ecx, 1
.text$mn:00001226                 mov     [ebp+var_14], ecx
.text$mn:00001229                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000122D                 lea     ecx, [ebp+var_4C]
.text$mn:00001230                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:00001235                 mov     eax, [ebp+arg_0]
.text$mn:00001238
.text$mn:00001238 loc_1238:                               ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+6Ej
.text$mn:00001238                                         ; ClipboardHistoryPanel::getClipboadData(void)+A3j
.text$mn:00001238                 mov     ecx, [ebp+var_C]
.text$mn:0000123B                 mov     large fs:0, ecx
.text$mn:00001242                 pop     ecx
.text$mn:00001243                 mov     esp, ebp
.text$mn:00001245                 pop     ebp
.text$mn:00001246                 retn    4
.text$mn:00001246 ?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ endp
.text$mn:00001246
.text$mn:00001246 ; ---------------------------------------------------------------------------
.text$mn:00001249                 align 4
.text$mn:0000124C
.text$mn:0000124C ; =============== S U B R O U T I N E =======================================
.text$mn:0000124C
.text$mn:0000124C ; Attributes: bp-based frame
.text$mn:0000124C
.text$mn:0000124C ; public: void __thiscall ClipboardHistoryPanel::addToClipboadHistory(class std::vector<unsigned char, class std::allocator<unsigned char>>)
.text$mn:0000124C                 public ?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z
.text$mn:0000124C ?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z proc near
.text$mn:0000124C                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+14Ep
.text$mn:0000124C
.text$mn:0000124C var_B4          = byte ptr -0B4h
.text$mn:0000124C var_A8          = byte ptr -0A8h
.text$mn:0000124C var_9C          = byte ptr -9Ch
.text$mn:0000124C var_90          = byte ptr -90h
.text$mn:0000124C var_84          = byte ptr -84h
.text$mn:0000124C var_78          = dword ptr -78h
.text$mn:0000124C var_74          = dword ptr -74h
.text$mn:0000124C var_70          = dword ptr -70h
.text$mn:0000124C var_6C          = dword ptr -6Ch
.text$mn:0000124C var_68          = dword ptr -68h
.text$mn:0000124C var_64          = dword ptr -64h
.text$mn:0000124C var_60          = dword ptr -60h
.text$mn:0000124C var_5C          = dword ptr -5Ch
.text$mn:0000124C var_58          = dword ptr -58h
.text$mn:0000124C var_54          = dword ptr -54h
.text$mn:0000124C var_50          = dword ptr -50h
.text$mn:0000124C var_4C          = byte ptr -4Ch
.text$mn:0000124C lParam          = dword ptr -44h
.text$mn:0000124C var_40          = dword ptr -40h
.text$mn:0000124C var_3C          = dword ptr -3Ch
.text$mn:0000124C var_38          = dword ptr -38h
.text$mn:0000124C var_34          = dword ptr -34h
.text$mn:0000124C var_30          = dword ptr -30h
.text$mn:0000124C var_2C          = dword ptr -2Ch
.text$mn:0000124C var_28          = dword ptr -28h
.text$mn:0000124C var_24          = dword ptr -24h
.text$mn:0000124C var_20          = dword ptr -20h
.text$mn:0000124C var_1C          = dword ptr -1Ch
.text$mn:0000124C var_18          = dword ptr -18h
.text$mn:0000124C wParam          = dword ptr -14h
.text$mn:0000124C var_10          = dword ptr -10h
.text$mn:0000124C var_C           = dword ptr -0Ch
.text$mn:0000124C var_4           = dword ptr -4
.text$mn:0000124C arg_0           = byte ptr  8
.text$mn:0000124C
.text$mn:0000124C                 push    ebp
.text$mn:0000124D                 mov     ebp, esp
.text$mn:0000124F                 push    0FFFFFFFFh
.text$mn:00001251                 push    offset __ehhandler$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z
.text$mn:00001256                 mov     eax, large fs:0
.text$mn:0000125C                 push    eax
.text$mn:0000125D                 sub     esp, 0A8h
.text$mn:00001263                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001268                 xor     eax, ebp
.text$mn:0000126A                 push    eax
.text$mn:0000126B                 lea     eax, [ebp+var_C]
.text$mn:0000126E                 mov     large fs:0, eax
.text$mn:00001274                 mov     [ebp+var_10], ecx
.text$mn:00001277                 mov     [ebp+var_4], 0
.text$mn:0000127E                 sub     esp, 10h
.text$mn:00001281                 mov     ecx, esp
.text$mn:00001283                 mov     [ebp+var_64], esp
.text$mn:00001286                 lea     eax, [ebp+arg_0]
.text$mn:00001289                 push    eax
.text$mn:0000128A                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:0000128F                 mov     [ebp+var_40], eax
.text$mn:00001292                 mov     ecx, [ebp+var_40]
.text$mn:00001295                 mov     [ebp+var_50], ecx
.text$mn:00001298                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000129C                 mov     byte ptr [ebp+var_4], 0
.text$mn:000012A0                 mov     ecx, [ebp+var_10]
.text$mn:000012A3                 call    ?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z ; ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)
.text$mn:000012A8                 mov     [ebp+var_34], eax
.text$mn:000012AB                 mov     edx, [ebp+var_34]
.text$mn:000012AE                 mov     [ebp+wParam], edx
.text$mn:000012B1                 cmp     [ebp+wParam], 0
.text$mn:000012B5                 jnz     short loc_12CB
.text$mn:000012B7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012BE                 lea     ecx, [ebp+arg_0]
.text$mn:000012C1                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:000012C6                 jmp     loc_147B
.text$mn:000012CB ; ---------------------------------------------------------------------------
.text$mn:000012CB
.text$mn:000012CB loc_12CB:                               ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+69j
.text$mn:000012CB                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:000012CF                 jz      loc_1391
.text$mn:000012D5                 mov     eax, [ebp+wParam]
.text$mn:000012D8                 push    eax
.text$mn:000012D9                 lea     ecx, [ebp+var_A8]
.text$mn:000012DF                 push    ecx
.text$mn:000012E0                 lea     edx, [ebp+var_90]
.text$mn:000012E6                 push    edx
.text$mn:000012E7                 mov     ecx, [ebp+var_10]
.text$mn:000012EA                 add     ecx, 70h ; 'p'
.text$mn:000012ED                 call    ?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::begin(void)
.text$mn:000012F2                 mov     [ebp+var_24], eax
.text$mn:000012F5                 mov     eax, [ebp+var_24]
.text$mn:000012F8                 mov     [ebp+var_3C], eax
.text$mn:000012FB                 mov     byte ptr [ebp+var_4], 2
.text$mn:000012FF                 mov     ecx, [ebp+var_3C]
.text$mn:00001302                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+(int)
.text$mn:00001307                 mov     [ebp+var_2C], eax
.text$mn:0000130A                 mov     ecx, [ebp+var_2C]
.text$mn:0000130D                 mov     [ebp+var_18], ecx
.text$mn:00001310                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001314                 sub     esp, 0Ch
.text$mn:00001317                 mov     ecx, esp
.text$mn:00001319                 mov     [ebp+var_58], esp
.text$mn:0000131C                 mov     edx, [ebp+var_18]
.text$mn:0000131F                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00001320                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)
.text$mn:00001325                 mov     [ebp+var_1C], eax
.text$mn:00001328                 mov     eax, [ebp+var_1C]
.text$mn:0000132B                 mov     [ebp+var_6C], eax
.text$mn:0000132E                 mov     byte ptr [ebp+var_4], 4
.text$mn:00001332                 lea     ecx, [ebp+var_84]
.text$mn:00001338                 push    ecx
.text$mn:00001339                 mov     ecx, [ebp+var_10]
.text$mn:0000133C                 add     ecx, 70h ; 'p'
.text$mn:0000133F                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001343                 call    ?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)
.text$mn:00001348                 mov     [ebp+var_60], eax
.text$mn:0000134B                 lea     ecx, [ebp+var_84]
.text$mn:00001351                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:00001356                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000135A                 lea     ecx, [ebp+var_A8]
.text$mn:00001360                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:00001365                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001369                 lea     ecx, [ebp+var_90]
.text$mn:0000136F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:00001374                 push    0               ; lParam
.text$mn:00001376                 mov     edx, [ebp+wParam]
.text$mn:00001379                 push    edx             ; wParam
.text$mn:0000137A                 push    182h            ; Msg
.text$mn:0000137F                 push    0AF1h           ; nIDDlgItem
.text$mn:00001384                 mov     eax, [ebp+var_10]
.text$mn:00001387                 mov     ecx, [eax+0Ch]
.text$mn:0000138A                 push    ecx             ; hDlg
.text$mn:0000138B                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00001391
.text$mn:00001391 loc_1391:                               ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+83j
.text$mn:00001391                 lea     edx, [ebp+arg_0]
.text$mn:00001394                 push    edx
.text$mn:00001395                 lea     eax, [ebp+var_B4]
.text$mn:0000139B                 push    eax
.text$mn:0000139C                 mov     ecx, [ebp+var_10]
.text$mn:0000139F                 add     ecx, 70h ; 'p'
.text$mn:000013A2                 call    ?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::begin(void)
.text$mn:000013A7                 mov     [ebp+var_20], eax
.text$mn:000013AA                 mov     ecx, [ebp+var_20]
.text$mn:000013AD                 mov     [ebp+var_28], ecx
.text$mn:000013B0                 mov     byte ptr [ebp+var_4], 5
.text$mn:000013B4                 sub     esp, 0Ch
.text$mn:000013B7                 mov     ecx, esp
.text$mn:000013B9                 mov     [ebp+var_70], esp
.text$mn:000013BC                 mov     edx, [ebp+var_28]
.text$mn:000013BF                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000013C0                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)
.text$mn:000013C5                 mov     [ebp+var_30], eax
.text$mn:000013C8                 mov     eax, [ebp+var_30]
.text$mn:000013CB                 mov     [ebp+var_68], eax
.text$mn:000013CE                 mov     byte ptr [ebp+var_4], 6
.text$mn:000013D2                 lea     ecx, [ebp+var_9C]
.text$mn:000013D8                 push    ecx
.text$mn:000013D9                 mov     ecx, [ebp+var_10]
.text$mn:000013DC                 add     ecx, 70h ; 'p'
.text$mn:000013DF                 mov     byte ptr [ebp+var_4], 5
.text$mn:000013E3                 call    ?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::insert(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:000013E8                 mov     [ebp+var_78], eax
.text$mn:000013EB                 lea     ecx, [ebp+var_9C]
.text$mn:000013F1                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:000013F6                 mov     byte ptr [ebp+var_4], 0
.text$mn:000013FA                 lea     ecx, [ebp+var_B4]
.text$mn:00001400                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:00001405                 push    40h ; '@'
.text$mn:00001407                 sub     esp, 10h
.text$mn:0000140A                 mov     ecx, esp
.text$mn:0000140C                 mov     [ebp+var_74], esp
.text$mn:0000140F                 lea     edx, [ebp+arg_0]
.text$mn:00001412                 push    edx
.text$mn:00001413                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00001418                 mov     [ebp+var_38], eax
.text$mn:0000141B                 mov     eax, [ebp+var_38]
.text$mn:0000141E                 mov     [ebp+var_54], eax
.text$mn:00001421                 mov     byte ptr [ebp+var_4], 7
.text$mn:00001425                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001429                 lea     ecx, [ebp+var_4C]
.text$mn:0000142C                 call    ??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)
.text$mn:00001431                 mov     [ebp+var_5C], eax
.text$mn:00001434                 mov     byte ptr [ebp+var_4], 8
.text$mn:00001438                 lea     ecx, [ebp+var_4C] ; this
.text$mn:0000143B                 call    ?getPointer@ByteArray@@QBEPBEXZ ; ByteArray::getPointer(void)
.text$mn:00001440                 mov     [ebp+lParam], eax
.text$mn:00001443                 mov     ecx, [ebp+lParam]
.text$mn:00001446                 push    ecx             ; lParam
.text$mn:00001447                 push    0               ; wParam
.text$mn:00001449                 push    181h            ; Msg
.text$mn:0000144E                 push    0AF1h           ; nIDDlgItem
.text$mn:00001453                 mov     edx, [ebp+var_10]
.text$mn:00001456                 mov     eax, [edx+0Ch]
.text$mn:00001459                 push    eax             ; hDlg
.text$mn:0000145A                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00001460                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001464                 lea     ecx, [ebp+var_4C] ; this
.text$mn:00001467                 call    ??1StringArray@@QAE@XZ ; StringArray::~StringArray(void)
.text$mn:0000146C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001473                 lea     ecx, [ebp+arg_0]
.text$mn:00001476                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:0000147B
.text$mn:0000147B loc_147B:                               ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+7Aj
.text$mn:0000147B                 mov     ecx, [ebp+var_C]
.text$mn:0000147E                 mov     large fs:0, ecx
.text$mn:00001485                 pop     ecx
.text$mn:00001486                 mov     esp, ebp
.text$mn:00001488                 pop     ebp
.text$mn:00001489                 retn    10h
.text$mn:00001489 ?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z endp ; sp-analysis failed
.text$mn:00001489
.text$mn:0000148C
.text$mn:0000148C ; =============== S U B R O U T I N E =======================================
.text$mn:0000148C
.text$mn:0000148C ; Attributes: bp-based frame
.text$mn:0000148C
.text$mn:0000148C ; public: int __thiscall ClipboardHistoryPanel::getClipboardDataIndex(class std::vector<unsigned char, class std::allocator<unsigned char>>)
.text$mn:0000148C                 public ?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z
.text$mn:0000148C ?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z proc near
.text$mn:0000148C                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+57p
.text$mn:0000148C
.text$mn:0000148C var_2C          = dword ptr -2Ch
.text$mn:0000148C var_28          = dword ptr -28h
.text$mn:0000148C var_24          = dword ptr -24h
.text$mn:0000148C var_20          = dword ptr -20h
.text$mn:0000148C var_1C          = dword ptr -1Ch
.text$mn:0000148C var_18          = dword ptr -18h
.text$mn:0000148C var_14          = dword ptr -14h
.text$mn:0000148C var_D           = byte ptr -0Dh
.text$mn:0000148C var_C           = dword ptr -0Ch
.text$mn:0000148C var_4           = dword ptr -4
.text$mn:0000148C arg_0           = byte ptr  8
.text$mn:0000148C
.text$mn:0000148C                 push    ebp
.text$mn:0000148D                 mov     ebp, esp
.text$mn:0000148F                 push    0FFFFFFFFh
.text$mn:00001491                 push    offset __ehhandler$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z
.text$mn:00001496                 mov     eax, large fs:0
.text$mn:0000149C                 push    eax
.text$mn:0000149D                 sub     esp, 20h
.text$mn:000014A0                 push    esi
.text$mn:000014A1                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014A6                 xor     eax, ebp
.text$mn:000014A8                 push    eax
.text$mn:000014A9                 lea     eax, [ebp+var_C]
.text$mn:000014AC                 mov     large fs:0, eax
.text$mn:000014B2                 mov     [ebp+var_1C], ecx
.text$mn:000014B5                 mov     [ebp+var_4], 0
.text$mn:000014BC                 mov     [ebp+var_20], 0FFFFFFFFh
.text$mn:000014C3                 mov     [ebp+var_D], 0
.text$mn:000014C7                 mov     [ebp+var_14], 0
.text$mn:000014CE                 mov     ecx, [ebp+var_1C]
.text$mn:000014D1                 add     ecx, 70h ; 'p'
.text$mn:000014D4                 call    ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::size(void)
.text$mn:000014D9                 mov     [ebp+var_24], eax
.text$mn:000014DC                 jmp     short loc_14E7
.text$mn:000014DE ; ---------------------------------------------------------------------------
.text$mn:000014DE
.text$mn:000014DE loc_14DE:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>):loc_158Aj
.text$mn:000014DE                 mov     eax, [ebp+var_14]
.text$mn:000014E1                 add     eax, 1
.text$mn:000014E4                 mov     [ebp+var_14], eax
.text$mn:000014E7
.text$mn:000014E7 loc_14E7:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+50j
.text$mn:000014E7                 mov     ecx, [ebp+var_14]
.text$mn:000014EA                 cmp     ecx, [ebp+var_24]
.text$mn:000014ED                 jnb     loc_158F
.text$mn:000014F3                 lea     ecx, [ebp+arg_0]
.text$mn:000014F6                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:000014FB                 mov     esi, eax
.text$mn:000014FD                 mov     edx, [ebp+var_14]
.text$mn:00001500                 push    edx
.text$mn:00001501                 mov     ecx, [ebp+var_1C]
.text$mn:00001504                 add     ecx, 70h ; 'p'
.text$mn:00001507                 call    ??A?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAEAAV?$vector@EV?$allocator@E@std@@@1@I@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)
.text$mn:0000150C                 mov     ecx, eax
.text$mn:0000150E                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00001513                 cmp     esi, eax
.text$mn:00001515                 jnz     short loc_158A
.text$mn:00001517                 mov     [ebp+var_18], 0
.text$mn:0000151E                 lea     ecx, [ebp+arg_0]
.text$mn:00001521                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00001526                 mov     [ebp+var_28], eax
.text$mn:00001529                 jmp     short loc_1534
.text$mn:0000152B ; ---------------------------------------------------------------------------
.text$mn:0000152B
.text$mn:0000152B loc_152B:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>):loc_1578j
.text$mn:0000152B                 mov     eax, [ebp+var_18]
.text$mn:0000152E                 add     eax, 1
.text$mn:00001531                 mov     [ebp+var_18], eax
.text$mn:00001534
.text$mn:00001534 loc_1534:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+9Dj
.text$mn:00001534                 mov     ecx, [ebp+var_18]
.text$mn:00001537                 cmp     ecx, [ebp+var_28]
.text$mn:0000153A                 jnb     short loc_157A
.text$mn:0000153C                 mov     edx, [ebp+var_18]
.text$mn:0000153F                 push    edx
.text$mn:00001540                 lea     ecx, [ebp+arg_0]
.text$mn:00001543                 call    ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<uchar,std::allocator<uchar>>::operator[](uint)
.text$mn:00001548                 movzx   esi, byte ptr [eax]
.text$mn:0000154B                 mov     eax, [ebp+var_18]
.text$mn:0000154E                 push    eax
.text$mn:0000154F                 mov     ecx, [ebp+var_14]
.text$mn:00001552                 push    ecx
.text$mn:00001553                 mov     ecx, [ebp+var_1C]
.text$mn:00001556                 add     ecx, 70h ; 'p'
.text$mn:00001559                 call    ??A?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAEAAV?$vector@EV?$allocator@E@std@@@1@I@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)
.text$mn:0000155E                 mov     ecx, eax
.text$mn:00001560                 call    ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z ; std::vector<uchar,std::allocator<uchar>>::operator[](uint)
.text$mn:00001565                 movzx   edx, byte ptr [eax]
.text$mn:00001568                 cmp     esi, edx
.text$mn:0000156A                 jnz     short loc_1572
.text$mn:0000156C                 mov     [ebp+var_D], 1
.text$mn:00001570                 jmp     short loc_1578
.text$mn:00001572 ; ---------------------------------------------------------------------------
.text$mn:00001572
.text$mn:00001572 loc_1572:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+DEj
.text$mn:00001572                 mov     [ebp+var_D], 0
.text$mn:00001576                 jmp     short loc_157A
.text$mn:00001578 ; ---------------------------------------------------------------------------
.text$mn:00001578
.text$mn:00001578 loc_1578:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+E4j
.text$mn:00001578                 jmp     short loc_152B
.text$mn:0000157A ; ---------------------------------------------------------------------------
.text$mn:0000157A
.text$mn:0000157A loc_157A:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+AEj
.text$mn:0000157A                                         ; ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+EAj
.text$mn:0000157A                 movzx   eax, [ebp+var_D]
.text$mn:0000157E                 test    eax, eax
.text$mn:00001580                 jz      short loc_158A
.text$mn:00001582                 mov     ecx, [ebp+var_14]
.text$mn:00001585                 mov     [ebp+var_20], ecx
.text$mn:00001588                 jmp     short loc_158F
.text$mn:0000158A ; ---------------------------------------------------------------------------
.text$mn:0000158A
.text$mn:0000158A loc_158A:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+89j
.text$mn:0000158A                                         ; ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+F4j
.text$mn:0000158A                 jmp     loc_14DE
.text$mn:0000158F ; ---------------------------------------------------------------------------
.text$mn:0000158F
.text$mn:0000158F loc_158F:                               ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+61j
.text$mn:0000158F                                         ; ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+FCj
.text$mn:0000158F                 mov     edx, [ebp+var_20]
.text$mn:00001592                 mov     [ebp+var_2C], edx
.text$mn:00001595                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000159C                 lea     ecx, [ebp+arg_0]
.text$mn:0000159F                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:000015A4                 mov     eax, [ebp+var_2C]
.text$mn:000015A7                 mov     ecx, [ebp+var_C]
.text$mn:000015AA                 mov     large fs:0, ecx
.text$mn:000015B1                 pop     ecx
.text$mn:000015B2                 pop     esi
.text$mn:000015B3                 mov     esp, ebp
.text$mn:000015B5                 pop     ebp
.text$mn:000015B6                 retn    10h
.text$mn:000015B6 ?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z endp
.text$mn:000015B6
.text$mn:000015B6 ; ---------------------------------------------------------------------------
.text$mn:000015B9                 align 4
.text$mn:000015BC
.text$mn:000015BC ; =============== S U B R O U T I N E =======================================
.text$mn:000015BC
.text$mn:000015BC ; Attributes: bp-based frame
.text$mn:000015BC
.text$mn:000015BC ; void __thiscall ClipboardHistoryPanel::drawItem(ClipboardHistoryPanel *this, struct tagDRAWITEMSTRUCT *)
.text$mn:000015BC                 public ?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z
.text$mn:000015BC ?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z proc near
.text$mn:000015BC                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+40Dp
.text$mn:000015BC
.text$mn:000015BC var_3C          = byte ptr -3Ch
.text$mn:000015BC var_34          = dword ptr -34h
.text$mn:000015BC var_30          = dword ptr -30h
.text$mn:000015BC var_2C          = dword ptr -2Ch
.text$mn:000015BC var_28          = dword ptr -28h
.text$mn:000015BC color           = dword ptr -24h
.text$mn:000015BC var_20          = dword ptr -20h
.text$mn:000015BC lpString        = dword ptr -1Ch
.text$mn:000015BC var_18          = dword ptr -18h
.text$mn:000015BC var_14          = dword ptr -14h
.text$mn:000015BC var_10          = dword ptr -10h
.text$mn:000015BC var_C           = dword ptr -0Ch
.text$mn:000015BC var_4           = dword ptr -4
.text$mn:000015BC arg_0           = dword ptr  8
.text$mn:000015BC
.text$mn:000015BC                 push    ebp
.text$mn:000015BD                 mov     ebp, esp
.text$mn:000015BF                 push    0FFFFFFFFh
.text$mn:000015C1                 push    offset __ehhandler$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z
.text$mn:000015C6                 mov     eax, large fs:0
.text$mn:000015CC                 push    eax
.text$mn:000015CD                 sub     esp, 30h
.text$mn:000015D0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015D5                 xor     eax, ebp
.text$mn:000015D7                 push    eax
.text$mn:000015D8                 lea     eax, [ebp+var_C]
.text$mn:000015DB                 mov     large fs:0, eax
.text$mn:000015E1                 mov     [ebp+var_10], ecx
.text$mn:000015E4                 mov     ecx, [ebp+var_10]
.text$mn:000015E7                 add     ecx, 70h ; 'p'
.text$mn:000015EA                 call    ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::size(void)
.text$mn:000015EF                 mov     ecx, [ebp+arg_0]
.text$mn:000015F2                 cmp     [ecx+8], eax
.text$mn:000015F5                 jb      short loc_15FC
.text$mn:000015F7                 jmp     loc_16F6
.text$mn:000015FC ; ---------------------------------------------------------------------------
.text$mn:000015FC
.text$mn:000015FC loc_15FC:                               ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+39j
.text$mn:000015FC                 mov     edx, [ebp+var_10]
.text$mn:000015FF                 cmp     dword ptr [edx+88h], 0FFFFFFFFh
.text$mn:00001606                 jnz     short loc_1611
.text$mn:00001608                 mov     [ebp+var_14], 0
.text$mn:0000160F                 jmp     short loc_161D
.text$mn:00001611 ; ---------------------------------------------------------------------------
.text$mn:00001611
.text$mn:00001611 loc_1611:                               ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+4Aj
.text$mn:00001611                 mov     eax, [ebp+var_10]
.text$mn:00001614                 mov     ecx, [eax+88h]
.text$mn:0000161A                 mov     [ebp+var_14], ecx
.text$mn:0000161D
.text$mn:0000161D loc_161D:                               ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+53j
.text$mn:0000161D                 mov     edx, [ebp+var_14]
.text$mn:00001620                 mov     [ebp+color], edx
.text$mn:00001623                 mov     eax, [ebp+var_10]
.text$mn:00001626                 cmp     dword ptr [eax+84h], 0FFFFFFFFh
.text$mn:0000162D                 jnz     short loc_1638
.text$mn:0000162F                 mov     [ebp+var_18], 0FFFFFFh
.text$mn:00001636                 jmp     short loc_1644
.text$mn:00001638 ; ---------------------------------------------------------------------------
.text$mn:00001638
.text$mn:00001638 loc_1638:                               ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+71j
.text$mn:00001638                 mov     ecx, [ebp+var_10]
.text$mn:0000163B                 mov     edx, [ecx+84h]
.text$mn:00001641                 mov     [ebp+var_18], edx
.text$mn:00001644
.text$mn:00001644 loc_1644:                               ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+7Aj
.text$mn:00001644                 mov     eax, [ebp+var_18]
.text$mn:00001647                 mov     [ebp+var_28], eax
.text$mn:0000164A                 push    40h ; '@'
.text$mn:0000164C                 mov     ecx, [ebp+arg_0]
.text$mn:0000164F                 mov     edx, [ecx+8]
.text$mn:00001652                 push    edx
.text$mn:00001653                 mov     ecx, [ebp+var_10]
.text$mn:00001656                 add     ecx, 70h ; 'p'
.text$mn:00001659                 call    ??A?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAEAAV?$vector@EV?$allocator@E@std@@@1@I@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)
.text$mn:0000165E                 sub     esp, 10h
.text$mn:00001661                 mov     ecx, esp
.text$mn:00001663                 mov     [ebp+var_2C], esp
.text$mn:00001666                 push    eax
.text$mn:00001667                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:0000166C                 mov     [ebp+var_20], eax
.text$mn:0000166F                 mov     eax, [ebp+var_20]
.text$mn:00001672                 mov     [ebp+var_30], eax
.text$mn:00001675                 mov     [ebp+var_4], 0
.text$mn:0000167C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001683                 lea     ecx, [ebp+var_3C]
.text$mn:00001686                 call    ??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)
.text$mn:0000168B                 mov     [ebp+var_34], eax
.text$mn:0000168E                 mov     [ebp+var_4], 1
.text$mn:00001695                 lea     ecx, [ebp+var_3C] ; this
.text$mn:00001698                 call    ?getPointer@ByteArray@@QBEPBEXZ ; ByteArray::getPointer(void)
.text$mn:0000169D                 mov     [ebp+lpString], eax
.text$mn:000016A0                 mov     ecx, [ebp+color]
.text$mn:000016A3                 push    ecx             ; color
.text$mn:000016A4                 mov     edx, [ebp+arg_0]
.text$mn:000016A7                 mov     eax, [edx+18h]
.text$mn:000016AA                 push    eax             ; hdc
.text$mn:000016AB                 call    dword ptr ds:__imp__SetTextColor@8 ; SetTextColor(x,x)
.text$mn:000016B1                 mov     ecx, [ebp+var_28]
.text$mn:000016B4                 push    ecx             ; color
.text$mn:000016B5                 mov     edx, [ebp+arg_0]
.text$mn:000016B8                 mov     eax, [edx+18h]
.text$mn:000016BB                 push    eax             ; hdc
.text$mn:000016BC                 call    dword ptr ds:__imp__SetBkColor@8 ; SetBkColor(x,x)
.text$mn:000016C2                 push    24h ; '$'       ; format
.text$mn:000016C4                 mov     ecx, [ebp+arg_0]
.text$mn:000016C7                 add     ecx, 1Ch
.text$mn:000016CA                 push    ecx             ; lprc
.text$mn:000016CB                 mov     edx, [ebp+lpString]
.text$mn:000016CE                 push    edx             ; lpString
.text$mn:000016CF                 call    dword ptr ds:__imp__lstrlenW@4 ; lstrlenW(x)
.text$mn:000016D5                 push    eax             ; cchText
.text$mn:000016D6                 mov     eax, [ebp+lpString]
.text$mn:000016D9                 push    eax             ; lpchText
.text$mn:000016DA                 mov     ecx, [ebp+arg_0]
.text$mn:000016DD                 mov     edx, [ecx+18h]
.text$mn:000016E0                 push    edx             ; hdc
.text$mn:000016E1                 call    dword ptr ds:__imp__DrawTextW@20 ; DrawTextW(x,x,x,x,x)
.text$mn:000016E7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016EE                 lea     ecx, [ebp+var_3C] ; this
.text$mn:000016F1                 call    ??1StringArray@@QAE@XZ ; StringArray::~StringArray(void)
.text$mn:000016F6
.text$mn:000016F6 loc_16F6:                               ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+3Bj
.text$mn:000016F6                 mov     ecx, [ebp+var_C]
.text$mn:000016F9                 mov     large fs:0, ecx
.text$mn:00001700                 pop     ecx
.text$mn:00001701                 mov     esp, ebp
.text$mn:00001703                 pop     ebp
.text$mn:00001704                 retn    4
.text$mn:00001704 ?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z endp
.text$mn:00001704
.text$mn:00001704 ; ---------------------------------------------------------------------------
.text$mn:00001707                 db 5 dup(0CCh)
.text$mn:0000170C
.text$mn:0000170C ; =============== S U B R O U T I N E =======================================
.text$mn:0000170C
.text$mn:0000170C ; Attributes: bp-based frame
.text$mn:0000170C
.text$mn:0000170C ; int __stdcall ClipboardHistoryPanel::run_dlgProc(ClipboardHistoryPanel *this, UINT Msg, WPARAM wParam, LPARAM lParam)
.text$mn:0000170C                 public ?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z
.text$mn:0000170C ?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z proc near
.text$mn:0000170C
.text$mn:0000170C var_74          = byte ptr -74h
.text$mn:0000170C var_64          = byte ptr -64h
.text$mn:0000170C var_5C          = dword ptr -5Ch
.text$mn:0000170C var_58          = dword ptr -58h
.text$mn:0000170C var_54          = dword ptr -54h
.text$mn:0000170C var_50          = dword ptr -50h
.text$mn:0000170C var_4C          = dword ptr -4Ch
.text$mn:0000170C nWidth          = dword ptr -48h
.text$mn:0000170C nHeight         = dword ptr -44h
.text$mn:0000170C var_40          = dword ptr -40h
.text$mn:0000170C var_3C          = dword ptr -3Ch
.text$mn:0000170C var_38          = dword ptr -38h
.text$mn:0000170C var_34          = dword ptr -34h
.text$mn:0000170C var_30          = dword ptr -30h
.text$mn:0000170C var_2C          = dword ptr -2Ch
.text$mn:0000170C var_28          = dword ptr -28h
.text$mn:0000170C var_24          = dword ptr -24h
.text$mn:0000170C var_20          = dword ptr -20h
.text$mn:0000170C var_1C          = dword ptr -1Ch
.text$mn:0000170C lpMultiByteStr  = dword ptr -18h
.text$mn:0000170C CodePage        = dword ptr -14h
.text$mn:0000170C var_10          = dword ptr -10h
.text$mn:0000170C var_C           = dword ptr -0Ch
.text$mn:0000170C var_4           = dword ptr -4
.text$mn:0000170C this            = dword ptr  8
.text$mn:0000170C Msg             = dword ptr  0Ch
.text$mn:0000170C wParam          = dword ptr  10h
.text$mn:0000170C lParam          = dword ptr  14h
.text$mn:0000170C
.text$mn:0000170C                 push    ebp
.text$mn:0000170D                 mov     ebp, esp
.text$mn:0000170F                 push    0FFFFFFFFh
.text$mn:00001711                 push    offset __ehhandler$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z
.text$mn:00001716                 mov     eax, large fs:0
.text$mn:0000171C                 push    eax
.text$mn:0000171D                 sub     esp, 68h
.text$mn:00001720                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001725                 xor     eax, ebp
.text$mn:00001727                 push    eax
.text$mn:00001728                 lea     eax, [ebp+var_C]
.text$mn:0000172B                 mov     large fs:0, eax
.text$mn:00001731                 mov     eax, [ebp+Msg]
.text$mn:00001734                 mov     [ebp+var_10], eax
.text$mn:00001737                 cmp     [ebp+var_10], 111h
.text$mn:0000173E                 ja      short loc_1784
.text$mn:00001740                 cmp     [ebp+var_10], 111h
.text$mn:00001747                 jz      loc_18C1
.text$mn:0000174D                 cmp     [ebp+var_10], 2Bh ; '+'
.text$mn:00001751                 ja      short loc_1776
.text$mn:00001753                 cmp     [ebp+var_10], 2Bh ; '+'
.text$mn:00001757                 jz      loc_1B12
.text$mn:0000175D                 cmp     [ebp+var_10], 2
.text$mn:00001761                 jz      loc_18A5
.text$mn:00001767                 cmp     [ebp+var_10], 5
.text$mn:0000176B                 jz      loc_1AA9
.text$mn:00001771                 jmp     loc_1B20
.text$mn:00001776 ; ---------------------------------------------------------------------------
.text$mn:00001776
.text$mn:00001776 loc_1776:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+45j
.text$mn:00001776                 cmp     [ebp+var_10], 110h
.text$mn:0000177D                 jz      short loc_17A8
.text$mn:0000177F                 jmp     loc_1B20
.text$mn:00001784 ; ---------------------------------------------------------------------------
.text$mn:00001784
.text$mn:00001784 loc_1784:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+32j
.text$mn:00001784                 cmp     [ebp+var_10], 134h
.text$mn:0000178B                 jz      loc_1AF2
.text$mn:00001791                 cmp     [ebp+var_10], 308h
.text$mn:00001798                 jz      short loc_1816
.text$mn:0000179A                 cmp     [ebp+var_10], 30Dh
.text$mn:000017A1                 jz      short loc_17C8
.text$mn:000017A3                 jmp     loc_1B20
.text$mn:000017A8 ; ---------------------------------------------------------------------------
.text$mn:000017A8
.text$mn:000017A8 loc_17A8:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+71j
.text$mn:000017A8                 mov     ecx, [ebp+this]
.text$mn:000017AB                 mov     edx, [ecx+0Ch]
.text$mn:000017AE                 push    edx             ; hWndNewViewer
.text$mn:000017AF                 call    dword ptr ds:__imp__SetClipboardViewer@4 ; SetClipboardViewer(x)
.text$mn:000017B5                 mov     ecx, [ebp+this]
.text$mn:000017B8                 mov     [ecx+80h], eax
.text$mn:000017BE                 mov     eax, 1
.text$mn:000017C3                 jmp     loc_1B4C
.text$mn:000017C8 ; ---------------------------------------------------------------------------
.text$mn:000017C8
.text$mn:000017C8 loc_17C8:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+95j
.text$mn:000017C8                 mov     edx, [ebp+this]
.text$mn:000017CB                 mov     eax, [edx+80h]
.text$mn:000017D1                 cmp     eax, [ebp+wParam]
.text$mn:000017D4                 jnz     short loc_17E4
.text$mn:000017D6                 mov     ecx, [ebp+this]
.text$mn:000017D9                 mov     edx, [ebp+lParam]
.text$mn:000017DC                 mov     [ecx+80h], edx
.text$mn:000017E2                 jmp     short loc_180C
.text$mn:000017E4 ; ---------------------------------------------------------------------------
.text$mn:000017E4
.text$mn:000017E4 loc_17E4:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+C8j
.text$mn:000017E4                 mov     eax, [ebp+this]
.text$mn:000017E7                 cmp     dword ptr [eax+80h], 0
.text$mn:000017EE                 jz      short loc_180C
.text$mn:000017F0                 mov     ecx, [ebp+lParam]
.text$mn:000017F3                 push    ecx             ; lParam
.text$mn:000017F4                 mov     edx, [ebp+wParam]
.text$mn:000017F7                 push    edx             ; wParam
.text$mn:000017F8                 mov     eax, [ebp+Msg]
.text$mn:000017FB                 push    eax             ; Msg
.text$mn:000017FC                 mov     ecx, [ebp+this]
.text$mn:000017FF                 mov     edx, [ecx+80h]
.text$mn:00001805                 push    edx             ; hWnd
.text$mn:00001806                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000180C
.text$mn:0000180C loc_180C:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+D6j
.text$mn:0000180C                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+E2j
.text$mn:0000180C                 mov     eax, 1
.text$mn:00001811                 jmp     loc_1B4C
.text$mn:00001816 ; ---------------------------------------------------------------------------
.text$mn:00001816
.text$mn:00001816 loc_1816:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+8Cj
.text$mn:00001816                 lea     eax, [ebp+var_74]
.text$mn:00001819                 push    eax
.text$mn:0000181A                 mov     ecx, [ebp+this]
.text$mn:0000181D                 call    ?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ ; ClipboardHistoryPanel::getClipboadData(void)
.text$mn:00001822                 mov     [ebp+var_4], 0
.text$mn:00001829                 lea     ecx, [ebp+var_74]
.text$mn:0000182C                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00001831                 test    eax, eax
.text$mn:00001833                 jz      short loc_185F
.text$mn:00001835                 sub     esp, 10h
.text$mn:00001838                 mov     ecx, esp
.text$mn:0000183A                 mov     [ebp+var_4C], esp
.text$mn:0000183D                 lea     edx, [ebp+var_74]
.text$mn:00001840                 push    edx
.text$mn:00001841                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00001846                 mov     [ebp+var_28], eax
.text$mn:00001849                 mov     eax, [ebp+var_28]
.text$mn:0000184C                 mov     [ebp+var_50], eax
.text$mn:0000184F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001853                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001857                 mov     ecx, [ebp+this]
.text$mn:0000185A                 call    ?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z ; ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)
.text$mn:0000185F
.text$mn:0000185F loc_185F:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+127j
.text$mn:0000185F                 mov     ecx, [ebp+this]
.text$mn:00001862                 cmp     dword ptr [ecx+80h], 0
.text$mn:00001869                 jz      short loc_1887
.text$mn:0000186B                 mov     edx, [ebp+lParam]
.text$mn:0000186E                 push    edx             ; lParam
.text$mn:0000186F                 mov     eax, [ebp+wParam]
.text$mn:00001872                 push    eax             ; wParam
.text$mn:00001873                 mov     ecx, [ebp+Msg]
.text$mn:00001876                 push    ecx             ; Msg
.text$mn:00001877                 mov     edx, [ebp+this]
.text$mn:0000187A                 mov     eax, [edx+80h]
.text$mn:00001880                 push    eax             ; hWnd
.text$mn:00001881                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001887
.text$mn:00001887 loc_1887:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+15Dj
.text$mn:00001887                 mov     [ebp+var_2C], 1
.text$mn:0000188E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001895                 lea     ecx, [ebp+var_74]
.text$mn:00001898                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:0000189D                 mov     eax, [ebp+var_2C]
.text$mn:000018A0                 jmp     loc_1B4C
.text$mn:000018A5 ; ---------------------------------------------------------------------------
.text$mn:000018A5
.text$mn:000018A5 loc_18A5:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+55j
.text$mn:000018A5                 mov     ecx, [ebp+this]
.text$mn:000018A8                 mov     edx, [ecx+80h]
.text$mn:000018AE                 push    edx             ; hWndNewNext
.text$mn:000018AF                 mov     eax, [ebp+this]
.text$mn:000018B2                 mov     ecx, [eax+0Ch]
.text$mn:000018B5                 push    ecx             ; hWndRemove
.text$mn:000018B6                 call    dword ptr ds:__imp__ChangeClipboardChain@8 ; ChangeClipboardChain(x,x)
.text$mn:000018BC                 jmp     loc_1B37
.text$mn:000018C1 ; ---------------------------------------------------------------------------
.text$mn:000018C1
.text$mn:000018C1 loc_18C1:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3Bj
.text$mn:000018C1                 mov     edx, [ebp+wParam]
.text$mn:000018C4                 and     edx, 0FFFFh
.text$mn:000018CA                 movzx   eax, dx
.text$mn:000018CD                 mov     [ebp+var_30], eax
.text$mn:000018D0                 cmp     [ebp+var_30], 0AF1h
.text$mn:000018D7                 jz      short loc_18DE
.text$mn:000018D9                 jmp     loc_1AA4
.text$mn:000018DE ; ---------------------------------------------------------------------------
.text$mn:000018DE
.text$mn:000018DE loc_18DE:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+1CBj
.text$mn:000018DE                 mov     ecx, [ebp+wParam]
.text$mn:000018E1                 shr     ecx, 10h
.text$mn:000018E4                 and     ecx, 0FFFFh
.text$mn:000018EA                 movzx   edx, cx
.text$mn:000018ED                 cmp     edx, 2
.text$mn:000018F0                 jnz     loc_1A9A
.text$mn:000018F6                 push    0               ; lParam
.text$mn:000018F8                 push    0               ; wParam
.text$mn:000018FA                 push    188h            ; Msg
.text$mn:000018FF                 push    0AF1h           ; nIDDlgItem
.text$mn:00001904                 mov     eax, [ebp+this]
.text$mn:00001907                 mov     ecx, [eax+0Ch]
.text$mn:0000190A                 push    ecx             ; hDlg
.text$mn:0000190B                 call    dword ptr ds:__imp__SendDlgItemMessageW@20 ; SendDlgItemMessageW(x,x,x,x,x)
.text$mn:00001911                 mov     [ebp+var_20], eax
.text$mn:00001914                 cmp     [ebp+var_20], 0FFFFFFFFh
.text$mn:00001918                 jz      loc_1A9A
.text$mn:0000191E                 mov     edx, [ebp+this]
.text$mn:00001921                 mov     eax, [edx+6Ch]
.text$mn:00001924                 mov     ecx, [eax]      ; this
.text$mn:00001926                 call    ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ ; ScintillaEditView::getCurrentBuffer(void)
.text$mn:0000192B                 mov     ecx, eax        ; this
.text$mn:0000192D                 call    ?getEncoding@Buffer@@QBEHXZ ; Buffer::getEncoding(void)
.text$mn:00001932                 mov     [ebp+CodePage], eax
.text$mn:00001935                 cmp     [ebp+CodePage], 0FFFFFFFFh
.text$mn:00001939                 jnz     short loc_1975
.text$mn:0000193B                 push    0               ; __int32
.text$mn:0000193D                 push    0               ; unsigned int
.text$mn:0000193F                 push    859h            ; unsigned int
.text$mn:00001944                 mov     ecx, [ebp+this]
.text$mn:00001947                 mov     edx, [ecx+6Ch]
.text$mn:0000194A                 mov     ecx, [edx]      ; this
.text$mn:0000194C                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001951                 mov     [ebp+var_34], eax
.text$mn:00001954                 cmp     [ebp+var_34], 0FDE9h
.text$mn:0000195B                 jnz     short loc_1966
.text$mn:0000195D                 mov     [ebp+var_1C], 0FDE9h
.text$mn:00001964                 jmp     short loc_196D
.text$mn:00001966 ; ---------------------------------------------------------------------------
.text$mn:00001966
.text$mn:00001966 loc_1966:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+24Fj
.text$mn:00001966                 mov     [ebp+var_1C], 0
.text$mn:0000196D
.text$mn:0000196D loc_196D:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+258j
.text$mn:0000196D                 mov     eax, [ebp+var_1C]
.text$mn:00001970                 mov     [ebp+CodePage], eax
.text$mn:00001973                 jmp     short loc_197C
.text$mn:00001975 ; ---------------------------------------------------------------------------
.text$mn:00001975
.text$mn:00001975 loc_1975:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+22Dj
.text$mn:00001975                 mov     [ebp+CodePage], 0FDE9h
.text$mn:0000197C
.text$mn:0000197C loc_197C:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+267j
.text$mn:0000197C                 mov     ecx, [ebp+var_20]
.text$mn:0000197F                 push    ecx
.text$mn:00001980                 mov     ecx, [ebp+this]
.text$mn:00001983                 add     ecx, 70h ; 'p'
.text$mn:00001986                 call    ??A?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAEAAV?$vector@EV?$allocator@E@std@@@1@I@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)
.text$mn:0000198B                 sub     esp, 10h
.text$mn:0000198E                 mov     ecx, esp
.text$mn:00001990                 mov     [ebp+var_54], esp
.text$mn:00001993                 push    eax
.text$mn:00001994                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00001999                 mov     [ebp+var_38], eax
.text$mn:0000199C                 mov     edx, [ebp+var_38]
.text$mn:0000199F                 mov     [ebp+var_58], edx
.text$mn:000019A2                 mov     [ebp+var_4], 2
.text$mn:000019A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019B0                 lea     ecx, [ebp+var_64]
.text$mn:000019B3                 call    ??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z ; ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)
.text$mn:000019B8                 mov     [ebp+var_5C], eax
.text$mn:000019BB                 mov     [ebp+var_4], 3
.text$mn:000019C2                 push    0               ; lpUsedDefaultChar
.text$mn:000019C4                 push    0               ; lpDefaultChar
.text$mn:000019C6                 push    0               ; cbMultiByte
.text$mn:000019C8                 push    0               ; lpMultiByteStr
.text$mn:000019CA                 lea     ecx, [ebp+var_64] ; this
.text$mn:000019CD                 call    ?getLength@ByteArray@@QBEIXZ ; ByteArray::getLength(void)
.text$mn:000019D2                 push    eax             ; cchWideChar
.text$mn:000019D3                 lea     ecx, [ebp+var_64] ; this
.text$mn:000019D6                 call    ?getPointer@ByteArray@@QBEPBEXZ ; ByteArray::getPointer(void)
.text$mn:000019DB                 push    eax             ; lpWideCharStr
.text$mn:000019DC                 push    0               ; dwFlags
.text$mn:000019DE                 mov     eax, [ebp+CodePage]
.text$mn:000019E1                 push    eax             ; CodePage
.text$mn:000019E2                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:000019E8                 mov     [ebp+var_24], eax
.text$mn:000019EB                 mov     ecx, [ebp+var_24]
.text$mn:000019EE                 add     ecx, 1
.text$mn:000019F1                 push    ecx             ; unsigned int
.text$mn:000019F2                 call    ??_U@YAPAXI@Z   ; operator new[](uint)
.text$mn:000019F7                 add     esp, 4
.text$mn:000019FA                 mov     [ebp+var_3C], eax
.text$mn:000019FD                 mov     edx, [ebp+var_3C]
.text$mn:00001A00                 mov     [ebp+lpMultiByteStr], edx
.text$mn:00001A03                 push    0               ; lpUsedDefaultChar
.text$mn:00001A05                 push    0               ; lpDefaultChar
.text$mn:00001A07                 mov     eax, [ebp+var_24]
.text$mn:00001A0A                 add     eax, 1
.text$mn:00001A0D                 push    eax             ; cbMultiByte
.text$mn:00001A0E                 mov     ecx, [ebp+lpMultiByteStr]
.text$mn:00001A11                 push    ecx             ; lpMultiByteStr
.text$mn:00001A12                 lea     ecx, [ebp+var_64] ; this
.text$mn:00001A15                 call    ?getLength@ByteArray@@QBEIXZ ; ByteArray::getLength(void)
.text$mn:00001A1A                 push    eax             ; cchWideChar
.text$mn:00001A1B                 lea     ecx, [ebp+var_64] ; this
.text$mn:00001A1E                 call    ?getPointer@ByteArray@@QBEPBEXZ ; ByteArray::getPointer(void)
.text$mn:00001A23                 push    eax             ; lpWideCharStr
.text$mn:00001A24                 push    0               ; dwFlags
.text$mn:00001A26                 mov     edx, [ebp+CodePage]
.text$mn:00001A29                 push    edx             ; CodePage
.text$mn:00001A2A                 call    dword ptr ds:__imp__WideCharToMultiByte@32 ; WideCharToMultiByte(x,x,x,x,x,x,x,x)
.text$mn:00001A30                 push    offset $SG154964 ; __int32
.text$mn:00001A35                 push    0               ; unsigned int
.text$mn:00001A37                 push    87Ah            ; unsigned int
.text$mn:00001A3C                 mov     eax, [ebp+this]
.text$mn:00001A3F                 mov     ecx, [eax+6Ch]
.text$mn:00001A42                 mov     ecx, [ecx]      ; this
.text$mn:00001A44                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001A49                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:00001A4C                 push    edx             ; __int32
.text$mn:00001A4D                 mov     eax, [ebp+lpMultiByteStr]
.text$mn:00001A50                 push    eax             ; Str
.text$mn:00001A51                 call    _strlen
.text$mn:00001A56                 add     esp, 4
.text$mn:00001A59                 push    eax             ; unsigned int
.text$mn:00001A5A                 push    7D1h            ; unsigned int
.text$mn:00001A5F                 mov     ecx, [ebp+this]
.text$mn:00001A62                 mov     edx, [ecx+6Ch]
.text$mn:00001A65                 mov     ecx, [edx]      ; this
.text$mn:00001A67                 call    ?execute@ScintillaEditView@@QBEJIIJ@Z ; ScintillaEditView::execute(uint,uint,long)
.text$mn:00001A6C                 mov     eax, [ebp+this]
.text$mn:00001A6F                 mov     ecx, [eax+6Ch]
.text$mn:00001A72                 mov     ecx, [ecx]      ; this
.text$mn:00001A74                 call    ?getFocus@Window@@QBEXXZ ; Window::getFocus(void)
.text$mn:00001A79                 mov     edx, [ebp+lpMultiByteStr]
.text$mn:00001A7C                 mov     [ebp+var_40], edx
.text$mn:00001A7F                 mov     eax, [ebp+var_40]
.text$mn:00001A82                 push    eax             ; void *
.text$mn:00001A83                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00001A88                 add     esp, 4
.text$mn:00001A8B                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A92                 lea     ecx, [ebp+var_64] ; this
.text$mn:00001A95                 call    ??1ByteArray@@QAE@XZ ; ByteArray::~ByteArray(void)
.text$mn:00001A9A
.text$mn:00001A9A loc_1A9A:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+1E4j
.text$mn:00001A9A                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+20Cj
.text$mn:00001A9A                 mov     eax, 1
.text$mn:00001A9F                 jmp     loc_1B4C
.text$mn:00001AA4 ; ---------------------------------------------------------------------------
.text$mn:00001AA4
.text$mn:00001AA4 loc_1AA4:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+1CDj
.text$mn:00001AA4                 jmp     loc_1B37
.text$mn:00001AA9 ; ---------------------------------------------------------------------------
.text$mn:00001AA9
.text$mn:00001AA9 loc_1AA9:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+5Fj
.text$mn:00001AA9                 mov     ecx, [ebp+lParam]
.text$mn:00001AAC                 and     ecx, 0FFFFh
.text$mn:00001AB2                 movzx   edx, cx
.text$mn:00001AB5                 mov     [ebp+nWidth], edx
.text$mn:00001AB8                 mov     eax, [ebp+lParam]
.text$mn:00001ABB                 shr     eax, 10h
.text$mn:00001ABE                 and     eax, 0FFFFh
.text$mn:00001AC3                 movzx   ecx, ax
.text$mn:00001AC6                 mov     [ebp+nHeight], ecx
.text$mn:00001AC9                 push    1               ; bRepaint
.text$mn:00001ACB                 mov     edx, [ebp+nHeight]
.text$mn:00001ACE                 push    edx             ; nHeight
.text$mn:00001ACF                 mov     eax, [ebp+nWidth]
.text$mn:00001AD2                 push    eax             ; nWidth
.text$mn:00001AD3                 push    0               ; Y
.text$mn:00001AD5                 push    0               ; X
.text$mn:00001AD7                 push    0AF1h           ; nIDDlgItem
.text$mn:00001ADC                 mov     ecx, [ebp+this]
.text$mn:00001ADF                 mov     edx, [ecx+0Ch]
.text$mn:00001AE2                 push    edx             ; hDlg
.text$mn:00001AE3                 call    dword ptr ds:__imp__GetDlgItem@8 ; GetDlgItem(x,x)
.text$mn:00001AE9                 push    eax             ; hWnd
.text$mn:00001AEA                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00001AF0                 jmp     short loc_1B37
.text$mn:00001AF2 ; ---------------------------------------------------------------------------
.text$mn:00001AF2
.text$mn:00001AF2 loc_1AF2:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+7Fj
.text$mn:00001AF2                 mov     eax, [ebp+this]
.text$mn:00001AF5                 cmp     dword ptr [eax+84h], 0FFFFFFFFh
.text$mn:00001AFC                 jz      short loc_1B10
.text$mn:00001AFE                 mov     ecx, [ebp+this]
.text$mn:00001B01                 mov     edx, [ecx+84h]
.text$mn:00001B07                 push    edx             ; color
.text$mn:00001B08                 call    dword ptr ds:__imp__CreateSolidBrush@4 ; CreateSolidBrush(x)
.text$mn:00001B0E                 jmp     short loc_1B4C
.text$mn:00001B10 ; ---------------------------------------------------------------------------
.text$mn:00001B10
.text$mn:00001B10 loc_1B10:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3F0j
.text$mn:00001B10                 jmp     short loc_1B37
.text$mn:00001B12 ; ---------------------------------------------------------------------------
.text$mn:00001B12
.text$mn:00001B12 loc_1B12:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+4Bj
.text$mn:00001B12                 mov     eax, [ebp+lParam]
.text$mn:00001B15                 push    eax             ; struct tagDRAWITEMSTRUCT *
.text$mn:00001B16                 mov     ecx, [ebp+this] ; this
.text$mn:00001B19                 call    ?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z ; ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)
.text$mn:00001B1E                 jmp     short loc_1B37
.text$mn:00001B20 ; ---------------------------------------------------------------------------
.text$mn:00001B20
.text$mn:00001B20 loc_1B20:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+65j
.text$mn:00001B20                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+73j ...
.text$mn:00001B20                 mov     ecx, [ebp+lParam]
.text$mn:00001B23                 push    ecx             ; __int32
.text$mn:00001B24                 mov     edx, [ebp+wParam]
.text$mn:00001B27                 push    edx             ; unsigned int
.text$mn:00001B28                 mov     eax, [ebp+Msg]
.text$mn:00001B2B                 push    eax             ; unsigned int
.text$mn:00001B2C                 mov     ecx, [ebp+this]
.text$mn:00001B2F                 push    ecx             ; this
.text$mn:00001B30                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:00001B35                 jmp     short loc_1B4C
.text$mn:00001B37 ; ---------------------------------------------------------------------------
.text$mn:00001B37
.text$mn:00001B37 loc_1B37:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+1B0j
.text$mn:00001B37                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long):loc_1AA4j ...
.text$mn:00001B37                 mov     edx, [ebp+lParam]
.text$mn:00001B3A                 push    edx             ; __int32
.text$mn:00001B3B                 mov     eax, [ebp+wParam]
.text$mn:00001B3E                 push    eax             ; unsigned int
.text$mn:00001B3F                 mov     ecx, [ebp+Msg]
.text$mn:00001B42                 push    ecx             ; unsigned int
.text$mn:00001B43                 mov     edx, [ebp+this]
.text$mn:00001B46                 push    edx             ; this
.text$mn:00001B47                 call    ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z ; DockingDlgInterface::run_dlgProc(uint,uint,long)
.text$mn:00001B4C
.text$mn:00001B4C loc_1B4C:                               ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+B7j
.text$mn:00001B4C                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+105j ...
.text$mn:00001B4C                 mov     ecx, [ebp+var_C]
.text$mn:00001B4F                 mov     large fs:0, ecx
.text$mn:00001B56                 pop     ecx
.text$mn:00001B57                 mov     esp, ebp
.text$mn:00001B59                 pop     ebp
.text$mn:00001B5A                 retn    10h
.text$mn:00001B5A ?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z endp
.text$mn:00001B5A
.text$mn:00001B5A ; ---------------------------------------------------------------------------
.text$mn:00001B5D                 align 10h
.text$mn:00001B5D _text$mn        ends
.text$mn:00001B5D
.text$x:00001B60 ; ===========================================================================
.text$x:00001B60
.text$x:00001B60 ; Segment type: Pure code
.text$x:00001B60 ; Segment permissions: Read/Execute
.text$x:00001B60 _text$x         segment para public 'CODE' use32
.text$x:00001B60                 assume cs:_text$x
.text$x:00001B60                 ;org 1B60h
.text$x:00001B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001B60
.text$x:00001B60 ; =============== S U B R O U T I N E =======================================
.text$x:00001B60
.text$x:00001B60
.text$x:00001B60 __unwindfunclet$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z$0 proc near
.text$x:00001B60                                         ; DATA XREF: .xdata$x:000092C0o
.text$x:00001B60                 lea     ecx, [ebp+8]
.text$x:00001B63                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001B63 __unwindfunclet$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z$0 endp
.text$x:00001B63
.text$x:00001B68
.text$x:00001B68 ; =============== S U B R O U T I N E =======================================
.text$x:00001B68
.text$x:00001B68
.text$x:00001B68 __ehhandler$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z proc near
.text$x:00001B68                                         ; DATA XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+5o
.text$x:00001B68
.text$x:00001B68 arg_4           = dword ptr  8
.text$x:00001B68
.text$x:00001B68                 mov     edx, [esp+arg_4]
.text$x:00001B6C                 lea     eax, [edx+0Ch]
.text$x:00001B6F                 mov     ecx, [edx-10h]
.text$x:00001B72                 xor     ecx, eax
.text$x:00001B74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B79                 mov     eax, offset __ehfuncinfo$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z
.text$x:00001B7E                 jmp     ___CxxFrameHandler3
.text$x:00001B7E __ehhandler$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z endp
.text$x:00001B7E
.text$x:00001B83
.text$x:00001B83 ; =============== S U B R O U T I N E =======================================
.text$x:00001B83
.text$x:00001B83
.text$x:00001B83 __unwindfunclet$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z$0 proc near
.text$x:00001B83                                         ; DATA XREF: .xdata$x:000092E8o
.text$x:00001B83                 lea     ecx, [ebp+8]
.text$x:00001B86                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001B86 __unwindfunclet$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z$0 endp
.text$x:00001B86
.text$x:00001B8B
.text$x:00001B8B ; =============== S U B R O U T I N E =======================================
.text$x:00001B8B
.text$x:00001B8B
.text$x:00001B8B __unwindfunclet$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z$1 proc near
.text$x:00001B8B                                         ; DATA XREF: .xdata$x:000092F0o
.text$x:00001B8B                 mov     ecx, [ebp-14h]  ; this
.text$x:00001B8E                 jmp     ??1ByteArray@@QAE@XZ ; ByteArray::~ByteArray(void)
.text$x:00001B8E __unwindfunclet$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z$1 endp
.text$x:00001B8E
.text$x:00001B93
.text$x:00001B93 ; =============== S U B R O U T I N E =======================================
.text$x:00001B93
.text$x:00001B93
.text$x:00001B93 __ehhandler$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z proc near
.text$x:00001B93                                         ; DATA XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+5o
.text$x:00001B93
.text$x:00001B93 arg_4           = dword ptr  8
.text$x:00001B93
.text$x:00001B93                 mov     edx, [esp+arg_4]
.text$x:00001B97                 lea     eax, [edx+0Ch]
.text$x:00001B9A                 mov     ecx, [edx-20h]
.text$x:00001B9D                 xor     ecx, eax
.text$x:00001B9F                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BA4                 mov     eax, offset __ehfuncinfo$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z
.text$x:00001BA9                 jmp     ___CxxFrameHandler3
.text$x:00001BA9 __ehhandler$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z endp
.text$x:00001BA9
.text$x:00001BAE
.text$x:00001BAE ; =============== S U B R O U T I N E =======================================
.text$x:00001BAE
.text$x:00001BAE
.text$x:00001BAE __unwindfunclet$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ$0 proc near
.text$x:00001BAE                                         ; DATA XREF: .xdata$x:000092E0o
.text$x:00001BAE                 lea     ecx, [ebp-4Ch]
.text$x:00001BB1                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001BB1 __unwindfunclet$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ$0 endp
.text$x:00001BB1
.text$x:00001BB6
.text$x:00001BB6 ; =============== S U B R O U T I N E =======================================
.text$x:00001BB6
.text$x:00001BB6
.text$x:00001BB6 __unwindfunclet$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ$1 proc near
.text$x:00001BB6                                         ; DATA XREF: .xdata$x:000092D8o
.text$x:00001BB6                 mov     eax, [ebp-14h]
.text$x:00001BB9                 and     eax, 1
.text$x:00001BBC                 jz      locret_1BCE
.text$x:00001BC2                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00001BC6                 mov     ecx, [ebp+8]
.text$x:00001BC9                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001BCE ; ---------------------------------------------------------------------------
.text$x:00001BCE
.text$x:00001BCE locret_1BCE:                            ; CODE XREF: __unwindfunclet$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ$1+6j
.text$x:00001BCE                 retn
.text$x:00001BCE __unwindfunclet$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ$1 endp
.text$x:00001BCE
.text$x:00001BCF
.text$x:00001BCF ; =============== S U B R O U T I N E =======================================
.text$x:00001BCF
.text$x:00001BCF
.text$x:00001BCF __ehhandler$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ proc near
.text$x:00001BCF                                         ; DATA XREF: ClipboardHistoryPanel::getClipboadData(void)+5o
.text$x:00001BCF
.text$x:00001BCF arg_4           = dword ptr  8
.text$x:00001BCF
.text$x:00001BCF                 mov     edx, [esp+arg_4]
.text$x:00001BD3                 lea     eax, [edx+0Ch]
.text$x:00001BD6                 mov     ecx, [edx-44h]
.text$x:00001BD9                 xor     ecx, eax
.text$x:00001BDB                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BE0                 mov     eax, offset __ehfuncinfo$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ
.text$x:00001BE5                 jmp     ___CxxFrameHandler3
.text$x:00001BE5 __ehhandler$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ endp
.text$x:00001BE5
.text$x:00001BEA
.text$x:00001BEA ; =============== S U B R O U T I N E =======================================
.text$x:00001BEA
.text$x:00001BEA
.text$x:00001BEA __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$0 proc near
.text$x:00001BEA                                         ; DATA XREF: .xdata$x:00009414o
.text$x:00001BEA                 lea     ecx, [ebp+8]
.text$x:00001BED                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001BED __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$0 endp
.text$x:00001BED
.text$x:00001BF2
.text$x:00001BF2 ; =============== S U B R O U T I N E =======================================
.text$x:00001BF2
.text$x:00001BF2
.text$x:00001BF2 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$1 proc near
.text$x:00001BF2                                         ; DATA XREF: .xdata$x:0000941Co
.text$x:00001BF2                 mov     ecx, [ebp-64h]
.text$x:00001BF5                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001BF5 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$1 endp
.text$x:00001BF5
.text$x:00001BFA
.text$x:00001BFA ; =============== S U B R O U T I N E =======================================
.text$x:00001BFA
.text$x:00001BFA
.text$x:00001BFA __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$2 proc near
.text$x:00001BFA                                         ; DATA XREF: .xdata$x:00009424o
.text$x:00001BFA                 lea     ecx, [ebp-90h]
.text$x:00001C00                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00001C00 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$2 endp
.text$x:00001C00
.text$x:00001C05
.text$x:00001C05 ; =============== S U B R O U T I N E =======================================
.text$x:00001C05
.text$x:00001C05
.text$x:00001C05 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$3 proc near
.text$x:00001C05                                         ; DATA XREF: .xdata$x:0000942Co
.text$x:00001C05                 lea     ecx, [ebp-0A8h]
.text$x:00001C0B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00001C0B __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$3 endp
.text$x:00001C0B
.text$x:00001C10
.text$x:00001C10 ; =============== S U B R O U T I N E =======================================
.text$x:00001C10
.text$x:00001C10
.text$x:00001C10 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$4 proc near
.text$x:00001C10                                         ; DATA XREF: .xdata$x:00009434o
.text$x:00001C10                 mov     ecx, [ebp-58h]
.text$x:00001C13                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00001C13 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$4 endp
.text$x:00001C13
.text$x:00001C18
.text$x:00001C18 ; =============== S U B R O U T I N E =======================================
.text$x:00001C18
.text$x:00001C18
.text$x:00001C18 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$6 proc near
.text$x:00001C18                                         ; DATA XREF: .xdata$x:0000943Co
.text$x:00001C18                 lea     ecx, [ebp-0B4h]
.text$x:00001C1E                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00001C1E __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$6 endp
.text$x:00001C1E
.text$x:00001C23
.text$x:00001C23 ; =============== S U B R O U T I N E =======================================
.text$x:00001C23
.text$x:00001C23
.text$x:00001C23 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$7 proc near
.text$x:00001C23                                         ; DATA XREF: .xdata$x:00009444o
.text$x:00001C23                 mov     ecx, [ebp-70h]
.text$x:00001C26                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00001C26 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$7 endp
.text$x:00001C26
.text$x:00001C2B
.text$x:00001C2B ; =============== S U B R O U T I N E =======================================
.text$x:00001C2B
.text$x:00001C2B
.text$x:00001C2B __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$9 proc near
.text$x:00001C2B                                         ; DATA XREF: .xdata$x:0000944Co
.text$x:00001C2B                 mov     ecx, [ebp-74h]
.text$x:00001C2E                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001C2E __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$9 endp
.text$x:00001C2E
.text$x:00001C33
.text$x:00001C33 ; =============== S U B R O U T I N E =======================================
.text$x:00001C33
.text$x:00001C33
.text$x:00001C33 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$10 proc near
.text$x:00001C33                                         ; DATA XREF: .xdata$x:00009454o
.text$x:00001C33                 lea     ecx, [ebp-4Ch]  ; this
.text$x:00001C36                 jmp     ??1StringArray@@QAE@XZ ; StringArray::~StringArray(void)
.text$x:00001C36 __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$10 endp
.text$x:00001C36
.text$x:00001C3B
.text$x:00001C3B ; =============== S U B R O U T I N E =======================================
.text$x:00001C3B
.text$x:00001C3B
.text$x:00001C3B __ehhandler$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z proc near
.text$x:00001C3B                                         ; DATA XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+5o
.text$x:00001C3B
.text$x:00001C3B arg_4           = dword ptr  8
.text$x:00001C3B
.text$x:00001C3B                 mov     edx, [esp+arg_4]
.text$x:00001C3F                 lea     eax, [edx+0Ch]
.text$x:00001C42                 mov     ecx, [edx-0ACh]
.text$x:00001C48                 xor     ecx, eax
.text$x:00001C4A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C4F                 mov     eax, offset __ehfuncinfo$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z
.text$x:00001C54                 jmp     ___CxxFrameHandler3
.text$x:00001C54 __ehhandler$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z endp
.text$x:00001C54
.text$x:00001C59
.text$x:00001C59 ; =============== S U B R O U T I N E =======================================
.text$x:00001C59
.text$x:00001C59
.text$x:00001C59 __unwindfunclet$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z$0 proc near
.text$x:00001C59                                         ; DATA XREF: .xdata$x:000092B8o
.text$x:00001C59                 lea     ecx, [ebp+8]
.text$x:00001C5C                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001C5C __unwindfunclet$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z$0 endp
.text$x:00001C5C
.text$x:00001C61
.text$x:00001C61 ; =============== S U B R O U T I N E =======================================
.text$x:00001C61
.text$x:00001C61
.text$x:00001C61 __ehhandler$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z proc near
.text$x:00001C61                                         ; DATA XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+5o
.text$x:00001C61
.text$x:00001C61 arg_4           = dword ptr  8
.text$x:00001C61
.text$x:00001C61                 mov     edx, [esp+arg_4]
.text$x:00001C65                 lea     eax, [edx+0Ch]
.text$x:00001C68                 mov     ecx, [edx-28h]
.text$x:00001C6B                 xor     ecx, eax
.text$x:00001C6D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C72                 mov     eax, offset __ehfuncinfo$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z
.text$x:00001C77                 jmp     ___CxxFrameHandler3
.text$x:00001C77 __ehhandler$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z endp
.text$x:00001C77
.text$x:00001C7C
.text$x:00001C7C ; =============== S U B R O U T I N E =======================================
.text$x:00001C7C
.text$x:00001C7C
.text$x:00001C7C __unwindfunclet$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z$0 proc near
.text$x:00001C7C                                         ; DATA XREF: .xdata$x:000092C8o
.text$x:00001C7C                 mov     ecx, [ebp-2Ch]
.text$x:00001C7F                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001C7F __unwindfunclet$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z$0 endp
.text$x:00001C7F
.text$x:00001C84
.text$x:00001C84 ; =============== S U B R O U T I N E =======================================
.text$x:00001C84
.text$x:00001C84
.text$x:00001C84 __unwindfunclet$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z$1 proc near
.text$x:00001C84                                         ; DATA XREF: .xdata$x:000092D0o
.text$x:00001C84                 lea     ecx, [ebp-3Ch]  ; this
.text$x:00001C87                 jmp     ??1StringArray@@QAE@XZ ; StringArray::~StringArray(void)
.text$x:00001C87 __unwindfunclet$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z$1 endp
.text$x:00001C87
.text$x:00001C8C
.text$x:00001C8C ; =============== S U B R O U T I N E =======================================
.text$x:00001C8C
.text$x:00001C8C
.text$x:00001C8C __ehhandler$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z proc near
.text$x:00001C8C                                         ; DATA XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+5o
.text$x:00001C8C
.text$x:00001C8C arg_4           = dword ptr  8
.text$x:00001C8C
.text$x:00001C8C                 mov     edx, [esp+arg_4]
.text$x:00001C90                 lea     eax, [edx+0Ch]
.text$x:00001C93                 mov     ecx, [edx-34h]
.text$x:00001C96                 xor     ecx, eax
.text$x:00001C98                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C9D                 mov     eax, offset __ehfuncinfo$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z
.text$x:00001CA2                 jmp     ___CxxFrameHandler3
.text$x:00001CA2 __ehhandler$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z endp
.text$x:00001CA2
.text$x:00001CA7
.text$x:00001CA7 ; =============== S U B R O U T I N E =======================================
.text$x:00001CA7
.text$x:00001CA7
.text$x:00001CA7 __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$0 proc near
.text$x:00001CA7                                         ; DATA XREF: .xdata$x:000092F8o
.text$x:00001CA7                 lea     ecx, [ebp-74h]
.text$x:00001CAA                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001CAA __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$0 endp
.text$x:00001CAA
.text$x:00001CAF
.text$x:00001CAF ; =============== S U B R O U T I N E =======================================
.text$x:00001CAF
.text$x:00001CAF
.text$x:00001CAF __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$1 proc near
.text$x:00001CAF                                         ; DATA XREF: .xdata$x:00009300o
.text$x:00001CAF                 mov     ecx, [ebp-4Ch]
.text$x:00001CB2                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001CB2 __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$1 endp
.text$x:00001CB2
.text$x:00001CB7
.text$x:00001CB7 ; =============== S U B R O U T I N E =======================================
.text$x:00001CB7
.text$x:00001CB7
.text$x:00001CB7 __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$2 proc near
.text$x:00001CB7                                         ; DATA XREF: .xdata$x:00009308o
.text$x:00001CB7                 mov     ecx, [ebp-54h]
.text$x:00001CBA                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:00001CBA __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$2 endp
.text$x:00001CBA
.text$x:00001CBF
.text$x:00001CBF ; =============== S U B R O U T I N E =======================================
.text$x:00001CBF
.text$x:00001CBF
.text$x:00001CBF __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$3 proc near
.text$x:00001CBF                                         ; DATA XREF: .xdata$x:00009310o
.text$x:00001CBF                 lea     ecx, [ebp-64h]  ; this
.text$x:00001CC2                 jmp     ??1ByteArray@@QAE@XZ ; ByteArray::~ByteArray(void)
.text$x:00001CC2 __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$3 endp
.text$x:00001CC2
.text$x:00001CC7
.text$x:00001CC7 ; =============== S U B R O U T I N E =======================================
.text$x:00001CC7
.text$x:00001CC7
.text$x:00001CC7 __ehhandler$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z proc near
.text$x:00001CC7                                         ; DATA XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+5o
.text$x:00001CC7
.text$x:00001CC7 arg_4           = dword ptr  8
.text$x:00001CC7
.text$x:00001CC7                 mov     edx, [esp+arg_4]
.text$x:00001CCB                 lea     eax, [edx+0Ch]
.text$x:00001CCE                 mov     ecx, [edx-6Ch]
.text$x:00001CD1                 xor     ecx, eax
.text$x:00001CD3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CD8                 mov     eax, offset __ehfuncinfo$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z
.text$x:00001CDD                 jmp     ___CxxFrameHandler3
.text$x:00001CDD __ehhandler$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z endp
.text$x:00001CDD
.text$x:00001CDD ; ---------------------------------------------------------------------------
.text$x:00001CE2                 align 4
.text$x:00001CE2 _text$x         ends
.text$x:00001CE2
.text$mn:00001CE4 ; ===========================================================================
.text$mn:00001CE4
.text$mn:00001CE4 ; Segment type: Pure code
.text$mn:00001CE4 ; Segment permissions: Read/Execute
.text$mn:00001CE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CE4                 assume cs:_text$mn
.text$mn:00001CE4                 ;org 1CE4h
.text$mn:00001CE4 ; COMDAT (pick any)
.text$mn:00001CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CE4
.text$mn:00001CE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CE4
.text$mn:00001CE4 ; Attributes: bp-based frame
.text$mn:00001CE4
.text$mn:00001CE4 ; bool __cdecl std::operator==<unsigned char, unsigned char>(class std::allocator<unsigned char> const &, class std::allocator<unsigned char> const &)
.text$mn:00001CE4                 public ??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z
.text$mn:00001CE4 ??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z proc near
.text$mn:00001CE4                                         ; CODE XREF: std::operator==<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)+1Ep
.text$mn:00001CE4                                         ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+43p
.text$mn:00001CE4                 push    ebp
.text$mn:00001CE5                 mov     ebp, esp
.text$mn:00001CE7                 mov     al, 1
.text$mn:00001CE9                 pop     ebp
.text$mn:00001CEA                 retn
.text$mn:00001CEA ??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z endp
.text$mn:00001CEA
.text$mn:00001CEA ; ---------------------------------------------------------------------------
.text$mn:00001CEB                 align 4
.text$mn:00001CEB _text$mn        ends
.text$mn:00001CEB
.text$mn:00001CEC ; ===========================================================================
.text$mn:00001CEC
.text$mn:00001CEC ; Segment type: Pure code
.text$mn:00001CEC ; Segment permissions: Read/Execute
.text$mn:00001CEC _text$mn        segment para public 'CODE' use32
.text$mn:00001CEC                 assume cs:_text$mn
.text$mn:00001CEC                 ;org 1CECh
.text$mn:00001CEC ; COMDAT (pick any)
.text$mn:00001CEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CEC
.text$mn:00001CEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001CEC
.text$mn:00001CEC ; Attributes: bp-based frame
.text$mn:00001CEC
.text$mn:00001CEC ; bool __cdecl std::operator==<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &)
.text$mn:00001CEC                 public ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z
.text$mn:00001CEC ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z proc near
.text$mn:00001CEC                                         ; CODE XREF: std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+Cp
.text$mn:00001CEC
.text$mn:00001CEC arg_0           = dword ptr  8
.text$mn:00001CEC arg_4           = dword ptr  0Ch
.text$mn:00001CEC
.text$mn:00001CEC                 push    ebp
.text$mn:00001CED                 mov     ebp, esp
.text$mn:00001CEF                 mov     eax, [ebp+arg_4]
.text$mn:00001CF2                 push    eax
.text$mn:00001CF3                 mov     ecx, [ebp+arg_0]
.text$mn:00001CF6                 call    ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::_Equal<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00001CFB                 pop     ebp
.text$mn:00001CFC                 retn
.text$mn:00001CFC ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z endp
.text$mn:00001CFC
.text$mn:00001CFC ; ---------------------------------------------------------------------------
.text$mn:00001CFD                 align 10h
.text$mn:00001CFD _text$mn        ends
.text$mn:00001CFD
.text$mn:00001D00 ; ===========================================================================
.text$mn:00001D00
.text$mn:00001D00 ; Segment type: Pure code
.text$mn:00001D00 ; Segment permissions: Read/Execute
.text$mn:00001D00 _text$mn        segment para public 'CODE' use32
.text$mn:00001D00                 assume cs:_text$mn
.text$mn:00001D00                 ;org 1D00h
.text$mn:00001D00 ; COMDAT (pick any)
.text$mn:00001D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D00
.text$mn:00001D00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D00
.text$mn:00001D00 ; Attributes: bp-based frame
.text$mn:00001D00
.text$mn:00001D00 ; bool __cdecl std::operator==<class std::allocator<unsigned char>, class std::allocator<unsigned char>>(struct std::_Wrap_alloc<class std::allocator<unsigned char>> const &, struct std::_Wrap_alloc<class std::allocator<unsigned char>> const &)
.text$mn:00001D00                 public ??$?8V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z
.text$mn:00001D00 ??$?8V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z proc near
.text$mn:00001D00                                         ; CODE XREF: std::operator!=<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)+Cp
.text$mn:00001D00
.text$mn:00001D00 var_2           = byte ptr -2
.text$mn:00001D00 var_1           = byte ptr -1
.text$mn:00001D00 arg_0           = dword ptr  8
.text$mn:00001D00 arg_4           = dword ptr  0Ch
.text$mn:00001D00
.text$mn:00001D00                 push    ebp
.text$mn:00001D01                 mov     ebp, esp
.text$mn:00001D03                 push    ecx
.text$mn:00001D04                 mov     eax, [ebp+arg_4]
.text$mn:00001D07                 push    eax
.text$mn:00001D08                 lea     ecx, [ebp+var_1]
.text$mn:00001D0B                 call    ??0?$allocator@E@std@@QAE@ABV01@@Z ; std::allocator<uchar>::allocator<uchar>(std::allocator<uchar> const &)
.text$mn:00001D10                 push    eax
.text$mn:00001D11                 mov     ecx, [ebp+arg_0]
.text$mn:00001D14                 push    ecx
.text$mn:00001D15                 lea     ecx, [ebp+var_2]
.text$mn:00001D18                 call    ??0?$allocator@E@std@@QAE@ABV01@@Z ; std::allocator<uchar>::allocator<uchar>(std::allocator<uchar> const &)
.text$mn:00001D1D                 push    eax
.text$mn:00001D1E                 call    ??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z ; std::operator==<uchar,uchar>(std::allocator<uchar> const &,std::allocator<uchar> const &)
.text$mn:00001D23                 add     esp, 8
.text$mn:00001D26                 mov     esp, ebp
.text$mn:00001D28                 pop     ebp
.text$mn:00001D29                 retn
.text$mn:00001D29 ??$?8V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z endp
.text$mn:00001D29
.text$mn:00001D29 ; ---------------------------------------------------------------------------
.text$mn:00001D2A                 align 4
.text$mn:00001D2A _text$mn        ends
.text$mn:00001D2A
.text$mn:00001D2C ; ===========================================================================
.text$mn:00001D2C
.text$mn:00001D2C ; Segment type: Pure code
.text$mn:00001D2C ; Segment permissions: Read/Execute
.text$mn:00001D2C _text$mn        segment para public 'CODE' use32
.text$mn:00001D2C                 assume cs:_text$mn
.text$mn:00001D2C                 ;org 1D2Ch
.text$mn:00001D2C ; COMDAT (pick any)
.text$mn:00001D2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D2C
.text$mn:00001D2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001D2C
.text$mn:00001D2C ; Attributes: bp-based frame
.text$mn:00001D2C
.text$mn:00001D2C ; bool __cdecl std::operator!=<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &)
.text$mn:00001D2C                 public ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z
.text$mn:00001D2C ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z proc near
.text$mn:00001D2C                                         ; CODE XREF: std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+31p
.text$mn:00001D2C                                         ; std::_Distance2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int &,std::random_access_iterator_tag)+31p ...
.text$mn:00001D2C
.text$mn:00001D2C var_4           = dword ptr -4
.text$mn:00001D2C arg_0           = dword ptr  8
.text$mn:00001D2C arg_4           = dword ptr  0Ch
.text$mn:00001D2C
.text$mn:00001D2C                 push    ebp
.text$mn:00001D2D                 mov     ebp, esp
.text$mn:00001D2F                 push    ecx
.text$mn:00001D30                 mov     eax, [ebp+arg_4]
.text$mn:00001D33                 push    eax
.text$mn:00001D34                 mov     ecx, [ebp+arg_0]
.text$mn:00001D37                 push    ecx
.text$mn:00001D38                 call    ??$?8V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z ; std::operator==<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00001D3D                 add     esp, 8
.text$mn:00001D40                 movzx   edx, al
.text$mn:00001D43                 test    edx, edx
.text$mn:00001D45                 jnz     short loc_1D50
.text$mn:00001D47                 mov     [ebp+var_4], 1
.text$mn:00001D4E                 jmp     short loc_1D57
.text$mn:00001D50 ; ---------------------------------------------------------------------------
.text$mn:00001D50
.text$mn:00001D50 loc_1D50:                               ; CODE XREF: std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+19j
.text$mn:00001D50                 mov     [ebp+var_4], 0
.text$mn:00001D57
.text$mn:00001D57 loc_1D57:                               ; CODE XREF: std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+22j
.text$mn:00001D57                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001D5A                 mov     esp, ebp
.text$mn:00001D5C                 pop     ebp
.text$mn:00001D5D                 retn
.text$mn:00001D5D ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z endp
.text$mn:00001D5D
.text$mn:00001D5D ; ---------------------------------------------------------------------------
.text$mn:00001D5E                 align 10h
.text$mn:00001D5E _text$mn        ends
.text$mn:00001D5E
.text$mn:00001D60 ; ===========================================================================
.text$mn:00001D60
.text$mn:00001D60 ; Segment type: Pure code
.text$mn:00001D60 ; Segment permissions: Read/Execute
.text$mn:00001D60 _text$mn        segment para public 'CODE' use32
.text$mn:00001D60                 assume cs:_text$mn
.text$mn:00001D60                 ;org 1D60h
.text$mn:00001D60 ; COMDAT (pick any)
.text$mn:00001D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D60
.text$mn:00001D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D60
.text$mn:00001D60 ; Attributes: bp-based frame
.text$mn:00001D60
.text$mn:00001D60 ; bool __cdecl std::operator!=<class std::allocator<unsigned char>, class std::allocator<unsigned char>>(struct std::_Wrap_alloc<class std::allocator<unsigned char>> const &, struct std::_Wrap_alloc<class std::allocator<unsigned char>> const &)
.text$mn:00001D60                 public ??$?9V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z
.text$mn:00001D60 ??$?9V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z proc near
.text$mn:00001D60                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+55p
.text$mn:00001D60
.text$mn:00001D60 var_4           = dword ptr -4
.text$mn:00001D60 arg_0           = dword ptr  8
.text$mn:00001D60 arg_4           = dword ptr  0Ch
.text$mn:00001D60
.text$mn:00001D60                 push    ebp
.text$mn:00001D61                 mov     ebp, esp
.text$mn:00001D63                 push    ecx
.text$mn:00001D64                 mov     eax, [ebp+arg_4]
.text$mn:00001D67                 push    eax
.text$mn:00001D68                 mov     ecx, [ebp+arg_0]
.text$mn:00001D6B                 push    ecx
.text$mn:00001D6C                 call    ??$?8V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z ; std::operator==<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)
.text$mn:00001D71                 add     esp, 8
.text$mn:00001D74                 movzx   edx, al
.text$mn:00001D77                 test    edx, edx
.text$mn:00001D79                 jnz     short loc_1D84
.text$mn:00001D7B                 mov     [ebp+var_4], 1
.text$mn:00001D82                 jmp     short loc_1D8B
.text$mn:00001D84 ; ---------------------------------------------------------------------------
.text$mn:00001D84
.text$mn:00001D84 loc_1D84:                               ; CODE XREF: std::operator!=<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)+19j
.text$mn:00001D84                 mov     [ebp+var_4], 0
.text$mn:00001D8B
.text$mn:00001D8B loc_1D8B:                               ; CODE XREF: std::operator!=<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)+22j
.text$mn:00001D8B                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001D8E                 mov     esp, ebp
.text$mn:00001D90                 pop     ebp
.text$mn:00001D91                 retn
.text$mn:00001D91 ??$?9V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z endp
.text$mn:00001D91
.text$mn:00001D91 ; ---------------------------------------------------------------------------
.text$mn:00001D92                 align 4
.text$mn:00001D92 _text$mn        ends
.text$mn:00001D92
.text$mn:00001D94 ; ===========================================================================
.text$mn:00001D94
.text$mn:00001D94 ; Segment type: Pure code
.text$mn:00001D94 ; Segment permissions: Read/Execute
.text$mn:00001D94 _text$mn        segment para public 'CODE' use32
.text$mn:00001D94                 assume cs:_text$mn
.text$mn:00001D94                 ;org 1D94h
.text$mn:00001D94 ; COMDAT (pick any)
.text$mn:00001D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D94
.text$mn:00001D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D94
.text$mn:00001D94 ; Attributes: bp-based frame
.text$mn:00001D94
.text$mn:00001D94 ; int __cdecl std::operator-<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> &, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &)
.text$mn:00001D94                 public ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z
.text$mn:00001D94 ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z proc near
.text$mn:00001D94                                         ; CODE XREF: std::_Distance2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int &,std::random_access_iterator_tag)+74p
.text$mn:00001D94
.text$mn:00001D94 var_38          = byte ptr -38h
.text$mn:00001D94 var_2C          = byte ptr -2Ch
.text$mn:00001D94 var_20          = dword ptr -20h
.text$mn:00001D94 var_1C          = dword ptr -1Ch
.text$mn:00001D94 var_18          = dword ptr -18h
.text$mn:00001D94 var_14          = dword ptr -14h
.text$mn:00001D94 var_10          = dword ptr -10h
.text$mn:00001D94 var_C           = dword ptr -0Ch
.text$mn:00001D94 var_4           = dword ptr -4
.text$mn:00001D94 arg_0           = dword ptr  8
.text$mn:00001D94 arg_4           = dword ptr  0Ch
.text$mn:00001D94
.text$mn:00001D94                 push    ebp
.text$mn:00001D95                 mov     ebp, esp
.text$mn:00001D97                 push    0FFFFFFFFh
.text$mn:00001D99                 push    offset __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z
.text$mn:00001D9E                 mov     eax, large fs:0
.text$mn:00001DA4                 push    eax
.text$mn:00001DA5                 sub     esp, 2Ch
.text$mn:00001DA8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001DAD                 xor     eax, ebp
.text$mn:00001DAF                 push    eax
.text$mn:00001DB0                 lea     eax, [ebp+var_C]
.text$mn:00001DB3                 mov     large fs:0, eax
.text$mn:00001DB9                 lea     eax, [ebp+var_38]
.text$mn:00001DBC                 push    eax
.text$mn:00001DBD                 mov     ecx, [ebp+arg_4]
.text$mn:00001DC0                 call    ?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::base(void)
.text$mn:00001DC5                 mov     [ebp+var_10], eax
.text$mn:00001DC8                 mov     ecx, [ebp+var_10]
.text$mn:00001DCB                 mov     [ebp+var_14], ecx
.text$mn:00001DCE                 mov     [ebp+var_4], 0
.text$mn:00001DD5                 mov     edx, [ebp+var_14]
.text$mn:00001DD8                 push    edx             ; std::_Iterator_base12 *
.text$mn:00001DD9                 lea     eax, [ebp+var_2C]
.text$mn:00001DDC                 push    eax
.text$mn:00001DDD                 mov     ecx, [ebp+arg_0]
.text$mn:00001DE0                 call    ?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::base(void)
.text$mn:00001DE5                 mov     [ebp+var_18], eax
.text$mn:00001DE8                 mov     ecx, [ebp+var_18]
.text$mn:00001DEB                 mov     [ebp+var_1C], ecx
.text$mn:00001DEE                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001DF2                 mov     ecx, [ebp+var_1C]
.text$mn:00001DF5                 call    ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00001DFA                 mov     [ebp+var_20], eax
.text$mn:00001DFD                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001E01                 lea     ecx, [ebp+var_2C]
.text$mn:00001E04                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00001E09                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001E10                 lea     ecx, [ebp+var_38]
.text$mn:00001E13                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00001E18                 mov     eax, [ebp+var_20]
.text$mn:00001E1B                 mov     ecx, [ebp+var_C]
.text$mn:00001E1E                 mov     large fs:0, ecx
.text$mn:00001E25                 pop     ecx
.text$mn:00001E26                 mov     esp, ebp
.text$mn:00001E28                 pop     ebp
.text$mn:00001E29                 retn
.text$mn:00001E29 ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z endp
.text$mn:00001E29
.text$mn:00001E29 ; ---------------------------------------------------------------------------
.text$mn:00001E2A                 align 4
.text$mn:00001E2A _text$mn        ends
.text$mn:00001E2A
.text$x:00001E2C ; ===========================================================================
.text$x:00001E2C
.text$x:00001E2C ; Segment type: Pure code
.text$x:00001E2C ; Segment permissions: Read/Execute
.text$x:00001E2C _text$x         segment para public 'CODE' use32
.text$x:00001E2C                 assume cs:_text$x
.text$x:00001E2C                 ;org 1E2Ch
.text$x:00001E2C ; COMDAT (pick associative to section at 1D94)
.text$x:00001E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001E2C
.text$x:00001E2C ; =============== S U B R O U T I N E =======================================
.text$x:00001E2C
.text$x:00001E2C
.text$x:00001E2C __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z$0 proc near
.text$x:00001E2C                                         ; DATA XREF: .xdata$x:0000A218o
.text$x:00001E2C                 lea     ecx, [ebp-38h]
.text$x:00001E2F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00001E2F __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z$0 endp
.text$x:00001E2F
.text$x:00001E34
.text$x:00001E34 ; =============== S U B R O U T I N E =======================================
.text$x:00001E34
.text$x:00001E34
.text$x:00001E34 __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z$1 proc near
.text$x:00001E34                                         ; DATA XREF: .xdata$x:0000A220o
.text$x:00001E34                 lea     ecx, [ebp-2Ch]
.text$x:00001E37                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00001E37 __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z$1 endp
.text$x:00001E37
.text$x:00001E3C
.text$x:00001E3C ; =============== S U B R O U T I N E =======================================
.text$x:00001E3C
.text$x:00001E3C
.text$x:00001E3C __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z proc near
.text$x:00001E3C                                         ; DATA XREF: std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+5o
.text$x:00001E3C
.text$x:00001E3C arg_4           = dword ptr  8
.text$x:00001E3C
.text$x:00001E3C                 mov     edx, [esp+arg_4]
.text$x:00001E40                 lea     eax, [edx+0Ch]
.text$x:00001E43                 mov     ecx, [edx-30h]
.text$x:00001E46                 xor     ecx, eax
.text$x:00001E48                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E4D                 mov     eax, offset __ehfuncinfo$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z
.text$x:00001E52                 jmp     ___CxxFrameHandler3
.text$x:00001E52 __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z endp
.text$x:00001E52
.text$x:00001E52 ; ---------------------------------------------------------------------------
.text$x:00001E57                 align 4
.text$x:00001E57 _text$x         ends
.text$x:00001E57
.text$mn:00001E58 ; ===========================================================================
.text$mn:00001E58
.text$mn:00001E58 ; Segment type: Pure code
.text$mn:00001E58 ; Segment permissions: Read/Execute
.text$mn:00001E58 _text$mn        segment para public 'CODE' use32
.text$mn:00001E58                 assume cs:_text$mn
.text$mn:00001E58                 ;org 1E58h
.text$mn:00001E58 ; COMDAT (pick any)
.text$mn:00001E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E58
.text$mn:00001E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E58
.text$mn:00001E58 ; Attributes: bp-based frame
.text$mn:00001E58
.text$mn:00001E58 ; bool __cdecl std::operator<<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &)
.text$mn:00001E58                 public ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z
.text$mn:00001E58 ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z proc near
.text$mn:00001E58                                         ; CODE XREF: std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+70p
.text$mn:00001E58
.text$mn:00001E58 arg_0           = dword ptr  8
.text$mn:00001E58 arg_4           = dword ptr  0Ch
.text$mn:00001E58
.text$mn:00001E58                 push    ebp
.text$mn:00001E59                 mov     ebp, esp
.text$mn:00001E5B                 mov     eax, [ebp+arg_4]
.text$mn:00001E5E                 push    eax
.text$mn:00001E5F                 mov     ecx, [ebp+arg_0]
.text$mn:00001E62                 call    ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::_Less<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00001E67                 pop     ebp
.text$mn:00001E68                 retn
.text$mn:00001E68 ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z endp
.text$mn:00001E68
.text$mn:00001E68 ; ---------------------------------------------------------------------------
.text$mn:00001E69                 align 4
.text$mn:00001E69 _text$mn        ends
.text$mn:00001E69
.text$mn:00001E6C ; ===========================================================================
.text$mn:00001E6C
.text$mn:00001E6C ; Segment type: Pure code
.text$mn:00001E6C ; Segment permissions: Read/Execute
.text$mn:00001E6C _text$mn        segment para public 'CODE' use32
.text$mn:00001E6C                 assume cs:_text$mn
.text$mn:00001E6C                 ;org 1E6Ch
.text$mn:00001E6C ; COMDAT (pick any)
.text$mn:00001E6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E6C
.text$mn:00001E6C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E6C
.text$mn:00001E6C ; Attributes: bp-based frame
.text$mn:00001E6C
.text$mn:00001E6C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001E6C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001E6C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001E6C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001E6C
.text$mn:00001E6C var_4           = dword ptr -4
.text$mn:00001E6C arg_0           = dword ptr  8
.text$mn:00001E6C
.text$mn:00001E6C                 push    ebp
.text$mn:00001E6D                 mov     ebp, esp
.text$mn:00001E6F                 push    ecx
.text$mn:00001E70                 mov     [ebp+var_4], 0
.text$mn:00001E77                 cmp     [ebp+arg_0], 0
.text$mn:00001E7B                 jnz     short loc_1E7F
.text$mn:00001E7D                 jmp     short loc_1E9F
.text$mn:00001E7F ; ---------------------------------------------------------------------------
.text$mn:00001E7F
.text$mn:00001E7F loc_1E7F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00001E7F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001E83                 ja      short loc_1E9A
.text$mn:00001E85                 mov     eax, [ebp+arg_0]
.text$mn:00001E88                 push    eax             ; unsigned int
.text$mn:00001E89                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001E8E                 add     esp, 4
.text$mn:00001E91                 mov     [ebp+var_4], eax
.text$mn:00001E94                 cmp     [ebp+var_4], 0
.text$mn:00001E98                 jnz     short loc_1E9F
.text$mn:00001E9A
.text$mn:00001E9A loc_1E9A:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00001E9A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001E9F
.text$mn:00001E9F loc_1E9F:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00001E9F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00001E9F                 mov     eax, [ebp+var_4]
.text$mn:00001EA2                 mov     esp, ebp
.text$mn:00001EA4                 pop     ebp
.text$mn:00001EA5                 retn
.text$mn:00001EA5 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001EA5
.text$mn:00001EA5 ; ---------------------------------------------------------------------------
.text$mn:00001EA6                 align 4
.text$mn:00001EA6 _text$mn        ends
.text$mn:00001EA6
.text$mn:00001EA8 ; ===========================================================================
.text$mn:00001EA8
.text$mn:00001EA8 ; Segment type: Pure code
.text$mn:00001EA8 ; Segment permissions: Read/Execute
.text$mn:00001EA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA8                 assume cs:_text$mn
.text$mn:00001EA8                 ;org 1EA8h
.text$mn:00001EA8 ; COMDAT (pick any)
.text$mn:00001EA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EA8
.text$mn:00001EA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA8
.text$mn:00001EA8 ; Attributes: bp-based frame
.text$mn:00001EA8
.text$mn:00001EA8 ; unsigned char * __cdecl std::_Allocate<unsigned char>(unsigned int, unsigned char *)
.text$mn:00001EA8                 public ??$_Allocate@E@std@@YAPAEIPAE@Z
.text$mn:00001EA8 ??$_Allocate@E@std@@YAPAEIPAE@Z proc near
.text$mn:00001EA8                                         ; CODE XREF: std::allocator<uchar>::allocate(uint)+Dp
.text$mn:00001EA8
.text$mn:00001EA8 var_4           = dword ptr -4
.text$mn:00001EA8 arg_0           = dword ptr  8
.text$mn:00001EA8
.text$mn:00001EA8                 push    ebp
.text$mn:00001EA9                 mov     ebp, esp
.text$mn:00001EAB                 push    ecx
.text$mn:00001EAC                 mov     [ebp+var_4], 0
.text$mn:00001EB3                 cmp     [ebp+arg_0], 0
.text$mn:00001EB7                 jnz     short loc_1EBB
.text$mn:00001EB9                 jmp     short loc_1EDB
.text$mn:00001EBB ; ---------------------------------------------------------------------------
.text$mn:00001EBB
.text$mn:00001EBB loc_1EBB:                               ; CODE XREF: std::_Allocate<uchar>(uint,uchar *)+Fj
.text$mn:00001EBB                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001EBF                 ja      short loc_1ED6
.text$mn:00001EC1                 mov     eax, [ebp+arg_0]
.text$mn:00001EC4                 push    eax             ; unsigned int
.text$mn:00001EC5                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001ECA                 add     esp, 4
.text$mn:00001ECD                 mov     [ebp+var_4], eax
.text$mn:00001ED0                 cmp     [ebp+var_4], 0
.text$mn:00001ED4                 jnz     short loc_1EDB
.text$mn:00001ED6
.text$mn:00001ED6 loc_1ED6:                               ; CODE XREF: std::_Allocate<uchar>(uint,uchar *)+17j
.text$mn:00001ED6                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001EDB
.text$mn:00001EDB loc_1EDB:                               ; CODE XREF: std::_Allocate<uchar>(uint,uchar *)+11j
.text$mn:00001EDB                                         ; std::_Allocate<uchar>(uint,uchar *)+2Cj
.text$mn:00001EDB                 mov     eax, [ebp+var_4]
.text$mn:00001EDE                 mov     esp, ebp
.text$mn:00001EE0                 pop     ebp
.text$mn:00001EE1                 retn
.text$mn:00001EE1 ??$_Allocate@E@std@@YAPAEIPAE@Z endp
.text$mn:00001EE1
.text$mn:00001EE1 ; ---------------------------------------------------------------------------
.text$mn:00001EE2                 align 4
.text$mn:00001EE2 _text$mn        ends
.text$mn:00001EE2
.text$mn:00001EE4 ; ===========================================================================
.text$mn:00001EE4
.text$mn:00001EE4 ; Segment type: Pure code
.text$mn:00001EE4 ; Segment permissions: Read/Execute
.text$mn:00001EE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001EE4                 assume cs:_text$mn
.text$mn:00001EE4                 ;org 1EE4h
.text$mn:00001EE4 ; COMDAT (pick any)
.text$mn:00001EE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EE4
.text$mn:00001EE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EE4
.text$mn:00001EE4 ; Attributes: bp-based frame
.text$mn:00001EE4
.text$mn:00001EE4 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001EE4                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001EE4 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001EE4                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001EE4
.text$mn:00001EE4 var_4           = dword ptr -4
.text$mn:00001EE4 arg_0           = dword ptr  8
.text$mn:00001EE4
.text$mn:00001EE4                 push    ebp
.text$mn:00001EE5                 mov     ebp, esp
.text$mn:00001EE7                 push    ecx
.text$mn:00001EE8                 mov     [ebp+var_4], 0
.text$mn:00001EEF                 cmp     [ebp+arg_0], 0
.text$mn:00001EF3                 jnz     short loc_1EF7
.text$mn:00001EF5                 jmp     short loc_1F1D
.text$mn:00001EF7 ; ---------------------------------------------------------------------------
.text$mn:00001EF7
.text$mn:00001EF7 loc_1EF7:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00001EF7                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00001EFE                 ja      short loc_1F18
.text$mn:00001F00                 mov     eax, [ebp+arg_0]
.text$mn:00001F03                 shl     eax, 3
.text$mn:00001F06                 push    eax             ; unsigned int
.text$mn:00001F07                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001F0C                 add     esp, 4
.text$mn:00001F0F                 mov     [ebp+var_4], eax
.text$mn:00001F12                 cmp     [ebp+var_4], 0
.text$mn:00001F16                 jnz     short loc_1F1D
.text$mn:00001F18
.text$mn:00001F18 loc_1F18:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001F18                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001F1D
.text$mn:00001F1D loc_1F1D:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001F1D                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001F1D                 mov     eax, [ebp+var_4]
.text$mn:00001F20                 mov     esp, ebp
.text$mn:00001F22                 pop     ebp
.text$mn:00001F23                 retn
.text$mn:00001F23 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00001F23
.text$mn:00001F23 _text$mn        ends
.text$mn:00001F23
.text$mn:00001F24 ; ===========================================================================
.text$mn:00001F24
.text$mn:00001F24 ; Segment type: Pure code
.text$mn:00001F24 ; Segment permissions: Read/Execute
.text$mn:00001F24 _text$mn        segment para public 'CODE' use32
.text$mn:00001F24                 assume cs:_text$mn
.text$mn:00001F24                 ;org 1F24h
.text$mn:00001F24 ; COMDAT (pick any)
.text$mn:00001F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F24
.text$mn:00001F24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F24
.text$mn:00001F24 ; Attributes: bp-based frame
.text$mn:00001F24
.text$mn:00001F24 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Allocate<class std::vector<unsigned char, class std::allocator<unsigned char>>>(unsigned int, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00001F24                 public ??$_Allocate@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@IPAV10@@Z
.text$mn:00001F24 ??$_Allocate@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@IPAV10@@Z proc near
.text$mn:00001F24                                         ; CODE XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::allocate(uint)+Dp
.text$mn:00001F24
.text$mn:00001F24 var_4           = dword ptr -4
.text$mn:00001F24 arg_0           = dword ptr  8
.text$mn:00001F24
.text$mn:00001F24                 push    ebp
.text$mn:00001F25                 mov     ebp, esp
.text$mn:00001F27                 push    ecx
.text$mn:00001F28                 mov     [ebp+var_4], 0
.text$mn:00001F2F                 cmp     [ebp+arg_0], 0
.text$mn:00001F33                 jnz     short loc_1F37
.text$mn:00001F35                 jmp     short loc_1F5D
.text$mn:00001F37 ; ---------------------------------------------------------------------------
.text$mn:00001F37
.text$mn:00001F37 loc_1F37:                               ; CODE XREF: std::_Allocate<std::vector<uchar,std::allocator<uchar>>>(uint,std::vector<uchar,std::allocator<uchar>> *)+Fj
.text$mn:00001F37                 cmp     [ebp+arg_0], 0FFFFFFFh
.text$mn:00001F3E                 ja      short loc_1F58
.text$mn:00001F40                 mov     eax, [ebp+arg_0]
.text$mn:00001F43                 shl     eax, 4
.text$mn:00001F46                 push    eax             ; unsigned int
.text$mn:00001F47                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001F4C                 add     esp, 4
.text$mn:00001F4F                 mov     [ebp+var_4], eax
.text$mn:00001F52                 cmp     [ebp+var_4], 0
.text$mn:00001F56                 jnz     short loc_1F5D
.text$mn:00001F58
.text$mn:00001F58 loc_1F58:                               ; CODE XREF: std::_Allocate<std::vector<uchar,std::allocator<uchar>>>(uint,std::vector<uchar,std::allocator<uchar>> *)+1Aj
.text$mn:00001F58                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001F5D
.text$mn:00001F5D loc_1F5D:                               ; CODE XREF: std::_Allocate<std::vector<uchar,std::allocator<uchar>>>(uint,std::vector<uchar,std::allocator<uchar>> *)+11j
.text$mn:00001F5D                                         ; std::_Allocate<std::vector<uchar,std::allocator<uchar>>>(uint,std::vector<uchar,std::allocator<uchar>> *)+32j
.text$mn:00001F5D                 mov     eax, [ebp+var_4]
.text$mn:00001F60                 mov     esp, ebp
.text$mn:00001F62                 pop     ebp
.text$mn:00001F63                 retn
.text$mn:00001F63 ??$_Allocate@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@IPAV10@@Z endp
.text$mn:00001F63
.text$mn:00001F63 _text$mn        ends
.text$mn:00001F63
.text$mn:00001F64 ; ===========================================================================
.text$mn:00001F64
.text$mn:00001F64 ; Segment type: Pure code
.text$mn:00001F64 ; Segment permissions: Read/Execute
.text$mn:00001F64 _text$mn        segment para public 'CODE' use32
.text$mn:00001F64                 assume cs:_text$mn
.text$mn:00001F64                 ;org 1F64h
.text$mn:00001F64 ; COMDAT (pick any)
.text$mn:00001F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F64
.text$mn:00001F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F64
.text$mn:00001F64 ; Attributes: bp-based frame
.text$mn:00001F64
.text$mn:00001F64 ; public: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Construct<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>)
.text$mn:00001F64                 public ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z
.text$mn:00001F64 ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z proc near
.text$mn:00001F64                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+109p
.text$mn:00001F64
.text$mn:00001F64 var_2C          = dword ptr -2Ch
.text$mn:00001F64 var_28          = dword ptr -28h
.text$mn:00001F64 var_24          = dword ptr -24h
.text$mn:00001F64 var_20          = dword ptr -20h
.text$mn:00001F64 var_1C          = dword ptr -1Ch
.text$mn:00001F64 var_18          = dword ptr -18h
.text$mn:00001F64 var_14          = dword ptr -14h
.text$mn:00001F64 var_E           = byte ptr -0Eh
.text$mn:00001F64 var_D           = byte ptr -0Dh
.text$mn:00001F64 var_C           = dword ptr -0Ch
.text$mn:00001F64 var_4           = dword ptr -4
.text$mn:00001F64 arg_0           = byte ptr  8
.text$mn:00001F64 arg_C           = byte ptr  14h
.text$mn:00001F64
.text$mn:00001F64                 push    ebp
.text$mn:00001F65                 mov     ebp, esp
.text$mn:00001F67                 push    0FFFFFFFFh
.text$mn:00001F69                 push    offset __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z
.text$mn:00001F6E                 mov     eax, large fs:0
.text$mn:00001F74                 push    eax
.text$mn:00001F75                 sub     esp, 20h
.text$mn:00001F78                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001F7D                 xor     eax, ebp
.text$mn:00001F7F                 push    eax
.text$mn:00001F80                 lea     eax, [ebp+var_C]
.text$mn:00001F83                 mov     large fs:0, eax
.text$mn:00001F89                 mov     [ebp+var_1C], ecx
.text$mn:00001F8C                 mov     [ebp+var_4], 1
.text$mn:00001F93                 lea     eax, [ebp+arg_0]
.text$mn:00001F96                 push    eax
.text$mn:00001F97                 lea     ecx, [ebp+var_E]
.text$mn:00001F9A                 push    ecx
.text$mn:00001F9B                 call    ??$_Iter_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00001FA0                 add     esp, 8
.text$mn:00001FA3                 mov     dl, [eax]
.text$mn:00001FA5                 mov     [ebp+var_D], dl
.text$mn:00001FA8                 movzx   eax, [ebp+var_D]
.text$mn:00001FAC                 push    eax
.text$mn:00001FAD                 sub     esp, 0Ch
.text$mn:00001FB0                 mov     ecx, esp
.text$mn:00001FB2                 mov     [ebp+var_20], esp
.text$mn:00001FB5                 lea     edx, [ebp+arg_C]
.text$mn:00001FB8                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00001FB9                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00001FBE                 mov     [ebp+var_14], eax
.text$mn:00001FC1                 mov     eax, [ebp+var_14]
.text$mn:00001FC4                 mov     [ebp+var_24], eax
.text$mn:00001FC7                 mov     byte ptr [ebp+var_4], 2
.text$mn:00001FCB                 sub     esp, 0Ch
.text$mn:00001FCE                 mov     ecx, esp
.text$mn:00001FD0                 mov     [ebp+var_28], esp
.text$mn:00001FD3                 lea     edx, [ebp+arg_0]
.text$mn:00001FD6                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00001FD7                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00001FDC                 mov     [ebp+var_18], eax
.text$mn:00001FDF                 mov     eax, [ebp+var_18]
.text$mn:00001FE2                 mov     [ebp+var_2C], eax
.text$mn:00001FE5                 mov     byte ptr [ebp+var_4], 3
.text$mn:00001FE9                 mov     byte ptr [ebp+var_4], 1
.text$mn:00001FED                 mov     ecx, [ebp+var_1C]
.text$mn:00001FF0                 call    ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)
.text$mn:00001FF5                 mov     byte ptr [ebp+var_4], 0
.text$mn:00001FF9                 lea     ecx, [ebp+arg_0]
.text$mn:00001FFC                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002001                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002008                 lea     ecx, [ebp+arg_C]
.text$mn:0000200B                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002010                 mov     ecx, [ebp+var_C]
.text$mn:00002013                 mov     large fs:0, ecx
.text$mn:0000201A                 pop     ecx
.text$mn:0000201B                 mov     esp, ebp
.text$mn:0000201D                 pop     ebp
.text$mn:0000201E                 retn    18h
.text$mn:0000201E ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z endp
.text$mn:0000201E
.text$mn:0000201E ; ---------------------------------------------------------------------------
.text$mn:00002021                 align 4
.text$mn:00002021 _text$mn        ends
.text$mn:00002021
.text$x:00002024 ; ===========================================================================
.text$x:00002024
.text$x:00002024 ; Segment type: Pure code
.text$x:00002024 ; Segment permissions: Read/Execute
.text$x:00002024 _text$x         segment para public 'CODE' use32
.text$x:00002024                 assume cs:_text$x
.text$x:00002024                 ;org 2024h
.text$x:00002024 ; COMDAT (pick associative to section at 1F64)
.text$x:00002024                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002024
.text$x:00002024 ; =============== S U B R O U T I N E =======================================
.text$x:00002024
.text$x:00002024
.text$x:00002024 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$0 proc near
.text$x:00002024                                         ; DATA XREF: .xdata$x:00009FB8o
.text$x:00002024                 lea     ecx, [ebp+14h]
.text$x:00002027                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002027 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$0 endp
.text$x:00002027
.text$x:0000202C
.text$x:0000202C ; =============== S U B R O U T I N E =======================================
.text$x:0000202C
.text$x:0000202C
.text$x:0000202C __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$1 proc near
.text$x:0000202C                                         ; DATA XREF: .xdata$x:00009FC0o
.text$x:0000202C                 lea     ecx, [ebp+8]
.text$x:0000202F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000202F __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$1 endp
.text$x:0000202F
.text$x:00002034
.text$x:00002034 ; =============== S U B R O U T I N E =======================================
.text$x:00002034
.text$x:00002034
.text$x:00002034 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$2 proc near
.text$x:00002034                                         ; DATA XREF: .xdata$x:00009FC8o
.text$x:00002034                 mov     ecx, [ebp-20h]
.text$x:00002037                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002037 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$2 endp
.text$x:00002037
.text$x:0000203C
.text$x:0000203C ; =============== S U B R O U T I N E =======================================
.text$x:0000203C
.text$x:0000203C
.text$x:0000203C __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$3 proc near
.text$x:0000203C                                         ; DATA XREF: .xdata$x:00009FD0o
.text$x:0000203C                 mov     ecx, [ebp-28h]
.text$x:0000203F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000203F __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$3 endp
.text$x:0000203F
.text$x:00002044
.text$x:00002044 ; =============== S U B R O U T I N E =======================================
.text$x:00002044
.text$x:00002044
.text$x:00002044 __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z proc near
.text$x:00002044                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+5o
.text$x:00002044
.text$x:00002044 arg_4           = dword ptr  8
.text$x:00002044
.text$x:00002044                 mov     edx, [esp+arg_4]
.text$x:00002048                 lea     eax, [edx+0Ch]
.text$x:0000204B                 mov     ecx, [edx-24h]
.text$x:0000204E                 xor     ecx, eax
.text$x:00002050                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002055                 mov     eax, offset __ehfuncinfo$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z
.text$x:0000205A                 jmp     ___CxxFrameHandler3
.text$x:0000205A __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z endp
.text$x:0000205A
.text$x:0000205A ; ---------------------------------------------------------------------------
.text$x:0000205F                 align 10h
.text$x:0000205F _text$x         ends
.text$x:0000205F
.text$mn:00002060 ; ===========================================================================
.text$mn:00002060
.text$mn:00002060 ; Segment type: Pure code
.text$mn:00002060 ; Segment permissions: Read/Execute
.text$mn:00002060 _text$mn        segment para public 'CODE' use32
.text$mn:00002060                 assume cs:_text$mn
.text$mn:00002060                 ;org 2060h
.text$mn:00002060 ; COMDAT (pick any)
.text$mn:00002060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002060
.text$mn:00002060 ; =============== S U B R O U T I N E =======================================
.text$mn:00002060
.text$mn:00002060 ; Attributes: bp-based frame
.text$mn:00002060
.text$mn:00002060 ; public: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Construct<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, struct std::forward_iterator_tag)
.text$mn:00002060                 public ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00002060 ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z proc near
.text$mn:00002060                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+8Cp
.text$mn:00002060
.text$mn:00002060 var_4C          = dword ptr -4Ch
.text$mn:00002060 var_48          = dword ptr -48h
.text$mn:00002060 var_44          = dword ptr -44h
.text$mn:00002060 var_40          = dword ptr -40h
.text$mn:00002060 var_3C          = dword ptr -3Ch
.text$mn:00002060 var_38          = dword ptr -38h
.text$mn:00002060 var_34          = dword ptr -34h
.text$mn:00002060 var_30          = dword ptr -30h
.text$mn:00002060 var_2C          = dword ptr -2Ch
.text$mn:00002060 var_28          = dword ptr -28h
.text$mn:00002060 var_24          = dword ptr -24h
.text$mn:00002060 var_20          = dword ptr -20h
.text$mn:00002060 var_1C          = dword ptr -1Ch
.text$mn:00002060 var_18          = dword ptr -18h
.text$mn:00002060 var_14          = dword ptr -14h
.text$mn:00002060 var_10          = dword ptr -10h
.text$mn:00002060 var_C           = dword ptr -0Ch
.text$mn:00002060 var_4           = dword ptr -4
.text$mn:00002060 arg_0           = byte ptr  8
.text$mn:00002060 arg_C           = byte ptr  14h
.text$mn:00002060
.text$mn:00002060 ; FUNCTION CHUNK AT .text$mn:00002170 SIZE 00000009 BYTES
.text$mn:00002060 ; FUNCTION CHUNK AT .text$mn:00002180 SIZE 0000002F BYTES
.text$mn:00002060
.text$mn:00002060                 push    ebp
.text$mn:00002061                 mov     ebp, esp
.text$mn:00002063                 push    0FFFFFFFFh
.text$mn:00002065                 push    offset __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:0000206A                 mov     eax, large fs:0
.text$mn:00002070                 push    eax
.text$mn:00002071                 push    ecx
.text$mn:00002072                 sub     esp, 3Ch
.text$mn:00002075                 push    ebx
.text$mn:00002076                 push    esi
.text$mn:00002077                 push    edi
.text$mn:00002078                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000207D                 xor     eax, ebp
.text$mn:0000207F                 push    eax
.text$mn:00002080                 lea     eax, [ebp+var_C]
.text$mn:00002083                 mov     large fs:0, eax
.text$mn:00002089                 mov     [ebp+var_10], esp
.text$mn:0000208C                 mov     [ebp+var_14], ecx
.text$mn:0000208F                 mov     [ebp+var_4], 1
.text$mn:00002096                 sub     esp, 0Ch
.text$mn:00002099                 mov     ecx, esp
.text$mn:0000209B                 mov     [ebp+var_30], esp
.text$mn:0000209E                 lea     eax, [ebp+arg_C]
.text$mn:000020A1                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000020A2                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:000020A7                 mov     [ebp+var_18], eax
.text$mn:000020AA                 mov     ecx, [ebp+var_18]
.text$mn:000020AD                 mov     [ebp+var_34], ecx
.text$mn:000020B0                 mov     byte ptr [ebp+var_4], 2
.text$mn:000020B4                 sub     esp, 0Ch
.text$mn:000020B7                 mov     ecx, esp
.text$mn:000020B9                 mov     [ebp+var_38], esp
.text$mn:000020BC                 lea     edx, [ebp+arg_0]
.text$mn:000020BF                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000020C0                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:000020C5                 mov     [ebp+var_1C], eax
.text$mn:000020C8                 mov     eax, [ebp+var_1C]
.text$mn:000020CB                 mov     [ebp+var_3C], eax
.text$mn:000020CE                 mov     byte ptr [ebp+var_4], 3
.text$mn:000020D2                 mov     byte ptr [ebp+var_4], 1
.text$mn:000020D6                 call    ??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z ; std::distance<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)
.text$mn:000020DB                 add     esp, 18h
.text$mn:000020DE                 mov     [ebp+var_20], eax
.text$mn:000020E1                 mov     ecx, [ebp+var_20]
.text$mn:000020E4                 push    ecx
.text$mn:000020E5                 mov     ecx, [ebp+var_14]
.text$mn:000020E8                 call    ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<uchar,std::allocator<uchar>>::_Buy(uint)
.text$mn:000020ED                 movzx   edx, al
.text$mn:000020F0                 test    edx, edx
.text$mn:000020F2                 jz      loc_2180
.text$mn:000020F8                 mov     byte ptr [ebp+var_4], 4
.text$mn:000020FC                 mov     eax, [ebp+var_14]
.text$mn:000020FF                 mov     ecx, [eax+4]
.text$mn:00002102                 push    ecx
.text$mn:00002103                 sub     esp, 0Ch
.text$mn:00002106                 mov     ecx, esp
.text$mn:00002108                 mov     [ebp+var_40], esp
.text$mn:0000210B                 lea     edx, [ebp+arg_C]
.text$mn:0000210E                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000210F                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002114                 mov     [ebp+var_24], eax
.text$mn:00002117                 mov     eax, [ebp+var_24]
.text$mn:0000211A                 mov     [ebp+var_44], eax
.text$mn:0000211D                 mov     byte ptr [ebp+var_4], 5
.text$mn:00002121                 sub     esp, 0Ch
.text$mn:00002124                 mov     ecx, esp
.text$mn:00002126                 mov     [ebp+var_48], esp
.text$mn:00002129                 lea     edx, [ebp+arg_0]
.text$mn:0000212C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000212D                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002132                 mov     [ebp+var_28], eax
.text$mn:00002135                 mov     eax, [ebp+var_28]
.text$mn:00002138                 mov     [ebp+var_4C], eax
.text$mn:0000213B                 mov     byte ptr [ebp+var_4], 6
.text$mn:0000213F                 mov     byte ptr [ebp+var_4], 4
.text$mn:00002143                 mov     ecx, [ebp+var_14]
.text$mn:00002146                 call    ??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z ; std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *)
.text$mn:0000214B                 mov     [ebp+var_2C], eax
.text$mn:0000214E                 mov     ecx, [ebp+var_14]
.text$mn:00002151                 mov     edx, [ebp+var_2C]
.text$mn:00002154                 mov     [ecx+8], edx
.text$mn:00002157                 jmp     short loc_2170
.text$mn:00002157 ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z endp
.text$mn:00002157
.text$mn:00002159
.text$mn:00002159 ; =============== S U B R O U T I N E =======================================
.text$mn:00002159
.text$mn:00002159 ; Attributes: noreturn
.text$mn:00002159
.text$mn:00002159 __catch$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0 proc near
.text$mn:00002159                                         ; DATA XREF: .xdata$x:0000A05Co
.text$mn:00002159                 mov     ecx, [ebp-14h]
.text$mn:0000215C                 call    ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Tidy(void)
.text$mn:00002161                 push    0
.text$mn:00002163                 push    0
.text$mn:00002165                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002165 __catch$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0 endp
.text$mn:00002165
.text$mn:0000216A ; ---------------------------------------------------------------------------
.text$mn:0000216A                 mov     eax, offset $LN14
.text$mn:0000216F                 retn
.text$mn:00002170 ; ---------------------------------------------------------------------------
.text$mn:00002170 ; START OF FUNCTION CHUNK FOR ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00002170
.text$mn:00002170 loc_2170:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)+F7j
.text$mn:00002170                 mov     [ebp+var_4], 1
.text$mn:00002177                 jmp     short loc_2180
.text$mn:00002177 ; END OF FUNCTION CHUNK FOR ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00002179
.text$mn:00002179 ; =============== S U B R O U T I N E =======================================
.text$mn:00002179
.text$mn:00002179
.text$mn:00002179 $LN14           proc near               ; DATA XREF: .text$mn:0000216Ao
.text$mn:00002179                 mov     dword ptr [ebp-4], 1
.text$mn:00002179 $LN14           endp ; sp-analysis failed
.text$mn:00002179
.text$mn:00002180 ; START OF FUNCTION CHUNK FOR ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:00002180
.text$mn:00002180 loc_2180:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)+92j
.text$mn:00002180                                         ; std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)+117j
.text$mn:00002180                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002184                 lea     ecx, [ebp+arg_0]
.text$mn:00002187                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:0000218C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002193                 lea     ecx, [ebp+arg_C]
.text$mn:00002196                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:0000219B                 mov     ecx, [ebp+var_C]
.text$mn:0000219E                 mov     large fs:0, ecx
.text$mn:000021A5                 pop     ecx
.text$mn:000021A6                 pop     edi
.text$mn:000021A7                 pop     esi
.text$mn:000021A8                 pop     ebx
.text$mn:000021A9                 mov     esp, ebp
.text$mn:000021AB                 pop     ebp
.text$mn:000021AC                 retn    1Ch
.text$mn:000021AC ; END OF FUNCTION CHUNK FOR ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$mn:000021AC ; ---------------------------------------------------------------------------
.text$mn:000021AF                 align 10h
.text$mn:000021AF _text$mn        ends
.text$mn:000021AF
.text$x:000021B0 ; ===========================================================================
.text$x:000021B0
.text$x:000021B0 ; Segment type: Pure code
.text$x:000021B0 ; Segment permissions: Read/Execute
.text$x:000021B0 _text$x         segment para public 'CODE' use32
.text$x:000021B0                 assume cs:_text$x
.text$x:000021B0                 ;org 21B0h
.text$x:000021B0 ; COMDAT (pick associative to section at 2060)
.text$x:000021B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000021B0
.text$x:000021B0 ; =============== S U B R O U T I N E =======================================
.text$x:000021B0
.text$x:000021B0
.text$x:000021B0 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2 proc near
.text$x:000021B0                                         ; DATA XREF: .xdata$x:0000A09Co
.text$x:000021B0                 lea     ecx, [ebp+14h]
.text$x:000021B3                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000021B3 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2 endp
.text$x:000021B3
.text$x:000021B8
.text$x:000021B8 ; =============== S U B R O U T I N E =======================================
.text$x:000021B8
.text$x:000021B8
.text$x:000021B8 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3 proc near
.text$x:000021B8                                         ; DATA XREF: .xdata$x:0000A0A4o
.text$x:000021B8                 lea     ecx, [ebp+8]
.text$x:000021BB                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000021BB __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3 endp
.text$x:000021BB
.text$x:000021C0
.text$x:000021C0 ; =============== S U B R O U T I N E =======================================
.text$x:000021C0
.text$x:000021C0
.text$x:000021C0 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4 proc near
.text$x:000021C0                                         ; DATA XREF: .xdata$x:0000A0ACo
.text$x:000021C0                 mov     ecx, [ebp-30h]
.text$x:000021C3                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000021C3 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4 endp
.text$x:000021C3
.text$x:000021C8
.text$x:000021C8 ; =============== S U B R O U T I N E =======================================
.text$x:000021C8
.text$x:000021C8
.text$x:000021C8 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5 proc near
.text$x:000021C8                                         ; DATA XREF: .xdata$x:0000A0B4o
.text$x:000021C8                 mov     ecx, [ebp-38h]
.text$x:000021CB                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000021CB __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5 endp
.text$x:000021CB
.text$x:000021D0
.text$x:000021D0 ; =============== S U B R O U T I N E =======================================
.text$x:000021D0
.text$x:000021D0
.text$x:000021D0 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6 proc near
.text$x:000021D0                                         ; DATA XREF: .xdata$x:0000A0C4o
.text$x:000021D0                 mov     ecx, [ebp-40h]
.text$x:000021D3                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000021D3 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6 endp
.text$x:000021D3
.text$x:000021D8
.text$x:000021D8 ; =============== S U B R O U T I N E =======================================
.text$x:000021D8
.text$x:000021D8
.text$x:000021D8 __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7 proc near
.text$x:000021D8                                         ; DATA XREF: .xdata$x:0000A0CCo
.text$x:000021D8                 mov     ecx, [ebp-48h]
.text$x:000021DB                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000021DB __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7 endp
.text$x:000021DB
.text$x:000021E0
.text$x:000021E0 ; =============== S U B R O U T I N E =======================================
.text$x:000021E0
.text$x:000021E0
.text$x:000021E0 __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z proc near
.text$x:000021E0                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)+5o
.text$x:000021E0
.text$x:000021E0 arg_4           = dword ptr  8
.text$x:000021E0
.text$x:000021E0                 mov     edx, [esp+arg_4]
.text$x:000021E4                 lea     eax, [edx+0Ch]
.text$x:000021E7                 mov     ecx, [edx-50h]
.text$x:000021EA                 xor     ecx, eax
.text$x:000021EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000021F1                 mov     eax, offset __ehfuncinfo$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.text$x:000021F6                 jmp     ___CxxFrameHandler3
.text$x:000021F6 __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z endp
.text$x:000021F6
.text$x:000021F6 ; ---------------------------------------------------------------------------
.text$x:000021FB                 align 4
.text$x:000021FB _text$x         ends
.text$x:000021FB
.text$mn:000021FC ; ===========================================================================
.text$mn:000021FC
.text$mn:000021FC ; Segment type: Pure code
.text$mn:000021FC ; Segment permissions: Read/Execute
.text$mn:000021FC _text$mn        segment para public 'CODE' use32
.text$mn:000021FC                 assume cs:_text$mn
.text$mn:000021FC                 ;org 21FCh
.text$mn:000021FC ; COMDAT (pick any)
.text$mn:000021FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021FC
.text$mn:000021FC ; =============== S U B R O U T I N E =======================================
.text$mn:000021FC
.text$mn:000021FC ; Attributes: bp-based frame
.text$mn:000021FC
.text$mn:000021FC ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Copy_backward<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:000021FC                 public ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z
.text$mn:000021FC ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z proc near
.text$mn:000021FC                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+3F5p
.text$mn:000021FC
.text$mn:000021FC var_1           = byte ptr -1
.text$mn:000021FC arg_0           = dword ptr  8
.text$mn:000021FC arg_4           = dword ptr  0Ch
.text$mn:000021FC arg_8           = dword ptr  10h
.text$mn:000021FC
.text$mn:000021FC                 push    ebp
.text$mn:000021FD                 mov     ebp, esp
.text$mn:000021FF                 push    ecx
.text$mn:00002200                 mov     eax, [ebp+arg_8]
.text$mn:00002203                 push    eax
.text$mn:00002204                 mov     ecx, [ebp+arg_0]
.text$mn:00002207                 push    ecx
.text$mn:00002208                 call    ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z ; std::_Ptr_cat<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:0000220D                 add     esp, 8
.text$mn:00002210                 mov     [ebp+var_1], al
.text$mn:00002213                 movzx   edx, [ebp+var_1]
.text$mn:00002217                 push    edx
.text$mn:00002218                 mov     eax, [ebp+arg_8]
.text$mn:0000221B                 push    eax
.text$mn:0000221C                 mov     ecx, [ebp+arg_4]
.text$mn:0000221F                 push    ecx
.text$mn:00002220                 mov     edx, [ebp+arg_0]
.text$mn:00002223                 push    edx
.text$mn:00002224                 call    ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Copy_backward<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002229                 add     esp, 10h
.text$mn:0000222C                 mov     esp, ebp
.text$mn:0000222E                 pop     ebp
.text$mn:0000222F                 retn
.text$mn:0000222F ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z endp
.text$mn:0000222F
.text$mn:0000222F _text$mn        ends
.text$mn:0000222F
.text$mn:00002230 ; ===========================================================================
.text$mn:00002230
.text$mn:00002230 ; Segment type: Pure code
.text$mn:00002230 ; Segment permissions: Read/Execute
.text$mn:00002230 _text$mn        segment para public 'CODE' use32
.text$mn:00002230                 assume cs:_text$mn
.text$mn:00002230                 ;org 2230h
.text$mn:00002230 ; COMDAT (pick any)
.text$mn:00002230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002230
.text$mn:00002230 ; =============== S U B R O U T I N E =======================================
.text$mn:00002230
.text$mn:00002230 ; Attributes: bp-based frame
.text$mn:00002230
.text$mn:00002230 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Copy_backward<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002230                 public ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002230 ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002230                                         ; CODE XREF: std::_Copy_backward<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+28p
.text$mn:00002230
.text$mn:00002230 arg_0           = dword ptr  8
.text$mn:00002230 arg_4           = dword ptr  0Ch
.text$mn:00002230 arg_8           = dword ptr  10h
.text$mn:00002230
.text$mn:00002230                 push    ebp
.text$mn:00002231                 mov     ebp, esp
.text$mn:00002233
.text$mn:00002233 loc_2233:                               ; CODE XREF: std::_Copy_backward<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+29j
.text$mn:00002233                 mov     eax, [ebp+arg_0]
.text$mn:00002236                 cmp     eax, [ebp+arg_4]
.text$mn:00002239                 jz      short loc_225B
.text$mn:0000223B                 mov     ecx, [ebp+arg_4]
.text$mn:0000223E                 sub     ecx, 10h
.text$mn:00002241                 mov     [ebp+arg_4], ecx
.text$mn:00002244                 mov     edx, [ebp+arg_8]
.text$mn:00002247                 sub     edx, 10h
.text$mn:0000224A                 mov     [ebp+arg_8], edx
.text$mn:0000224D                 mov     eax, [ebp+arg_4]
.text$mn:00002250                 push    eax
.text$mn:00002251                 mov     ecx, [ebp+arg_8]
.text$mn:00002254                 call    ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00002259                 jmp     short loc_2233
.text$mn:0000225B ; ---------------------------------------------------------------------------
.text$mn:0000225B
.text$mn:0000225B loc_225B:                               ; CODE XREF: std::_Copy_backward<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+9j
.text$mn:0000225B                 mov     eax, [ebp+arg_8]
.text$mn:0000225E                 pop     ebp
.text$mn:0000225F                 retn
.text$mn:0000225F ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000225F
.text$mn:0000225F _text$mn        ends
.text$mn:0000225F
.text$mn:00002260 ; ===========================================================================
.text$mn:00002260
.text$mn:00002260 ; Segment type: Pure code
.text$mn:00002260 ; Segment permissions: Read/Execute
.text$mn:00002260 _text$mn        segment para public 'CODE' use32
.text$mn:00002260                 assume cs:_text$mn
.text$mn:00002260                 ;org 2260h
.text$mn:00002260 ; COMDAT (pick any)
.text$mn:00002260                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002260
.text$mn:00002260 ; =============== S U B R O U T I N E =======================================
.text$mn:00002260
.text$mn:00002260 ; Attributes: bp-based frame
.text$mn:00002260
.text$mn:00002260 ; int __cdecl std::_Copy_impl<unsigned char *,unsigned char *>(void *Src, int, void *Dst)
.text$mn:00002260                 public ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00@Z
.text$mn:00002260 ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00@Z proc near
.text$mn:00002260                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+D4p
.text$mn:00002260                                         ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+144p
.text$mn:00002260
.text$mn:00002260 var_1           = byte ptr -1
.text$mn:00002260 Src             = dword ptr  8
.text$mn:00002260 arg_4           = dword ptr  0Ch
.text$mn:00002260 Dst             = dword ptr  10h
.text$mn:00002260
.text$mn:00002260                 push    ebp
.text$mn:00002261                 mov     ebp, esp
.text$mn:00002263                 push    ecx
.text$mn:00002264                 mov     eax, [ebp+Dst]
.text$mn:00002267                 push    eax
.text$mn:00002268                 mov     ecx, [ebp+Src]
.text$mn:0000226B                 push    ecx
.text$mn:0000226C                 call    ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z ; std::_Ptr_cat<uchar,uchar>(uchar *,uchar *)
.text$mn:00002271                 add     esp, 8
.text$mn:00002274                 mov     [ebp+var_1], al
.text$mn:00002277                 movzx   edx, [ebp+var_1]
.text$mn:0000227B                 push    edx
.text$mn:0000227C                 mov     eax, [ebp+Dst]
.text$mn:0000227F                 push    eax             ; Dst
.text$mn:00002280                 mov     ecx, [ebp+arg_4]
.text$mn:00002283                 push    ecx             ; int
.text$mn:00002284                 mov     edx, [ebp+Src]
.text$mn:00002287                 push    edx             ; Src
.text$mn:00002288                 call    ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z ; std::_Copy_impl<uchar *,uchar *>(uchar *,uchar *,uchar *,std::_Scalar_ptr_iterator_tag)
.text$mn:0000228D                 add     esp, 10h
.text$mn:00002290                 mov     esp, ebp
.text$mn:00002292                 pop     ebp
.text$mn:00002293                 retn
.text$mn:00002293 ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00@Z endp
.text$mn:00002293
.text$mn:00002293 _text$mn        ends
.text$mn:00002293
.text$mn:00002294 ; ===========================================================================
.text$mn:00002294
.text$mn:00002294 ; Segment type: Pure code
.text$mn:00002294 ; Segment permissions: Read/Execute
.text$mn:00002294 _text$mn        segment para public 'CODE' use32
.text$mn:00002294                 assume cs:_text$mn
.text$mn:00002294                 ;org 2294h
.text$mn:00002294 ; COMDAT (pick any)
.text$mn:00002294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002294
.text$mn:00002294 ; =============== S U B R O U T I N E =======================================
.text$mn:00002294
.text$mn:00002294 ; Attributes: bp-based frame
.text$mn:00002294
.text$mn:00002294 ; int __cdecl std::_Copy_impl<unsigned char *,unsigned char *>(void *Src, int, void *Dst)
.text$mn:00002294                 public ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002294 ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002294                                         ; CODE XREF: std::_Copy_impl<uchar *,uchar *>(uchar *,uchar *,uchar *)+28p
.text$mn:00002294
.text$mn:00002294 Size            = dword ptr -4
.text$mn:00002294 Src             = dword ptr  8
.text$mn:00002294 arg_4           = dword ptr  0Ch
.text$mn:00002294 Dst             = dword ptr  10h
.text$mn:00002294
.text$mn:00002294                 push    ebp
.text$mn:00002295                 mov     ebp, esp
.text$mn:00002297                 push    ecx
.text$mn:00002298                 mov     eax, [ebp+arg_4]
.text$mn:0000229B                 sub     eax, [ebp+Src]
.text$mn:0000229E                 mov     [ebp+Size], eax
.text$mn:000022A1                 mov     ecx, [ebp+Size]
.text$mn:000022A4                 push    ecx             ; Size
.text$mn:000022A5                 mov     edx, [ebp+Src]
.text$mn:000022A8                 push    edx             ; Src
.text$mn:000022A9                 mov     eax, [ebp+Dst]
.text$mn:000022AC                 push    eax             ; Dst
.text$mn:000022AD                 call    _memmove
.text$mn:000022B2                 add     esp, 0Ch
.text$mn:000022B5                 mov     eax, [ebp+Dst]
.text$mn:000022B8                 add     eax, [ebp+Size]
.text$mn:000022BB                 mov     esp, ebp
.text$mn:000022BD                 pop     ebp
.text$mn:000022BE                 retn
.text$mn:000022BE ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000022BE
.text$mn:000022BE ; ---------------------------------------------------------------------------
.text$mn:000022BF                 align 10h
.text$mn:000022BF _text$mn        ends
.text$mn:000022BF
.text$mn:000022C0 ; ===========================================================================
.text$mn:000022C0
.text$mn:000022C0 ; Segment type: Pure code
.text$mn:000022C0 ; Segment permissions: Read/Execute
.text$mn:000022C0 _text$mn        segment para public 'CODE' use32
.text$mn:000022C0                 assume cs:_text$mn
.text$mn:000022C0                 ;org 22C0h
.text$mn:000022C0 ; COMDAT (pick any)
.text$mn:000022C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022C0
.text$mn:000022C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022C0
.text$mn:000022C0 ; Attributes: bp-based frame
.text$mn:000022C0
.text$mn:000022C0 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:000022C0                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:000022C0 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:000022C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:000022C0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:000022C0
.text$mn:000022C0 arg_0           = dword ptr  8
.text$mn:000022C0 arg_4           = dword ptr  0Ch
.text$mn:000022C0 arg_8           = dword ptr  10h
.text$mn:000022C0
.text$mn:000022C0                 push    ebp
.text$mn:000022C1                 mov     ebp, esp
.text$mn:000022C3                 cmp     [ebp+arg_0], 0
.text$mn:000022C7                 jnz     short loc_22DE
.text$mn:000022C9                 mov     eax, [ebp+arg_8]
.text$mn:000022CC                 push    eax             ; unsigned int
.text$mn:000022CD                 mov     ecx, [ebp+arg_4]
.text$mn:000022D0                 push    ecx             ; wchar_t *
.text$mn:000022D1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000022D6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000022DB                 add     esp, 0Ch
.text$mn:000022DE
.text$mn:000022DE loc_22DE:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:000022DE                 pop     ebp
.text$mn:000022DF                 retn
.text$mn:000022DF ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:000022DF
.text$mn:000022DF _text$mn        ends
.text$mn:000022DF
.text$mn:000022E0 ; ===========================================================================
.text$mn:000022E0
.text$mn:000022E0 ; Segment type: Pure code
.text$mn:000022E0 ; Segment permissions: Read/Execute
.text$mn:000022E0 _text$mn        segment para public 'CODE' use32
.text$mn:000022E0                 assume cs:_text$mn
.text$mn:000022E0                 ;org 22E0h
.text$mn:000022E0 ; COMDAT (pick any)
.text$mn:000022E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022E0
.text$mn:000022E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000022E0
.text$mn:000022E0 ; Attributes: bp-based frame
.text$mn:000022E0
.text$mn:000022E0 ; int __cdecl std::_Debug_pointer<unsigned char>(int, wchar_t *, unsigned int)
.text$mn:000022E0                 public ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z
.text$mn:000022E0 ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z proc near
.text$mn:000022E0                                         ; CODE XREF: std::_Debug_range2<uchar *>(uchar *,uchar *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:000022E0                                         ; std::_Debug_range2<uchar *>(uchar *,uchar *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:000022E0
.text$mn:000022E0 arg_0           = dword ptr  8
.text$mn:000022E0 arg_4           = dword ptr  0Ch
.text$mn:000022E0 arg_8           = dword ptr  10h
.text$mn:000022E0
.text$mn:000022E0                 push    ebp
.text$mn:000022E1                 mov     ebp, esp
.text$mn:000022E3                 cmp     [ebp+arg_0], 0
.text$mn:000022E7                 jnz     short loc_22FE
.text$mn:000022E9                 mov     eax, [ebp+arg_8]
.text$mn:000022EC                 push    eax             ; unsigned int
.text$mn:000022ED                 mov     ecx, [ebp+arg_4]
.text$mn:000022F0                 push    ecx             ; wchar_t *
.text$mn:000022F1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:000022F6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000022FB                 add     esp, 0Ch
.text$mn:000022FE
.text$mn:000022FE loc_22FE:                               ; CODE XREF: std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)+7j
.text$mn:000022FE                 pop     ebp
.text$mn:000022FF                 retn
.text$mn:000022FF ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z endp
.text$mn:000022FF
.text$mn:000022FF _text$mn        ends
.text$mn:000022FF
.text$mn:00002300 ; ===========================================================================
.text$mn:00002300
.text$mn:00002300 ; Segment type: Pure code
.text$mn:00002300 ; Segment permissions: Read/Execute
.text$mn:00002300 _text$mn        segment para public 'CODE' use32
.text$mn:00002300                 assume cs:_text$mn
.text$mn:00002300                 ;org 2300h
.text$mn:00002300 ; COMDAT (pick any)
.text$mn:00002300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002300
.text$mn:00002300 ; =============== S U B R O U T I N E =======================================
.text$mn:00002300
.text$mn:00002300 ; Attributes: bp-based frame
.text$mn:00002300
.text$mn:00002300 ; int __cdecl std::_Debug_pointer<unsigned char>(int, wchar_t *, unsigned int)
.text$mn:00002300                 public ??$_Debug_pointer@E@std@@YAXPBEPB_WI@Z
.text$mn:00002300 ??$_Debug_pointer@E@std@@YAXPBEPB_WI@Z proc near
.text$mn:00002300                                         ; CODE XREF: std::_Debug_range2<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002300                                         ; std::_Debug_range2<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:00002300
.text$mn:00002300 arg_0           = dword ptr  8
.text$mn:00002300 arg_4           = dword ptr  0Ch
.text$mn:00002300 arg_8           = dword ptr  10h
.text$mn:00002300
.text$mn:00002300                 push    ebp
.text$mn:00002301                 mov     ebp, esp
.text$mn:00002303                 cmp     [ebp+arg_0], 0
.text$mn:00002307                 jnz     short loc_231E
.text$mn:00002309                 mov     eax, [ebp+arg_8]
.text$mn:0000230C                 push    eax             ; unsigned int
.text$mn:0000230D                 mov     ecx, [ebp+arg_4]
.text$mn:00002310                 push    ecx             ; wchar_t *
.text$mn:00002311                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00002316                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000231B                 add     esp, 0Ch
.text$mn:0000231E
.text$mn:0000231E loc_231E:                               ; CODE XREF: std::_Debug_pointer<uchar>(uchar const *,wchar_t const *,uint)+7j
.text$mn:0000231E                 pop     ebp
.text$mn:0000231F                 retn
.text$mn:0000231F ??$_Debug_pointer@E@std@@YAXPBEPB_WI@Z endp
.text$mn:0000231F
.text$mn:0000231F _text$mn        ends
.text$mn:0000231F
.text$mn:00002320 ; ===========================================================================
.text$mn:00002320
.text$mn:00002320 ; Segment type: Pure code
.text$mn:00002320 ; Segment permissions: Read/Execute
.text$mn:00002320 _text$mn        segment para public 'CODE' use32
.text$mn:00002320                 assume cs:_text$mn
.text$mn:00002320                 ;org 2320h
.text$mn:00002320 ; COMDAT (pick any)
.text$mn:00002320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002320
.text$mn:00002320 ; =============== S U B R O U T I N E =======================================
.text$mn:00002320
.text$mn:00002320 ; Attributes: bp-based frame
.text$mn:00002320
.text$mn:00002320 ; void __cdecl std::_Debug_pointer<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> &, wchar_t const *, unsigned int)
.text$mn:00002320                 public ??$_Debug_pointer@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@PB_WI@Z
.text$mn:00002320 ??$_Debug_pointer@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@PB_WI@Z proc near
.text$mn:00002320                                         ; CODE XREF: std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+4Cp
.text$mn:00002320                                         ; std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+60p ...
.text$mn:00002320                 push    ebp
.text$mn:00002321                 mov     ebp, esp
.text$mn:00002323                 pop     ebp
.text$mn:00002324                 retn
.text$mn:00002324 ??$_Debug_pointer@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@PB_WI@Z endp
.text$mn:00002324
.text$mn:00002324 ; ---------------------------------------------------------------------------
.text$mn:00002325                 align 4
.text$mn:00002325 _text$mn        ends
.text$mn:00002325
.text$mn:00002328 ; ===========================================================================
.text$mn:00002328
.text$mn:00002328 ; Segment type: Pure code
.text$mn:00002328 ; Segment permissions: Read/Execute
.text$mn:00002328 _text$mn        segment para public 'CODE' use32
.text$mn:00002328                 assume cs:_text$mn
.text$mn:00002328                 ;org 2328h
.text$mn:00002328 ; COMDAT (pick any)
.text$mn:00002328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002328
.text$mn:00002328 ; =============== S U B R O U T I N E =======================================
.text$mn:00002328
.text$mn:00002328 ; Attributes: bp-based frame
.text$mn:00002328
.text$mn:00002328 ; int __cdecl std::_Debug_pointer<std::vector<unsigned char,std::allocator<unsigned char>>>(int, wchar_t *, unsigned int)
.text$mn:00002328                 public ??$_Debug_pointer@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@PB_WI@Z
.text$mn:00002328 ??$_Debug_pointer@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@PB_WI@Z proc near
.text$mn:00002328                                         ; CODE XREF: std::_Debug_range2<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00002328                                         ; std::_Debug_range2<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp ...
.text$mn:00002328
.text$mn:00002328 arg_0           = dword ptr  8
.text$mn:00002328 arg_4           = dword ptr  0Ch
.text$mn:00002328 arg_8           = dword ptr  10h
.text$mn:00002328
.text$mn:00002328                 push    ebp
.text$mn:00002329                 mov     ebp, esp
.text$mn:0000232B                 cmp     [ebp+arg_0], 0
.text$mn:0000232F                 jnz     short loc_2346
.text$mn:00002331                 mov     eax, [ebp+arg_8]
.text$mn:00002334                 push    eax             ; unsigned int
.text$mn:00002335                 mov     ecx, [ebp+arg_4]
.text$mn:00002338                 push    ecx             ; wchar_t *
.text$mn:00002339                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000233E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002343                 add     esp, 0Ch
.text$mn:00002346
.text$mn:00002346 loc_2346:                               ; CODE XREF: std::_Debug_pointer<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)+7j
.text$mn:00002346                 pop     ebp
.text$mn:00002347                 retn
.text$mn:00002347 ??$_Debug_pointer@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@PB_WI@Z endp
.text$mn:00002347
.text$mn:00002347 _text$mn        ends
.text$mn:00002347
.text$mn:00002348 ; ===========================================================================
.text$mn:00002348
.text$mn:00002348 ; Segment type: Pure code
.text$mn:00002348 ; Segment permissions: Read/Execute
.text$mn:00002348 _text$mn        segment para public 'CODE' use32
.text$mn:00002348                 assume cs:_text$mn
.text$mn:00002348                 ;org 2348h
.text$mn:00002348 ; COMDAT (pick any)
.text$mn:00002348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002348
.text$mn:00002348 ; =============== S U B R O U T I N E =======================================
.text$mn:00002348
.text$mn:00002348 ; Attributes: bp-based frame
.text$mn:00002348
.text$mn:00002348 ; int __cdecl std::_Debug_range2<unsigned char *>(int, int, wchar_t *, unsigned int)
.text$mn:00002348                 public ??$_Debug_range2@PAE@std@@YAXPAE0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002348 ??$_Debug_range2@PAE@std@@YAXPAE0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002348                                         ; CODE XREF: std::_Debug_range<uchar *>(uchar *,uchar *,wchar_t const *,uint)+2Ap
.text$mn:00002348
.text$mn:00002348 arg_0           = dword ptr  8
.text$mn:00002348 arg_4           = dword ptr  0Ch
.text$mn:00002348 arg_8           = dword ptr  10h
.text$mn:00002348 arg_C           = dword ptr  14h
.text$mn:00002348
.text$mn:00002348                 push    ebp
.text$mn:00002349                 mov     ebp, esp
.text$mn:0000234B                 mov     eax, [ebp+arg_0]
.text$mn:0000234E                 cmp     eax, [ebp+arg_4]
.text$mn:00002351                 jz      short loc_2398
.text$mn:00002353                 mov     ecx, [ebp+arg_C]
.text$mn:00002356                 push    ecx             ; unsigned int
.text$mn:00002357                 mov     edx, [ebp+arg_8]
.text$mn:0000235A                 push    edx             ; wchar_t *
.text$mn:0000235B                 mov     eax, [ebp+arg_0]
.text$mn:0000235E                 push    eax             ; int
.text$mn:0000235F                 call    ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)
.text$mn:00002364                 add     esp, 0Ch
.text$mn:00002367                 mov     ecx, [ebp+arg_C]
.text$mn:0000236A                 push    ecx             ; unsigned int
.text$mn:0000236B                 mov     edx, [ebp+arg_8]
.text$mn:0000236E                 push    edx             ; wchar_t *
.text$mn:0000236F                 mov     eax, [ebp+arg_4]
.text$mn:00002372                 push    eax             ; int
.text$mn:00002373                 call    ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)
.text$mn:00002378                 add     esp, 0Ch
.text$mn:0000237B                 mov     ecx, [ebp+arg_4]
.text$mn:0000237E                 cmp     ecx, [ebp+arg_0]
.text$mn:00002381                 jnb     short loc_2398
.text$mn:00002383                 mov     edx, [ebp+arg_C]
.text$mn:00002386                 push    edx             ; unsigned int
.text$mn:00002387                 mov     eax, [ebp+arg_8]
.text$mn:0000238A                 push    eax             ; wchar_t *
.text$mn:0000238B                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002390                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00002395                 add     esp, 0Ch
.text$mn:00002398
.text$mn:00002398 loc_2398:                               ; CODE XREF: std::_Debug_range2<uchar *>(uchar *,uchar *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002398                                         ; std::_Debug_range2<uchar *>(uchar *,uchar *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002398                 pop     ebp
.text$mn:00002399                 retn
.text$mn:00002399 ??$_Debug_range2@PAE@std@@YAXPAE0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002399
.text$mn:00002399 ; ---------------------------------------------------------------------------
.text$mn:0000239A                 align 4
.text$mn:0000239A _text$mn        ends
.text$mn:0000239A
.text$mn:0000239C ; ===========================================================================
.text$mn:0000239C
.text$mn:0000239C ; Segment type: Pure code
.text$mn:0000239C ; Segment permissions: Read/Execute
.text$mn:0000239C _text$mn        segment para public 'CODE' use32
.text$mn:0000239C                 assume cs:_text$mn
.text$mn:0000239C                 ;org 239Ch
.text$mn:0000239C ; COMDAT (pick any)
.text$mn:0000239C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000239C
.text$mn:0000239C ; =============== S U B R O U T I N E =======================================
.text$mn:0000239C
.text$mn:0000239C ; Attributes: bp-based frame
.text$mn:0000239C
.text$mn:0000239C ; int __cdecl std::_Debug_range2<std::vector<unsigned char,std::allocator<unsigned char>> *>(int, int, wchar_t *, unsigned int)
.text$mn:0000239C                 public ??$_Debug_range2@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000239C ??$_Debug_range2@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:0000239C                                         ; CODE XREF: std::_Debug_range<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)+2Ap
.text$mn:0000239C
.text$mn:0000239C arg_0           = dword ptr  8
.text$mn:0000239C arg_4           = dword ptr  0Ch
.text$mn:0000239C arg_8           = dword ptr  10h
.text$mn:0000239C arg_C           = dword ptr  14h
.text$mn:0000239C
.text$mn:0000239C                 push    ebp
.text$mn:0000239D                 mov     ebp, esp
.text$mn:0000239F                 mov     eax, [ebp+arg_0]
.text$mn:000023A2                 cmp     eax, [ebp+arg_4]
.text$mn:000023A5                 jz      short loc_23EC
.text$mn:000023A7                 mov     ecx, [ebp+arg_C]
.text$mn:000023AA                 push    ecx             ; unsigned int
.text$mn:000023AB                 mov     edx, [ebp+arg_8]
.text$mn:000023AE                 push    edx             ; wchar_t *
.text$mn:000023AF                 mov     eax, [ebp+arg_0]
.text$mn:000023B2                 push    eax             ; int
.text$mn:000023B3                 call    ??$_Debug_pointer@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)
.text$mn:000023B8                 add     esp, 0Ch
.text$mn:000023BB                 mov     ecx, [ebp+arg_C]
.text$mn:000023BE                 push    ecx             ; unsigned int
.text$mn:000023BF                 mov     edx, [ebp+arg_8]
.text$mn:000023C2                 push    edx             ; wchar_t *
.text$mn:000023C3                 mov     eax, [ebp+arg_4]
.text$mn:000023C6                 push    eax             ; int
.text$mn:000023C7                 call    ??$_Debug_pointer@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)
.text$mn:000023CC                 add     esp, 0Ch
.text$mn:000023CF                 mov     ecx, [ebp+arg_4]
.text$mn:000023D2                 cmp     ecx, [ebp+arg_0]
.text$mn:000023D5                 jnb     short loc_23EC
.text$mn:000023D7                 mov     edx, [ebp+arg_C]
.text$mn:000023DA                 push    edx             ; unsigned int
.text$mn:000023DB                 mov     eax, [ebp+arg_8]
.text$mn:000023DE                 push    eax             ; wchar_t *
.text$mn:000023DF                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000023E4                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000023E9                 add     esp, 0Ch
.text$mn:000023EC
.text$mn:000023EC loc_23EC:                               ; CODE XREF: std::_Debug_range2<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:000023EC                                         ; std::_Debug_range2<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:000023EC                 pop     ebp
.text$mn:000023ED                 retn
.text$mn:000023ED ??$_Debug_range2@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:000023ED
.text$mn:000023ED ; ---------------------------------------------------------------------------
.text$mn:000023EE                 align 10h
.text$mn:000023EE _text$mn        ends
.text$mn:000023EE
.text$mn:000023F0 ; ===========================================================================
.text$mn:000023F0
.text$mn:000023F0 ; Segment type: Pure code
.text$mn:000023F0 ; Segment permissions: Read/Execute
.text$mn:000023F0 _text$mn        segment para public 'CODE' use32
.text$mn:000023F0                 assume cs:_text$mn
.text$mn:000023F0                 ;org 23F0h
.text$mn:000023F0 ; COMDAT (pick any)
.text$mn:000023F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023F0
.text$mn:000023F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023F0
.text$mn:000023F0 ; Attributes: bp-based frame
.text$mn:000023F0
.text$mn:000023F0 ; int __cdecl std::_Debug_range2<unsigned char const *>(int, int, wchar_t *, unsigned int)
.text$mn:000023F0                 public ??$_Debug_range2@PBE@std@@YAXPBE0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:000023F0 ??$_Debug_range2@PBE@std@@YAXPBE0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:000023F0                                         ; CODE XREF: std::_Debug_range<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint)+2Ap
.text$mn:000023F0
.text$mn:000023F0 arg_0           = dword ptr  8
.text$mn:000023F0 arg_4           = dword ptr  0Ch
.text$mn:000023F0 arg_8           = dword ptr  10h
.text$mn:000023F0 arg_C           = dword ptr  14h
.text$mn:000023F0
.text$mn:000023F0                 push    ebp
.text$mn:000023F1                 mov     ebp, esp
.text$mn:000023F3                 mov     eax, [ebp+arg_0]
.text$mn:000023F6                 cmp     eax, [ebp+arg_4]
.text$mn:000023F9                 jz      short loc_2440
.text$mn:000023FB                 mov     ecx, [ebp+arg_C]
.text$mn:000023FE                 push    ecx             ; unsigned int
.text$mn:000023FF                 mov     edx, [ebp+arg_8]
.text$mn:00002402                 push    edx             ; wchar_t *
.text$mn:00002403                 mov     eax, [ebp+arg_0]
.text$mn:00002406                 push    eax             ; int
.text$mn:00002407                 call    ??$_Debug_pointer@E@std@@YAXPBEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar const *,wchar_t const *,uint)
.text$mn:0000240C                 add     esp, 0Ch
.text$mn:0000240F                 mov     ecx, [ebp+arg_C]
.text$mn:00002412                 push    ecx             ; unsigned int
.text$mn:00002413                 mov     edx, [ebp+arg_8]
.text$mn:00002416                 push    edx             ; wchar_t *
.text$mn:00002417                 mov     eax, [ebp+arg_4]
.text$mn:0000241A                 push    eax             ; int
.text$mn:0000241B                 call    ??$_Debug_pointer@E@std@@YAXPBEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar const *,wchar_t const *,uint)
.text$mn:00002420                 add     esp, 0Ch
.text$mn:00002423                 mov     ecx, [ebp+arg_4]
.text$mn:00002426                 cmp     ecx, [ebp+arg_0]
.text$mn:00002429                 jnb     short loc_2440
.text$mn:0000242B                 mov     edx, [ebp+arg_C]
.text$mn:0000242E                 push    edx             ; unsigned int
.text$mn:0000242F                 mov     eax, [ebp+arg_8]
.text$mn:00002432                 push    eax             ; wchar_t *
.text$mn:00002433                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00002438                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000243D                 add     esp, 0Ch
.text$mn:00002440
.text$mn:00002440 loc_2440:                               ; CODE XREF: std::_Debug_range2<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002440                                         ; std::_Debug_range2<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002440                 pop     ebp
.text$mn:00002441                 retn
.text$mn:00002441 ??$_Debug_range2@PBE@std@@YAXPBE0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002441
.text$mn:00002441 ; ---------------------------------------------------------------------------
.text$mn:00002442                 align 4
.text$mn:00002442 _text$mn        ends
.text$mn:00002442
.text$mn:00002444 ; ===========================================================================
.text$mn:00002444
.text$mn:00002444 ; Segment type: Pure code
.text$mn:00002444 ; Segment permissions: Read/Execute
.text$mn:00002444 _text$mn        segment para public 'CODE' use32
.text$mn:00002444                 assume cs:_text$mn
.text$mn:00002444                 ;org 2444h
.text$mn:00002444 ; COMDAT (pick any)
.text$mn:00002444                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002444
.text$mn:00002444 ; =============== S U B R O U T I N E =======================================
.text$mn:00002444
.text$mn:00002444 ; Attributes: bp-based frame
.text$mn:00002444
.text$mn:00002444 ; int __cdecl std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>>>(char, int, int, char, int, int, wchar_t *, unsigned int)
.text$mn:00002444                 public ??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00002444 ??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002444                                         ; CODE XREF: std::_Debug_range<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint)+8Ap
.text$mn:00002444
.text$mn:00002444 var_C           = dword ptr -0Ch
.text$mn:00002444 var_4           = dword ptr -4
.text$mn:00002444 arg_0           = byte ptr  8
.text$mn:00002444 arg_C           = byte ptr  14h
.text$mn:00002444 arg_18          = dword ptr  20h
.text$mn:00002444 arg_1C          = dword ptr  24h
.text$mn:00002444
.text$mn:00002444                 push    ebp
.text$mn:00002445                 mov     ebp, esp
.text$mn:00002447                 push    0FFFFFFFFh
.text$mn:00002449                 push    offset __ehhandler$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:0000244E                 mov     eax, large fs:0
.text$mn:00002454                 push    eax
.text$mn:00002455                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000245A                 xor     eax, ebp
.text$mn:0000245C                 push    eax
.text$mn:0000245D                 lea     eax, [ebp+var_C]
.text$mn:00002460                 mov     large fs:0, eax
.text$mn:00002466                 mov     [ebp+var_4], 1
.text$mn:0000246D                 lea     eax, [ebp+arg_C]
.text$mn:00002470                 push    eax
.text$mn:00002471                 lea     ecx, [ebp+arg_0]
.text$mn:00002474                 push    ecx
.text$mn:00002475                 call    ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z ; std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:0000247A                 add     esp, 8
.text$mn:0000247D                 movzx   edx, al
.text$mn:00002480                 test    edx, edx
.text$mn:00002482                 jz      short loc_24D8
.text$mn:00002484                 mov     eax, [ebp+arg_1C]
.text$mn:00002487                 push    eax
.text$mn:00002488                 mov     ecx, [ebp+arg_18]
.text$mn:0000248B                 push    ecx
.text$mn:0000248C                 lea     edx, [ebp+arg_0]
.text$mn:0000248F                 push    edx
.text$mn:00002490                 call    ??$_Debug_pointer@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,wchar_t const *,uint)
.text$mn:00002495                 add     esp, 0Ch
.text$mn:00002498                 mov     eax, [ebp+arg_1C]
.text$mn:0000249B                 push    eax
.text$mn:0000249C                 mov     ecx, [ebp+arg_18]
.text$mn:0000249F                 push    ecx
.text$mn:000024A0                 lea     edx, [ebp+arg_C]
.text$mn:000024A3                 push    edx
.text$mn:000024A4                 call    ??$_Debug_pointer@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,wchar_t const *,uint)
.text$mn:000024A9                 add     esp, 0Ch
.text$mn:000024AC                 lea     eax, [ebp+arg_0]
.text$mn:000024AF                 push    eax
.text$mn:000024B0                 lea     ecx, [ebp+arg_C]
.text$mn:000024B3                 push    ecx
.text$mn:000024B4                 call    ??$?MV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z ; std::operator<<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:000024B9                 add     esp, 8
.text$mn:000024BC                 movzx   edx, al
.text$mn:000024BF                 test    edx, edx
.text$mn:000024C1                 jz      short loc_24D8
.text$mn:000024C3                 mov     eax, [ebp+arg_1C]
.text$mn:000024C6                 push    eax             ; unsigned int
.text$mn:000024C7                 mov     ecx, [ebp+arg_18]
.text$mn:000024CA                 push    ecx             ; wchar_t *
.text$mn:000024CB                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:000024D0                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000024D5                 add     esp, 0Ch
.text$mn:000024D8
.text$mn:000024D8 loc_24D8:                               ; CODE XREF: std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+3Ej
.text$mn:000024D8                                         ; std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+7Dj
.text$mn:000024D8                 mov     byte ptr [ebp+var_4], 0
.text$mn:000024DC                 lea     ecx, [ebp+arg_0]
.text$mn:000024DF                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:000024E4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000024EB                 lea     ecx, [ebp+arg_C]
.text$mn:000024EE                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:000024F3                 mov     ecx, [ebp+var_C]
.text$mn:000024F6                 mov     large fs:0, ecx
.text$mn:000024FD                 pop     ecx
.text$mn:000024FE                 mov     esp, ebp
.text$mn:00002500                 pop     ebp
.text$mn:00002501                 retn
.text$mn:00002501 ??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002501
.text$mn:00002501 ; ---------------------------------------------------------------------------
.text$mn:00002502                 align 4
.text$mn:00002502 _text$mn        ends
.text$mn:00002502
.text$x:00002504 ; ===========================================================================
.text$x:00002504
.text$x:00002504 ; Segment type: Pure code
.text$x:00002504 ; Segment permissions: Read/Execute
.text$x:00002504 _text$x         segment para public 'CODE' use32
.text$x:00002504                 assume cs:_text$x
.text$x:00002504                 ;org 2504h
.text$x:00002504 ; COMDAT (pick associative to section at 2444)
.text$x:00002504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002504
.text$x:00002504 ; =============== S U B R O U T I N E =======================================
.text$x:00002504
.text$x:00002504
.text$x:00002504 __unwindfunclet$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:00002504                                         ; DATA XREF: .xdata$x:0000A3ACo
.text$x:00002504                 lea     ecx, [ebp+14h]
.text$x:00002507                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002507 __unwindfunclet$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:00002507
.text$x:0000250C
.text$x:0000250C ; =============== S U B R O U T I N E =======================================
.text$x:0000250C
.text$x:0000250C
.text$x:0000250C __unwindfunclet$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:0000250C                                         ; DATA XREF: .xdata$x:0000A3B4o
.text$x:0000250C                 lea     ecx, [ebp+8]
.text$x:0000250F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000250F __unwindfunclet$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:0000250F
.text$x:00002514
.text$x:00002514 ; =============== S U B R O U T I N E =======================================
.text$x:00002514
.text$x:00002514
.text$x:00002514 __ehhandler$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$x:00002514                                         ; DATA XREF: std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)+5o
.text$x:00002514
.text$x:00002514 arg_4           = dword ptr  8
.text$x:00002514
.text$x:00002514                 mov     edx, [esp+arg_4]
.text$x:00002518                 lea     eax, [edx+0Ch]
.text$x:0000251B                 mov     ecx, [edx-4]
.text$x:0000251E                 xor     ecx, eax
.text$x:00002520                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002525                 mov     eax, offset __ehfuncinfo$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$x:0000252A                 jmp     ___CxxFrameHandler3
.text$x:0000252A __ehhandler$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$x:0000252A
.text$x:0000252A ; ---------------------------------------------------------------------------
.text$x:0000252F                 align 10h
.text$x:0000252F _text$x         ends
.text$x:0000252F
.text$mn:00002530 ; ===========================================================================
.text$mn:00002530
.text$mn:00002530 ; Segment type: Pure code
.text$mn:00002530 ; Segment permissions: Read/Execute
.text$mn:00002530 _text$mn        segment para public 'CODE' use32
.text$mn:00002530                 assume cs:_text$mn
.text$mn:00002530                 ;org 2530h
.text$mn:00002530 ; COMDAT (pick any)
.text$mn:00002530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002530
.text$mn:00002530 ; =============== S U B R O U T I N E =======================================
.text$mn:00002530
.text$mn:00002530 ; Attributes: bp-based frame
.text$mn:00002530
.text$mn:00002530 ; int __cdecl std::_Debug_range<unsigned char *>(int, int, wchar_t *, unsigned int)
.text$mn:00002530                 public ??$_Debug_range@PAE@std@@YAXPAE0PB_WI@Z
.text$mn:00002530 ??$_Debug_range@PAE@std@@YAXPAE0PB_WI@Z proc near
.text$mn:00002530                                         ; CODE XREF: std::_Uninit_copy<uchar,uchar>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002530                                         ; std::_Uninit_move<uchar,uchar,uchar>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,uchar *,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002530
.text$mn:00002530 var_1           = byte ptr -1
.text$mn:00002530 arg_0           = dword ptr  8
.text$mn:00002530 arg_4           = dword ptr  0Ch
.text$mn:00002530 arg_8           = dword ptr  10h
.text$mn:00002530 arg_C           = dword ptr  14h
.text$mn:00002530
.text$mn:00002530                 push    ebp
.text$mn:00002531                 mov     ebp, esp
.text$mn:00002533                 push    ecx
.text$mn:00002534                 lea     eax, [ebp+arg_0]
.text$mn:00002537                 push    eax
.text$mn:00002538                 lea     ecx, [ebp+var_1]
.text$mn:0000253B                 push    ecx
.text$mn:0000253C                 call    ??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z ; std::_Iter_cat<uchar *>(uchar * const &)
.text$mn:00002541                 add     esp, 8
.text$mn:00002544                 mov     dl, [eax]
.text$mn:00002546                 movzx   eax, dl
.text$mn:00002549                 push    eax
.text$mn:0000254A                 mov     ecx, [ebp+arg_C]
.text$mn:0000254D                 push    ecx             ; unsigned int
.text$mn:0000254E                 mov     edx, [ebp+arg_8]
.text$mn:00002551                 push    edx             ; wchar_t *
.text$mn:00002552                 mov     eax, [ebp+arg_4]
.text$mn:00002555                 push    eax             ; int
.text$mn:00002556                 mov     ecx, [ebp+arg_0]
.text$mn:00002559                 push    ecx             ; int
.text$mn:0000255A                 call    ??$_Debug_range2@PAE@std@@YAXPAE0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<uchar *>(uchar *,uchar *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:0000255F                 add     esp, 14h
.text$mn:00002562                 mov     esp, ebp
.text$mn:00002564                 pop     ebp
.text$mn:00002565                 retn
.text$mn:00002565 ??$_Debug_range@PAE@std@@YAXPAE0PB_WI@Z endp
.text$mn:00002565
.text$mn:00002565 ; ---------------------------------------------------------------------------
.text$mn:00002566                 align 4
.text$mn:00002566 _text$mn        ends
.text$mn:00002566
.text$mn:00002568 ; ===========================================================================
.text$mn:00002568
.text$mn:00002568 ; Segment type: Pure code
.text$mn:00002568 ; Segment permissions: Read/Execute
.text$mn:00002568 _text$mn        segment para public 'CODE' use32
.text$mn:00002568                 assume cs:_text$mn
.text$mn:00002568                 ;org 2568h
.text$mn:00002568 ; COMDAT (pick any)
.text$mn:00002568                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002568
.text$mn:00002568 ; =============== S U B R O U T I N E =======================================
.text$mn:00002568
.text$mn:00002568 ; Attributes: bp-based frame
.text$mn:00002568
.text$mn:00002568 ; int __cdecl std::_Debug_range<std::vector<unsigned char,std::allocator<unsigned char>> *>(int, int, wchar_t *, unsigned int)
.text$mn:00002568                 public ??$_Debug_range@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WI@Z
.text$mn:00002568 ??$_Debug_range@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WI@Z proc near
.text$mn:00002568                                         ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+3Cp
.text$mn:00002568                                         ; std::fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+15p
.text$mn:00002568
.text$mn:00002568 var_1           = byte ptr -1
.text$mn:00002568 arg_0           = dword ptr  8
.text$mn:00002568 arg_4           = dword ptr  0Ch
.text$mn:00002568 arg_8           = dword ptr  10h
.text$mn:00002568 arg_C           = dword ptr  14h
.text$mn:00002568
.text$mn:00002568                 push    ebp
.text$mn:00002569                 mov     ebp, esp
.text$mn:0000256B                 push    ecx
.text$mn:0000256C                 lea     eax, [ebp+arg_0]
.text$mn:0000256F                 push    eax
.text$mn:00002570                 lea     ecx, [ebp+var_1]
.text$mn:00002573                 push    ecx
.text$mn:00002574                 call    ??$_Iter_cat@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@EV?$allocator@E@std@@@0@@Z ; std::_Iter_cat<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> * const &)
.text$mn:00002579                 add     esp, 8
.text$mn:0000257C                 mov     dl, [eax]
.text$mn:0000257E                 movzx   eax, dl
.text$mn:00002581                 push    eax
.text$mn:00002582                 mov     ecx, [ebp+arg_C]
.text$mn:00002585                 push    ecx             ; unsigned int
.text$mn:00002586                 mov     edx, [ebp+arg_8]
.text$mn:00002589                 push    edx             ; wchar_t *
.text$mn:0000258A                 mov     eax, [ebp+arg_4]
.text$mn:0000258D                 push    eax             ; int
.text$mn:0000258E                 mov     ecx, [ebp+arg_0]
.text$mn:00002591                 push    ecx             ; int
.text$mn:00002592                 call    ??$_Debug_range2@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002597                 add     esp, 14h
.text$mn:0000259A                 mov     esp, ebp
.text$mn:0000259C                 pop     ebp
.text$mn:0000259D                 retn
.text$mn:0000259D ??$_Debug_range@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WI@Z endp
.text$mn:0000259D
.text$mn:0000259D ; ---------------------------------------------------------------------------
.text$mn:0000259E                 align 10h
.text$mn:0000259E _text$mn        ends
.text$mn:0000259E
.text$mn:000025A0 ; ===========================================================================
.text$mn:000025A0
.text$mn:000025A0 ; Segment type: Pure code
.text$mn:000025A0 ; Segment permissions: Read/Execute
.text$mn:000025A0 _text$mn        segment para public 'CODE' use32
.text$mn:000025A0                 assume cs:_text$mn
.text$mn:000025A0                 ;org 25A0h
.text$mn:000025A0 ; COMDAT (pick any)
.text$mn:000025A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025A0
.text$mn:000025A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A0
.text$mn:000025A0 ; Attributes: bp-based frame
.text$mn:000025A0
.text$mn:000025A0 ; int __cdecl std::_Debug_range<unsigned char const *>(int, int, wchar_t *, unsigned int)
.text$mn:000025A0                 public ??$_Debug_range@PBE@std@@YAXPBE0PB_WI@Z
.text$mn:000025A0 ??$_Debug_range@PBE@std@@YAXPBE0PB_WI@Z proc near
.text$mn:000025A0                                         ; CODE XREF: std::_Uninit_copy<uchar const,uchar>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:000025A0
.text$mn:000025A0 var_1           = byte ptr -1
.text$mn:000025A0 arg_0           = dword ptr  8
.text$mn:000025A0 arg_4           = dword ptr  0Ch
.text$mn:000025A0 arg_8           = dword ptr  10h
.text$mn:000025A0 arg_C           = dword ptr  14h
.text$mn:000025A0
.text$mn:000025A0                 push    ebp
.text$mn:000025A1                 mov     ebp, esp
.text$mn:000025A3                 push    ecx
.text$mn:000025A4                 lea     eax, [ebp+arg_0]
.text$mn:000025A7                 push    eax
.text$mn:000025A8                 lea     ecx, [ebp+var_1]
.text$mn:000025AB                 push    ecx
.text$mn:000025AC                 call    ??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z ; std::_Iter_cat<uchar const *>(uchar const * const &)
.text$mn:000025B1                 add     esp, 8
.text$mn:000025B4                 mov     dl, [eax]
.text$mn:000025B6                 movzx   eax, dl
.text$mn:000025B9                 push    eax
.text$mn:000025BA                 mov     ecx, [ebp+arg_C]
.text$mn:000025BD                 push    ecx             ; unsigned int
.text$mn:000025BE                 mov     edx, [ebp+arg_8]
.text$mn:000025C1                 push    edx             ; wchar_t *
.text$mn:000025C2                 mov     eax, [ebp+arg_4]
.text$mn:000025C5                 push    eax             ; int
.text$mn:000025C6                 mov     ecx, [ebp+arg_0]
.text$mn:000025C9                 push    ecx             ; int
.text$mn:000025CA                 call    ??$_Debug_range2@PBE@std@@YAXPBE0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:000025CF                 add     esp, 14h
.text$mn:000025D2                 mov     esp, ebp
.text$mn:000025D4                 pop     ebp
.text$mn:000025D5                 retn
.text$mn:000025D5 ??$_Debug_range@PBE@std@@YAXPBE0PB_WI@Z endp
.text$mn:000025D5
.text$mn:000025D5 ; ---------------------------------------------------------------------------
.text$mn:000025D6                 align 4
.text$mn:000025D6 _text$mn        ends
.text$mn:000025D6
.text$mn:000025D8 ; ===========================================================================
.text$mn:000025D8
.text$mn:000025D8 ; Segment type: Pure code
.text$mn:000025D8 ; Segment permissions: Read/Execute
.text$mn:000025D8 _text$mn        segment para public 'CODE' use32
.text$mn:000025D8                 assume cs:_text$mn
.text$mn:000025D8                 ;org 25D8h
.text$mn:000025D8 ; COMDAT (pick any)
.text$mn:000025D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025D8
.text$mn:000025D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025D8
.text$mn:000025D8 ; Attributes: bp-based frame
.text$mn:000025D8
.text$mn:000025D8 ; int __cdecl std::_Debug_range<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>>>(char, int, int, int, int, int, wchar_t *, unsigned int)
.text$mn:000025D8                 public ??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z
.text$mn:000025D8 ??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z proc near
.text$mn:000025D8                                         ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+7Dp
.text$mn:000025D8
.text$mn:000025D8 var_28          = dword ptr -28h
.text$mn:000025D8 var_24          = dword ptr -24h
.text$mn:000025D8 var_20          = dword ptr -20h
.text$mn:000025D8 var_1C          = dword ptr -1Ch
.text$mn:000025D8 var_18          = dword ptr -18h
.text$mn:000025D8 var_14          = dword ptr -14h
.text$mn:000025D8 var_D           = byte ptr -0Dh
.text$mn:000025D8 var_C           = dword ptr -0Ch
.text$mn:000025D8 var_4           = dword ptr -4
.text$mn:000025D8 arg_0           = byte ptr  8
.text$mn:000025D8 arg_C           = dword ptr  14h
.text$mn:000025D8 arg_18          = dword ptr  20h
.text$mn:000025D8 arg_1C          = dword ptr  24h
.text$mn:000025D8
.text$mn:000025D8                 push    ebp
.text$mn:000025D9                 mov     ebp, esp
.text$mn:000025DB                 push    0FFFFFFFFh
.text$mn:000025DD                 push    offset __ehhandler$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z
.text$mn:000025E2                 mov     eax, large fs:0
.text$mn:000025E8                 push    eax
.text$mn:000025E9                 sub     esp, 1Ch
.text$mn:000025EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000025F1                 xor     eax, ebp
.text$mn:000025F3                 push    eax
.text$mn:000025F4                 lea     eax, [ebp+var_C]
.text$mn:000025F7                 mov     large fs:0, eax
.text$mn:000025FD                 mov     [ebp+var_4], 1
.text$mn:00002604                 lea     eax, [ebp+arg_0]
.text$mn:00002607                 push    eax
.text$mn:00002608                 lea     ecx, [ebp+var_D]
.text$mn:0000260B                 push    ecx
.text$mn:0000260C                 call    ??$_Iter_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002611                 add     esp, 8
.text$mn:00002614                 mov     dl, [eax]
.text$mn:00002616                 movzx   eax, dl
.text$mn:00002619                 push    eax
.text$mn:0000261A                 mov     ecx, [ebp+arg_1C]
.text$mn:0000261D                 push    ecx             ; unsigned int
.text$mn:0000261E                 mov     edx, [ebp+arg_18]
.text$mn:00002621                 push    edx             ; wchar_t *
.text$mn:00002622                 sub     esp, 0Ch
.text$mn:00002625                 mov     ecx, esp
.text$mn:00002627                 mov     [ebp+var_1C], esp
.text$mn:0000262A                 lea     eax, [ebp+arg_C]
.text$mn:0000262D                 push    eax             ; int
.text$mn:0000262E                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002633                 mov     [ebp+var_14], eax
.text$mn:00002636                 mov     ecx, [ebp+var_14]
.text$mn:00002639                 mov     [ebp+var_20], ecx
.text$mn:0000263C                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002640                 sub     esp, 0Ch
.text$mn:00002643                 mov     ecx, esp
.text$mn:00002645                 mov     [ebp+var_24], esp
.text$mn:00002648                 lea     edx, [ebp+arg_0]
.text$mn:0000264B                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000264C                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002651                 mov     [ebp+var_18], eax
.text$mn:00002654                 mov     eax, [ebp+var_18]
.text$mn:00002657                 mov     [ebp+var_28], eax
.text$mn:0000265A                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000265E                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002662                 call    ??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002667                 add     esp, 24h
.text$mn:0000266A                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000266E                 lea     ecx, [ebp+arg_0]
.text$mn:00002671                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002676                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000267D                 lea     ecx, [ebp+arg_C]
.text$mn:00002680                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002685                 mov     ecx, [ebp+var_C]
.text$mn:00002688                 mov     large fs:0, ecx
.text$mn:0000268F                 pop     ecx
.text$mn:00002690                 mov     esp, ebp
.text$mn:00002692                 pop     ebp
.text$mn:00002693                 retn
.text$mn:00002693 ??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z endp
.text$mn:00002693
.text$mn:00002693 _text$mn        ends
.text$mn:00002693
.text$x:00002694 ; ===========================================================================
.text$x:00002694
.text$x:00002694 ; Segment type: Pure code
.text$x:00002694 ; Segment permissions: Read/Execute
.text$x:00002694 _text$x         segment para public 'CODE' use32
.text$x:00002694                 assume cs:_text$x
.text$x:00002694                 ;org 2694h
.text$x:00002694 ; COMDAT (pick associative to section at 25D8)
.text$x:00002694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002694
.text$x:00002694 ; =============== S U B R O U T I N E =======================================
.text$x:00002694
.text$x:00002694
.text$x:00002694 __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$0 proc near
.text$x:00002694                                         ; DATA XREF: .xdata$x:0000A368o
.text$x:00002694                 lea     ecx, [ebp+14h]
.text$x:00002697                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002697 __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$0 endp
.text$x:00002697
.text$x:0000269C
.text$x:0000269C ; =============== S U B R O U T I N E =======================================
.text$x:0000269C
.text$x:0000269C
.text$x:0000269C __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$1 proc near
.text$x:0000269C                                         ; DATA XREF: .xdata$x:0000A370o
.text$x:0000269C                 lea     ecx, [ebp+8]
.text$x:0000269F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000269F __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$1 endp
.text$x:0000269F
.text$x:000026A4
.text$x:000026A4 ; =============== S U B R O U T I N E =======================================
.text$x:000026A4
.text$x:000026A4
.text$x:000026A4 __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$2 proc near
.text$x:000026A4                                         ; DATA XREF: .xdata$x:0000A378o
.text$x:000026A4                 mov     ecx, [ebp-1Ch]
.text$x:000026A7                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000026A7 __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$2 endp
.text$x:000026A7
.text$x:000026AC
.text$x:000026AC ; =============== S U B R O U T I N E =======================================
.text$x:000026AC
.text$x:000026AC
.text$x:000026AC __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$3 proc near
.text$x:000026AC                                         ; DATA XREF: .xdata$x:0000A380o
.text$x:000026AC                 mov     ecx, [ebp-24h]
.text$x:000026AF                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000026AF __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$3 endp
.text$x:000026AF
.text$x:000026B4
.text$x:000026B4 ; =============== S U B R O U T I N E =======================================
.text$x:000026B4
.text$x:000026B4
.text$x:000026B4 __ehhandler$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z proc near
.text$x:000026B4                                         ; DATA XREF: std::_Debug_range<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint)+5o
.text$x:000026B4
.text$x:000026B4 arg_4           = dword ptr  8
.text$x:000026B4
.text$x:000026B4                 mov     edx, [esp+arg_4]
.text$x:000026B8                 lea     eax, [edx+0Ch]
.text$x:000026BB                 mov     ecx, [edx-20h]
.text$x:000026BE                 xor     ecx, eax
.text$x:000026C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000026C5                 mov     eax, offset __ehfuncinfo$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z
.text$x:000026CA                 jmp     ___CxxFrameHandler3
.text$x:000026CA __ehhandler$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z endp
.text$x:000026CA
.text$x:000026CA ; ---------------------------------------------------------------------------
.text$x:000026CF                 align 10h
.text$x:000026CF _text$x         ends
.text$x:000026CF
.text$mn:000026D0 ; ===========================================================================
.text$mn:000026D0
.text$mn:000026D0 ; Segment type: Pure code
.text$mn:000026D0 ; Segment permissions: Read/Execute
.text$mn:000026D0 _text$mn        segment para public 'CODE' use32
.text$mn:000026D0                 assume cs:_text$mn
.text$mn:000026D0                 ;org 26D0h
.text$mn:000026D0 ; COMDAT (pick any)
.text$mn:000026D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026D0
.text$mn:000026D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D0
.text$mn:000026D0 ; Attributes: bp-based frame
.text$mn:000026D0
.text$mn:000026D0 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned char>>>(unsigned char *, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>> &)
.text$mn:000026D0                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:000026D0 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:000026D0                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Destroy(uchar *,uchar *)+21p
.text$mn:000026D0
.text$mn:000026D0 var_1           = byte ptr -1
.text$mn:000026D0 arg_0           = dword ptr  8
.text$mn:000026D0 arg_4           = dword ptr  0Ch
.text$mn:000026D0 arg_8           = dword ptr  10h
.text$mn:000026D0
.text$mn:000026D0                 push    ebp
.text$mn:000026D1                 mov     ebp, esp
.text$mn:000026D3                 push    ecx
.text$mn:000026D4                 mov     eax, [ebp+arg_4]
.text$mn:000026D7                 push    eax
.text$mn:000026D8                 mov     ecx, [ebp+arg_0]
.text$mn:000026DB                 push    ecx
.text$mn:000026DC                 call    ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z ; std::_Ptr_cat<uchar,uchar>(uchar *,uchar *)
.text$mn:000026E1                 add     esp, 8
.text$mn:000026E4                 mov     [ebp+var_1], al
.text$mn:000026E7                 movzx   edx, [ebp+var_1]
.text$mn:000026EB                 push    edx
.text$mn:000026EC                 mov     eax, [ebp+arg_8]
.text$mn:000026EF                 push    eax
.text$mn:000026F0                 mov     ecx, [ebp+arg_4]
.text$mn:000026F3                 push    ecx
.text$mn:000026F4                 mov     edx, [ebp+arg_0]
.text$mn:000026F7                 push    edx
.text$mn:000026F8                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:000026FD                 add     esp, 10h
.text$mn:00002700                 mov     esp, ebp
.text$mn:00002702                 pop     ebp
.text$mn:00002703                 retn
.text$mn:00002703 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:00002703
.text$mn:00002703 _text$mn        ends
.text$mn:00002703
.text$mn:00002704 ; ===========================================================================
.text$mn:00002704
.text$mn:00002704 ; Segment type: Pure code
.text$mn:00002704 ; Segment permissions: Read/Execute
.text$mn:00002704 _text$mn        segment para public 'CODE' use32
.text$mn:00002704                 assume cs:_text$mn
.text$mn:00002704                 ;org 2704h
.text$mn:00002704 ; COMDAT (pick any)
.text$mn:00002704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002704
.text$mn:00002704 ; =============== S U B R O U T I N E =======================================
.text$mn:00002704
.text$mn:00002704 ; Attributes: bp-based frame
.text$mn:00002704
.text$mn:00002704 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<unsigned char>>>(unsigned char *, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00002704                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002704 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002704                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+28p
.text$mn:00002704                 push    ebp
.text$mn:00002705                 mov     ebp, esp
.text$mn:00002707                 pop     ebp
.text$mn:00002708                 retn
.text$mn:00002708 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002708
.text$mn:00002708 ; ---------------------------------------------------------------------------
.text$mn:00002709                 align 4
.text$mn:00002709 _text$mn        ends
.text$mn:00002709
.text$mn:0000270C ; ===========================================================================
.text$mn:0000270C
.text$mn:0000270C ; Segment type: Pure code
.text$mn:0000270C ; Segment permissions: Read/Execute
.text$mn:0000270C _text$mn        segment para public 'CODE' use32
.text$mn:0000270C                 assume cs:_text$mn
.text$mn:0000270C                 ;org 270Ch
.text$mn:0000270C ; COMDAT (pick any)
.text$mn:0000270C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000270C
.text$mn:0000270C ; =============== S U B R O U T I N E =======================================
.text$mn:0000270C
.text$mn:0000270C ; Attributes: bp-based frame
.text$mn:0000270C
.text$mn:0000270C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>> &)
.text$mn:0000270C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z
.text$mn:0000270C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z proc near
.text$mn:0000270C                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Destroy(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+21p
.text$mn:0000270C
.text$mn:0000270C var_1           = byte ptr -1
.text$mn:0000270C arg_0           = dword ptr  8
.text$mn:0000270C arg_4           = dword ptr  0Ch
.text$mn:0000270C arg_8           = dword ptr  10h
.text$mn:0000270C
.text$mn:0000270C                 push    ebp
.text$mn:0000270D                 mov     ebp, esp
.text$mn:0000270F                 push    ecx
.text$mn:00002710                 mov     eax, [ebp+arg_4]
.text$mn:00002713                 push    eax
.text$mn:00002714                 mov     ecx, [ebp+arg_0]
.text$mn:00002717                 push    ecx
.text$mn:00002718                 call    ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z ; std::_Ptr_cat<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:0000271D                 add     esp, 8
.text$mn:00002720                 mov     [ebp+var_1], al
.text$mn:00002723                 movzx   edx, [ebp+var_1]
.text$mn:00002727                 push    edx
.text$mn:00002728                 mov     eax, [ebp+arg_8]
.text$mn:0000272B                 push    eax
.text$mn:0000272C                 mov     ecx, [ebp+arg_4]
.text$mn:0000272F                 push    ecx
.text$mn:00002730                 mov     edx, [ebp+arg_0]
.text$mn:00002733                 push    edx
.text$mn:00002734                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002739                 add     esp, 10h
.text$mn:0000273C                 mov     esp, ebp
.text$mn:0000273E                 pop     ebp
.text$mn:0000273F                 retn
.text$mn:0000273F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z endp
.text$mn:0000273F
.text$mn:0000273F _text$mn        ends
.text$mn:0000273F
.text$mn:00002740 ; ===========================================================================
.text$mn:00002740
.text$mn:00002740 ; Segment type: Pure code
.text$mn:00002740 ; Segment permissions: Read/Execute
.text$mn:00002740 _text$mn        segment para public 'CODE' use32
.text$mn:00002740                 assume cs:_text$mn
.text$mn:00002740                 ;org 2740h
.text$mn:00002740 ; COMDAT (pick any)
.text$mn:00002740                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002740
.text$mn:00002740 ; =============== S U B R O U T I N E =======================================
.text$mn:00002740
.text$mn:00002740 ; Attributes: bp-based frame
.text$mn:00002740
.text$mn:00002740 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>> &, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002740                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002740 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002740                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+28p
.text$mn:00002740
.text$mn:00002740 arg_0           = dword ptr  8
.text$mn:00002740 arg_4           = dword ptr  0Ch
.text$mn:00002740 arg_8           = dword ptr  10h
.text$mn:00002740
.text$mn:00002740                 push    ebp
.text$mn:00002741                 mov     ebp, esp
.text$mn:00002743                 jmp     short loc_274E
.text$mn:00002745 ; ---------------------------------------------------------------------------
.text$mn:00002745
.text$mn:00002745 loc_2745:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::_Nonscalar_ptr_iterator_tag)+22j
.text$mn:00002745                 mov     eax, [ebp+arg_0]
.text$mn:00002748                 add     eax, 10h
.text$mn:0000274B                 mov     [ebp+arg_0], eax
.text$mn:0000274E
.text$mn:0000274E loc_274E:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:0000274E                 mov     ecx, [ebp+arg_0]
.text$mn:00002751                 cmp     ecx, [ebp+arg_4]
.text$mn:00002754                 jz      short loc_2764
.text$mn:00002756                 mov     edx, [ebp+arg_0]
.text$mn:00002759                 push    edx
.text$mn:0000275A                 mov     ecx, [ebp+arg_8]
.text$mn:0000275D                 call    ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00002762                 jmp     short loc_2745
.text$mn:00002764 ; ---------------------------------------------------------------------------
.text$mn:00002764
.text$mn:00002764 loc_2764:                               ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::_Nonscalar_ptr_iterator_tag)+14j
.text$mn:00002764                 pop     ebp
.text$mn:00002765                 retn
.text$mn:00002765 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002765
.text$mn:00002765 ; ---------------------------------------------------------------------------
.text$mn:00002766                 align 4
.text$mn:00002766 _text$mn        ends
.text$mn:00002766
.text$mn:00002768 ; ===========================================================================
.text$mn:00002768
.text$mn:00002768 ; Segment type: Pure code
.text$mn:00002768 ; Segment permissions: Read/Execute
.text$mn:00002768 _text$mn        segment para public 'CODE' use32
.text$mn:00002768                 assume cs:_text$mn
.text$mn:00002768                 ;org 2768h
.text$mn:00002768 ; COMDAT (pick any)
.text$mn:00002768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002768
.text$mn:00002768 ; =============== S U B R O U T I N E =======================================
.text$mn:00002768
.text$mn:00002768 ; Attributes: bp-based frame
.text$mn:00002768
.text$mn:00002768 ; void __cdecl std::_Distance2<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, int>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, int &, struct std::random_access_iterator_tag)
.text$mn:00002768                 public ??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.text$mn:00002768 ??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00002768                                         ; CODE XREF: std::distance<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+8Dp
.text$mn:00002768
.text$mn:00002768 var_C           = dword ptr -0Ch
.text$mn:00002768 var_4           = dword ptr -4
.text$mn:00002768 arg_0           = byte ptr  8
.text$mn:00002768 arg_C           = byte ptr  14h
.text$mn:00002768 arg_18          = dword ptr  20h
.text$mn:00002768
.text$mn:00002768                 push    ebp
.text$mn:00002769                 mov     ebp, esp
.text$mn:0000276B                 push    0FFFFFFFFh
.text$mn:0000276D                 push    offset __ehhandler$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.text$mn:00002772                 mov     eax, large fs:0
.text$mn:00002778                 push    eax
.text$mn:00002779                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000277E                 xor     eax, ebp
.text$mn:00002780                 push    eax
.text$mn:00002781                 lea     eax, [ebp+var_C]
.text$mn:00002784                 mov     large fs:0, eax
.text$mn:0000278A                 mov     [ebp+var_4], 1
.text$mn:00002791                 lea     eax, [ebp+arg_C]
.text$mn:00002794                 push    eax
.text$mn:00002795                 lea     ecx, [ebp+arg_0]
.text$mn:00002798                 push    ecx
.text$mn:00002799                 call    ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z ; std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:0000279E                 add     esp, 8
.text$mn:000027A1                 movzx   edx, al
.text$mn:000027A4                 test    edx, edx
.text$mn:000027A6                 jz      short loc_27D4
.text$mn:000027A8                 push    2E9h
.text$mn:000027AD                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000027B2                 lea     eax, [ebp+arg_0]
.text$mn:000027B5                 push    eax
.text$mn:000027B6                 call    ??$_Debug_pointer@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,wchar_t const *,uint)
.text$mn:000027BB                 add     esp, 0Ch
.text$mn:000027BE                 push    2EAh
.text$mn:000027C3                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000027C8                 lea     ecx, [ebp+arg_C]
.text$mn:000027CB                 push    ecx
.text$mn:000027CC                 call    ??$_Debug_pointer@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,wchar_t const *,uint)
.text$mn:000027D1                 add     esp, 0Ch
.text$mn:000027D4
.text$mn:000027D4 loc_27D4:                               ; CODE XREF: std::_Distance2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int &,std::random_access_iterator_tag)+3Ej
.text$mn:000027D4                 lea     edx, [ebp+arg_0]
.text$mn:000027D7                 push    edx
.text$mn:000027D8                 lea     eax, [ebp+arg_C]
.text$mn:000027DB                 push    eax
.text$mn:000027DC                 call    ??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z ; std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:000027E1                 add     esp, 8
.text$mn:000027E4                 mov     ecx, [ebp+arg_18]
.text$mn:000027E7                 add     eax, [ecx]
.text$mn:000027E9                 mov     edx, [ebp+arg_18]
.text$mn:000027EC                 mov     [edx], eax
.text$mn:000027EE                 mov     byte ptr [ebp+var_4], 0
.text$mn:000027F2                 lea     ecx, [ebp+arg_0]
.text$mn:000027F5                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:000027FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002801                 lea     ecx, [ebp+arg_C]
.text$mn:00002804                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002809                 mov     ecx, [ebp+var_C]
.text$mn:0000280C                 mov     large fs:0, ecx
.text$mn:00002813                 pop     ecx
.text$mn:00002814                 mov     esp, ebp
.text$mn:00002816                 pop     ebp
.text$mn:00002817                 retn
.text$mn:00002817 ??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002817
.text$mn:00002817 _text$mn        ends
.text$mn:00002817
.text$x:00002818 ; ===========================================================================
.text$x:00002818
.text$x:00002818 ; Segment type: Pure code
.text$x:00002818 ; Segment permissions: Read/Execute
.text$x:00002818 _text$x         segment para public 'CODE' use32
.text$x:00002818                 assume cs:_text$x
.text$x:00002818                 ;org 2818h
.text$x:00002818 ; COMDAT (pick associative to section at 2768)
.text$x:00002818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002818
.text$x:00002818 ; =============== S U B R O U T I N E =======================================
.text$x:00002818
.text$x:00002818
.text$x:00002818 __unwindfunclet$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0 proc near
.text$x:00002818                                         ; DATA XREF: .xdata$x:0000A164o
.text$x:00002818                 lea     ecx, [ebp+14h]
.text$x:0000281B                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000281B __unwindfunclet$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0 endp
.text$x:0000281B
.text$x:00002820
.text$x:00002820 ; =============== S U B R O U T I N E =======================================
.text$x:00002820
.text$x:00002820
.text$x:00002820 __unwindfunclet$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1 proc near
.text$x:00002820                                         ; DATA XREF: .xdata$x:0000A16Co
.text$x:00002820                 lea     ecx, [ebp+8]
.text$x:00002823                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002823 __unwindfunclet$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1 endp
.text$x:00002823
.text$x:00002828
.text$x:00002828 ; =============== S U B R O U T I N E =======================================
.text$x:00002828
.text$x:00002828
.text$x:00002828 __ehhandler$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z proc near
.text$x:00002828                                         ; DATA XREF: std::_Distance2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int &,std::random_access_iterator_tag)+5o
.text$x:00002828
.text$x:00002828 arg_4           = dword ptr  8
.text$x:00002828
.text$x:00002828                 mov     edx, [esp+arg_4]
.text$x:0000282C                 lea     eax, [edx+0Ch]
.text$x:0000282F                 mov     ecx, [edx-4]
.text$x:00002832                 xor     ecx, eax
.text$x:00002834                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002839                 mov     eax, offset __ehfuncinfo$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.text$x:0000283E                 jmp     ___CxxFrameHandler3
.text$x:0000283E __ehhandler$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z endp
.text$x:0000283E
.text$x:0000283E ; ---------------------------------------------------------------------------
.text$x:00002843                 align 4
.text$x:00002843 _text$x         ends
.text$x:00002843
.text$mn:00002844 ; ===========================================================================
.text$mn:00002844
.text$mn:00002844 ; Segment type: Pure code
.text$mn:00002844 ; Segment permissions: Read/Execute
.text$mn:00002844 _text$mn        segment para public 'CODE' use32
.text$mn:00002844                 assume cs:_text$mn
.text$mn:00002844                 ;org 2844h
.text$mn:00002844 ; COMDAT (pick any)
.text$mn:00002844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002844
.text$mn:00002844 ; =============== S U B R O U T I N E =======================================
.text$mn:00002844
.text$mn:00002844 ; Attributes: bp-based frame
.text$mn:00002844
.text$mn:00002844 ; public: bool __thiscall std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>::_Equal<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &)const
.text$mn:00002844                 public ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00002844 ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00002844                                         ; CODE XREF: std::operator==<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+Ap
.text$mn:00002844
.text$mn:00002844 var_28          = byte ptr -28h
.text$mn:00002844 var_1C          = dword ptr -1Ch
.text$mn:00002844 var_18          = dword ptr -18h
.text$mn:00002844 var_14          = dword ptr -14h
.text$mn:00002844 var_D           = byte ptr -0Dh
.text$mn:00002844 var_C           = dword ptr -0Ch
.text$mn:00002844 var_4           = dword ptr -4
.text$mn:00002844 arg_0           = dword ptr  8
.text$mn:00002844
.text$mn:00002844                 push    ebp
.text$mn:00002845                 mov     ebp, esp
.text$mn:00002847                 push    0FFFFFFFFh
.text$mn:00002849                 push    offset __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:0000284E                 mov     eax, large fs:0
.text$mn:00002854                 push    eax
.text$mn:00002855                 sub     esp, 1Ch
.text$mn:00002858                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000285D                 xor     eax, ebp
.text$mn:0000285F                 push    eax
.text$mn:00002860                 lea     eax, [ebp+var_C]
.text$mn:00002863                 mov     large fs:0, eax
.text$mn:00002869                 mov     [ebp+var_1C], ecx
.text$mn:0000286C                 lea     eax, [ebp+var_28]
.text$mn:0000286F                 push    eax
.text$mn:00002870                 mov     ecx, [ebp+arg_0]
.text$mn:00002873                 call    ?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::base(void)
.text$mn:00002878                 mov     [ebp+var_14], eax
.text$mn:0000287B                 mov     ecx, [ebp+var_14]
.text$mn:0000287E                 mov     [ebp+var_18], ecx
.text$mn:00002881                 mov     [ebp+var_4], 0
.text$mn:00002888                 mov     edx, [ebp+var_18]
.text$mn:0000288B                 push    edx             ; std::_Iterator_base12 *
.text$mn:0000288C                 mov     ecx, [ebp+var_1C]
.text$mn:0000288F                 call    ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00002894                 mov     [ebp+var_D], al
.text$mn:00002897                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000289E                 lea     ecx, [ebp+var_28]
.text$mn:000028A1                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:000028A6                 mov     al, [ebp+var_D]
.text$mn:000028A9                 mov     ecx, [ebp+var_C]
.text$mn:000028AC                 mov     large fs:0, ecx
.text$mn:000028B3                 pop     ecx
.text$mn:000028B4                 mov     esp, ebp
.text$mn:000028B6                 pop     ebp
.text$mn:000028B7                 retn    4
.text$mn:000028B7 ??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:000028B7
.text$mn:000028B7 ; ---------------------------------------------------------------------------
.text$mn:000028BA                 align 4
.text$mn:000028BA _text$mn        ends
.text$mn:000028BA
.text$x:000028BC ; ===========================================================================
.text$x:000028BC
.text$x:000028BC ; Segment type: Pure code
.text$x:000028BC ; Segment permissions: Read/Execute
.text$x:000028BC _text$x         segment para public 'CODE' use32
.text$x:000028BC                 assume cs:_text$x
.text$x:000028BC                 ;org 28BCh
.text$x:000028BC ; COMDAT (pick associative to section at 2844)
.text$x:000028BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028BC
.text$x:000028BC ; =============== S U B R O U T I N E =======================================
.text$x:000028BC
.text$x:000028BC
.text$x:000028BC __unwindfunclet$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z$0 proc near
.text$x:000028BC                                         ; DATA XREF: .xdata$x:0000A33Co
.text$x:000028BC                 lea     ecx, [ebp-28h]
.text$x:000028BF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:000028BF __unwindfunclet$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z$0 endp
.text$x:000028BF
.text$x:000028C4
.text$x:000028C4 ; =============== S U B R O U T I N E =======================================
.text$x:000028C4
.text$x:000028C4
.text$x:000028C4 __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$x:000028C4                                         ; DATA XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::_Equal<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+5o
.text$x:000028C4
.text$x:000028C4 arg_4           = dword ptr  8
.text$x:000028C4
.text$x:000028C4                 mov     edx, [esp+arg_4]
.text$x:000028C8                 lea     eax, [edx+0Ch]
.text$x:000028CB                 mov     ecx, [edx-20h]
.text$x:000028CE                 xor     ecx, eax
.text$x:000028D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028D5                 mov     eax, offset __ehfuncinfo$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$x:000028DA                 jmp     ___CxxFrameHandler3
.text$x:000028DA __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$x:000028DA
.text$x:000028DA ; ---------------------------------------------------------------------------
.text$x:000028DF                 align 10h
.text$x:000028DF _text$x         ends
.text$x:000028DF
.text$mn:000028E0 ; ===========================================================================
.text$mn:000028E0
.text$mn:000028E0 ; Segment type: Pure code
.text$mn:000028E0 ; Segment permissions: Read/Execute
.text$mn:000028E0 _text$mn        segment para public 'CODE' use32
.text$mn:000028E0                 assume cs:_text$mn
.text$mn:000028E0                 ;org 28E0h
.text$mn:000028E0 ; COMDAT (pick any)
.text$mn:000028E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028E0
.text$mn:000028E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000028E0
.text$mn:000028E0 ; Attributes: bp-based frame
.text$mn:000028E0
.text$mn:000028E0 ; void __cdecl std::_Fill<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:000028E0                 public ??$_Fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z
.text$mn:000028E0 ??$_Fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z proc near
.text$mn:000028E0                                         ; CODE XREF: std::fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+3Bp
.text$mn:000028E0
.text$mn:000028E0 arg_0           = dword ptr  8
.text$mn:000028E0 arg_4           = dword ptr  0Ch
.text$mn:000028E0 arg_8           = dword ptr  10h
.text$mn:000028E0
.text$mn:000028E0                 push    ebp
.text$mn:000028E1                 mov     ebp, esp
.text$mn:000028E3                 jmp     short loc_28EE
.text$mn:000028E5 ; ---------------------------------------------------------------------------
.text$mn:000028E5
.text$mn:000028E5 loc_28E5:                               ; CODE XREF: std::_Fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+22j
.text$mn:000028E5                 mov     eax, [ebp+arg_0]
.text$mn:000028E8                 add     eax, 10h
.text$mn:000028EB                 mov     [ebp+arg_0], eax
.text$mn:000028EE
.text$mn:000028EE loc_28EE:                               ; CODE XREF: std::_Fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+3j
.text$mn:000028EE                 mov     ecx, [ebp+arg_0]
.text$mn:000028F1                 cmp     ecx, [ebp+arg_4]
.text$mn:000028F4                 jz      short loc_2904
.text$mn:000028F6                 mov     edx, [ebp+arg_8]
.text$mn:000028F9                 push    edx
.text$mn:000028FA                 mov     ecx, [ebp+arg_0]
.text$mn:000028FD                 call    ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00002902                 jmp     short loc_28E5
.text$mn:00002904 ; ---------------------------------------------------------------------------
.text$mn:00002904
.text$mn:00002904 loc_2904:                               ; CODE XREF: std::_Fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+14j
.text$mn:00002904                 pop     ebp
.text$mn:00002905                 retn
.text$mn:00002905 ??$_Fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z endp
.text$mn:00002905
.text$mn:00002905 ; ---------------------------------------------------------------------------
.text$mn:00002906                 align 4
.text$mn:00002906 _text$mn        ends
.text$mn:00002906
.text$mn:00002908 ; ===========================================================================
.text$mn:00002908
.text$mn:00002908 ; Segment type: Pure code
.text$mn:00002908 ; Segment permissions: Read/Execute
.text$mn:00002908 _text$mn        segment para public 'CODE' use32
.text$mn:00002908                 assume cs:_text$mn
.text$mn:00002908                 ;org 2908h
.text$mn:00002908 ; COMDAT (pick any)
.text$mn:00002908                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002908
.text$mn:00002908 ; =============== S U B R O U T I N E =======================================
.text$mn:00002908
.text$mn:00002908 ; Attributes: bp-based frame
.text$mn:00002908
.text$mn:00002908 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<unsigned char *>(unsigned char * const &)
.text$mn:00002908                 public ??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z
.text$mn:00002908 ??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z proc near
.text$mn:00002908                                         ; CODE XREF: std::_Debug_range<uchar *>(uchar *,uchar *,wchar_t const *,uint)+Cp
.text$mn:00002908
.text$mn:00002908 var_1           = byte ptr -1
.text$mn:00002908 arg_0           = dword ptr  8
.text$mn:00002908
.text$mn:00002908                 push    ebp
.text$mn:00002909                 mov     ebp, esp
.text$mn:0000290B                 push    ecx
.text$mn:0000290C                 mov     eax, [ebp+arg_0]
.text$mn:0000290F                 mov     cl, [ebp+var_1]
.text$mn:00002912                 mov     [eax], cl
.text$mn:00002914                 mov     eax, [ebp+arg_0]
.text$mn:00002917                 mov     esp, ebp
.text$mn:00002919                 pop     ebp
.text$mn:0000291A                 retn
.text$mn:0000291A ??$_Iter_cat@PAE@std@@YA?AUrandom_access_iterator_tag@0@ABQAE@Z endp
.text$mn:0000291A
.text$mn:0000291A ; ---------------------------------------------------------------------------
.text$mn:0000291B                 align 4
.text$mn:0000291B _text$mn        ends
.text$mn:0000291B
.text$mn:0000291C ; ===========================================================================
.text$mn:0000291C
.text$mn:0000291C ; Segment type: Pure code
.text$mn:0000291C ; Segment permissions: Read/Execute
.text$mn:0000291C _text$mn        segment para public 'CODE' use32
.text$mn:0000291C                 assume cs:_text$mn
.text$mn:0000291C                 ;org 291Ch
.text$mn:0000291C ; COMDAT (pick any)
.text$mn:0000291C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000291C
.text$mn:0000291C ; =============== S U B R O U T I N E =======================================
.text$mn:0000291C
.text$mn:0000291C ; Attributes: bp-based frame
.text$mn:0000291C
.text$mn:0000291C ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> * const &)
.text$mn:0000291C                 public ??$_Iter_cat@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@EV?$allocator@E@std@@@0@@Z
.text$mn:0000291C ??$_Iter_cat@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@EV?$allocator@E@std@@@0@@Z proc near
.text$mn:0000291C                                         ; CODE XREF: std::_Debug_range<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)+Cp
.text$mn:0000291C
.text$mn:0000291C var_1           = byte ptr -1
.text$mn:0000291C arg_0           = dword ptr  8
.text$mn:0000291C
.text$mn:0000291C                 push    ebp
.text$mn:0000291D                 mov     ebp, esp
.text$mn:0000291F                 push    ecx
.text$mn:00002920                 mov     eax, [ebp+arg_0]
.text$mn:00002923                 mov     cl, [ebp+var_1]
.text$mn:00002926                 mov     [eax], cl
.text$mn:00002928                 mov     eax, [ebp+arg_0]
.text$mn:0000292B                 mov     esp, ebp
.text$mn:0000292D                 pop     ebp
.text$mn:0000292E                 retn
.text$mn:0000292E ??$_Iter_cat@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAV?$vector@EV?$allocator@E@std@@@0@@Z endp
.text$mn:0000292E
.text$mn:0000292E ; ---------------------------------------------------------------------------
.text$mn:0000292F                 align 10h
.text$mn:0000292F _text$mn        ends
.text$mn:0000292F
.text$mn:00002930 ; ===========================================================================
.text$mn:00002930
.text$mn:00002930 ; Segment type: Pure code
.text$mn:00002930 ; Segment permissions: Read/Execute
.text$mn:00002930 _text$mn        segment para public 'CODE' use32
.text$mn:00002930                 assume cs:_text$mn
.text$mn:00002930                 ;org 2930h
.text$mn:00002930 ; COMDAT (pick any)
.text$mn:00002930                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002930
.text$mn:00002930 ; =============== S U B R O U T I N E =======================================
.text$mn:00002930
.text$mn:00002930 ; Attributes: bp-based frame
.text$mn:00002930
.text$mn:00002930 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<unsigned char const *>(unsigned char const * const &)
.text$mn:00002930                 public ??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z
.text$mn:00002930 ??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z proc near
.text$mn:00002930                                         ; CODE XREF: std::_Debug_range<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint)+Cp
.text$mn:00002930
.text$mn:00002930 var_1           = byte ptr -1
.text$mn:00002930 arg_0           = dword ptr  8
.text$mn:00002930
.text$mn:00002930                 push    ebp
.text$mn:00002931                 mov     ebp, esp
.text$mn:00002933                 push    ecx
.text$mn:00002934                 mov     eax, [ebp+arg_0]
.text$mn:00002937                 mov     cl, [ebp+var_1]
.text$mn:0000293A                 mov     [eax], cl
.text$mn:0000293C                 mov     eax, [ebp+arg_0]
.text$mn:0000293F                 mov     esp, ebp
.text$mn:00002941                 pop     ebp
.text$mn:00002942                 retn
.text$mn:00002942 ??$_Iter_cat@PBE@std@@YA?AUrandom_access_iterator_tag@0@ABQBE@Z endp
.text$mn:00002942
.text$mn:00002942 ; ---------------------------------------------------------------------------
.text$mn:00002943                 align 4
.text$mn:00002943 _text$mn        ends
.text$mn:00002943
.text$mn:00002944 ; ===========================================================================
.text$mn:00002944
.text$mn:00002944 ; Segment type: Pure code
.text$mn:00002944 ; Segment permissions: Read/Execute
.text$mn:00002944 _text$mn        segment para public 'CODE' use32
.text$mn:00002944                 assume cs:_text$mn
.text$mn:00002944                 ;org 2944h
.text$mn:00002944 ; COMDAT (pick any)
.text$mn:00002944                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002944
.text$mn:00002944 ; =============== S U B R O U T I N E =======================================
.text$mn:00002944
.text$mn:00002944 ; Attributes: bp-based frame
.text$mn:00002944
.text$mn:00002944 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &)
.text$mn:00002944                 public ??$_Iter_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@@Z
.text$mn:00002944 ??$_Iter_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@@Z proc near
.text$mn:00002944                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+37p
.text$mn:00002944                                         ; std::_Debug_range<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint)+34p ...
.text$mn:00002944
.text$mn:00002944 var_1           = byte ptr -1
.text$mn:00002944 arg_0           = dword ptr  8
.text$mn:00002944
.text$mn:00002944                 push    ebp
.text$mn:00002945                 mov     ebp, esp
.text$mn:00002947                 push    ecx
.text$mn:00002948                 mov     eax, [ebp+arg_0]
.text$mn:0000294B                 mov     cl, [ebp+var_1]
.text$mn:0000294E                 mov     [eax], cl
.text$mn:00002950                 mov     eax, [ebp+arg_0]
.text$mn:00002953                 mov     esp, ebp
.text$mn:00002955                 pop     ebp
.text$mn:00002956                 retn
.text$mn:00002956 ??$_Iter_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@@Z endp
.text$mn:00002956
.text$mn:00002956 ; ---------------------------------------------------------------------------
.text$mn:00002957                 align 4
.text$mn:00002957 _text$mn        ends
.text$mn:00002957
.text$mn:00002958 ; ===========================================================================
.text$mn:00002958
.text$mn:00002958 ; Segment type: Pure code
.text$mn:00002958 ; Segment permissions: Read/Execute
.text$mn:00002958 _text$mn        segment para public 'CODE' use32
.text$mn:00002958                 assume cs:_text$mn
.text$mn:00002958                 ;org 2958h
.text$mn:00002958 ; COMDAT (pick any)
.text$mn:00002958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002958
.text$mn:00002958 ; =============== S U B R O U T I N E =======================================
.text$mn:00002958
.text$mn:00002958 ; Attributes: bp-based frame
.text$mn:00002958
.text$mn:00002958 ; public: bool __thiscall std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>::_Less<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> const &)const
.text$mn:00002958                 public ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00002958 ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00002958                                         ; CODE XREF: std::operator<<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+Ap
.text$mn:00002958
.text$mn:00002958 var_28          = byte ptr -28h
.text$mn:00002958 var_1C          = dword ptr -1Ch
.text$mn:00002958 var_18          = dword ptr -18h
.text$mn:00002958 var_14          = dword ptr -14h
.text$mn:00002958 var_D           = byte ptr -0Dh
.text$mn:00002958 var_C           = dword ptr -0Ch
.text$mn:00002958 var_4           = dword ptr -4
.text$mn:00002958 arg_0           = dword ptr  8
.text$mn:00002958
.text$mn:00002958                 push    ebp
.text$mn:00002959                 mov     ebp, esp
.text$mn:0000295B                 push    0FFFFFFFFh
.text$mn:0000295D                 push    offset __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00002962                 mov     eax, large fs:0
.text$mn:00002968                 push    eax
.text$mn:00002969                 sub     esp, 1Ch
.text$mn:0000296C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002971                 xor     eax, ebp
.text$mn:00002973                 push    eax
.text$mn:00002974                 lea     eax, [ebp+var_C]
.text$mn:00002977                 mov     large fs:0, eax
.text$mn:0000297D                 mov     [ebp+var_1C], ecx
.text$mn:00002980                 lea     eax, [ebp+var_28]
.text$mn:00002983                 push    eax
.text$mn:00002984                 mov     ecx, [ebp+arg_0]
.text$mn:00002987                 call    ?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::base(void)
.text$mn:0000298C                 mov     [ebp+var_14], eax
.text$mn:0000298F                 mov     ecx, [ebp+var_14]
.text$mn:00002992                 mov     [ebp+var_18], ecx
.text$mn:00002995                 mov     [ebp+var_4], 0
.text$mn:0000299C                 mov     edx, [ebp+var_18]
.text$mn:0000299F                 push    edx             ; std::_Iterator_base12 *
.text$mn:000029A0                 mov     ecx, [ebp+var_1C]
.text$mn:000029A3                 call    ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:000029A8                 mov     [ebp+var_D], al
.text$mn:000029AB                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000029B2                 lea     ecx, [ebp+var_28]
.text$mn:000029B5                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:000029BA                 mov     al, [ebp+var_D]
.text$mn:000029BD                 mov     ecx, [ebp+var_C]
.text$mn:000029C0                 mov     large fs:0, ecx
.text$mn:000029C7                 pop     ecx
.text$mn:000029C8                 mov     esp, ebp
.text$mn:000029CA                 pop     ebp
.text$mn:000029CB                 retn    4
.text$mn:000029CB ??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:000029CB
.text$mn:000029CB ; ---------------------------------------------------------------------------
.text$mn:000029CE                 align 10h
.text$mn:000029CE _text$mn        ends
.text$mn:000029CE
.text$x:000029D0 ; ===========================================================================
.text$x:000029D0
.text$x:000029D0 ; Segment type: Pure code
.text$x:000029D0 ; Segment permissions: Read/Execute
.text$x:000029D0 _text$x         segment para public 'CODE' use32
.text$x:000029D0                 assume cs:_text$x
.text$x:000029D0                 ;org 29D0h
.text$x:000029D0 ; COMDAT (pick associative to section at 2958)
.text$x:000029D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000029D0
.text$x:000029D0 ; =============== S U B R O U T I N E =======================================
.text$x:000029D0
.text$x:000029D0
.text$x:000029D0 __unwindfunclet$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z$0 proc near
.text$x:000029D0                                         ; DATA XREF: .xdata$x:0000A3E0o
.text$x:000029D0                 lea     ecx, [ebp-28h]
.text$x:000029D3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:000029D3 __unwindfunclet$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z$0 endp
.text$x:000029D3
.text$x:000029D8
.text$x:000029D8 ; =============== S U B R O U T I N E =======================================
.text$x:000029D8
.text$x:000029D8
.text$x:000029D8 __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$x:000029D8                                         ; DATA XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::_Less<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+5o
.text$x:000029D8
.text$x:000029D8 arg_4           = dword ptr  8
.text$x:000029D8
.text$x:000029D8                 mov     edx, [esp+arg_4]
.text$x:000029DC                 lea     eax, [edx+0Ch]
.text$x:000029DF                 mov     ecx, [edx-20h]
.text$x:000029E2                 xor     ecx, eax
.text$x:000029E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000029E9                 mov     eax, offset __ehfuncinfo$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.text$x:000029EE                 jmp     ___CxxFrameHandler3
.text$x:000029EE __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$x:000029EE
.text$x:000029EE ; ---------------------------------------------------------------------------
.text$x:000029F3                 align 4
.text$x:000029F3 _text$x         ends
.text$x:000029F3
.text$mn:000029F4 ; ===========================================================================
.text$mn:000029F4
.text$mn:000029F4 ; Segment type: Pure code
.text$mn:000029F4 ; Segment permissions: Read/Execute
.text$mn:000029F4 _text$mn        segment para public 'CODE' use32
.text$mn:000029F4                 assume cs:_text$mn
.text$mn:000029F4                 ;org 29F4h
.text$mn:000029F4 ; COMDAT (pick any)
.text$mn:000029F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000029F4
.text$mn:000029F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029F4
.text$mn:000029F4 ; Attributes: bp-based frame
.text$mn:000029F4
.text$mn:000029F4 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Move<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:000029F4                 public ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z
.text$mn:000029F4 ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z proc near
.text$mn:000029F4                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+82p
.text$mn:000029F4
.text$mn:000029F4 var_1           = byte ptr -1
.text$mn:000029F4 arg_0           = dword ptr  8
.text$mn:000029F4 arg_4           = dword ptr  0Ch
.text$mn:000029F4 arg_8           = dword ptr  10h
.text$mn:000029F4
.text$mn:000029F4                 push    ebp
.text$mn:000029F5                 mov     ebp, esp
.text$mn:000029F7                 push    ecx
.text$mn:000029F8                 mov     eax, [ebp+arg_8]
.text$mn:000029FB                 push    eax
.text$mn:000029FC                 mov     ecx, [ebp+arg_0]
.text$mn:000029FF                 push    ecx
.text$mn:00002A00                 call    ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z ; std::_Ptr_cat<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00002A05                 add     esp, 8
.text$mn:00002A08                 mov     [ebp+var_1], al
.text$mn:00002A0B                 movzx   edx, [ebp+var_1]
.text$mn:00002A0F                 push    edx
.text$mn:00002A10                 mov     eax, [ebp+arg_8]
.text$mn:00002A13                 push    eax
.text$mn:00002A14                 mov     ecx, [ebp+arg_4]
.text$mn:00002A17                 push    ecx
.text$mn:00002A18                 mov     edx, [ebp+arg_0]
.text$mn:00002A1B                 push    edx
.text$mn:00002A1C                 call    ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002A21                 add     esp, 10h
.text$mn:00002A24                 mov     esp, ebp
.text$mn:00002A26                 pop     ebp
.text$mn:00002A27                 retn
.text$mn:00002A27 ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z endp
.text$mn:00002A27
.text$mn:00002A27 _text$mn        ends
.text$mn:00002A27
.text$mn:00002A28 ; ===========================================================================
.text$mn:00002A28
.text$mn:00002A28 ; Segment type: Pure code
.text$mn:00002A28 ; Segment permissions: Read/Execute
.text$mn:00002A28 _text$mn        segment para public 'CODE' use32
.text$mn:00002A28                 assume cs:_text$mn
.text$mn:00002A28                 ;org 2A28h
.text$mn:00002A28 ; COMDAT (pick any)
.text$mn:00002A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A28
.text$mn:00002A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A28
.text$mn:00002A28 ; Attributes: bp-based frame
.text$mn:00002A28
.text$mn:00002A28 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Move<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, struct std::_Nonscalar_ptr_iterator_tag)
.text$mn:00002A28                 public ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00002A28 ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002A28                                         ; CODE XREF: std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+28p
.text$mn:00002A28
.text$mn:00002A28 arg_0           = dword ptr  8
.text$mn:00002A28 arg_4           = dword ptr  0Ch
.text$mn:00002A28 arg_8           = dword ptr  10h
.text$mn:00002A28
.text$mn:00002A28                 push    ebp
.text$mn:00002A29                 mov     ebp, esp
.text$mn:00002A2B                 jmp     short loc_2A3F
.text$mn:00002A2D ; ---------------------------------------------------------------------------
.text$mn:00002A2D
.text$mn:00002A2D loc_2A2D:                               ; CODE XREF: std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+34j
.text$mn:00002A2D                 mov     eax, [ebp+arg_8]
.text$mn:00002A30                 add     eax, 10h
.text$mn:00002A33                 mov     [ebp+arg_8], eax
.text$mn:00002A36                 mov     ecx, [ebp+arg_0]
.text$mn:00002A39                 add     ecx, 10h
.text$mn:00002A3C                 mov     [ebp+arg_0], ecx
.text$mn:00002A3F
.text$mn:00002A3F loc_2A3F:                               ; CODE XREF: std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+3j
.text$mn:00002A3F                 mov     edx, [ebp+arg_0]
.text$mn:00002A42                 cmp     edx, [ebp+arg_4]
.text$mn:00002A45                 jz      short loc_2A5E
.text$mn:00002A47                 mov     eax, [ebp+arg_0]
.text$mn:00002A4A                 push    eax
.text$mn:00002A4B                 call    ??$move@AAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::move<std::vector<uchar,std::allocator<uchar>> &>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:00002A50                 add     esp, 4
.text$mn:00002A53                 push    eax
.text$mn:00002A54                 mov     ecx, [ebp+arg_8]
.text$mn:00002A57                 call    ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:00002A5C                 jmp     short loc_2A2D
.text$mn:00002A5E ; ---------------------------------------------------------------------------
.text$mn:00002A5E
.text$mn:00002A5E loc_2A5E:                               ; CODE XREF: std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+1Dj
.text$mn:00002A5E                 mov     eax, [ebp+arg_8]
.text$mn:00002A61                 pop     ebp
.text$mn:00002A62                 retn
.text$mn:00002A62 ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002A62
.text$mn:00002A62 ; ---------------------------------------------------------------------------
.text$mn:00002A63                 align 4
.text$mn:00002A63 _text$mn        ends
.text$mn:00002A63
.text$mn:00002A64 ; ===========================================================================
.text$mn:00002A64
.text$mn:00002A64 ; Segment type: Pure code
.text$mn:00002A64 ; Segment permissions: Read/Execute
.text$mn:00002A64 _text$mn        segment para public 'CODE' use32
.text$mn:00002A64                 assume cs:_text$mn
.text$mn:00002A64                 ;org 2A64h
.text$mn:00002A64 ; COMDAT (pick any)
.text$mn:00002A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A64
.text$mn:00002A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A64
.text$mn:00002A64 ; Attributes: bp-based frame
.text$mn:00002A64
.text$mn:00002A64 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<unsigned char, unsigned char>(unsigned char *, unsigned char *)
.text$mn:00002A64                 public ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z
.text$mn:00002A64 ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z proc near
.text$mn:00002A64                                         ; CODE XREF: std::_Copy_impl<uchar *,uchar *>(uchar *,uchar *,uchar *)+Cp
.text$mn:00002A64                                         ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+Cp ...
.text$mn:00002A64
.text$mn:00002A64 var_1           = byte ptr -1
.text$mn:00002A64
.text$mn:00002A64                 push    ebp
.text$mn:00002A65                 mov     ebp, esp
.text$mn:00002A67                 push    ecx
.text$mn:00002A68                 mov     al, [ebp+var_1]
.text$mn:00002A6B                 mov     esp, ebp
.text$mn:00002A6D                 pop     ebp
.text$mn:00002A6E                 retn
.text$mn:00002A6E ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z endp
.text$mn:00002A6E
.text$mn:00002A6E ; ---------------------------------------------------------------------------
.text$mn:00002A6F                 align 10h
.text$mn:00002A6F _text$mn        ends
.text$mn:00002A6F
.text$mn:00002A70 ; ===========================================================================
.text$mn:00002A70
.text$mn:00002A70 ; Segment type: Pure code
.text$mn:00002A70 ; Segment permissions: Read/Execute
.text$mn:00002A70 _text$mn        segment para public 'CODE' use32
.text$mn:00002A70                 assume cs:_text$mn
.text$mn:00002A70                 ;org 2A70h
.text$mn:00002A70 ; COMDAT (pick any)
.text$mn:00002A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A70
.text$mn:00002A70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A70
.text$mn:00002A70 ; Attributes: bp-based frame
.text$mn:00002A70
.text$mn:00002A70 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<unsigned char, unsigned char>(unsigned char const *, unsigned char *)
.text$mn:00002A70                 public ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBEPAE@Z
.text$mn:00002A70 ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBEPAE@Z proc near
.text$mn:00002A70                                         ; CODE XREF: std::_Uninit_copy<uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+Cp
.text$mn:00002A70
.text$mn:00002A70 var_1           = byte ptr -1
.text$mn:00002A70
.text$mn:00002A70                 push    ebp
.text$mn:00002A71                 mov     ebp, esp
.text$mn:00002A73                 push    ecx
.text$mn:00002A74                 mov     al, [ebp+var_1]
.text$mn:00002A77                 mov     esp, ebp
.text$mn:00002A79                 pop     ebp
.text$mn:00002A7A                 retn
.text$mn:00002A7A ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBEPAE@Z endp
.text$mn:00002A7A
.text$mn:00002A7A ; ---------------------------------------------------------------------------
.text$mn:00002A7B                 align 4
.text$mn:00002A7B _text$mn        ends
.text$mn:00002A7B
.text$mn:00002A7C ; ===========================================================================
.text$mn:00002A7C
.text$mn:00002A7C ; Segment type: Pure code
.text$mn:00002A7C ; Segment permissions: Read/Execute
.text$mn:00002A7C _text$mn        segment para public 'CODE' use32
.text$mn:00002A7C                 assume cs:_text$mn
.text$mn:00002A7C                 ;org 2A7Ch
.text$mn:00002A7C ; COMDAT (pick any)
.text$mn:00002A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A7C
.text$mn:00002A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A7C
.text$mn:00002A7C ; Attributes: bp-based frame
.text$mn:00002A7C
.text$mn:00002A7C ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, unsigned char *>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> &, unsigned char * &)
.text$mn:00002A7C                 public ??$_Ptr_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@AAPAE@Z
.text$mn:00002A7C ??$_Ptr_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@AAPAE@Z proc near
.text$mn:00002A7C                                         ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+34p
.text$mn:00002A7C
.text$mn:00002A7C var_1           = byte ptr -1
.text$mn:00002A7C
.text$mn:00002A7C                 push    ebp
.text$mn:00002A7D                 mov     ebp, esp
.text$mn:00002A7F                 push    ecx
.text$mn:00002A80                 mov     al, [ebp+var_1]
.text$mn:00002A83                 mov     esp, ebp
.text$mn:00002A85                 pop     ebp
.text$mn:00002A86                 retn
.text$mn:00002A86 ??$_Ptr_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@AAPAE@Z endp
.text$mn:00002A86
.text$mn:00002A86 ; ---------------------------------------------------------------------------
.text$mn:00002A87                 align 4
.text$mn:00002A87 _text$mn        ends
.text$mn:00002A87
.text$mn:00002A88 ; ===========================================================================
.text$mn:00002A88
.text$mn:00002A88 ; Segment type: Pure code
.text$mn:00002A88 ; Segment permissions: Read/Execute
.text$mn:00002A88 _text$mn        segment para public 'CODE' use32
.text$mn:00002A88                 assume cs:_text$mn
.text$mn:00002A88                 ;org 2A88h
.text$mn:00002A88 ; COMDAT (pick any)
.text$mn:00002A88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A88
.text$mn:00002A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A88
.text$mn:00002A88 ; Attributes: bp-based frame
.text$mn:00002A88
.text$mn:00002A88 ; struct std::_Nonscalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00002A88                 public ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z
.text$mn:00002A88 ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z proc near
.text$mn:00002A88                                         ; CODE XREF: std::_Copy_backward<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+Cp
.text$mn:00002A88                                         ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+Cp ...
.text$mn:00002A88
.text$mn:00002A88 var_1           = byte ptr -1
.text$mn:00002A88
.text$mn:00002A88                 push    ebp
.text$mn:00002A89                 mov     ebp, esp
.text$mn:00002A8B                 push    ecx
.text$mn:00002A8C                 mov     al, [ebp+var_1]
.text$mn:00002A8F                 mov     esp, ebp
.text$mn:00002A91                 pop     ebp
.text$mn:00002A92                 retn
.text$mn:00002A92 ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z endp
.text$mn:00002A92
.text$mn:00002A92 ; ---------------------------------------------------------------------------
.text$mn:00002A93                 align 4
.text$mn:00002A93 _text$mn        ends
.text$mn:00002A93
.text$mn:00002A94 ; ===========================================================================
.text$mn:00002A94
.text$mn:00002A94 ; Segment type: Pure code
.text$mn:00002A94 ; Segment permissions: Read/Execute
.text$mn:00002A94 _text$mn        segment para public 'CODE' use32
.text$mn:00002A94                 assume cs:_text$mn
.text$mn:00002A94                 ;org 2A94h
.text$mn:00002A94 ; COMDAT (pick any)
.text$mn:00002A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A94
.text$mn:00002A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A94
.text$mn:00002A94 ; Attributes: bp-based frame
.text$mn:00002A94
.text$mn:00002A94 ; unsigned char * & __cdecl std::_Rechecked<unsigned char *, unsigned char *>(unsigned char * &, unsigned char *)
.text$mn:00002A94                 public ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z
.text$mn:00002A94 ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z proc near
.text$mn:00002A94                                         ; CODE XREF: std::_Uninitialized_copy<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+3Bp
.text$mn:00002A94                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+B2p ...
.text$mn:00002A94
.text$mn:00002A94 arg_0           = dword ptr  8
.text$mn:00002A94 arg_4           = dword ptr  0Ch
.text$mn:00002A94
.text$mn:00002A94                 push    ebp
.text$mn:00002A95                 mov     ebp, esp
.text$mn:00002A97                 mov     eax, [ebp+arg_0]
.text$mn:00002A9A                 mov     ecx, [ebp+arg_4]
.text$mn:00002A9D                 mov     [eax], ecx
.text$mn:00002A9F                 mov     eax, [ebp+arg_0]
.text$mn:00002AA2                 pop     ebp
.text$mn:00002AA3                 retn
.text$mn:00002AA3 ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z endp
.text$mn:00002AA3
.text$mn:00002AA3 _text$mn        ends
.text$mn:00002AA3
.text$mn:00002AA4 ; ===========================================================================
.text$mn:00002AA4
.text$mn:00002AA4 ; Segment type: Pure code
.text$mn:00002AA4 ; Segment permissions: Read/Execute
.text$mn:00002AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AA4                 assume cs:_text$mn
.text$mn:00002AA4                 ;org 2AA4h
.text$mn:00002AA4 ; COMDAT (pick any)
.text$mn:00002AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AA4
.text$mn:00002AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AA4
.text$mn:00002AA4 ; Attributes: bp-based frame
.text$mn:00002AA4
.text$mn:00002AA4 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * & __cdecl std::_Rechecked<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> * &, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00002AA4                 public ??$_Rechecked@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAAAPAV?$vector@EV?$allocator@E@std@@@0@AAPAV10@PAV10@@Z
.text$mn:00002AA4 ??$_Rechecked@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAAAPAV?$vector@EV?$allocator@E@std@@@0@AAPAV10@PAV10@@Z proc near
.text$mn:00002AA4                                         ; CODE XREF: std::_Uninitialized_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+3Bp
.text$mn:00002AA4
.text$mn:00002AA4 arg_0           = dword ptr  8
.text$mn:00002AA4 arg_4           = dword ptr  0Ch
.text$mn:00002AA4
.text$mn:00002AA4                 push    ebp
.text$mn:00002AA5                 mov     ebp, esp
.text$mn:00002AA7                 mov     eax, [ebp+arg_0]
.text$mn:00002AAA                 mov     ecx, [ebp+arg_4]
.text$mn:00002AAD                 mov     [eax], ecx
.text$mn:00002AAF                 mov     eax, [ebp+arg_0]
.text$mn:00002AB2                 pop     ebp
.text$mn:00002AB3                 retn
.text$mn:00002AB3 ??$_Rechecked@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAAAPAV?$vector@EV?$allocator@E@std@@@0@AAPAV10@PAV10@@Z endp
.text$mn:00002AB3
.text$mn:00002AB3 _text$mn        ends
.text$mn:00002AB3
.text$mn:00002AB4 ; ===========================================================================
.text$mn:00002AB4
.text$mn:00002AB4 ; Segment type: Pure code
.text$mn:00002AB4 ; Segment permissions: Read/Execute
.text$mn:00002AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB4                 assume cs:_text$mn
.text$mn:00002AB4                 ;org 2AB4h
.text$mn:00002AB4 ; COMDAT (pick any)
.text$mn:00002AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AB4
.text$mn:00002AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB4
.text$mn:00002AB4 ; Attributes: bp-based frame
.text$mn:00002AB4
.text$mn:00002AB4 ; protected: unsigned char * __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Ucopy<unsigned char *>(unsigned char *, unsigned char *, unsigned char *)
.text$mn:00002AB4                 public ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
.text$mn:00002AB4 ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z proc near
.text$mn:00002AB4                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+161p
.text$mn:00002AB4                                         ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+1EEp
.text$mn:00002AB4
.text$mn:00002AB4 var_8           = dword ptr -8
.text$mn:00002AB4 var_1           = byte ptr -1
.text$mn:00002AB4 arg_0           = dword ptr  8
.text$mn:00002AB4 arg_4           = dword ptr  0Ch
.text$mn:00002AB4 arg_8           = dword ptr  10h
.text$mn:00002AB4
.text$mn:00002AB4                 push    ebp
.text$mn:00002AB5                 mov     ebp, esp
.text$mn:00002AB7                 sub     esp, 8
.text$mn:00002ABA                 mov     [ebp+var_8], ecx
.text$mn:00002ABD                 lea     eax, [ebp+var_1]
.text$mn:00002AC0                 push    eax
.text$mn:00002AC1                 mov     ecx, [ebp+var_8]
.text$mn:00002AC4                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00002AC9                 lea     ecx, [ebp+var_1]
.text$mn:00002ACC                 push    ecx
.text$mn:00002ACD                 mov     edx, [ebp+arg_8]
.text$mn:00002AD0                 push    edx
.text$mn:00002AD1                 mov     eax, [ebp+arg_4]
.text$mn:00002AD4                 push    eax
.text$mn:00002AD5                 mov     ecx, [ebp+arg_0]
.text$mn:00002AD8                 push    ecx
.text$mn:00002AD9                 call    ??$_Uninitialized_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninitialized_copy<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:00002ADE                 add     esp, 10h
.text$mn:00002AE1                 mov     esp, ebp
.text$mn:00002AE3                 pop     ebp
.text$mn:00002AE4                 retn    0Ch
.text$mn:00002AE4 ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z endp
.text$mn:00002AE4
.text$mn:00002AE4 ; ---------------------------------------------------------------------------
.text$mn:00002AE7                 align 4
.text$mn:00002AE7 _text$mn        ends
.text$mn:00002AE7
.text$mn:00002AE8 ; ===========================================================================
.text$mn:00002AE8
.text$mn:00002AE8 ; Segment type: Pure code
.text$mn:00002AE8 ; Segment permissions: Read/Execute
.text$mn:00002AE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AE8                 assume cs:_text$mn
.text$mn:00002AE8                 ;org 2AE8h
.text$mn:00002AE8 ; COMDAT (pick any)
.text$mn:00002AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AE8
.text$mn:00002AE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AE8
.text$mn:00002AE8 ; Attributes: bp-based frame
.text$mn:00002AE8
.text$mn:00002AE8 ; protected: unsigned char * __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, unsigned char *)
.text$mn:00002AE8                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z
.text$mn:00002AE8 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z proc near
.text$mn:00002AE8                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+C0p
.text$mn:00002AE8
.text$mn:00002AE8 var_34          = dword ptr -34h
.text$mn:00002AE8 var_30          = dword ptr -30h
.text$mn:00002AE8 var_2C          = dword ptr -2Ch
.text$mn:00002AE8 var_28          = dword ptr -28h
.text$mn:00002AE8 var_24          = dword ptr -24h
.text$mn:00002AE8 var_20          = dword ptr -20h
.text$mn:00002AE8 var_1C          = dword ptr -1Ch
.text$mn:00002AE8 var_18          = dword ptr -18h
.text$mn:00002AE8 var_14          = dword ptr -14h
.text$mn:00002AE8 var_D           = byte ptr -0Dh
.text$mn:00002AE8 var_C           = dword ptr -0Ch
.text$mn:00002AE8 var_4           = dword ptr -4
.text$mn:00002AE8 arg_0           = byte ptr  8
.text$mn:00002AE8 arg_C           = byte ptr  14h
.text$mn:00002AE8 arg_18          = dword ptr  20h
.text$mn:00002AE8
.text$mn:00002AE8                 push    ebp
.text$mn:00002AE9                 mov     ebp, esp
.text$mn:00002AEB                 push    0FFFFFFFFh
.text$mn:00002AED                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z
.text$mn:00002AF2                 mov     eax, large fs:0
.text$mn:00002AF8                 push    eax
.text$mn:00002AF9                 sub     esp, 28h
.text$mn:00002AFC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B01                 xor     eax, ebp
.text$mn:00002B03                 push    eax
.text$mn:00002B04                 lea     eax, [ebp+var_C]
.text$mn:00002B07                 mov     large fs:0, eax
.text$mn:00002B0D                 mov     [ebp+var_14], ecx
.text$mn:00002B10                 mov     [ebp+var_4], 1
.text$mn:00002B17                 lea     eax, [ebp+var_D]
.text$mn:00002B1A                 push    eax
.text$mn:00002B1B                 mov     ecx, [ebp+var_14]
.text$mn:00002B1E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00002B23                 lea     ecx, [ebp+var_D]
.text$mn:00002B26                 push    ecx
.text$mn:00002B27                 mov     edx, [ebp+arg_18]
.text$mn:00002B2A                 push    edx
.text$mn:00002B2B                 sub     esp, 0Ch
.text$mn:00002B2E                 mov     ecx, esp
.text$mn:00002B30                 mov     [ebp+var_28], esp
.text$mn:00002B33                 lea     eax, [ebp+arg_C]
.text$mn:00002B36                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002B37                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00002B3C                 mov     [ebp+var_18], eax
.text$mn:00002B3F                 mov     ecx, [ebp+var_18]
.text$mn:00002B42                 mov     [ebp+var_2C], ecx
.text$mn:00002B45                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002B49                 sub     esp, 0Ch
.text$mn:00002B4C                 mov     ecx, esp
.text$mn:00002B4E                 mov     [ebp+var_30], esp
.text$mn:00002B51                 lea     edx, [ebp+arg_0]
.text$mn:00002B54                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00002B55                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00002B5A                 mov     [ebp+var_1C], eax
.text$mn:00002B5D                 mov     eax, [ebp+var_1C]
.text$mn:00002B60                 mov     [ebp+var_34], eax
.text$mn:00002B63                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002B67                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002B6B                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:00002B70                 add     esp, 20h
.text$mn:00002B73                 mov     [ebp+var_20], eax
.text$mn:00002B76                 mov     ecx, [ebp+var_20]
.text$mn:00002B79                 mov     [ebp+var_24], ecx
.text$mn:00002B7C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002B80                 lea     ecx, [ebp+arg_0]
.text$mn:00002B83                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00002B88                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002B8F                 lea     ecx, [ebp+arg_C]
.text$mn:00002B92                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00002B97                 mov     eax, [ebp+var_24]
.text$mn:00002B9A                 mov     ecx, [ebp+var_C]
.text$mn:00002B9D                 mov     large fs:0, ecx
.text$mn:00002BA4                 pop     ecx
.text$mn:00002BA5                 mov     esp, ebp
.text$mn:00002BA7                 pop     ebp
.text$mn:00002BA8                 retn    1Ch
.text$mn:00002BA8 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z endp
.text$mn:00002BA8
.text$mn:00002BA8 ; ---------------------------------------------------------------------------
.text$mn:00002BAB                 align 4
.text$mn:00002BAB _text$mn        ends
.text$mn:00002BAB
.text$x:00002BAC ; ===========================================================================
.text$x:00002BAC
.text$x:00002BAC ; Segment type: Pure code
.text$x:00002BAC ; Segment permissions: Read/Execute
.text$x:00002BAC _text$x         segment para public 'CODE' use32
.text$x:00002BAC                 assume cs:_text$x
.text$x:00002BAC                 ;org 2BACh
.text$x:00002BAC ; COMDAT (pick associative to section at 2AE8)
.text$x:00002BAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BAC
.text$x:00002BAC ; =============== S U B R O U T I N E =======================================
.text$x:00002BAC
.text$x:00002BAC
.text$x:00002BAC __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$0 proc near
.text$x:00002BAC                                         ; DATA XREF: .xdata$x:00009CA8o
.text$x:00002BAC                 lea     ecx, [ebp+14h]
.text$x:00002BAF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00002BAF __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$0 endp
.text$x:00002BAF
.text$x:00002BB4
.text$x:00002BB4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BB4
.text$x:00002BB4
.text$x:00002BB4 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$1 proc near
.text$x:00002BB4                                         ; DATA XREF: .xdata$x:00009CB0o
.text$x:00002BB4                 lea     ecx, [ebp+8]
.text$x:00002BB7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00002BB7 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$1 endp
.text$x:00002BB7
.text$x:00002BBC
.text$x:00002BBC ; =============== S U B R O U T I N E =======================================
.text$x:00002BBC
.text$x:00002BBC
.text$x:00002BBC __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$2 proc near
.text$x:00002BBC                                         ; DATA XREF: .xdata$x:00009CB8o
.text$x:00002BBC                 mov     ecx, [ebp-28h]
.text$x:00002BBF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00002BBF __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$2 endp
.text$x:00002BBF
.text$x:00002BC4
.text$x:00002BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC4
.text$x:00002BC4
.text$x:00002BC4 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$3 proc near
.text$x:00002BC4                                         ; DATA XREF: .xdata$x:00009CC0o
.text$x:00002BC4                 mov     ecx, [ebp-30h]
.text$x:00002BC7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00002BC7 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$3 endp
.text$x:00002BC7
.text$x:00002BCC
.text$x:00002BCC ; =============== S U B R O U T I N E =======================================
.text$x:00002BCC
.text$x:00002BCC
.text$x:00002BCC __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z proc near
.text$x:00002BCC                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)+5o
.text$x:00002BCC
.text$x:00002BCC arg_4           = dword ptr  8
.text$x:00002BCC
.text$x:00002BCC                 mov     edx, [esp+arg_4]
.text$x:00002BD0                 lea     eax, [edx+0Ch]
.text$x:00002BD3                 mov     ecx, [edx-2Ch]
.text$x:00002BD6                 xor     ecx, eax
.text$x:00002BD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BDD                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z
.text$x:00002BE2                 jmp     ___CxxFrameHandler3
.text$x:00002BE2 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z endp
.text$x:00002BE2
.text$x:00002BE2 ; ---------------------------------------------------------------------------
.text$x:00002BE7                 align 4
.text$x:00002BE7 _text$x         ends
.text$x:00002BE7
.text$mn:00002BE8 ; ===========================================================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Segment type: Pure code
.text$mn:00002BE8 ; Segment permissions: Read/Execute
.text$mn:00002BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE8                 assume cs:_text$mn
.text$mn:00002BE8                 ;org 2BE8h
.text$mn:00002BE8 ; COMDAT (pick any)
.text$mn:00002BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BE8
.text$mn:00002BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Attributes: bp-based frame
.text$mn:00002BE8
.text$mn:00002BE8 ; protected: unsigned char * __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Ucopy<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, unsigned char *)
.text$mn:00002BE8                 public ??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z
.text$mn:00002BE8 ??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z proc near
.text$mn:00002BE8                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)+E6p
.text$mn:00002BE8
.text$mn:00002BE8 var_34          = dword ptr -34h
.text$mn:00002BE8 var_30          = dword ptr -30h
.text$mn:00002BE8 var_2C          = dword ptr -2Ch
.text$mn:00002BE8 var_28          = dword ptr -28h
.text$mn:00002BE8 var_24          = dword ptr -24h
.text$mn:00002BE8 var_20          = dword ptr -20h
.text$mn:00002BE8 var_1C          = dword ptr -1Ch
.text$mn:00002BE8 var_18          = dword ptr -18h
.text$mn:00002BE8 var_14          = dword ptr -14h
.text$mn:00002BE8 var_D           = byte ptr -0Dh
.text$mn:00002BE8 var_C           = dword ptr -0Ch
.text$mn:00002BE8 var_4           = dword ptr -4
.text$mn:00002BE8 arg_0           = byte ptr  8
.text$mn:00002BE8 arg_C           = byte ptr  14h
.text$mn:00002BE8 arg_18          = dword ptr  20h
.text$mn:00002BE8
.text$mn:00002BE8                 push    ebp
.text$mn:00002BE9                 mov     ebp, esp
.text$mn:00002BEB                 push    0FFFFFFFFh
.text$mn:00002BED                 push    offset __ehhandler$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z
.text$mn:00002BF2                 mov     eax, large fs:0
.text$mn:00002BF8                 push    eax
.text$mn:00002BF9                 sub     esp, 28h
.text$mn:00002BFC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C01                 xor     eax, ebp
.text$mn:00002C03                 push    eax
.text$mn:00002C04                 lea     eax, [ebp+var_C]
.text$mn:00002C07                 mov     large fs:0, eax
.text$mn:00002C0D                 mov     [ebp+var_14], ecx
.text$mn:00002C10                 mov     [ebp+var_4], 1
.text$mn:00002C17                 lea     eax, [ebp+var_D]
.text$mn:00002C1A                 push    eax
.text$mn:00002C1B                 mov     ecx, [ebp+var_14]
.text$mn:00002C1E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00002C23                 lea     ecx, [ebp+var_D]
.text$mn:00002C26                 push    ecx
.text$mn:00002C27                 mov     edx, [ebp+arg_18]
.text$mn:00002C2A                 push    edx
.text$mn:00002C2B                 sub     esp, 0Ch
.text$mn:00002C2E                 mov     ecx, esp
.text$mn:00002C30                 mov     [ebp+var_28], esp
.text$mn:00002C33                 lea     eax, [ebp+arg_C]
.text$mn:00002C36                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002C37                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002C3C                 mov     [ebp+var_18], eax
.text$mn:00002C3F                 mov     ecx, [ebp+var_18]
.text$mn:00002C42                 mov     [ebp+var_2C], ecx
.text$mn:00002C45                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002C49                 sub     esp, 0Ch
.text$mn:00002C4C                 mov     ecx, esp
.text$mn:00002C4E                 mov     [ebp+var_30], esp
.text$mn:00002C51                 lea     edx, [ebp+arg_0]
.text$mn:00002C54                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00002C55                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002C5A                 mov     [ebp+var_1C], eax
.text$mn:00002C5D                 mov     eax, [ebp+var_1C]
.text$mn:00002C60                 mov     [ebp+var_34], eax
.text$mn:00002C63                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002C67                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002C6B                 call    ??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninitialized_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:00002C70                 add     esp, 20h
.text$mn:00002C73                 mov     [ebp+var_20], eax
.text$mn:00002C76                 mov     ecx, [ebp+var_20]
.text$mn:00002C79                 mov     [ebp+var_24], ecx
.text$mn:00002C7C                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002C80                 lea     ecx, [ebp+arg_0]
.text$mn:00002C83                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002C88                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002C8F                 lea     ecx, [ebp+arg_C]
.text$mn:00002C92                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002C97                 mov     eax, [ebp+var_24]
.text$mn:00002C9A                 mov     ecx, [ebp+var_C]
.text$mn:00002C9D                 mov     large fs:0, ecx
.text$mn:00002CA4                 pop     ecx
.text$mn:00002CA5                 mov     esp, ebp
.text$mn:00002CA7                 pop     ebp
.text$mn:00002CA8                 retn    1Ch
.text$mn:00002CA8 ??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z endp
.text$mn:00002CA8
.text$mn:00002CA8 ; ---------------------------------------------------------------------------
.text$mn:00002CAB                 align 4
.text$mn:00002CAB _text$mn        ends
.text$mn:00002CAB
.text$x:00002CAC ; ===========================================================================
.text$x:00002CAC
.text$x:00002CAC ; Segment type: Pure code
.text$x:00002CAC ; Segment permissions: Read/Execute
.text$x:00002CAC _text$x         segment para public 'CODE' use32
.text$x:00002CAC                 assume cs:_text$x
.text$x:00002CAC                 ;org 2CACh
.text$x:00002CAC ; COMDAT (pick associative to section at 2BE8)
.text$x:00002CAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002CAC
.text$x:00002CAC ; =============== S U B R O U T I N E =======================================
.text$x:00002CAC
.text$x:00002CAC
.text$x:00002CAC __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$0 proc near
.text$x:00002CAC                                         ; DATA XREF: .xdata$x:0000A120o
.text$x:00002CAC                 lea     ecx, [ebp+14h]
.text$x:00002CAF                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002CAF __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$0 endp
.text$x:00002CAF
.text$x:00002CB4
.text$x:00002CB4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CB4
.text$x:00002CB4
.text$x:00002CB4 __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$1 proc near
.text$x:00002CB4                                         ; DATA XREF: .xdata$x:0000A128o
.text$x:00002CB4                 lea     ecx, [ebp+8]
.text$x:00002CB7                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002CB7 __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$1 endp
.text$x:00002CB7
.text$x:00002CBC
.text$x:00002CBC ; =============== S U B R O U T I N E =======================================
.text$x:00002CBC
.text$x:00002CBC
.text$x:00002CBC __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$2 proc near
.text$x:00002CBC                                         ; DATA XREF: .xdata$x:0000A130o
.text$x:00002CBC                 mov     ecx, [ebp-28h]
.text$x:00002CBF                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002CBF __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$2 endp
.text$x:00002CBF
.text$x:00002CC4
.text$x:00002CC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CC4
.text$x:00002CC4
.text$x:00002CC4 __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$3 proc near
.text$x:00002CC4                                         ; DATA XREF: .xdata$x:0000A138o
.text$x:00002CC4                 mov     ecx, [ebp-30h]
.text$x:00002CC7                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002CC7 __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$3 endp
.text$x:00002CC7
.text$x:00002CCC
.text$x:00002CCC ; =============== S U B R O U T I N E =======================================
.text$x:00002CCC
.text$x:00002CCC
.text$x:00002CCC __ehhandler$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z proc near
.text$x:00002CCC                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *)+5o
.text$x:00002CCC
.text$x:00002CCC arg_4           = dword ptr  8
.text$x:00002CCC
.text$x:00002CCC                 mov     edx, [esp+arg_4]
.text$x:00002CD0                 lea     eax, [edx+0Ch]
.text$x:00002CD3                 mov     ecx, [edx-2Ch]
.text$x:00002CD6                 xor     ecx, eax
.text$x:00002CD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CDD                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z
.text$x:00002CE2                 jmp     ___CxxFrameHandler3
.text$x:00002CE2 __ehhandler$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z endp
.text$x:00002CE2
.text$x:00002CE2 ; ---------------------------------------------------------------------------
.text$x:00002CE7                 align 4
.text$x:00002CE7 _text$x         ends
.text$x:00002CE7
.text$mn:00002CE8 ; ===========================================================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Segment type: Pure code
.text$mn:00002CE8 ; Segment permissions: Read/Execute
.text$mn:00002CE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CE8                 assume cs:_text$mn
.text$mn:00002CE8                 ;org 2CE8h
.text$mn:00002CE8 ; COMDAT (pick any)
.text$mn:00002CE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CE8
.text$mn:00002CE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CE8
.text$mn:00002CE8 ; Attributes: bp-based frame
.text$mn:00002CE8
.text$mn:00002CE8 ; protected: unsigned char * __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Umove<unsigned char *>(unsigned char *, unsigned char *, unsigned char *)
.text$mn:00002CE8                 public ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z
.text$mn:00002CE8 ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z proc near
.text$mn:00002CE8                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reallocate(uint)+65p
.text$mn:00002CE8
.text$mn:00002CE8 var_8           = dword ptr -8
.text$mn:00002CE8 var_1           = byte ptr -1
.text$mn:00002CE8 arg_0           = dword ptr  8
.text$mn:00002CE8 arg_4           = dword ptr  0Ch
.text$mn:00002CE8 arg_8           = dword ptr  10h
.text$mn:00002CE8
.text$mn:00002CE8                 push    ebp
.text$mn:00002CE9                 mov     ebp, esp
.text$mn:00002CEB                 sub     esp, 8
.text$mn:00002CEE                 mov     [ebp+var_8], ecx
.text$mn:00002CF1                 lea     eax, [ebp+var_1]
.text$mn:00002CF4                 push    eax
.text$mn:00002CF5                 mov     ecx, [ebp+var_8]
.text$mn:00002CF8                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00002CFD                 lea     ecx, [ebp+var_1]
.text$mn:00002D00                 push    ecx
.text$mn:00002D01                 mov     edx, [ebp+arg_8]
.text$mn:00002D04                 push    edx
.text$mn:00002D05                 mov     eax, [ebp+arg_4]
.text$mn:00002D08                 push    eax
.text$mn:00002D09                 mov     ecx, [ebp+arg_0]
.text$mn:00002D0C                 push    ecx
.text$mn:00002D0D                 call    ??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninitialized_move<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:00002D12                 add     esp, 10h
.text$mn:00002D15                 mov     esp, ebp
.text$mn:00002D17                 pop     ebp
.text$mn:00002D18                 retn    0Ch
.text$mn:00002D18 ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z endp
.text$mn:00002D18
.text$mn:00002D18 ; ---------------------------------------------------------------------------
.text$mn:00002D1B                 align 4
.text$mn:00002D1B _text$mn        ends
.text$mn:00002D1B
.text$mn:00002D1C ; ===========================================================================
.text$mn:00002D1C
.text$mn:00002D1C ; Segment type: Pure code
.text$mn:00002D1C ; Segment permissions: Read/Execute
.text$mn:00002D1C _text$mn        segment para public 'CODE' use32
.text$mn:00002D1C                 assume cs:_text$mn
.text$mn:00002D1C                 ;org 2D1Ch
.text$mn:00002D1C ; COMDAT (pick any)
.text$mn:00002D1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D1C
.text$mn:00002D1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D1C
.text$mn:00002D1C ; Attributes: bp-based frame
.text$mn:00002D1C
.text$mn:00002D1C ; protected: class std::vector<unsigned char, class std::allocator<unsigned char>> * __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Umove<class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00002D1C                 public ??$_Umove@PAV?$vector@EV?$allocator@E@std@@@std@@@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@1@PAV21@00@Z
.text$mn:00002D1C ??$_Umove@PAV?$vector@EV?$allocator@E@std@@@std@@@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@1@PAV21@00@Z proc near
.text$mn:00002D1C                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+14Cp
.text$mn:00002D1C                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+175p ...
.text$mn:00002D1C
.text$mn:00002D1C var_8           = dword ptr -8
.text$mn:00002D1C var_1           = byte ptr -1
.text$mn:00002D1C arg_0           = dword ptr  8
.text$mn:00002D1C arg_4           = dword ptr  0Ch
.text$mn:00002D1C arg_8           = dword ptr  10h
.text$mn:00002D1C
.text$mn:00002D1C                 push    ebp
.text$mn:00002D1D                 mov     ebp, esp
.text$mn:00002D1F                 sub     esp, 8
.text$mn:00002D22                 mov     [ebp+var_8], ecx
.text$mn:00002D25                 lea     eax, [ebp+var_1]
.text$mn:00002D28                 push    eax
.text$mn:00002D29                 mov     ecx, [ebp+var_8]
.text$mn:00002D2C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)
.text$mn:00002D31                 lea     ecx, [ebp+var_1]
.text$mn:00002D34                 push    ecx
.text$mn:00002D35                 mov     edx, [ebp+arg_8]
.text$mn:00002D38                 push    edx
.text$mn:00002D39                 mov     eax, [ebp+arg_4]
.text$mn:00002D3C                 push    eax
.text$mn:00002D3D                 mov     ecx, [ebp+arg_0]
.text$mn:00002D40                 push    ecx
.text$mn:00002D41                 call    ??$_Uninitialized_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)
.text$mn:00002D46                 add     esp, 10h
.text$mn:00002D49                 mov     esp, ebp
.text$mn:00002D4B                 pop     ebp
.text$mn:00002D4C                 retn    0Ch
.text$mn:00002D4C ??$_Umove@PAV?$vector@EV?$allocator@E@std@@@std@@@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@1@PAV21@00@Z endp
.text$mn:00002D4C
.text$mn:00002D4C ; ---------------------------------------------------------------------------
.text$mn:00002D4F                 align 10h
.text$mn:00002D4F _text$mn        ends
.text$mn:00002D4F
.text$mn:00002D50 ; ===========================================================================
.text$mn:00002D50
.text$mn:00002D50 ; Segment type: Pure code
.text$mn:00002D50 ; Segment permissions: Read/Execute
.text$mn:00002D50 _text$mn        segment para public 'CODE' use32
.text$mn:00002D50                 assume cs:_text$mn
.text$mn:00002D50                 ;org 2D50h
.text$mn:00002D50 ; COMDAT (pick any)
.text$mn:00002D50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D50
.text$mn:00002D50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D50
.text$mn:00002D50 ; Attributes: bp-based frame
.text$mn:00002D50
.text$mn:00002D50 ; unsigned char * __cdecl std::_Unchecked<unsigned char *>(unsigned char *)
.text$mn:00002D50                 public ??$_Unchecked@PAE@std@@YAPAEPAE@Z
.text$mn:00002D50 ??$_Unchecked@PAE@std@@YAPAEPAE@Z proc near
.text$mn:00002D50                                         ; CODE XREF: std::_Uninitialized_copy<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+Bp
.text$mn:00002D50                                         ; std::_Uninitialized_copy<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+18p ...
.text$mn:00002D50
.text$mn:00002D50 arg_0           = dword ptr  8
.text$mn:00002D50
.text$mn:00002D50                 push    ebp
.text$mn:00002D51                 mov     ebp, esp
.text$mn:00002D53                 mov     eax, [ebp+arg_0]
.text$mn:00002D56                 pop     ebp
.text$mn:00002D57                 retn
.text$mn:00002D57 ??$_Unchecked@PAE@std@@YAPAEPAE@Z endp
.text$mn:00002D57
.text$mn:00002D57 _text$mn        ends
.text$mn:00002D57
.text$mn:00002D58 ; ===========================================================================
.text$mn:00002D58
.text$mn:00002D58 ; Segment type: Pure code
.text$mn:00002D58 ; Segment permissions: Read/Execute
.text$mn:00002D58 _text$mn        segment para public 'CODE' use32
.text$mn:00002D58                 assume cs:_text$mn
.text$mn:00002D58                 ;org 2D58h
.text$mn:00002D58 ; COMDAT (pick any)
.text$mn:00002D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D58
.text$mn:00002D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D58
.text$mn:00002D58 ; Attributes: bp-based frame
.text$mn:00002D58
.text$mn:00002D58 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Unchecked<class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00002D58                 public ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z
.text$mn:00002D58 ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z proc near
.text$mn:00002D58                                         ; CODE XREF: std::_Uninitialized_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+Bp
.text$mn:00002D58                                         ; std::_Uninitialized_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+18p ...
.text$mn:00002D58
.text$mn:00002D58 arg_0           = dword ptr  8
.text$mn:00002D58
.text$mn:00002D58                 push    ebp
.text$mn:00002D59                 mov     ebp, esp
.text$mn:00002D5B                 mov     eax, [ebp+arg_0]
.text$mn:00002D5E                 pop     ebp
.text$mn:00002D5F                 retn
.text$mn:00002D5F ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z endp
.text$mn:00002D5F
.text$mn:00002D5F _text$mn        ends
.text$mn:00002D5F
.text$mn:00002D60 ; ===========================================================================
.text$mn:00002D60
.text$mn:00002D60 ; Segment type: Pure code
.text$mn:00002D60 ; Segment permissions: Read/Execute
.text$mn:00002D60 _text$mn        segment para public 'CODE' use32
.text$mn:00002D60                 assume cs:_text$mn
.text$mn:00002D60                 ;org 2D60h
.text$mn:00002D60 ; COMDAT (pick any)
.text$mn:00002D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D60
.text$mn:00002D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D60
.text$mn:00002D60 ; Attributes: bp-based frame
.text$mn:00002D60
.text$mn:00002D60 ; unsigned char const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>)
.text$mn:00002D60                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.text$mn:00002D60 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z proc near
.text$mn:00002D60                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+5Fp
.text$mn:00002D60                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+90p
.text$mn:00002D60
.text$mn:00002D60 var_10          = dword ptr -10h
.text$mn:00002D60 var_C           = dword ptr -0Ch
.text$mn:00002D60 var_4           = dword ptr -4
.text$mn:00002D60 arg_0           = byte ptr  8
.text$mn:00002D60
.text$mn:00002D60                 push    ebp
.text$mn:00002D61                 mov     ebp, esp
.text$mn:00002D63                 push    0FFFFFFFFh
.text$mn:00002D65                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.text$mn:00002D6A                 mov     eax, large fs:0
.text$mn:00002D70                 push    eax
.text$mn:00002D71                 push    ecx
.text$mn:00002D72                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D77                 xor     eax, ebp
.text$mn:00002D79                 push    eax
.text$mn:00002D7A                 lea     eax, [ebp+var_C]
.text$mn:00002D7D                 mov     large fs:0, eax
.text$mn:00002D83                 mov     [ebp+var_4], 0
.text$mn:00002D8A                 lea     ecx, [ebp+arg_0]
.text$mn:00002D8D                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPBEXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Unchecked(void)
.text$mn:00002D92                 mov     [ebp+var_10], eax
.text$mn:00002D95                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002D9C                 lea     ecx, [ebp+arg_0]
.text$mn:00002D9F                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00002DA4                 mov     eax, [ebp+var_10]
.text$mn:00002DA7                 mov     ecx, [ebp+var_C]
.text$mn:00002DAA                 mov     large fs:0, ecx
.text$mn:00002DB1                 pop     ecx
.text$mn:00002DB2                 mov     esp, ebp
.text$mn:00002DB4                 pop     ebp
.text$mn:00002DB5                 retn
.text$mn:00002DB5 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z endp
.text$mn:00002DB5
.text$mn:00002DB5 ; ---------------------------------------------------------------------------
.text$mn:00002DB6                 align 4
.text$mn:00002DB6 _text$mn        ends
.text$mn:00002DB6
.text$x:00002DB8 ; ===========================================================================
.text$x:00002DB8
.text$x:00002DB8 ; Segment type: Pure code
.text$x:00002DB8 ; Segment permissions: Read/Execute
.text$x:00002DB8 _text$x         segment para public 'CODE' use32
.text$x:00002DB8                 assume cs:_text$x
.text$x:00002DB8                 ;org 2DB8h
.text$x:00002DB8 ; COMDAT (pick associative to section at 2D60)
.text$x:00002DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DB8
.text$x:00002DB8 ; =============== S U B R O U T I N E =======================================
.text$x:00002DB8
.text$x:00002DB8
.text$x:00002DB8 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$0 proc near
.text$x:00002DB8                                         ; DATA XREF: .xdata$x:00009DB4o
.text$x:00002DB8                 lea     ecx, [ebp+8]
.text$x:00002DBB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00002DBB __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$0 endp
.text$x:00002DBB
.text$x:00002DC0
.text$x:00002DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00002DC0
.text$x:00002DC0
.text$x:00002DC0 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z proc near
.text$x:00002DC0                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)+5o
.text$x:00002DC0
.text$x:00002DC0 arg_4           = dword ptr  8
.text$x:00002DC0
.text$x:00002DC0                 mov     edx, [esp+arg_4]
.text$x:00002DC4                 lea     eax, [edx+0Ch]
.text$x:00002DC7                 mov     ecx, [edx-8]
.text$x:00002DCA                 xor     ecx, eax
.text$x:00002DCC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DD1                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.text$x:00002DD6                 jmp     ___CxxFrameHandler3
.text$x:00002DD6 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z endp
.text$x:00002DD6
.text$x:00002DD6 ; ---------------------------------------------------------------------------
.text$x:00002DDB                 align 4
.text$x:00002DDB _text$x         ends
.text$x:00002DDB
.text$mn:00002DDC ; ===========================================================================
.text$mn:00002DDC
.text$mn:00002DDC ; Segment type: Pure code
.text$mn:00002DDC ; Segment permissions: Read/Execute
.text$mn:00002DDC _text$mn        segment para public 'CODE' use32
.text$mn:00002DDC                 assume cs:_text$mn
.text$mn:00002DDC                 ;org 2DDCh
.text$mn:00002DDC ; COMDAT (pick any)
.text$mn:00002DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DDC
.text$mn:00002DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00002DDC
.text$mn:00002DDC ; Attributes: bp-based frame
.text$mn:00002DDC
.text$mn:00002DDC ; class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> __cdecl std::_Unchecked<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>)
.text$mn:00002DDC                 public ??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z
.text$mn:00002DDC ??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z proc near
.text$mn:00002DDC                                         ; CODE XREF: std::_Uninitialized_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+69p
.text$mn:00002DDC                                         ; std::_Uninitialized_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+A9p
.text$mn:00002DDC
.text$mn:00002DDC var_10          = dword ptr -10h
.text$mn:00002DDC var_C           = dword ptr -0Ch
.text$mn:00002DDC var_4           = dword ptr -4
.text$mn:00002DDC arg_0           = dword ptr  8
.text$mn:00002DDC arg_4           = byte ptr  0Ch
.text$mn:00002DDC
.text$mn:00002DDC                 push    ebp
.text$mn:00002DDD                 mov     ebp, esp
.text$mn:00002DDF                 push    0FFFFFFFFh
.text$mn:00002DE1                 push    offset __ehhandler$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z
.text$mn:00002DE6                 mov     eax, large fs:0
.text$mn:00002DEC                 push    eax
.text$mn:00002DED                 push    ecx
.text$mn:00002DEE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002DF3                 xor     eax, ebp
.text$mn:00002DF5                 push    eax
.text$mn:00002DF6                 lea     eax, [ebp+var_C]
.text$mn:00002DF9                 mov     large fs:0, eax
.text$mn:00002DFF                 mov     [ebp+var_10], 0
.text$mn:00002E06                 mov     [ebp+var_4], 1
.text$mn:00002E0D                 lea     eax, [ebp+arg_4]
.text$mn:00002E10                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002E11                 mov     ecx, [ebp+arg_0]
.text$mn:00002E14                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002E19                 mov     ecx, [ebp+var_10]
.text$mn:00002E1C                 or      ecx, 1
.text$mn:00002E1F                 mov     [ebp+var_10], ecx
.text$mn:00002E22                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002E26                 lea     ecx, [ebp+arg_4]
.text$mn:00002E29                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00002E2E                 mov     eax, [ebp+arg_0]
.text$mn:00002E31                 mov     ecx, [ebp+var_C]
.text$mn:00002E34                 mov     large fs:0, ecx
.text$mn:00002E3B                 pop     ecx
.text$mn:00002E3C                 mov     esp, ebp
.text$mn:00002E3E                 pop     ebp
.text$mn:00002E3F                 retn
.text$mn:00002E3F ??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z endp
.text$mn:00002E3F
.text$mn:00002E3F _text$mn        ends
.text$mn:00002E3F
.text$x:00002E40 ; ===========================================================================
.text$x:00002E40
.text$x:00002E40 ; Segment type: Pure code
.text$x:00002E40 ; Segment permissions: Read/Execute
.text$x:00002E40 _text$x         segment para public 'CODE' use32
.text$x:00002E40                 assume cs:_text$x
.text$x:00002E40                 ;org 2E40h
.text$x:00002E40 ; COMDAT (pick associative to section at 2DDC)
.text$x:00002E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E40
.text$x:00002E40 ; =============== S U B R O U T I N E =======================================
.text$x:00002E40
.text$x:00002E40
.text$x:00002E40 __unwindfunclet$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z$0 proc near
.text$x:00002E40                                         ; DATA XREF: .xdata$x:0000A254o
.text$x:00002E40                 lea     ecx, [ebp+0Ch]
.text$x:00002E43                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002E43 __unwindfunclet$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z$0 endp
.text$x:00002E43
.text$x:00002E48
.text$x:00002E48 ; =============== S U B R O U T I N E =======================================
.text$x:00002E48
.text$x:00002E48
.text$x:00002E48 __unwindfunclet$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z$1 proc near
.text$x:00002E48                                         ; DATA XREF: .xdata$x:0000A24Co
.text$x:00002E48                 mov     eax, [ebp-10h]
.text$x:00002E4B                 and     eax, 1
.text$x:00002E4E                 jz      $LN5_1
.text$x:00002E54                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002E58                 mov     ecx, [ebp+8]
.text$x:00002E5B                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00002E60 ; ---------------------------------------------------------------------------
.text$x:00002E60
.text$x:00002E60 $LN5_1:                                 ; CODE XREF: __unwindfunclet$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z$1+6j
.text$x:00002E60                 retn
.text$x:00002E60 __unwindfunclet$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z$1 endp
.text$x:00002E60
.text$x:00002E61
.text$x:00002E61 ; =============== S U B R O U T I N E =======================================
.text$x:00002E61
.text$x:00002E61
.text$x:00002E61 __ehhandler$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z proc near
.text$x:00002E61                                         ; DATA XREF: std::_Unchecked<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+5o
.text$x:00002E61
.text$x:00002E61 arg_4           = dword ptr  8
.text$x:00002E61
.text$x:00002E61                 mov     edx, [esp+arg_4]
.text$x:00002E65                 lea     eax, [edx+0Ch]
.text$x:00002E68                 mov     ecx, [edx-8]
.text$x:00002E6B                 xor     ecx, eax
.text$x:00002E6D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E72                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z
.text$x:00002E77                 jmp     ___CxxFrameHandler3
.text$x:00002E77 __ehhandler$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z endp
.text$x:00002E77
.text$x:00002E77 _text$x         ends
.text$x:00002E77
.text$mn:00002E7C ; ===========================================================================
.text$mn:00002E7C
.text$mn:00002E7C ; Segment type: Pure code
.text$mn:00002E7C ; Segment permissions: Read/Execute
.text$mn:00002E7C _text$mn        segment para public 'CODE' use32
.text$mn:00002E7C                 assume cs:_text$mn
.text$mn:00002E7C                 ;org 2E7Ch
.text$mn:00002E7C ; COMDAT (pick any)
.text$mn:00002E7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E7C
.text$mn:00002E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E7C
.text$mn:00002E7C ; Attributes: bp-based frame
.text$mn:00002E7C
.text$mn:00002E7C ; int __cdecl std::_Uninit_copy<unsigned char const,unsigned char>(void *Src, int, void *Dst)
.text$mn:00002E7C                 public ??$_Uninit_copy@$$CBEE@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002E7C ??$_Uninit_copy@$$CBEE@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002E7C                                         ; CODE XREF: std::_Uninit_copy<uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+2Cp
.text$mn:00002E7C
.text$mn:00002E7C Size            = dword ptr -4
.text$mn:00002E7C Src             = dword ptr  8
.text$mn:00002E7C arg_4           = dword ptr  0Ch
.text$mn:00002E7C Dst             = dword ptr  10h
.text$mn:00002E7C
.text$mn:00002E7C                 push    ebp
.text$mn:00002E7D                 mov     ebp, esp
.text$mn:00002E7F                 push    ecx
.text$mn:00002E80                 push    192h            ; unsigned int
.text$mn:00002E85                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002E8A                 mov     eax, [ebp+arg_4]
.text$mn:00002E8D                 push    eax             ; int
.text$mn:00002E8E                 mov     ecx, [ebp+Src]
.text$mn:00002E91                 push    ecx             ; int
.text$mn:00002E92                 call    ??$_Debug_range@PBE@std@@YAXPBE0PB_WI@Z ; std::_Debug_range<uchar const *>(uchar const *,uchar const *,wchar_t const *,uint)
.text$mn:00002E97                 add     esp, 10h
.text$mn:00002E9A                 push    193h            ; unsigned int
.text$mn:00002E9F                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002EA4                 mov     edx, [ebp+Dst]
.text$mn:00002EA7                 push    edx             ; int
.text$mn:00002EA8                 call    ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)
.text$mn:00002EAD                 add     esp, 0Ch
.text$mn:00002EB0                 mov     eax, [ebp+arg_4]
.text$mn:00002EB3                 sub     eax, [ebp+Src]
.text$mn:00002EB6                 mov     [ebp+Size], eax
.text$mn:00002EB9                 mov     ecx, [ebp+Size]
.text$mn:00002EBC                 push    ecx             ; Size
.text$mn:00002EBD                 mov     edx, [ebp+Src]
.text$mn:00002EC0                 push    edx             ; Src
.text$mn:00002EC1                 mov     eax, [ebp+Dst]
.text$mn:00002EC4                 push    eax             ; Dst
.text$mn:00002EC5                 call    _memmove
.text$mn:00002ECA                 add     esp, 0Ch
.text$mn:00002ECD                 add     eax, [ebp+Size]
.text$mn:00002ED0                 mov     esp, ebp
.text$mn:00002ED2                 pop     ebp
.text$mn:00002ED3                 retn
.text$mn:00002ED3 ??$_Uninit_copy@$$CBEE@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002ED3
.text$mn:00002ED3 _text$mn        ends
.text$mn:00002ED3
.text$mn:00002ED4 ; ===========================================================================
.text$mn:00002ED4
.text$mn:00002ED4 ; Segment type: Pure code
.text$mn:00002ED4 ; Segment permissions: Read/Execute
.text$mn:00002ED4 _text$mn        segment para public 'CODE' use32
.text$mn:00002ED4                 assume cs:_text$mn
.text$mn:00002ED4                 ;org 2ED4h
.text$mn:00002ED4 ; COMDAT (pick any)
.text$mn:00002ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002ED4
.text$mn:00002ED4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002ED4
.text$mn:00002ED4 ; Attributes: bp-based frame
.text$mn:00002ED4
.text$mn:00002ED4 ; int __cdecl std::_Uninit_copy<unsigned char,unsigned char>(void *Src, int, void *Dst)
.text$mn:00002ED4                 public ??$_Uninit_copy@EE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002ED4 ??$_Uninit_copy@EE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002ED4                                         ; CODE XREF: std::_Uninit_copy<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+2Cp
.text$mn:00002ED4
.text$mn:00002ED4 Size            = dword ptr -4
.text$mn:00002ED4 Src             = dword ptr  8
.text$mn:00002ED4 arg_4           = dword ptr  0Ch
.text$mn:00002ED4 Dst             = dword ptr  10h
.text$mn:00002ED4
.text$mn:00002ED4                 push    ebp
.text$mn:00002ED5                 mov     ebp, esp
.text$mn:00002ED7                 push    ecx
.text$mn:00002ED8                 push    192h            ; unsigned int
.text$mn:00002EDD                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002EE2                 mov     eax, [ebp+arg_4]
.text$mn:00002EE5                 push    eax             ; int
.text$mn:00002EE6                 mov     ecx, [ebp+Src]
.text$mn:00002EE9                 push    ecx             ; int
.text$mn:00002EEA                 call    ??$_Debug_range@PAE@std@@YAXPAE0PB_WI@Z ; std::_Debug_range<uchar *>(uchar *,uchar *,wchar_t const *,uint)
.text$mn:00002EEF                 add     esp, 10h
.text$mn:00002EF2                 push    193h            ; unsigned int
.text$mn:00002EF7                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002EFC                 mov     edx, [ebp+Dst]
.text$mn:00002EFF                 push    edx             ; int
.text$mn:00002F00                 call    ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)
.text$mn:00002F05                 add     esp, 0Ch
.text$mn:00002F08                 mov     eax, [ebp+arg_4]
.text$mn:00002F0B                 sub     eax, [ebp+Src]
.text$mn:00002F0E                 mov     [ebp+Size], eax
.text$mn:00002F11                 mov     ecx, [ebp+Size]
.text$mn:00002F14                 push    ecx             ; Size
.text$mn:00002F15                 mov     edx, [ebp+Src]
.text$mn:00002F18                 push    edx             ; Src
.text$mn:00002F19                 mov     eax, [ebp+Dst]
.text$mn:00002F1C                 push    eax             ; Dst
.text$mn:00002F1D                 call    _memmove
.text$mn:00002F22                 add     esp, 0Ch
.text$mn:00002F25                 add     eax, [ebp+Size]
.text$mn:00002F28                 mov     esp, ebp
.text$mn:00002F2A                 pop     ebp
.text$mn:00002F2B                 retn
.text$mn:00002F2B ??$_Uninit_copy@EE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002F2B
.text$mn:00002F2B _text$mn        ends
.text$mn:00002F2B
.text$mn:00002F2C ; ===========================================================================
.text$mn:00002F2C
.text$mn:00002F2C ; Segment type: Pure code
.text$mn:00002F2C ; Segment permissions: Read/Execute
.text$mn:00002F2C _text$mn        segment para public 'CODE' use32
.text$mn:00002F2C                 assume cs:_text$mn
.text$mn:00002F2C                 ;org 2F2Ch
.text$mn:00002F2C ; COMDAT (pick any)
.text$mn:00002F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F2C
.text$mn:00002F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F2C
.text$mn:00002F2C ; Attributes: bp-based frame
.text$mn:00002F2C
.text$mn:00002F2C ; int __cdecl std::_Uninit_copy<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char>>>(void *Src, int, void *Dst, int)
.text$mn:00002F2C                 public ??$_Uninit_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00002F2C ??$_Uninit_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:00002F2C                                         ; CODE XREF: std::_Uninitialized_copy<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+2Ep
.text$mn:00002F2C
.text$mn:00002F2C var_1           = byte ptr -1
.text$mn:00002F2C Src             = dword ptr  8
.text$mn:00002F2C arg_4           = dword ptr  0Ch
.text$mn:00002F2C Dst             = dword ptr  10h
.text$mn:00002F2C arg_C           = dword ptr  14h
.text$mn:00002F2C
.text$mn:00002F2C                 push    ebp
.text$mn:00002F2D                 mov     ebp, esp
.text$mn:00002F2F                 push    ecx
.text$mn:00002F30                 mov     eax, [ebp+Dst]
.text$mn:00002F33                 push    eax
.text$mn:00002F34                 mov     ecx, [ebp+Src]
.text$mn:00002F37                 push    ecx
.text$mn:00002F38                 call    ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z ; std::_Ptr_cat<uchar,uchar>(uchar *,uchar *)
.text$mn:00002F3D                 add     esp, 8
.text$mn:00002F40                 mov     [ebp+var_1], al
.text$mn:00002F43                 movzx   edx, [ebp+var_1]
.text$mn:00002F47                 push    edx
.text$mn:00002F48                 mov     eax, [ebp+arg_C]
.text$mn:00002F4B                 push    eax
.text$mn:00002F4C                 mov     ecx, [ebp+Dst]
.text$mn:00002F4F                 push    ecx             ; Dst
.text$mn:00002F50                 mov     edx, [ebp+arg_4]
.text$mn:00002F53                 push    edx             ; int
.text$mn:00002F54                 mov     eax, [ebp+Src]
.text$mn:00002F57                 push    eax             ; Src
.text$mn:00002F58                 call    ??$_Uninit_copy@EE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<uchar,uchar>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002F5D                 add     esp, 14h
.text$mn:00002F60                 mov     esp, ebp
.text$mn:00002F62                 pop     ebp
.text$mn:00002F63                 retn
.text$mn:00002F63 ??$_Uninit_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:00002F63
.text$mn:00002F63 _text$mn        ends
.text$mn:00002F63
.text$mn:00002F64 ; ===========================================================================
.text$mn:00002F64
.text$mn:00002F64 ; Segment type: Pure code
.text$mn:00002F64 ; Segment permissions: Read/Execute
.text$mn:00002F64 _text$mn        segment para public 'CODE' use32
.text$mn:00002F64                 assume cs:_text$mn
.text$mn:00002F64                 ;org 2F64h
.text$mn:00002F64 ; COMDAT (pick any)
.text$mn:00002F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F64
.text$mn:00002F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F64
.text$mn:00002F64 ; Attributes: bp-based frame
.text$mn:00002F64
.text$mn:00002F64 ; int __cdecl std::_Uninit_copy<unsigned char const *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char>>>(void *Src, int, void *Dst, int)
.text$mn:00002F64                 public ??$_Uninit_copy@PBEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00002F64 ??$_Uninit_copy@PBEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:00002F64                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+9Fp
.text$mn:00002F64
.text$mn:00002F64 var_1           = byte ptr -1
.text$mn:00002F64 Src             = dword ptr  8
.text$mn:00002F64 arg_4           = dword ptr  0Ch
.text$mn:00002F64 Dst             = dword ptr  10h
.text$mn:00002F64 arg_C           = dword ptr  14h
.text$mn:00002F64
.text$mn:00002F64                 push    ebp
.text$mn:00002F65                 mov     ebp, esp
.text$mn:00002F67                 push    ecx
.text$mn:00002F68                 mov     eax, [ebp+Dst]
.text$mn:00002F6B                 push    eax
.text$mn:00002F6C                 mov     ecx, [ebp+Src]
.text$mn:00002F6F                 push    ecx
.text$mn:00002F70                 call    ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBEPAE@Z ; std::_Ptr_cat<uchar,uchar>(uchar const *,uchar *)
.text$mn:00002F75                 add     esp, 8
.text$mn:00002F78                 mov     [ebp+var_1], al
.text$mn:00002F7B                 movzx   edx, [ebp+var_1]
.text$mn:00002F7F                 push    edx
.text$mn:00002F80                 mov     eax, [ebp+arg_C]
.text$mn:00002F83                 push    eax
.text$mn:00002F84                 mov     ecx, [ebp+Dst]
.text$mn:00002F87                 push    ecx             ; Dst
.text$mn:00002F88                 mov     edx, [ebp+arg_4]
.text$mn:00002F8B                 push    edx             ; int
.text$mn:00002F8C                 mov     eax, [ebp+Src]
.text$mn:00002F8F                 push    eax             ; Src
.text$mn:00002F90                 call    ??$_Uninit_copy@$$CBEE@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<uchar const,uchar>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002F95                 add     esp, 14h
.text$mn:00002F98                 mov     esp, ebp
.text$mn:00002F9A                 pop     ebp
.text$mn:00002F9B                 retn
.text$mn:00002F9B ??$_Uninit_copy@PBEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:00002F9B
.text$mn:00002F9B _text$mn        ends
.text$mn:00002F9B
.text$mn:00002F9C ; ===========================================================================
.text$mn:00002F9C
.text$mn:00002F9C ; Segment type: Pure code
.text$mn:00002F9C ; Segment permissions: Read/Execute
.text$mn:00002F9C _text$mn        segment para public 'CODE' use32
.text$mn:00002F9C                 assume cs:_text$mn
.text$mn:00002F9C                 ;org 2F9Ch
.text$mn:00002F9C ; COMDAT (pick any)
.text$mn:00002F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F9C
.text$mn:00002F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F9C
.text$mn:00002F9C ; Attributes: bp-based frame
.text$mn:00002F9C
.text$mn:00002F9C ; int __cdecl std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>>,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char>>>(char, int, int, int, int, int, void *, int)
.text$mn:00002F9C                 public ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00002F9C ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:00002F9C                                         ; CODE XREF: std::_Uninitialized_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+C2p
.text$mn:00002F9C
.text$mn:00002F9C var_30          = dword ptr -30h
.text$mn:00002F9C var_2C          = dword ptr -2Ch
.text$mn:00002F9C var_28          = dword ptr -28h
.text$mn:00002F9C var_24          = dword ptr -24h
.text$mn:00002F9C var_20          = dword ptr -20h
.text$mn:00002F9C var_1C          = dword ptr -1Ch
.text$mn:00002F9C var_18          = dword ptr -18h
.text$mn:00002F9C var_14          = dword ptr -14h
.text$mn:00002F9C var_D           = byte ptr -0Dh
.text$mn:00002F9C var_C           = dword ptr -0Ch
.text$mn:00002F9C var_4           = dword ptr -4
.text$mn:00002F9C arg_0           = byte ptr  8
.text$mn:00002F9C arg_C           = dword ptr  14h
.text$mn:00002F9C arg_18          = dword ptr  20h
.text$mn:00002F9C arg_1C          = dword ptr  24h
.text$mn:00002F9C
.text$mn:00002F9C                 push    ebp
.text$mn:00002F9D                 mov     ebp, esp
.text$mn:00002F9F                 push    0FFFFFFFFh
.text$mn:00002FA1                 push    offset __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00002FA6                 mov     eax, large fs:0
.text$mn:00002FAC                 push    eax
.text$mn:00002FAD                 sub     esp, 24h
.text$mn:00002FB0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FB5                 xor     eax, ebp
.text$mn:00002FB7                 push    eax
.text$mn:00002FB8                 lea     eax, [ebp+var_C]
.text$mn:00002FBB                 mov     large fs:0, eax
.text$mn:00002FC1                 mov     [ebp+var_4], 1
.text$mn:00002FC8                 lea     eax, [ebp+arg_18]
.text$mn:00002FCB                 push    eax
.text$mn:00002FCC                 lea     ecx, [ebp+arg_0]
.text$mn:00002FCF                 push    ecx
.text$mn:00002FD0                 call    ??$_Ptr_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAE@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@AAPAE@Z ; std::_Ptr_cat<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,uchar * &)
.text$mn:00002FD5                 add     esp, 8
.text$mn:00002FD8                 mov     [ebp+var_D], al
.text$mn:00002FDB                 movzx   edx, [ebp+var_D]
.text$mn:00002FDF                 push    edx
.text$mn:00002FE0                 mov     eax, [ebp+arg_1C]
.text$mn:00002FE3                 push    eax             ; int
.text$mn:00002FE4                 mov     ecx, [ebp+arg_18]
.text$mn:00002FE7                 push    ecx             ; void *
.text$mn:00002FE8                 sub     esp, 0Ch
.text$mn:00002FEB                 mov     ecx, esp
.text$mn:00002FED                 mov     [ebp+var_24], esp
.text$mn:00002FF0                 lea     edx, [ebp+arg_C]
.text$mn:00002FF3                 push    edx             ; int
.text$mn:00002FF4                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00002FF9                 mov     [ebp+var_14], eax
.text$mn:00002FFC                 mov     eax, [ebp+var_14]
.text$mn:00002FFF                 mov     [ebp+var_28], eax
.text$mn:00003002                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003006                 sub     esp, 0Ch
.text$mn:00003009                 mov     ecx, esp
.text$mn:0000300B                 mov     [ebp+var_2C], esp
.text$mn:0000300E                 lea     edx, [ebp+arg_0]
.text$mn:00003011                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003012                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00003017                 mov     [ebp+var_18], eax
.text$mn:0000301A                 mov     eax, [ebp+var_18]
.text$mn:0000301D                 mov     [ebp+var_30], eax
.text$mn:00003020                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003024                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003028                 call    ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000302D                 add     esp, 24h
.text$mn:00003030                 mov     [ebp+var_1C], eax
.text$mn:00003033                 mov     ecx, [ebp+var_1C]
.text$mn:00003036                 mov     [ebp+var_20], ecx
.text$mn:00003039                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000303D                 lea     ecx, [ebp+arg_0]
.text$mn:00003040                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00003045                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000304C                 lea     ecx, [ebp+arg_C]
.text$mn:0000304F                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00003054                 mov     eax, [ebp+var_20]
.text$mn:00003057                 mov     ecx, [ebp+var_C]
.text$mn:0000305A                 mov     large fs:0, ecx
.text$mn:00003061                 pop     ecx
.text$mn:00003062                 mov     esp, ebp
.text$mn:00003064                 pop     ebp
.text$mn:00003065                 retn
.text$mn:00003065 ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:00003065
.text$mn:00003065 ; ---------------------------------------------------------------------------
.text$mn:00003066                 align 4
.text$mn:00003066 _text$mn        ends
.text$mn:00003066
.text$x:00003068 ; ===========================================================================
.text$x:00003068
.text$x:00003068 ; Segment type: Pure code
.text$x:00003068 ; Segment permissions: Read/Execute
.text$x:00003068 _text$x         segment para public 'CODE' use32
.text$x:00003068                 assume cs:_text$x
.text$x:00003068                 ;org 3068h
.text$x:00003068 ; COMDAT (pick associative to section at 2F9C)
.text$x:00003068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003068
.text$x:00003068 ; =============== S U B R O U T I N E =======================================
.text$x:00003068
.text$x:00003068
.text$x:00003068 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0 proc near
.text$x:00003068                                         ; DATA XREF: .xdata$x:0000A280o
.text$x:00003068                 lea     ecx, [ebp+14h]
.text$x:0000306B                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000306B __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0 endp
.text$x:0000306B
.text$x:00003070
.text$x:00003070 ; =============== S U B R O U T I N E =======================================
.text$x:00003070
.text$x:00003070
.text$x:00003070 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1 proc near
.text$x:00003070                                         ; DATA XREF: .xdata$x:0000A288o
.text$x:00003070                 lea     ecx, [ebp+8]
.text$x:00003073                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003073 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1 endp
.text$x:00003073
.text$x:00003078
.text$x:00003078 ; =============== S U B R O U T I N E =======================================
.text$x:00003078
.text$x:00003078
.text$x:00003078 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2 proc near
.text$x:00003078                                         ; DATA XREF: .xdata$x:0000A290o
.text$x:00003078                 mov     ecx, [ebp-24h]
.text$x:0000307B                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000307B __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2 endp
.text$x:0000307B
.text$x:00003080
.text$x:00003080 ; =============== S U B R O U T I N E =======================================
.text$x:00003080
.text$x:00003080
.text$x:00003080 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3 proc near
.text$x:00003080                                         ; DATA XREF: .xdata$x:0000A298o
.text$x:00003080                 mov     ecx, [ebp-2Ch]
.text$x:00003083                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003083 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3 endp
.text$x:00003083
.text$x:00003088
.text$x:00003088 ; =============== S U B R O U T I N E =======================================
.text$x:00003088
.text$x:00003088
.text$x:00003088 __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$x:00003088                                         ; DATA XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+5o
.text$x:00003088
.text$x:00003088 arg_4           = dword ptr  8
.text$x:00003088
.text$x:00003088                 mov     edx, [esp+arg_4]
.text$x:0000308C                 lea     eax, [edx+0Ch]
.text$x:0000308F                 mov     ecx, [edx-28h]
.text$x:00003092                 xor     ecx, eax
.text$x:00003094                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003099                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$x:0000309E                 jmp     ___CxxFrameHandler3
.text$x:0000309E __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$x:0000309E
.text$x:0000309E ; ---------------------------------------------------------------------------
.text$x:000030A3                 align 4
.text$x:000030A3 _text$x         ends
.text$x:000030A3
.text$mn:000030A4 ; ===========================================================================
.text$mn:000030A4
.text$mn:000030A4 ; Segment type: Pure code
.text$mn:000030A4 ; Segment permissions: Read/Execute
.text$mn:000030A4 _text$mn        segment para public 'CODE' use32
.text$mn:000030A4                 assume cs:_text$mn
.text$mn:000030A4                 ;org 30A4h
.text$mn:000030A4 ; COMDAT (pick any)
.text$mn:000030A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000030A4
.text$mn:000030A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000030A4
.text$mn:000030A4 ; Attributes: bp-based frame
.text$mn:000030A4
.text$mn:000030A4 ; int __cdecl std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>>,unsigned char *,std::allocator<unsigned char>>(char, int, int, int, int, int, void *, int)
.text$mn:000030A4                 public ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000030A4 ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000030A4                                         ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+8Cp
.text$mn:000030A4
.text$mn:000030A4 var_30          = dword ptr -30h
.text$mn:000030A4 var_2C          = dword ptr -2Ch
.text$mn:000030A4 var_28          = dword ptr -28h
.text$mn:000030A4 var_24          = dword ptr -24h
.text$mn:000030A4 var_20          = dword ptr -20h
.text$mn:000030A4 var_1C          = dword ptr -1Ch
.text$mn:000030A4 var_18          = dword ptr -18h
.text$mn:000030A4 var_14          = dword ptr -14h
.text$mn:000030A4 var_10          = dword ptr -10h
.text$mn:000030A4 var_C           = dword ptr -0Ch
.text$mn:000030A4 var_4           = dword ptr -4
.text$mn:000030A4 arg_0           = byte ptr  8
.text$mn:000030A4 arg_C           = dword ptr  14h
.text$mn:000030A4 arg_18          = dword ptr  20h
.text$mn:000030A4 arg_1C          = dword ptr  24h
.text$mn:000030A4
.text$mn:000030A4 ; FUNCTION CHUNK AT .text$mn:000031BC SIZE 00000009 BYTES
.text$mn:000030A4 ; FUNCTION CHUNK AT .text$mn:000031CC SIZE 00000036 BYTES
.text$mn:000030A4
.text$mn:000030A4                 push    ebp
.text$mn:000030A5                 mov     ebp, esp
.text$mn:000030A7                 push    0FFFFFFFFh
.text$mn:000030A9                 push    offset __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000030AE                 mov     eax, large fs:0
.text$mn:000030B4                 push    eax
.text$mn:000030B5                 push    ecx
.text$mn:000030B6                 sub     esp, 20h
.text$mn:000030B9                 push    ebx
.text$mn:000030BA                 push    esi
.text$mn:000030BB                 push    edi
.text$mn:000030BC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030C1                 xor     eax, ebp
.text$mn:000030C3                 push    eax
.text$mn:000030C4                 lea     eax, [ebp+var_C]
.text$mn:000030C7                 mov     large fs:0, eax
.text$mn:000030CD                 mov     [ebp+var_10], esp
.text$mn:000030D0                 mov     [ebp+var_4], 1
.text$mn:000030D7                 push    174h            ; unsigned int
.text$mn:000030DC                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000030E1                 sub     esp, 0Ch
.text$mn:000030E4                 mov     ecx, esp
.text$mn:000030E6                 mov     [ebp+var_24], esp
.text$mn:000030E9                 lea     eax, [ebp+arg_C]
.text$mn:000030EC                 push    eax             ; int
.text$mn:000030ED                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:000030F2                 mov     [ebp+var_18], eax
.text$mn:000030F5                 mov     ecx, [ebp+var_18]
.text$mn:000030F8                 mov     [ebp+var_28], ecx
.text$mn:000030FB                 mov     byte ptr [ebp+var_4], 2
.text$mn:000030FF                 sub     esp, 0Ch
.text$mn:00003102                 mov     ecx, esp
.text$mn:00003104                 mov     [ebp+var_2C], esp
.text$mn:00003107                 lea     edx, [ebp+arg_0]
.text$mn:0000310A                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000310B                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00003110                 mov     [ebp+var_1C], eax
.text$mn:00003113                 mov     eax, [ebp+var_1C]
.text$mn:00003116                 mov     [ebp+var_30], eax
.text$mn:00003119                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000311D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003121                 call    ??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,wchar_t const *,uint)
.text$mn:00003126                 add     esp, 20h
.text$mn:00003129                 push    175h            ; unsigned int
.text$mn:0000312E                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003133                 mov     ecx, [ebp+arg_18]
.text$mn:00003136                 push    ecx             ; int
.text$mn:00003137                 call    ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)
.text$mn:0000313C                 add     esp, 0Ch
.text$mn:0000313F                 mov     edx, [ebp+arg_18]
.text$mn:00003142                 mov     [ebp+var_14], edx
.text$mn:00003145                 mov     byte ptr [ebp+var_4], 4
.text$mn:00003149                 jmp     short loc_315C
.text$mn:0000314B ; ---------------------------------------------------------------------------
.text$mn:0000314B
.text$mn:0000314B loc_314B:                               ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+E4j
.text$mn:0000314B                 mov     eax, [ebp+arg_18]
.text$mn:0000314E                 add     eax, 1
.text$mn:00003151                 mov     [ebp+arg_18], eax
.text$mn:00003154                 lea     ecx, [ebp+arg_0]
.text$mn:00003157                 call    ??E?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::operator++(void)
.text$mn:0000315C
.text$mn:0000315C loc_315C:                               ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+A5j
.text$mn:0000315C                 lea     ecx, [ebp+arg_C]
.text$mn:0000315F                 push    ecx
.text$mn:00003160                 lea     edx, [ebp+arg_0]
.text$mn:00003163                 push    edx
.text$mn:00003164                 call    ??$?9V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YA_NABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z ; std::operator!=<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00003169                 add     esp, 8
.text$mn:0000316C                 movzx   eax, al
.text$mn:0000316F                 test    eax, eax
.text$mn:00003171                 jz      short loc_318A
.text$mn:00003173                 lea     ecx, [ebp+arg_0]
.text$mn:00003176                 call    ??D?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE$$QAEXZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::operator*(void)
.text$mn:0000317B                 push    eax             ; int
.text$mn:0000317C                 mov     ecx, [ebp+arg_18]
.text$mn:0000317F                 push    ecx             ; void *
.text$mn:00003180                 mov     ecx, [ebp+arg_1C]
.text$mn:00003183                 call    ??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z ; std::_Wrap_alloc<std::allocator<uchar>>::construct<uchar,uchar>(uchar *,uchar &&)
.text$mn:00003188                 jmp     short loc_314B
.text$mn:0000318A ; ---------------------------------------------------------------------------
.text$mn:0000318A
.text$mn:0000318A loc_318A:                               ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+CDj
.text$mn:0000318A                 jmp     short loc_31BC
.text$mn:0000318A ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000318A
.text$mn:0000318C
.text$mn:0000318C ; =============== S U B R O U T I N E =======================================
.text$mn:0000318C
.text$mn:0000318C ; Attributes: noreturn
.text$mn:0000318C
.text$mn:0000318C __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:0000318C                                         ; DATA XREF: .xdata$x:0000A2CCo
.text$mn:0000318C                 jmp     short loc_3197
.text$mn:0000318E ; ---------------------------------------------------------------------------
.text$mn:0000318E
.text$mn:0000318E loc_318E:                               ; CODE XREF: __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:0000318E                 mov     edx, [ebp-14h]
.text$mn:00003191                 add     edx, 1
.text$mn:00003194                 mov     [ebp-14h], edx
.text$mn:00003197
.text$mn:00003197 loc_3197:                               ; CODE XREF: __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:00003197                 mov     eax, [ebp-14h]
.text$mn:0000319A                 cmp     eax, [ebp+20h]
.text$mn:0000319D                 jz      short loc_31AD
.text$mn:0000319F                 mov     ecx, [ebp-14h]
.text$mn:000031A2                 push    ecx
.text$mn:000031A3                 mov     ecx, [ebp+24h]
.text$mn:000031A6                 call    ??$destroy@E@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE@Z ; std::_Wrap_alloc<std::allocator<uchar>>::destroy<uchar>(uchar *)
.text$mn:000031AB                 jmp     short loc_318E
.text$mn:000031AD ; ---------------------------------------------------------------------------
.text$mn:000031AD
.text$mn:000031AD loc_31AD:                               ; CODE XREF: __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:000031AD                 push    0
.text$mn:000031AF                 push    0
.text$mn:000031B1                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000031B1 __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000031B1
.text$mn:000031B6 ; ---------------------------------------------------------------------------
.text$mn:000031B6                 mov     eax, offset $LN17_1
.text$mn:000031BB                 retn
.text$mn:000031BC ; ---------------------------------------------------------------------------
.text$mn:000031BC ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000031BC
.text$mn:000031BC loc_31BC:                               ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag):loc_318Aj
.text$mn:000031BC                 mov     [ebp+var_4], 1
.text$mn:000031C3                 jmp     short loc_31CC
.text$mn:000031C3 ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000031C5
.text$mn:000031C5 ; =============== S U B R O U T I N E =======================================
.text$mn:000031C5
.text$mn:000031C5
.text$mn:000031C5 $LN17_1         proc near               ; DATA XREF: .text$mn:000031B6o
.text$mn:000031C5                 mov     dword ptr [ebp-4], 1
.text$mn:000031C5 $LN17_1         endp ; sp-analysis failed
.text$mn:000031C5
.text$mn:000031CC ; START OF FUNCTION CHUNK FOR ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000031CC
.text$mn:000031CC loc_31CC:                               ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+11Fj
.text$mn:000031CC                 mov     edx, [ebp+arg_18]
.text$mn:000031CF                 mov     [ebp+var_20], edx
.text$mn:000031D2                 mov     byte ptr [ebp+var_4], 0
.text$mn:000031D6                 lea     ecx, [ebp+arg_0]
.text$mn:000031D9                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:000031DE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031E5                 lea     ecx, [ebp+arg_C]
.text$mn:000031E8                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:000031ED                 mov     eax, [ebp+var_20]
.text$mn:000031F0                 mov     ecx, [ebp+var_C]
.text$mn:000031F3                 mov     large fs:0, ecx
.text$mn:000031FA                 pop     ecx
.text$mn:000031FB                 pop     edi
.text$mn:000031FC                 pop     esi
.text$mn:000031FD                 pop     ebx
.text$mn:000031FE                 mov     esp, ebp
.text$mn:00003200                 pop     ebp
.text$mn:00003201                 retn
.text$mn:00003201 ; END OF FUNCTION CHUNK FOR ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003201 ; ---------------------------------------------------------------------------
.text$mn:00003202                 align 4
.text$mn:00003202 _text$mn        ends
.text$mn:00003202
.text$x:00003204 ; ===========================================================================
.text$x:00003204
.text$x:00003204 ; Segment type: Pure code
.text$x:00003204 ; Segment permissions: Read/Execute
.text$x:00003204 _text$x         segment para public 'CODE' use32
.text$x:00003204                 assume cs:_text$x
.text$x:00003204                 ;org 3204h
.text$x:00003204 ; COMDAT (pick associative to section at 30A4)
.text$x:00003204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003204
.text$x:00003204 ; =============== S U B R O U T I N E =======================================
.text$x:00003204
.text$x:00003204
.text$x:00003204 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 proc near
.text$x:00003204                                         ; DATA XREF: .xdata$x:0000A30Co
.text$x:00003204                 lea     ecx, [ebp+14h]
.text$x:00003207                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003207 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2 endp
.text$x:00003207
.text$x:0000320C
.text$x:0000320C ; =============== S U B R O U T I N E =======================================
.text$x:0000320C
.text$x:0000320C
.text$x:0000320C __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$3 proc near
.text$x:0000320C                                         ; DATA XREF: .xdata$x:0000A314o
.text$x:0000320C                 lea     ecx, [ebp+8]
.text$x:0000320F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000320F __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$3 endp
.text$x:0000320F
.text$x:00003214
.text$x:00003214 ; =============== S U B R O U T I N E =======================================
.text$x:00003214
.text$x:00003214
.text$x:00003214 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$4 proc near
.text$x:00003214                                         ; DATA XREF: .xdata$x:0000A31Co
.text$x:00003214                 mov     ecx, [ebp-24h]
.text$x:00003217                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003217 __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$4 endp
.text$x:00003217
.text$x:0000321C
.text$x:0000321C ; =============== S U B R O U T I N E =======================================
.text$x:0000321C
.text$x:0000321C
.text$x:0000321C __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$5 proc near
.text$x:0000321C                                         ; DATA XREF: .xdata$x:0000A324o
.text$x:0000321C                 mov     ecx, [ebp-2Ch]
.text$x:0000321F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000321F __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$5 endp
.text$x:0000321F
.text$x:00003224
.text$x:00003224 ; =============== S U B R O U T I N E =======================================
.text$x:00003224
.text$x:00003224
.text$x:00003224 __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:00003224                                         ; DATA XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:00003224
.text$x:00003224 arg_4           = dword ptr  8
.text$x:00003224
.text$x:00003224                 mov     edx, [esp+arg_4]
.text$x:00003228                 lea     eax, [edx+0Ch]
.text$x:0000322B                 mov     ecx, [edx-34h]
.text$x:0000322E                 xor     ecx, eax
.text$x:00003230                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003235                 mov     eax, offset __ehfuncinfo$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000323A                 jmp     ___CxxFrameHandler3
.text$x:0000323A __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000323A
.text$x:0000323A ; ---------------------------------------------------------------------------
.text$x:0000323F                 align 10h
.text$x:0000323F _text$x         ends
.text$x:0000323F
.text$mn:00003240 ; ===========================================================================
.text$mn:00003240
.text$mn:00003240 ; Segment type: Pure code
.text$mn:00003240 ; Segment permissions: Read/Execute
.text$mn:00003240 _text$mn        segment para public 'CODE' use32
.text$mn:00003240                 assume cs:_text$mn
.text$mn:00003240                 ;org 3240h
.text$mn:00003240 ; COMDAT (pick any)
.text$mn:00003240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003240
.text$mn:00003240 ; =============== S U B R O U T I N E =======================================
.text$mn:00003240
.text$mn:00003240 ; Attributes: bp-based frame
.text$mn:00003240
.text$mn:00003240 ; int __cdecl std::_Uninit_fill_n<std::vector<unsigned char,std::allocator<unsigned char>> *,unsigned int,std::vector<unsigned char,std::allocator<unsigned char>>,std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>,std::vector<unsigned char,std::allocator<unsigned char>>>(void *, int, int, int)
.text$mn:00003240                 public ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003240 ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003240                                         ; CODE XREF: std::_Uninitialized_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+39p
.text$mn:00003240
.text$mn:00003240 var_14          = dword ptr -14h
.text$mn:00003240 var_10          = dword ptr -10h
.text$mn:00003240 var_C           = dword ptr -0Ch
.text$mn:00003240 var_4           = dword ptr -4
.text$mn:00003240 arg_0           = dword ptr  8
.text$mn:00003240 arg_4           = dword ptr  0Ch
.text$mn:00003240 arg_8           = dword ptr  10h
.text$mn:00003240 arg_C           = dword ptr  14h
.text$mn:00003240
.text$mn:00003240 ; FUNCTION CHUNK AT .text$mn:000032D5 SIZE 00000009 BYTES
.text$mn:00003240 ; FUNCTION CHUNK AT .text$mn:000032E5 SIZE 00000012 BYTES
.text$mn:00003240
.text$mn:00003240                 push    ebp
.text$mn:00003241                 mov     ebp, esp
.text$mn:00003243                 push    0FFFFFFFFh
.text$mn:00003245                 push    offset __ehhandler$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:0000324A                 mov     eax, large fs:0
.text$mn:00003250                 push    eax
.text$mn:00003251                 push    ecx
.text$mn:00003252                 push    ecx
.text$mn:00003253                 push    ebx
.text$mn:00003254                 push    esi
.text$mn:00003255                 push    edi
.text$mn:00003256                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000325B                 xor     eax, ebp
.text$mn:0000325D                 push    eax
.text$mn:0000325E                 lea     eax, [ebp+var_C]
.text$mn:00003261                 mov     large fs:0, eax
.text$mn:00003267                 mov     [ebp+var_10], esp
.text$mn:0000326A                 mov     eax, [ebp+arg_0]
.text$mn:0000326D                 mov     [ebp+var_14], eax
.text$mn:00003270                 mov     [ebp+var_4], 0
.text$mn:00003277                 jmp     short loc_328B
.text$mn:00003279 ; ---------------------------------------------------------------------------
.text$mn:00003279
.text$mn:00003279 loc_3279:                               ; CODE XREF: std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+61j
.text$mn:00003279                 mov     ecx, [ebp+arg_4]
.text$mn:0000327C                 sub     ecx, 1
.text$mn:0000327F                 mov     [ebp+arg_4], ecx
.text$mn:00003282                 mov     edx, [ebp+arg_0]
.text$mn:00003285                 add     edx, 10h
.text$mn:00003288                 mov     [ebp+arg_0], edx
.text$mn:0000328B
.text$mn:0000328B loc_328B:                               ; CODE XREF: std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+37j
.text$mn:0000328B                 cmp     [ebp+arg_4], 0
.text$mn:0000328F                 jbe     short loc_32A3
.text$mn:00003291                 mov     eax, [ebp+arg_8]
.text$mn:00003294                 push    eax             ; int
.text$mn:00003295                 mov     ecx, [ebp+arg_0]
.text$mn:00003298                 push    ecx             ; void *
.text$mn:00003299                 mov     ecx, [ebp+arg_C]
.text$mn:0000329C                 call    ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@ABV21@@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>> const &>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:000032A1                 jmp     short loc_3279
.text$mn:000032A3 ; ---------------------------------------------------------------------------
.text$mn:000032A3
.text$mn:000032A3 loc_32A3:                               ; CODE XREF: std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+4Fj
.text$mn:000032A3                 jmp     short loc_32D5
.text$mn:000032A3 ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:000032A3
.text$mn:000032A5
.text$mn:000032A5 ; =============== S U B R O U T I N E =======================================
.text$mn:000032A5
.text$mn:000032A5 ; Attributes: noreturn
.text$mn:000032A5
.text$mn:000032A5 __catch$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:000032A5                                         ; DATA XREF: .xdata$x:00009D64o
.text$mn:000032A5                 jmp     short loc_32B0
.text$mn:000032A7 ; ---------------------------------------------------------------------------
.text$mn:000032A7
.text$mn:000032A7 loc_32A7:                               ; CODE XREF: __catch$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:000032A7                 mov     edx, [ebp-14h]
.text$mn:000032AA                 add     edx, 10h
.text$mn:000032AD                 mov     [ebp-14h], edx
.text$mn:000032B0
.text$mn:000032B0 loc_32B0:                               ; CODE XREF: __catch$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:000032B0                 mov     eax, [ebp-14h]
.text$mn:000032B3                 cmp     eax, [ebp+8]
.text$mn:000032B6                 jz      short loc_32C6
.text$mn:000032B8                 mov     ecx, [ebp-14h]
.text$mn:000032BB                 push    ecx
.text$mn:000032BC                 mov     ecx, [ebp+14h]
.text$mn:000032BF                 call    ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000032C4                 jmp     short loc_32A7
.text$mn:000032C6 ; ---------------------------------------------------------------------------
.text$mn:000032C6
.text$mn:000032C6 loc_32C6:                               ; CODE XREF: __catch$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:000032C6                 push    0
.text$mn:000032C8                 push    0
.text$mn:000032CA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000032CA __catch$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000032CA
.text$mn:000032CF ; ---------------------------------------------------------------------------
.text$mn:000032CF                 mov     eax, offset $LN13
.text$mn:000032D4                 retn
.text$mn:000032D5 ; ---------------------------------------------------------------------------
.text$mn:000032D5 ; START OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000032D5
.text$mn:000032D5 loc_32D5:                               ; CODE XREF: std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag):loc_32A3j
.text$mn:000032D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000032DC                 jmp     short loc_32E5
.text$mn:000032DC ; END OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000032DE
.text$mn:000032DE ; =============== S U B R O U T I N E =======================================
.text$mn:000032DE
.text$mn:000032DE
.text$mn:000032DE $LN13           proc near               ; DATA XREF: .text$mn:000032CFo
.text$mn:000032DE                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000032DE $LN13           endp ; sp-analysis failed
.text$mn:000032DE
.text$mn:000032E5 ; START OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000032E5
.text$mn:000032E5 loc_32E5:                               ; CODE XREF: std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+9Cj
.text$mn:000032E5                 mov     ecx, [ebp+var_C]
.text$mn:000032E8                 mov     large fs:0, ecx
.text$mn:000032EF                 pop     ecx
.text$mn:000032F0                 pop     edi
.text$mn:000032F1                 pop     esi
.text$mn:000032F2                 pop     ebx
.text$mn:000032F3                 mov     esp, ebp
.text$mn:000032F5                 pop     ebp
.text$mn:000032F6                 retn
.text$mn:000032F6 ; END OF FUNCTION CHUNK FOR ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000032F6 ; ---------------------------------------------------------------------------
.text$mn:000032F7                 align 4
.text$mn:000032F7 _text$mn        ends
.text$mn:000032F7
.text$x:000032F8 ; ===========================================================================
.text$x:000032F8
.text$x:000032F8 ; Segment type: Pure code
.text$x:000032F8 ; Segment permissions: Read/Execute
.text$x:000032F8 _text$x         segment para public 'CODE' use32
.text$x:000032F8                 assume cs:_text$x
.text$x:000032F8                 ;org 32F8h
.text$x:000032F8 ; COMDAT (pick associative to section at 3240)
.text$x:000032F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000032F8
.text$x:000032F8 ; =============== S U B R O U T I N E =======================================
.text$x:000032F8
.text$x:000032F8
.text$x:000032F8 __ehhandler$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:000032F8                                         ; DATA XREF: std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:000032F8
.text$x:000032F8 arg_4           = dword ptr  8
.text$x:000032F8
.text$x:000032F8                 mov     edx, [esp+arg_4]
.text$x:000032FC                 lea     eax, [edx+0Ch]
.text$x:000032FF                 mov     ecx, [edx-18h]
.text$x:00003302                 xor     ecx, eax
.text$x:00003304                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003309                 mov     eax, offset __ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:0000330E                 jmp     ___CxxFrameHandler3
.text$x:0000330E __ehhandler$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:0000330E
.text$x:0000330E ; ---------------------------------------------------------------------------
.text$x:00003313                 align 4
.text$x:00003313 _text$x         ends
.text$x:00003313
.text$mn:00003314 ; ===========================================================================
.text$mn:00003314
.text$mn:00003314 ; Segment type: Pure code
.text$mn:00003314 ; Segment permissions: Read/Execute
.text$mn:00003314 _text$mn        segment para public 'CODE' use32
.text$mn:00003314                 assume cs:_text$mn
.text$mn:00003314                 ;org 3314h
.text$mn:00003314 ; COMDAT (pick any)
.text$mn:00003314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003314
.text$mn:00003314 ; =============== S U B R O U T I N E =======================================
.text$mn:00003314
.text$mn:00003314 ; Attributes: bp-based frame
.text$mn:00003314
.text$mn:00003314 ; int __cdecl std::_Uninit_move<unsigned char,unsigned char,unsigned char>(void *Src, int, void *Dst)
.text$mn:00003314                 public ??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00003314 ??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00003314                                         ; CODE XREF: std::_Uninit_move<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+39p
.text$mn:00003314
.text$mn:00003314 Size            = dword ptr -4
.text$mn:00003314 Src             = dword ptr  8
.text$mn:00003314 arg_4           = dword ptr  0Ch
.text$mn:00003314 Dst             = dword ptr  10h
.text$mn:00003314
.text$mn:00003314                 push    ebp
.text$mn:00003315                 mov     ebp, esp
.text$mn:00003317                 push    ecx
.text$mn:00003318                 push    1D6h            ; unsigned int
.text$mn:0000331D                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003322                 mov     eax, [ebp+arg_4]
.text$mn:00003325                 push    eax             ; int
.text$mn:00003326                 mov     ecx, [ebp+Src]
.text$mn:00003329                 push    ecx             ; int
.text$mn:0000332A                 call    ??$_Debug_range@PAE@std@@YAXPAE0PB_WI@Z ; std::_Debug_range<uchar *>(uchar *,uchar *,wchar_t const *,uint)
.text$mn:0000332F                 add     esp, 10h
.text$mn:00003332                 push    1D7h            ; unsigned int
.text$mn:00003337                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000333C                 mov     edx, [ebp+Dst]
.text$mn:0000333F                 push    edx             ; int
.text$mn:00003340                 call    ??$_Debug_pointer@E@std@@YAXPAEPB_WI@Z ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)
.text$mn:00003345                 add     esp, 0Ch
.text$mn:00003348                 mov     eax, [ebp+arg_4]
.text$mn:0000334B                 sub     eax, [ebp+Src]
.text$mn:0000334E                 mov     [ebp+Size], eax
.text$mn:00003351                 mov     ecx, [ebp+Size]
.text$mn:00003354                 push    ecx             ; Size
.text$mn:00003355                 mov     edx, [ebp+Src]
.text$mn:00003358                 push    edx             ; Src
.text$mn:00003359                 mov     eax, [ebp+Dst]
.text$mn:0000335C                 push    eax             ; Dst
.text$mn:0000335D                 call    _memmove
.text$mn:00003362                 add     esp, 0Ch
.text$mn:00003365                 add     eax, [ebp+Size]
.text$mn:00003368                 mov     esp, ebp
.text$mn:0000336A                 pop     ebp
.text$mn:0000336B                 retn
.text$mn:0000336B ??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:0000336B
.text$mn:0000336B _text$mn        ends
.text$mn:0000336B
.text$mn:0000336C ; ===========================================================================
.text$mn:0000336C
.text$mn:0000336C ; Segment type: Pure code
.text$mn:0000336C ; Segment permissions: Read/Execute
.text$mn:0000336C _text$mn        segment para public 'CODE' use32
.text$mn:0000336C                 assume cs:_text$mn
.text$mn:0000336C                 ;org 336Ch
.text$mn:0000336C ; COMDAT (pick any)
.text$mn:0000336C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000336C
.text$mn:0000336C ; =============== S U B R O U T I N E =======================================
.text$mn:0000336C
.text$mn:0000336C ; Attributes: bp-based frame
.text$mn:0000336C
.text$mn:0000336C ; int __cdecl std::_Uninit_move<unsigned char *,unsigned char *,std::_Wrap_alloc<std::allocator<unsigned char>>>(void *Src, int, void *Dst, int)
.text$mn:0000336C                 public ??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:0000336C ??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:0000336C                                         ; CODE XREF: std::_Uninitialized_move<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+2Ep
.text$mn:0000336C
.text$mn:0000336C var_1           = byte ptr -1
.text$mn:0000336C Src             = dword ptr  8
.text$mn:0000336C arg_4           = dword ptr  0Ch
.text$mn:0000336C Dst             = dword ptr  10h
.text$mn:0000336C arg_C           = dword ptr  14h
.text$mn:0000336C
.text$mn:0000336C                 push    ebp
.text$mn:0000336D                 mov     ebp, esp
.text$mn:0000336F                 push    ecx
.text$mn:00003370                 mov     eax, [ebp+Dst]
.text$mn:00003373                 push    eax
.text$mn:00003374                 mov     ecx, [ebp+Src]
.text$mn:00003377                 push    ecx
.text$mn:00003378                 call    ??$_Ptr_cat@EE@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAE0@Z ; std::_Ptr_cat<uchar,uchar>(uchar *,uchar *)
.text$mn:0000337D                 add     esp, 8
.text$mn:00003380                 mov     [ebp+var_1], al
.text$mn:00003383                 movzx   edx, [ebp+var_1]
.text$mn:00003387                 push    edx
.text$mn:00003388                 mov     eax, [ebp+Src]
.text$mn:0000338B                 push    eax
.text$mn:0000338C                 call    ??$_Val_type@PAE@std@@YAPAEPAE@Z ; std::_Val_type<uchar *>(uchar *)
.text$mn:00003391                 add     esp, 4
.text$mn:00003394                 push    eax
.text$mn:00003395                 mov     ecx, [ebp+arg_C]
.text$mn:00003398                 push    ecx
.text$mn:00003399                 mov     edx, [ebp+Dst]
.text$mn:0000339C                 push    edx             ; Dst
.text$mn:0000339D                 mov     eax, [ebp+arg_4]
.text$mn:000033A0                 push    eax             ; int
.text$mn:000033A1                 mov     ecx, [ebp+Src]
.text$mn:000033A4                 push    ecx             ; Src
.text$mn:000033A5                 call    ??$_Uninit_move@EEE@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@0U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<uchar,uchar,uchar>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,uchar *,std::_Scalar_ptr_iterator_tag)
.text$mn:000033AA                 add     esp, 18h
.text$mn:000033AD                 mov     esp, ebp
.text$mn:000033AF                 pop     ebp
.text$mn:000033B0                 retn
.text$mn:000033B0 ??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:000033B0
.text$mn:000033B0 ; ---------------------------------------------------------------------------
.text$mn:000033B1                 align 4
.text$mn:000033B1 _text$mn        ends
.text$mn:000033B1
.text$mn:000033B4 ; ===========================================================================
.text$mn:000033B4
.text$mn:000033B4 ; Segment type: Pure code
.text$mn:000033B4 ; Segment permissions: Read/Execute
.text$mn:000033B4 _text$mn        segment para public 'CODE' use32
.text$mn:000033B4                 assume cs:_text$mn
.text$mn:000033B4                 ;org 33B4h
.text$mn:000033B4 ; COMDAT (pick any)
.text$mn:000033B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033B4
.text$mn:000033B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000033B4
.text$mn:000033B4 ; Attributes: bp-based frame
.text$mn:000033B4
.text$mn:000033B4 ; int __cdecl std::_Uninit_move<std::vector<unsigned char,std::allocator<unsigned char>> *,std::vector<unsigned char,std::allocator<unsigned char>> *,std::_Wrap_alloc<std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>>(int, int, void *, int)
.text$mn:000033B4                 public ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z
.text$mn:000033B4 ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z proc near
.text$mn:000033B4                                         ; CODE XREF: std::_Uninitialized_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+2Ep
.text$mn:000033B4
.text$mn:000033B4 var_1           = byte ptr -1
.text$mn:000033B4 arg_0           = dword ptr  8
.text$mn:000033B4 arg_4           = dword ptr  0Ch
.text$mn:000033B4 arg_8           = dword ptr  10h
.text$mn:000033B4 arg_C           = dword ptr  14h
.text$mn:000033B4
.text$mn:000033B4                 push    ebp
.text$mn:000033B5                 mov     ebp, esp
.text$mn:000033B7                 push    ecx
.text$mn:000033B8                 mov     eax, [ebp+arg_8]
.text$mn:000033BB                 push    eax
.text$mn:000033BC                 mov     ecx, [ebp+arg_0]
.text$mn:000033BF                 push    ecx
.text$mn:000033C0                 call    ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z ; std::_Ptr_cat<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000033C5                 add     esp, 8
.text$mn:000033C8                 mov     [ebp+var_1], al
.text$mn:000033CB                 movzx   edx, [ebp+var_1]
.text$mn:000033CF                 push    edx
.text$mn:000033D0                 mov     eax, [ebp+arg_0]
.text$mn:000033D3                 push    eax
.text$mn:000033D4                 call    ??$_Val_type@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z ; std::_Val_type<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000033D9                 add     esp, 4
.text$mn:000033DC                 push    eax
.text$mn:000033DD                 mov     ecx, [ebp+arg_C]
.text$mn:000033E0                 push    ecx             ; int
.text$mn:000033E1                 mov     edx, [ebp+arg_8]
.text$mn:000033E4                 push    edx             ; void *
.text$mn:000033E5                 mov     eax, [ebp+arg_4]
.text$mn:000033E8                 push    eax             ; int
.text$mn:000033E9                 mov     ecx, [ebp+arg_0]
.text$mn:000033EC                 push    ecx             ; int
.text$mn:000033ED                 call    ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:000033F2                 add     esp, 18h
.text$mn:000033F5                 mov     esp, ebp
.text$mn:000033F7                 pop     ebp
.text$mn:000033F8                 retn
.text$mn:000033F8 ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z endp
.text$mn:000033F8
.text$mn:000033F8 ; ---------------------------------------------------------------------------
.text$mn:000033F9                 align 4
.text$mn:000033F9 _text$mn        ends
.text$mn:000033F9
.text$mn:000033FC ; ===========================================================================
.text$mn:000033FC
.text$mn:000033FC ; Segment type: Pure code
.text$mn:000033FC ; Segment permissions: Read/Execute
.text$mn:000033FC _text$mn        segment para public 'CODE' use32
.text$mn:000033FC                 assume cs:_text$mn
.text$mn:000033FC                 ;org 33FCh
.text$mn:000033FC ; COMDAT (pick any)
.text$mn:000033FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033FC
.text$mn:000033FC ; =============== S U B R O U T I N E =======================================
.text$mn:000033FC
.text$mn:000033FC ; Attributes: bp-based frame
.text$mn:000033FC
.text$mn:000033FC ; int __cdecl std::_Uninit_move<std::vector<unsigned char,std::allocator<unsigned char>> *,std::vector<unsigned char,std::allocator<unsigned char>> *,std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>,std::vector<unsigned char,std::allocator<unsigned char>>>(int, int, void *, int)
.text$mn:000033FC                 public ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000033FC ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$mn:000033FC                                         ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+39p
.text$mn:000033FC
.text$mn:000033FC var_14          = dword ptr -14h
.text$mn:000033FC var_10          = dword ptr -10h
.text$mn:000033FC var_C           = dword ptr -0Ch
.text$mn:000033FC var_4           = dword ptr -4
.text$mn:000033FC arg_0           = dword ptr  8
.text$mn:000033FC arg_4           = dword ptr  0Ch
.text$mn:000033FC arg_8           = dword ptr  10h
.text$mn:000033FC arg_C           = dword ptr  14h
.text$mn:000033FC
.text$mn:000033FC ; FUNCTION CHUNK AT .text$mn:000034C3 SIZE 00000009 BYTES
.text$mn:000033FC ; FUNCTION CHUNK AT .text$mn:000034D3 SIZE 00000015 BYTES
.text$mn:000033FC
.text$mn:000033FC                 push    ebp
.text$mn:000033FD                 mov     ebp, esp
.text$mn:000033FF                 push    0FFFFFFFFh
.text$mn:00003401                 push    offset __ehhandler$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:00003406                 mov     eax, large fs:0
.text$mn:0000340C                 push    eax
.text$mn:0000340D                 push    ecx
.text$mn:0000340E                 push    ecx
.text$mn:0000340F                 push    ebx
.text$mn:00003410                 push    esi
.text$mn:00003411                 push    edi
.text$mn:00003412                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003417                 xor     eax, ebp
.text$mn:00003419                 push    eax
.text$mn:0000341A                 lea     eax, [ebp+var_C]
.text$mn:0000341D                 mov     large fs:0, eax
.text$mn:00003423                 mov     [ebp+var_10], esp
.text$mn:00003426                 push    1B6h            ; unsigned int
.text$mn:0000342B                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003430                 mov     eax, [ebp+arg_4]
.text$mn:00003433                 push    eax             ; int
.text$mn:00003434                 mov     ecx, [ebp+arg_0]
.text$mn:00003437                 push    ecx             ; int
.text$mn:00003438                 call    ??$_Debug_range@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WI@Z ; std::_Debug_range<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)
.text$mn:0000343D                 add     esp, 10h
.text$mn:00003440                 push    1B7h            ; unsigned int
.text$mn:00003445                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000344A                 mov     edx, [ebp+arg_8]
.text$mn:0000344D                 push    edx             ; int
.text$mn:0000344E                 call    ??$_Debug_pointer@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)
.text$mn:00003453                 add     esp, 0Ch
.text$mn:00003456                 mov     eax, [ebp+arg_8]
.text$mn:00003459                 mov     [ebp+var_14], eax
.text$mn:0000345C                 mov     [ebp+var_4], 0
.text$mn:00003463                 jmp     short loc_3477
.text$mn:00003465 ; ---------------------------------------------------------------------------
.text$mn:00003465
.text$mn:00003465 loc_3465:                               ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+93j
.text$mn:00003465                 mov     ecx, [ebp+arg_8]
.text$mn:00003468                 add     ecx, 10h
.text$mn:0000346B                 mov     [ebp+arg_8], ecx
.text$mn:0000346E                 mov     edx, [ebp+arg_0]
.text$mn:00003471                 add     edx, 10h
.text$mn:00003474                 mov     [ebp+arg_0], edx
.text$mn:00003477
.text$mn:00003477 loc_3477:                               ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+67j
.text$mn:00003477                 mov     eax, [ebp+arg_0]
.text$mn:0000347A                 cmp     eax, [ebp+arg_4]
.text$mn:0000347D                 jz      short loc_3491
.text$mn:0000347F                 mov     ecx, [ebp+arg_0]
.text$mn:00003482                 push    ecx             ; int
.text$mn:00003483                 mov     edx, [ebp+arg_8]
.text$mn:00003486                 push    edx             ; void *
.text$mn:00003487                 mov     ecx, [ebp+arg_C]
.text$mn:0000348A                 call    ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:0000348F                 jmp     short loc_3465
.text$mn:00003491 ; ---------------------------------------------------------------------------
.text$mn:00003491
.text$mn:00003491 loc_3491:                               ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+81j
.text$mn:00003491                 jmp     short loc_34C3
.text$mn:00003491 ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$mn:00003491
.text$mn:00003493
.text$mn:00003493 ; =============== S U B R O U T I N E =======================================
.text$mn:00003493
.text$mn:00003493 ; Attributes: noreturn
.text$mn:00003493
.text$mn:00003493 __catch$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 proc near
.text$mn:00003493                                         ; DATA XREF: .xdata$x:0000A004o
.text$mn:00003493                 jmp     short loc_349E
.text$mn:00003495 ; ---------------------------------------------------------------------------
.text$mn:00003495
.text$mn:00003495 loc_3495:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Fj
.text$mn:00003495                 mov     eax, [ebp-14h]
.text$mn:00003498                 add     eax, 10h
.text$mn:0000349B                 mov     [ebp-14h], eax
.text$mn:0000349E
.text$mn:0000349E loc_349E:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0j
.text$mn:0000349E                 mov     ecx, [ebp-14h]
.text$mn:000034A1                 cmp     ecx, [ebp+10h]
.text$mn:000034A4                 jz      short loc_34B4
.text$mn:000034A6                 mov     edx, [ebp-14h]
.text$mn:000034A9                 push    edx
.text$mn:000034AA                 mov     ecx, [ebp+14h]
.text$mn:000034AD                 call    ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000034B2                 jmp     short loc_3495
.text$mn:000034B4 ; ---------------------------------------------------------------------------
.text$mn:000034B4
.text$mn:000034B4 loc_34B4:                               ; CODE XREF: __catch$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+11j
.text$mn:000034B4                 push    0
.text$mn:000034B6                 push    0
.text$mn:000034B8                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000034B8 __catch$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0 endp
.text$mn:000034B8
.text$mn:000034BD ; ---------------------------------------------------------------------------
.text$mn:000034BD                 mov     eax, offset $LN13_0
.text$mn:000034C2                 retn
.text$mn:000034C3 ; ---------------------------------------------------------------------------
.text$mn:000034C3 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000034C3
.text$mn:000034C3 loc_34C3:                               ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag):loc_3491j
.text$mn:000034C3                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000034CA                 jmp     short loc_34D3
.text$mn:000034CA ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000034CC
.text$mn:000034CC ; =============== S U B R O U T I N E =======================================
.text$mn:000034CC
.text$mn:000034CC
.text$mn:000034CC $LN13_0         proc near               ; DATA XREF: .text$mn:000034BDo
.text$mn:000034CC                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000034CC $LN13_0         endp ; sp-analysis failed
.text$mn:000034CC
.text$mn:000034D3 ; START OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000034D3
.text$mn:000034D3 loc_34D3:                               ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+CEj
.text$mn:000034D3                 mov     eax, [ebp+arg_8]
.text$mn:000034D6                 mov     ecx, [ebp+var_C]
.text$mn:000034D9                 mov     large fs:0, ecx
.text$mn:000034E0                 pop     ecx
.text$mn:000034E1                 pop     edi
.text$mn:000034E2                 pop     esi
.text$mn:000034E3                 pop     ebx
.text$mn:000034E4                 mov     esp, ebp
.text$mn:000034E6                 pop     ebp
.text$mn:000034E7                 retn
.text$mn:000034E7 ; END OF FUNCTION CHUNK FOR ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$mn:000034E7 _text$mn        ends
.text$mn:000034E7
.text$x:000034E8 ; ===========================================================================
.text$x:000034E8
.text$x:000034E8 ; Segment type: Pure code
.text$x:000034E8 ; Segment permissions: Read/Execute
.text$x:000034E8 _text$x         segment para public 'CODE' use32
.text$x:000034E8                 assume cs:_text$x
.text$x:000034E8                 ;org 34E8h
.text$x:000034E8 ; COMDAT (pick associative to section at 33FC)
.text$x:000034E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000034E8
.text$x:000034E8 ; =============== S U B R O U T I N E =======================================
.text$x:000034E8
.text$x:000034E8
.text$x:000034E8 __ehhandler$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z proc near
.text$x:000034E8                                         ; DATA XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+5o
.text$x:000034E8
.text$x:000034E8 arg_4           = dword ptr  8
.text$x:000034E8
.text$x:000034E8                 mov     edx, [esp+arg_4]
.text$x:000034EC                 lea     eax, [edx+0Ch]
.text$x:000034EF                 mov     ecx, [edx-18h]
.text$x:000034F2                 xor     ecx, eax
.text$x:000034F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034F9                 mov     eax, offset __ehfuncinfo$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.text$x:000034FE                 jmp     ___CxxFrameHandler3
.text$x:000034FE __ehhandler$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z endp
.text$x:000034FE
.text$x:000034FE ; ---------------------------------------------------------------------------
.text$x:00003503                 align 4
.text$x:00003503 _text$x         ends
.text$x:00003503
.text$mn:00003504 ; ===========================================================================
.text$mn:00003504
.text$mn:00003504 ; Segment type: Pure code
.text$mn:00003504 ; Segment permissions: Read/Execute
.text$mn:00003504 _text$mn        segment para public 'CODE' use32
.text$mn:00003504                 assume cs:_text$mn
.text$mn:00003504                 ;org 3504h
.text$mn:00003504 ; COMDAT (pick any)
.text$mn:00003504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003504
.text$mn:00003504 ; =============== S U B R O U T I N E =======================================
.text$mn:00003504
.text$mn:00003504 ; Attributes: bp-based frame
.text$mn:00003504
.text$mn:00003504 ; unsigned char * __cdecl std::_Uninitialized_copy<unsigned char *, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>>>(unsigned char *, unsigned char *, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>> &)
.text$mn:00003504                 public ??$_Uninitialized_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00003504 ??$_Uninitialized_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:00003504                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<uchar *>(uchar *,uchar *,uchar *)+25p
.text$mn:00003504
.text$mn:00003504 arg_0           = dword ptr  8
.text$mn:00003504 arg_4           = dword ptr  0Ch
.text$mn:00003504 arg_8           = dword ptr  10h
.text$mn:00003504 arg_C           = dword ptr  14h
.text$mn:00003504
.text$mn:00003504                 push    ebp
.text$mn:00003505                 mov     ebp, esp
.text$mn:00003507                 mov     eax, [ebp+arg_C]
.text$mn:0000350A                 push    eax             ; int
.text$mn:0000350B                 mov     ecx, [ebp+arg_8]
.text$mn:0000350E                 push    ecx
.text$mn:0000350F                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:00003514                 add     esp, 4
.text$mn:00003517                 push    eax             ; Dst
.text$mn:00003518                 mov     edx, [ebp+arg_4]
.text$mn:0000351B                 push    edx
.text$mn:0000351C                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:00003521                 add     esp, 4
.text$mn:00003524                 push    eax             ; int
.text$mn:00003525                 mov     eax, [ebp+arg_0]
.text$mn:00003528                 push    eax
.text$mn:00003529                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:0000352E                 add     esp, 4
.text$mn:00003531                 push    eax             ; Src
.text$mn:00003532                 call    ??$_Uninit_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninit_copy<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:00003537                 add     esp, 10h
.text$mn:0000353A                 push    eax
.text$mn:0000353B                 lea     ecx, [ebp+arg_8]
.text$mn:0000353E                 push    ecx
.text$mn:0000353F                 call    ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ; std::_Rechecked<uchar *,uchar *>(uchar * &,uchar *)
.text$mn:00003544                 add     esp, 8
.text$mn:00003547                 mov     eax, [eax]
.text$mn:00003549                 pop     ebp
.text$mn:0000354A                 retn
.text$mn:0000354A ??$_Uninitialized_copy@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:0000354A
.text$mn:0000354A ; ---------------------------------------------------------------------------
.text$mn:0000354B                 align 4
.text$mn:0000354B _text$mn        ends
.text$mn:0000354B
.text$mn:0000354C ; ===========================================================================
.text$mn:0000354C
.text$mn:0000354C ; Segment type: Pure code
.text$mn:0000354C ; Segment permissions: Read/Execute
.text$mn:0000354C _text$mn        segment para public 'CODE' use32
.text$mn:0000354C                 assume cs:_text$mn
.text$mn:0000354C                 ;org 354Ch
.text$mn:0000354C ; COMDAT (pick any)
.text$mn:0000354C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000354C
.text$mn:0000354C ; =============== S U B R O U T I N E =======================================
.text$mn:0000354C
.text$mn:0000354C ; Attributes: bp-based frame
.text$mn:0000354C
.text$mn:0000354C ; unsigned char * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>> &)
.text$mn:0000354C                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:0000354C ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:0000354C                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)+83p
.text$mn:0000354C
.text$mn:0000354C var_34          = dword ptr -34h
.text$mn:0000354C var_30          = dword ptr -30h
.text$mn:0000354C var_2C          = dword ptr -2Ch
.text$mn:0000354C var_28          = dword ptr -28h
.text$mn:0000354C var_24          = dword ptr -24h
.text$mn:0000354C var_20          = dword ptr -20h
.text$mn:0000354C Src             = dword ptr -1Ch
.text$mn:0000354C var_18          = dword ptr -18h
.text$mn:0000354C var_14          = dword ptr -14h
.text$mn:0000354C var_10          = dword ptr -10h
.text$mn:0000354C var_C           = dword ptr -0Ch
.text$mn:0000354C var_4           = dword ptr -4
.text$mn:0000354C arg_0           = byte ptr  8
.text$mn:0000354C arg_C           = byte ptr  14h
.text$mn:0000354C arg_18          = dword ptr  20h
.text$mn:0000354C arg_1C          = dword ptr  24h
.text$mn:0000354C
.text$mn:0000354C                 push    ebp
.text$mn:0000354D                 mov     ebp, esp
.text$mn:0000354F                 push    0FFFFFFFFh
.text$mn:00003551                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00003556                 mov     eax, large fs:0
.text$mn:0000355C                 push    eax
.text$mn:0000355D                 sub     esp, 28h
.text$mn:00003560                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003565                 xor     eax, ebp
.text$mn:00003567                 push    eax
.text$mn:00003568                 lea     eax, [ebp+var_C]
.text$mn:0000356B                 mov     large fs:0, eax
.text$mn:00003571                 mov     [ebp+var_4], 1
.text$mn:00003578                 mov     eax, [ebp+arg_1C]
.text$mn:0000357B                 push    eax             ; int
.text$mn:0000357C                 mov     ecx, [ebp+arg_18]
.text$mn:0000357F                 push    ecx
.text$mn:00003580                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:00003585                 add     esp, 4
.text$mn:00003588                 push    eax             ; Dst
.text$mn:00003589                 sub     esp, 0Ch
.text$mn:0000358C                 mov     ecx, esp
.text$mn:0000358E                 mov     [ebp+var_28], esp
.text$mn:00003591                 lea     edx, [ebp+arg_C]
.text$mn:00003594                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003595                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:0000359A                 mov     [ebp+var_10], eax
.text$mn:0000359D                 mov     eax, [ebp+var_10]
.text$mn:000035A0                 mov     [ebp+var_2C], eax
.text$mn:000035A3                 mov     byte ptr [ebp+var_4], 2
.text$mn:000035A7                 mov     byte ptr [ebp+var_4], 1
.text$mn:000035AB                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)
.text$mn:000035B0                 add     esp, 0Ch
.text$mn:000035B3                 mov     [ebp+var_14], eax
.text$mn:000035B6                 mov     ecx, [ebp+var_14]
.text$mn:000035B9                 push    ecx             ; int
.text$mn:000035BA                 sub     esp, 0Ch
.text$mn:000035BD                 mov     ecx, esp
.text$mn:000035BF                 mov     [ebp+var_30], esp
.text$mn:000035C2                 lea     edx, [ebp+arg_0]
.text$mn:000035C5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000035C6                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:000035CB                 mov     [ebp+var_18], eax
.text$mn:000035CE                 mov     eax, [ebp+var_18]
.text$mn:000035D1                 mov     [ebp+var_34], eax
.text$mn:000035D4                 mov     byte ptr [ebp+var_4], 3
.text$mn:000035D8                 mov     byte ptr [ebp+var_4], 1
.text$mn:000035DC                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)
.text$mn:000035E1                 add     esp, 0Ch
.text$mn:000035E4                 mov     [ebp+Src], eax
.text$mn:000035E7                 mov     ecx, [ebp+Src]
.text$mn:000035EA                 push    ecx             ; Src
.text$mn:000035EB                 call    ??$_Uninit_copy@PBEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPBE0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninit_copy<uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:000035F0                 add     esp, 10h
.text$mn:000035F3                 mov     [ebp+var_20], eax
.text$mn:000035F6                 mov     edx, [ebp+var_20]
.text$mn:000035F9                 push    edx
.text$mn:000035FA                 lea     eax, [ebp+arg_18]
.text$mn:000035FD                 push    eax
.text$mn:000035FE                 call    ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ; std::_Rechecked<uchar *,uchar *>(uchar * &,uchar *)
.text$mn:00003603                 add     esp, 8
.text$mn:00003606                 mov     ecx, [eax]
.text$mn:00003608                 mov     [ebp+var_24], ecx
.text$mn:0000360B                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000360F                 lea     ecx, [ebp+arg_0]
.text$mn:00003612                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00003617                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000361E                 lea     ecx, [ebp+arg_C]
.text$mn:00003621                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00003626                 mov     eax, [ebp+var_24]
.text$mn:00003629                 mov     ecx, [ebp+var_C]
.text$mn:0000362C                 mov     large fs:0, ecx
.text$mn:00003633                 pop     ecx
.text$mn:00003634                 mov     esp, ebp
.text$mn:00003636                 pop     ebp
.text$mn:00003637                 retn
.text$mn:00003637 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:00003637
.text$mn:00003637 _text$mn        ends
.text$mn:00003637
.text$x:00003638 ; ===========================================================================
.text$x:00003638
.text$x:00003638 ; Segment type: Pure code
.text$x:00003638 ; Segment permissions: Read/Execute
.text$x:00003638 _text$x         segment para public 'CODE' use32
.text$x:00003638                 assume cs:_text$x
.text$x:00003638                 ;org 3638h
.text$x:00003638 ; COMDAT (pick associative to section at 354C)
.text$x:00003638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003638
.text$x:00003638 ; =============== S U B R O U T I N E =======================================
.text$x:00003638
.text$x:00003638
.text$x:00003638 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0 proc near
.text$x:00003638                                         ; DATA XREF: .xdata$x:00009D18o
.text$x:00003638                 lea     ecx, [ebp+14h]
.text$x:0000363B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:0000363B __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0 endp
.text$x:0000363B
.text$x:00003640
.text$x:00003640 ; =============== S U B R O U T I N E =======================================
.text$x:00003640
.text$x:00003640
.text$x:00003640 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1 proc near
.text$x:00003640                                         ; DATA XREF: .xdata$x:00009D20o
.text$x:00003640                 lea     ecx, [ebp+8]
.text$x:00003643                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00003643 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1 endp
.text$x:00003643
.text$x:00003648
.text$x:00003648 ; =============== S U B R O U T I N E =======================================
.text$x:00003648
.text$x:00003648
.text$x:00003648 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2 proc near
.text$x:00003648                                         ; DATA XREF: .xdata$x:00009D28o
.text$x:00003648                 mov     ecx, [ebp-28h]
.text$x:0000364B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:0000364B __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2 endp
.text$x:0000364B
.text$x:00003650
.text$x:00003650 ; =============== S U B R O U T I N E =======================================
.text$x:00003650
.text$x:00003650
.text$x:00003650 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3 proc near
.text$x:00003650                                         ; DATA XREF: .xdata$x:00009D30o
.text$x:00003650                 mov     ecx, [ebp-30h]
.text$x:00003653                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00003653 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3 endp
.text$x:00003653
.text$x:00003658
.text$x:00003658 ; =============== S U B R O U T I N E =======================================
.text$x:00003658
.text$x:00003658
.text$x:00003658 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$x:00003658                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+5o
.text$x:00003658
.text$x:00003658 arg_4           = dword ptr  8
.text$x:00003658
.text$x:00003658                 mov     edx, [esp+arg_4]
.text$x:0000365C                 lea     eax, [edx+0Ch]
.text$x:0000365F                 mov     ecx, [edx-2Ch]
.text$x:00003662                 xor     ecx, eax
.text$x:00003664                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003669                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$x:0000366E                 jmp     ___CxxFrameHandler3
.text$x:0000366E __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$x:0000366E
.text$x:0000366E ; ---------------------------------------------------------------------------
.text$x:00003673                 align 4
.text$x:00003673 _text$x         ends
.text$x:00003673
.text$mn:00003674 ; ===========================================================================
.text$mn:00003674
.text$mn:00003674 ; Segment type: Pure code
.text$mn:00003674 ; Segment permissions: Read/Execute
.text$mn:00003674 _text$mn        segment para public 'CODE' use32
.text$mn:00003674                 assume cs:_text$mn
.text$mn:00003674                 ;org 3674h
.text$mn:00003674 ; COMDAT (pick any)
.text$mn:00003674                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003674
.text$mn:00003674 ; =============== S U B R O U T I N E =======================================
.text$mn:00003674
.text$mn:00003674 ; Attributes: bp-based frame
.text$mn:00003674
.text$mn:00003674 ; unsigned char * __cdecl std::_Uninitialized_copy<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>> &)
.text$mn:00003674                 public ??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00003674 ??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:00003674                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *)+83p
.text$mn:00003674
.text$mn:00003674 var_44          = dword ptr -44h
.text$mn:00003674 var_40          = dword ptr -40h
.text$mn:00003674 var_3C          = dword ptr -3Ch
.text$mn:00003674 var_38          = dword ptr -38h
.text$mn:00003674 var_34          = dword ptr -34h
.text$mn:00003674 var_30          = dword ptr -30h
.text$mn:00003674 var_2C          = dword ptr -2Ch
.text$mn:00003674 var_28          = dword ptr -28h
.text$mn:00003674 var_24          = dword ptr -24h
.text$mn:00003674 var_20          = dword ptr -20h
.text$mn:00003674 var_1C          = dword ptr -1Ch
.text$mn:00003674 var_18          = dword ptr -18h
.text$mn:00003674 var_14          = dword ptr -14h
.text$mn:00003674 var_10          = dword ptr -10h
.text$mn:00003674 var_C           = dword ptr -0Ch
.text$mn:00003674 var_4           = dword ptr -4
.text$mn:00003674 arg_0           = byte ptr  8
.text$mn:00003674 arg_C           = byte ptr  14h
.text$mn:00003674 arg_18          = dword ptr  20h
.text$mn:00003674 arg_1C          = dword ptr  24h
.text$mn:00003674
.text$mn:00003674                 push    ebp
.text$mn:00003675                 mov     ebp, esp
.text$mn:00003677                 push    0FFFFFFFFh
.text$mn:00003679                 push    offset __ehhandler$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:0000367E                 mov     eax, large fs:0
.text$mn:00003684                 push    eax
.text$mn:00003685                 sub     esp, 38h
.text$mn:00003688                 push    esi
.text$mn:00003689                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000368E                 xor     eax, ebp
.text$mn:00003690                 push    eax
.text$mn:00003691                 lea     eax, [ebp+var_C]
.text$mn:00003694                 mov     large fs:0, eax
.text$mn:0000369A                 mov     [ebp+var_4], 1
.text$mn:000036A1                 mov     eax, [ebp+arg_1C]
.text$mn:000036A4                 push    eax             ; int
.text$mn:000036A5                 mov     ecx, [ebp+arg_18]
.text$mn:000036A8                 push    ecx
.text$mn:000036A9                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:000036AE                 add     esp, 4
.text$mn:000036B1                 push    eax             ; void *
.text$mn:000036B2                 sub     esp, 0Ch
.text$mn:000036B5                 mov     esi, esp
.text$mn:000036B7                 mov     [ebp+var_28], esp
.text$mn:000036BA                 sub     esp, 0Ch
.text$mn:000036BD                 mov     ecx, esp
.text$mn:000036BF                 mov     [ebp+var_2C], esp
.text$mn:000036C2                 lea     edx, [ebp+arg_C]
.text$mn:000036C5                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000036C6                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:000036CB                 mov     [ebp+var_10], eax
.text$mn:000036CE                 mov     eax, [ebp+var_10]
.text$mn:000036D1                 mov     [ebp+var_30], eax
.text$mn:000036D4                 mov     byte ptr [ebp+var_4], 2
.text$mn:000036D8                 push    esi
.text$mn:000036D9                 mov     byte ptr [ebp+var_4], 1
.text$mn:000036DD                 call    ??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)
.text$mn:000036E2                 add     esp, 10h
.text$mn:000036E5                 mov     [ebp+var_14], eax
.text$mn:000036E8                 mov     ecx, [ebp+var_14]
.text$mn:000036EB                 mov     [ebp+var_34], ecx
.text$mn:000036EE                 mov     byte ptr [ebp+var_4], 3
.text$mn:000036F2                 sub     esp, 0Ch
.text$mn:000036F5                 mov     esi, esp
.text$mn:000036F7                 mov     [ebp+var_38], esp
.text$mn:000036FA                 sub     esp, 0Ch
.text$mn:000036FD                 mov     ecx, esp
.text$mn:000036FF                 mov     [ebp+var_3C], esp
.text$mn:00003702                 lea     edx, [ebp+arg_0]
.text$mn:00003705                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003706                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:0000370B                 mov     [ebp+var_18], eax
.text$mn:0000370E                 mov     eax, [ebp+var_18]
.text$mn:00003711                 mov     [ebp+var_40], eax
.text$mn:00003714                 mov     byte ptr [ebp+var_4], 4
.text$mn:00003718                 push    esi
.text$mn:00003719                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000371D                 call    ??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z ; std::_Unchecked<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)
.text$mn:00003722                 add     esp, 10h
.text$mn:00003725                 mov     [ebp+var_1C], eax
.text$mn:00003728                 mov     ecx, [ebp+var_1C]
.text$mn:0000372B                 mov     [ebp+var_44], ecx
.text$mn:0000372E                 mov     byte ptr [ebp+var_4], 5
.text$mn:00003732                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003736                 call    ??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:0000373B                 add     esp, 20h
.text$mn:0000373E                 mov     [ebp+var_20], eax
.text$mn:00003741                 mov     edx, [ebp+var_20]
.text$mn:00003744                 push    edx
.text$mn:00003745                 lea     eax, [ebp+arg_18]
.text$mn:00003748                 push    eax
.text$mn:00003749                 call    ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ; std::_Rechecked<uchar *,uchar *>(uchar * &,uchar *)
.text$mn:0000374E                 add     esp, 8
.text$mn:00003751                 mov     ecx, [eax]
.text$mn:00003753                 mov     [ebp+var_24], ecx
.text$mn:00003756                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000375A                 lea     ecx, [ebp+arg_0]
.text$mn:0000375D                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00003762                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003769                 lea     ecx, [ebp+arg_C]
.text$mn:0000376C                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00003771                 mov     eax, [ebp+var_24]
.text$mn:00003774                 mov     ecx, [ebp+var_C]
.text$mn:00003777                 mov     large fs:0, ecx
.text$mn:0000377E                 pop     ecx
.text$mn:0000377F                 pop     esi
.text$mn:00003780                 mov     esp, ebp
.text$mn:00003782                 pop     ebp
.text$mn:00003783                 retn
.text$mn:00003783 ??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:00003783
.text$mn:00003783 _text$mn        ends
.text$mn:00003783
.text$x:00003784 ; ===========================================================================
.text$x:00003784
.text$x:00003784 ; Segment type: Pure code
.text$x:00003784 ; Segment permissions: Read/Execute
.text$x:00003784 _text$x         segment para public 'CODE' use32
.text$x:00003784                 assume cs:_text$x
.text$x:00003784                 ;org 3784h
.text$x:00003784 ; COMDAT (pick associative to section at 3674)
.text$x:00003784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003784
.text$x:00003784 ; =============== S U B R O U T I N E =======================================
.text$x:00003784
.text$x:00003784
.text$x:00003784 __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0 proc near
.text$x:00003784                                         ; DATA XREF: .xdata$x:0000A1BCo
.text$x:00003784                 lea     ecx, [ebp+14h]
.text$x:00003787                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003787 __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0 endp
.text$x:00003787
.text$x:0000378C
.text$x:0000378C ; =============== S U B R O U T I N E =======================================
.text$x:0000378C
.text$x:0000378C
.text$x:0000378C __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1 proc near
.text$x:0000378C                                         ; DATA XREF: .xdata$x:0000A1C4o
.text$x:0000378C                 lea     ecx, [ebp+8]
.text$x:0000378F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000378F __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1 endp
.text$x:0000378F
.text$x:00003794
.text$x:00003794 ; =============== S U B R O U T I N E =======================================
.text$x:00003794
.text$x:00003794
.text$x:00003794 __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2 proc near
.text$x:00003794                                         ; DATA XREF: .xdata$x:0000A1CCo
.text$x:00003794                 mov     ecx, [ebp-2Ch]
.text$x:00003797                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003797 __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2 endp
.text$x:00003797
.text$x:0000379C
.text$x:0000379C ; =============== S U B R O U T I N E =======================================
.text$x:0000379C
.text$x:0000379C
.text$x:0000379C __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3 proc near
.text$x:0000379C                                         ; DATA XREF: .xdata$x:0000A1D4o
.text$x:0000379C                 mov     ecx, [ebp-28h]
.text$x:0000379F                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:0000379F __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3 endp
.text$x:0000379F
.text$x:000037A4
.text$x:000037A4 ; =============== S U B R O U T I N E =======================================
.text$x:000037A4
.text$x:000037A4
.text$x:000037A4 __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$4 proc near
.text$x:000037A4                                         ; DATA XREF: .xdata$x:0000A1DCo
.text$x:000037A4                 mov     ecx, [ebp-3Ch]
.text$x:000037A7                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000037A7 __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$4 endp
.text$x:000037A7
.text$x:000037AC
.text$x:000037AC ; =============== S U B R O U T I N E =======================================
.text$x:000037AC
.text$x:000037AC
.text$x:000037AC __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$5 proc near
.text$x:000037AC                                         ; DATA XREF: .xdata$x:0000A1E4o
.text$x:000037AC                 mov     ecx, [ebp-38h]
.text$x:000037AF                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000037AF __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$5 endp
.text$x:000037AF
.text$x:000037B4
.text$x:000037B4 ; =============== S U B R O U T I N E =======================================
.text$x:000037B4
.text$x:000037B4
.text$x:000037B4 __ehhandler$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$x:000037B4                                         ; DATA XREF: std::_Uninitialized_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+5o
.text$x:000037B4
.text$x:000037B4 arg_4           = dword ptr  8
.text$x:000037B4
.text$x:000037B4                 mov     edx, [esp+arg_4]
.text$x:000037B8                 lea     eax, [edx+0Ch]
.text$x:000037BB                 mov     ecx, [edx-40h]
.text$x:000037BE                 xor     ecx, eax
.text$x:000037C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000037C5                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$x:000037CA                 jmp     ___CxxFrameHandler3
.text$x:000037CA __ehhandler$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$x:000037CA
.text$x:000037CA ; ---------------------------------------------------------------------------
.text$x:000037CF                 align 10h
.text$x:000037CF _text$x         ends
.text$x:000037CF
.text$mn:000037D0 ; ===========================================================================
.text$mn:000037D0
.text$mn:000037D0 ; Segment type: Pure code
.text$mn:000037D0 ; Segment permissions: Read/Execute
.text$mn:000037D0 _text$mn        segment para public 'CODE' use32
.text$mn:000037D0                 assume cs:_text$mn
.text$mn:000037D0                 ;org 37D0h
.text$mn:000037D0 ; COMDAT (pick any)
.text$mn:000037D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037D0
.text$mn:000037D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037D0
.text$mn:000037D0 ; Attributes: bp-based frame
.text$mn:000037D0
.text$mn:000037D0 ; int __cdecl std::_Uninitialized_fill_n<std::vector<unsigned char,std::allocator<unsigned char>> *,unsigned int,std::vector<unsigned char,std::allocator<unsigned char>>,std::_Wrap_alloc<std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>>(void *, int, int, int)
.text$mn:000037D0                 public ??$_Uninitialized_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z
.text$mn:000037D0 ??$_Uninitialized_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z proc near
.text$mn:000037D0                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Ufill(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *)+25p
.text$mn:000037D0
.text$mn:000037D0 var_1           = byte ptr -1
.text$mn:000037D0 arg_0           = dword ptr  8
.text$mn:000037D0 arg_4           = dword ptr  0Ch
.text$mn:000037D0 arg_8           = dword ptr  10h
.text$mn:000037D0 arg_C           = dword ptr  14h
.text$mn:000037D0
.text$mn:000037D0                 push    ebp
.text$mn:000037D1                 mov     ebp, esp
.text$mn:000037D3                 push    ecx
.text$mn:000037D4                 mov     eax, [ebp+arg_0]
.text$mn:000037D7                 push    eax
.text$mn:000037D8                 mov     ecx, [ebp+arg_0]
.text$mn:000037DB                 push    ecx
.text$mn:000037DC                 call    ??$_Ptr_cat@V?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@PAV?$vector@EV?$allocator@E@std@@@0@0@Z ; std::_Ptr_cat<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000037E1                 add     esp, 8
.text$mn:000037E4                 mov     [ebp+var_1], al
.text$mn:000037E7                 movzx   edx, [ebp+var_1]
.text$mn:000037EB                 push    edx
.text$mn:000037EC                 mov     eax, [ebp+arg_0]
.text$mn:000037EF                 push    eax
.text$mn:000037F0                 call    ??$_Val_type@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z ; std::_Val_type<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000037F5                 add     esp, 4
.text$mn:000037F8                 push    eax
.text$mn:000037F9                 mov     ecx, [ebp+arg_C]
.text$mn:000037FC                 push    ecx             ; int
.text$mn:000037FD                 mov     edx, [ebp+arg_8]
.text$mn:00003800                 push    edx             ; int
.text$mn:00003801                 mov     eax, [ebp+arg_4]
.text$mn:00003804                 push    eax             ; int
.text$mn:00003805                 mov     ecx, [ebp+arg_0]
.text$mn:00003808                 push    ecx             ; void *
.text$mn:00003809                 call    ??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)
.text$mn:0000380E                 add     esp, 18h
.text$mn:00003811                 mov     esp, ebp
.text$mn:00003813                 pop     ebp
.text$mn:00003814                 retn
.text$mn:00003814 ??$_Uninitialized_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z endp
.text$mn:00003814
.text$mn:00003814 ; ---------------------------------------------------------------------------
.text$mn:00003815                 align 4
.text$mn:00003815 _text$mn        ends
.text$mn:00003815
.text$mn:00003818 ; ===========================================================================
.text$mn:00003818
.text$mn:00003818 ; Segment type: Pure code
.text$mn:00003818 ; Segment permissions: Read/Execute
.text$mn:00003818 _text$mn        segment para public 'CODE' use32
.text$mn:00003818                 assume cs:_text$mn
.text$mn:00003818                 ;org 3818h
.text$mn:00003818 ; COMDAT (pick any)
.text$mn:00003818                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003818
.text$mn:00003818 ; =============== S U B R O U T I N E =======================================
.text$mn:00003818
.text$mn:00003818 ; Attributes: bp-based frame
.text$mn:00003818
.text$mn:00003818 ; unsigned char * __cdecl std::_Uninitialized_move<unsigned char *, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>>>(unsigned char *, unsigned char *, unsigned char *, struct std::_Wrap_alloc<class std::allocator<unsigned char>> &)
.text$mn:00003818                 public ??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.text$mn:00003818 ??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z proc near
.text$mn:00003818                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Umove<uchar *>(uchar *,uchar *,uchar *)+25p
.text$mn:00003818
.text$mn:00003818 arg_0           = dword ptr  8
.text$mn:00003818 arg_4           = dword ptr  0Ch
.text$mn:00003818 arg_8           = dword ptr  10h
.text$mn:00003818 arg_C           = dword ptr  14h
.text$mn:00003818
.text$mn:00003818                 push    ebp
.text$mn:00003819                 mov     ebp, esp
.text$mn:0000381B                 mov     eax, [ebp+arg_C]
.text$mn:0000381E                 push    eax             ; int
.text$mn:0000381F                 mov     ecx, [ebp+arg_8]
.text$mn:00003822                 push    ecx
.text$mn:00003823                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:00003828                 add     esp, 4
.text$mn:0000382B                 push    eax             ; Dst
.text$mn:0000382C                 mov     edx, [ebp+arg_4]
.text$mn:0000382F                 push    edx
.text$mn:00003830                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:00003835                 add     esp, 4
.text$mn:00003838                 push    eax             ; int
.text$mn:00003839                 mov     eax, [ebp+arg_0]
.text$mn:0000383C                 push    eax
.text$mn:0000383D                 call    ??$_Unchecked@PAE@std@@YAPAEPAE@Z ; std::_Unchecked<uchar *>(uchar *)
.text$mn:00003842                 add     esp, 4
.text$mn:00003845                 push    eax             ; Src
.text$mn:00003846                 call    ??$_Uninit_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Uninit_move<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:0000384B                 add     esp, 10h
.text$mn:0000384E                 push    eax
.text$mn:0000384F                 lea     ecx, [ebp+arg_8]
.text$mn:00003852                 push    ecx
.text$mn:00003853                 call    ??$_Rechecked@PAEPAE@std@@YAAAPAEAAPAEPAE@Z ; std::_Rechecked<uchar *,uchar *>(uchar * &,uchar *)
.text$mn:00003858                 add     esp, 8
.text$mn:0000385B                 mov     eax, [eax]
.text$mn:0000385D                 pop     ebp
.text$mn:0000385E                 retn
.text$mn:0000385E ??$_Uninitialized_move@PAEPAEU?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAPAEPAE00AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z endp
.text$mn:0000385E
.text$mn:0000385E ; ---------------------------------------------------------------------------
.text$mn:0000385F                 align 10h
.text$mn:0000385F _text$mn        ends
.text$mn:0000385F
.text$mn:00003860 ; ===========================================================================
.text$mn:00003860
.text$mn:00003860 ; Segment type: Pure code
.text$mn:00003860 ; Segment permissions: Read/Execute
.text$mn:00003860 _text$mn        segment para public 'CODE' use32
.text$mn:00003860                 assume cs:_text$mn
.text$mn:00003860                 ;org 3860h
.text$mn:00003860 ; COMDAT (pick any)
.text$mn:00003860                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003860
.text$mn:00003860 ; =============== S U B R O U T I N E =======================================
.text$mn:00003860
.text$mn:00003860 ; Attributes: bp-based frame
.text$mn:00003860
.text$mn:00003860 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Uninitialized_move<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, struct std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>> &)
.text$mn:00003860                 public ??$_Uninitialized_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z
.text$mn:00003860 ??$_Uninitialized_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z proc near
.text$mn:00003860                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Umove<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+25p
.text$mn:00003860
.text$mn:00003860 arg_0           = dword ptr  8
.text$mn:00003860 arg_4           = dword ptr  0Ch
.text$mn:00003860 arg_8           = dword ptr  10h
.text$mn:00003860 arg_C           = dword ptr  14h
.text$mn:00003860
.text$mn:00003860                 push    ebp
.text$mn:00003861                 mov     ebp, esp
.text$mn:00003863                 mov     eax, [ebp+arg_C]
.text$mn:00003866                 push    eax             ; int
.text$mn:00003867                 mov     ecx, [ebp+arg_8]
.text$mn:0000386A                 push    ecx
.text$mn:0000386B                 call    ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00003870                 add     esp, 4
.text$mn:00003873                 push    eax             ; void *
.text$mn:00003874                 mov     edx, [ebp+arg_4]
.text$mn:00003877                 push    edx
.text$mn:00003878                 call    ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:0000387D                 add     esp, 4
.text$mn:00003880                 push    eax             ; int
.text$mn:00003881                 mov     eax, [ebp+arg_0]
.text$mn:00003884                 push    eax
.text$mn:00003885                 call    ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:0000388A                 add     esp, 4
.text$mn:0000388D                 push    eax             ; int
.text$mn:0000388E                 call    ??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z ; std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)
.text$mn:00003893                 add     esp, 10h
.text$mn:00003896                 push    eax
.text$mn:00003897                 lea     ecx, [ebp+arg_8]
.text$mn:0000389A                 push    ecx
.text$mn:0000389B                 call    ??$_Rechecked@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAAAPAV?$vector@EV?$allocator@E@std@@@0@AAPAV10@PAV10@@Z ; std::_Rechecked<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> * &,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000038A0                 add     esp, 8
.text$mn:000038A3                 mov     eax, [eax]
.text$mn:000038A5                 pop     ebp
.text$mn:000038A6                 retn
.text$mn:000038A6 ??$_Uninitialized_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z endp
.text$mn:000038A6
.text$mn:000038A6 ; ---------------------------------------------------------------------------
.text$mn:000038A7                 align 4
.text$mn:000038A7 _text$mn        ends
.text$mn:000038A7
.text$mn:000038A8 ; ===========================================================================
.text$mn:000038A8
.text$mn:000038A8 ; Segment type: Pure code
.text$mn:000038A8 ; Segment permissions: Read/Execute
.text$mn:000038A8 _text$mn        segment para public 'CODE' use32
.text$mn:000038A8                 assume cs:_text$mn
.text$mn:000038A8                 ;org 38A8h
.text$mn:000038A8 ; COMDAT (pick any)
.text$mn:000038A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038A8
.text$mn:000038A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038A8
.text$mn:000038A8 ; Attributes: bp-based frame
.text$mn:000038A8
.text$mn:000038A8 ; unsigned char * __cdecl std::_Val_type<unsigned char *>(unsigned char *)
.text$mn:000038A8                 public ??$_Val_type@PAE@std@@YAPAEPAE@Z
.text$mn:000038A8 ??$_Val_type@PAE@std@@YAPAEPAE@Z proc near
.text$mn:000038A8                                         ; CODE XREF: std::_Uninit_move<uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)+20p
.text$mn:000038A8                 push    ebp
.text$mn:000038A9                 mov     ebp, esp
.text$mn:000038AB                 xor     eax, eax
.text$mn:000038AD                 pop     ebp
.text$mn:000038AE                 retn
.text$mn:000038AE ??$_Val_type@PAE@std@@YAPAEPAE@Z endp
.text$mn:000038AE
.text$mn:000038AE ; ---------------------------------------------------------------------------
.text$mn:000038AF                 align 10h
.text$mn:000038AF _text$mn        ends
.text$mn:000038AF
.text$mn:000038B0 ; ===========================================================================
.text$mn:000038B0
.text$mn:000038B0 ; Segment type: Pure code
.text$mn:000038B0 ; Segment permissions: Read/Execute
.text$mn:000038B0 _text$mn        segment para public 'CODE' use32
.text$mn:000038B0                 assume cs:_text$mn
.text$mn:000038B0                 ;org 38B0h
.text$mn:000038B0 ; COMDAT (pick any)
.text$mn:000038B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038B0
.text$mn:000038B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000038B0
.text$mn:000038B0 ; Attributes: bp-based frame
.text$mn:000038B0
.text$mn:000038B0 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::_Val_type<class std::vector<unsigned char, class std::allocator<unsigned char>> *>(class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:000038B0                 public ??$_Val_type@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z
.text$mn:000038B0 ??$_Val_type@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z proc near
.text$mn:000038B0                                         ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+20p
.text$mn:000038B0                                         ; std::_Uninitialized_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)+20p
.text$mn:000038B0                 push    ebp
.text$mn:000038B1                 mov     ebp, esp
.text$mn:000038B3                 xor     eax, eax
.text$mn:000038B5                 pop     ebp
.text$mn:000038B6                 retn
.text$mn:000038B6 ??$_Val_type@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z endp
.text$mn:000038B6
.text$mn:000038B6 ; ---------------------------------------------------------------------------
.text$mn:000038B7                 align 4
.text$mn:000038B7 _text$mn        ends
.text$mn:000038B7
.text$mn:000038B8 ; ===========================================================================
.text$mn:000038B8
.text$mn:000038B8 ; Segment type: Pure code
.text$mn:000038B8 ; Segment permissions: Read/Execute
.text$mn:000038B8 _text$mn        segment para public 'CODE' use32
.text$mn:000038B8                 assume cs:_text$mn
.text$mn:000038B8                 ;org 38B8h
.text$mn:000038B8 ; COMDAT (pick any)
.text$mn:000038B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038B8
.text$mn:000038B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038B8
.text$mn:000038B8 ; Attributes: bp-based frame
.text$mn:000038B8
.text$mn:000038B8 ; class std::vector<unsigned char, class std::allocator<unsigned char>> const * __cdecl std::addressof<class std::vector<unsigned char, class std::allocator<unsigned char>> const>(class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:000038B8                 public ??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPBV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z
.text$mn:000038B8 ??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPBV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z proc near
.text$mn:000038B8                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+112p
.text$mn:000038B8
.text$mn:000038B8 arg_0           = dword ptr  8
.text$mn:000038B8
.text$mn:000038B8                 push    ebp
.text$mn:000038B9                 mov     ebp, esp
.text$mn:000038BB                 mov     eax, [ebp+arg_0]
.text$mn:000038BE                 pop     ebp
.text$mn:000038BF                 retn
.text$mn:000038BF ??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPBV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z endp
.text$mn:000038BF
.text$mn:000038BF _text$mn        ends
.text$mn:000038BF
.text$mn:000038C0 ; ===========================================================================
.text$mn:000038C0
.text$mn:000038C0 ; Segment type: Pure code
.text$mn:000038C0 ; Segment permissions: Read/Execute
.text$mn:000038C0 _text$mn        segment para public 'CODE' use32
.text$mn:000038C0                 assume cs:_text$mn
.text$mn:000038C0                 ;org 38C0h
.text$mn:000038C0 ; COMDAT (pick any)
.text$mn:000038C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038C0
.text$mn:000038C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000038C0
.text$mn:000038C0 ; Attributes: bp-based frame
.text$mn:000038C0
.text$mn:000038C0 ; char * __cdecl std::addressof<char>(char &)
.text$mn:000038C0                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000038C0 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000038C0                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000038C0                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000038C0
.text$mn:000038C0 arg_0           = dword ptr  8
.text$mn:000038C0
.text$mn:000038C0                 push    ebp
.text$mn:000038C1                 mov     ebp, esp
.text$mn:000038C3                 mov     eax, [ebp+arg_0]
.text$mn:000038C6                 pop     ebp
.text$mn:000038C7                 retn
.text$mn:000038C7 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:000038C7
.text$mn:000038C7 _text$mn        ends
.text$mn:000038C7
.text$mn:000038C8 ; ===========================================================================
.text$mn:000038C8
.text$mn:000038C8 ; Segment type: Pure code
.text$mn:000038C8 ; Segment permissions: Read/Execute
.text$mn:000038C8 _text$mn        segment para public 'CODE' use32
.text$mn:000038C8                 assume cs:_text$mn
.text$mn:000038C8                 ;org 38C8h
.text$mn:000038C8 ; COMDAT (pick any)
.text$mn:000038C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038C8
.text$mn:000038C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038C8
.text$mn:000038C8 ; Attributes: bp-based frame
.text$mn:000038C8
.text$mn:000038C8 ; unsigned char * __cdecl std::addressof<unsigned char>(unsigned char &)
.text$mn:000038C8                 public ??$addressof@E@std@@YAPAEAAE@Z
.text$mn:000038C8 ??$addressof@E@std@@YAPAEAAE@Z proc near
.text$mn:000038C8                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+Dp
.text$mn:000038C8                                         ; std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+2Dp
.text$mn:000038C8
.text$mn:000038C8 arg_0           = dword ptr  8
.text$mn:000038C8
.text$mn:000038C8                 push    ebp
.text$mn:000038C9                 mov     ebp, esp
.text$mn:000038CB                 mov     eax, [ebp+arg_0]
.text$mn:000038CE                 pop     ebp
.text$mn:000038CF                 retn
.text$mn:000038CF ??$addressof@E@std@@YAPAEAAE@Z endp
.text$mn:000038CF
.text$mn:000038CF _text$mn        ends
.text$mn:000038CF
.text$mn:000038D0 ; ===========================================================================
.text$mn:000038D0
.text$mn:000038D0 ; Segment type: Pure code
.text$mn:000038D0 ; Segment permissions: Read/Execute
.text$mn:000038D0 _text$mn        segment para public 'CODE' use32
.text$mn:000038D0                 assume cs:_text$mn
.text$mn:000038D0                 ;org 38D0h
.text$mn:000038D0 ; COMDAT (pick any)
.text$mn:000038D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038D0
.text$mn:000038D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000038D0
.text$mn:000038D0 ; Attributes: bp-based frame
.text$mn:000038D0
.text$mn:000038D0 ; class std::vector<unsigned char, class std::allocator<unsigned char>> * __cdecl std::addressof<class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> &)
.text$mn:000038D0                 public ??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z
.text$mn:000038D0 ??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z proc near
.text$mn:000038D0                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+2D1p
.text$mn:000038D0
.text$mn:000038D0 arg_0           = dword ptr  8
.text$mn:000038D0
.text$mn:000038D0                 push    ebp
.text$mn:000038D1                 mov     ebp, esp
.text$mn:000038D3                 mov     eax, [ebp+arg_0]
.text$mn:000038D6                 pop     ebp
.text$mn:000038D7                 retn
.text$mn:000038D7 ??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z endp
.text$mn:000038D7
.text$mn:000038D7 _text$mn        ends
.text$mn:000038D7
.text$mn:000038D8 ; ===========================================================================
.text$mn:000038D8
.text$mn:000038D8 ; Segment type: Pure code
.text$mn:000038D8 ; Segment permissions: Read/Execute
.text$mn:000038D8 _text$mn        segment para public 'CODE' use32
.text$mn:000038D8                 assume cs:_text$mn
.text$mn:000038D8                 ;org 38D8h
.text$mn:000038D8 ; COMDAT (pick any)
.text$mn:000038D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038D8
.text$mn:000038D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038D8
.text$mn:000038D8 ; Attributes: bp-based frame
.text$mn:000038D8
.text$mn:000038D8 ; int __stdcall std::_Wrap_alloc<std::allocator<unsigned char>>::construct<unsigned char,unsigned char>(void *, int)
.text$mn:000038D8                 public ??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z
.text$mn:000038D8 ??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z proc near
.text$mn:000038D8                                         ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+DFp
.text$mn:000038D8                                         ; std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+94p ...
.text$mn:000038D8
.text$mn:000038D8 var_4           = dword ptr -4
.text$mn:000038D8 arg_0           = dword ptr  8
.text$mn:000038D8 arg_4           = dword ptr  0Ch
.text$mn:000038D8
.text$mn:000038D8                 push    ebp
.text$mn:000038D9                 mov     ebp, esp
.text$mn:000038DB                 push    ecx
.text$mn:000038DC                 mov     [ebp+var_4], ecx
.text$mn:000038DF                 mov     eax, [ebp+arg_4]
.text$mn:000038E2                 push    eax
.text$mn:000038E3                 call    ??$forward@E@std@@YA$$QAEAAE@Z ; std::forward<uchar>(uchar &)
.text$mn:000038E8                 add     esp, 4
.text$mn:000038EB                 push    eax             ; int
.text$mn:000038EC                 mov     ecx, [ebp+arg_0]
.text$mn:000038EF                 push    ecx             ; void *
.text$mn:000038F0                 mov     edx, [ebp+var_4]
.text$mn:000038F3                 push    edx             ; int
.text$mn:000038F4                 call    ??$construct@EE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE$$QAE@Z ; std::allocator_traits<std::allocator<uchar>>::construct<uchar,uchar>(std::allocator<uchar> &,uchar *,uchar &&)
.text$mn:000038F9                 add     esp, 0Ch
.text$mn:000038FC                 mov     esp, ebp
.text$mn:000038FE                 pop     ebp
.text$mn:000038FF                 retn    8
.text$mn:000038FF ??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z endp
.text$mn:000038FF
.text$mn:000038FF ; ---------------------------------------------------------------------------
.text$mn:00003902                 align 4
.text$mn:00003902 _text$mn        ends
.text$mn:00003902
.text$mn:00003904 ; ===========================================================================
.text$mn:00003904
.text$mn:00003904 ; Segment type: Pure code
.text$mn:00003904 ; Segment permissions: Read/Execute
.text$mn:00003904 _text$mn        segment para public 'CODE' use32
.text$mn:00003904                 assume cs:_text$mn
.text$mn:00003904                 ;org 3904h
.text$mn:00003904 ; COMDAT (pick any)
.text$mn:00003904                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003904
.text$mn:00003904 ; =============== S U B R O U T I N E =======================================
.text$mn:00003904
.text$mn:00003904 ; Attributes: bp-based frame
.text$mn:00003904
.text$mn:00003904 ; int __stdcall std::allocator<unsigned char>::construct<unsigned char,unsigned char>(void *, int)
.text$mn:00003904                 public ??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z
.text$mn:00003904 ??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z proc near
.text$mn:00003904                                         ; CODE XREF: std::allocator_traits<std::allocator<uchar>>::construct<uchar,uchar>(std::allocator<uchar> &,uchar *,uchar &&)+17p
.text$mn:00003904
.text$mn:00003904 var_1C          = dword ptr -1Ch
.text$mn:00003904 var_18          = dword ptr -18h
.text$mn:00003904 var_14          = dword ptr -14h
.text$mn:00003904 var_10          = dword ptr -10h
.text$mn:00003904 var_C           = dword ptr -0Ch
.text$mn:00003904 var_4           = dword ptr -4
.text$mn:00003904 arg_0           = dword ptr  8
.text$mn:00003904 arg_4           = dword ptr  0Ch
.text$mn:00003904
.text$mn:00003904                 push    ebp
.text$mn:00003905                 mov     ebp, esp
.text$mn:00003907                 push    0FFFFFFFFh
.text$mn:00003909                 push    offset __ehhandler$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z
.text$mn:0000390E                 mov     eax, large fs:0
.text$mn:00003914                 push    eax
.text$mn:00003915                 sub     esp, 10h
.text$mn:00003918                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000391D                 xor     eax, ebp
.text$mn:0000391F                 push    eax
.text$mn:00003920                 lea     eax, [ebp+var_C]
.text$mn:00003923                 mov     large fs:0, eax
.text$mn:00003929                 mov     [ebp+var_18], ecx
.text$mn:0000392C                 mov     eax, [ebp+arg_0]
.text$mn:0000392F                 push    eax             ; void *
.text$mn:00003930                 push    1               ; unsigned int
.text$mn:00003932                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003937                 add     esp, 8
.text$mn:0000393A                 mov     [ebp+var_10], eax
.text$mn:0000393D                 mov     [ebp+var_4], 0
.text$mn:00003944                 cmp     [ebp+var_10], 0
.text$mn:00003948                 jz      short loc_3965
.text$mn:0000394A                 mov     ecx, [ebp+arg_4]
.text$mn:0000394D                 push    ecx
.text$mn:0000394E                 call    ??$forward@E@std@@YA$$QAEAAE@Z ; std::forward<uchar>(uchar &)
.text$mn:00003953                 add     esp, 4
.text$mn:00003956                 mov     edx, [ebp+var_10]
.text$mn:00003959                 mov     al, [eax]
.text$mn:0000395B                 mov     [edx], al
.text$mn:0000395D                 mov     ecx, [ebp+var_10]
.text$mn:00003960                 mov     [ebp+var_14], ecx
.text$mn:00003963                 jmp     short loc_396C
.text$mn:00003965 ; ---------------------------------------------------------------------------
.text$mn:00003965
.text$mn:00003965 loc_3965:                               ; CODE XREF: std::allocator<uchar>::construct<uchar,uchar>(uchar *,uchar &&)+44j
.text$mn:00003965                 mov     [ebp+var_14], 0
.text$mn:0000396C
.text$mn:0000396C loc_396C:                               ; CODE XREF: std::allocator<uchar>::construct<uchar,uchar>(uchar *,uchar &&)+5Fj
.text$mn:0000396C                 mov     edx, [ebp+var_14]
.text$mn:0000396F                 mov     [ebp+var_1C], edx
.text$mn:00003972                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003979                 mov     ecx, [ebp+var_C]
.text$mn:0000397C                 mov     large fs:0, ecx
.text$mn:00003983                 pop     ecx
.text$mn:00003984                 mov     esp, ebp
.text$mn:00003986                 pop     ebp
.text$mn:00003987                 retn    8
.text$mn:00003987 ??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z endp
.text$mn:00003987
.text$mn:00003987 ; ---------------------------------------------------------------------------
.text$mn:0000398A                 align 4
.text$mn:0000398A _text$mn        ends
.text$mn:0000398A
.text$x:0000398C ; ===========================================================================
.text$x:0000398C
.text$x:0000398C ; Segment type: Pure code
.text$x:0000398C ; Segment permissions: Read/Execute
.text$x:0000398C _text$x         segment para public 'CODE' use32
.text$x:0000398C                 assume cs:_text$x
.text$x:0000398C                 ;org 398Ch
.text$x:0000398C ; COMDAT (pick associative to section at 3904)
.text$x:0000398C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000398C
.text$x:0000398C ; =============== S U B R O U T I N E =======================================
.text$x:0000398C
.text$x:0000398C
.text$x:0000398C __unwindfunclet$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z$0 proc near
.text$x:0000398C                                         ; DATA XREF: .xdata$x:00009DE0o
.text$x:0000398C                 mov     eax, [ebp+8]
.text$x:0000398F                 push    eax
.text$x:00003990                 mov     eax, [ebp-10h]
.text$x:00003993                 push    eax             ; void *
.text$x:00003994                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003999                 add     esp, 8
.text$x:0000399C                 retn
.text$x:0000399C __unwindfunclet$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z$0 endp
.text$x:0000399C
.text$x:0000399D
.text$x:0000399D ; =============== S U B R O U T I N E =======================================
.text$x:0000399D
.text$x:0000399D
.text$x:0000399D __ehhandler$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z proc near
.text$x:0000399D                                         ; DATA XREF: std::allocator<uchar>::construct<uchar,uchar>(uchar *,uchar &&)+5o
.text$x:0000399D
.text$x:0000399D arg_4           = dword ptr  8
.text$x:0000399D
.text$x:0000399D                 mov     edx, [esp+arg_4]
.text$x:000039A1                 lea     eax, [edx+0Ch]
.text$x:000039A4                 mov     ecx, [edx-14h]
.text$x:000039A7                 xor     ecx, eax
.text$x:000039A9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000039AE                 mov     eax, offset __ehfuncinfo$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z
.text$x:000039B3                 jmp     ___CxxFrameHandler3
.text$x:000039B3 __ehhandler$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z endp
.text$x:000039B3
.text$x:000039B3 _text$x         ends
.text$x:000039B3
.text$mn:000039B8 ; ===========================================================================
.text$mn:000039B8
.text$mn:000039B8 ; Segment type: Pure code
.text$mn:000039B8 ; Segment permissions: Read/Execute
.text$mn:000039B8 _text$mn        segment para public 'CODE' use32
.text$mn:000039B8                 assume cs:_text$mn
.text$mn:000039B8                 ;org 39B8h
.text$mn:000039B8 ; COMDAT (pick any)
.text$mn:000039B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039B8
.text$mn:000039B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000039B8
.text$mn:000039B8 ; Attributes: bp-based frame
.text$mn:000039B8
.text$mn:000039B8 ; int __cdecl std::allocator_traits<std::allocator<unsigned char>>::construct<unsigned char,unsigned char>(int, void *, int)
.text$mn:000039B8                 public ??$construct@EE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE$$QAE@Z
.text$mn:000039B8 ??$construct@EE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE$$QAE@Z proc near
.text$mn:000039B8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::construct<uchar,uchar>(uchar *,uchar &&)+1Cp
.text$mn:000039B8
.text$mn:000039B8 arg_0           = dword ptr  8
.text$mn:000039B8 arg_4           = dword ptr  0Ch
.text$mn:000039B8 arg_8           = dword ptr  10h
.text$mn:000039B8
.text$mn:000039B8                 push    ebp
.text$mn:000039B9                 mov     ebp, esp
.text$mn:000039BB                 mov     eax, [ebp+arg_8]
.text$mn:000039BE                 push    eax
.text$mn:000039BF                 call    ??$forward@E@std@@YA$$QAEAAE@Z ; std::forward<uchar>(uchar &)
.text$mn:000039C4                 add     esp, 4
.text$mn:000039C7                 push    eax             ; int
.text$mn:000039C8                 mov     ecx, [ebp+arg_4]
.text$mn:000039CB                 push    ecx             ; void *
.text$mn:000039CC                 mov     ecx, [ebp+arg_0]
.text$mn:000039CF                 call    ??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z ; std::allocator<uchar>::construct<uchar,uchar>(uchar *,uchar &&)
.text$mn:000039D4                 pop     ebp
.text$mn:000039D5                 retn
.text$mn:000039D5 ??$construct@EE@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE$$QAE@Z endp
.text$mn:000039D5
.text$mn:000039D5 ; ---------------------------------------------------------------------------
.text$mn:000039D6                 align 4
.text$mn:000039D6 _text$mn        ends
.text$mn:000039D6
.text$mn:000039D8 ; ===========================================================================
.text$mn:000039D8
.text$mn:000039D8 ; Segment type: Pure code
.text$mn:000039D8 ; Segment permissions: Read/Execute
.text$mn:000039D8 _text$mn        segment para public 'CODE' use32
.text$mn:000039D8                 assume cs:_text$mn
.text$mn:000039D8                 ;org 39D8h
.text$mn:000039D8 ; COMDAT (pick any)
.text$mn:000039D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039D8
.text$mn:000039D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000039D8
.text$mn:000039D8 ; Attributes: bp-based frame
.text$mn:000039D8
.text$mn:000039D8 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:000039D8                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:000039D8 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000039D8                                         ; CODE XREF: $LN19+4Bp
.text$mn:000039D8
.text$mn:000039D8 var_4           = dword ptr -4
.text$mn:000039D8 arg_0           = dword ptr  8
.text$mn:000039D8 arg_4           = dword ptr  0Ch
.text$mn:000039D8
.text$mn:000039D8                 push    ebp
.text$mn:000039D9                 mov     ebp, esp
.text$mn:000039DB                 push    ecx
.text$mn:000039DC                 mov     [ebp+var_4], ecx
.text$mn:000039DF                 mov     eax, [ebp+arg_4]
.text$mn:000039E2                 push    eax
.text$mn:000039E3                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000039E8                 add     esp, 4
.text$mn:000039EB                 push    eax             ; int
.text$mn:000039EC                 mov     ecx, [ebp+arg_0]
.text$mn:000039EF                 push    ecx             ; void *
.text$mn:000039F0                 mov     edx, [ebp+var_4]
.text$mn:000039F3                 push    edx             ; int
.text$mn:000039F4                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:000039F9                 add     esp, 0Ch
.text$mn:000039FC                 mov     esp, ebp
.text$mn:000039FE                 pop     ebp
.text$mn:000039FF                 retn    8
.text$mn:000039FF ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000039FF
.text$mn:000039FF ; ---------------------------------------------------------------------------
.text$mn:00003A02                 align 4
.text$mn:00003A02 _text$mn        ends
.text$mn:00003A02
.text$mn:00003A04 ; ===========================================================================
.text$mn:00003A04
.text$mn:00003A04 ; Segment type: Pure code
.text$mn:00003A04 ; Segment permissions: Read/Execute
.text$mn:00003A04 _text$mn        segment para public 'CODE' use32
.text$mn:00003A04                 assume cs:_text$mn
.text$mn:00003A04                 ;org 3A04h
.text$mn:00003A04 ; COMDAT (pick any)
.text$mn:00003A04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003A04
.text$mn:00003A04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003A04
.text$mn:00003A04 ; Attributes: bp-based frame
.text$mn:00003A04
.text$mn:00003A04 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00003A04                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00003A04 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00003A04                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00003A04
.text$mn:00003A04 var_1C          = dword ptr -1Ch
.text$mn:00003A04 var_18          = dword ptr -18h
.text$mn:00003A04 var_14          = dword ptr -14h
.text$mn:00003A04 var_10          = dword ptr -10h
.text$mn:00003A04 var_C           = dword ptr -0Ch
.text$mn:00003A04 var_4           = dword ptr -4
.text$mn:00003A04 arg_0           = dword ptr  8
.text$mn:00003A04 arg_4           = dword ptr  0Ch
.text$mn:00003A04
.text$mn:00003A04                 push    ebp
.text$mn:00003A05                 mov     ebp, esp
.text$mn:00003A07                 push    0FFFFFFFFh
.text$mn:00003A09                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00003A0E                 mov     eax, large fs:0
.text$mn:00003A14                 push    eax
.text$mn:00003A15                 sub     esp, 10h
.text$mn:00003A18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003A1D                 xor     eax, ebp
.text$mn:00003A1F                 push    eax
.text$mn:00003A20                 lea     eax, [ebp+var_C]
.text$mn:00003A23                 mov     large fs:0, eax
.text$mn:00003A29                 mov     [ebp+var_18], ecx
.text$mn:00003A2C                 mov     eax, [ebp+arg_0]
.text$mn:00003A2F                 push    eax             ; void *
.text$mn:00003A30                 push    4               ; unsigned int
.text$mn:00003A32                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003A37                 add     esp, 8
.text$mn:00003A3A                 mov     [ebp+var_10], eax
.text$mn:00003A3D                 mov     [ebp+var_4], 0
.text$mn:00003A44                 cmp     [ebp+var_10], 0
.text$mn:00003A48                 jz      short loc_3A65
.text$mn:00003A4A                 mov     ecx, [ebp+arg_4]
.text$mn:00003A4D                 push    ecx
.text$mn:00003A4E                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00003A53                 add     esp, 4
.text$mn:00003A56                 mov     edx, [ebp+var_10]
.text$mn:00003A59                 mov     eax, [eax]
.text$mn:00003A5B                 mov     [edx], eax
.text$mn:00003A5D                 mov     ecx, [ebp+var_10]
.text$mn:00003A60                 mov     [ebp+var_14], ecx
.text$mn:00003A63                 jmp     short loc_3A6C
.text$mn:00003A65 ; ---------------------------------------------------------------------------
.text$mn:00003A65
.text$mn:00003A65 loc_3A65:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00003A65                 mov     [ebp+var_14], 0
.text$mn:00003A6C
.text$mn:00003A6C loc_3A6C:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00003A6C                 mov     edx, [ebp+var_14]
.text$mn:00003A6F                 mov     [ebp+var_1C], edx
.text$mn:00003A72                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003A79                 mov     ecx, [ebp+var_C]
.text$mn:00003A7C                 mov     large fs:0, ecx
.text$mn:00003A83                 pop     ecx
.text$mn:00003A84                 mov     esp, ebp
.text$mn:00003A86                 pop     ebp
.text$mn:00003A87                 retn    8
.text$mn:00003A87 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00003A87
.text$mn:00003A87 ; ---------------------------------------------------------------------------
.text$mn:00003A8A                 align 4
.text$mn:00003A8A _text$mn        ends
.text$mn:00003A8A
.text$x:00003A8C ; ===========================================================================
.text$x:00003A8C
.text$x:00003A8C ; Segment type: Pure code
.text$x:00003A8C ; Segment permissions: Read/Execute
.text$x:00003A8C _text$x         segment para public 'CODE' use32
.text$x:00003A8C                 assume cs:_text$x
.text$x:00003A8C                 ;org 3A8Ch
.text$x:00003A8C ; COMDAT (pick associative to section at 3A04)
.text$x:00003A8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003A8C
.text$x:00003A8C ; =============== S U B R O U T I N E =======================================
.text$x:00003A8C
.text$x:00003A8C
.text$x:00003A8C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00003A8C                                         ; DATA XREF: .xdata$x:00009E0Co
.text$x:00003A8C                 mov     eax, [ebp+8]
.text$x:00003A8F                 push    eax
.text$x:00003A90                 mov     eax, [ebp-10h]
.text$x:00003A93                 push    eax             ; void *
.text$x:00003A94                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003A99                 add     esp, 8
.text$x:00003A9C                 retn
.text$x:00003A9C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00003A9C
.text$x:00003A9D
.text$x:00003A9D ; =============== S U B R O U T I N E =======================================
.text$x:00003A9D
.text$x:00003A9D
.text$x:00003A9D __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00003A9D                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00003A9D
.text$x:00003A9D arg_4           = dword ptr  8
.text$x:00003A9D
.text$x:00003A9D                 mov     edx, [esp+arg_4]
.text$x:00003AA1                 lea     eax, [edx+0Ch]
.text$x:00003AA4                 mov     ecx, [edx-14h]
.text$x:00003AA7                 xor     ecx, eax
.text$x:00003AA9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003AAE                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00003AB3                 jmp     ___CxxFrameHandler3
.text$x:00003AB3 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00003AB3
.text$x:00003AB3 _text$x         ends
.text$x:00003AB3
.text$mn:00003AB8 ; ===========================================================================
.text$mn:00003AB8
.text$mn:00003AB8 ; Segment type: Pure code
.text$mn:00003AB8 ; Segment permissions: Read/Execute
.text$mn:00003AB8 _text$mn        segment para public 'CODE' use32
.text$mn:00003AB8                 assume cs:_text$mn
.text$mn:00003AB8                 ;org 3AB8h
.text$mn:00003AB8 ; COMDAT (pick any)
.text$mn:00003AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AB8
.text$mn:00003AB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AB8
.text$mn:00003AB8 ; Attributes: bp-based frame
.text$mn:00003AB8
.text$mn:00003AB8 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00003AB8                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00003AB8 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00003AB8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00003AB8
.text$mn:00003AB8 arg_0           = dword ptr  8
.text$mn:00003AB8 arg_4           = dword ptr  0Ch
.text$mn:00003AB8 arg_8           = dword ptr  10h
.text$mn:00003AB8
.text$mn:00003AB8                 push    ebp
.text$mn:00003AB9                 mov     ebp, esp
.text$mn:00003ABB                 mov     eax, [ebp+arg_8]
.text$mn:00003ABE                 push    eax
.text$mn:00003ABF                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00003AC4                 add     esp, 4
.text$mn:00003AC7                 push    eax             ; int
.text$mn:00003AC8                 mov     ecx, [ebp+arg_4]
.text$mn:00003ACB                 push    ecx             ; void *
.text$mn:00003ACC                 mov     ecx, [ebp+arg_0]
.text$mn:00003ACF                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00003AD4                 pop     ebp
.text$mn:00003AD5                 retn
.text$mn:00003AD5 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00003AD5
.text$mn:00003AD5 ; ---------------------------------------------------------------------------
.text$mn:00003AD6                 align 4
.text$mn:00003AD6 _text$mn        ends
.text$mn:00003AD6
.text$mn:00003AD8 ; ===========================================================================
.text$mn:00003AD8
.text$mn:00003AD8 ; Segment type: Pure code
.text$mn:00003AD8 ; Segment permissions: Read/Execute
.text$mn:00003AD8 _text$mn        segment para public 'CODE' use32
.text$mn:00003AD8                 assume cs:_text$mn
.text$mn:00003AD8                 ;org 3AD8h
.text$mn:00003AD8 ; COMDAT (pick any)
.text$mn:00003AD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AD8
.text$mn:00003AD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AD8
.text$mn:00003AD8 ; Attributes: bp-based frame
.text$mn:00003AD8
.text$mn:00003AD8 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00003AD8                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00003AD8 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00003AD8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Alloc_proxy(void)+32p
.text$mn:00003AD8
.text$mn:00003AD8 var_4           = dword ptr -4
.text$mn:00003AD8 arg_0           = dword ptr  8
.text$mn:00003AD8 arg_4           = dword ptr  0Ch
.text$mn:00003AD8
.text$mn:00003AD8                 push    ebp
.text$mn:00003AD9                 mov     ebp, esp
.text$mn:00003ADB                 push    ecx
.text$mn:00003ADC                 mov     [ebp+var_4], ecx
.text$mn:00003ADF                 mov     eax, [ebp+arg_4]
.text$mn:00003AE2                 push    eax
.text$mn:00003AE3                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00003AE8                 add     esp, 4
.text$mn:00003AEB                 push    eax             ; int
.text$mn:00003AEC                 mov     ecx, [ebp+arg_0]
.text$mn:00003AEF                 push    ecx             ; void *
.text$mn:00003AF0                 mov     edx, [ebp+var_4]
.text$mn:00003AF3                 push    edx             ; int
.text$mn:00003AF4                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003AF9                 add     esp, 0Ch
.text$mn:00003AFC                 mov     esp, ebp
.text$mn:00003AFE                 pop     ebp
.text$mn:00003AFF                 retn    8
.text$mn:00003AFF ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00003AFF
.text$mn:00003AFF ; ---------------------------------------------------------------------------
.text$mn:00003B02                 align 4
.text$mn:00003B02 _text$mn        ends
.text$mn:00003B02
.text$mn:00003B04 ; ===========================================================================
.text$mn:00003B04
.text$mn:00003B04 ; Segment type: Pure code
.text$mn:00003B04 ; Segment permissions: Read/Execute
.text$mn:00003B04 _text$mn        segment para public 'CODE' use32
.text$mn:00003B04                 assume cs:_text$mn
.text$mn:00003B04                 ;org 3B04h
.text$mn:00003B04 ; COMDAT (pick any)
.text$mn:00003B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B04
.text$mn:00003B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B04
.text$mn:00003B04 ; Attributes: bp-based frame
.text$mn:00003B04
.text$mn:00003B04 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00003B04                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00003B04 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00003B04                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00003B04                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00003B04
.text$mn:00003B04 var_1C          = dword ptr -1Ch
.text$mn:00003B04 var_18          = dword ptr -18h
.text$mn:00003B04 var_14          = dword ptr -14h
.text$mn:00003B04 var_10          = dword ptr -10h
.text$mn:00003B04 var_C           = dword ptr -0Ch
.text$mn:00003B04 var_4           = dword ptr -4
.text$mn:00003B04 arg_0           = dword ptr  8
.text$mn:00003B04 arg_4           = dword ptr  0Ch
.text$mn:00003B04
.text$mn:00003B04                 push    ebp
.text$mn:00003B05                 mov     ebp, esp
.text$mn:00003B07                 push    0FFFFFFFFh
.text$mn:00003B09                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00003B0E                 mov     eax, large fs:0
.text$mn:00003B14                 push    eax
.text$mn:00003B15                 sub     esp, 10h
.text$mn:00003B18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003B1D                 xor     eax, ebp
.text$mn:00003B1F                 push    eax
.text$mn:00003B20                 lea     eax, [ebp+var_C]
.text$mn:00003B23                 mov     large fs:0, eax
.text$mn:00003B29                 mov     [ebp+var_18], ecx
.text$mn:00003B2C                 mov     eax, [ebp+arg_0]
.text$mn:00003B2F                 push    eax             ; void *
.text$mn:00003B30                 push    8               ; unsigned int
.text$mn:00003B32                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003B37                 add     esp, 8
.text$mn:00003B3A                 mov     [ebp+var_10], eax
.text$mn:00003B3D                 mov     [ebp+var_4], 0
.text$mn:00003B44                 cmp     [ebp+var_10], 0
.text$mn:00003B48                 jz      short loc_3B6B
.text$mn:00003B4A                 mov     ecx, [ebp+arg_4]
.text$mn:00003B4D                 push    ecx
.text$mn:00003B4E                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00003B53                 add     esp, 4
.text$mn:00003B56                 mov     edx, [eax]
.text$mn:00003B58                 mov     eax, [eax+4]
.text$mn:00003B5B                 mov     ecx, [ebp+var_10]
.text$mn:00003B5E                 mov     [ecx], edx
.text$mn:00003B60                 mov     [ecx+4], eax
.text$mn:00003B63                 mov     edx, [ebp+var_10]
.text$mn:00003B66                 mov     [ebp+var_14], edx
.text$mn:00003B69                 jmp     short loc_3B72
.text$mn:00003B6B ; ---------------------------------------------------------------------------
.text$mn:00003B6B
.text$mn:00003B6B loc_3B6B:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00003B6B                 mov     [ebp+var_14], 0
.text$mn:00003B72
.text$mn:00003B72 loc_3B72:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00003B72                 mov     eax, [ebp+var_14]
.text$mn:00003B75                 mov     [ebp+var_1C], eax
.text$mn:00003B78                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003B7F                 mov     ecx, [ebp+var_C]
.text$mn:00003B82                 mov     large fs:0, ecx
.text$mn:00003B89                 pop     ecx
.text$mn:00003B8A                 mov     esp, ebp
.text$mn:00003B8C                 pop     ebp
.text$mn:00003B8D                 retn    8
.text$mn:00003B8D ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00003B8D
.text$mn:00003B8D _text$mn        ends
.text$mn:00003B8D
.text$x:00003B90 ; ===========================================================================
.text$x:00003B90
.text$x:00003B90 ; Segment type: Pure code
.text$x:00003B90 ; Segment permissions: Read/Execute
.text$x:00003B90 _text$x         segment para public 'CODE' use32
.text$x:00003B90                 assume cs:_text$x
.text$x:00003B90                 ;org 3B90h
.text$x:00003B90 ; COMDAT (pick associative to section at 3B04)
.text$x:00003B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003B90
.text$x:00003B90 ; =============== S U B R O U T I N E =======================================
.text$x:00003B90
.text$x:00003B90
.text$x:00003B90 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00003B90                                         ; DATA XREF: .xdata$x:00009CECo
.text$x:00003B90                 mov     eax, [ebp+8]
.text$x:00003B93                 push    eax
.text$x:00003B94                 mov     eax, [ebp-10h]
.text$x:00003B97                 push    eax             ; void *
.text$x:00003B98                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003B9D                 add     esp, 8
.text$x:00003BA0                 retn
.text$x:00003BA0 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00003BA0
.text$x:00003BA1
.text$x:00003BA1 ; =============== S U B R O U T I N E =======================================
.text$x:00003BA1
.text$x:00003BA1
.text$x:00003BA1 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00003BA1                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00003BA1
.text$x:00003BA1 arg_4           = dword ptr  8
.text$x:00003BA1
.text$x:00003BA1                 mov     edx, [esp+arg_4]
.text$x:00003BA5                 lea     eax, [edx+0Ch]
.text$x:00003BA8                 mov     ecx, [edx-14h]
.text$x:00003BAB                 xor     ecx, eax
.text$x:00003BAD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003BB2                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:00003BB7                 jmp     ___CxxFrameHandler3
.text$x:00003BB7 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:00003BB7
.text$x:00003BB7 _text$x         ends
.text$x:00003BB7
.text$mn:00003BBC ; ===========================================================================
.text$mn:00003BBC
.text$mn:00003BBC ; Segment type: Pure code
.text$mn:00003BBC ; Segment permissions: Read/Execute
.text$mn:00003BBC _text$mn        segment para public 'CODE' use32
.text$mn:00003BBC                 assume cs:_text$mn
.text$mn:00003BBC                 ;org 3BBCh
.text$mn:00003BBC ; COMDAT (pick any)
.text$mn:00003BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BBC
.text$mn:00003BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BBC
.text$mn:00003BBC ; Attributes: bp-based frame
.text$mn:00003BBC
.text$mn:00003BBC ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:00003BBC                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:00003BBC ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:00003BBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:00003BBC
.text$mn:00003BBC arg_0           = dword ptr  8
.text$mn:00003BBC arg_4           = dword ptr  0Ch
.text$mn:00003BBC arg_8           = dword ptr  10h
.text$mn:00003BBC
.text$mn:00003BBC                 push    ebp
.text$mn:00003BBD                 mov     ebp, esp
.text$mn:00003BBF                 mov     eax, [ebp+arg_8]
.text$mn:00003BC2                 push    eax
.text$mn:00003BC3                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00003BC8                 add     esp, 4
.text$mn:00003BCB                 push    eax             ; int
.text$mn:00003BCC                 mov     ecx, [ebp+arg_4]
.text$mn:00003BCF                 push    ecx             ; void *
.text$mn:00003BD0                 mov     ecx, [ebp+arg_0]
.text$mn:00003BD3                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003BD8                 pop     ebp
.text$mn:00003BD9                 retn
.text$mn:00003BD9 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00003BD9
.text$mn:00003BD9 ; ---------------------------------------------------------------------------
.text$mn:00003BDA                 align 4
.text$mn:00003BDA _text$mn        ends
.text$mn:00003BDA
.text$mn:00003BDC ; ===========================================================================
.text$mn:00003BDC
.text$mn:00003BDC ; Segment type: Pure code
.text$mn:00003BDC ; Segment permissions: Read/Execute
.text$mn:00003BDC _text$mn        segment para public 'CODE' use32
.text$mn:00003BDC                 assume cs:_text$mn
.text$mn:00003BDC                 ;org 3BDCh
.text$mn:00003BDC ; COMDAT (pick any)
.text$mn:00003BDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003BDC
.text$mn:00003BDC ; =============== S U B R O U T I N E =======================================
.text$mn:00003BDC
.text$mn:00003BDC ; Attributes: bp-based frame
.text$mn:00003BDC
.text$mn:00003BDC ; int __stdcall std::_Wrap_alloc<std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>::construct<std::vector<unsigned char,std::allocator<unsigned char>>,std::vector<unsigned char,std::allocator<unsigned char>> const &>(void *, int)
.text$mn:00003BDC                 public ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@ABV21@@Z
.text$mn:00003BDC ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@ABV21@@Z proc near
.text$mn:00003BDC                                         ; CODE XREF: std::_Uninit_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+5Cp
.text$mn:00003BDC
.text$mn:00003BDC var_4           = dword ptr -4
.text$mn:00003BDC arg_0           = dword ptr  8
.text$mn:00003BDC arg_4           = dword ptr  0Ch
.text$mn:00003BDC
.text$mn:00003BDC                 push    ebp
.text$mn:00003BDD                 mov     ebp, esp
.text$mn:00003BDF                 push    ecx
.text$mn:00003BE0                 mov     [ebp+var_4], ecx
.text$mn:00003BE3                 mov     eax, [ebp+arg_4]
.text$mn:00003BE6                 push    eax
.text$mn:00003BE7                 call    ??$forward@ABV?$vector@EV?$allocator@E@std@@@std@@@std@@YAABV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>> const &>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00003BEC                 add     esp, 4
.text$mn:00003BEF                 push    eax             ; int
.text$mn:00003BF0                 mov     ecx, [ebp+arg_0]
.text$mn:00003BF3                 push    ecx             ; void *
.text$mn:00003BF4                 mov     edx, [ebp+var_4]
.text$mn:00003BF7                 push    edx             ; int
.text$mn:00003BF8                 call    ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@ABV31@@Z ; std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>> const &>(std::allocator<std::vector<uchar,std::allocator<uchar>>> &,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00003BFD                 add     esp, 0Ch
.text$mn:00003C00                 mov     esp, ebp
.text$mn:00003C02                 pop     ebp
.text$mn:00003C03                 retn    8
.text$mn:00003C03 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@ABV21@@Z endp
.text$mn:00003C03
.text$mn:00003C03 ; ---------------------------------------------------------------------------
.text$mn:00003C06                 align 4
.text$mn:00003C06 _text$mn        ends
.text$mn:00003C06
.text$mn:00003C08 ; ===========================================================================
.text$mn:00003C08
.text$mn:00003C08 ; Segment type: Pure code
.text$mn:00003C08 ; Segment permissions: Read/Execute
.text$mn:00003C08 _text$mn        segment para public 'CODE' use32
.text$mn:00003C08                 assume cs:_text$mn
.text$mn:00003C08                 ;org 3C08h
.text$mn:00003C08 ; COMDAT (pick any)
.text$mn:00003C08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C08
.text$mn:00003C08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C08
.text$mn:00003C08 ; Attributes: bp-based frame
.text$mn:00003C08
.text$mn:00003C08 ; int __cdecl std::allocator_traits<std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>::construct<std::vector<unsigned char,std::allocator<unsigned char>>,std::vector<unsigned char,std::allocator<unsigned char>> const &>(int, void *, int)
.text$mn:00003C08                 public ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@ABV31@@Z
.text$mn:00003C08 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@ABV31@@Z proc near
.text$mn:00003C08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>> const &>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+1Cp
.text$mn:00003C08
.text$mn:00003C08 arg_0           = dword ptr  8
.text$mn:00003C08 arg_4           = dword ptr  0Ch
.text$mn:00003C08 arg_8           = dword ptr  10h
.text$mn:00003C08
.text$mn:00003C08                 push    ebp
.text$mn:00003C09                 mov     ebp, esp
.text$mn:00003C0B                 mov     eax, [ebp+arg_8]
.text$mn:00003C0E                 push    eax
.text$mn:00003C0F                 call    ??$forward@ABV?$vector@EV?$allocator@E@std@@@std@@@std@@YAABV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>> const &>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00003C14                 add     esp, 4
.text$mn:00003C17                 push    eax             ; int
.text$mn:00003C18                 mov     ecx, [ebp+arg_4]
.text$mn:00003C1B                 push    ecx             ; void *
.text$mn:00003C1C                 mov     ecx, [ebp+arg_0]
.text$mn:00003C1F                 call    ?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00003C24                 pop     ebp
.text$mn:00003C25                 retn
.text$mn:00003C25 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@ABV12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@ABV31@@Z endp
.text$mn:00003C25
.text$mn:00003C25 ; ---------------------------------------------------------------------------
.text$mn:00003C26                 align 4
.text$mn:00003C26 _text$mn        ends
.text$mn:00003C26
.text$mn:00003C28 ; ===========================================================================
.text$mn:00003C28
.text$mn:00003C28 ; Segment type: Pure code
.text$mn:00003C28 ; Segment permissions: Read/Execute
.text$mn:00003C28 _text$mn        segment para public 'CODE' use32
.text$mn:00003C28                 assume cs:_text$mn
.text$mn:00003C28                 ;org 3C28h
.text$mn:00003C28 ; COMDAT (pick any)
.text$mn:00003C28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C28
.text$mn:00003C28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C28
.text$mn:00003C28 ; Attributes: bp-based frame
.text$mn:00003C28
.text$mn:00003C28 ; int __stdcall std::_Wrap_alloc<std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>::construct<std::vector<unsigned char,std::allocator<unsigned char>>,std::vector<unsigned char,std::allocator<unsigned char>>>(void *, int)
.text$mn:00003C28                 public ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z
.text$mn:00003C28 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z proc near
.text$mn:00003C28                                         ; CODE XREF: std::_Uninit_move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::allocator<std::vector<uchar,std::allocator<uchar>>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+8Ep
.text$mn:00003C28
.text$mn:00003C28 var_4           = dword ptr -4
.text$mn:00003C28 arg_0           = dword ptr  8
.text$mn:00003C28 arg_4           = dword ptr  0Ch
.text$mn:00003C28
.text$mn:00003C28                 push    ebp
.text$mn:00003C29                 mov     ebp, esp
.text$mn:00003C2B                 push    ecx
.text$mn:00003C2C                 mov     [ebp+var_4], ecx
.text$mn:00003C2F                 mov     eax, [ebp+arg_4]
.text$mn:00003C32                 push    eax
.text$mn:00003C33                 call    ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:00003C38                 add     esp, 4
.text$mn:00003C3B                 push    eax             ; int
.text$mn:00003C3C                 mov     ecx, [ebp+arg_0]
.text$mn:00003C3F                 push    ecx             ; void *
.text$mn:00003C40                 mov     edx, [ebp+var_4]
.text$mn:00003C43                 push    edx             ; int
.text$mn:00003C44                 call    ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@$$QAV31@@Z ; std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::allocator<std::vector<uchar,std::allocator<uchar>>> &,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:00003C49                 add     esp, 0Ch
.text$mn:00003C4C                 mov     esp, ebp
.text$mn:00003C4E                 pop     ebp
.text$mn:00003C4F                 retn    8
.text$mn:00003C4F ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z endp
.text$mn:00003C4F
.text$mn:00003C4F ; ---------------------------------------------------------------------------
.text$mn:00003C52                 align 4
.text$mn:00003C52 _text$mn        ends
.text$mn:00003C52
.text$mn:00003C54 ; ===========================================================================
.text$mn:00003C54
.text$mn:00003C54 ; Segment type: Pure code
.text$mn:00003C54 ; Segment permissions: Read/Execute
.text$mn:00003C54 _text$mn        segment para public 'CODE' use32
.text$mn:00003C54                 assume cs:_text$mn
.text$mn:00003C54                 ;org 3C54h
.text$mn:00003C54 ; COMDAT (pick any)
.text$mn:00003C54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C54
.text$mn:00003C54 ; =============== S U B R O U T I N E =======================================
.text$mn:00003C54
.text$mn:00003C54 ; Attributes: bp-based frame
.text$mn:00003C54
.text$mn:00003C54 ; int __stdcall std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>::construct<std::vector<unsigned char,std::allocator<unsigned char>>,std::vector<unsigned char,std::allocator<unsigned char>>>(void *, int)
.text$mn:00003C54                 public ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z
.text$mn:00003C54 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z proc near
.text$mn:00003C54                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::allocator<std::vector<uchar,std::allocator<uchar>>> &,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)+17p
.text$mn:00003C54
.text$mn:00003C54 var_1C          = dword ptr -1Ch
.text$mn:00003C54 var_18          = dword ptr -18h
.text$mn:00003C54 var_14          = dword ptr -14h
.text$mn:00003C54 var_10          = dword ptr -10h
.text$mn:00003C54 var_C           = dword ptr -0Ch
.text$mn:00003C54 var_4           = dword ptr -4
.text$mn:00003C54 arg_0           = dword ptr  8
.text$mn:00003C54 arg_4           = dword ptr  0Ch
.text$mn:00003C54
.text$mn:00003C54                 push    ebp
.text$mn:00003C55                 mov     ebp, esp
.text$mn:00003C57                 push    0FFFFFFFFh
.text$mn:00003C59                 push    offset __ehhandler$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z
.text$mn:00003C5E                 mov     eax, large fs:0
.text$mn:00003C64                 push    eax
.text$mn:00003C65                 sub     esp, 10h
.text$mn:00003C68                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003C6D                 xor     eax, ebp
.text$mn:00003C6F                 push    eax
.text$mn:00003C70                 lea     eax, [ebp+var_C]
.text$mn:00003C73                 mov     large fs:0, eax
.text$mn:00003C79                 mov     [ebp+var_18], ecx
.text$mn:00003C7C                 mov     eax, [ebp+arg_0]
.text$mn:00003C7F                 push    eax             ; void *
.text$mn:00003C80                 push    10h             ; unsigned int
.text$mn:00003C82                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00003C87                 add     esp, 8
.text$mn:00003C8A                 mov     [ebp+var_10], eax
.text$mn:00003C8D                 mov     [ebp+var_4], 0
.text$mn:00003C94                 cmp     [ebp+var_10], 0
.text$mn:00003C98                 jz      short loc_3CB4
.text$mn:00003C9A                 mov     ecx, [ebp+arg_4]
.text$mn:00003C9D                 push    ecx
.text$mn:00003C9E                 call    ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:00003CA3                 add     esp, 4
.text$mn:00003CA6                 push    eax
.text$mn:00003CA7                 mov     ecx, [ebp+var_10]
.text$mn:00003CAA                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:00003CAF                 mov     [ebp+var_14], eax
.text$mn:00003CB2                 jmp     short loc_3CBB
.text$mn:00003CB4 ; ---------------------------------------------------------------------------
.text$mn:00003CB4
.text$mn:00003CB4 loc_3CB4:                               ; CODE XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)+44j
.text$mn:00003CB4                 mov     [ebp+var_14], 0
.text$mn:00003CBB
.text$mn:00003CBB loc_3CBB:                               ; CODE XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)+5Ej
.text$mn:00003CBB                 mov     edx, [ebp+var_14]
.text$mn:00003CBE                 mov     [ebp+var_1C], edx
.text$mn:00003CC1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003CC8                 mov     ecx, [ebp+var_C]
.text$mn:00003CCB                 mov     large fs:0, ecx
.text$mn:00003CD2                 pop     ecx
.text$mn:00003CD3                 mov     esp, ebp
.text$mn:00003CD5                 pop     ebp
.text$mn:00003CD6                 retn    8
.text$mn:00003CD6 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z endp
.text$mn:00003CD6
.text$mn:00003CD6 ; ---------------------------------------------------------------------------
.text$mn:00003CD9                 align 4
.text$mn:00003CD9 _text$mn        ends
.text$mn:00003CD9
.text$x:00003CDC ; ===========================================================================
.text$x:00003CDC
.text$x:00003CDC ; Segment type: Pure code
.text$x:00003CDC ; Segment permissions: Read/Execute
.text$x:00003CDC _text$x         segment para public 'CODE' use32
.text$x:00003CDC                 assume cs:_text$x
.text$x:00003CDC                 ;org 3CDCh
.text$x:00003CDC ; COMDAT (pick associative to section at 3C54)
.text$x:00003CDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003CDC
.text$x:00003CDC ; =============== S U B R O U T I N E =======================================
.text$x:00003CDC
.text$x:00003CDC
.text$x:00003CDC __unwindfunclet$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z$0 proc near
.text$x:00003CDC                                         ; DATA XREF: .xdata$x:0000A1ECo
.text$x:00003CDC                 mov     eax, [ebp+8]
.text$x:00003CDF                 push    eax
.text$x:00003CE0                 mov     eax, [ebp-10h]
.text$x:00003CE3                 push    eax             ; void *
.text$x:00003CE4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00003CE9                 add     esp, 8
.text$x:00003CEC                 retn
.text$x:00003CEC __unwindfunclet$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z$0 endp
.text$x:00003CEC
.text$x:00003CED
.text$x:00003CED ; =============== S U B R O U T I N E =======================================
.text$x:00003CED
.text$x:00003CED
.text$x:00003CED __ehhandler$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z proc near
.text$x:00003CED                                         ; DATA XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)+5o
.text$x:00003CED
.text$x:00003CED arg_4           = dword ptr  8
.text$x:00003CED
.text$x:00003CED                 mov     edx, [esp+arg_4]
.text$x:00003CF1                 lea     eax, [edx+0Ch]
.text$x:00003CF4                 mov     ecx, [edx-14h]
.text$x:00003CF7                 xor     ecx, eax
.text$x:00003CF9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003CFE                 mov     eax, offset __ehfuncinfo$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z
.text$x:00003D03                 jmp     ___CxxFrameHandler3
.text$x:00003D03 __ehhandler$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z endp
.text$x:00003D03
.text$x:00003D03 _text$x         ends
.text$x:00003D03
.text$mn:00003D08 ; ===========================================================================
.text$mn:00003D08
.text$mn:00003D08 ; Segment type: Pure code
.text$mn:00003D08 ; Segment permissions: Read/Execute
.text$mn:00003D08 _text$mn        segment para public 'CODE' use32
.text$mn:00003D08                 assume cs:_text$mn
.text$mn:00003D08                 ;org 3D08h
.text$mn:00003D08 ; COMDAT (pick any)
.text$mn:00003D08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D08
.text$mn:00003D08 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D08
.text$mn:00003D08 ; Attributes: bp-based frame
.text$mn:00003D08
.text$mn:00003D08 ; int __cdecl std::allocator_traits<std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>::construct<std::vector<unsigned char,std::allocator<unsigned char>>,std::vector<unsigned char,std::allocator<unsigned char>>>(int, void *, int)
.text$mn:00003D08                 public ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@$$QAV31@@Z
.text$mn:00003D08 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@$$QAV31@@Z proc near
.text$mn:00003D08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)+1Cp
.text$mn:00003D08
.text$mn:00003D08 arg_0           = dword ptr  8
.text$mn:00003D08 arg_4           = dword ptr  0Ch
.text$mn:00003D08 arg_8           = dword ptr  10h
.text$mn:00003D08
.text$mn:00003D08                 push    ebp
.text$mn:00003D09                 mov     ebp, esp
.text$mn:00003D0B                 mov     eax, [ebp+arg_8]
.text$mn:00003D0E                 push    eax
.text$mn:00003D0F                 call    ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:00003D14                 add     esp, 4
.text$mn:00003D17                 push    eax             ; int
.text$mn:00003D18                 mov     ecx, [ebp+arg_4]
.text$mn:00003D1B                 push    ecx             ; void *
.text$mn:00003D1C                 mov     ecx, [ebp+arg_0]
.text$mn:00003D1F                 call    ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:00003D24                 pop     ebp
.text$mn:00003D25                 retn
.text$mn:00003D25 ??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@$$QAV31@@Z endp
.text$mn:00003D25
.text$mn:00003D25 ; ---------------------------------------------------------------------------
.text$mn:00003D26                 align 4
.text$mn:00003D26 _text$mn        ends
.text$mn:00003D26
.text$mn:00003D28 ; ===========================================================================
.text$mn:00003D28
.text$mn:00003D28 ; Segment type: Pure code
.text$mn:00003D28 ; Segment permissions: Read/Execute
.text$mn:00003D28 _text$mn        segment para public 'CODE' use32
.text$mn:00003D28                 assume cs:_text$mn
.text$mn:00003D28                 ;org 3D28h
.text$mn:00003D28 ; COMDAT (pick any)
.text$mn:00003D28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D28
.text$mn:00003D28 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D28
.text$mn:00003D28 ; Attributes: bp-based frame
.text$mn:00003D28
.text$mn:00003D28 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>>::destroy<unsigned char>(unsigned char *)
.text$mn:00003D28                 public ??$destroy@E@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE@Z
.text$mn:00003D28 ??$destroy@E@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE@Z proc near
.text$mn:00003D28                                         ; CODE XREF: __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap
.text$mn:00003D28
.text$mn:00003D28 var_4           = dword ptr -4
.text$mn:00003D28 arg_0           = dword ptr  8
.text$mn:00003D28
.text$mn:00003D28                 push    ebp
.text$mn:00003D29                 mov     ebp, esp
.text$mn:00003D2B                 push    ecx
.text$mn:00003D2C                 mov     [ebp+var_4], ecx
.text$mn:00003D2F                 mov     eax, [ebp+arg_0]
.text$mn:00003D32                 push    eax
.text$mn:00003D33                 mov     ecx, [ebp+var_4]
.text$mn:00003D36                 push    ecx
.text$mn:00003D37                 call    ??$destroy@E@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE@Z ; std::allocator_traits<std::allocator<uchar>>::destroy<uchar>(std::allocator<uchar> &,uchar *)
.text$mn:00003D3C                 add     esp, 8
.text$mn:00003D3F                 mov     esp, ebp
.text$mn:00003D41                 pop     ebp
.text$mn:00003D42                 retn    4
.text$mn:00003D42 ??$destroy@E@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE@Z endp
.text$mn:00003D42
.text$mn:00003D42 ; ---------------------------------------------------------------------------
.text$mn:00003D45                 align 4
.text$mn:00003D45 _text$mn        ends
.text$mn:00003D45
.text$mn:00003D48 ; ===========================================================================
.text$mn:00003D48
.text$mn:00003D48 ; Segment type: Pure code
.text$mn:00003D48 ; Segment permissions: Read/Execute
.text$mn:00003D48 _text$mn        segment para public 'CODE' use32
.text$mn:00003D48                 assume cs:_text$mn
.text$mn:00003D48                 ;org 3D48h
.text$mn:00003D48 ; COMDAT (pick any)
.text$mn:00003D48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D48
.text$mn:00003D48 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D48
.text$mn:00003D48 ; Attributes: bp-based frame
.text$mn:00003D48
.text$mn:00003D48 ; public: void __thiscall std::allocator<unsigned char>::destroy<unsigned char>(unsigned char *)
.text$mn:00003D48                 public ??$destroy@E@?$allocator@E@std@@QAEXPAE@Z
.text$mn:00003D48 ??$destroy@E@?$allocator@E@std@@QAEXPAE@Z proc near
.text$mn:00003D48                                         ; CODE XREF: std::allocator_traits<std::allocator<uchar>>::destroy<uchar>(std::allocator<uchar> &,uchar *)+Ap
.text$mn:00003D48
.text$mn:00003D48 var_4           = dword ptr -4
.text$mn:00003D48
.text$mn:00003D48                 push    ebp
.text$mn:00003D49                 mov     ebp, esp
.text$mn:00003D4B                 push    ecx
.text$mn:00003D4C                 mov     [ebp+var_4], ecx
.text$mn:00003D4F                 mov     esp, ebp
.text$mn:00003D51                 pop     ebp
.text$mn:00003D52                 retn    4
.text$mn:00003D52 ??$destroy@E@?$allocator@E@std@@QAEXPAE@Z endp
.text$mn:00003D52
.text$mn:00003D52 ; ---------------------------------------------------------------------------
.text$mn:00003D55                 align 4
.text$mn:00003D55 _text$mn        ends
.text$mn:00003D55
.text$mn:00003D58 ; ===========================================================================
.text$mn:00003D58
.text$mn:00003D58 ; Segment type: Pure code
.text$mn:00003D58 ; Segment permissions: Read/Execute
.text$mn:00003D58 _text$mn        segment para public 'CODE' use32
.text$mn:00003D58                 assume cs:_text$mn
.text$mn:00003D58                 ;org 3D58h
.text$mn:00003D58 ; COMDAT (pick any)
.text$mn:00003D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D58
.text$mn:00003D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00003D58
.text$mn:00003D58 ; Attributes: bp-based frame
.text$mn:00003D58
.text$mn:00003D58 ; public: static void __cdecl std::allocator_traits<class std::allocator<unsigned char>>::destroy<unsigned char>(class std::allocator<unsigned char> &, unsigned char *)
.text$mn:00003D58                 public ??$destroy@E@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE@Z
.text$mn:00003D58 ??$destroy@E@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE@Z proc near
.text$mn:00003D58                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::destroy<uchar>(uchar *)+Fp
.text$mn:00003D58
.text$mn:00003D58 arg_0           = dword ptr  8
.text$mn:00003D58 arg_4           = dword ptr  0Ch
.text$mn:00003D58
.text$mn:00003D58                 push    ebp
.text$mn:00003D59                 mov     ebp, esp
.text$mn:00003D5B                 mov     eax, [ebp+arg_4]
.text$mn:00003D5E                 push    eax
.text$mn:00003D5F                 mov     ecx, [ebp+arg_0]
.text$mn:00003D62                 call    ??$destroy@E@?$allocator@E@std@@QAEXPAE@Z ; std::allocator<uchar>::destroy<uchar>(uchar *)
.text$mn:00003D67                 pop     ebp
.text$mn:00003D68                 retn
.text$mn:00003D68 ??$destroy@E@?$allocator_traits@V?$allocator@E@std@@@std@@SAXAAV?$allocator@E@1@PAE@Z endp
.text$mn:00003D68
.text$mn:00003D68 ; ---------------------------------------------------------------------------
.text$mn:00003D69                 align 4
.text$mn:00003D69 _text$mn        ends
.text$mn:00003D69
.text$mn:00003D6C ; ===========================================================================
.text$mn:00003D6C
.text$mn:00003D6C ; Segment type: Pure code
.text$mn:00003D6C ; Segment permissions: Read/Execute
.text$mn:00003D6C _text$mn        segment para public 'CODE' use32
.text$mn:00003D6C                 assume cs:_text$mn
.text$mn:00003D6C                 ;org 3D6Ch
.text$mn:00003D6C ; COMDAT (pick any)
.text$mn:00003D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D6C
.text$mn:00003D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D6C
.text$mn:00003D6C ; Attributes: bp-based frame
.text$mn:00003D6C
.text$mn:00003D6C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00003D6C                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00003D6C ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00003D6C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00003D6C
.text$mn:00003D6C var_4           = dword ptr -4
.text$mn:00003D6C arg_0           = dword ptr  8
.text$mn:00003D6C
.text$mn:00003D6C                 push    ebp
.text$mn:00003D6D                 mov     ebp, esp
.text$mn:00003D6F                 push    ecx
.text$mn:00003D70                 mov     [ebp+var_4], ecx
.text$mn:00003D73                 mov     eax, [ebp+arg_0]
.text$mn:00003D76                 push    eax
.text$mn:00003D77                 mov     ecx, [ebp+var_4]
.text$mn:00003D7A                 push    ecx
.text$mn:00003D7B                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00003D80                 add     esp, 8
.text$mn:00003D83                 mov     esp, ebp
.text$mn:00003D85                 pop     ebp
.text$mn:00003D86                 retn    4
.text$mn:00003D86 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00003D86
.text$mn:00003D86 ; ---------------------------------------------------------------------------
.text$mn:00003D89                 align 4
.text$mn:00003D89 _text$mn        ends
.text$mn:00003D89
.text$mn:00003D8C ; ===========================================================================
.text$mn:00003D8C
.text$mn:00003D8C ; Segment type: Pure code
.text$mn:00003D8C ; Segment permissions: Read/Execute
.text$mn:00003D8C _text$mn        segment para public 'CODE' use32
.text$mn:00003D8C                 assume cs:_text$mn
.text$mn:00003D8C                 ;org 3D8Ch
.text$mn:00003D8C ; COMDAT (pick any)
.text$mn:00003D8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D8C
.text$mn:00003D8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D8C
.text$mn:00003D8C ; Attributes: bp-based frame
.text$mn:00003D8C
.text$mn:00003D8C ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00003D8C                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00003D8C ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00003D8C                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00003D8C
.text$mn:00003D8C var_4           = dword ptr -4
.text$mn:00003D8C
.text$mn:00003D8C                 push    ebp
.text$mn:00003D8D                 mov     ebp, esp
.text$mn:00003D8F                 push    ecx
.text$mn:00003D90                 mov     [ebp+var_4], ecx
.text$mn:00003D93                 mov     esp, ebp
.text$mn:00003D95                 pop     ebp
.text$mn:00003D96                 retn    4
.text$mn:00003D96 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00003D96
.text$mn:00003D96 ; ---------------------------------------------------------------------------
.text$mn:00003D99                 align 4
.text$mn:00003D99 _text$mn        ends
.text$mn:00003D99
.text$mn:00003D9C ; ===========================================================================
.text$mn:00003D9C
.text$mn:00003D9C ; Segment type: Pure code
.text$mn:00003D9C ; Segment permissions: Read/Execute
.text$mn:00003D9C _text$mn        segment para public 'CODE' use32
.text$mn:00003D9C                 assume cs:_text$mn
.text$mn:00003D9C                 ;org 3D9Ch
.text$mn:00003D9C ; COMDAT (pick any)
.text$mn:00003D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D9C
.text$mn:00003D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D9C
.text$mn:00003D9C ; Attributes: bp-based frame
.text$mn:00003D9C
.text$mn:00003D9C ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00003D9C                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00003D9C ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00003D9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00003D9C
.text$mn:00003D9C arg_0           = dword ptr  8
.text$mn:00003D9C arg_4           = dword ptr  0Ch
.text$mn:00003D9C
.text$mn:00003D9C                 push    ebp
.text$mn:00003D9D                 mov     ebp, esp
.text$mn:00003D9F                 mov     eax, [ebp+arg_4]
.text$mn:00003DA2                 push    eax
.text$mn:00003DA3                 mov     ecx, [ebp+arg_0]
.text$mn:00003DA6                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00003DAB                 pop     ebp
.text$mn:00003DAC                 retn
.text$mn:00003DAC ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00003DAC
.text$mn:00003DAC ; ---------------------------------------------------------------------------
.text$mn:00003DAD                 align 10h
.text$mn:00003DAD _text$mn        ends
.text$mn:00003DAD
.text$mn:00003DB0 ; ===========================================================================
.text$mn:00003DB0
.text$mn:00003DB0 ; Segment type: Pure code
.text$mn:00003DB0 ; Segment permissions: Read/Execute
.text$mn:00003DB0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DB0                 assume cs:_text$mn
.text$mn:00003DB0                 ;org 3DB0h
.text$mn:00003DB0 ; COMDAT (pick any)
.text$mn:00003DB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DB0
.text$mn:00003DB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DB0
.text$mn:00003DB0 ; Attributes: bp-based frame
.text$mn:00003DB0
.text$mn:00003DB0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00003DB0                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00003DB0 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00003DB0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Free_proxy(void)+22p
.text$mn:00003DB0
.text$mn:00003DB0 var_4           = dword ptr -4
.text$mn:00003DB0 arg_0           = dword ptr  8
.text$mn:00003DB0
.text$mn:00003DB0                 push    ebp
.text$mn:00003DB1                 mov     ebp, esp
.text$mn:00003DB3                 push    ecx
.text$mn:00003DB4                 mov     [ebp+var_4], ecx
.text$mn:00003DB7                 mov     eax, [ebp+arg_0]
.text$mn:00003DBA                 push    eax
.text$mn:00003DBB                 mov     ecx, [ebp+var_4]
.text$mn:00003DBE                 push    ecx
.text$mn:00003DBF                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00003DC4                 add     esp, 8
.text$mn:00003DC7                 mov     esp, ebp
.text$mn:00003DC9                 pop     ebp
.text$mn:00003DCA                 retn    4
.text$mn:00003DCA ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00003DCA
.text$mn:00003DCA ; ---------------------------------------------------------------------------
.text$mn:00003DCD                 align 10h
.text$mn:00003DCD _text$mn        ends
.text$mn:00003DCD
.text$mn:00003DD0 ; ===========================================================================
.text$mn:00003DD0
.text$mn:00003DD0 ; Segment type: Pure code
.text$mn:00003DD0 ; Segment permissions: Read/Execute
.text$mn:00003DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DD0                 assume cs:_text$mn
.text$mn:00003DD0                 ;org 3DD0h
.text$mn:00003DD0 ; COMDAT (pick any)
.text$mn:00003DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DD0
.text$mn:00003DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DD0
.text$mn:00003DD0 ; Attributes: bp-based frame
.text$mn:00003DD0
.text$mn:00003DD0 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00003DD0                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00003DD0 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00003DD0                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:00003DD0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00003DD0
.text$mn:00003DD0 var_4           = dword ptr -4
.text$mn:00003DD0
.text$mn:00003DD0                 push    ebp
.text$mn:00003DD1                 mov     ebp, esp
.text$mn:00003DD3                 push    ecx
.text$mn:00003DD4                 mov     [ebp+var_4], ecx
.text$mn:00003DD7                 mov     esp, ebp
.text$mn:00003DD9                 pop     ebp
.text$mn:00003DDA                 retn    4
.text$mn:00003DDA ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00003DDA
.text$mn:00003DDA ; ---------------------------------------------------------------------------
.text$mn:00003DDD                 align 10h
.text$mn:00003DDD _text$mn        ends
.text$mn:00003DDD
.text$mn:00003DE0 ; ===========================================================================
.text$mn:00003DE0
.text$mn:00003DE0 ; Segment type: Pure code
.text$mn:00003DE0 ; Segment permissions: Read/Execute
.text$mn:00003DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00003DE0                 assume cs:_text$mn
.text$mn:00003DE0                 ;org 3DE0h
.text$mn:00003DE0 ; COMDAT (pick any)
.text$mn:00003DE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DE0
.text$mn:00003DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DE0
.text$mn:00003DE0 ; Attributes: bp-based frame
.text$mn:00003DE0
.text$mn:00003DE0 ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:00003DE0                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:00003DE0 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:00003DE0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:00003DE0
.text$mn:00003DE0 arg_0           = dword ptr  8
.text$mn:00003DE0 arg_4           = dword ptr  0Ch
.text$mn:00003DE0
.text$mn:00003DE0                 push    ebp
.text$mn:00003DE1                 mov     ebp, esp
.text$mn:00003DE3                 mov     eax, [ebp+arg_4]
.text$mn:00003DE6                 push    eax
.text$mn:00003DE7                 mov     ecx, [ebp+arg_0]
.text$mn:00003DEA                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003DEF                 pop     ebp
.text$mn:00003DF0                 retn
.text$mn:00003DF0 ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:00003DF0
.text$mn:00003DF0 ; ---------------------------------------------------------------------------
.text$mn:00003DF1                 align 4
.text$mn:00003DF1 _text$mn        ends
.text$mn:00003DF1
.text$mn:00003DF4 ; ===========================================================================
.text$mn:00003DF4
.text$mn:00003DF4 ; Segment type: Pure code
.text$mn:00003DF4 ; Segment permissions: Read/Execute
.text$mn:00003DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00003DF4                 assume cs:_text$mn
.text$mn:00003DF4                 ;org 3DF4h
.text$mn:00003DF4 ; COMDAT (pick any)
.text$mn:00003DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003DF4
.text$mn:00003DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003DF4
.text$mn:00003DF4 ; Attributes: bp-based frame
.text$mn:00003DF4
.text$mn:00003DF4 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::destroy<class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00003DF4                 public ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z
.text$mn:00003DF4 ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z proc near
.text$mn:00003DF4                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &,std::_Nonscalar_ptr_iterator_tag)+1Dp
.text$mn:00003DF4                                         ; __catch$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0+1Ap ...
.text$mn:00003DF4
.text$mn:00003DF4 var_4           = dword ptr -4
.text$mn:00003DF4 arg_0           = dword ptr  8
.text$mn:00003DF4
.text$mn:00003DF4                 push    ebp
.text$mn:00003DF5                 mov     ebp, esp
.text$mn:00003DF7                 push    ecx
.text$mn:00003DF8                 mov     [ebp+var_4], ecx
.text$mn:00003DFB                 mov     eax, [ebp+arg_0]
.text$mn:00003DFE                 push    eax
.text$mn:00003DFF                 mov     ecx, [ebp+var_4]
.text$mn:00003E02                 push    ecx
.text$mn:00003E03                 call    ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@@Z ; std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::allocator<std::vector<uchar,std::allocator<uchar>>> &,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00003E08                 add     esp, 8
.text$mn:00003E0B                 mov     esp, ebp
.text$mn:00003E0D                 pop     ebp
.text$mn:00003E0E                 retn    4
.text$mn:00003E0E ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z endp
.text$mn:00003E0E
.text$mn:00003E0E ; ---------------------------------------------------------------------------
.text$mn:00003E11                 align 4
.text$mn:00003E11 _text$mn        ends
.text$mn:00003E11
.text$mn:00003E14 ; ===========================================================================
.text$mn:00003E14
.text$mn:00003E14 ; Segment type: Pure code
.text$mn:00003E14 ; Segment permissions: Read/Execute
.text$mn:00003E14 _text$mn        segment para public 'CODE' use32
.text$mn:00003E14                 assume cs:_text$mn
.text$mn:00003E14                 ;org 3E14h
.text$mn:00003E14 ; COMDAT (pick any)
.text$mn:00003E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E14
.text$mn:00003E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E14
.text$mn:00003E14 ; Attributes: bp-based frame
.text$mn:00003E14
.text$mn:00003E14 ; public: void __thiscall std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>::destroy<class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00003E14                 public ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z
.text$mn:00003E14 ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z proc near
.text$mn:00003E14                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::allocator<std::vector<uchar,std::allocator<uchar>>> &,std::vector<uchar,std::allocator<uchar>> *)+Ap
.text$mn:00003E14
.text$mn:00003E14 var_4           = dword ptr -4
.text$mn:00003E14 arg_0           = dword ptr  8
.text$mn:00003E14
.text$mn:00003E14                 push    ebp
.text$mn:00003E15                 mov     ebp, esp
.text$mn:00003E17                 push    ecx
.text$mn:00003E18                 mov     [ebp+var_4], ecx
.text$mn:00003E1B                 push    0
.text$mn:00003E1D                 mov     ecx, [ebp+arg_0]
.text$mn:00003E20                 call    ??_G?$vector@EV?$allocator@E@std@@@std@@QAEPAXI@Z ; std::vector<uchar,std::allocator<uchar>>::`scalar deleting destructor'(uint)
.text$mn:00003E25                 mov     esp, ebp
.text$mn:00003E27                 pop     ebp
.text$mn:00003E28                 retn    4
.text$mn:00003E28 ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z endp
.text$mn:00003E28
.text$mn:00003E28 ; ---------------------------------------------------------------------------
.text$mn:00003E2B                 align 4
.text$mn:00003E2B _text$mn        ends
.text$mn:00003E2B
.text$mn:00003E2C ; ===========================================================================
.text$mn:00003E2C
.text$mn:00003E2C ; Segment type: Pure code
.text$mn:00003E2C ; Segment permissions: Read/Execute
.text$mn:00003E2C _text$mn        segment para public 'CODE' use32
.text$mn:00003E2C                 assume cs:_text$mn
.text$mn:00003E2C                 ;org 3E2Ch
.text$mn:00003E2C ; COMDAT (pick any)
.text$mn:00003E2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E2C
.text$mn:00003E2C ; =============== S U B R O U T I N E =======================================
.text$mn:00003E2C
.text$mn:00003E2C ; Attributes: bp-based frame
.text$mn:00003E2C
.text$mn:00003E2C ; public: static void __cdecl std::allocator_traits<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::destroy<class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>> &, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00003E2C                 public ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@@Z
.text$mn:00003E2C ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@@Z proc near
.text$mn:00003E2C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *)+Fp
.text$mn:00003E2C
.text$mn:00003E2C arg_0           = dword ptr  8
.text$mn:00003E2C arg_4           = dword ptr  0Ch
.text$mn:00003E2C
.text$mn:00003E2C                 push    ebp
.text$mn:00003E2D                 mov     ebp, esp
.text$mn:00003E2F                 mov     eax, [ebp+arg_4]
.text$mn:00003E32                 push    eax
.text$mn:00003E33                 mov     ecx, [ebp+arg_0]
.text$mn:00003E36                 call    ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@@Z ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00003E3B                 pop     ebp
.text$mn:00003E3C                 retn
.text$mn:00003E3C ??$destroy@V?$vector@EV?$allocator@E@std@@@std@@@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@1@PAV?$vector@EV?$allocator@E@std@@@1@@Z endp
.text$mn:00003E3C
.text$mn:00003E3C ; ---------------------------------------------------------------------------
.text$mn:00003E3D                 align 10h
.text$mn:00003E3D _text$mn        ends
.text$mn:00003E3D
.text$mn:00003E40 ; ===========================================================================
.text$mn:00003E40
.text$mn:00003E40 ; Segment type: Pure code
.text$mn:00003E40 ; Segment permissions: Read/Execute
.text$mn:00003E40 _text$mn        segment para public 'CODE' use32
.text$mn:00003E40                 assume cs:_text$mn
.text$mn:00003E40                 ;org 3E40h
.text$mn:00003E40 ; COMDAT (pick any)
.text$mn:00003E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003E40
.text$mn:00003E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E40
.text$mn:00003E40 ; Attributes: bp-based frame
.text$mn:00003E40
.text$mn:00003E40 ; int __cdecl std::distance<class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>>(class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>, class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>)
.text$mn:00003E40                 public ??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z
.text$mn:00003E40 ??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z proc near
.text$mn:00003E40                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)+76p
.text$mn:00003E40
.text$mn:00003E40 var_30          = dword ptr -30h
.text$mn:00003E40 var_2C          = dword ptr -2Ch
.text$mn:00003E40 var_28          = dword ptr -28h
.text$mn:00003E40 var_24          = dword ptr -24h
.text$mn:00003E40 var_20          = dword ptr -20h
.text$mn:00003E40 var_1C          = dword ptr -1Ch
.text$mn:00003E40 var_18          = dword ptr -18h
.text$mn:00003E40 var_14          = dword ptr -14h
.text$mn:00003E40 var_D           = byte ptr -0Dh
.text$mn:00003E40 var_C           = dword ptr -0Ch
.text$mn:00003E40 var_4           = dword ptr -4
.text$mn:00003E40 arg_0           = byte ptr  8
.text$mn:00003E40 arg_C           = byte ptr  14h
.text$mn:00003E40
.text$mn:00003E40                 push    ebp
.text$mn:00003E41                 mov     ebp, esp
.text$mn:00003E43                 push    0FFFFFFFFh
.text$mn:00003E45                 push    offset __ehhandler$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z
.text$mn:00003E4A                 mov     eax, large fs:0
.text$mn:00003E50                 push    eax
.text$mn:00003E51                 sub     esp, 24h
.text$mn:00003E54                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003E59                 xor     eax, ebp
.text$mn:00003E5B                 push    eax
.text$mn:00003E5C                 lea     eax, [ebp+var_C]
.text$mn:00003E5F                 mov     large fs:0, eax
.text$mn:00003E65                 mov     [ebp+var_4], 1
.text$mn:00003E6C                 mov     [ebp+var_14], 0
.text$mn:00003E73                 lea     eax, [ebp+arg_0]
.text$mn:00003E76                 push    eax
.text$mn:00003E77                 lea     ecx, [ebp+var_D]
.text$mn:00003E7A                 push    ecx
.text$mn:00003E7B                 call    ??$_Iter_cat@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@@Z ; std::_Iter_cat<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00003E80                 add     esp, 8
.text$mn:00003E83                 mov     dl, [eax]
.text$mn:00003E85                 movzx   eax, dl
.text$mn:00003E88                 push    eax
.text$mn:00003E89                 lea     ecx, [ebp+var_14]
.text$mn:00003E8C                 push    ecx
.text$mn:00003E8D                 sub     esp, 0Ch
.text$mn:00003E90                 mov     ecx, esp
.text$mn:00003E92                 mov     [ebp+var_24], esp
.text$mn:00003E95                 lea     edx, [ebp+arg_C]
.text$mn:00003E98                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003E99                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00003E9E                 mov     [ebp+var_18], eax
.text$mn:00003EA1                 mov     eax, [ebp+var_18]
.text$mn:00003EA4                 mov     [ebp+var_28], eax
.text$mn:00003EA7                 mov     byte ptr [ebp+var_4], 2
.text$mn:00003EAB                 sub     esp, 0Ch
.text$mn:00003EAE                 mov     ecx, esp
.text$mn:00003EB0                 mov     [ebp+var_2C], esp
.text$mn:00003EB3                 lea     edx, [ebp+arg_0]
.text$mn:00003EB6                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00003EB7                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:00003EBC                 mov     [ebp+var_1C], eax
.text$mn:00003EBF                 mov     eax, [ebp+var_1C]
.text$mn:00003EC2                 mov     [ebp+var_30], eax
.text$mn:00003EC5                 mov     byte ptr [ebp+var_4], 3
.text$mn:00003EC9                 mov     byte ptr [ebp+var_4], 1
.text$mn:00003ECD                 call    ??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z ; std::_Distance2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int &,std::random_access_iterator_tag)
.text$mn:00003ED2                 add     esp, 20h
.text$mn:00003ED5                 mov     ecx, [ebp+var_14]
.text$mn:00003ED8                 mov     [ebp+var_20], ecx
.text$mn:00003EDB                 mov     byte ptr [ebp+var_4], 0
.text$mn:00003EDF                 lea     ecx, [ebp+arg_0]
.text$mn:00003EE2                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00003EE7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003EEE                 lea     ecx, [ebp+arg_C]
.text$mn:00003EF1                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:00003EF6                 mov     eax, [ebp+var_20]
.text$mn:00003EF9                 mov     ecx, [ebp+var_C]
.text$mn:00003EFC                 mov     large fs:0, ecx
.text$mn:00003F03                 pop     ecx
.text$mn:00003F04                 mov     esp, ebp
.text$mn:00003F06                 pop     ebp
.text$mn:00003F07                 retn
.text$mn:00003F07 ??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z endp
.text$mn:00003F07
.text$mn:00003F07 _text$mn        ends
.text$mn:00003F07
.text$x:00003F08 ; ===========================================================================
.text$x:00003F08
.text$x:00003F08 ; Segment type: Pure code
.text$x:00003F08 ; Segment permissions: Read/Execute
.text$x:00003F08 _text$x         segment para public 'CODE' use32
.text$x:00003F08                 assume cs:_text$x
.text$x:00003F08                 ;org 3F08h
.text$x:00003F08 ; COMDAT (pick associative to section at 3E40)
.text$x:00003F08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F08
.text$x:00003F08 ; =============== S U B R O U T I N E =======================================
.text$x:00003F08
.text$x:00003F08
.text$x:00003F08 __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$0 proc near
.text$x:00003F08                                         ; DATA XREF: .xdata$x:0000A0DCo
.text$x:00003F08                 lea     ecx, [ebp+14h]
.text$x:00003F0B                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003F0B __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$0 endp
.text$x:00003F0B
.text$x:00003F10
.text$x:00003F10 ; =============== S U B R O U T I N E =======================================
.text$x:00003F10
.text$x:00003F10
.text$x:00003F10 __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$1 proc near
.text$x:00003F10                                         ; DATA XREF: .xdata$x:0000A0E4o
.text$x:00003F10                 lea     ecx, [ebp+8]
.text$x:00003F13                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003F13 __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$1 endp
.text$x:00003F13
.text$x:00003F18
.text$x:00003F18 ; =============== S U B R O U T I N E =======================================
.text$x:00003F18
.text$x:00003F18
.text$x:00003F18 __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$2 proc near
.text$x:00003F18                                         ; DATA XREF: .xdata$x:0000A0ECo
.text$x:00003F18                 mov     ecx, [ebp-24h]
.text$x:00003F1B                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003F1B __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$2 endp
.text$x:00003F1B
.text$x:00003F20
.text$x:00003F20 ; =============== S U B R O U T I N E =======================================
.text$x:00003F20
.text$x:00003F20
.text$x:00003F20 __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$3 proc near
.text$x:00003F20                                         ; DATA XREF: .xdata$x:0000A0F4o
.text$x:00003F20                 mov     ecx, [ebp-2Ch]
.text$x:00003F23                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00003F23 __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$3 endp
.text$x:00003F23
.text$x:00003F28
.text$x:00003F28 ; =============== S U B R O U T I N E =======================================
.text$x:00003F28
.text$x:00003F28
.text$x:00003F28 __ehhandler$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z proc near
.text$x:00003F28                                         ; DATA XREF: std::distance<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+5o
.text$x:00003F28
.text$x:00003F28 arg_4           = dword ptr  8
.text$x:00003F28
.text$x:00003F28                 mov     edx, [esp+arg_4]
.text$x:00003F2C                 lea     eax, [edx+0Ch]
.text$x:00003F2F                 mov     ecx, [edx-28h]
.text$x:00003F32                 xor     ecx, eax
.text$x:00003F34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F39                 mov     eax, offset __ehfuncinfo$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z
.text$x:00003F3E                 jmp     ___CxxFrameHandler3
.text$x:00003F3E __ehhandler$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z endp
.text$x:00003F3E
.text$x:00003F3E ; ---------------------------------------------------------------------------
.text$x:00003F43                 align 4
.text$x:00003F43 _text$x         ends
.text$x:00003F43
.text$mn:00003F44 ; ===========================================================================
.text$mn:00003F44
.text$mn:00003F44 ; Segment type: Pure code
.text$mn:00003F44 ; Segment permissions: Read/Execute
.text$mn:00003F44 _text$mn        segment para public 'CODE' use32
.text$mn:00003F44                 assume cs:_text$mn
.text$mn:00003F44                 ;org 3F44h
.text$mn:00003F44 ; COMDAT (pick any)
.text$mn:00003F44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F44
.text$mn:00003F44 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F44
.text$mn:00003F44 ; Attributes: bp-based frame
.text$mn:00003F44
.text$mn:00003F44 ; void __cdecl std::fill<class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:00003F44                 public ??$fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z
.text$mn:00003F44 ??$fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z proc near
.text$mn:00003F44                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+377p
.text$mn:00003F44                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+40Fp
.text$mn:00003F44
.text$mn:00003F44 arg_0           = dword ptr  8
.text$mn:00003F44 arg_4           = dword ptr  0Ch
.text$mn:00003F44 arg_8           = dword ptr  10h
.text$mn:00003F44
.text$mn:00003F44                 push    ebp
.text$mn:00003F45                 mov     ebp, esp
.text$mn:00003F47                 push    0A3Eh           ; unsigned int
.text$mn:00003F4C                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003F51                 mov     eax, [ebp+arg_4]
.text$mn:00003F54                 push    eax             ; int
.text$mn:00003F55                 mov     ecx, [ebp+arg_0]
.text$mn:00003F58                 push    ecx             ; int
.text$mn:00003F59                 call    ??$_Debug_range@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0PB_WI@Z ; std::_Debug_range<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint)
.text$mn:00003F5E                 add     esp, 10h
.text$mn:00003F61                 mov     edx, [ebp+arg_8]
.text$mn:00003F64                 push    edx
.text$mn:00003F65                 mov     eax, [ebp+arg_4]
.text$mn:00003F68                 push    eax
.text$mn:00003F69                 call    ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00003F6E                 add     esp, 4
.text$mn:00003F71                 push    eax
.text$mn:00003F72                 mov     ecx, [ebp+arg_0]
.text$mn:00003F75                 push    ecx
.text$mn:00003F76                 call    ??$_Unchecked@PAV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@@Z ; std::_Unchecked<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00003F7B                 add     esp, 4
.text$mn:00003F7E                 push    eax
.text$mn:00003F7F                 call    ??$_Fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z ; std::_Fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00003F84                 add     esp, 0Ch
.text$mn:00003F87                 pop     ebp
.text$mn:00003F88                 retn
.text$mn:00003F88 ??$fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z endp
.text$mn:00003F88
.text$mn:00003F88 ; ---------------------------------------------------------------------------
.text$mn:00003F89                 align 4
.text$mn:00003F89 _text$mn        ends
.text$mn:00003F89
.text$mn:00003F8C ; ===========================================================================
.text$mn:00003F8C
.text$mn:00003F8C ; Segment type: Pure code
.text$mn:00003F8C ; Segment permissions: Read/Execute
.text$mn:00003F8C _text$mn        segment para public 'CODE' use32
.text$mn:00003F8C                 assume cs:_text$mn
.text$mn:00003F8C                 ;org 3F8Ch
.text$mn:00003F8C ; COMDAT (pick any)
.text$mn:00003F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F8C
.text$mn:00003F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003F8C
.text$mn:00003F8C ; Attributes: bp-based frame
.text$mn:00003F8C
.text$mn:00003F8C ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00003F8C                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00003F8C ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00003F8C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00003F8C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00003F8C
.text$mn:00003F8C arg_0           = dword ptr  8
.text$mn:00003F8C
.text$mn:00003F8C                 push    ebp
.text$mn:00003F8D                 mov     ebp, esp
.text$mn:00003F8F                 mov     eax, [ebp+arg_0]
.text$mn:00003F92                 pop     ebp
.text$mn:00003F93                 retn
.text$mn:00003F93 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00003F93
.text$mn:00003F93 _text$mn        ends
.text$mn:00003F93
.text$mn:00003F94 ; ===========================================================================
.text$mn:00003F94
.text$mn:00003F94 ; Segment type: Pure code
.text$mn:00003F94 ; Segment permissions: Read/Execute
.text$mn:00003F94 _text$mn        segment para public 'CODE' use32
.text$mn:00003F94                 assume cs:_text$mn
.text$mn:00003F94                 ;org 3F94h
.text$mn:00003F94 ; COMDAT (pick any)
.text$mn:00003F94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F94
.text$mn:00003F94 ; =============== S U B R O U T I N E =======================================
.text$mn:00003F94
.text$mn:00003F94 ; Attributes: bp-based frame
.text$mn:00003F94
.text$mn:00003F94 ; class std::vector<unsigned char, class std::allocator<unsigned char>> const & __cdecl std::forward<class std::vector<unsigned char, class std::allocator<unsigned char>> const &>(class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:00003F94                 public ??$forward@ABV?$vector@EV?$allocator@E@std@@@std@@@std@@YAABV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z
.text$mn:00003F94 ??$forward@ABV?$vector@EV?$allocator@E@std@@@std@@@std@@YAABV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z proc near
.text$mn:00003F94                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>> const &>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+Bp
.text$mn:00003F94                                         ; std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>> const &>(std::allocator<std::vector<uchar,std::allocator<uchar>>> &,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+7p
.text$mn:00003F94
.text$mn:00003F94 arg_0           = dword ptr  8
.text$mn:00003F94
.text$mn:00003F94                 push    ebp
.text$mn:00003F95                 mov     ebp, esp
.text$mn:00003F97                 mov     eax, [ebp+arg_0]
.text$mn:00003F9A                 pop     ebp
.text$mn:00003F9B                 retn
.text$mn:00003F9B ??$forward@ABV?$vector@EV?$allocator@E@std@@@std@@@std@@YAABV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z endp
.text$mn:00003F9B
.text$mn:00003F9B _text$mn        ends
.text$mn:00003F9B
.text$mn:00003F9C ; ===========================================================================
.text$mn:00003F9C
.text$mn:00003F9C ; Segment type: Pure code
.text$mn:00003F9C ; Segment permissions: Read/Execute
.text$mn:00003F9C _text$mn        segment para public 'CODE' use32
.text$mn:00003F9C                 assume cs:_text$mn
.text$mn:00003F9C                 ;org 3F9Ch
.text$mn:00003F9C ; COMDAT (pick any)
.text$mn:00003F9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F9C
.text$mn:00003F9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003F9C
.text$mn:00003F9C ; Attributes: bp-based frame
.text$mn:00003F9C
.text$mn:00003F9C ; unsigned char && __cdecl std::forward<unsigned char>(unsigned char &)
.text$mn:00003F9C                 public ??$forward@E@std@@YA$$QAEAAE@Z
.text$mn:00003F9C ??$forward@E@std@@YA$$QAEAAE@Z proc near
.text$mn:00003F9C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::construct<uchar,uchar>(uchar *,uchar &&)+Bp
.text$mn:00003F9C                                         ; std::allocator<uchar>::construct<uchar,uchar>(uchar *,uchar &&)+4Ap ...
.text$mn:00003F9C
.text$mn:00003F9C arg_0           = dword ptr  8
.text$mn:00003F9C
.text$mn:00003F9C                 push    ebp
.text$mn:00003F9D                 mov     ebp, esp
.text$mn:00003F9F                 mov     eax, [ebp+arg_0]
.text$mn:00003FA2                 pop     ebp
.text$mn:00003FA3                 retn
.text$mn:00003FA3 ??$forward@E@std@@YA$$QAEAAE@Z endp
.text$mn:00003FA3
.text$mn:00003FA3 _text$mn        ends
.text$mn:00003FA3
.text$mn:00003FA4 ; ===========================================================================
.text$mn:00003FA4
.text$mn:00003FA4 ; Segment type: Pure code
.text$mn:00003FA4 ; Segment permissions: Read/Execute
.text$mn:00003FA4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FA4                 assume cs:_text$mn
.text$mn:00003FA4                 ;org 3FA4h
.text$mn:00003FA4 ; COMDAT (pick any)
.text$mn:00003FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FA4
.text$mn:00003FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FA4
.text$mn:00003FA4 ; Attributes: bp-based frame
.text$mn:00003FA4
.text$mn:00003FA4 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00003FA4                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00003FA4 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00003FA4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00003FA4                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00003FA4
.text$mn:00003FA4 arg_0           = dword ptr  8
.text$mn:00003FA4
.text$mn:00003FA4                 push    ebp
.text$mn:00003FA5                 mov     ebp, esp
.text$mn:00003FA7                 mov     eax, [ebp+arg_0]
.text$mn:00003FAA                 pop     ebp
.text$mn:00003FAB                 retn
.text$mn:00003FAB ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00003FAB
.text$mn:00003FAB _text$mn        ends
.text$mn:00003FAB
.text$mn:00003FAC ; ===========================================================================
.text$mn:00003FAC
.text$mn:00003FAC ; Segment type: Pure code
.text$mn:00003FAC ; Segment permissions: Read/Execute
.text$mn:00003FAC _text$mn        segment para public 'CODE' use32
.text$mn:00003FAC                 assume cs:_text$mn
.text$mn:00003FAC                 ;org 3FACh
.text$mn:00003FAC ; COMDAT (pick any)
.text$mn:00003FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FAC
.text$mn:00003FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00003FAC
.text$mn:00003FAC ; Attributes: bp-based frame
.text$mn:00003FAC
.text$mn:00003FAC ; class std::vector<unsigned char, class std::allocator<unsigned char>> && __cdecl std::forward<class std::vector<unsigned char, class std::allocator<unsigned char>>>(class std::vector<unsigned char, class std::allocator<unsigned char>> &)
.text$mn:00003FAC                 public ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z
.text$mn:00003FAC ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z proc near
.text$mn:00003FAC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)+Bp
.text$mn:00003FAC                                         ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> &&)+4Ap ...
.text$mn:00003FAC
.text$mn:00003FAC arg_0           = dword ptr  8
.text$mn:00003FAC
.text$mn:00003FAC                 push    ebp
.text$mn:00003FAD                 mov     ebp, esp
.text$mn:00003FAF                 mov     eax, [ebp+arg_0]
.text$mn:00003FB2                 pop     ebp
.text$mn:00003FB3                 retn
.text$mn:00003FB3 ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z endp
.text$mn:00003FB3
.text$mn:00003FB3 _text$mn        ends
.text$mn:00003FB3
.text$mn:00003FB4 ; ===========================================================================
.text$mn:00003FB4
.text$mn:00003FB4 ; Segment type: Pure code
.text$mn:00003FB4 ; Segment permissions: Read/Execute
.text$mn:00003FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00003FB4                 assume cs:_text$mn
.text$mn:00003FB4                 ;org 3FB4h
.text$mn:00003FB4 ; COMDAT (pick any)
.text$mn:00003FB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FB4
.text$mn:00003FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FB4
.text$mn:00003FB4 ; Attributes: bp-based frame
.text$mn:00003FB4
.text$mn:00003FB4 ; class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> __cdecl std::make_move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>)
.text$mn:00003FB4                 public ??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.text$mn:00003FB4 ??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z proc near
.text$mn:00003FB4                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+A7p
.text$mn:00003FB4                                         ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+EAp
.text$mn:00003FB4
.text$mn:00003FB4 var_30          = byte ptr -30h
.text$mn:00003FB4 var_24          = dword ptr -24h
.text$mn:00003FB4 var_20          = dword ptr -20h
.text$mn:00003FB4 var_1C          = dword ptr -1Ch
.text$mn:00003FB4 var_18          = dword ptr -18h
.text$mn:00003FB4 var_14          = dword ptr -14h
.text$mn:00003FB4 var_10          = dword ptr -10h
.text$mn:00003FB4 var_C           = dword ptr -0Ch
.text$mn:00003FB4 var_4           = dword ptr -4
.text$mn:00003FB4 arg_0           = dword ptr  8
.text$mn:00003FB4 arg_4           = byte ptr  0Ch
.text$mn:00003FB4
.text$mn:00003FB4                 push    ebp
.text$mn:00003FB5                 mov     ebp, esp
.text$mn:00003FB7                 push    0FFFFFFFFh
.text$mn:00003FB9                 push    offset __ehhandler$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.text$mn:00003FBE                 mov     eax, large fs:0
.text$mn:00003FC4                 push    eax
.text$mn:00003FC5                 sub     esp, 24h
.text$mn:00003FC8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003FCD                 xor     eax, ebp
.text$mn:00003FCF                 push    eax
.text$mn:00003FD0                 lea     eax, [ebp+var_C]
.text$mn:00003FD3                 mov     large fs:0, eax
.text$mn:00003FD9                 mov     [ebp+var_10], 0
.text$mn:00003FE0                 mov     [ebp+var_4], 1
.text$mn:00003FE7                 sub     esp, 0Ch
.text$mn:00003FEA                 mov     ecx, esp
.text$mn:00003FEC                 mov     [ebp+var_20], esp
.text$mn:00003FEF                 lea     eax, [ebp+arg_4]
.text$mn:00003FF2                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00003FF3                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00003FF8                 mov     [ebp+var_14], eax
.text$mn:00003FFB                 mov     ecx, [ebp+var_14]
.text$mn:00003FFE                 mov     [ebp+var_24], ecx
.text$mn:00004001                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004005                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004009                 lea     ecx, [ebp+var_30]
.text$mn:0000400C                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)
.text$mn:00004011                 mov     [ebp+var_18], eax
.text$mn:00004014                 mov     edx, [ebp+var_18]
.text$mn:00004017                 mov     [ebp+var_1C], edx
.text$mn:0000401A                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000401E                 mov     eax, [ebp+var_1C]
.text$mn:00004021                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004022                 mov     ecx, [ebp+arg_0]
.text$mn:00004025                 call    ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)
.text$mn:0000402A                 mov     ecx, [ebp+var_10]
.text$mn:0000402D                 or      ecx, 1
.text$mn:00004030                 mov     [ebp+var_10], ecx
.text$mn:00004033                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004037                 lea     ecx, [ebp+var_30]
.text$mn:0000403A                 call    ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$mn:0000403F                 mov     byte ptr [ebp+var_4], 0
.text$mn:00004043                 lea     ecx, [ebp+arg_4]
.text$mn:00004046                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:0000404B                 mov     eax, [ebp+arg_0]
.text$mn:0000404E                 mov     ecx, [ebp+var_C]
.text$mn:00004051                 mov     large fs:0, ecx
.text$mn:00004058                 pop     ecx
.text$mn:00004059                 mov     esp, ebp
.text$mn:0000405B                 pop     ebp
.text$mn:0000405C                 retn
.text$mn:0000405C ??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z endp
.text$mn:0000405C
.text$mn:0000405C ; ---------------------------------------------------------------------------
.text$mn:0000405D                 align 10h
.text$mn:0000405D _text$mn        ends
.text$mn:0000405D
.text$x:00004060 ; ===========================================================================
.text$x:00004060
.text$x:00004060 ; Segment type: Pure code
.text$x:00004060 ; Segment permissions: Read/Execute
.text$x:00004060 _text$x         segment para public 'CODE' use32
.text$x:00004060                 assume cs:_text$x
.text$x:00004060                 ;org 4060h
.text$x:00004060 ; COMDAT (pick associative to section at 3FB4)
.text$x:00004060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004060
.text$x:00004060 ; =============== S U B R O U T I N E =======================================
.text$x:00004060
.text$x:00004060
.text$x:00004060 __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$0 proc near
.text$x:00004060                                         ; DATA XREF: .xdata$x:00009EC4o
.text$x:00004060                 lea     ecx, [ebp+0Ch]
.text$x:00004063                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00004063 __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$0 endp
.text$x:00004063
.text$x:00004068
.text$x:00004068 ; =============== S U B R O U T I N E =======================================
.text$x:00004068
.text$x:00004068
.text$x:00004068 __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$1 proc near
.text$x:00004068                                         ; DATA XREF: .xdata$x:00009ECCo
.text$x:00004068                 mov     ecx, [ebp-20h]
.text$x:0000406B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:0000406B __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$1 endp
.text$x:0000406B
.text$x:00004070
.text$x:00004070 ; =============== S U B R O U T I N E =======================================
.text$x:00004070
.text$x:00004070
.text$x:00004070 __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$2 proc near
.text$x:00004070                                         ; DATA XREF: .xdata$x:00009ED4o
.text$x:00004070                 lea     ecx, [ebp-30h]
.text$x:00004073                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00004073 __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$2 endp
.text$x:00004073
.text$x:00004078
.text$x:00004078 ; =============== S U B R O U T I N E =======================================
.text$x:00004078
.text$x:00004078
.text$x:00004078 __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$3 proc near
.text$x:00004078                                         ; DATA XREF: .xdata$x:00009EBCo
.text$x:00004078                 mov     eax, [ebp-10h]
.text$x:0000407B                 and     eax, 1
.text$x:0000407E                 jz      $LN7
.text$x:00004084                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00004088                 mov     ecx, [ebp+8]
.text$x:0000408B                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:00004090 ; ---------------------------------------------------------------------------
.text$x:00004090
.text$x:00004090 $LN7:                                   ; CODE XREF: __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$3+6j
.text$x:00004090                 retn
.text$x:00004090 __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$3 endp
.text$x:00004090
.text$x:00004091
.text$x:00004091 ; =============== S U B R O U T I N E =======================================
.text$x:00004091
.text$x:00004091
.text$x:00004091 __ehhandler$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z proc near
.text$x:00004091                                         ; DATA XREF: std::make_move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)+5o
.text$x:00004091
.text$x:00004091 arg_4           = dword ptr  8
.text$x:00004091
.text$x:00004091                 mov     edx, [esp+arg_4]
.text$x:00004095                 lea     eax, [edx+0Ch]
.text$x:00004098                 mov     ecx, [edx-28h]
.text$x:0000409B                 xor     ecx, eax
.text$x:0000409D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000040A2                 mov     eax, offset __ehfuncinfo$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.text$x:000040A7                 jmp     ___CxxFrameHandler3
.text$x:000040A7 __ehhandler$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z endp
.text$x:000040A7
.text$x:000040A7 _text$x         ends
.text$x:000040A7
.text$mn:000040AC ; ===========================================================================
.text$mn:000040AC
.text$mn:000040AC ; Segment type: Pure code
.text$mn:000040AC ; Segment permissions: Read/Execute
.text$mn:000040AC _text$mn        segment para public 'CODE' use32
.text$mn:000040AC                 assume cs:_text$mn
.text$mn:000040AC                 ;org 40ACh
.text$mn:000040AC ; COMDAT (pick any)
.text$mn:000040AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040AC
.text$mn:000040AC ; =============== S U B R O U T I N E =======================================
.text$mn:000040AC
.text$mn:000040AC ; Attributes: bp-based frame
.text$mn:000040AC
.text$mn:000040AC ; unsigned char && __cdecl std::move<unsigned char &>(unsigned char &)
.text$mn:000040AC                 public ??$move@AAE@std@@YA$$QAEAAE@Z
.text$mn:000040AC ??$move@AAE@std@@YA$$QAEAAE@Z proc near ; CODE XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::operator*(void)+10p
.text$mn:000040AC
.text$mn:000040AC arg_0           = dword ptr  8
.text$mn:000040AC
.text$mn:000040AC                 push    ebp
.text$mn:000040AD                 mov     ebp, esp
.text$mn:000040AF                 mov     eax, [ebp+arg_0]
.text$mn:000040B2                 pop     ebp
.text$mn:000040B3                 retn
.text$mn:000040B3 ??$move@AAE@std@@YA$$QAEAAE@Z endp
.text$mn:000040B3
.text$mn:000040B3 _text$mn        ends
.text$mn:000040B3
.text$mn:000040B4 ; ===========================================================================
.text$mn:000040B4
.text$mn:000040B4 ; Segment type: Pure code
.text$mn:000040B4 ; Segment permissions: Read/Execute
.text$mn:000040B4 _text$mn        segment para public 'CODE' use32
.text$mn:000040B4                 assume cs:_text$mn
.text$mn:000040B4                 ;org 40B4h
.text$mn:000040B4 ; COMDAT (pick any)
.text$mn:000040B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040B4
.text$mn:000040B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000040B4
.text$mn:000040B4 ; Attributes: bp-based frame
.text$mn:000040B4
.text$mn:000040B4 ; class std::vector<unsigned char, class std::allocator<unsigned char>> && __cdecl std::move<class std::vector<unsigned char, class std::allocator<unsigned char>> &>(class std::vector<unsigned char, class std::allocator<unsigned char>> &)
.text$mn:000040B4                 public ??$move@AAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z
.text$mn:000040B4 ??$move@AAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z proc near
.text$mn:000040B4                                         ; CODE XREF: std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+23p
.text$mn:000040B4
.text$mn:000040B4 arg_0           = dword ptr  8
.text$mn:000040B4
.text$mn:000040B4                 push    ebp
.text$mn:000040B5                 mov     ebp, esp
.text$mn:000040B7                 mov     eax, [ebp+arg_0]
.text$mn:000040BA                 pop     ebp
.text$mn:000040BB                 retn
.text$mn:000040BB ??$move@AAV?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z endp
.text$mn:000040BB
.text$mn:000040BB _text$mn        ends
.text$mn:000040BB
.text$mn:000040BC ; ===========================================================================
.text$mn:000040BC
.text$mn:000040BC ; Segment type: Pure code
.text$mn:000040BC ; Segment permissions: Read/Execute
.text$mn:000040BC _text$mn        segment para public 'CODE' use32
.text$mn:000040BC                 assume cs:_text$mn
.text$mn:000040BC                 ;org 40BCh
.text$mn:000040BC ; COMDAT (pick any)
.text$mn:000040BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000040BC
.text$mn:000040BC ; =============== S U B R O U T I N E =======================================
.text$mn:000040BC
.text$mn:000040BC ; Attributes: bp-based frame
.text$mn:000040BC
.text$mn:000040BC ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,unsigned char,int,unsigned char const *,unsigned char const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:000040BC                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000040BC ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:000040BC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+2Dp
.text$mn:000040BC
.text$mn:000040BC var_10          = dword ptr -10h
.text$mn:000040BC var_C           = dword ptr -0Ch
.text$mn:000040BC var_4           = dword ptr -4
.text$mn:000040BC arg_0           = dword ptr  8
.text$mn:000040BC
.text$mn:000040BC                 push    ebp
.text$mn:000040BD                 mov     ebp, esp
.text$mn:000040BF                 push    0FFFFFFFFh
.text$mn:000040C1                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000040C6                 mov     eax, large fs:0
.text$mn:000040CC                 push    eax
.text$mn:000040CD                 push    ecx
.text$mn:000040CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000040D3                 xor     eax, ebp
.text$mn:000040D5                 push    eax
.text$mn:000040D6                 lea     eax, [ebp+var_C]
.text$mn:000040D9                 mov     large fs:0, eax
.text$mn:000040DF                 mov     [ebp+var_10], ecx
.text$mn:000040E2                 mov     eax, [ebp+arg_0]
.text$mn:000040E5                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000040E6                 mov     ecx, [ebp+var_10] ; this
.text$mn:000040E9                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:000040EE                 mov     [ebp+var_4], 0
.text$mn:000040F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000040FC                 mov     eax, [ebp+var_10]
.text$mn:000040FF                 mov     ecx, [ebp+var_C]
.text$mn:00004102                 mov     large fs:0, ecx
.text$mn:00004109                 pop     ecx
.text$mn:0000410A                 mov     esp, ebp
.text$mn:0000410C                 pop     ebp
.text$mn:0000410D                 retn    4
.text$mn:0000410D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:0000410D
.text$mn:0000410D _text$mn        ends
.text$mn:0000410D
.text$x:00004110 ; ===========================================================================
.text$x:00004110
.text$x:00004110 ; Segment type: Pure code
.text$x:00004110 ; Segment permissions: Read/Execute
.text$x:00004110 _text$x         segment para public 'CODE' use32
.text$x:00004110                 assume cs:_text$x
.text$x:00004110                 ;org 4110h
.text$x:00004110 ; COMDAT (pick associative to section at 40BC)
.text$x:00004110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004110
.text$x:00004110 ; =============== S U B R O U T I N E =======================================
.text$x:00004110
.text$x:00004110
.text$x:00004110 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:00004110                                         ; DATA XREF: .xdata$x:00009BF8o
.text$x:00004110                 mov     ecx, [ebp-10h]  ; this
.text$x:00004113                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004113 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:00004113
.text$x:00004118
.text$x:00004118 ; =============== S U B R O U T I N E =======================================
.text$x:00004118
.text$x:00004118
.text$x:00004118 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00004118                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12> const &)+5o
.text$x:00004118
.text$x:00004118 arg_4           = dword ptr  8
.text$x:00004118
.text$x:00004118                 mov     edx, [esp+arg_4]
.text$x:0000411C                 lea     eax, [edx+0Ch]
.text$x:0000411F                 mov     ecx, [edx-8]
.text$x:00004122                 xor     ecx, eax
.text$x:00004124                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004129                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:0000412E                 jmp     ___CxxFrameHandler3
.text$x:0000412E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:0000412E
.text$x:0000412E ; ---------------------------------------------------------------------------
.text$x:00004133                 align 4
.text$x:00004133 _text$x         ends
.text$x:00004133
.text$mn:00004134 ; ===========================================================================
.text$mn:00004134
.text$mn:00004134 ; Segment type: Pure code
.text$mn:00004134 ; Segment permissions: Read/Execute
.text$mn:00004134 _text$mn        segment para public 'CODE' use32
.text$mn:00004134                 assume cs:_text$mn
.text$mn:00004134                 ;org 4134h
.text$mn:00004134 ; COMDAT (pick any)
.text$mn:00004134                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004134
.text$mn:00004134 ; =============== S U B R O U T I N E =======================================
.text$mn:00004134
.text$mn:00004134 ; Attributes: bp-based frame
.text$mn:00004134
.text$mn:00004134 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, unsigned char, int, unsigned char const *, unsigned char const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, unsigned char, int, unsigned char const *, unsigned char const &, struct std::_Iterator_base12>(void)
.text$mn:00004134                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004134 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004134                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)+29p
.text$mn:00004134
.text$mn:00004134 var_10          = dword ptr -10h
.text$mn:00004134 var_C           = dword ptr -0Ch
.text$mn:00004134 var_4           = dword ptr -4
.text$mn:00004134
.text$mn:00004134                 push    ebp
.text$mn:00004135                 mov     ebp, esp
.text$mn:00004137                 push    0FFFFFFFFh
.text$mn:00004139                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000413E                 mov     eax, large fs:0
.text$mn:00004144                 push    eax
.text$mn:00004145                 push    ecx
.text$mn:00004146                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000414B                 xor     eax, ebp
.text$mn:0000414D                 push    eax
.text$mn:0000414E                 lea     eax, [ebp+var_C]
.text$mn:00004151                 mov     large fs:0, eax
.text$mn:00004157                 mov     [ebp+var_10], ecx
.text$mn:0000415A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000415D                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00004162                 mov     [ebp+var_4], 0
.text$mn:00004169                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004170                 mov     eax, [ebp+var_10]
.text$mn:00004173                 mov     ecx, [ebp+var_C]
.text$mn:00004176                 mov     large fs:0, ecx
.text$mn:0000417D                 pop     ecx
.text$mn:0000417E                 mov     esp, ebp
.text$mn:00004180                 pop     ebp
.text$mn:00004181                 retn
.text$mn:00004181 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00004181
.text$mn:00004181 ; ---------------------------------------------------------------------------
.text$mn:00004182                 align 4
.text$mn:00004182 _text$mn        ends
.text$mn:00004182
.text$x:00004184 ; ===========================================================================
.text$x:00004184
.text$x:00004184 ; Segment type: Pure code
.text$x:00004184 ; Segment permissions: Read/Execute
.text$x:00004184 _text$x         segment para public 'CODE' use32
.text$x:00004184                 assume cs:_text$x
.text$x:00004184                 ;org 4184h
.text$x:00004184 ; COMDAT (pick associative to section at 4134)
.text$x:00004184                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004184
.text$x:00004184 ; =============== S U B R O U T I N E =======================================
.text$x:00004184
.text$x:00004184
.text$x:00004184 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004184                                         ; DATA XREF: .xdata$x:00009BA0o
.text$x:00004184                 mov     ecx, [ebp-10h]  ; this
.text$x:00004187                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004187 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00004187
.text$x:0000418C
.text$x:0000418C ; =============== S U B R O U T I N E =======================================
.text$x:0000418C
.text$x:0000418C
.text$x:0000418C __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:0000418C                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)+5o
.text$x:0000418C
.text$x:0000418C arg_4           = dword ptr  8
.text$x:0000418C
.text$x:0000418C                 mov     edx, [esp+arg_4]
.text$x:00004190                 lea     eax, [edx+0Ch]
.text$x:00004193                 mov     ecx, [edx-8]
.text$x:00004196                 xor     ecx, eax
.text$x:00004198                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000419D                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.text$x:000041A2                 jmp     ___CxxFrameHandler3
.text$x:000041A2 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000041A2
.text$x:000041A2 ; ---------------------------------------------------------------------------
.text$x:000041A7                 align 4
.text$x:000041A7 _text$x         ends
.text$x:000041A7
.text$mn:000041A8 ; ===========================================================================
.text$mn:000041A8
.text$mn:000041A8 ; Segment type: Pure code
.text$mn:000041A8 ; Segment permissions: Read/Execute
.text$mn:000041A8 _text$mn        segment para public 'CODE' use32
.text$mn:000041A8                 assume cs:_text$mn
.text$mn:000041A8                 ;org 41A8h
.text$mn:000041A8 ; COMDAT (pick any)
.text$mn:000041A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041A8
.text$mn:000041A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000041A8
.text$mn:000041A8 ; Attributes: bp-based frame
.text$mn:000041A8
.text$mn:000041A8 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,std::vector<unsigned char,std::allocator<unsigned char>>,int,std::vector<unsigned char,std::allocator<unsigned char>> const *,std::vector<unsigned char,std::allocator<unsigned char>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::vector<unsigned char,std::allocator<unsigned char>>,int,std::vector<unsigned char,std::allocator<unsigned char>> const *,std::vector<unsigned char,std::allocator<unsigned char>> const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:000041A8                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000041A8 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:000041A8                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)+2Dp
.text$mn:000041A8
.text$mn:000041A8 var_10          = dword ptr -10h
.text$mn:000041A8 var_C           = dword ptr -0Ch
.text$mn:000041A8 var_4           = dword ptr -4
.text$mn:000041A8 arg_0           = dword ptr  8
.text$mn:000041A8
.text$mn:000041A8                 push    ebp
.text$mn:000041A9                 mov     ebp, esp
.text$mn:000041AB                 push    0FFFFFFFFh
.text$mn:000041AD                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000041B2                 mov     eax, large fs:0
.text$mn:000041B8                 push    eax
.text$mn:000041B9                 push    ecx
.text$mn:000041BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041BF                 xor     eax, ebp
.text$mn:000041C1                 push    eax
.text$mn:000041C2                 lea     eax, [ebp+var_C]
.text$mn:000041C5                 mov     large fs:0, eax
.text$mn:000041CB                 mov     [ebp+var_10], ecx
.text$mn:000041CE                 mov     eax, [ebp+arg_0]
.text$mn:000041D1                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000041D2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000041D5                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:000041DA                 mov     [ebp+var_4], 0
.text$mn:000041E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000041E8                 mov     eax, [ebp+var_10]
.text$mn:000041EB                 mov     ecx, [ebp+var_C]
.text$mn:000041EE                 mov     large fs:0, ecx
.text$mn:000041F5                 pop     ecx
.text$mn:000041F6                 mov     esp, ebp
.text$mn:000041F8                 pop     ebp
.text$mn:000041F9                 retn    4
.text$mn:000041F9 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000041F9
.text$mn:000041F9 _text$mn        ends
.text$mn:000041F9
.text$x:000041FC ; ===========================================================================
.text$x:000041FC
.text$x:000041FC ; Segment type: Pure code
.text$x:000041FC ; Segment permissions: Read/Execute
.text$x:000041FC _text$x         segment para public 'CODE' use32
.text$x:000041FC                 assume cs:_text$x
.text$x:000041FC                 ;org 41FCh
.text$x:000041FC ; COMDAT (pick associative to section at 41A8)
.text$x:000041FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000041FC
.text$x:000041FC ; =============== S U B R O U T I N E =======================================
.text$x:000041FC
.text$x:000041FC
.text$x:000041FC __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000041FC                                         ; DATA XREF: .xdata$x:00009A38o
.text$x:000041FC                 mov     ecx, [ebp-10h]  ; this
.text$x:000041FF                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000041FF __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000041FF
.text$x:00004204
.text$x:00004204 ; =============== S U B R O U T I N E =======================================
.text$x:00004204
.text$x:00004204
.text$x:00004204 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:00004204                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12> const &)+5o
.text$x:00004204
.text$x:00004204 arg_4           = dword ptr  8
.text$x:00004204
.text$x:00004204                 mov     edx, [esp+arg_4]
.text$x:00004208                 lea     eax, [edx+0Ch]
.text$x:0000420B                 mov     ecx, [edx-8]
.text$x:0000420E                 xor     ecx, eax
.text$x:00004210                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004215                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:0000421A                 jmp     ___CxxFrameHandler3
.text$x:0000421A __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:0000421A
.text$x:0000421A ; ---------------------------------------------------------------------------
.text$x:0000421F                 align 10h
.text$x:0000421F _text$x         ends
.text$x:0000421F
.text$mn:00004220 ; ===========================================================================
.text$mn:00004220
.text$mn:00004220 ; Segment type: Pure code
.text$mn:00004220 ; Segment permissions: Read/Execute
.text$mn:00004220 _text$mn        segment para public 'CODE' use32
.text$mn:00004220                 assume cs:_text$mn
.text$mn:00004220                 ;org 4220h
.text$mn:00004220 ; COMDAT (pick any)
.text$mn:00004220                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004220
.text$mn:00004220 ; =============== S U B R O U T I N E =======================================
.text$mn:00004220
.text$mn:00004220 ; Attributes: bp-based frame
.text$mn:00004220
.text$mn:00004220 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class std::vector<unsigned char, class std::allocator<unsigned char>>, int, class std::vector<unsigned char, class std::allocator<unsigned char>> const *, class std::vector<unsigned char, class std::allocator<unsigned char>> const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, class std::vector<unsigned char, class std::allocator<unsigned char>>, int, class std::vector<unsigned char, class std::allocator<unsigned char>> const *, class std::vector<unsigned char, class std::allocator<unsigned char>> const &, struct std::_Iterator_base12>(void)
.text$mn:00004220                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00004220 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00004220                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)+29p
.text$mn:00004220
.text$mn:00004220 var_10          = dword ptr -10h
.text$mn:00004220 var_C           = dword ptr -0Ch
.text$mn:00004220 var_4           = dword ptr -4
.text$mn:00004220
.text$mn:00004220                 push    ebp
.text$mn:00004221                 mov     ebp, esp
.text$mn:00004223                 push    0FFFFFFFFh
.text$mn:00004225                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000422A                 mov     eax, large fs:0
.text$mn:00004230                 push    eax
.text$mn:00004231                 push    ecx
.text$mn:00004232                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004237                 xor     eax, ebp
.text$mn:00004239                 push    eax
.text$mn:0000423A                 lea     eax, [ebp+var_C]
.text$mn:0000423D                 mov     large fs:0, eax
.text$mn:00004243                 mov     [ebp+var_10], ecx
.text$mn:00004246                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004249                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:0000424E                 mov     [ebp+var_4], 0
.text$mn:00004255                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000425C                 mov     eax, [ebp+var_10]
.text$mn:0000425F                 mov     ecx, [ebp+var_C]
.text$mn:00004262                 mov     large fs:0, ecx
.text$mn:00004269                 pop     ecx
.text$mn:0000426A                 mov     esp, ebp
.text$mn:0000426C                 pop     ebp
.text$mn:0000426D                 retn
.text$mn:0000426D ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000426D
.text$mn:0000426D ; ---------------------------------------------------------------------------
.text$mn:0000426E                 align 10h
.text$mn:0000426E _text$mn        ends
.text$mn:0000426E
.text$x:00004270 ; ===========================================================================
.text$x:00004270
.text$x:00004270 ; Segment type: Pure code
.text$x:00004270 ; Segment permissions: Read/Execute
.text$x:00004270 _text$x         segment para public 'CODE' use32
.text$x:00004270                 assume cs:_text$x
.text$x:00004270                 ;org 4270h
.text$x:00004270 ; COMDAT (pick associative to section at 4220)
.text$x:00004270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004270
.text$x:00004270 ; =============== S U B R O U T I N E =======================================
.text$x:00004270
.text$x:00004270
.text$x:00004270 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00004270                                         ; DATA XREF: .xdata$x:000099E0o
.text$x:00004270                 mov     ecx, [ebp-10h]  ; this
.text$x:00004273                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:00004273 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:00004273
.text$x:00004278
.text$x:00004278 ; =============== S U B R O U T I N E =======================================
.text$x:00004278
.text$x:00004278
.text$x:00004278 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00004278                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)+5o
.text$x:00004278
.text$x:00004278 arg_4           = dword ptr  8
.text$x:00004278
.text$x:00004278                 mov     edx, [esp+arg_4]
.text$x:0000427C                 lea     eax, [edx+0Ch]
.text$x:0000427F                 mov     ecx, [edx-8]
.text$x:00004282                 xor     ecx, eax
.text$x:00004284                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004289                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000428E                 jmp     ___CxxFrameHandler3
.text$x:0000428E __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000428E
.text$x:0000428E ; ---------------------------------------------------------------------------
.text$x:00004293                 align 4
.text$x:00004293 _text$x         ends
.text$x:00004293
.text$mn:00004294 ; ===========================================================================
.text$mn:00004294
.text$mn:00004294 ; Segment type: Pure code
.text$mn:00004294 ; Segment permissions: Read/Execute
.text$mn:00004294 _text$mn        segment para public 'CODE' use32
.text$mn:00004294                 assume cs:_text$mn
.text$mn:00004294                 ;org 4294h
.text$mn:00004294 ; COMDAT (pick any)
.text$mn:00004294                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004294
.text$mn:00004294 ; =============== S U B R O U T I N E =======================================
.text$mn:00004294
.text$mn:00004294 ; Attributes: bp-based frame
.text$mn:00004294
.text$mn:00004294 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00004294                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00004294 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00004294                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00004294
.text$mn:00004294 var_10          = dword ptr -10h
.text$mn:00004294 var_C           = dword ptr -0Ch
.text$mn:00004294 var_4           = dword ptr -4
.text$mn:00004294
.text$mn:00004294                 push    ebp
.text$mn:00004295                 mov     ebp, esp
.text$mn:00004297                 push    0FFFFFFFFh
.text$mn:00004299                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000429E                 mov     eax, large fs:0
.text$mn:000042A4                 push    eax
.text$mn:000042A5                 push    ecx
.text$mn:000042A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000042AB                 xor     eax, ebp
.text$mn:000042AD                 push    eax
.text$mn:000042AE                 lea     eax, [ebp+var_C]
.text$mn:000042B1                 mov     large fs:0, eax
.text$mn:000042B7                 mov     [ebp+var_10], ecx
.text$mn:000042BA                 mov     ecx, [ebp+var_10]
.text$mn:000042BD                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000042C2                 mov     [ebp+var_4], 0
.text$mn:000042C9                 mov     ecx, [ebp+var_10]
.text$mn:000042CC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000042D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000042D8                 mov     eax, [ebp+var_10]
.text$mn:000042DB                 mov     ecx, [ebp+var_C]
.text$mn:000042DE                 mov     large fs:0, ecx
.text$mn:000042E5                 pop     ecx
.text$mn:000042E6                 mov     esp, ebp
.text$mn:000042E8                 pop     ebp
.text$mn:000042E9                 retn    4
.text$mn:000042E9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000042E9
.text$mn:000042E9 _text$mn        ends
.text$mn:000042E9
.text$x:000042EC ; ===========================================================================
.text$x:000042EC
.text$x:000042EC ; Segment type: Pure code
.text$x:000042EC ; Segment permissions: Read/Execute
.text$x:000042EC _text$x         segment para public 'CODE' use32
.text$x:000042EC                 assume cs:_text$x
.text$x:000042EC                 ;org 42ECh
.text$x:000042EC ; COMDAT (pick associative to section at 4294)
.text$x:000042EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000042EC
.text$x:000042EC ; =============== S U B R O U T I N E =======================================
.text$x:000042EC
.text$x:000042EC
.text$x:000042EC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000042EC                                         ; DATA XREF: .xdata$x:00008FF0o
.text$x:000042EC                 mov     ecx, [ebp-10h]
.text$x:000042EF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000042EF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000042EF
.text$x:000042F4
.text$x:000042F4 ; =============== S U B R O U T I N E =======================================
.text$x:000042F4
.text$x:000042F4
.text$x:000042F4 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000042F4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000042F4
.text$x:000042F4 arg_4           = dword ptr  8
.text$x:000042F4
.text$x:000042F4                 mov     edx, [esp+arg_4]
.text$x:000042F8                 lea     eax, [edx+0Ch]
.text$x:000042FB                 mov     ecx, [edx-8]
.text$x:000042FE                 xor     ecx, eax
.text$x:00004300                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004305                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000430A                 jmp     ___CxxFrameHandler3
.text$x:0000430A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000430A
.text$x:0000430A ; ---------------------------------------------------------------------------
.text$x:0000430F                 align 10h
.text$x:0000430F _text$x         ends
.text$x:0000430F
.text$mn:00004310 ; ===========================================================================
.text$mn:00004310
.text$mn:00004310 ; Segment type: Pure code
.text$mn:00004310 ; Segment permissions: Read/Execute
.text$mn:00004310 _text$mn        segment para public 'CODE' use32
.text$mn:00004310                 assume cs:_text$mn
.text$mn:00004310                 ;org 4310h
.text$mn:00004310 ; COMDAT (pick any)
.text$mn:00004310                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004310
.text$mn:00004310 ; =============== S U B R O U T I N E =======================================
.text$mn:00004310
.text$mn:00004310 ; Attributes: bp-based frame
.text$mn:00004310
.text$mn:00004310 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00004310                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00004310 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00004310                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00004310
.text$mn:00004310 var_10          = dword ptr -10h
.text$mn:00004310 var_C           = dword ptr -0Ch
.text$mn:00004310 var_4           = dword ptr -4
.text$mn:00004310
.text$mn:00004310                 push    ebp
.text$mn:00004311                 mov     ebp, esp
.text$mn:00004313                 push    0FFFFFFFFh
.text$mn:00004315                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000431A                 mov     eax, large fs:0
.text$mn:00004320                 push    eax
.text$mn:00004321                 push    ecx
.text$mn:00004322                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004327                 xor     eax, ebp
.text$mn:00004329                 push    eax
.text$mn:0000432A                 lea     eax, [ebp+var_C]
.text$mn:0000432D                 mov     large fs:0, eax
.text$mn:00004333                 mov     [ebp+var_10], ecx
.text$mn:00004336                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004339                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000433E                 mov     [ebp+var_4], 0
.text$mn:00004345                 mov     eax, [ebp+var_10]
.text$mn:00004348                 mov     dword ptr [eax+14h], 0
.text$mn:0000434F                 mov     ecx, [ebp+var_10]
.text$mn:00004352                 mov     dword ptr [ecx+18h], 0
.text$mn:00004359                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004360                 mov     eax, [ebp+var_10]
.text$mn:00004363                 mov     ecx, [ebp+var_C]
.text$mn:00004366                 mov     large fs:0, ecx
.text$mn:0000436D                 pop     ecx
.text$mn:0000436E                 mov     esp, ebp
.text$mn:00004370                 pop     ebp
.text$mn:00004371                 retn
.text$mn:00004371 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00004371
.text$mn:00004371 ; ---------------------------------------------------------------------------
.text$mn:00004372                 align 4
.text$mn:00004372 _text$mn        ends
.text$mn:00004372
.text$x:00004374 ; ===========================================================================
.text$x:00004374
.text$x:00004374 ; Segment type: Pure code
.text$x:00004374 ; Segment permissions: Read/Execute
.text$x:00004374 _text$x         segment para public 'CODE' use32
.text$x:00004374                 assume cs:_text$x
.text$x:00004374                 ;org 4374h
.text$x:00004374 ; COMDAT (pick associative to section at 4310)
.text$x:00004374                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004374
.text$x:00004374 ; =============== S U B R O U T I N E =======================================
.text$x:00004374
.text$x:00004374
.text$x:00004374 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00004374                                         ; DATA XREF: .xdata$x:00008F98o
.text$x:00004374                 mov     ecx, [ebp-10h]  ; this
.text$x:00004377                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00004377 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00004377
.text$x:0000437C
.text$x:0000437C ; =============== S U B R O U T I N E =======================================
.text$x:0000437C
.text$x:0000437C
.text$x:0000437C __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000437C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000437C
.text$x:0000437C arg_4           = dword ptr  8
.text$x:0000437C
.text$x:0000437C                 mov     edx, [esp+arg_4]
.text$x:00004380                 lea     eax, [edx+0Ch]
.text$x:00004383                 mov     ecx, [edx-8]
.text$x:00004386                 xor     ecx, eax
.text$x:00004388                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000438D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00004392                 jmp     ___CxxFrameHandler3
.text$x:00004392 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00004392
.text$x:00004392 ; ---------------------------------------------------------------------------
.text$x:00004397                 align 4
.text$x:00004397 _text$x         ends
.text$x:00004397
.text$mn:00004398 ; ===========================================================================
.text$mn:00004398
.text$mn:00004398 ; Segment type: Pure code
.text$mn:00004398 ; Segment permissions: Read/Execute
.text$mn:00004398 _text$mn        segment para public 'CODE' use32
.text$mn:00004398                 assume cs:_text$mn
.text$mn:00004398                 ;org 4398h
.text$mn:00004398 ; COMDAT (pick any)
.text$mn:00004398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004398
.text$mn:00004398 ; =============== S U B R O U T I N E =======================================
.text$mn:00004398
.text$mn:00004398 ; Attributes: bp-based frame
.text$mn:00004398
.text$mn:00004398 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>::_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>(class std::allocator<unsigned char> const &)
.text$mn:00004398                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z
.text$mn:00004398 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z proc near
.text$mn:00004398                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> &&)+38p
.text$mn:00004398                                         ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+4Ap ...
.text$mn:00004398
.text$mn:00004398 var_10          = dword ptr -10h
.text$mn:00004398 var_C           = dword ptr -0Ch
.text$mn:00004398 var_4           = dword ptr -4
.text$mn:00004398
.text$mn:00004398                 push    ebp
.text$mn:00004399                 mov     ebp, esp
.text$mn:0000439B                 push    0FFFFFFFFh
.text$mn:0000439D                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z
.text$mn:000043A2                 mov     eax, large fs:0
.text$mn:000043A8                 push    eax
.text$mn:000043A9                 push    ecx
.text$mn:000043AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000043AF                 xor     eax, ebp
.text$mn:000043B1                 push    eax
.text$mn:000043B2                 lea     eax, [ebp+var_C]
.text$mn:000043B5                 mov     large fs:0, eax
.text$mn:000043BB                 mov     [ebp+var_10], ecx
.text$mn:000043BE                 mov     ecx, [ebp+var_10]
.text$mn:000043C1                 call    ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uchar>>::_Vector_val<std::_Simple_types<uchar>>(void)
.text$mn:000043C6                 mov     [ebp+var_4], 0
.text$mn:000043CD                 mov     ecx, [ebp+var_10]
.text$mn:000043D0                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Alloc_proxy(void)
.text$mn:000043D5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000043DC                 mov     eax, [ebp+var_10]
.text$mn:000043DF                 mov     ecx, [ebp+var_C]
.text$mn:000043E2                 mov     large fs:0, ecx
.text$mn:000043E9                 pop     ecx
.text$mn:000043EA                 mov     esp, ebp
.text$mn:000043EC                 pop     ebp
.text$mn:000043ED                 retn    4
.text$mn:000043ED ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z endp
.text$mn:000043ED
.text$mn:000043ED _text$mn        ends
.text$mn:000043ED
.text$x:000043F0 ; ===========================================================================
.text$x:000043F0
.text$x:000043F0 ; Segment type: Pure code
.text$x:000043F0 ; Segment permissions: Read/Execute
.text$x:000043F0 _text$x         segment para public 'CODE' use32
.text$x:000043F0                 assume cs:_text$x
.text$x:000043F0                 ;org 43F0h
.text$x:000043F0 ; COMDAT (pick associative to section at 4398)
.text$x:000043F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000043F0
.text$x:000043F0 ; =============== S U B R O U T I N E =======================================
.text$x:000043F0
.text$x:000043F0
.text$x:000043F0 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z$0 proc near
.text$x:000043F0                                         ; DATA XREF: .xdata$x:000096C4o
.text$x:000043F0                 mov     ecx, [ebp-10h]
.text$x:000043F3                 jmp     ??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uchar>>::~_Vector_val<std::_Simple_types<uchar>>(void)
.text$x:000043F3 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z$0 endp
.text$x:000043F3
.text$x:000043F8
.text$x:000043F8 ; =============== S U B R O U T I N E =======================================
.text$x:000043F8
.text$x:000043F8
.text$x:000043F8 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z proc near
.text$x:000043F8                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(std::allocator<uchar> const &)+5o
.text$x:000043F8
.text$x:000043F8 arg_4           = dword ptr  8
.text$x:000043F8
.text$x:000043F8                 mov     edx, [esp+arg_4]
.text$x:000043FC                 lea     eax, [edx+0Ch]
.text$x:000043FF                 mov     ecx, [edx-8]
.text$x:00004402                 xor     ecx, eax
.text$x:00004404                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004409                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z
.text$x:0000440E                 jmp     ___CxxFrameHandler3
.text$x:0000440E __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z endp
.text$x:0000440E
.text$x:0000440E ; ---------------------------------------------------------------------------
.text$x:00004413                 align 4
.text$x:00004413 _text$x         ends
.text$x:00004413
.text$mn:00004414 ; ===========================================================================
.text$mn:00004414
.text$mn:00004414 ; Segment type: Pure code
.text$mn:00004414 ; Segment permissions: Read/Execute
.text$mn:00004414 _text$mn        segment para public 'CODE' use32
.text$mn:00004414                 assume cs:_text$mn
.text$mn:00004414                 ;org 4414h
.text$mn:00004414 ; COMDAT (pick any)
.text$mn:00004414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004414
.text$mn:00004414 ; =============== S U B R O U T I N E =======================================
.text$mn:00004414
.text$mn:00004414 ; Attributes: bp-based frame
.text$mn:00004414
.text$mn:00004414 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>(struct std::_Iterator_base12 *)
.text$mn:00004414                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004414 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004414                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)+4Fp
.text$mn:00004414                                         ; std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)+6Dp ...
.text$mn:00004414
.text$mn:00004414 var_10          = dword ptr -10h
.text$mn:00004414 var_C           = dword ptr -0Ch
.text$mn:00004414 var_4           = dword ptr -4
.text$mn:00004414 arg_0           = dword ptr  8
.text$mn:00004414
.text$mn:00004414                 push    ebp
.text$mn:00004415                 mov     ebp, esp
.text$mn:00004417                 push    0FFFFFFFFh
.text$mn:00004419                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000441E                 mov     eax, large fs:0
.text$mn:00004424                 push    eax
.text$mn:00004425                 push    ecx
.text$mn:00004426                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000442B                 xor     eax, ebp
.text$mn:0000442D                 push    eax
.text$mn:0000442E                 lea     eax, [ebp+var_C]
.text$mn:00004431                 mov     large fs:0, eax
.text$mn:00004437                 mov     [ebp+var_10], ecx
.text$mn:0000443A                 mov     eax, [ebp+arg_0]
.text$mn:0000443D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000443E                 mov     ecx, [ebp+var_10]
.text$mn:00004441                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12> const &)
.text$mn:00004446                 mov     [ebp+var_4], 0
.text$mn:0000444D                 mov     ecx, [ebp+var_10]
.text$mn:00004450                 mov     edx, [ebp+arg_0]
.text$mn:00004453                 mov     eax, [edx+8]
.text$mn:00004456                 mov     [ecx+8], eax
.text$mn:00004459                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004460                 mov     eax, [ebp+var_10]
.text$mn:00004463                 mov     ecx, [ebp+var_C]
.text$mn:00004466                 mov     large fs:0, ecx
.text$mn:0000446D                 pop     ecx
.text$mn:0000446E                 mov     esp, ebp
.text$mn:00004470                 pop     ebp
.text$mn:00004471                 retn    4
.text$mn:00004471 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004471
.text$mn:00004471 _text$mn        ends
.text$mn:00004471
.text$x:00004474 ; ===========================================================================
.text$x:00004474
.text$x:00004474 ; Segment type: Pure code
.text$x:00004474 ; Segment permissions: Read/Execute
.text$x:00004474 _text$x         segment para public 'CODE' use32
.text$x:00004474                 assume cs:_text$x
.text$x:00004474                 ;org 4474h
.text$x:00004474 ; COMDAT (pick associative to section at 4414)
.text$x:00004474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004474
.text$x:00004474 ; =============== S U B R O U T I N E =======================================
.text$x:00004474
.text$x:00004474
.text$x:00004474 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004474                                         ; DATA XREF: .xdata$x:00009C7Co
.text$x:00004474                 mov     ecx, [ebp-10h]
.text$x:00004477                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)
.text$x:00004477 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00004477
.text$x:0000447C
.text$x:0000447C ; =============== S U B R O U T I N E =======================================
.text$x:0000447C
.text$x:0000447C
.text$x:0000447C __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000447C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+5o
.text$x:0000447C
.text$x:0000447C arg_4           = dword ptr  8
.text$x:0000447C
.text$x:0000447C                 mov     edx, [esp+arg_4]
.text$x:00004480                 lea     eax, [edx+0Ch]
.text$x:00004483                 mov     ecx, [edx-8]
.text$x:00004486                 xor     ecx, eax
.text$x:00004488                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000448D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00004492                 jmp     ___CxxFrameHandler3
.text$x:00004492 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00004492
.text$x:00004492 ; ---------------------------------------------------------------------------
.text$x:00004497                 align 4
.text$x:00004497 _text$x         ends
.text$x:00004497
.text$mn:00004498 ; ===========================================================================
.text$mn:00004498
.text$mn:00004498 ; Segment type: Pure code
.text$mn:00004498 ; Segment permissions: Read/Execute
.text$mn:00004498 _text$mn        segment para public 'CODE' use32
.text$mn:00004498                 assume cs:_text$mn
.text$mn:00004498                 ;org 4498h
.text$mn:00004498 ; COMDAT (pick any)
.text$mn:00004498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004498
.text$mn:00004498 ; =============== S U B R O U T I N E =======================================
.text$mn:00004498
.text$mn:00004498 ; Attributes: bp-based frame
.text$mn:00004498
.text$mn:00004498 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>(int, struct std::_Container_base12 *)
.text$mn:00004498                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.text$mn:00004498 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z proc near
.text$mn:00004498                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)+31p
.text$mn:00004498                                         ; std::vector<uchar,std::allocator<uchar>>::begin(void)+3Dp ...
.text$mn:00004498
.text$mn:00004498 var_10          = dword ptr -10h
.text$mn:00004498 var_C           = dword ptr -0Ch
.text$mn:00004498 var_4           = dword ptr -4
.text$mn:00004498 arg_0           = dword ptr  8
.text$mn:00004498 arg_4           = dword ptr  0Ch
.text$mn:00004498
.text$mn:00004498                 push    ebp
.text$mn:00004499                 mov     ebp, esp
.text$mn:0000449B                 push    0FFFFFFFFh
.text$mn:0000449D                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.text$mn:000044A2                 mov     eax, large fs:0
.text$mn:000044A8                 push    eax
.text$mn:000044A9                 push    ecx
.text$mn:000044AA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000044AF                 xor     eax, ebp
.text$mn:000044B1                 push    eax
.text$mn:000044B2                 lea     eax, [ebp+var_C]
.text$mn:000044B5                 mov     large fs:0, eax
.text$mn:000044BB                 mov     [ebp+var_10], ecx
.text$mn:000044BE                 mov     ecx, [ebp+var_10]
.text$mn:000044C1                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)
.text$mn:000044C6                 mov     [ebp+var_4], 0
.text$mn:000044CD                 mov     eax, [ebp+var_10]
.text$mn:000044D0                 mov     ecx, [ebp+arg_0]
.text$mn:000044D3                 mov     [eax+8], ecx
.text$mn:000044D6                 mov     edx, [ebp+arg_4]
.text$mn:000044D9                 push    edx             ; struct std::_Container_base12 *
.text$mn:000044DA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000044DD                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000044E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000044E9                 mov     eax, [ebp+var_10]
.text$mn:000044EC                 mov     ecx, [ebp+var_C]
.text$mn:000044EF                 mov     large fs:0, ecx
.text$mn:000044F6                 pop     ecx
.text$mn:000044F7                 mov     esp, ebp
.text$mn:000044F9                 pop     ebp
.text$mn:000044FA                 retn    8
.text$mn:000044FA ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z endp
.text$mn:000044FA
.text$mn:000044FA ; ---------------------------------------------------------------------------
.text$mn:000044FD                 align 10h
.text$mn:000044FD _text$mn        ends
.text$mn:000044FD
.text$x:00004500 ; ===========================================================================
.text$x:00004500
.text$x:00004500 ; Segment type: Pure code
.text$x:00004500 ; Segment permissions: Read/Execute
.text$x:00004500 _text$x         segment para public 'CODE' use32
.text$x:00004500                 assume cs:_text$x
.text$x:00004500                 ;org 4500h
.text$x:00004500 ; COMDAT (pick associative to section at 4498)
.text$x:00004500                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004500
.text$x:00004500 ; =============== S U B R O U T I N E =======================================
.text$x:00004500
.text$x:00004500
.text$x:00004500 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z$0 proc near
.text$x:00004500                                         ; DATA XREF: .xdata$x:00009C24o
.text$x:00004500                 mov     ecx, [ebp-10h]
.text$x:00004503                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)
.text$x:00004503 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z$0 endp
.text$x:00004503
.text$x:00004508
.text$x:00004508 ; =============== S U B R O U T I N E =======================================
.text$x:00004508
.text$x:00004508
.text$x:00004508 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z proc near
.text$x:00004508                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)+5o
.text$x:00004508
.text$x:00004508 arg_4           = dword ptr  8
.text$x:00004508
.text$x:00004508                 mov     edx, [esp+arg_4]
.text$x:0000450C                 lea     eax, [edx+0Ch]
.text$x:0000450F                 mov     ecx, [edx-8]
.text$x:00004512                 xor     ecx, eax
.text$x:00004514                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004519                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.text$x:0000451E                 jmp     ___CxxFrameHandler3
.text$x:0000451E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z endp
.text$x:0000451E
.text$x:0000451E ; ---------------------------------------------------------------------------
.text$x:00004523                 align 4
.text$x:00004523 _text$x         ends
.text$x:00004523
.text$mn:00004524 ; ===========================================================================
.text$mn:00004524
.text$mn:00004524 ; Segment type: Pure code
.text$mn:00004524 ; Segment permissions: Read/Execute
.text$mn:00004524 _text$mn        segment para public 'CODE' use32
.text$mn:00004524                 assume cs:_text$mn
.text$mn:00004524                 ;org 4524h
.text$mn:00004524 ; COMDAT (pick any)
.text$mn:00004524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004524
.text$mn:00004524 ; =============== S U B R O U T I N E =======================================
.text$mn:00004524
.text$mn:00004524 ; Attributes: bp-based frame
.text$mn:00004524
.text$mn:00004524 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>(struct std::_Iterator_base12 *)
.text$mn:00004524                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004524 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004524                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+D4p
.text$mn:00004524                                         ; ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+174p ...
.text$mn:00004524
.text$mn:00004524 var_10          = dword ptr -10h
.text$mn:00004524 var_C           = dword ptr -0Ch
.text$mn:00004524 var_4           = dword ptr -4
.text$mn:00004524 arg_0           = dword ptr  8
.text$mn:00004524
.text$mn:00004524                 push    ebp
.text$mn:00004525                 mov     ebp, esp
.text$mn:00004527                 push    0FFFFFFFFh
.text$mn:00004529                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000452E                 mov     eax, large fs:0
.text$mn:00004534                 push    eax
.text$mn:00004535                 push    ecx
.text$mn:00004536                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000453B                 xor     eax, ebp
.text$mn:0000453D                 push    eax
.text$mn:0000453E                 lea     eax, [ebp+var_C]
.text$mn:00004541                 mov     large fs:0, eax
.text$mn:00004547                 mov     [ebp+var_10], ecx
.text$mn:0000454A                 mov     eax, [ebp+arg_0]
.text$mn:0000454D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000454E                 mov     ecx, [ebp+var_10]
.text$mn:00004551                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12> const &)
.text$mn:00004556                 mov     [ebp+var_4], 0
.text$mn:0000455D                 mov     ecx, [ebp+var_10]
.text$mn:00004560                 mov     edx, [ebp+arg_0]
.text$mn:00004563                 mov     eax, [edx+8]
.text$mn:00004566                 mov     [ecx+8], eax
.text$mn:00004569                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004570                 mov     eax, [ebp+var_10]
.text$mn:00004573                 mov     ecx, [ebp+var_C]
.text$mn:00004576                 mov     large fs:0, ecx
.text$mn:0000457D                 pop     ecx
.text$mn:0000457E                 mov     esp, ebp
.text$mn:00004580                 pop     ebp
.text$mn:00004581                 retn    4
.text$mn:00004581 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004581
.text$mn:00004581 _text$mn        ends
.text$mn:00004581
.text$x:00004584 ; ===========================================================================
.text$x:00004584
.text$x:00004584 ; Segment type: Pure code
.text$x:00004584 ; Segment permissions: Read/Execute
.text$x:00004584 _text$x         segment para public 'CODE' use32
.text$x:00004584                 assume cs:_text$x
.text$x:00004584                 ;org 4584h
.text$x:00004584 ; COMDAT (pick associative to section at 4524)
.text$x:00004584                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004584
.text$x:00004584 ; =============== S U B R O U T I N E =======================================
.text$x:00004584
.text$x:00004584
.text$x:00004584 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004584                                         ; DATA XREF: .xdata$x:00009ABCo
.text$x:00004584                 mov     ecx, [ebp-10h]
.text$x:00004587                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)
.text$x:00004587 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00004587
.text$x:0000458C
.text$x:0000458C ; =============== S U B R O U T I N E =======================================
.text$x:0000458C
.text$x:0000458C
.text$x:0000458C __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:0000458C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)+5o
.text$x:0000458C
.text$x:0000458C arg_4           = dword ptr  8
.text$x:0000458C
.text$x:0000458C                 mov     edx, [esp+arg_4]
.text$x:00004590                 lea     eax, [edx+0Ch]
.text$x:00004593                 mov     ecx, [edx-8]
.text$x:00004596                 xor     ecx, eax
.text$x:00004598                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000459D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000045A2                 jmp     ___CxxFrameHandler3
.text$x:000045A2 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000045A2
.text$x:000045A2 ; ---------------------------------------------------------------------------
.text$x:000045A7                 align 4
.text$x:000045A7 _text$x         ends
.text$x:000045A7
.text$mn:000045A8 ; ===========================================================================
.text$mn:000045A8
.text$mn:000045A8 ; Segment type: Pure code
.text$mn:000045A8 ; Segment permissions: Read/Execute
.text$mn:000045A8 _text$mn        segment para public 'CODE' use32
.text$mn:000045A8                 assume cs:_text$mn
.text$mn:000045A8                 ;org 45A8h
.text$mn:000045A8 ; COMDAT (pick any)
.text$mn:000045A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045A8
.text$mn:000045A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000045A8
.text$mn:000045A8 ; Attributes: bp-based frame
.text$mn:000045A8
.text$mn:000045A8 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>(int, struct std::_Container_base12 *)
.text$mn:000045A8                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.text$mn:000045A8 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z proc near
.text$mn:000045A8                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)+31p
.text$mn:000045A8
.text$mn:000045A8 var_10          = dword ptr -10h
.text$mn:000045A8 var_C           = dword ptr -0Ch
.text$mn:000045A8 var_4           = dword ptr -4
.text$mn:000045A8 arg_0           = dword ptr  8
.text$mn:000045A8 arg_4           = dword ptr  0Ch
.text$mn:000045A8
.text$mn:000045A8                 push    ebp
.text$mn:000045A9                 mov     ebp, esp
.text$mn:000045AB                 push    0FFFFFFFFh
.text$mn:000045AD                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.text$mn:000045B2                 mov     eax, large fs:0
.text$mn:000045B8                 push    eax
.text$mn:000045B9                 push    ecx
.text$mn:000045BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000045BF                 xor     eax, ebp
.text$mn:000045C1                 push    eax
.text$mn:000045C2                 lea     eax, [ebp+var_C]
.text$mn:000045C5                 mov     large fs:0, eax
.text$mn:000045CB                 mov     [ebp+var_10], ecx
.text$mn:000045CE                 mov     ecx, [ebp+var_10]
.text$mn:000045D1                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)
.text$mn:000045D6                 mov     [ebp+var_4], 0
.text$mn:000045DD                 mov     eax, [ebp+var_10]
.text$mn:000045E0                 mov     ecx, [ebp+arg_0]
.text$mn:000045E3                 mov     [eax+8], ecx
.text$mn:000045E6                 mov     edx, [ebp+arg_4]
.text$mn:000045E9                 push    edx             ; struct std::_Container_base12 *
.text$mn:000045EA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000045ED                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000045F2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000045F9                 mov     eax, [ebp+var_10]
.text$mn:000045FC                 mov     ecx, [ebp+var_C]
.text$mn:000045FF                 mov     large fs:0, ecx
.text$mn:00004606                 pop     ecx
.text$mn:00004607                 mov     esp, ebp
.text$mn:00004609                 pop     ebp
.text$mn:0000460A                 retn    8
.text$mn:0000460A ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z endp
.text$mn:0000460A
.text$mn:0000460A ; ---------------------------------------------------------------------------
.text$mn:0000460D                 align 10h
.text$mn:0000460D _text$mn        ends
.text$mn:0000460D
.text$x:00004610 ; ===========================================================================
.text$x:00004610
.text$x:00004610 ; Segment type: Pure code
.text$x:00004610 ; Segment permissions: Read/Execute
.text$x:00004610 _text$x         segment para public 'CODE' use32
.text$x:00004610                 assume cs:_text$x
.text$x:00004610                 ;org 4610h
.text$x:00004610 ; COMDAT (pick associative to section at 45A8)
.text$x:00004610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004610
.text$x:00004610 ; =============== S U B R O U T I N E =======================================
.text$x:00004610
.text$x:00004610
.text$x:00004610 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z$0 proc near
.text$x:00004610                                         ; DATA XREF: .xdata$x:00009A64o
.text$x:00004610                 mov     ecx, [ebp-10h]
.text$x:00004613                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)
.text$x:00004613 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z$0 endp
.text$x:00004613
.text$x:00004618
.text$x:00004618 ; =============== S U B R O U T I N E =======================================
.text$x:00004618
.text$x:00004618
.text$x:00004618 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z proc near
.text$x:00004618                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)+5o
.text$x:00004618
.text$x:00004618 arg_4           = dword ptr  8
.text$x:00004618
.text$x:00004618                 mov     edx, [esp+arg_4]
.text$x:0000461C                 lea     eax, [edx+0Ch]
.text$x:0000461F                 mov     ecx, [edx-8]
.text$x:00004622                 xor     ecx, eax
.text$x:00004624                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004629                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.text$x:0000462E                 jmp     ___CxxFrameHandler3
.text$x:0000462E __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z endp
.text$x:0000462E
.text$x:0000462E ; ---------------------------------------------------------------------------
.text$x:00004633                 align 4
.text$x:00004633 _text$x         ends
.text$x:00004633
.text$mn:00004634 ; ===========================================================================
.text$mn:00004634
.text$mn:00004634 ; Segment type: Pure code
.text$mn:00004634 ; Segment permissions: Read/Execute
.text$mn:00004634 _text$mn        segment para public 'CODE' use32
.text$mn:00004634                 assume cs:_text$mn
.text$mn:00004634                 ;org 4634h
.text$mn:00004634 ; COMDAT (pick any)
.text$mn:00004634                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004634
.text$mn:00004634 ; =============== S U B R O U T I N E =======================================
.text$mn:00004634
.text$mn:00004634 ; Attributes: bp-based frame
.text$mn:00004634
.text$mn:00004634 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>(struct std::_Iterator_base12 *)
.text$mn:00004634                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004634 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004634                                         ; CODE XREF: std::make_move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)+3Fp
.text$mn:00004634                                         ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+2Dp ...
.text$mn:00004634
.text$mn:00004634 var_10          = dword ptr -10h
.text$mn:00004634 var_C           = dword ptr -0Ch
.text$mn:00004634 var_4           = dword ptr -4
.text$mn:00004634 arg_0           = dword ptr  8
.text$mn:00004634
.text$mn:00004634                 push    ebp
.text$mn:00004635                 mov     ebp, esp
.text$mn:00004637                 push    0FFFFFFFFh
.text$mn:00004639                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000463E                 mov     eax, large fs:0
.text$mn:00004644                 push    eax
.text$mn:00004645                 push    ecx
.text$mn:00004646                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000464B                 xor     eax, ebp
.text$mn:0000464D                 push    eax
.text$mn:0000464E                 lea     eax, [ebp+var_C]
.text$mn:00004651                 mov     large fs:0, eax
.text$mn:00004657                 mov     [ebp+var_10], ecx
.text$mn:0000465A                 mov     eax, [ebp+arg_0]
.text$mn:0000465D                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:0000465E                 mov     ecx, [ebp+var_10]
.text$mn:00004661                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00004666                 mov     [ebp+var_4], 0
.text$mn:0000466D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004674                 mov     eax, [ebp+var_10]
.text$mn:00004677                 mov     ecx, [ebp+var_C]
.text$mn:0000467A                 mov     large fs:0, ecx
.text$mn:00004681                 pop     ecx
.text$mn:00004682                 mov     esp, ebp
.text$mn:00004684                 pop     ebp
.text$mn:00004685                 retn    4
.text$mn:00004685 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004685
.text$mn:00004685 _text$mn        ends
.text$mn:00004685
.text$x:00004688 ; ===========================================================================
.text$x:00004688
.text$x:00004688 ; Segment type: Pure code
.text$x:00004688 ; Segment permissions: Read/Execute
.text$x:00004688 _text$x         segment para public 'CODE' use32
.text$x:00004688                 assume cs:_text$x
.text$x:00004688                 ;org 4688h
.text$x:00004688 ; COMDAT (pick associative to section at 4634)
.text$x:00004688                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004688
.text$x:00004688 ; =============== S U B R O U T I N E =======================================
.text$x:00004688
.text$x:00004688
.text$x:00004688 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004688                                         ; DATA XREF: .xdata$x:00009E90o
.text$x:00004688                 mov     ecx, [ebp-10h]
.text$x:0000468B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:0000468B __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000468B
.text$x:00004690
.text$x:00004690 ; =============== S U B R O U T I N E =======================================
.text$x:00004690
.text$x:00004690
.text$x:00004690 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004690                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+5o
.text$x:00004690
.text$x:00004690 arg_4           = dword ptr  8
.text$x:00004690
.text$x:00004690                 mov     edx, [esp+arg_4]
.text$x:00004694                 lea     eax, [edx+0Ch]
.text$x:00004697                 mov     ecx, [edx-8]
.text$x:0000469A                 xor     ecx, eax
.text$x:0000469C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000046A1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:000046A6                 jmp     ___CxxFrameHandler3
.text$x:000046A6 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:000046A6
.text$x:000046A6 ; ---------------------------------------------------------------------------
.text$x:000046AB                 align 4
.text$x:000046AB _text$x         ends
.text$x:000046AB
.text$mn:000046AC ; ===========================================================================
.text$mn:000046AC
.text$mn:000046AC ; Segment type: Pure code
.text$mn:000046AC ; Segment permissions: Read/Execute
.text$mn:000046AC _text$mn        segment para public 'CODE' use32
.text$mn:000046AC                 assume cs:_text$mn
.text$mn:000046AC                 ;org 46ACh
.text$mn:000046AC ; COMDAT (pick any)
.text$mn:000046AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046AC
.text$mn:000046AC ; =============== S U B R O U T I N E =======================================
.text$mn:000046AC
.text$mn:000046AC ; Attributes: bp-based frame
.text$mn:000046AC
.text$mn:000046AC ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>(int, struct std::_Container_base12 *)
.text$mn:000046AC                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.text$mn:000046AC ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z proc near
.text$mn:000046AC                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::begin(void)+3Dp
.text$mn:000046AC                                         ; std::vector<uchar,std::allocator<uchar>>::end(void)+3Dp
.text$mn:000046AC
.text$mn:000046AC var_10          = dword ptr -10h
.text$mn:000046AC var_C           = dword ptr -0Ch
.text$mn:000046AC var_4           = dword ptr -4
.text$mn:000046AC arg_0           = dword ptr  8
.text$mn:000046AC arg_4           = dword ptr  0Ch
.text$mn:000046AC
.text$mn:000046AC                 push    ebp
.text$mn:000046AD                 mov     ebp, esp
.text$mn:000046AF                 push    0FFFFFFFFh
.text$mn:000046B1                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.text$mn:000046B6                 mov     eax, large fs:0
.text$mn:000046BC                 push    eax
.text$mn:000046BD                 push    ecx
.text$mn:000046BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000046C3                 xor     eax, ebp
.text$mn:000046C5                 push    eax
.text$mn:000046C6                 lea     eax, [ebp+var_C]
.text$mn:000046C9                 mov     large fs:0, eax
.text$mn:000046CF                 mov     [ebp+var_10], ecx
.text$mn:000046D2                 mov     eax, [ebp+arg_4]
.text$mn:000046D5                 push    eax             ; struct std::_Container_base12 *
.text$mn:000046D6                 mov     ecx, [ebp+arg_0]
.text$mn:000046D9                 push    ecx             ; int
.text$mn:000046DA                 mov     ecx, [ebp+var_10]
.text$mn:000046DD                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)
.text$mn:000046E2                 mov     [ebp+var_4], 0
.text$mn:000046E9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000046F0                 mov     eax, [ebp+var_10]
.text$mn:000046F3                 mov     ecx, [ebp+var_C]
.text$mn:000046F6                 mov     large fs:0, ecx
.text$mn:000046FD                 pop     ecx
.text$mn:000046FE                 mov     esp, ebp
.text$mn:00004700                 pop     ebp
.text$mn:00004701                 retn    8
.text$mn:00004701 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z endp
.text$mn:00004701
.text$mn:00004701 _text$mn        ends
.text$mn:00004701
.text$x:00004704 ; ===========================================================================
.text$x:00004704
.text$x:00004704 ; Segment type: Pure code
.text$x:00004704 ; Segment permissions: Read/Execute
.text$x:00004704 _text$x         segment para public 'CODE' use32
.text$x:00004704                 assume cs:_text$x
.text$x:00004704                 ;org 4704h
.text$x:00004704 ; COMDAT (pick associative to section at 46AC)
.text$x:00004704                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004704
.text$x:00004704 ; =============== S U B R O U T I N E =======================================
.text$x:00004704
.text$x:00004704
.text$x:00004704 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z$0 proc near
.text$x:00004704                                         ; DATA XREF: .xdata$x:00009E38o
.text$x:00004704                 mov     ecx, [ebp-10h]
.text$x:00004707                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00004707 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z$0 endp
.text$x:00004707
.text$x:0000470C
.text$x:0000470C ; =============== S U B R O U T I N E =======================================
.text$x:0000470C
.text$x:0000470C
.text$x:0000470C __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z proc near
.text$x:0000470C                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)+5o
.text$x:0000470C
.text$x:0000470C arg_4           = dword ptr  8
.text$x:0000470C
.text$x:0000470C                 mov     edx, [esp+arg_4]
.text$x:00004710                 lea     eax, [edx+0Ch]
.text$x:00004713                 mov     ecx, [edx-8]
.text$x:00004716                 xor     ecx, eax
.text$x:00004718                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000471D                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.text$x:00004722                 jmp     ___CxxFrameHandler3
.text$x:00004722 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z endp
.text$x:00004722
.text$x:00004722 ; ---------------------------------------------------------------------------
.text$x:00004727                 align 4
.text$x:00004727 _text$x         ends
.text$x:00004727
.text$mn:00004728 ; ===========================================================================
.text$mn:00004728
.text$mn:00004728 ; Segment type: Pure code
.text$mn:00004728 ; Segment permissions: Read/Execute
.text$mn:00004728 _text$mn        segment para public 'CODE' use32
.text$mn:00004728                 assume cs:_text$mn
.text$mn:00004728                 ;org 4728h
.text$mn:00004728 ; COMDAT (pick any)
.text$mn:00004728                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004728
.text$mn:00004728 ; =============== S U B R O U T I N E =======================================
.text$mn:00004728
.text$mn:00004728 ; Attributes: bp-based frame
.text$mn:00004728
.text$mn:00004728 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>(struct std::_Iterator_base12 *)
.text$mn:00004728                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004728 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004728                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+(int)+36p
.text$mn:00004728                                         ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+(int)+52p
.text$mn:00004728
.text$mn:00004728 var_10          = dword ptr -10h
.text$mn:00004728 var_C           = dword ptr -0Ch
.text$mn:00004728 var_4           = dword ptr -4
.text$mn:00004728 arg_0           = dword ptr  8
.text$mn:00004728
.text$mn:00004728                 push    ebp
.text$mn:00004729                 mov     ebp, esp
.text$mn:0000472B                 push    0FFFFFFFFh
.text$mn:0000472D                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004732                 mov     eax, large fs:0
.text$mn:00004738                 push    eax
.text$mn:00004739                 push    ecx
.text$mn:0000473A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000473F                 xor     eax, ebp
.text$mn:00004741                 push    eax
.text$mn:00004742                 lea     eax, [ebp+var_C]
.text$mn:00004745                 mov     large fs:0, eax
.text$mn:0000474B                 mov     [ebp+var_10], ecx
.text$mn:0000474E                 mov     eax, [ebp+arg_0]
.text$mn:00004751                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004752                 mov     ecx, [ebp+var_10]
.text$mn:00004755                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)
.text$mn:0000475A                 mov     [ebp+var_4], 0
.text$mn:00004761                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004768                 mov     eax, [ebp+var_10]
.text$mn:0000476B                 mov     ecx, [ebp+var_C]
.text$mn:0000476E                 mov     large fs:0, ecx
.text$mn:00004775                 pop     ecx
.text$mn:00004776                 mov     esp, ebp
.text$mn:00004778                 pop     ebp
.text$mn:00004779                 retn    4
.text$mn:00004779 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004779
.text$mn:00004779 _text$mn        ends
.text$mn:00004779
.text$x:0000477C ; ===========================================================================
.text$x:0000477C
.text$x:0000477C ; Segment type: Pure code
.text$x:0000477C ; Segment permissions: Read/Execute
.text$x:0000477C _text$x         segment para public 'CODE' use32
.text$x:0000477C                 assume cs:_text$x
.text$x:0000477C                 ;org 477Ch
.text$x:0000477C ; COMDAT (pick associative to section at 4728)
.text$x:0000477C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000477C
.text$x:0000477C ; =============== S U B R O U T I N E =======================================
.text$x:0000477C
.text$x:0000477C
.text$x:0000477C __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000477C                                         ; DATA XREF: .xdata$x:00009B74o
.text$x:0000477C                 mov     ecx, [ebp-10h]
.text$x:0000477F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:0000477F __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000477F
.text$x:00004784
.text$x:00004784 ; =============== S U B R O U T I N E =======================================
.text$x:00004784
.text$x:00004784
.text$x:00004784 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004784                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)+5o
.text$x:00004784
.text$x:00004784 arg_4           = dword ptr  8
.text$x:00004784
.text$x:00004784                 mov     edx, [esp+arg_4]
.text$x:00004788                 lea     eax, [edx+0Ch]
.text$x:0000478B                 mov     ecx, [edx-8]
.text$x:0000478E                 xor     ecx, eax
.text$x:00004790                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004795                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000479A                 jmp     ___CxxFrameHandler3
.text$x:0000479A __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000479A
.text$x:0000479A ; ---------------------------------------------------------------------------
.text$x:0000479F                 align 10h
.text$x:0000479F _text$x         ends
.text$x:0000479F
.text$mn:000047A0 ; ===========================================================================
.text$mn:000047A0
.text$mn:000047A0 ; Segment type: Pure code
.text$mn:000047A0 ; Segment permissions: Read/Execute
.text$mn:000047A0 _text$mn        segment para public 'CODE' use32
.text$mn:000047A0                 assume cs:_text$mn
.text$mn:000047A0                 ;org 47A0h
.text$mn:000047A0 ; COMDAT (pick any)
.text$mn:000047A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047A0
.text$mn:000047A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000047A0
.text$mn:000047A0 ; Attributes: bp-based frame
.text$mn:000047A0
.text$mn:000047A0 ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<unsigned char,std::allocator<unsigned char>>>>>(int, struct std::_Container_base12 *)
.text$mn:000047A0                 public ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.text$mn:000047A0 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z proc near
.text$mn:000047A0                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+41p
.text$mn:000047A0                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::begin(void)+3Dp
.text$mn:000047A0
.text$mn:000047A0 var_10          = dword ptr -10h
.text$mn:000047A0 var_C           = dword ptr -0Ch
.text$mn:000047A0 var_4           = dword ptr -4
.text$mn:000047A0 arg_0           = dword ptr  8
.text$mn:000047A0 arg_4           = dword ptr  0Ch
.text$mn:000047A0
.text$mn:000047A0                 push    ebp
.text$mn:000047A1                 mov     ebp, esp
.text$mn:000047A3                 push    0FFFFFFFFh
.text$mn:000047A5                 push    offset __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.text$mn:000047AA                 mov     eax, large fs:0
.text$mn:000047B0                 push    eax
.text$mn:000047B1                 push    ecx
.text$mn:000047B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000047B7                 xor     eax, ebp
.text$mn:000047B9                 push    eax
.text$mn:000047BA                 lea     eax, [ebp+var_C]
.text$mn:000047BD                 mov     large fs:0, eax
.text$mn:000047C3                 mov     [ebp+var_10], ecx
.text$mn:000047C6                 mov     eax, [ebp+arg_4]
.text$mn:000047C9                 push    eax             ; struct std::_Container_base12 *
.text$mn:000047CA                 mov     ecx, [ebp+arg_0]
.text$mn:000047CD                 push    ecx             ; int
.text$mn:000047CE                 mov     ecx, [ebp+var_10]
.text$mn:000047D1                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)
.text$mn:000047D6                 mov     [ebp+var_4], 0
.text$mn:000047DD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000047E4                 mov     eax, [ebp+var_10]
.text$mn:000047E7                 mov     ecx, [ebp+var_C]
.text$mn:000047EA                 mov     large fs:0, ecx
.text$mn:000047F1                 pop     ecx
.text$mn:000047F2                 mov     esp, ebp
.text$mn:000047F4                 pop     ebp
.text$mn:000047F5                 retn    8
.text$mn:000047F5 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z endp
.text$mn:000047F5
.text$mn:000047F5 _text$mn        ends
.text$mn:000047F5
.text$x:000047F8 ; ===========================================================================
.text$x:000047F8
.text$x:000047F8 ; Segment type: Pure code
.text$x:000047F8 ; Segment permissions: Read/Execute
.text$x:000047F8 _text$x         segment para public 'CODE' use32
.text$x:000047F8                 assume cs:_text$x
.text$x:000047F8                 ;org 47F8h
.text$x:000047F8 ; COMDAT (pick associative to section at 47A0)
.text$x:000047F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000047F8
.text$x:000047F8 ; =============== S U B R O U T I N E =======================================
.text$x:000047F8
.text$x:000047F8
.text$x:000047F8 __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z$0 proc near
.text$x:000047F8                                         ; DATA XREF: .xdata$x:00009AE8o
.text$x:000047F8                 mov     ecx, [ebp-10h]
.text$x:000047FB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000047FB __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z$0 endp
.text$x:000047FB
.text$x:00004800
.text$x:00004800 ; =============== S U B R O U T I N E =======================================
.text$x:00004800
.text$x:00004800
.text$x:00004800 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z proc near
.text$x:00004800                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)+5o
.text$x:00004800
.text$x:00004800 arg_4           = dword ptr  8
.text$x:00004800
.text$x:00004800                 mov     edx, [esp+arg_4]
.text$x:00004804                 lea     eax, [edx+0Ch]
.text$x:00004807                 mov     ecx, [edx-8]
.text$x:0000480A                 xor     ecx, eax
.text$x:0000480C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004811                 mov     eax, offset __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.text$x:00004816                 jmp     ___CxxFrameHandler3
.text$x:00004816 __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z endp
.text$x:00004816
.text$x:00004816 ; ---------------------------------------------------------------------------
.text$x:0000481B                 align 4
.text$x:0000481B _text$x         ends
.text$x:0000481B
.text$mn:0000481C ; ===========================================================================
.text$mn:0000481C
.text$mn:0000481C ; Segment type: Pure code
.text$mn:0000481C ; Segment permissions: Read/Execute
.text$mn:0000481C _text$mn        segment para public 'CODE' use32
.text$mn:0000481C                 assume cs:_text$mn
.text$mn:0000481C                 ;org 481Ch
.text$mn:0000481C ; COMDAT (pick any)
.text$mn:0000481C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000481C
.text$mn:0000481C ; =============== S U B R O U T I N E =======================================
.text$mn:0000481C
.text$mn:0000481C ; Attributes: bp-based frame
.text$mn:0000481C
.text$mn:0000481C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned char>>::_Vector_val<struct std::_Simple_types<unsigned char>>(void)
.text$mn:0000481C                 public ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.text$mn:0000481C ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ proc near
.text$mn:0000481C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(std::allocator<uchar> const &)+29p
.text$mn:0000481C
.text$mn:0000481C var_10          = dword ptr -10h
.text$mn:0000481C var_C           = dword ptr -0Ch
.text$mn:0000481C var_4           = dword ptr -4
.text$mn:0000481C
.text$mn:0000481C                 push    ebp
.text$mn:0000481D                 mov     ebp, esp
.text$mn:0000481F                 push    0FFFFFFFFh
.text$mn:00004821                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.text$mn:00004826                 mov     eax, large fs:0
.text$mn:0000482C                 push    eax
.text$mn:0000482D                 push    ecx
.text$mn:0000482E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004833                 xor     eax, ebp
.text$mn:00004835                 push    eax
.text$mn:00004836                 lea     eax, [ebp+var_C]
.text$mn:00004839                 mov     large fs:0, eax
.text$mn:0000483F                 mov     [ebp+var_10], ecx
.text$mn:00004842                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004845                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000484A                 mov     [ebp+var_4], 0
.text$mn:00004851                 mov     eax, [ebp+var_10]
.text$mn:00004854                 mov     dword ptr [eax+4], 0
.text$mn:0000485B                 mov     ecx, [ebp+var_10]
.text$mn:0000485E                 mov     dword ptr [ecx+8], 0
.text$mn:00004865                 mov     edx, [ebp+var_10]
.text$mn:00004868                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000486F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004876                 mov     eax, [ebp+var_10]
.text$mn:00004879                 mov     ecx, [ebp+var_C]
.text$mn:0000487C                 mov     large fs:0, ecx
.text$mn:00004883                 pop     ecx
.text$mn:00004884                 mov     esp, ebp
.text$mn:00004886                 pop     ebp
.text$mn:00004887                 retn
.text$mn:00004887 ??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ endp
.text$mn:00004887
.text$mn:00004887 _text$mn        ends
.text$mn:00004887
.text$x:00004888 ; ===========================================================================
.text$x:00004888
.text$x:00004888 ; Segment type: Pure code
.text$x:00004888 ; Segment permissions: Read/Execute
.text$x:00004888 _text$x         segment para public 'CODE' use32
.text$x:00004888                 assume cs:_text$x
.text$x:00004888                 ;org 4888h
.text$x:00004888 ; COMDAT (pick associative to section at 481C)
.text$x:00004888                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004888
.text$x:00004888 ; =============== S U B R O U T I N E =======================================
.text$x:00004888
.text$x:00004888
.text$x:00004888 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ$0 proc near
.text$x:00004888                                         ; DATA XREF: .xdata$x:0000966Co
.text$x:00004888                 mov     ecx, [ebp-10h]  ; this
.text$x:0000488B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000488B __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ$0 endp
.text$x:0000488B
.text$x:00004890
.text$x:00004890 ; =============== S U B R O U T I N E =======================================
.text$x:00004890
.text$x:00004890
.text$x:00004890 __ehhandler$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ proc near
.text$x:00004890                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<uchar>>::_Vector_val<std::_Simple_types<uchar>>(void)+5o
.text$x:00004890
.text$x:00004890 arg_4           = dword ptr  8
.text$x:00004890
.text$x:00004890                 mov     edx, [esp+arg_4]
.text$x:00004894                 lea     eax, [edx+0Ch]
.text$x:00004897                 mov     ecx, [edx-8]
.text$x:0000489A                 xor     ecx, eax
.text$x:0000489C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000048A1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.text$x:000048A6                 jmp     ___CxxFrameHandler3
.text$x:000048A6 __ehhandler$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ endp
.text$x:000048A6
.text$x:000048A6 ; ---------------------------------------------------------------------------
.text$x:000048AB                 align 4
.text$x:000048AB _text$x         ends
.text$x:000048AB
.text$mn:000048AC ; ===========================================================================
.text$mn:000048AC
.text$mn:000048AC ; Segment type: Pure code
.text$mn:000048AC ; Segment permissions: Read/Execute
.text$mn:000048AC _text$mn        segment para public 'CODE' use32
.text$mn:000048AC                 assume cs:_text$mn
.text$mn:000048AC                 ;org 48ACh
.text$mn:000048AC ; COMDAT (pick any)
.text$mn:000048AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048AC
.text$mn:000048AC ; =============== S U B R O U T I N E =======================================
.text$mn:000048AC
.text$mn:000048AC ; Attributes: bp-based frame
.text$mn:000048AC
.text$mn:000048AC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:000048AC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:000048AC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:000048AC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:000048AC
.text$mn:000048AC var_4           = dword ptr -4
.text$mn:000048AC
.text$mn:000048AC                 push    ebp
.text$mn:000048AD                 mov     ebp, esp
.text$mn:000048AF                 push    ecx
.text$mn:000048B0                 mov     [ebp+var_4], ecx
.text$mn:000048B3                 mov     ecx, [ebp+var_4]
.text$mn:000048B6                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000048BB                 mov     eax, [ebp+var_4]
.text$mn:000048BE                 mov     esp, ebp
.text$mn:000048C0                 pop     ebp
.text$mn:000048C1                 retn
.text$mn:000048C1 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000048C1
.text$mn:000048C1 ; ---------------------------------------------------------------------------
.text$mn:000048C2                 align 4
.text$mn:000048C2 _text$mn        ends
.text$mn:000048C2
.text$mn:000048C4 ; ===========================================================================
.text$mn:000048C4
.text$mn:000048C4 ; Segment type: Pure code
.text$mn:000048C4 ; Segment permissions: Read/Execute
.text$mn:000048C4 _text$mn        segment para public 'CODE' use32
.text$mn:000048C4                 assume cs:_text$mn
.text$mn:000048C4                 ;org 48C4h
.text$mn:000048C4 ; COMDAT (pick any)
.text$mn:000048C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048C4
.text$mn:000048C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000048C4
.text$mn:000048C4 ; Attributes: bp-based frame
.text$mn:000048C4
.text$mn:000048C4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>>::_Wrap_alloc<class std::allocator<unsigned char>>(class std::allocator<unsigned char> const &)
.text$mn:000048C4                 public ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@ABV?$allocator@E@1@@Z
.text$mn:000048C4 ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@ABV?$allocator@E@1@@Z proc near
.text$mn:000048C4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::select_on_container_copy_construction(void)+1Dp
.text$mn:000048C4
.text$mn:000048C4 var_4           = dword ptr -4
.text$mn:000048C4 arg_0           = dword ptr  8
.text$mn:000048C4
.text$mn:000048C4                 push    ebp
.text$mn:000048C5                 mov     ebp, esp
.text$mn:000048C7                 push    ecx
.text$mn:000048C8                 mov     [ebp+var_4], ecx
.text$mn:000048CB                 mov     eax, [ebp+arg_0]
.text$mn:000048CE                 push    eax
.text$mn:000048CF                 mov     ecx, [ebp+var_4]
.text$mn:000048D2                 call    ??0?$allocator@E@std@@QAE@ABV01@@Z ; std::allocator<uchar>::allocator<uchar>(std::allocator<uchar> const &)
.text$mn:000048D7                 mov     eax, [ebp+var_4]
.text$mn:000048DA                 mov     esp, ebp
.text$mn:000048DC                 pop     ebp
.text$mn:000048DD                 retn    4
.text$mn:000048DD ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@ABV?$allocator@E@1@@Z endp
.text$mn:000048DD
.text$mn:000048DD _text$mn        ends
.text$mn:000048DD
.text$mn:000048E0 ; ===========================================================================
.text$mn:000048E0
.text$mn:000048E0 ; Segment type: Pure code
.text$mn:000048E0 ; Segment permissions: Read/Execute
.text$mn:000048E0 _text$mn        segment para public 'CODE' use32
.text$mn:000048E0                 assume cs:_text$mn
.text$mn:000048E0                 ;org 48E0h
.text$mn:000048E0 ; COMDAT (pick any)
.text$mn:000048E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048E0
.text$mn:000048E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000048E0
.text$mn:000048E0 ; Attributes: bp-based frame
.text$mn:000048E0
.text$mn:000048E0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>>::_Wrap_alloc<class std::allocator<unsigned char>>(void)
.text$mn:000048E0                 public ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ
.text$mn:000048E0 ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ proc near
.text$mn:000048E0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)+Ap
.text$mn:000048E0
.text$mn:000048E0 var_4           = dword ptr -4
.text$mn:000048E0
.text$mn:000048E0                 push    ebp
.text$mn:000048E1                 mov     ebp, esp
.text$mn:000048E3                 push    ecx
.text$mn:000048E4                 mov     [ebp+var_4], ecx
.text$mn:000048E7                 mov     ecx, [ebp+var_4]
.text$mn:000048EA                 call    ??0?$allocator@E@std@@QAE@XZ ; std::allocator<uchar>::allocator<uchar>(void)
.text$mn:000048EF                 mov     eax, [ebp+var_4]
.text$mn:000048F2                 mov     esp, ebp
.text$mn:000048F4                 pop     ebp
.text$mn:000048F5                 retn
.text$mn:000048F5 ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ endp
.text$mn:000048F5
.text$mn:000048F5 ; ---------------------------------------------------------------------------
.text$mn:000048F6                 align 4
.text$mn:000048F6 _text$mn        ends
.text$mn:000048F6
.text$mn:000048F8 ; ===========================================================================
.text$mn:000048F8
.text$mn:000048F8 ; Segment type: Pure code
.text$mn:000048F8 ; Segment permissions: Read/Execute
.text$mn:000048F8 _text$mn        segment para public 'CODE' use32
.text$mn:000048F8                 assume cs:_text$mn
.text$mn:000048F8                 ;org 48F8h
.text$mn:000048F8 ; COMDAT (pick any)
.text$mn:000048F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048F8
.text$mn:000048F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000048F8
.text$mn:000048F8 ; Attributes: bp-based frame
.text$mn:000048F8
.text$mn:000048F8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:000048F8                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:000048F8 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000048F8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Alloc_proxy(void)+Cp
.text$mn:000048F8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Free_proxy(void)+Cp
.text$mn:000048F8
.text$mn:000048F8 var_4           = dword ptr -4
.text$mn:000048F8
.text$mn:000048F8                 push    ebp
.text$mn:000048F9                 mov     ebp, esp
.text$mn:000048FB                 push    ecx
.text$mn:000048FC                 mov     [ebp+var_4], ecx
.text$mn:000048FF                 mov     ecx, [ebp+var_4]
.text$mn:00004902                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00004907                 mov     eax, [ebp+var_4]
.text$mn:0000490A                 mov     esp, ebp
.text$mn:0000490C                 pop     ebp
.text$mn:0000490D                 retn
.text$mn:0000490D ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000490D
.text$mn:0000490D ; ---------------------------------------------------------------------------
.text$mn:0000490E                 align 10h
.text$mn:0000490E _text$mn        ends
.text$mn:0000490E
.text$mn:00004910 ; ===========================================================================
.text$mn:00004910
.text$mn:00004910 ; Segment type: Pure code
.text$mn:00004910 ; Segment permissions: Read/Execute
.text$mn:00004910 _text$mn        segment para public 'CODE' use32
.text$mn:00004910                 assume cs:_text$mn
.text$mn:00004910                 ;org 4910h
.text$mn:00004910 ; COMDAT (pick any)
.text$mn:00004910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004910
.text$mn:00004910 ; =============== S U B R O U T I N E =======================================
.text$mn:00004910
.text$mn:00004910 ; Attributes: bp-based frame
.text$mn:00004910
.text$mn:00004910 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>(void)
.text$mn:00004910                 public ??0?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00004910 ??0?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00004910                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)+Ap
.text$mn:00004910
.text$mn:00004910 var_4           = dword ptr -4
.text$mn:00004910
.text$mn:00004910                 push    ebp
.text$mn:00004911                 mov     ebp, esp
.text$mn:00004913                 push    ecx
.text$mn:00004914                 mov     [ebp+var_4], ecx
.text$mn:00004917                 mov     ecx, [ebp+var_4]
.text$mn:0000491A                 call    ??0?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::allocator<std::vector<uchar,std::allocator<uchar>>>(void)
.text$mn:0000491F                 mov     eax, [ebp+var_4]
.text$mn:00004922                 mov     esp, ebp
.text$mn:00004924                 pop     ebp
.text$mn:00004925                 retn
.text$mn:00004925 ??0?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004925
.text$mn:00004925 ; ---------------------------------------------------------------------------
.text$mn:00004926                 align 4
.text$mn:00004926 _text$mn        ends
.text$mn:00004926
.text$mn:00004928 ; ===========================================================================
.text$mn:00004928
.text$mn:00004928 ; Segment type: Pure code
.text$mn:00004928 ; Segment permissions: Read/Execute
.text$mn:00004928 _text$mn        segment para public 'CODE' use32
.text$mn:00004928                 assume cs:_text$mn
.text$mn:00004928                 ;org 4928h
.text$mn:00004928 ; COMDAT (pick any)
.text$mn:00004928                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004928
.text$mn:00004928 ; =============== S U B R O U T I N E =======================================
.text$mn:00004928
.text$mn:00004928 ; Attributes: bp-based frame
.text$mn:00004928
.text$mn:00004928 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00004928                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00004928 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00004928                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00004928
.text$mn:00004928 var_4           = dword ptr -4
.text$mn:00004928
.text$mn:00004928                 push    ebp
.text$mn:00004929                 mov     ebp, esp
.text$mn:0000492B                 push    ecx
.text$mn:0000492C                 mov     [ebp+var_4], ecx
.text$mn:0000492F                 mov     eax, [ebp+var_4]
.text$mn:00004932                 mov     esp, ebp
.text$mn:00004934                 pop     ebp
.text$mn:00004935                 retn
.text$mn:00004935 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00004935
.text$mn:00004935 ; ---------------------------------------------------------------------------
.text$mn:00004936                 align 4
.text$mn:00004936 _text$mn        ends
.text$mn:00004936
.text$mn:00004938 ; ===========================================================================
.text$mn:00004938
.text$mn:00004938 ; Segment type: Pure code
.text$mn:00004938 ; Segment permissions: Read/Execute
.text$mn:00004938 _text$mn        segment para public 'CODE' use32
.text$mn:00004938                 assume cs:_text$mn
.text$mn:00004938                 ;org 4938h
.text$mn:00004938 ; COMDAT (pick any)
.text$mn:00004938                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004938
.text$mn:00004938 ; =============== S U B R O U T I N E =======================================
.text$mn:00004938
.text$mn:00004938 ; Attributes: bp-based frame
.text$mn:00004938
.text$mn:00004938 ; public: __thiscall std::allocator<unsigned char>::allocator<unsigned char>(class std::allocator<unsigned char> const &)
.text$mn:00004938                 public ??0?$allocator@E@std@@QAE@ABV01@@Z
.text$mn:00004938 ??0?$allocator@E@std@@QAE@ABV01@@Z proc near
.text$mn:00004938                                         ; CODE XREF: std::operator==<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)+Bp
.text$mn:00004938                                         ; std::operator==<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)+18p ...
.text$mn:00004938
.text$mn:00004938 var_4           = dword ptr -4
.text$mn:00004938
.text$mn:00004938                 push    ebp
.text$mn:00004939                 mov     ebp, esp
.text$mn:0000493B                 push    ecx
.text$mn:0000493C                 mov     [ebp+var_4], ecx
.text$mn:0000493F                 mov     eax, [ebp+var_4]
.text$mn:00004942                 mov     esp, ebp
.text$mn:00004944                 pop     ebp
.text$mn:00004945                 retn    4
.text$mn:00004945 ??0?$allocator@E@std@@QAE@ABV01@@Z endp
.text$mn:00004945
.text$mn:00004945 _text$mn        ends
.text$mn:00004945
.text$mn:00004948 ; ===========================================================================
.text$mn:00004948
.text$mn:00004948 ; Segment type: Pure code
.text$mn:00004948 ; Segment permissions: Read/Execute
.text$mn:00004948 _text$mn        segment para public 'CODE' use32
.text$mn:00004948                 assume cs:_text$mn
.text$mn:00004948                 ;org 4948h
.text$mn:00004948 ; COMDAT (pick any)
.text$mn:00004948                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004948
.text$mn:00004948 ; =============== S U B R O U T I N E =======================================
.text$mn:00004948
.text$mn:00004948 ; Attributes: bp-based frame
.text$mn:00004948
.text$mn:00004948 ; public: __thiscall std::allocator<unsigned char>::allocator<unsigned char>(void)
.text$mn:00004948                 public ??0?$allocator@E@std@@QAE@XZ
.text$mn:00004948 ??0?$allocator@E@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::_Wrap_alloc<std::allocator<uchar>>(void)+Ap
.text$mn:00004948                                         ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(void)+2Bp
.text$mn:00004948
.text$mn:00004948 var_4           = dword ptr -4
.text$mn:00004948
.text$mn:00004948                 push    ebp
.text$mn:00004949                 mov     ebp, esp
.text$mn:0000494B                 push    ecx
.text$mn:0000494C                 mov     [ebp+var_4], ecx
.text$mn:0000494F                 mov     eax, [ebp+var_4]
.text$mn:00004952                 mov     esp, ebp
.text$mn:00004954                 pop     ebp
.text$mn:00004955                 retn
.text$mn:00004955 ??0?$allocator@E@std@@QAE@XZ endp
.text$mn:00004955
.text$mn:00004955 ; ---------------------------------------------------------------------------
.text$mn:00004956                 align 4
.text$mn:00004956 _text$mn        ends
.text$mn:00004956
.text$mn:00004958 ; ===========================================================================
.text$mn:00004958
.text$mn:00004958 ; Segment type: Pure code
.text$mn:00004958 ; Segment permissions: Read/Execute
.text$mn:00004958 _text$mn        segment para public 'CODE' use32
.text$mn:00004958                 assume cs:_text$mn
.text$mn:00004958                 ;org 4958h
.text$mn:00004958 ; COMDAT (pick any)
.text$mn:00004958                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004958
.text$mn:00004958 ; =============== S U B R O U T I N E =======================================
.text$mn:00004958
.text$mn:00004958 ; Attributes: bp-based frame
.text$mn:00004958
.text$mn:00004958 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00004958                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00004958 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00004958                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00004958                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00004958
.text$mn:00004958 var_4           = dword ptr -4
.text$mn:00004958
.text$mn:00004958                 push    ebp
.text$mn:00004959                 mov     ebp, esp
.text$mn:0000495B                 push    ecx
.text$mn:0000495C                 mov     [ebp+var_4], ecx
.text$mn:0000495F                 mov     eax, [ebp+var_4]
.text$mn:00004962                 mov     esp, ebp
.text$mn:00004964                 pop     ebp
.text$mn:00004965                 retn
.text$mn:00004965 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00004965
.text$mn:00004965 ; ---------------------------------------------------------------------------
.text$mn:00004966                 align 4
.text$mn:00004966 _text$mn        ends
.text$mn:00004966
.text$mn:00004968 ; ===========================================================================
.text$mn:00004968
.text$mn:00004968 ; Segment type: Pure code
.text$mn:00004968 ; Segment permissions: Read/Execute
.text$mn:00004968 _text$mn        segment para public 'CODE' use32
.text$mn:00004968                 assume cs:_text$mn
.text$mn:00004968                 ;org 4968h
.text$mn:00004968 ; COMDAT (pick any)
.text$mn:00004968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004968
.text$mn:00004968 ; =============== S U B R O U T I N E =======================================
.text$mn:00004968
.text$mn:00004968 ; Attributes: bp-based frame
.text$mn:00004968
.text$mn:00004968 ; public: __thiscall std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>(void)
.text$mn:00004968                 public ??0?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
.text$mn:00004968 ??0?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00004968                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>(void)+Ap
.text$mn:00004968
.text$mn:00004968 var_4           = dword ptr -4
.text$mn:00004968
.text$mn:00004968                 push    ebp
.text$mn:00004969                 mov     ebp, esp
.text$mn:0000496B                 push    ecx
.text$mn:0000496C                 mov     [ebp+var_4], ecx
.text$mn:0000496F                 mov     eax, [ebp+var_4]
.text$mn:00004972                 mov     esp, ebp
.text$mn:00004974                 pop     ebp
.text$mn:00004975                 retn
.text$mn:00004975 ??0?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAE@XZ endp
.text$mn:00004975
.text$mn:00004975 ; ---------------------------------------------------------------------------
.text$mn:00004976                 align 4
.text$mn:00004976 _text$mn        ends
.text$mn:00004976
.text$mn:00004978 ; ===========================================================================
.text$mn:00004978
.text$mn:00004978 ; Segment type: Pure code
.text$mn:00004978 ; Segment permissions: Read/Execute
.text$mn:00004978 _text$mn        segment para public 'CODE' use32
.text$mn:00004978                 assume cs:_text$mn
.text$mn:00004978                 ;org 4978h
.text$mn:00004978 ; COMDAT (pick any)
.text$mn:00004978                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004978
.text$mn:00004978 ; =============== S U B R O U T I N E =======================================
.text$mn:00004978
.text$mn:00004978 ; Attributes: bp-based frame
.text$mn:00004978
.text$mn:00004978 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00004978                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00004978 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00004978                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00004978                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00004978
.text$mn:00004978 var_14          = dword ptr -14h
.text$mn:00004978 var_D           = byte ptr -0Dh
.text$mn:00004978 var_C           = dword ptr -0Ch
.text$mn:00004978 var_4           = dword ptr -4
.text$mn:00004978 Str             = dword ptr  8
.text$mn:00004978
.text$mn:00004978                 push    ebp
.text$mn:00004979                 mov     ebp, esp
.text$mn:0000497B                 push    0FFFFFFFFh
.text$mn:0000497D                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00004982                 mov     eax, large fs:0
.text$mn:00004988                 push    eax
.text$mn:00004989                 sub     esp, 8
.text$mn:0000498C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004991                 xor     eax, ebp
.text$mn:00004993                 push    eax
.text$mn:00004994                 lea     eax, [ebp+var_C]
.text$mn:00004997                 mov     large fs:0, eax
.text$mn:0000499D                 mov     [ebp+var_14], ecx
.text$mn:000049A0                 lea     ecx, [ebp+var_D]
.text$mn:000049A3                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000049A8                 push    eax
.text$mn:000049A9                 mov     ecx, [ebp+var_14]
.text$mn:000049AC                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:000049B1                 mov     [ebp+var_4], 0
.text$mn:000049B8                 push    0               ; Size
.text$mn:000049BA                 push    0               ; char
.text$mn:000049BC                 mov     ecx, [ebp+var_14]
.text$mn:000049BF                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000049C4                 mov     eax, [ebp+Str]
.text$mn:000049C7                 push    eax             ; Str
.text$mn:000049C8                 mov     ecx, [ebp+var_14]
.text$mn:000049CB                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:000049D0                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000049D7                 mov     eax, [ebp+var_14]
.text$mn:000049DA                 mov     ecx, [ebp+var_C]
.text$mn:000049DD                 mov     large fs:0, ecx
.text$mn:000049E4                 pop     ecx
.text$mn:000049E5                 mov     esp, ebp
.text$mn:000049E7                 pop     ebp
.text$mn:000049E8                 retn    4
.text$mn:000049E8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:000049E8
.text$mn:000049E8 ; ---------------------------------------------------------------------------
.text$mn:000049EB                 align 4
.text$mn:000049EB _text$mn        ends
.text$mn:000049EB
.text$x:000049EC ; ===========================================================================
.text$x:000049EC
.text$x:000049EC ; Segment type: Pure code
.text$x:000049EC ; Segment permissions: Read/Execute
.text$x:000049EC _text$x         segment para public 'CODE' use32
.text$x:000049EC                 assume cs:_text$x
.text$x:000049EC                 ;org 49ECh
.text$x:000049EC ; COMDAT (pick associative to section at 4978)
.text$x:000049EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000049EC
.text$x:000049EC ; =============== S U B R O U T I N E =======================================
.text$x:000049EC
.text$x:000049EC
.text$x:000049EC __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:000049EC                                         ; DATA XREF: .xdata$x:00009048o
.text$x:000049EC                 mov     ecx, [ebp-14h]
.text$x:000049EF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000049EF __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:000049EF
.text$x:000049F4
.text$x:000049F4 ; =============== S U B R O U T I N E =======================================
.text$x:000049F4
.text$x:000049F4
.text$x:000049F4 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:000049F4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:000049F4
.text$x:000049F4 arg_4           = dword ptr  8
.text$x:000049F4
.text$x:000049F4                 mov     edx, [esp+arg_4]
.text$x:000049F8                 lea     eax, [edx+0Ch]
.text$x:000049FB                 mov     ecx, [edx-0Ch]
.text$x:000049FE                 xor     ecx, eax
.text$x:00004A00                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A05                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00004A0A                 jmp     ___CxxFrameHandler3
.text$x:00004A0A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00004A0A
.text$x:00004A0A ; ---------------------------------------------------------------------------
.text$x:00004A0F                 align 10h
.text$x:00004A0F _text$x         ends
.text$x:00004A0F
.text$mn:00004A10 ; ===========================================================================
.text$mn:00004A10
.text$mn:00004A10 ; Segment type: Pure code
.text$mn:00004A10 ; Segment permissions: Read/Execute
.text$mn:00004A10 _text$mn        segment para public 'CODE' use32
.text$mn:00004A10                 assume cs:_text$mn
.text$mn:00004A10                 ;org 4A10h
.text$mn:00004A10 ; COMDAT (pick any)
.text$mn:00004A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A10
.text$mn:00004A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A10
.text$mn:00004A10 ; Attributes: bp-based frame
.text$mn:00004A10
.text$mn:00004A10 ; int __stdcall std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>>(struct std::_Iterator_base12 *)
.text$mn:00004A10                 public ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004A10 ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004A10                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+55p
.text$mn:00004A10                                         ; std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+73p ...
.text$mn:00004A10
.text$mn:00004A10 var_10          = dword ptr -10h
.text$mn:00004A10 var_C           = dword ptr -0Ch
.text$mn:00004A10 var_4           = dword ptr -4
.text$mn:00004A10 arg_0           = dword ptr  8
.text$mn:00004A10
.text$mn:00004A10                 push    ebp
.text$mn:00004A11                 mov     ebp, esp
.text$mn:00004A13                 push    0FFFFFFFFh
.text$mn:00004A15                 push    offset __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00004A1A                 mov     eax, large fs:0
.text$mn:00004A20                 push    eax
.text$mn:00004A21                 push    ecx
.text$mn:00004A22                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A27                 xor     eax, ebp
.text$mn:00004A29                 push    eax
.text$mn:00004A2A                 lea     eax, [ebp+var_C]
.text$mn:00004A2D                 mov     large fs:0, eax
.text$mn:00004A33                 mov     [ebp+var_10], ecx
.text$mn:00004A36                 mov     eax, [ebp+arg_0]
.text$mn:00004A39                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004A3A                 mov     ecx, [ebp+var_10]
.text$mn:00004A3D                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00004A42                 mov     [ebp+var_4], 0
.text$mn:00004A49                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004A50                 mov     eax, [ebp+var_10]
.text$mn:00004A53                 mov     ecx, [ebp+var_C]
.text$mn:00004A56                 mov     large fs:0, ecx
.text$mn:00004A5D                 pop     ecx
.text$mn:00004A5E                 mov     esp, ebp
.text$mn:00004A60                 pop     ebp
.text$mn:00004A61                 retn    4
.text$mn:00004A61 ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004A61
.text$mn:00004A61 _text$mn        ends
.text$mn:00004A61
.text$x:00004A64 ; ===========================================================================
.text$x:00004A64
.text$x:00004A64 ; Segment type: Pure code
.text$x:00004A64 ; Segment permissions: Read/Execute
.text$x:00004A64 _text$x         segment para public 'CODE' use32
.text$x:00004A64                 assume cs:_text$x
.text$x:00004A64                 ;org 4A64h
.text$x:00004A64 ; COMDAT (pick associative to section at 4A10)
.text$x:00004A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004A64
.text$x:00004A64 ; =============== S U B R O U T I N E =======================================
.text$x:00004A64
.text$x:00004A64
.text$x:00004A64 __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:00004A64                                         ; DATA XREF: .xdata$x:00009F8Co
.text$x:00004A64                 mov     ecx, [ebp-10h]
.text$x:00004A67                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00004A67 __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:00004A67
.text$x:00004A6C
.text$x:00004A6C ; =============== S U B R O U T I N E =======================================
.text$x:00004A6C
.text$x:00004A6C
.text$x:00004A6C __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004A6C                                         ; DATA XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+5o
.text$x:00004A6C
.text$x:00004A6C arg_4           = dword ptr  8
.text$x:00004A6C
.text$x:00004A6C                 mov     edx, [esp+arg_4]
.text$x:00004A70                 lea     eax, [edx+0Ch]
.text$x:00004A73                 mov     ecx, [edx-8]
.text$x:00004A76                 xor     ecx, eax
.text$x:00004A78                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004A7D                 mov     eax, offset __ehfuncinfo$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:00004A82                 jmp     ___CxxFrameHandler3
.text$x:00004A82 __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00004A82
.text$x:00004A82 ; ---------------------------------------------------------------------------
.text$x:00004A87                 align 4
.text$x:00004A87 _text$x         ends
.text$x:00004A87
.text$mn:00004A88 ; ===========================================================================
.text$mn:00004A88
.text$mn:00004A88 ; Segment type: Pure code
.text$mn:00004A88 ; Segment permissions: Read/Execute
.text$mn:00004A88 _text$mn        segment para public 'CODE' use32
.text$mn:00004A88                 assume cs:_text$mn
.text$mn:00004A88                 ;org 4A88h
.text$mn:00004A88 ; COMDAT (pick any)
.text$mn:00004A88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A88
.text$mn:00004A88 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A88
.text$mn:00004A88 ; Attributes: bp-based frame
.text$mn:00004A88
.text$mn:00004A88 ; public: __thiscall std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>)
.text$mn:00004A88                 public ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z
.text$mn:00004A88 ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z proc near
.text$mn:00004A88                                         ; CODE XREF: std::make_move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)+58p
.text$mn:00004A88
.text$mn:00004A88 var_10          = dword ptr -10h
.text$mn:00004A88 var_C           = dword ptr -0Ch
.text$mn:00004A88 var_4           = dword ptr -4
.text$mn:00004A88 arg_0           = byte ptr  8
.text$mn:00004A88
.text$mn:00004A88                 push    ebp
.text$mn:00004A89                 mov     ebp, esp
.text$mn:00004A8B                 push    0FFFFFFFFh
.text$mn:00004A8D                 push    offset __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z
.text$mn:00004A92                 mov     eax, large fs:0
.text$mn:00004A98                 push    eax
.text$mn:00004A99                 push    ecx
.text$mn:00004A9A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004A9F                 xor     eax, ebp
.text$mn:00004AA1                 push    eax
.text$mn:00004AA2                 lea     eax, [ebp+var_C]
.text$mn:00004AA5                 mov     large fs:0, eax
.text$mn:00004AAB                 mov     [ebp+var_10], ecx
.text$mn:00004AAE                 mov     [ebp+var_4], 0
.text$mn:00004AB5                 lea     eax, [ebp+arg_0]
.text$mn:00004AB8                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00004AB9                 mov     ecx, [ebp+var_10]
.text$mn:00004ABC                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00004AC1                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004AC5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004ACC                 lea     ecx, [ebp+arg_0]
.text$mn:00004ACF                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00004AD4                 mov     eax, [ebp+var_10]
.text$mn:00004AD7                 mov     ecx, [ebp+var_C]
.text$mn:00004ADA                 mov     large fs:0, ecx
.text$mn:00004AE1                 pop     ecx
.text$mn:00004AE2                 mov     esp, ebp
.text$mn:00004AE4                 pop     ebp
.text$mn:00004AE5                 retn    0Ch
.text$mn:00004AE5 ??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z endp
.text$mn:00004AE5
.text$mn:00004AE5 _text$mn        ends
.text$mn:00004AE5
.text$x:00004AE8 ; ===========================================================================
.text$x:00004AE8
.text$x:00004AE8 ; Segment type: Pure code
.text$x:00004AE8 ; Segment permissions: Read/Execute
.text$x:00004AE8 _text$x         segment para public 'CODE' use32
.text$x:00004AE8                 assume cs:_text$x
.text$x:00004AE8                 ;org 4AE8h
.text$x:00004AE8 ; COMDAT (pick associative to section at 4A88)
.text$x:00004AE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004AE8
.text$x:00004AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004AE8
.text$x:00004AE8
.text$x:00004AE8 __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z$0 proc near
.text$x:00004AE8                                         ; DATA XREF: .xdata$x:00009F00o
.text$x:00004AE8                 lea     ecx, [ebp+8]
.text$x:00004AEB                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00004AEB __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z$0 endp
.text$x:00004AEB
.text$x:00004AF0
.text$x:00004AF0 ; =============== S U B R O U T I N E =======================================
.text$x:00004AF0
.text$x:00004AF0
.text$x:00004AF0 __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z$1 proc near
.text$x:00004AF0                                         ; DATA XREF: .xdata$x:00009F08o
.text$x:00004AF0                 mov     ecx, [ebp-10h]
.text$x:00004AF3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00004AF3 __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z$1 endp
.text$x:00004AF3
.text$x:00004AF8
.text$x:00004AF8 ; =============== S U B R O U T I N E =======================================
.text$x:00004AF8
.text$x:00004AF8
.text$x:00004AF8 __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z proc near
.text$x:00004AF8                                         ; DATA XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)+5o
.text$x:00004AF8
.text$x:00004AF8 arg_4           = dword ptr  8
.text$x:00004AF8
.text$x:00004AF8                 mov     edx, [esp+arg_4]
.text$x:00004AFC                 lea     eax, [edx+0Ch]
.text$x:00004AFF                 mov     ecx, [edx-8]
.text$x:00004B02                 xor     ecx, eax
.text$x:00004B04                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004B09                 mov     eax, offset __ehfuncinfo$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z
.text$x:00004B0E                 jmp     ___CxxFrameHandler3
.text$x:00004B0E __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z endp
.text$x:00004B0E
.text$x:00004B0E ; ---------------------------------------------------------------------------
.text$x:00004B13                 align 4
.text$x:00004B13 _text$x         ends
.text$x:00004B13
.text$mn:00004B14 ; ===========================================================================
.text$mn:00004B14
.text$mn:00004B14 ; Segment type: Pure code
.text$mn:00004B14 ; Segment permissions: Read/Execute
.text$mn:00004B14 _text$mn        segment para public 'CODE' use32
.text$mn:00004B14                 assume cs:_text$mn
.text$mn:00004B14                 ;org 4B14h
.text$mn:00004B14 ; COMDAT (pick any)
.text$mn:00004B14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B14
.text$mn:00004B14 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B14
.text$mn:00004B14 ; Attributes: bp-based frame
.text$mn:00004B14
.text$mn:00004B14 ; public: __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::vector<unsigned char, class std::allocator<unsigned char>>(class std::vector<unsigned char, class std::allocator<unsigned char>> &&)
.text$mn:00004B14                 public ??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z
.text$mn:00004B14 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z proc near
.text$mn:00004B14                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+51p
.text$mn:00004B14                                         ; ClipboardHistoryPanel::getClipboadData(void)+86p ...
.text$mn:00004B14
.text$mn:00004B14 var_14          = dword ptr -14h
.text$mn:00004B14 var_E           = byte ptr -0Eh
.text$mn:00004B14 var_D           = byte ptr -0Dh
.text$mn:00004B14 var_C           = dword ptr -0Ch
.text$mn:00004B14 var_4           = dword ptr -4
.text$mn:00004B14 arg_0           = dword ptr  8
.text$mn:00004B14
.text$mn:00004B14                 push    ebp
.text$mn:00004B15                 mov     ebp, esp
.text$mn:00004B17                 push    0FFFFFFFFh
.text$mn:00004B19                 push    offset __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z
.text$mn:00004B1E                 mov     eax, large fs:0
.text$mn:00004B24                 push    eax
.text$mn:00004B25                 sub     esp, 8
.text$mn:00004B28                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004B2D                 xor     eax, ebp
.text$mn:00004B2F                 push    eax
.text$mn:00004B30                 lea     eax, [ebp+var_C]
.text$mn:00004B33                 mov     large fs:0, eax
.text$mn:00004B39                 mov     [ebp+var_14], ecx
.text$mn:00004B3C                 lea     eax, [ebp+var_E]
.text$mn:00004B3F                 push    eax
.text$mn:00004B40                 mov     ecx, [ebp+arg_0]
.text$mn:00004B43                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00004B48                 push    eax
.text$mn:00004B49                 mov     ecx, [ebp+var_14]
.text$mn:00004B4C                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(std::allocator<uchar> const &)
.text$mn:00004B51                 mov     [ebp+var_4], 0
.text$mn:00004B58                 xor     ecx, ecx
.text$mn:00004B5A                 mov     [ebp+var_D], cl
.text$mn:00004B5D                 movzx   edx, [ebp+var_D]
.text$mn:00004B61                 push    edx             ; int
.text$mn:00004B62                 mov     eax, [ebp+arg_0]
.text$mn:00004B65                 push    eax
.text$mn:00004B66                 call    ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:00004B6B                 add     esp, 4
.text$mn:00004B6E                 push    eax             ; struct std::_Container_base12 *
.text$mn:00004B6F                 mov     ecx, [ebp+var_14]
.text$mn:00004B72                 call    ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,1>)
.text$mn:00004B77                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004B7E                 mov     eax, [ebp+var_14]
.text$mn:00004B81                 mov     ecx, [ebp+var_C]
.text$mn:00004B84                 mov     large fs:0, ecx
.text$mn:00004B8B                 pop     ecx
.text$mn:00004B8C                 mov     esp, ebp
.text$mn:00004B8E                 pop     ebp
.text$mn:00004B8F                 retn    4
.text$mn:00004B8F ??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z endp
.text$mn:00004B8F
.text$mn:00004B8F ; ---------------------------------------------------------------------------
.text$mn:00004B92                 align 4
.text$mn:00004B92 _text$mn        ends
.text$mn:00004B92
.text$x:00004B94 ; ===========================================================================
.text$x:00004B94
.text$x:00004B94 ; Segment type: Pure code
.text$x:00004B94 ; Segment permissions: Read/Execute
.text$x:00004B94 _text$x         segment para public 'CODE' use32
.text$x:00004B94                 assume cs:_text$x
.text$x:00004B94                 ;org 4B94h
.text$x:00004B94 ; COMDAT (pick associative to section at 4B14)
.text$x:00004B94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004B94
.text$x:00004B94 ; =============== S U B R O U T I N E =======================================
.text$x:00004B94
.text$x:00004B94
.text$x:00004B94 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z$0 proc near
.text$x:00004B94                                         ; DATA XREF: .xdata$x:000097B8o
.text$x:00004B94                 mov     ecx, [ebp-14h]
.text$x:00004B97                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)
.text$x:00004B97 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z$0 endp
.text$x:00004B97
.text$x:00004B9C
.text$x:00004B9C ; =============== S U B R O U T I N E =======================================
.text$x:00004B9C
.text$x:00004B9C
.text$x:00004B9C __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z proc near
.text$x:00004B9C                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> &&)+5o
.text$x:00004B9C
.text$x:00004B9C arg_4           = dword ptr  8
.text$x:00004B9C
.text$x:00004B9C                 mov     edx, [esp+arg_4]
.text$x:00004BA0                 lea     eax, [edx+0Ch]
.text$x:00004BA3                 mov     ecx, [edx-0Ch]
.text$x:00004BA6                 xor     ecx, eax
.text$x:00004BA8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004BAD                 mov     eax, offset __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z
.text$x:00004BB2                 jmp     ___CxxFrameHandler3
.text$x:00004BB2 __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z endp
.text$x:00004BB2
.text$x:00004BB2 ; ---------------------------------------------------------------------------
.text$x:00004BB7                 align 4
.text$x:00004BB7 _text$x         ends
.text$x:00004BB7
.text$mn:00004BB8 ; ===========================================================================
.text$mn:00004BB8
.text$mn:00004BB8 ; Segment type: Pure code
.text$mn:00004BB8 ; Segment permissions: Read/Execute
.text$mn:00004BB8 _text$mn        segment para public 'CODE' use32
.text$mn:00004BB8                 assume cs:_text$mn
.text$mn:00004BB8                 ;org 4BB8h
.text$mn:00004BB8 ; COMDAT (pick any)
.text$mn:00004BB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BB8
.text$mn:00004BB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BB8
.text$mn:00004BB8 ; Attributes: bp-based frame
.text$mn:00004BB8
.text$mn:00004BB8 ; public: __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::vector<unsigned char, class std::allocator<unsigned char>>(class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:00004BB8                 public ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.text$mn:00004BB8 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00004BB8                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+3Ep
.text$mn:00004BB8                                         ; ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+1C7p ...
.text$mn:00004BB8
.text$mn:00004BB8 var_34          = dword ptr -34h
.text$mn:00004BB8 var_30          = dword ptr -30h
.text$mn:00004BB8 var_2C          = dword ptr -2Ch
.text$mn:00004BB8 var_28          = dword ptr -28h
.text$mn:00004BB8 var_24          = dword ptr -24h
.text$mn:00004BB8 var_20          = dword ptr -20h
.text$mn:00004BB8 var_1C          = dword ptr -1Ch
.text$mn:00004BB8 var_18          = dword ptr -18h
.text$mn:00004BB8 var_12          = byte ptr -12h
.text$mn:00004BB8 var_11          = byte ptr -11h
.text$mn:00004BB8 var_10          = dword ptr -10h
.text$mn:00004BB8 var_C           = dword ptr -0Ch
.text$mn:00004BB8 var_4           = dword ptr -4
.text$mn:00004BB8 arg_0           = dword ptr  8
.text$mn:00004BB8
.text$mn:00004BB8 ; FUNCTION CHUNK AT .text$mn:00004CA2 SIZE 00000009 BYTES
.text$mn:00004BB8 ; FUNCTION CHUNK AT .text$mn:00004CB2 SIZE 0000001E BYTES
.text$mn:00004BB8
.text$mn:00004BB8                 push    ebp
.text$mn:00004BB9                 mov     ebp, esp
.text$mn:00004BBB                 push    0FFFFFFFFh
.text$mn:00004BBD                 push    offset __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.text$mn:00004BC2                 mov     eax, large fs:0
.text$mn:00004BC8                 push    eax
.text$mn:00004BC9                 push    ecx
.text$mn:00004BCA                 sub     esp, 24h
.text$mn:00004BCD                 push    ebx
.text$mn:00004BCE                 push    esi
.text$mn:00004BCF                 push    edi
.text$mn:00004BD0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004BD5                 xor     eax, ebp
.text$mn:00004BD7                 push    eax
.text$mn:00004BD8                 lea     eax, [ebp+var_C]
.text$mn:00004BDB                 mov     large fs:0, eax
.text$mn:00004BE1                 mov     [ebp+var_10], esp
.text$mn:00004BE4                 mov     [ebp+var_18], ecx
.text$mn:00004BE7                 lea     eax, [ebp+var_11]
.text$mn:00004BEA                 push    eax
.text$mn:00004BEB                 lea     ecx, [ebp+var_12]
.text$mn:00004BEE                 push    ecx
.text$mn:00004BEF                 mov     ecx, [ebp+arg_0]
.text$mn:00004BF2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00004BF7                 mov     ecx, eax
.text$mn:00004BF9                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<uchar>>::select_on_container_copy_construction(void)
.text$mn:00004BFE                 push    eax
.text$mn:00004BFF                 mov     ecx, [ebp+var_18]
.text$mn:00004C02                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(std::allocator<uchar> const &)
.text$mn:00004C07                 mov     [ebp+var_4], 0
.text$mn:00004C0E                 mov     ecx, [ebp+arg_0]
.text$mn:00004C11                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00004C16                 push    eax
.text$mn:00004C17                 mov     ecx, [ebp+var_18]
.text$mn:00004C1A                 call    ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<uchar,std::allocator<uchar>>::_Buy(uint)
.text$mn:00004C1F                 movzx   edx, al
.text$mn:00004C22                 test    edx, edx
.text$mn:00004C24                 jz      loc_4CB2
.text$mn:00004C2A                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004C2E                 mov     eax, [ebp+var_18]
.text$mn:00004C31                 mov     ecx, [eax+4]
.text$mn:00004C34                 push    ecx
.text$mn:00004C35                 sub     esp, 0Ch
.text$mn:00004C38                 mov     edx, esp
.text$mn:00004C3A                 mov     [ebp+var_28], esp
.text$mn:00004C3D                 push    edx
.text$mn:00004C3E                 mov     ecx, [ebp+arg_0]
.text$mn:00004C41                 call    ?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<uchar,std::allocator<uchar>>::end(void)
.text$mn:00004C46                 mov     [ebp+var_1C], eax
.text$mn:00004C49                 mov     eax, [ebp+var_1C]
.text$mn:00004C4C                 mov     [ebp+var_2C], eax
.text$mn:00004C4F                 mov     byte ptr [ebp+var_4], 2
.text$mn:00004C53                 sub     esp, 0Ch
.text$mn:00004C56                 mov     ecx, esp
.text$mn:00004C58                 mov     [ebp+var_30], esp
.text$mn:00004C5B                 push    ecx
.text$mn:00004C5C                 mov     ecx, [ebp+arg_0]
.text$mn:00004C5F                 call    ?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<uchar,std::allocator<uchar>>::begin(void)
.text$mn:00004C64                 mov     [ebp+var_20], eax
.text$mn:00004C67                 mov     edx, [ebp+var_20]
.text$mn:00004C6A                 mov     [ebp+var_34], edx
.text$mn:00004C6D                 mov     byte ptr [ebp+var_4], 3
.text$mn:00004C71                 mov     byte ptr [ebp+var_4], 1
.text$mn:00004C75                 mov     ecx, [ebp+var_18]
.text$mn:00004C78                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z ; std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)
.text$mn:00004C7D                 mov     [ebp+var_24], eax
.text$mn:00004C80                 mov     eax, [ebp+var_18]
.text$mn:00004C83                 mov     ecx, [ebp+var_24]
.text$mn:00004C86                 mov     [eax+8], ecx
.text$mn:00004C89                 jmp     short loc_4CA2
.text$mn:00004C89 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00004C89
.text$mn:00004C8B
.text$mn:00004C8B ; =============== S U B R O U T I N E =======================================
.text$mn:00004C8B
.text$mn:00004C8B ; Attributes: noreturn
.text$mn:00004C8B
.text$mn:00004C8B __catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:00004C8B                                         ; DATA XREF: .xdata$x:00009750o
.text$mn:00004C8B                 mov     ecx, [ebp-18h]
.text$mn:00004C8E                 call    ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Tidy(void)
.text$mn:00004C93                 push    0
.text$mn:00004C95                 push    0
.text$mn:00004C97                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00004C97 __catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:00004C97
.text$mn:00004C9C ; ---------------------------------------------------------------------------
.text$mn:00004C9C                 mov     eax, offset $LN11
.text$mn:00004CA1                 retn
.text$mn:00004CA2 ; ---------------------------------------------------------------------------
.text$mn:00004CA2 ; START OF FUNCTION CHUNK FOR ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.text$mn:00004CA2
.text$mn:00004CA2 loc_4CA2:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+D1j
.text$mn:00004CA2                 mov     [ebp+var_4], 0
.text$mn:00004CA9                 jmp     short loc_4CB2
.text$mn:00004CA9 ; END OF FUNCTION CHUNK FOR ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.text$mn:00004CAB
.text$mn:00004CAB ; =============== S U B R O U T I N E =======================================
.text$mn:00004CAB
.text$mn:00004CAB
.text$mn:00004CAB $LN11           proc near               ; DATA XREF: .text$mn:00004C9Co
.text$mn:00004CAB                 mov     dword ptr [ebp-4], 0
.text$mn:00004CAB $LN11           endp ; sp-analysis failed
.text$mn:00004CAB
.text$mn:00004CB2 ; START OF FUNCTION CHUNK FOR ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.text$mn:00004CB2
.text$mn:00004CB2 loc_4CB2:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+6Cj
.text$mn:00004CB2                                         ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+F1j
.text$mn:00004CB2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004CB9                 mov     eax, [ebp+var_18]
.text$mn:00004CBC                 mov     ecx, [ebp+var_C]
.text$mn:00004CBF                 mov     large fs:0, ecx
.text$mn:00004CC6                 pop     ecx
.text$mn:00004CC7                 pop     edi
.text$mn:00004CC8                 pop     esi
.text$mn:00004CC9                 pop     ebx
.text$mn:00004CCA                 mov     esp, ebp
.text$mn:00004CCC                 pop     ebp
.text$mn:00004CCD                 retn    4
.text$mn:00004CCD ; END OF FUNCTION CHUNK FOR ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.text$mn:00004CCD _text$mn        ends
.text$mn:00004CCD
.text$x:00004CD0 ; ===========================================================================
.text$x:00004CD0
.text$x:00004CD0 ; Segment type: Pure code
.text$x:00004CD0 ; Segment permissions: Read/Execute
.text$x:00004CD0 _text$x         segment para public 'CODE' use32
.text$x:00004CD0                 assume cs:_text$x
.text$x:00004CD0                 ;org 4CD0h
.text$x:00004CD0 ; COMDAT (pick associative to section at 4BB8)
.text$x:00004CD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004CD0
.text$x:00004CD0 ; =============== S U B R O U T I N E =======================================
.text$x:00004CD0
.text$x:00004CD0
.text$x:00004CD0 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:00004CD0                                         ; DATA XREF: .xdata$x:00009790o
.text$x:00004CD0                 mov     ecx, [ebp-18h]
.text$x:00004CD3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)
.text$x:00004CD3 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:00004CD3
.text$x:00004CD8
.text$x:00004CD8 ; =============== S U B R O U T I N E =======================================
.text$x:00004CD8
.text$x:00004CD8
.text$x:00004CD8 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:00004CD8                                         ; DATA XREF: .xdata$x:000097A0o
.text$x:00004CD8                 mov     ecx, [ebp-28h]
.text$x:00004CDB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00004CDB __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:00004CDB
.text$x:00004CE0
.text$x:00004CE0 ; =============== S U B R O U T I N E =======================================
.text$x:00004CE0
.text$x:00004CE0
.text$x:00004CE0 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:00004CE0                                         ; DATA XREF: .xdata$x:000097A8o
.text$x:00004CE0                 mov     ecx, [ebp-30h]
.text$x:00004CE3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00004CE3 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:00004CE3
.text$x:00004CE8
.text$x:00004CE8 ; =============== S U B R O U T I N E =======================================
.text$x:00004CE8
.text$x:00004CE8
.text$x:00004CE8 __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00004CE8                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+5o
.text$x:00004CE8
.text$x:00004CE8 arg_4           = dword ptr  8
.text$x:00004CE8
.text$x:00004CE8                 mov     edx, [esp+arg_4]
.text$x:00004CEC                 lea     eax, [edx+0Ch]
.text$x:00004CEF                 mov     ecx, [edx-38h]
.text$x:00004CF2                 xor     ecx, eax
.text$x:00004CF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004CF9                 mov     eax, offset __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.text$x:00004CFE                 jmp     ___CxxFrameHandler3
.text$x:00004CFE __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z endp
.text$x:00004CFE
.text$x:00004CFE ; ---------------------------------------------------------------------------
.text$x:00004D03                 align 4
.text$x:00004D03 _text$x         ends
.text$x:00004D03
.text$mn:00004D04 ; ===========================================================================
.text$mn:00004D04
.text$mn:00004D04 ; Segment type: Pure code
.text$mn:00004D04 ; Segment permissions: Read/Execute
.text$mn:00004D04 _text$mn        segment para public 'CODE' use32
.text$mn:00004D04                 assume cs:_text$mn
.text$mn:00004D04                 ;org 4D04h
.text$mn:00004D04 ; COMDAT (pick any)
.text$mn:00004D04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D04
.text$mn:00004D04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D04
.text$mn:00004D04 ; Attributes: bp-based frame
.text$mn:00004D04
.text$mn:00004D04 ; public: __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::vector<unsigned char, class std::allocator<unsigned char>>(void)
.text$mn:00004D04                 public ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.text$mn:00004D04 ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ proc near
.text$mn:00004D04                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+32p
.text$mn:00004D04
.text$mn:00004D04 var_14          = dword ptr -14h
.text$mn:00004D04 var_D           = byte ptr -0Dh
.text$mn:00004D04 var_C           = dword ptr -0Ch
.text$mn:00004D04 var_4           = dword ptr -4
.text$mn:00004D04
.text$mn:00004D04                 push    ebp
.text$mn:00004D05                 mov     ebp, esp
.text$mn:00004D07                 push    0FFFFFFFFh
.text$mn:00004D09                 push    offset __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.text$mn:00004D0E                 mov     eax, large fs:0
.text$mn:00004D14                 push    eax
.text$mn:00004D15                 sub     esp, 8
.text$mn:00004D18                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D1D                 xor     eax, ebp
.text$mn:00004D1F                 push    eax
.text$mn:00004D20                 lea     eax, [ebp+var_C]
.text$mn:00004D23                 mov     large fs:0, eax
.text$mn:00004D29                 mov     [ebp+var_14], ecx
.text$mn:00004D2C                 lea     ecx, [ebp+var_D]
.text$mn:00004D2F                 call    ??0?$allocator@E@std@@QAE@XZ ; std::allocator<uchar>::allocator<uchar>(void)
.text$mn:00004D34                 push    eax
.text$mn:00004D35                 mov     ecx, [ebp+var_14]
.text$mn:00004D38                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(std::allocator<uchar> const &)
.text$mn:00004D3D                 mov     [ebp+var_4], 0
.text$mn:00004D44                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004D4B                 mov     eax, [ebp+var_14]
.text$mn:00004D4E                 mov     ecx, [ebp+var_C]
.text$mn:00004D51                 mov     large fs:0, ecx
.text$mn:00004D58                 pop     ecx
.text$mn:00004D59                 mov     esp, ebp
.text$mn:00004D5B                 pop     ebp
.text$mn:00004D5C                 retn
.text$mn:00004D5C ??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ endp
.text$mn:00004D5C
.text$mn:00004D5C ; ---------------------------------------------------------------------------
.text$mn:00004D5D                 align 10h
.text$mn:00004D5D _text$mn        ends
.text$mn:00004D5D
.text$x:00004D60 ; ===========================================================================
.text$x:00004D60
.text$x:00004D60 ; Segment type: Pure code
.text$x:00004D60 ; Segment permissions: Read/Execute
.text$x:00004D60 _text$x         segment para public 'CODE' use32
.text$x:00004D60                 assume cs:_text$x
.text$x:00004D60                 ;org 4D60h
.text$x:00004D60 ; COMDAT (pick associative to section at 4D04)
.text$x:00004D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004D60
.text$x:00004D60 ; =============== S U B R O U T I N E =======================================
.text$x:00004D60
.text$x:00004D60
.text$x:00004D60 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0 proc near
.text$x:00004D60                                         ; DATA XREF: .xdata$x:0000971Co
.text$x:00004D60                 mov     ecx, [ebp-14h]
.text$x:00004D63                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)
.text$x:00004D63 __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0 endp
.text$x:00004D63
.text$x:00004D68
.text$x:00004D68 ; =============== S U B R O U T I N E =======================================
.text$x:00004D68
.text$x:00004D68
.text$x:00004D68 __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ proc near
.text$x:00004D68                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(void)+5o
.text$x:00004D68
.text$x:00004D68 arg_4           = dword ptr  8
.text$x:00004D68
.text$x:00004D68                 mov     edx, [esp+arg_4]
.text$x:00004D6C                 lea     eax, [edx+0Ch]
.text$x:00004D6F                 mov     ecx, [edx-0Ch]
.text$x:00004D72                 xor     ecx, eax
.text$x:00004D74                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D79                 mov     eax, offset __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.text$x:00004D7E                 jmp     ___CxxFrameHandler3
.text$x:00004D7E __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ endp
.text$x:00004D7E
.text$x:00004D7E ; ---------------------------------------------------------------------------
.text$x:00004D83                 align 4
.text$x:00004D83 _text$x         ends
.text$x:00004D83
.text$mn:00004D84 ; ===========================================================================
.text$mn:00004D84
.text$mn:00004D84 ; Segment type: Pure code
.text$mn:00004D84 ; Segment permissions: Read/Execute
.text$mn:00004D84 _text$mn        segment para public 'CODE' use32
.text$mn:00004D84                 assume cs:_text$mn
.text$mn:00004D84                 ;org 4D84h
.text$mn:00004D84 ; COMDAT (pick any)
.text$mn:00004D84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D84
.text$mn:00004D84 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D84
.text$mn:00004D84 ; Attributes: bp-based frame
.text$mn:00004D84
.text$mn:00004D84 ; _DWORD __thiscall ByteArray::ByteArray(ByteArray *__hidden this)
.text$mn:00004D84                 public ??0ByteArray@@QAE@XZ
.text$mn:00004D84 ??0ByteArray@@QAE@XZ proc near          ; CODE XREF: StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+32p
.text$mn:00004D84
.text$mn:00004D84 var_4           = dword ptr -4
.text$mn:00004D84
.text$mn:00004D84                 push    ebp
.text$mn:00004D85                 mov     ebp, esp
.text$mn:00004D87                 push    ecx
.text$mn:00004D88                 mov     [ebp+var_4], ecx
.text$mn:00004D8B                 mov     eax, [ebp+var_4]
.text$mn:00004D8E                 mov     dword ptr [eax], 0
.text$mn:00004D94                 mov     ecx, [ebp+var_4]
.text$mn:00004D97                 mov     dword ptr [ecx+4], 0
.text$mn:00004D9E                 mov     eax, [ebp+var_4]
.text$mn:00004DA1                 mov     esp, ebp
.text$mn:00004DA3                 pop     ebp
.text$mn:00004DA4                 retn
.text$mn:00004DA4 ??0ByteArray@@QAE@XZ endp
.text$mn:00004DA4
.text$mn:00004DA4 ; ---------------------------------------------------------------------------
.text$mn:00004DA5                 align 4
.text$mn:00004DA5 _text$mn        ends
.text$mn:00004DA5
.text$mn:00004DA8 ; ===========================================================================
.text$mn:00004DA8
.text$mn:00004DA8 ; Segment type: Pure code
.text$mn:00004DA8 ; Segment permissions: Read/Execute
.text$mn:00004DA8 _text$mn        segment para public 'CODE' use32
.text$mn:00004DA8                 assume cs:_text$mn
.text$mn:00004DA8                 ;org 4DA8h
.text$mn:00004DA8 ; COMDAT (pick any)
.text$mn:00004DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DA8
.text$mn:00004DA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DA8
.text$mn:00004DA8 ; Attributes: bp-based frame
.text$mn:00004DA8
.text$mn:00004DA8 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00004DA8                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00004DA8 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00004DA8                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00004DA8                                         ; std::_Vector_val<std::_Simple_types<uchar>>::_Vector_val<std::_Simple_types<uchar>>(void)+29p
.text$mn:00004DA8
.text$mn:00004DA8 var_4           = dword ptr -4
.text$mn:00004DA8
.text$mn:00004DA8                 push    ebp
.text$mn:00004DA9                 mov     ebp, esp
.text$mn:00004DAB                 push    ecx
.text$mn:00004DAC                 mov     [ebp+var_4], ecx
.text$mn:00004DAF                 mov     eax, [ebp+var_4]
.text$mn:00004DB2                 mov     dword ptr [eax], 0
.text$mn:00004DB8                 mov     eax, [ebp+var_4]
.text$mn:00004DBB                 mov     esp, ebp
.text$mn:00004DBD                 pop     ebp
.text$mn:00004DBE                 retn
.text$mn:00004DBE ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00004DBE
.text$mn:00004DBE ; ---------------------------------------------------------------------------
.text$mn:00004DBF                 align 10h
.text$mn:00004DBF _text$mn        ends
.text$mn:00004DBF
.text$mn:00004DC0 ; ===========================================================================
.text$mn:00004DC0
.text$mn:00004DC0 ; Segment type: Pure code
.text$mn:00004DC0 ; Segment permissions: Read/Execute
.text$mn:00004DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00004DC0                 assume cs:_text$mn
.text$mn:00004DC0                 ;org 4DC0h
.text$mn:00004DC0 ; COMDAT (pick any)
.text$mn:00004DC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DC0
.text$mn:00004DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DC0
.text$mn:00004DC0 ; Attributes: bp-based frame
.text$mn:00004DC0
.text$mn:00004DC0 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00004DC0                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00004DC0 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00004DC0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00004DC0                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Alloc_proxy(void)+23p
.text$mn:00004DC0
.text$mn:00004DC0 var_4           = dword ptr -4
.text$mn:00004DC0
.text$mn:00004DC0                 push    ebp
.text$mn:00004DC1                 mov     ebp, esp
.text$mn:00004DC3                 push    ecx
.text$mn:00004DC4                 mov     [ebp+var_4], ecx
.text$mn:00004DC7                 mov     eax, [ebp+var_4]
.text$mn:00004DCA                 mov     dword ptr [eax], 0
.text$mn:00004DD0                 mov     ecx, [ebp+var_4]
.text$mn:00004DD3                 mov     dword ptr [ecx+4], 0
.text$mn:00004DDA                 mov     eax, [ebp+var_4]
.text$mn:00004DDD                 mov     esp, ebp
.text$mn:00004DDF                 pop     ebp
.text$mn:00004DE0                 retn
.text$mn:00004DE0 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00004DE0
.text$mn:00004DE0 ; ---------------------------------------------------------------------------
.text$mn:00004DE1                 align 4
.text$mn:00004DE1 _text$mn        ends
.text$mn:00004DE1
.text$mn:00004DE4 ; ===========================================================================
.text$mn:00004DE4
.text$mn:00004DE4 ; Segment type: Pure code
.text$mn:00004DE4 ; Segment permissions: Read/Execute
.text$mn:00004DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00004DE4                 assume cs:_text$mn
.text$mn:00004DE4                 ;org 4DE4h
.text$mn:00004DE4 ; COMDAT (pick any)
.text$mn:00004DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DE4
.text$mn:00004DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004DE4
.text$mn:00004DE4 ; Attributes: bp-based frame
.text$mn:00004DE4
.text$mn:00004DE4 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00004DE4                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00004DE4 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00004DE4                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00004DE4                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00004DE4
.text$mn:00004DE4 var_10          = dword ptr -10h
.text$mn:00004DE4 var_C           = dword ptr -0Ch
.text$mn:00004DE4 var_4           = dword ptr -4
.text$mn:00004DE4
.text$mn:00004DE4                 push    ebp
.text$mn:00004DE5                 mov     ebp, esp
.text$mn:00004DE7                 push    0FFFFFFFFh
.text$mn:00004DE9                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00004DEE                 mov     eax, large fs:0
.text$mn:00004DF4                 push    eax
.text$mn:00004DF5                 push    ecx
.text$mn:00004DF6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004DFB                 xor     eax, ebp
.text$mn:00004DFD                 push    eax
.text$mn:00004DFE                 lea     eax, [ebp+var_C]
.text$mn:00004E01                 mov     large fs:0, eax
.text$mn:00004E07                 mov     [ebp+var_10], ecx
.text$mn:00004E0A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004E0D                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00004E12                 mov     [ebp+var_4], 0
.text$mn:00004E19                 mov     eax, [ebp+var_10]
.text$mn:00004E1C                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00004E22                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004E29                 mov     eax, [ebp+var_10]
.text$mn:00004E2C                 mov     ecx, [ebp+var_C]
.text$mn:00004E2F                 mov     large fs:0, ecx
.text$mn:00004E36                 pop     ecx
.text$mn:00004E37                 mov     esp, ebp
.text$mn:00004E39                 pop     ebp
.text$mn:00004E3A                 retn
.text$mn:00004E3A ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00004E3A
.text$mn:00004E3A ; ---------------------------------------------------------------------------
.text$mn:00004E3B                 align 4
.text$mn:00004E3B _text$mn        ends
.text$mn:00004E3B
.text$x:00004E3C ; ===========================================================================
.text$x:00004E3C
.text$x:00004E3C ; Segment type: Pure code
.text$x:00004E3C ; Segment permissions: Read/Execute
.text$x:00004E3C _text$x         segment para public 'CODE' use32
.text$x:00004E3C                 assume cs:_text$x
.text$x:00004E3C                 ;org 4E3Ch
.text$x:00004E3C ; COMDAT (pick associative to section at 4DE4)
.text$x:00004E3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004E3C
.text$x:00004E3C ; =============== S U B R O U T I N E =======================================
.text$x:00004E3C
.text$x:00004E3C
.text$x:00004E3C __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00004E3C                                         ; DATA XREF: .xdata$x:0000912Co
.text$x:00004E3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00004E3F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00004E3F __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00004E3F
.text$x:00004E44
.text$x:00004E44 ; =============== S U B R O U T I N E =======================================
.text$x:00004E44
.text$x:00004E44
.text$x:00004E44 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00004E44                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00004E44
.text$x:00004E44 arg_4           = dword ptr  8
.text$x:00004E44
.text$x:00004E44                 mov     edx, [esp+arg_4]
.text$x:00004E48                 lea     eax, [edx+0Ch]
.text$x:00004E4B                 mov     ecx, [edx-8]
.text$x:00004E4E                 xor     ecx, eax
.text$x:00004E50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E55                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00004E5A                 jmp     ___CxxFrameHandler3
.text$x:00004E5A __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00004E5A
.text$x:00004E5A ; ---------------------------------------------------------------------------
.text$x:00004E5F                 align 10h
.text$x:00004E5F _text$x         ends
.text$x:00004E5F
.text$mn:00004E60 ; ===========================================================================
.text$mn:00004E60
.text$mn:00004E60 ; Segment type: Pure code
.text$mn:00004E60 ; Segment permissions: Read/Execute
.text$mn:00004E60 _text$mn        segment para public 'CODE' use32
.text$mn:00004E60                 assume cs:_text$mn
.text$mn:00004E60                 ;org 4E60h
.text$mn:00004E60 ; COMDAT (pick any)
.text$mn:00004E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E60
.text$mn:00004E60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E60
.text$mn:00004E60 ; Attributes: bp-based frame
.text$mn:00004E60
.text$mn:00004E60 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00004E60                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00004E60 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00004E60
.text$mn:00004E60 var_4           = dword ptr -4
.text$mn:00004E60
.text$mn:00004E60                 push    ebp
.text$mn:00004E61                 mov     ebp, esp
.text$mn:00004E63                 push    ecx
.text$mn:00004E64                 mov     [ebp+var_4], ecx
.text$mn:00004E67                 mov     eax, [ebp+var_4]
.text$mn:00004E6A                 mov     esp, ebp
.text$mn:00004E6C                 pop     ebp
.text$mn:00004E6D                 retn
.text$mn:00004E6D ??0_Ignore@std@@QAE@XZ endp
.text$mn:00004E6D
.text$mn:00004E6D ; ---------------------------------------------------------------------------
.text$mn:00004E6E                 align 10h
.text$mn:00004E6E _text$mn        ends
.text$mn:00004E6E
.text$mn:00004E70 ; ===========================================================================
.text$mn:00004E70
.text$mn:00004E70 ; Segment type: Pure code
.text$mn:00004E70 ; Segment permissions: Read/Execute
.text$mn:00004E70 _text$mn        segment para public 'CODE' use32
.text$mn:00004E70                 assume cs:_text$mn
.text$mn:00004E70                 ;org 4E70h
.text$mn:00004E70 ; COMDAT (pick any)
.text$mn:00004E70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E70
.text$mn:00004E70 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E70
.text$mn:00004E70 ; Attributes: bp-based frame
.text$mn:00004E70
.text$mn:00004E70 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00004E70                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00004E70 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00004E70                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00004E70
.text$mn:00004E70 var_10          = dword ptr -10h
.text$mn:00004E70 var_C           = dword ptr -0Ch
.text$mn:00004E70 var_4           = dword ptr -4
.text$mn:00004E70
.text$mn:00004E70                 push    ebp
.text$mn:00004E71                 mov     ebp, esp
.text$mn:00004E73                 push    0FFFFFFFFh
.text$mn:00004E75                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00004E7A                 mov     eax, large fs:0
.text$mn:00004E80                 push    eax
.text$mn:00004E81                 push    ecx
.text$mn:00004E82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004E87                 xor     eax, ebp
.text$mn:00004E89                 push    eax
.text$mn:00004E8A                 lea     eax, [ebp+var_C]
.text$mn:00004E8D                 mov     large fs:0, eax
.text$mn:00004E93                 mov     [ebp+var_10], ecx
.text$mn:00004E96                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004E99                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00004E9E                 mov     [ebp+var_4], 0
.text$mn:00004EA5                 mov     eax, [ebp+var_10]
.text$mn:00004EA8                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00004EAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004EB5                 mov     eax, [ebp+var_10]
.text$mn:00004EB8                 mov     ecx, [ebp+var_C]
.text$mn:00004EBB                 mov     large fs:0, ecx
.text$mn:00004EC2                 pop     ecx
.text$mn:00004EC3                 mov     esp, ebp
.text$mn:00004EC5                 pop     ebp
.text$mn:00004EC6                 retn
.text$mn:00004EC6 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00004EC6
.text$mn:00004EC6 ; ---------------------------------------------------------------------------
.text$mn:00004EC7                 align 4
.text$mn:00004EC7 _text$mn        ends
.text$mn:00004EC7
.text$x:00004EC8 ; ===========================================================================
.text$x:00004EC8
.text$x:00004EC8 ; Segment type: Pure code
.text$x:00004EC8 ; Segment permissions: Read/Execute
.text$x:00004EC8 _text$x         segment para public 'CODE' use32
.text$x:00004EC8                 assume cs:_text$x
.text$x:00004EC8                 ;org 4EC8h
.text$x:00004EC8 ; COMDAT (pick associative to section at 4E70)
.text$x:00004EC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004EC8
.text$x:00004EC8 ; =============== S U B R O U T I N E =======================================
.text$x:00004EC8
.text$x:00004EC8
.text$x:00004EC8 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00004EC8                                         ; DATA XREF: .xdata$x:000091B0o
.text$x:00004EC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00004ECB                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004ECB __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00004ECB
.text$x:00004ED0
.text$x:00004ED0 ; =============== S U B R O U T I N E =======================================
.text$x:00004ED0
.text$x:00004ED0
.text$x:00004ED0 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00004ED0                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00004ED0
.text$x:00004ED0 arg_4           = dword ptr  8
.text$x:00004ED0
.text$x:00004ED0                 mov     edx, [esp+arg_4]
.text$x:00004ED4                 lea     eax, [edx+0Ch]
.text$x:00004ED7                 mov     ecx, [edx-8]
.text$x:00004EDA                 xor     ecx, eax
.text$x:00004EDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004EE1                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00004EE6                 jmp     ___CxxFrameHandler3
.text$x:00004EE6 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00004EE6
.text$x:00004EE6 ; ---------------------------------------------------------------------------
.text$x:00004EEB                 align 4
.text$x:00004EEB _text$x         ends
.text$x:00004EEB
.text$mn:00004EEC ; ===========================================================================
.text$mn:00004EEC
.text$mn:00004EEC ; Segment type: Pure code
.text$mn:00004EEC ; Segment permissions: Read/Execute
.text$mn:00004EEC _text$mn        segment para public 'CODE' use32
.text$mn:00004EEC                 assume cs:_text$mn
.text$mn:00004EEC                 ;org 4EECh
.text$mn:00004EEC ; COMDAT (pick any)
.text$mn:00004EEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EEC
.text$mn:00004EEC ; =============== S U B R O U T I N E =======================================
.text$mn:00004EEC
.text$mn:00004EEC ; Attributes: bp-based frame
.text$mn:00004EEC
.text$mn:00004EEC ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00004EEC                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00004EEC ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00004EEC                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00004EEC                                         ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00004EEC
.text$mn:00004EEC var_4           = dword ptr -4
.text$mn:00004EEC arg_0           = dword ptr  8
.text$mn:00004EEC
.text$mn:00004EEC                 push    ebp
.text$mn:00004EED                 mov     ebp, esp
.text$mn:00004EEF                 push    ecx
.text$mn:00004EF0                 mov     [ebp+var_4], ecx
.text$mn:00004EF3                 mov     eax, [ebp+var_4]
.text$mn:00004EF6                 mov     dword ptr [eax], 0
.text$mn:00004EFC                 mov     ecx, [ebp+var_4]
.text$mn:00004EFF                 mov     dword ptr [ecx+4], 0
.text$mn:00004F06                 mov     edx, [ebp+arg_0]
.text$mn:00004F09                 push    edx
.text$mn:00004F0A                 mov     ecx, [ebp+var_4]
.text$mn:00004F0D                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00004F12                 mov     eax, [ebp+var_4]
.text$mn:00004F15                 mov     esp, ebp
.text$mn:00004F17                 pop     ebp
.text$mn:00004F18                 retn    4
.text$mn:00004F18 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00004F18
.text$mn:00004F18 ; ---------------------------------------------------------------------------
.text$mn:00004F1B                 align 4
.text$mn:00004F1B _text$mn        ends
.text$mn:00004F1B
.text$mn:00004F1C ; ===========================================================================
.text$mn:00004F1C
.text$mn:00004F1C ; Segment type: Pure code
.text$mn:00004F1C ; Segment permissions: Read/Execute
.text$mn:00004F1C _text$mn        segment para public 'CODE' use32
.text$mn:00004F1C                 assume cs:_text$mn
.text$mn:00004F1C                 ;org 4F1Ch
.text$mn:00004F1C ; COMDAT (pick any)
.text$mn:00004F1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F1C
.text$mn:00004F1C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F1C
.text$mn:00004F1C ; Attributes: bp-based frame
.text$mn:00004F1C
.text$mn:00004F1C ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00004F1C                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00004F1C ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00004F1C                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)+29p
.text$mn:00004F1C                                         ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)+29p
.text$mn:00004F1C
.text$mn:00004F1C var_4           = dword ptr -4
.text$mn:00004F1C
.text$mn:00004F1C                 push    ebp
.text$mn:00004F1D                 mov     ebp, esp
.text$mn:00004F1F                 push    ecx
.text$mn:00004F20                 mov     [ebp+var_4], ecx
.text$mn:00004F23                 mov     eax, [ebp+var_4]
.text$mn:00004F26                 mov     dword ptr [eax], 0
.text$mn:00004F2C                 mov     ecx, [ebp+var_4]
.text$mn:00004F2F                 mov     dword ptr [ecx+4], 0
.text$mn:00004F36                 mov     eax, [ebp+var_4]
.text$mn:00004F39                 mov     esp, ebp
.text$mn:00004F3B                 pop     ebp
.text$mn:00004F3C                 retn
.text$mn:00004F3C ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00004F3C
.text$mn:00004F3C ; ---------------------------------------------------------------------------
.text$mn:00004F3D                 align 10h
.text$mn:00004F3D _text$mn        ends
.text$mn:00004F3D
.text$mn:00004F40 ; ===========================================================================
.text$mn:00004F40
.text$mn:00004F40 ; Segment type: Pure code
.text$mn:00004F40 ; Segment permissions: Read/Execute
.text$mn:00004F40 _text$mn        segment para public 'CODE' use32
.text$mn:00004F40                 assume cs:_text$mn
.text$mn:00004F40                 ;org 4F40h
.text$mn:00004F40 ; COMDAT (pick any)
.text$mn:00004F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F40
.text$mn:00004F40 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F40
.text$mn:00004F40 ; Attributes: bp-based frame
.text$mn:00004F40
.text$mn:00004F40 ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00004F40                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00004F40 ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00004F40                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00004F40
.text$mn:00004F40 var_10          = dword ptr -10h
.text$mn:00004F40 var_C           = dword ptr -0Ch
.text$mn:00004F40 var_4           = dword ptr -4
.text$mn:00004F40
.text$mn:00004F40                 push    ebp
.text$mn:00004F41                 mov     ebp, esp
.text$mn:00004F43                 push    0FFFFFFFFh
.text$mn:00004F45                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00004F4A                 mov     eax, large fs:0
.text$mn:00004F50                 push    eax
.text$mn:00004F51                 push    ecx
.text$mn:00004F52                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004F57                 xor     eax, ebp
.text$mn:00004F59                 push    eax
.text$mn:00004F5A                 lea     eax, [ebp+var_C]
.text$mn:00004F5D                 mov     large fs:0, eax
.text$mn:00004F63                 mov     [ebp+var_10], ecx
.text$mn:00004F66                 mov     ecx, [ebp+var_10] ; this
.text$mn:00004F69                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00004F6E                 mov     [ebp+var_4], 0
.text$mn:00004F75                 mov     eax, [ebp+var_10]
.text$mn:00004F78                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00004F7E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00004F85                 mov     eax, [ebp+var_10]
.text$mn:00004F88                 mov     ecx, [ebp+var_C]
.text$mn:00004F8B                 mov     large fs:0, ecx
.text$mn:00004F92                 pop     ecx
.text$mn:00004F93                 mov     esp, ebp
.text$mn:00004F95                 pop     ebp
.text$mn:00004F96                 retn
.text$mn:00004F96 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00004F96
.text$mn:00004F96 ; ---------------------------------------------------------------------------
.text$mn:00004F97                 align 4
.text$mn:00004F97 _text$mn        ends
.text$mn:00004F97
.text$x:00004F98 ; ===========================================================================
.text$x:00004F98
.text$x:00004F98 ; Segment type: Pure code
.text$x:00004F98 ; Segment permissions: Read/Execute
.text$x:00004F98 _text$x         segment para public 'CODE' use32
.text$x:00004F98                 assume cs:_text$x
.text$x:00004F98                 ;org 4F98h
.text$x:00004F98 ; COMDAT (pick associative to section at 4F40)
.text$x:00004F98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004F98
.text$x:00004F98 ; =============== S U B R O U T I N E =======================================
.text$x:00004F98
.text$x:00004F98
.text$x:00004F98 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00004F98                                         ; DATA XREF: .xdata$x:00009234o
.text$x:00004F98                 mov     ecx, [ebp-10h]  ; this
.text$x:00004F9B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00004F9B __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00004F9B
.text$x:00004FA0
.text$x:00004FA0 ; =============== S U B R O U T I N E =======================================
.text$x:00004FA0
.text$x:00004FA0
.text$x:00004FA0 __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00004FA0                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00004FA0
.text$x:00004FA0 arg_4           = dword ptr  8
.text$x:00004FA0
.text$x:00004FA0                 mov     edx, [esp+arg_4]
.text$x:00004FA4                 lea     eax, [edx+0Ch]
.text$x:00004FA7                 mov     ecx, [edx-8]
.text$x:00004FAA                 xor     ecx, eax
.text$x:00004FAC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004FB1                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00004FB6                 jmp     ___CxxFrameHandler3
.text$x:00004FB6 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00004FB6
.text$x:00004FB6 ; ---------------------------------------------------------------------------
.text$x:00004FBB                 align 4
.text$x:00004FBB _text$x         ends
.text$x:00004FBB
.text$mn:00004FBC ; ===========================================================================
.text$mn:00004FBC
.text$mn:00004FBC ; Segment type: Pure code
.text$mn:00004FBC ; Segment permissions: Read/Execute
.text$mn:00004FBC _text$mn        segment para public 'CODE' use32
.text$mn:00004FBC                 assume cs:_text$mn
.text$mn:00004FBC                 ;org 4FBCh
.text$mn:00004FBC ; COMDAT (pick any)
.text$mn:00004FBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FBC
.text$mn:00004FBC ; =============== S U B R O U T I N E =======================================
.text$mn:00004FBC
.text$mn:00004FBC ; Attributes: bp-based frame
.text$mn:00004FBC
.text$mn:00004FBC ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00004FBC                 public ??0error_category@std@@QAE@XZ
.text$mn:00004FBC ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00004FBC
.text$mn:00004FBC var_4           = dword ptr -4
.text$mn:00004FBC
.text$mn:00004FBC                 push    ebp
.text$mn:00004FBD                 mov     ebp, esp
.text$mn:00004FBF                 push    ecx
.text$mn:00004FC0                 mov     [ebp+var_4], ecx
.text$mn:00004FC3                 mov     eax, [ebp+var_4]
.text$mn:00004FC6                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00004FCC                 mov     eax, [ebp+var_4]
.text$mn:00004FCF                 mov     esp, ebp
.text$mn:00004FD1                 pop     ebp
.text$mn:00004FD2                 retn
.text$mn:00004FD2 ??0error_category@std@@QAE@XZ endp
.text$mn:00004FD2
.text$mn:00004FD2 ; ---------------------------------------------------------------------------
.text$mn:00004FD3                 align 4
.text$mn:00004FD3 _text$mn        ends
.text$mn:00004FD3
.text$mn:00004FD4 ; ===========================================================================
.text$mn:00004FD4
.text$mn:00004FD4 ; Segment type: Pure code
.text$mn:00004FD4 ; Segment permissions: Read/Execute
.text$mn:00004FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00004FD4                 assume cs:_text$mn
.text$mn:00004FD4                 ;org 4FD4h
.text$mn:00004FD4 ; COMDAT (pick any)
.text$mn:00004FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FD4
.text$mn:00004FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FD4
.text$mn:00004FD4 ; Attributes: bp-based frame
.text$mn:00004FD4
.text$mn:00004FD4 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00004FD4                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00004FD4 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00004FD4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00004FD4                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00004FD4
.text$mn:00004FD4 var_4           = dword ptr -4
.text$mn:00004FD4 arg_0           = dword ptr  8
.text$mn:00004FD4 arg_4           = dword ptr  0Ch
.text$mn:00004FD4
.text$mn:00004FD4                 push    ebp
.text$mn:00004FD5                 mov     ebp, esp
.text$mn:00004FD7                 push    ecx
.text$mn:00004FD8                 mov     [ebp+var_4], ecx
.text$mn:00004FDB                 mov     eax, [ebp+var_4]
.text$mn:00004FDE                 mov     ecx, [ebp+arg_0]
.text$mn:00004FE1                 mov     [eax], ecx
.text$mn:00004FE3                 mov     edx, [ebp+var_4]
.text$mn:00004FE6                 mov     eax, [ebp+arg_4]
.text$mn:00004FE9                 mov     [edx+4], eax
.text$mn:00004FEC                 mov     eax, [ebp+var_4]
.text$mn:00004FEF                 mov     esp, ebp
.text$mn:00004FF1                 pop     ebp
.text$mn:00004FF2                 retn    8
.text$mn:00004FF2 ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00004FF2
.text$mn:00004FF2 ; ---------------------------------------------------------------------------
.text$mn:00004FF5                 align 4
.text$mn:00004FF5 _text$mn        ends
.text$mn:00004FF5
.text$mn:00004FF8 ; ===========================================================================
.text$mn:00004FF8
.text$mn:00004FF8 ; Segment type: Pure code
.text$mn:00004FF8 ; Segment permissions: Read/Execute
.text$mn:00004FF8 _text$mn        segment para public 'CODE' use32
.text$mn:00004FF8                 assume cs:_text$mn
.text$mn:00004FF8                 ;org 4FF8h
.text$mn:00004FF8 ; COMDAT (pick any)
.text$mn:00004FF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FF8
.text$mn:00004FF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FF8
.text$mn:00004FF8 ; Attributes: bp-based frame
.text$mn:00004FF8
.text$mn:00004FF8 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00004FF8                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00004FF8 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00004FF8                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00004FF8
.text$mn:00004FF8 var_4           = dword ptr -4
.text$mn:00004FF8 arg_0           = dword ptr  8
.text$mn:00004FF8
.text$mn:00004FF8                 push    ebp
.text$mn:00004FF9                 mov     ebp, esp
.text$mn:00004FFB                 push    ecx
.text$mn:00004FFC                 mov     [ebp+var_4], ecx
.text$mn:00004FFF                 mov     eax, [ebp+var_4]
.text$mn:00005002                 mov     ecx, [ebp+arg_0]
.text$mn:00005005                 mov     [eax], ecx
.text$mn:00005007                 mov     eax, [ebp+var_4]
.text$mn:0000500A                 mov     esp, ebp
.text$mn:0000500C                 pop     ebp
.text$mn:0000500D                 retn    4
.text$mn:0000500D ??0id@locale@std@@QAE@I@Z endp
.text$mn:0000500D
.text$mn:0000500D _text$mn        ends
.text$mn:0000500D
.text$mn:00005010 ; ===========================================================================
.text$mn:00005010
.text$mn:00005010 ; Segment type: Pure code
.text$mn:00005010 ; Segment permissions: Read/Execute
.text$mn:00005010 _text$mn        segment para public 'CODE' use32
.text$mn:00005010                 assume cs:_text$mn
.text$mn:00005010                 ;org 5010h
.text$mn:00005010 ; COMDAT (pick any)
.text$mn:00005010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005010
.text$mn:00005010 ; =============== S U B R O U T I N E =======================================
.text$mn:00005010
.text$mn:00005010 ; Attributes: bp-based frame
.text$mn:00005010
.text$mn:00005010 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, unsigned char, int, unsigned char const *, unsigned char const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, unsigned char, int, unsigned char const *, unsigned char const &, struct std::_Iterator_base12>(void)
.text$mn:00005010                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00005010 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00005010                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00005010                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z$0+3j ...
.text$mn:00005010
.text$mn:00005010 var_10          = dword ptr -10h
.text$mn:00005010 var_C           = dword ptr -0Ch
.text$mn:00005010 var_4           = dword ptr -4
.text$mn:00005010
.text$mn:00005010                 push    ebp
.text$mn:00005011                 mov     ebp, esp
.text$mn:00005013                 push    0FFFFFFFFh
.text$mn:00005015                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000501A                 mov     eax, large fs:0
.text$mn:00005020                 push    eax
.text$mn:00005021                 push    ecx
.text$mn:00005022                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005027                 xor     eax, ebp
.text$mn:00005029                 push    eax
.text$mn:0000502A                 lea     eax, [ebp+var_C]
.text$mn:0000502D                 mov     large fs:0, eax
.text$mn:00005033                 mov     [ebp+var_10], ecx
.text$mn:00005036                 mov     [ebp+var_4], 0
.text$mn:0000503D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005044                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005047                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:0000504C                 mov     ecx, [ebp+var_C]
.text$mn:0000504F                 mov     large fs:0, ecx
.text$mn:00005056                 pop     ecx
.text$mn:00005057                 mov     esp, ebp
.text$mn:00005059                 pop     ebp
.text$mn:0000505A                 retn
.text$mn:0000505A ??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:0000505A
.text$mn:0000505A ; ---------------------------------------------------------------------------
.text$mn:0000505B                 align 4
.text$mn:0000505B _text$mn        ends
.text$mn:0000505B
.text$x:0000505C ; ===========================================================================
.text$x:0000505C
.text$x:0000505C ; Segment type: Pure code
.text$x:0000505C ; Segment permissions: Read/Execute
.text$x:0000505C _text$x         segment para public 'CODE' use32
.text$x:0000505C                 assume cs:_text$x
.text$x:0000505C                 ;org 505Ch
.text$x:0000505C ; COMDAT (pick associative to section at 5010)
.text$x:0000505C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000505C
.text$x:0000505C ; =============== S U B R O U T I N E =======================================
.text$x:0000505C
.text$x:0000505C
.text$x:0000505C __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:0000505C                                         ; DATA XREF: .xdata$x:00009BCCo
.text$x:0000505C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000505F                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000505F __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000505F
.text$x:00005064
.text$x:00005064 ; =============== S U B R O U T I N E =======================================
.text$x:00005064
.text$x:00005064
.text$x:00005064 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00005064                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)+5o
.text$x:00005064
.text$x:00005064 arg_4           = dword ptr  8
.text$x:00005064
.text$x:00005064                 mov     edx, [esp+arg_4]
.text$x:00005068                 lea     eax, [edx+0Ch]
.text$x:0000506B                 mov     ecx, [edx-8]
.text$x:0000506E                 xor     ecx, eax
.text$x:00005070                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005075                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.text$x:0000507A                 jmp     ___CxxFrameHandler3
.text$x:0000507A __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:0000507A
.text$x:0000507A ; ---------------------------------------------------------------------------
.text$x:0000507F                 align 10h
.text$x:0000507F _text$x         ends
.text$x:0000507F
.text$mn:00005080 ; ===========================================================================
.text$mn:00005080
.text$mn:00005080 ; Segment type: Pure code
.text$mn:00005080 ; Segment permissions: Read/Execute
.text$mn:00005080 _text$mn        segment para public 'CODE' use32
.text$mn:00005080                 assume cs:_text$mn
.text$mn:00005080                 ;org 5080h
.text$mn:00005080 ; COMDAT (pick any)
.text$mn:00005080                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005080
.text$mn:00005080 ; =============== S U B R O U T I N E =======================================
.text$mn:00005080
.text$mn:00005080 ; Attributes: bp-based frame
.text$mn:00005080
.text$mn:00005080 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class std::vector<unsigned char, class std::allocator<unsigned char>>, int, class std::vector<unsigned char, class std::allocator<unsigned char>> const *, class std::vector<unsigned char, class std::allocator<unsigned char>> const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, class std::vector<unsigned char, class std::allocator<unsigned char>>, int, class std::vector<unsigned char, class std::allocator<unsigned char>> const *, class std::vector<unsigned char, class std::allocator<unsigned char>> const &, struct std::_Iterator_base12>(void)
.text$mn:00005080                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00005080 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00005080                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00005080                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00005080
.text$mn:00005080 var_10          = dword ptr -10h
.text$mn:00005080 var_C           = dword ptr -0Ch
.text$mn:00005080 var_4           = dword ptr -4
.text$mn:00005080
.text$mn:00005080                 push    ebp
.text$mn:00005081                 mov     ebp, esp
.text$mn:00005083                 push    0FFFFFFFFh
.text$mn:00005085                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000508A                 mov     eax, large fs:0
.text$mn:00005090                 push    eax
.text$mn:00005091                 push    ecx
.text$mn:00005092                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005097                 xor     eax, ebp
.text$mn:00005099                 push    eax
.text$mn:0000509A                 lea     eax, [ebp+var_C]
.text$mn:0000509D                 mov     large fs:0, eax
.text$mn:000050A3                 mov     [ebp+var_10], ecx
.text$mn:000050A6                 mov     [ebp+var_4], 0
.text$mn:000050AD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000050B4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000050B7                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:000050BC                 mov     ecx, [ebp+var_C]
.text$mn:000050BF                 mov     large fs:0, ecx
.text$mn:000050C6                 pop     ecx
.text$mn:000050C7                 mov     esp, ebp
.text$mn:000050C9                 pop     ebp
.text$mn:000050CA                 retn
.text$mn:000050CA ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:000050CA
.text$mn:000050CA ; ---------------------------------------------------------------------------
.text$mn:000050CB                 align 4
.text$mn:000050CB _text$mn        ends
.text$mn:000050CB
.text$x:000050CC ; ===========================================================================
.text$x:000050CC
.text$x:000050CC ; Segment type: Pure code
.text$x:000050CC ; Segment permissions: Read/Execute
.text$x:000050CC _text$x         segment para public 'CODE' use32
.text$x:000050CC                 assume cs:_text$x
.text$x:000050CC                 ;org 50CCh
.text$x:000050CC ; COMDAT (pick associative to section at 5080)
.text$x:000050CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000050CC
.text$x:000050CC ; =============== S U B R O U T I N E =======================================
.text$x:000050CC
.text$x:000050CC
.text$x:000050CC __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000050CC                                         ; DATA XREF: .xdata$x:00009A0Co
.text$x:000050CC                 mov     ecx, [ebp-10h]  ; this
.text$x:000050CF                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000050CF __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000050CF
.text$x:000050D4
.text$x:000050D4 ; =============== S U B R O U T I N E =======================================
.text$x:000050D4
.text$x:000050D4
.text$x:000050D4 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:000050D4                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)+5o
.text$x:000050D4
.text$x:000050D4 arg_4           = dword ptr  8
.text$x:000050D4
.text$x:000050D4                 mov     edx, [esp+arg_4]
.text$x:000050D8                 lea     eax, [edx+0Ch]
.text$x:000050DB                 mov     ecx, [edx-8]
.text$x:000050DE                 xor     ecx, eax
.text$x:000050E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000050E5                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:000050EA                 jmp     ___CxxFrameHandler3
.text$x:000050EA __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000050EA
.text$x:000050EA ; ---------------------------------------------------------------------------
.text$x:000050EF                 align 10h
.text$x:000050EF _text$x         ends
.text$x:000050EF
.text$mn:000050F0 ; ===========================================================================
.text$mn:000050F0
.text$mn:000050F0 ; Segment type: Pure code
.text$mn:000050F0 ; Segment permissions: Read/Execute
.text$mn:000050F0 _text$mn        segment para public 'CODE' use32
.text$mn:000050F0                 assume cs:_text$mn
.text$mn:000050F0                 ;org 50F0h
.text$mn:000050F0 ; COMDAT (pick any)
.text$mn:000050F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000050F0
.text$mn:000050F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000050F0
.text$mn:000050F0 ; Attributes: bp-based frame
.text$mn:000050F0
.text$mn:000050F0 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:000050F0                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000050F0 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000050F0                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:000050F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:000050F0
.text$mn:000050F0 var_10          = dword ptr -10h
.text$mn:000050F0 var_C           = dword ptr -0Ch
.text$mn:000050F0 var_4           = dword ptr -4
.text$mn:000050F0
.text$mn:000050F0                 push    ebp
.text$mn:000050F1                 mov     ebp, esp
.text$mn:000050F3                 push    0FFFFFFFFh
.text$mn:000050F5                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:000050FA                 mov     eax, large fs:0
.text$mn:00005100                 push    eax
.text$mn:00005101                 push    ecx
.text$mn:00005102                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005107                 xor     eax, ebp
.text$mn:00005109                 push    eax
.text$mn:0000510A                 lea     eax, [ebp+var_C]
.text$mn:0000510D                 mov     large fs:0, eax
.text$mn:00005113                 mov     [ebp+var_10], ecx
.text$mn:00005116                 mov     [ebp+var_4], 0
.text$mn:0000511D                 mov     ecx, [ebp+var_10]
.text$mn:00005120                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00005125                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000512C                 mov     ecx, [ebp+var_10]
.text$mn:0000512F                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00005134                 mov     ecx, [ebp+var_C]
.text$mn:00005137                 mov     large fs:0, ecx
.text$mn:0000513E                 pop     ecx
.text$mn:0000513F                 mov     esp, ebp
.text$mn:00005141                 pop     ebp
.text$mn:00005142                 retn
.text$mn:00005142 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005142
.text$mn:00005142 ; ---------------------------------------------------------------------------
.text$mn:00005143                 align 4
.text$mn:00005143 _text$mn        ends
.text$mn:00005143
.text$x:00005144 ; ===========================================================================
.text$x:00005144
.text$x:00005144 ; Segment type: Pure code
.text$x:00005144 ; Segment permissions: Read/Execute
.text$x:00005144 _text$x         segment para public 'CODE' use32
.text$x:00005144                 assume cs:_text$x
.text$x:00005144                 ;org 5144h
.text$x:00005144 ; COMDAT (pick associative to section at 50F0)
.text$x:00005144                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005144
.text$x:00005144 ; =============== S U B R O U T I N E =======================================
.text$x:00005144
.text$x:00005144
.text$x:00005144 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005144                                         ; DATA XREF: .xdata$x:0000901Co
.text$x:00005144                 mov     ecx, [ebp-10h]
.text$x:00005147                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00005147 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00005147
.text$x:0000514C
.text$x:0000514C ; =============== S U B R O U T I N E =======================================
.text$x:0000514C
.text$x:0000514C
.text$x:0000514C __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:0000514C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:0000514C
.text$x:0000514C arg_4           = dword ptr  8
.text$x:0000514C
.text$x:0000514C                 mov     edx, [esp+arg_4]
.text$x:00005150                 lea     eax, [edx+0Ch]
.text$x:00005153                 mov     ecx, [edx-8]
.text$x:00005156                 xor     ecx, eax
.text$x:00005158                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000515D                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00005162                 jmp     ___CxxFrameHandler3
.text$x:00005162 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00005162
.text$x:00005162 ; ---------------------------------------------------------------------------
.text$x:00005167                 align 4
.text$x:00005167 _text$x         ends
.text$x:00005167
.text$mn:00005168 ; ===========================================================================
.text$mn:00005168
.text$mn:00005168 ; Segment type: Pure code
.text$mn:00005168 ; Segment permissions: Read/Execute
.text$mn:00005168 _text$mn        segment para public 'CODE' use32
.text$mn:00005168                 assume cs:_text$mn
.text$mn:00005168                 ;org 5168h
.text$mn:00005168 ; COMDAT (pick any)
.text$mn:00005168                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005168
.text$mn:00005168 ; =============== S U B R O U T I N E =======================================
.text$mn:00005168
.text$mn:00005168 ; Attributes: bp-based frame
.text$mn:00005168
.text$mn:00005168 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00005168                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005168 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00005168                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00005168                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00005168
.text$mn:00005168 var_10          = dword ptr -10h
.text$mn:00005168 var_C           = dword ptr -0Ch
.text$mn:00005168 var_4           = dword ptr -4
.text$mn:00005168
.text$mn:00005168                 push    ebp
.text$mn:00005169                 mov     ebp, esp
.text$mn:0000516B                 push    0FFFFFFFFh
.text$mn:0000516D                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00005172                 mov     eax, large fs:0
.text$mn:00005178                 push    eax
.text$mn:00005179                 push    ecx
.text$mn:0000517A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000517F                 xor     eax, ebp
.text$mn:00005181                 push    eax
.text$mn:00005182                 lea     eax, [ebp+var_C]
.text$mn:00005185                 mov     large fs:0, eax
.text$mn:0000518B                 mov     [ebp+var_10], ecx
.text$mn:0000518E                 mov     [ebp+var_4], 0
.text$mn:00005195                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000519C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000519F                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000051A4                 mov     ecx, [ebp+var_C]
.text$mn:000051A7                 mov     large fs:0, ecx
.text$mn:000051AE                 pop     ecx
.text$mn:000051AF                 mov     esp, ebp
.text$mn:000051B1                 pop     ebp
.text$mn:000051B2                 retn
.text$mn:000051B2 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000051B2
.text$mn:000051B2 ; ---------------------------------------------------------------------------
.text$mn:000051B3                 align 4
.text$mn:000051B3 _text$mn        ends
.text$mn:000051B3
.text$x:000051B4 ; ===========================================================================
.text$x:000051B4
.text$x:000051B4 ; Segment type: Pure code
.text$x:000051B4 ; Segment permissions: Read/Execute
.text$x:000051B4 _text$x         segment para public 'CODE' use32
.text$x:000051B4                 assume cs:_text$x
.text$x:000051B4                 ;org 51B4h
.text$x:000051B4 ; COMDAT (pick associative to section at 5168)
.text$x:000051B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000051B4
.text$x:000051B4 ; =============== S U B R O U T I N E =======================================
.text$x:000051B4
.text$x:000051B4
.text$x:000051B4 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000051B4                                         ; DATA XREF: .xdata$x:00008FC4o
.text$x:000051B4                 mov     ecx, [ebp-10h]  ; this
.text$x:000051B7                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000051B7 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000051B7
.text$x:000051BC
.text$x:000051BC ; =============== S U B R O U T I N E =======================================
.text$x:000051BC
.text$x:000051BC
.text$x:000051BC __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000051BC                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000051BC
.text$x:000051BC arg_4           = dword ptr  8
.text$x:000051BC
.text$x:000051BC                 mov     edx, [esp+arg_4]
.text$x:000051C0                 lea     eax, [edx+0Ch]
.text$x:000051C3                 mov     ecx, [edx-8]
.text$x:000051C6                 xor     ecx, eax
.text$x:000051C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000051CD                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000051D2                 jmp     ___CxxFrameHandler3
.text$x:000051D2 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000051D2
.text$x:000051D2 ; ---------------------------------------------------------------------------
.text$x:000051D7                 align 4
.text$x:000051D7 _text$x         ends
.text$x:000051D7
.text$mn:000051D8 ; ===========================================================================
.text$mn:000051D8
.text$mn:000051D8 ; Segment type: Pure code
.text$mn:000051D8 ; Segment permissions: Read/Execute
.text$mn:000051D8 _text$mn        segment para public 'CODE' use32
.text$mn:000051D8                 assume cs:_text$mn
.text$mn:000051D8                 ;org 51D8h
.text$mn:000051D8 ; COMDAT (pick any)
.text$mn:000051D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000051D8
.text$mn:000051D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000051D8
.text$mn:000051D8 ; Attributes: bp-based frame
.text$mn:000051D8
.text$mn:000051D8 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>::~_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>(void)
.text$mn:000051D8                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
.text$mn:000051D8 ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000051D8                                         ; CODE XREF: __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z$0+3j
.text$mn:000051D8                                         ; __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$2+3j ...
.text$mn:000051D8
.text$mn:000051D8 var_10          = dword ptr -10h
.text$mn:000051D8 var_C           = dword ptr -0Ch
.text$mn:000051D8 var_4           = dword ptr -4
.text$mn:000051D8
.text$mn:000051D8                 push    ebp
.text$mn:000051D9                 mov     ebp, esp
.text$mn:000051DB                 push    0FFFFFFFFh
.text$mn:000051DD                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
.text$mn:000051E2                 mov     eax, large fs:0
.text$mn:000051E8                 push    eax
.text$mn:000051E9                 push    ecx
.text$mn:000051EA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000051EF                 xor     eax, ebp
.text$mn:000051F1                 push    eax
.text$mn:000051F2                 lea     eax, [ebp+var_C]
.text$mn:000051F5                 mov     large fs:0, eax
.text$mn:000051FB                 mov     [ebp+var_10], ecx
.text$mn:000051FE                 mov     [ebp+var_4], 0
.text$mn:00005205                 mov     ecx, [ebp+var_10]
.text$mn:00005208                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Free_proxy(void)
.text$mn:0000520D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005214                 mov     ecx, [ebp+var_10]
.text$mn:00005217                 call    ??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uchar>>::~_Vector_val<std::_Simple_types<uchar>>(void)
.text$mn:0000521C                 mov     ecx, [ebp+var_C]
.text$mn:0000521F                 mov     large fs:0, ecx
.text$mn:00005226                 pop     ecx
.text$mn:00005227                 mov     esp, ebp
.text$mn:00005229                 pop     ebp
.text$mn:0000522A                 retn
.text$mn:0000522A ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000522A
.text$mn:0000522A ; ---------------------------------------------------------------------------
.text$mn:0000522B                 align 4
.text$mn:0000522B _text$mn        ends
.text$mn:0000522B
.text$x:0000522C ; ===========================================================================
.text$x:0000522C
.text$x:0000522C ; Segment type: Pure code
.text$x:0000522C ; Segment permissions: Read/Execute
.text$x:0000522C _text$x         segment para public 'CODE' use32
.text$x:0000522C                 assume cs:_text$x
.text$x:0000522C                 ;org 522Ch
.text$x:0000522C ; COMDAT (pick associative to section at 51D8)
.text$x:0000522C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000522C
.text$x:0000522C ; =============== S U B R O U T I N E =======================================
.text$x:0000522C
.text$x:0000522C
.text$x:0000522C __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000522C                                         ; DATA XREF: .xdata$x:000096F0o
.text$x:0000522C                 mov     ecx, [ebp-10h]
.text$x:0000522F                 jmp     ??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<uchar>>::~_Vector_val<std::_Simple_types<uchar>>(void)
.text$x:0000522F __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000522F
.text$x:00005234
.text$x:00005234 ; =============== S U B R O U T I N E =======================================
.text$x:00005234
.text$x:00005234
.text$x:00005234 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005234                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)+5o
.text$x:00005234
.text$x:00005234 arg_4           = dword ptr  8
.text$x:00005234
.text$x:00005234                 mov     edx, [esp+arg_4]
.text$x:00005238                 lea     eax, [edx+0Ch]
.text$x:0000523B                 mov     ecx, [edx-8]
.text$x:0000523E                 xor     ecx, eax
.text$x:00005240                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005245                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
.text$x:0000524A                 jmp     ___CxxFrameHandler3
.text$x:0000524A __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ endp
.text$x:0000524A
.text$x:0000524A ; ---------------------------------------------------------------------------
.text$x:0000524F                 align 10h
.text$x:0000524F _text$x         ends
.text$x:0000524F
.text$mn:00005250 ; ===========================================================================
.text$mn:00005250
.text$mn:00005250 ; Segment type: Pure code
.text$mn:00005250 ; Segment permissions: Read/Execute
.text$mn:00005250 _text$mn        segment para public 'CODE' use32
.text$mn:00005250                 assume cs:_text$mn
.text$mn:00005250                 ;org 5250h
.text$mn:00005250 ; COMDAT (pick any)
.text$mn:00005250                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005250
.text$mn:00005250 ; =============== S U B R O U T I N E =======================================
.text$mn:00005250
.text$mn:00005250 ; Attributes: bp-based frame
.text$mn:00005250
.text$mn:00005250 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>(void)
.text$mn:00005250                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.text$mn:00005250 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005250                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)+9Bp
.text$mn:00005250                                         ; std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)+AAp ...
.text$mn:00005250
.text$mn:00005250 var_10          = dword ptr -10h
.text$mn:00005250 var_C           = dword ptr -0Ch
.text$mn:00005250 var_4           = dword ptr -4
.text$mn:00005250
.text$mn:00005250                 push    ebp
.text$mn:00005251                 mov     ebp, esp
.text$mn:00005253                 push    0FFFFFFFFh
.text$mn:00005255                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.text$mn:0000525A                 mov     eax, large fs:0
.text$mn:00005260                 push    eax
.text$mn:00005261                 push    ecx
.text$mn:00005262                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005267                 xor     eax, ebp
.text$mn:00005269                 push    eax
.text$mn:0000526A                 lea     eax, [ebp+var_C]
.text$mn:0000526D                 mov     large fs:0, eax
.text$mn:00005273                 mov     [ebp+var_10], ecx
.text$mn:00005276                 mov     [ebp+var_4], 0
.text$mn:0000527D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005284                 mov     ecx, [ebp+var_10]
.text$mn:00005287                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)
.text$mn:0000528C                 mov     ecx, [ebp+var_C]
.text$mn:0000528F                 mov     large fs:0, ecx
.text$mn:00005296                 pop     ecx
.text$mn:00005297                 mov     esp, ebp
.text$mn:00005299                 pop     ebp
.text$mn:0000529A                 retn
.text$mn:0000529A ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000529A
.text$mn:0000529A ; ---------------------------------------------------------------------------
.text$mn:0000529B                 align 4
.text$mn:0000529B _text$mn        ends
.text$mn:0000529B
.text$x:0000529C ; ===========================================================================
.text$x:0000529C
.text$x:0000529C ; Segment type: Pure code
.text$x:0000529C ; Segment permissions: Read/Execute
.text$x:0000529C _text$x         segment para public 'CODE' use32
.text$x:0000529C                 assume cs:_text$x
.text$x:0000529C                 ;org 529Ch
.text$x:0000529C ; COMDAT (pick associative to section at 5250)
.text$x:0000529C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000529C
.text$x:0000529C ; =============== S U B R O U T I N E =======================================
.text$x:0000529C
.text$x:0000529C
.text$x:0000529C __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000529C                                         ; DATA XREF: .xdata$x:00009C50o
.text$x:0000529C                 mov     ecx, [ebp-10h]
.text$x:0000529F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,uchar,int,uchar const *,uchar const &,std::_Iterator_base12>(void)
.text$x:0000529F __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000529F
.text$x:000052A4
.text$x:000052A4 ; =============== S U B R O U T I N E =======================================
.text$x:000052A4
.text$x:000052A4
.text$x:000052A4 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ proc near
.text$x:000052A4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)+5o
.text$x:000052A4
.text$x:000052A4 arg_4           = dword ptr  8
.text$x:000052A4
.text$x:000052A4                 mov     edx, [esp+arg_4]
.text$x:000052A8                 lea     eax, [edx+0Ch]
.text$x:000052AB                 mov     ecx, [edx-8]
.text$x:000052AE                 xor     ecx, eax
.text$x:000052B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000052B5                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.text$x:000052BA                 jmp     ___CxxFrameHandler3
.text$x:000052BA __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ endp
.text$x:000052BA
.text$x:000052BA ; ---------------------------------------------------------------------------
.text$x:000052BF                 align 10h
.text$x:000052BF _text$x         ends
.text$x:000052BF
.text$mn:000052C0 ; ===========================================================================
.text$mn:000052C0
.text$mn:000052C0 ; Segment type: Pure code
.text$mn:000052C0 ; Segment permissions: Read/Execute
.text$mn:000052C0 _text$mn        segment para public 'CODE' use32
.text$mn:000052C0                 assume cs:_text$mn
.text$mn:000052C0                 ;org 52C0h
.text$mn:000052C0 ; COMDAT (pick any)
.text$mn:000052C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000052C0
.text$mn:000052C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000052C0
.text$mn:000052C0 ; Attributes: bp-based frame
.text$mn:000052C0
.text$mn:000052C0 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>(void)
.text$mn:000052C0                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000052C0 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000052C0                                         ; CODE XREF: __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$4+3j
.text$mn:000052C0                                         ; __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$7+3j ...
.text$mn:000052C0
.text$mn:000052C0 var_10          = dword ptr -10h
.text$mn:000052C0 var_C           = dword ptr -0Ch
.text$mn:000052C0 var_4           = dword ptr -4
.text$mn:000052C0
.text$mn:000052C0                 push    ebp
.text$mn:000052C1                 mov     ebp, esp
.text$mn:000052C3                 push    0FFFFFFFFh
.text$mn:000052C5                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000052CA                 mov     eax, large fs:0
.text$mn:000052D0                 push    eax
.text$mn:000052D1                 push    ecx
.text$mn:000052D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000052D7                 xor     eax, ebp
.text$mn:000052D9                 push    eax
.text$mn:000052DA                 lea     eax, [ebp+var_C]
.text$mn:000052DD                 mov     large fs:0, eax
.text$mn:000052E3                 mov     [ebp+var_10], ecx
.text$mn:000052E6                 mov     [ebp+var_4], 0
.text$mn:000052ED                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000052F4                 mov     ecx, [ebp+var_10]
.text$mn:000052F7                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)
.text$mn:000052FC                 mov     ecx, [ebp+var_C]
.text$mn:000052FF                 mov     large fs:0, ecx
.text$mn:00005306                 pop     ecx
.text$mn:00005307                 mov     esp, ebp
.text$mn:00005309                 pop     ebp
.text$mn:0000530A                 retn
.text$mn:0000530A ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000530A
.text$mn:0000530A ; ---------------------------------------------------------------------------
.text$mn:0000530B                 align 4
.text$mn:0000530B _text$mn        ends
.text$mn:0000530B
.text$x:0000530C ; ===========================================================================
.text$x:0000530C
.text$x:0000530C ; Segment type: Pure code
.text$x:0000530C ; Segment permissions: Read/Execute
.text$x:0000530C _text$x         segment para public 'CODE' use32
.text$x:0000530C                 assume cs:_text$x
.text$x:0000530C                 ;org 530Ch
.text$x:0000530C ; COMDAT (pick associative to section at 52C0)
.text$x:0000530C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000530C
.text$x:0000530C ; =============== S U B R O U T I N E =======================================
.text$x:0000530C
.text$x:0000530C
.text$x:0000530C __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000530C                                         ; DATA XREF: .xdata$x:00009A90o
.text$x:0000530C                 mov     ecx, [ebp-10h]
.text$x:0000530F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,std::vector<uchar,std::allocator<uchar>>,int,std::vector<uchar,std::allocator<uchar>> const *,std::vector<uchar,std::allocator<uchar>> const &,std::_Iterator_base12>(void)
.text$x:0000530F __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000530F
.text$x:00005314
.text$x:00005314 ; =============== S U B R O U T I N E =======================================
.text$x:00005314
.text$x:00005314
.text$x:00005314 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005314                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)+5o
.text$x:00005314
.text$x:00005314 arg_4           = dword ptr  8
.text$x:00005314
.text$x:00005314                 mov     edx, [esp+arg_4]
.text$x:00005318                 lea     eax, [edx+0Ch]
.text$x:0000531B                 mov     ecx, [edx-8]
.text$x:0000531E                 xor     ecx, eax
.text$x:00005320                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005325                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:0000532A                 jmp     ___CxxFrameHandler3
.text$x:0000532A __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000532A
.text$x:0000532A ; ---------------------------------------------------------------------------
.text$x:0000532F                 align 10h
.text$x:0000532F _text$x         ends
.text$x:0000532F
.text$mn:00005330 ; ===========================================================================
.text$mn:00005330
.text$mn:00005330 ; Segment type: Pure code
.text$mn:00005330 ; Segment permissions: Read/Execute
.text$mn:00005330 _text$mn        segment para public 'CODE' use32
.text$mn:00005330                 assume cs:_text$mn
.text$mn:00005330                 ;org 5330h
.text$mn:00005330 ; COMDAT (pick any)
.text$mn:00005330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005330
.text$mn:00005330 ; =============== S U B R O U T I N E =======================================
.text$mn:00005330
.text$mn:00005330 ; Attributes: bp-based frame
.text$mn:00005330
.text$mn:00005330 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>(void)
.text$mn:00005330                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.text$mn:00005330 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00005330                                         ; CODE XREF: std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+70p
.text$mn:00005330                                         ; std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+7Fp ...
.text$mn:00005330
.text$mn:00005330 var_10          = dword ptr -10h
.text$mn:00005330 var_C           = dword ptr -0Ch
.text$mn:00005330 var_4           = dword ptr -4
.text$mn:00005330
.text$mn:00005330                 push    ebp
.text$mn:00005331                 mov     ebp, esp
.text$mn:00005333                 push    0FFFFFFFFh
.text$mn:00005335                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.text$mn:0000533A                 mov     eax, large fs:0
.text$mn:00005340                 push    eax
.text$mn:00005341                 push    ecx
.text$mn:00005342                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005347                 xor     eax, ebp
.text$mn:00005349                 push    eax
.text$mn:0000534A                 lea     eax, [ebp+var_C]
.text$mn:0000534D                 mov     large fs:0, eax
.text$mn:00005353                 mov     [ebp+var_10], ecx
.text$mn:00005356                 mov     [ebp+var_4], 0
.text$mn:0000535D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005364                 mov     ecx, [ebp+var_10]
.text$mn:00005367                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:0000536C                 mov     ecx, [ebp+var_C]
.text$mn:0000536F                 mov     large fs:0, ecx
.text$mn:00005376                 pop     ecx
.text$mn:00005377                 mov     esp, ebp
.text$mn:00005379                 pop     ebp
.text$mn:0000537A                 retn
.text$mn:0000537A ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000537A
.text$mn:0000537A ; ---------------------------------------------------------------------------
.text$mn:0000537B                 align 4
.text$mn:0000537B _text$mn        ends
.text$mn:0000537B
.text$x:0000537C ; ===========================================================================
.text$x:0000537C
.text$x:0000537C ; Segment type: Pure code
.text$x:0000537C ; Segment permissions: Read/Execute
.text$x:0000537C _text$x         segment para public 'CODE' use32
.text$x:0000537C                 assume cs:_text$x
.text$x:0000537C                 ;org 537Ch
.text$x:0000537C ; COMDAT (pick associative to section at 5330)
.text$x:0000537C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000537C
.text$x:0000537C ; =============== S U B R O U T I N E =======================================
.text$x:0000537C
.text$x:0000537C
.text$x:0000537C __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:0000537C                                         ; DATA XREF: .xdata$x:00009E64o
.text$x:0000537C                 mov     ecx, [ebp-10h]
.text$x:0000537F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:0000537F __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000537F
.text$x:00005384
.text$x:00005384 ; =============== S U B R O U T I N E =======================================
.text$x:00005384
.text$x:00005384
.text$x:00005384 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005384                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)+5o
.text$x:00005384
.text$x:00005384 arg_4           = dword ptr  8
.text$x:00005384
.text$x:00005384                 mov     edx, [esp+arg_4]
.text$x:00005388                 lea     eax, [edx+0Ch]
.text$x:0000538B                 mov     ecx, [edx-8]
.text$x:0000538E                 xor     ecx, eax
.text$x:00005390                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005395                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.text$x:0000539A                 jmp     ___CxxFrameHandler3
.text$x:0000539A __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ endp
.text$x:0000539A
.text$x:0000539A ; ---------------------------------------------------------------------------
.text$x:0000539F                 align 10h
.text$x:0000539F _text$x         ends
.text$x:0000539F
.text$mn:000053A0 ; ===========================================================================
.text$mn:000053A0
.text$mn:000053A0 ; Segment type: Pure code
.text$mn:000053A0 ; Segment permissions: Read/Execute
.text$mn:000053A0 _text$mn        segment para public 'CODE' use32
.text$mn:000053A0                 assume cs:_text$mn
.text$mn:000053A0                 ;org 53A0h
.text$mn:000053A0 ; COMDAT (pick any)
.text$mn:000053A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000053A0
.text$mn:000053A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000053A0
.text$mn:000053A0 ; Attributes: bp-based frame
.text$mn:000053A0
.text$mn:000053A0 ; public: __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>::~_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>(void)
.text$mn:000053A0                 public ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000053A0 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000053A0                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+105p
.text$mn:000053A0                                         ; ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+114p ...
.text$mn:000053A0
.text$mn:000053A0 var_10          = dword ptr -10h
.text$mn:000053A0 var_C           = dword ptr -0Ch
.text$mn:000053A0 var_4           = dword ptr -4
.text$mn:000053A0
.text$mn:000053A0                 push    ebp
.text$mn:000053A1                 mov     ebp, esp
.text$mn:000053A3                 push    0FFFFFFFFh
.text$mn:000053A5                 push    offset __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000053AA                 mov     eax, large fs:0
.text$mn:000053B0                 push    eax
.text$mn:000053B1                 push    ecx
.text$mn:000053B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000053B7                 xor     eax, ebp
.text$mn:000053B9                 push    eax
.text$mn:000053BA                 lea     eax, [ebp+var_C]
.text$mn:000053BD                 mov     large fs:0, eax
.text$mn:000053C3                 mov     [ebp+var_10], ecx
.text$mn:000053C6                 mov     [ebp+var_4], 0
.text$mn:000053CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000053D4                 mov     ecx, [ebp+var_10]
.text$mn:000053D7                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:000053DC                 mov     ecx, [ebp+var_C]
.text$mn:000053DF                 mov     large fs:0, ecx
.text$mn:000053E6                 pop     ecx
.text$mn:000053E7                 mov     esp, ebp
.text$mn:000053E9                 pop     ebp
.text$mn:000053EA                 retn
.text$mn:000053EA ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000053EA
.text$mn:000053EA ; ---------------------------------------------------------------------------
.text$mn:000053EB                 align 4
.text$mn:000053EB _text$mn        ends
.text$mn:000053EB
.text$x:000053EC ; ===========================================================================
.text$x:000053EC
.text$x:000053EC ; Segment type: Pure code
.text$x:000053EC ; Segment permissions: Read/Execute
.text$x:000053EC _text$x         segment para public 'CODE' use32
.text$x:000053EC                 assume cs:_text$x
.text$x:000053EC                 ;org 53ECh
.text$x:000053EC ; COMDAT (pick associative to section at 53A0)
.text$x:000053EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000053EC
.text$x:000053EC ; =============== S U B R O U T I N E =======================================
.text$x:000053EC
.text$x:000053EC
.text$x:000053EC __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000053EC                                         ; DATA XREF: .xdata$x:00009B48o
.text$x:000053EC                 mov     ecx, [ebp-10h]
.text$x:000053EF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000053EF __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000053EF
.text$x:000053F4
.text$x:000053F4 ; =============== S U B R O U T I N E =======================================
.text$x:000053F4
.text$x:000053F4
.text$x:000053F4 __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000053F4                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)+5o
.text$x:000053F4
.text$x:000053F4 arg_4           = dword ptr  8
.text$x:000053F4
.text$x:000053F4                 mov     edx, [esp+arg_4]
.text$x:000053F8                 lea     eax, [edx+0Ch]
.text$x:000053FB                 mov     ecx, [edx-8]
.text$x:000053FE                 xor     ecx, eax
.text$x:00005400                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005405                 mov     eax, offset __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.text$x:0000540A                 jmp     ___CxxFrameHandler3
.text$x:0000540A __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000540A
.text$x:0000540A ; ---------------------------------------------------------------------------
.text$x:0000540F                 align 10h
.text$x:0000540F _text$x         ends
.text$x:0000540F
.text$mn:00005410 ; ===========================================================================
.text$mn:00005410
.text$mn:00005410 ; Segment type: Pure code
.text$mn:00005410 ; Segment permissions: Read/Execute
.text$mn:00005410 _text$mn        segment para public 'CODE' use32
.text$mn:00005410                 assume cs:_text$mn
.text$mn:00005410                 ;org 5410h
.text$mn:00005410 ; COMDAT (pick any)
.text$mn:00005410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005410
.text$mn:00005410 ; =============== S U B R O U T I N E =======================================
.text$mn:00005410
.text$mn:00005410 ; Attributes: bp-based frame
.text$mn:00005410
.text$mn:00005410 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<unsigned char>>::~_Vector_val<struct std::_Simple_types<unsigned char>>(void)
.text$mn:00005410                 public ??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.text$mn:00005410 ??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ proc near
.text$mn:00005410                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z$0+3j
.text$mn:00005410                                         ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)+3Fp ...
.text$mn:00005410
.text$mn:00005410 var_10          = dword ptr -10h
.text$mn:00005410 var_C           = dword ptr -0Ch
.text$mn:00005410 var_4           = dword ptr -4
.text$mn:00005410
.text$mn:00005410                 push    ebp
.text$mn:00005411                 mov     ebp, esp
.text$mn:00005413                 push    0FFFFFFFFh
.text$mn:00005415                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.text$mn:0000541A                 mov     eax, large fs:0
.text$mn:00005420                 push    eax
.text$mn:00005421                 push    ecx
.text$mn:00005422                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005427                 xor     eax, ebp
.text$mn:00005429                 push    eax
.text$mn:0000542A                 lea     eax, [ebp+var_C]
.text$mn:0000542D                 mov     large fs:0, eax
.text$mn:00005433                 mov     [ebp+var_10], ecx
.text$mn:00005436                 mov     [ebp+var_4], 0
.text$mn:0000543D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005444                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005447                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:0000544C                 mov     ecx, [ebp+var_C]
.text$mn:0000544F                 mov     large fs:0, ecx
.text$mn:00005456                 pop     ecx
.text$mn:00005457                 mov     esp, ebp
.text$mn:00005459                 pop     ebp
.text$mn:0000545A                 retn
.text$mn:0000545A ??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ endp
.text$mn:0000545A
.text$mn:0000545A ; ---------------------------------------------------------------------------
.text$mn:0000545B                 align 4
.text$mn:0000545B _text$mn        ends
.text$mn:0000545B
.text$x:0000545C ; ===========================================================================
.text$x:0000545C
.text$x:0000545C ; Segment type: Pure code
.text$x:0000545C ; Segment permissions: Read/Execute
.text$x:0000545C _text$x         segment para public 'CODE' use32
.text$x:0000545C                 assume cs:_text$x
.text$x:0000545C                 ;org 545Ch
.text$x:0000545C ; COMDAT (pick associative to section at 5410)
.text$x:0000545C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000545C
.text$x:0000545C ; =============== S U B R O U T I N E =======================================
.text$x:0000545C
.text$x:0000545C
.text$x:0000545C __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ$0 proc near
.text$x:0000545C                                         ; DATA XREF: .xdata$x:00009698o
.text$x:0000545C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000545F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000545F __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ$0 endp
.text$x:0000545F
.text$x:00005464
.text$x:00005464 ; =============== S U B R O U T I N E =======================================
.text$x:00005464
.text$x:00005464
.text$x:00005464 __ehhandler$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ proc near
.text$x:00005464                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<uchar>>::~_Vector_val<std::_Simple_types<uchar>>(void)+5o
.text$x:00005464
.text$x:00005464 arg_4           = dword ptr  8
.text$x:00005464
.text$x:00005464                 mov     edx, [esp+arg_4]
.text$x:00005468                 lea     eax, [edx+0Ch]
.text$x:0000546B                 mov     ecx, [edx-8]
.text$x:0000546E                 xor     ecx, eax
.text$x:00005470                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005475                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.text$x:0000547A                 jmp     ___CxxFrameHandler3
.text$x:0000547A __ehhandler$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ endp
.text$x:0000547A
.text$x:0000547A ; ---------------------------------------------------------------------------
.text$x:0000547F                 align 10h
.text$x:0000547F _text$x         ends
.text$x:0000547F
.text$mn:00005480 ; ===========================================================================
.text$mn:00005480
.text$mn:00005480 ; Segment type: Pure code
.text$mn:00005480 ; Segment permissions: Read/Execute
.text$mn:00005480 _text$mn        segment para public 'CODE' use32
.text$mn:00005480                 assume cs:_text$mn
.text$mn:00005480                 ;org 5480h
.text$mn:00005480 ; COMDAT (pick any)
.text$mn:00005480                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005480
.text$mn:00005480 ; =============== S U B R O U T I N E =======================================
.text$mn:00005480
.text$mn:00005480 ; Attributes: bp-based frame
.text$mn:00005480
.text$mn:00005480 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00005480                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00005480 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00005480                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00005480                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00005480
.text$mn:00005480 var_10          = dword ptr -10h
.text$mn:00005480 var_C           = dword ptr -0Ch
.text$mn:00005480 var_4           = dword ptr -4
.text$mn:00005480
.text$mn:00005480                 push    ebp
.text$mn:00005481                 mov     ebp, esp
.text$mn:00005483                 push    0FFFFFFFFh
.text$mn:00005485                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000548A                 mov     eax, large fs:0
.text$mn:00005490                 push    eax
.text$mn:00005491                 push    ecx
.text$mn:00005492                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005497                 xor     eax, ebp
.text$mn:00005499                 push    eax
.text$mn:0000549A                 lea     eax, [ebp+var_C]
.text$mn:0000549D                 mov     large fs:0, eax
.text$mn:000054A3                 mov     [ebp+var_10], ecx
.text$mn:000054A6                 mov     [ebp+var_4], 0
.text$mn:000054AD                 push    0               ; Size
.text$mn:000054AF                 push    1               ; char
.text$mn:000054B1                 mov     ecx, [ebp+var_10]
.text$mn:000054B4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000054B9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000054C0                 mov     ecx, [ebp+var_10]
.text$mn:000054C3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:000054C8                 mov     ecx, [ebp+var_C]
.text$mn:000054CB                 mov     large fs:0, ecx
.text$mn:000054D2                 pop     ecx
.text$mn:000054D3                 mov     esp, ebp
.text$mn:000054D5                 pop     ebp
.text$mn:000054D6                 retn
.text$mn:000054D6 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:000054D6
.text$mn:000054D6 ; ---------------------------------------------------------------------------
.text$mn:000054D7                 align 4
.text$mn:000054D7 _text$mn        ends
.text$mn:000054D7
.text$x:000054D8 ; ===========================================================================
.text$x:000054D8
.text$x:000054D8 ; Segment type: Pure code
.text$x:000054D8 ; Segment permissions: Read/Execute
.text$x:000054D8 _text$x         segment para public 'CODE' use32
.text$x:000054D8                 assume cs:_text$x
.text$x:000054D8                 ;org 54D8h
.text$x:000054D8 ; COMDAT (pick associative to section at 5480)
.text$x:000054D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000054D8
.text$x:000054D8 ; =============== S U B R O U T I N E =======================================
.text$x:000054D8
.text$x:000054D8
.text$x:000054D8 __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:000054D8                                         ; DATA XREF: .xdata$x:00009074o
.text$x:000054D8                 mov     ecx, [ebp-10h]
.text$x:000054DB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:000054DB __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:000054DB
.text$x:000054E0
.text$x:000054E0 ; =============== S U B R O U T I N E =======================================
.text$x:000054E0
.text$x:000054E0
.text$x:000054E0 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000054E0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000054E0
.text$x:000054E0 arg_4           = dword ptr  8
.text$x:000054E0
.text$x:000054E0                 mov     edx, [esp+arg_4]
.text$x:000054E4                 lea     eax, [edx+0Ch]
.text$x:000054E7                 mov     ecx, [edx-8]
.text$x:000054EA                 xor     ecx, eax
.text$x:000054EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000054F1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000054F6                 jmp     ___CxxFrameHandler3
.text$x:000054F6 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000054F6
.text$x:000054F6 ; ---------------------------------------------------------------------------
.text$x:000054FB                 align 4
.text$x:000054FB _text$x         ends
.text$x:000054FB
.text$mn:000054FC ; ===========================================================================
.text$mn:000054FC
.text$mn:000054FC ; Segment type: Pure code
.text$mn:000054FC ; Segment permissions: Read/Execute
.text$mn:000054FC _text$mn        segment para public 'CODE' use32
.text$mn:000054FC                 assume cs:_text$mn
.text$mn:000054FC                 ;org 54FCh
.text$mn:000054FC ; COMDAT (pick any)
.text$mn:000054FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000054FC
.text$mn:000054FC ; =============== S U B R O U T I N E =======================================
.text$mn:000054FC
.text$mn:000054FC ; Attributes: bp-based frame
.text$mn:000054FC
.text$mn:000054FC ; public: __thiscall std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>::~move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>(void)
.text$mn:000054FC                 public ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:000054FC ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000054FC                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+98p
.text$mn:000054FC                                         ; std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)+A7p ...
.text$mn:000054FC
.text$mn:000054FC var_10          = dword ptr -10h
.text$mn:000054FC var_C           = dword ptr -0Ch
.text$mn:000054FC var_4           = dword ptr -4
.text$mn:000054FC
.text$mn:000054FC                 push    ebp
.text$mn:000054FD                 mov     ebp, esp
.text$mn:000054FF                 push    0FFFFFFFFh
.text$mn:00005501                 push    offset __ehhandler$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ
.text$mn:00005506                 mov     eax, large fs:0
.text$mn:0000550C                 push    eax
.text$mn:0000550D                 push    ecx
.text$mn:0000550E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005513                 xor     eax, ebp
.text$mn:00005515                 push    eax
.text$mn:00005516                 lea     eax, [ebp+var_C]
.text$mn:00005519                 mov     large fs:0, eax
.text$mn:0000551F                 mov     [ebp+var_10], ecx
.text$mn:00005522                 mov     [ebp+var_4], 0
.text$mn:00005529                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005530                 mov     ecx, [ebp+var_10]
.text$mn:00005533                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$mn:00005538                 mov     ecx, [ebp+var_C]
.text$mn:0000553B                 mov     large fs:0, ecx
.text$mn:00005542                 pop     ecx
.text$mn:00005543                 mov     esp, ebp
.text$mn:00005545                 pop     ebp
.text$mn:00005546                 retn
.text$mn:00005546 ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:00005546
.text$mn:00005546 ; ---------------------------------------------------------------------------
.text$mn:00005547                 align 4
.text$mn:00005547 _text$mn        ends
.text$mn:00005547
.text$x:00005548 ; ===========================================================================
.text$x:00005548
.text$x:00005548 ; Segment type: Pure code
.text$x:00005548 ; Segment permissions: Read/Execute
.text$x:00005548 _text$x         segment para public 'CODE' use32
.text$x:00005548                 assume cs:_text$x
.text$x:00005548                 ;org 5548h
.text$x:00005548 ; COMDAT (pick associative to section at 54FC)
.text$x:00005548                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005548
.text$x:00005548 ; =============== S U B R O U T I N E =======================================
.text$x:00005548
.text$x:00005548
.text$x:00005548 __unwindfunclet$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00005548                                         ; DATA XREF: .xdata$x:00009F60o
.text$x:00005548                 mov     ecx, [ebp-10h]
.text$x:0000554B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:0000554B __unwindfunclet$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000554B
.text$x:00005550
.text$x:00005550 ; =============== S U B R O U T I N E =======================================
.text$x:00005550
.text$x:00005550
.text$x:00005550 __ehhandler$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00005550                                         ; DATA XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)+5o
.text$x:00005550
.text$x:00005550 arg_4           = dword ptr  8
.text$x:00005550
.text$x:00005550                 mov     edx, [esp+arg_4]
.text$x:00005554                 lea     eax, [edx+0Ch]
.text$x:00005557                 mov     ecx, [edx-8]
.text$x:0000555A                 xor     ecx, eax
.text$x:0000555C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005561                 mov     eax, offset __ehfuncinfo$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ
.text$x:00005566                 jmp     ___CxxFrameHandler3
.text$x:00005566 __ehhandler$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ endp
.text$x:00005566
.text$x:00005566 ; ---------------------------------------------------------------------------
.text$x:0000556B                 align 4
.text$x:0000556B _text$x         ends
.text$x:0000556B
.text$mn:0000556C ; ===========================================================================
.text$mn:0000556C
.text$mn:0000556C ; Segment type: Pure code
.text$mn:0000556C ; Segment permissions: Read/Execute
.text$mn:0000556C _text$mn        segment para public 'CODE' use32
.text$mn:0000556C                 assume cs:_text$mn
.text$mn:0000556C                 ;org 556Ch
.text$mn:0000556C ; COMDAT (pick any)
.text$mn:0000556C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000556C
.text$mn:0000556C ; =============== S U B R O U T I N E =======================================
.text$mn:0000556C
.text$mn:0000556C ; Attributes: bp-based frame
.text$mn:0000556C
.text$mn:0000556C ; public: __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::~vector<unsigned char, class std::allocator<unsigned char>>(void)
.text$mn:0000556C                 public ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.text$mn:0000556C ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ proc near
.text$mn:0000556C                                         ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+ADp
.text$mn:0000556C                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+1C3p ...
.text$mn:0000556C
.text$mn:0000556C var_10          = dword ptr -10h
.text$mn:0000556C var_C           = dword ptr -0Ch
.text$mn:0000556C var_4           = dword ptr -4
.text$mn:0000556C
.text$mn:0000556C                 push    ebp
.text$mn:0000556D                 mov     ebp, esp
.text$mn:0000556F                 push    0FFFFFFFFh
.text$mn:00005571                 push    offset __ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.text$mn:00005576                 mov     eax, large fs:0
.text$mn:0000557C                 push    eax
.text$mn:0000557D                 push    ecx
.text$mn:0000557E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005583                 xor     eax, ebp
.text$mn:00005585                 push    eax
.text$mn:00005586                 lea     eax, [ebp+var_C]
.text$mn:00005589                 mov     large fs:0, eax
.text$mn:0000558F                 mov     [ebp+var_10], ecx
.text$mn:00005592                 mov     [ebp+var_4], 0
.text$mn:00005599                 mov     ecx, [ebp+var_10]
.text$mn:0000559C                 call    ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Tidy(void)
.text$mn:000055A1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000055A8                 mov     ecx, [ebp+var_10]
.text$mn:000055AB                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)
.text$mn:000055B0                 mov     ecx, [ebp+var_C]
.text$mn:000055B3                 mov     large fs:0, ecx
.text$mn:000055BA                 pop     ecx
.text$mn:000055BB                 mov     esp, ebp
.text$mn:000055BD                 pop     ebp
.text$mn:000055BE                 retn
.text$mn:000055BE ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ endp
.text$mn:000055BE
.text$mn:000055BE ; ---------------------------------------------------------------------------
.text$mn:000055BF                 align 10h
.text$mn:000055BF _text$mn        ends
.text$mn:000055BF
.text$x:000055C0 ; ===========================================================================
.text$x:000055C0
.text$x:000055C0 ; Segment type: Pure code
.text$x:000055C0 ; Segment permissions: Read/Execute
.text$x:000055C0 _text$x         segment para public 'CODE' use32
.text$x:000055C0                 assume cs:_text$x
.text$x:000055C0                 ;org 55C0h
.text$x:000055C0 ; COMDAT (pick associative to section at 556C)
.text$x:000055C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000055C0
.text$x:000055C0 ; =============== S U B R O U T I N E =======================================
.text$x:000055C0
.text$x:000055C0
.text$x:000055C0 __unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0 proc near
.text$x:000055C0                                         ; DATA XREF: .xdata$x:00009828o
.text$x:000055C0                 mov     ecx, [ebp-10h]
.text$x:000055C3                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)
.text$x:000055C3 __unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0 endp
.text$x:000055C3
.text$x:000055C8
.text$x:000055C8 ; =============== S U B R O U T I N E =======================================
.text$x:000055C8
.text$x:000055C8
.text$x:000055C8 __ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ proc near
.text$x:000055C8                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)+5o
.text$x:000055C8
.text$x:000055C8 arg_4           = dword ptr  8
.text$x:000055C8
.text$x:000055C8                 mov     edx, [esp+arg_4]
.text$x:000055CC                 lea     eax, [edx+0Ch]
.text$x:000055CF                 mov     ecx, [edx-8]
.text$x:000055D2                 xor     ecx, eax
.text$x:000055D4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000055D9                 mov     eax, offset __ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.text$x:000055DE                 jmp     ___CxxFrameHandler3
.text$x:000055DE __ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ endp
.text$x:000055DE
.text$x:000055DE ; ---------------------------------------------------------------------------
.text$x:000055E3                 align 4
.text$x:000055E3 _text$x         ends
.text$x:000055E3
.text$mn:000055E4 ; ===========================================================================
.text$mn:000055E4
.text$mn:000055E4 ; Segment type: Pure code
.text$mn:000055E4 ; Segment permissions: Read/Execute
.text$mn:000055E4 _text$mn        segment para public 'CODE' use32
.text$mn:000055E4                 assume cs:_text$mn
.text$mn:000055E4                 ;org 55E4h
.text$mn:000055E4 ; COMDAT (pick any)
.text$mn:000055E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000055E4
.text$mn:000055E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000055E4
.text$mn:000055E4 ; Attributes: bp-based frame
.text$mn:000055E4
.text$mn:000055E4 ; _DWORD __thiscall ByteArray::~ByteArray(ByteArray *__hidden this)
.text$mn:000055E4                 public ??1ByteArray@@QAE@XZ
.text$mn:000055E4 ??1ByteArray@@QAE@XZ proc near          ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+389p
.text$mn:000055E4                                         ; __unwindfunclet$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z$1+3j ...
.text$mn:000055E4
.text$mn:000055E4 var_8           = dword ptr -8
.text$mn:000055E4 var_4           = dword ptr -4
.text$mn:000055E4
.text$mn:000055E4                 push    ebp
.text$mn:000055E5                 mov     ebp, esp
.text$mn:000055E7                 sub     esp, 8
.text$mn:000055EA                 mov     [ebp+var_4], ecx
.text$mn:000055ED                 mov     eax, [ebp+var_4]
.text$mn:000055F0                 cmp     dword ptr [eax], 0
.text$mn:000055F3                 jz      short loc_5609
.text$mn:000055F5                 mov     ecx, [ebp+var_4]
.text$mn:000055F8                 mov     edx, [ecx]
.text$mn:000055FA                 mov     [ebp+var_8], edx
.text$mn:000055FD                 mov     eax, [ebp+var_8]
.text$mn:00005600                 push    eax             ; void *
.text$mn:00005601                 call    ??_V@YAXPAX@Z   ; operator delete[](void *)
.text$mn:00005606                 add     esp, 4
.text$mn:00005609
.text$mn:00005609 loc_5609:                               ; CODE XREF: ByteArray::~ByteArray(void)+Fj
.text$mn:00005609                 mov     ecx, [ebp+var_4]
.text$mn:0000560C                 mov     dword ptr [ecx], 0
.text$mn:00005612                 mov     edx, [ebp+var_4]
.text$mn:00005615                 mov     dword ptr [edx+4], 0
.text$mn:0000561C                 mov     esp, ebp
.text$mn:0000561E                 pop     ebp
.text$mn:0000561F                 retn
.text$mn:0000561F ??1ByteArray@@QAE@XZ endp
.text$mn:0000561F
.text$mn:0000561F _text$mn        ends
.text$mn:0000561F
.text$mn:00005620 ; ===========================================================================
.text$mn:00005620
.text$mn:00005620 ; Segment type: Pure code
.text$mn:00005620 ; Segment permissions: Read/Execute
.text$mn:00005620 _text$mn        segment para public 'CODE' use32
.text$mn:00005620                 assume cs:_text$mn
.text$mn:00005620                 ;org 5620h
.text$mn:00005620 ; COMDAT (pick any)
.text$mn:00005620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005620
.text$mn:00005620 ; =============== S U B R O U T I N E =======================================
.text$mn:00005620
.text$mn:00005620 ; Attributes: bp-based frame
.text$mn:00005620
.text$mn:00005620 ; _DWORD __thiscall StringArray::~StringArray(StringArray *__hidden this)
.text$mn:00005620                 public ??1StringArray@@QAE@XZ
.text$mn:00005620 ??1StringArray@@QAE@XZ proc near        ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+21Bp
.text$mn:00005620                                         ; ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+135p ...
.text$mn:00005620
.text$mn:00005620 var_10          = dword ptr -10h
.text$mn:00005620 var_C           = dword ptr -0Ch
.text$mn:00005620 var_4           = dword ptr -4
.text$mn:00005620
.text$mn:00005620                 push    ebp
.text$mn:00005621                 mov     ebp, esp
.text$mn:00005623                 push    0FFFFFFFFh
.text$mn:00005625                 push    offset __ehhandler$??1StringArray@@QAE@XZ
.text$mn:0000562A                 mov     eax, large fs:0
.text$mn:00005630                 push    eax
.text$mn:00005631                 push    ecx
.text$mn:00005632                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005637                 xor     eax, ebp
.text$mn:00005639                 push    eax
.text$mn:0000563A                 lea     eax, [ebp+var_C]
.text$mn:0000563D                 mov     large fs:0, eax
.text$mn:00005643                 mov     [ebp+var_10], ecx
.text$mn:00005646                 mov     [ebp+var_4], 0
.text$mn:0000564D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005654                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005657                 call    ??1ByteArray@@QAE@XZ ; ByteArray::~ByteArray(void)
.text$mn:0000565C                 mov     ecx, [ebp+var_C]
.text$mn:0000565F                 mov     large fs:0, ecx
.text$mn:00005666                 pop     ecx
.text$mn:00005667                 mov     esp, ebp
.text$mn:00005669                 pop     ebp
.text$mn:0000566A                 retn
.text$mn:0000566A ??1StringArray@@QAE@XZ endp
.text$mn:0000566A
.text$mn:0000566A ; ---------------------------------------------------------------------------
.text$mn:0000566B                 align 4
.text$mn:0000566B _text$mn        ends
.text$mn:0000566B
.text$x:0000566C ; ===========================================================================
.text$x:0000566C
.text$x:0000566C ; Segment type: Pure code
.text$x:0000566C ; Segment permissions: Read/Execute
.text$x:0000566C _text$x         segment para public 'CODE' use32
.text$x:0000566C                 assume cs:_text$x
.text$x:0000566C                 ;org 566Ch
.text$x:0000566C ; COMDAT (pick associative to section at 5620)
.text$x:0000566C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000566C
.text$x:0000566C ; =============== S U B R O U T I N E =======================================
.text$x:0000566C
.text$x:0000566C
.text$x:0000566C __unwindfunclet$??1StringArray@@QAE@XZ$0 proc near
.text$x:0000566C                                         ; DATA XREF: .xdata$x:0000945Co
.text$x:0000566C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000566F                 jmp     ??1ByteArray@@QAE@XZ ; ByteArray::~ByteArray(void)
.text$x:0000566F __unwindfunclet$??1StringArray@@QAE@XZ$0 endp
.text$x:0000566F
.text$x:00005674
.text$x:00005674 ; =============== S U B R O U T I N E =======================================
.text$x:00005674
.text$x:00005674
.text$x:00005674 __ehhandler$??1StringArray@@QAE@XZ proc near
.text$x:00005674                                         ; DATA XREF: StringArray::~StringArray(void)+5o
.text$x:00005674
.text$x:00005674 arg_4           = dword ptr  8
.text$x:00005674
.text$x:00005674                 mov     edx, [esp+arg_4]
.text$x:00005678                 lea     eax, [edx+0Ch]
.text$x:0000567B                 mov     ecx, [edx-8]
.text$x:0000567E                 xor     ecx, eax
.text$x:00005680                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005685                 mov     eax, offset __ehfuncinfo$??1StringArray@@QAE@XZ
.text$x:0000568A                 jmp     ___CxxFrameHandler3
.text$x:0000568A __ehhandler$??1StringArray@@QAE@XZ endp
.text$x:0000568A
.text$x:0000568A ; ---------------------------------------------------------------------------
.text$x:0000568F                 align 10h
.text$x:0000568F _text$x         ends
.text$x:0000568F
.text$mn:00005690 ; ===========================================================================
.text$mn:00005690
.text$mn:00005690 ; Segment type: Pure code
.text$mn:00005690 ; Segment permissions: Read/Execute
.text$mn:00005690 _text$mn        segment para public 'CODE' use32
.text$mn:00005690                 assume cs:_text$mn
.text$mn:00005690                 ;org 5690h
.text$mn:00005690 ; COMDAT (pick any)
.text$mn:00005690                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005690
.text$mn:00005690 ; =============== S U B R O U T I N E =======================================
.text$mn:00005690
.text$mn:00005690 ; Attributes: bp-based frame
.text$mn:00005690
.text$mn:00005690 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00005690                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00005690 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00005690                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00005690                                         ; __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00005690
.text$mn:00005690 var_4           = dword ptr -4
.text$mn:00005690
.text$mn:00005690                 push    ebp
.text$mn:00005691                 mov     ebp, esp
.text$mn:00005693                 push    ecx
.text$mn:00005694                 mov     [ebp+var_4], ecx
.text$mn:00005697                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000569A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000569F                 mov     esp, ebp
.text$mn:000056A1                 pop     ebp
.text$mn:000056A2                 retn
.text$mn:000056A2 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:000056A2
.text$mn:000056A2 ; ---------------------------------------------------------------------------
.text$mn:000056A3                 align 4
.text$mn:000056A3 _text$mn        ends
.text$mn:000056A3
.text$mn:000056A4 ; ===========================================================================
.text$mn:000056A4
.text$mn:000056A4 ; Segment type: Pure code
.text$mn:000056A4 ; Segment permissions: Read/Execute
.text$mn:000056A4 _text$mn        segment para public 'CODE' use32
.text$mn:000056A4                 assume cs:_text$mn
.text$mn:000056A4                 ;org 56A4h
.text$mn:000056A4 ; COMDAT (pick any)
.text$mn:000056A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000056A4
.text$mn:000056A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000056A4
.text$mn:000056A4 ; Attributes: bp-based frame
.text$mn:000056A4
.text$mn:000056A4 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000056A4                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:000056A4 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:000056A4                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:000056A4                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:000056A4
.text$mn:000056A4 var_10          = dword ptr -10h
.text$mn:000056A4 var_C           = dword ptr -0Ch
.text$mn:000056A4 var_4           = dword ptr -4
.text$mn:000056A4
.text$mn:000056A4                 push    ebp
.text$mn:000056A5                 mov     ebp, esp
.text$mn:000056A7                 push    0FFFFFFFFh
.text$mn:000056A9                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000056AE                 mov     eax, large fs:0
.text$mn:000056B4                 push    eax
.text$mn:000056B5                 push    ecx
.text$mn:000056B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000056BB                 xor     eax, ebp
.text$mn:000056BD                 push    eax
.text$mn:000056BE                 lea     eax, [ebp+var_C]
.text$mn:000056C1                 mov     large fs:0, eax
.text$mn:000056C7                 mov     [ebp+var_10], ecx
.text$mn:000056CA                 mov     [ebp+var_4], 0
.text$mn:000056D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000056D8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000056DB                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000056E0                 mov     ecx, [ebp+var_C]
.text$mn:000056E3                 mov     large fs:0, ecx
.text$mn:000056EA                 pop     ecx
.text$mn:000056EB                 mov     esp, ebp
.text$mn:000056ED                 pop     ebp
.text$mn:000056EE                 retn
.text$mn:000056EE ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:000056EE
.text$mn:000056EE ; ---------------------------------------------------------------------------
.text$mn:000056EF                 align 10h
.text$mn:000056EF _text$mn        ends
.text$mn:000056EF
.text$x:000056F0 ; ===========================================================================
.text$x:000056F0
.text$x:000056F0 ; Segment type: Pure code
.text$x:000056F0 ; Segment permissions: Read/Execute
.text$x:000056F0 _text$x         segment para public 'CODE' use32
.text$x:000056F0                 assume cs:_text$x
.text$x:000056F0                 ;org 56F0h
.text$x:000056F0 ; COMDAT (pick associative to section at 56A4)
.text$x:000056F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000056F0
.text$x:000056F0 ; =============== S U B R O U T I N E =======================================
.text$x:000056F0
.text$x:000056F0
.text$x:000056F0 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:000056F0                                         ; DATA XREF: .xdata$x:00009184o
.text$x:000056F0                 mov     ecx, [ebp-10h]  ; this
.text$x:000056F3                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000056F3 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:000056F3
.text$x:000056F8
.text$x:000056F8 ; =============== S U B R O U T I N E =======================================
.text$x:000056F8
.text$x:000056F8
.text$x:000056F8 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:000056F8                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:000056F8
.text$x:000056F8 arg_4           = dword ptr  8
.text$x:000056F8
.text$x:000056F8                 mov     edx, [esp+arg_4]
.text$x:000056FC                 lea     eax, [edx+0Ch]
.text$x:000056FF                 mov     ecx, [edx-8]
.text$x:00005702                 xor     ecx, eax
.text$x:00005704                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005709                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:0000570E                 jmp     ___CxxFrameHandler3
.text$x:0000570E __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:0000570E
.text$x:0000570E ; ---------------------------------------------------------------------------
.text$x:00005713                 align 4
.text$x:00005713 _text$x         ends
.text$x:00005713
.text$mn:00005714 ; ===========================================================================
.text$mn:00005714
.text$mn:00005714 ; Segment type: Pure code
.text$mn:00005714 ; Segment permissions: Read/Execute
.text$mn:00005714 _text$mn        segment para public 'CODE' use32
.text$mn:00005714                 assume cs:_text$mn
.text$mn:00005714                 ;org 5714h
.text$mn:00005714 ; COMDAT (pick any)
.text$mn:00005714                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005714
.text$mn:00005714 ; =============== S U B R O U T I N E =======================================
.text$mn:00005714
.text$mn:00005714 ; Attributes: bp-based frame
.text$mn:00005714
.text$mn:00005714 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00005714                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00005714 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00005714                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00005714                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00005714
.text$mn:00005714 var_10          = dword ptr -10h
.text$mn:00005714 var_C           = dword ptr -0Ch
.text$mn:00005714 var_4           = dword ptr -4
.text$mn:00005714
.text$mn:00005714                 push    ebp
.text$mn:00005715                 mov     ebp, esp
.text$mn:00005717                 push    0FFFFFFFFh
.text$mn:00005719                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:0000571E                 mov     eax, large fs:0
.text$mn:00005724                 push    eax
.text$mn:00005725                 push    ecx
.text$mn:00005726                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000572B                 xor     eax, ebp
.text$mn:0000572D                 push    eax
.text$mn:0000572E                 lea     eax, [ebp+var_C]
.text$mn:00005731                 mov     large fs:0, eax
.text$mn:00005737                 mov     [ebp+var_10], ecx
.text$mn:0000573A                 mov     [ebp+var_4], 0
.text$mn:00005741                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005748                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000574B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00005750                 mov     ecx, [ebp+var_C]
.text$mn:00005753                 mov     large fs:0, ecx
.text$mn:0000575A                 pop     ecx
.text$mn:0000575B                 mov     esp, ebp
.text$mn:0000575D                 pop     ebp
.text$mn:0000575E                 retn
.text$mn:0000575E ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:0000575E
.text$mn:0000575E ; ---------------------------------------------------------------------------
.text$mn:0000575F                 align 10h
.text$mn:0000575F _text$mn        ends
.text$mn:0000575F
.text$x:00005760 ; ===========================================================================
.text$x:00005760
.text$x:00005760 ; Segment type: Pure code
.text$x:00005760 ; Segment permissions: Read/Execute
.text$x:00005760 _text$x         segment para public 'CODE' use32
.text$x:00005760                 assume cs:_text$x
.text$x:00005760                 ;org 5760h
.text$x:00005760 ; COMDAT (pick associative to section at 5714)
.text$x:00005760                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005760
.text$x:00005760 ; =============== S U B R O U T I N E =======================================
.text$x:00005760
.text$x:00005760
.text$x:00005760 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00005760                                         ; DATA XREF: .xdata$x:00009208o
.text$x:00005760                 mov     ecx, [ebp-10h]  ; this
.text$x:00005763                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00005763 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00005763
.text$x:00005768
.text$x:00005768 ; =============== S U B R O U T I N E =======================================
.text$x:00005768
.text$x:00005768
.text$x:00005768 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00005768                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00005768
.text$x:00005768 arg_4           = dword ptr  8
.text$x:00005768
.text$x:00005768                 mov     edx, [esp+arg_4]
.text$x:0000576C                 lea     eax, [edx+0Ch]
.text$x:0000576F                 mov     ecx, [edx-8]
.text$x:00005772                 xor     ecx, eax
.text$x:00005774                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005779                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:0000577E                 jmp     ___CxxFrameHandler3
.text$x:0000577E __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:0000577E
.text$x:0000577E ; ---------------------------------------------------------------------------
.text$x:00005783                 align 4
.text$x:00005783 _text$x         ends
.text$x:00005783
.text$mn:00005784 ; ===========================================================================
.text$mn:00005784
.text$mn:00005784 ; Segment type: Pure code
.text$mn:00005784 ; Segment permissions: Read/Execute
.text$mn:00005784 _text$mn        segment para public 'CODE' use32
.text$mn:00005784                 assume cs:_text$mn
.text$mn:00005784                 ;org 5784h
.text$mn:00005784 ; COMDAT (pick any)
.text$mn:00005784                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005784
.text$mn:00005784 ; =============== S U B R O U T I N E =======================================
.text$mn:00005784
.text$mn:00005784 ; Attributes: bp-based frame
.text$mn:00005784
.text$mn:00005784 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00005784                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00005784 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00005784                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00005784                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00005784
.text$mn:00005784 var_14          = byte ptr -14h
.text$mn:00005784 var_10          = dword ptr -10h
.text$mn:00005784 var_C           = dword ptr -0Ch
.text$mn:00005784 var_4           = dword ptr -4
.text$mn:00005784
.text$mn:00005784                 push    ebp
.text$mn:00005785                 mov     ebp, esp
.text$mn:00005787                 push    0FFFFFFFFh
.text$mn:00005789                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:0000578E                 mov     eax, large fs:0
.text$mn:00005794                 push    eax
.text$mn:00005795                 sub     esp, 8
.text$mn:00005798                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000579D                 xor     eax, ebp
.text$mn:0000579F                 push    eax
.text$mn:000057A0                 lea     eax, [ebp+var_C]
.text$mn:000057A3                 mov     large fs:0, eax
.text$mn:000057A9                 mov     [ebp+var_10], ecx
.text$mn:000057AC                 push    3               ; int
.text$mn:000057AE                 lea     ecx, [ebp+var_14] ; this
.text$mn:000057B1                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000057B6                 mov     [ebp+var_4], 0
.text$mn:000057BD                 mov     ecx, [ebp+var_10] ; this
.text$mn:000057C0                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000057C5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000057CC                 lea     ecx, [ebp+var_14] ; this
.text$mn:000057CF                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000057D4                 mov     ecx, [ebp+var_C]
.text$mn:000057D7                 mov     large fs:0, ecx
.text$mn:000057DE                 pop     ecx
.text$mn:000057DF                 mov     esp, ebp
.text$mn:000057E1                 pop     ebp
.text$mn:000057E2                 retn
.text$mn:000057E2 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:000057E2
.text$mn:000057E2 ; ---------------------------------------------------------------------------
.text$mn:000057E3                 align 4
.text$mn:000057E3 _text$mn        ends
.text$mn:000057E3
.text$x:000057E4 ; ===========================================================================
.text$x:000057E4
.text$x:000057E4 ; Segment type: Pure code
.text$x:000057E4 ; Segment permissions: Read/Execute
.text$x:000057E4 _text$x         segment para public 'CODE' use32
.text$x:000057E4                 assume cs:_text$x
.text$x:000057E4                 ;org 57E4h
.text$x:000057E4 ; COMDAT (pick associative to section at 5784)
.text$x:000057E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000057E4
.text$x:000057E4 ; =============== S U B R O U T I N E =======================================
.text$x:000057E4
.text$x:000057E4
.text$x:000057E4 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:000057E4                                         ; DATA XREF: .xdata$x:00008F38o
.text$x:000057E4                 lea     ecx, [ebp-14h]  ; this
.text$x:000057E7                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000057E7 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:000057E7
.text$x:000057EC
.text$x:000057EC ; =============== S U B R O U T I N E =======================================
.text$x:000057EC
.text$x:000057EC
.text$x:000057EC __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:000057EC                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:000057EC
.text$x:000057EC arg_4           = dword ptr  8
.text$x:000057EC
.text$x:000057EC                 mov     edx, [esp+arg_4]
.text$x:000057F0                 lea     eax, [edx+0Ch]
.text$x:000057F3                 mov     ecx, [edx-0Ch]
.text$x:000057F6                 xor     ecx, eax
.text$x:000057F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000057FD                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00005802                 jmp     ___CxxFrameHandler3
.text$x:00005802 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00005802
.text$x:00005802 ; ---------------------------------------------------------------------------
.text$x:00005807                 align 4
.text$x:00005807 _text$x         ends
.text$x:00005807
.text$mn:00005808 ; ===========================================================================
.text$mn:00005808
.text$mn:00005808 ; Segment type: Pure code
.text$mn:00005808 ; Segment permissions: Read/Execute
.text$mn:00005808 _text$mn        segment para public 'CODE' use32
.text$mn:00005808                 assume cs:_text$mn
.text$mn:00005808                 ;org 5808h
.text$mn:00005808 ; COMDAT (pick any)
.text$mn:00005808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005808
.text$mn:00005808 ; =============== S U B R O U T I N E =======================================
.text$mn:00005808
.text$mn:00005808 ; Attributes: bp-based frame
.text$mn:00005808
.text$mn:00005808 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00005808                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00005808 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00005808                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00005808                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00005808
.text$mn:00005808 var_10          = dword ptr -10h
.text$mn:00005808 var_C           = dword ptr -0Ch
.text$mn:00005808 var_4           = dword ptr -4
.text$mn:00005808
.text$mn:00005808                 push    ebp
.text$mn:00005809                 mov     ebp, esp
.text$mn:0000580B                 push    0FFFFFFFFh
.text$mn:0000580D                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00005812                 mov     eax, large fs:0
.text$mn:00005818                 push    eax
.text$mn:00005819                 push    ecx
.text$mn:0000581A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000581F                 xor     eax, ebp
.text$mn:00005821                 push    eax
.text$mn:00005822                 lea     eax, [ebp+var_C]
.text$mn:00005825                 mov     large fs:0, eax
.text$mn:0000582B                 mov     [ebp+var_10], ecx
.text$mn:0000582E                 mov     [ebp+var_4], 0
.text$mn:00005835                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000583C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000583F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00005844                 mov     ecx, [ebp+var_C]
.text$mn:00005847                 mov     large fs:0, ecx
.text$mn:0000584E                 pop     ecx
.text$mn:0000584F                 mov     esp, ebp
.text$mn:00005851                 pop     ebp
.text$mn:00005852                 retn
.text$mn:00005852 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00005852
.text$mn:00005852 ; ---------------------------------------------------------------------------
.text$mn:00005853                 align 4
.text$mn:00005853 _text$mn        ends
.text$mn:00005853
.text$x:00005854 ; ===========================================================================
.text$x:00005854
.text$x:00005854 ; Segment type: Pure code
.text$x:00005854 ; Segment permissions: Read/Execute
.text$x:00005854 _text$x         segment para public 'CODE' use32
.text$x:00005854                 assume cs:_text$x
.text$x:00005854                 ;org 5854h
.text$x:00005854 ; COMDAT (pick associative to section at 5808)
.text$x:00005854                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005854
.text$x:00005854 ; =============== S U B R O U T I N E =======================================
.text$x:00005854
.text$x:00005854
.text$x:00005854 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00005854                                         ; DATA XREF: .xdata$x:0000928Co
.text$x:00005854                 mov     ecx, [ebp-10h]  ; this
.text$x:00005857                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00005857 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00005857
.text$x:0000585C
.text$x:0000585C ; =============== S U B R O U T I N E =======================================
.text$x:0000585C
.text$x:0000585C
.text$x:0000585C __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:0000585C                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:0000585C
.text$x:0000585C arg_4           = dword ptr  8
.text$x:0000585C
.text$x:0000585C                 mov     edx, [esp+arg_4]
.text$x:00005860                 lea     eax, [edx+0Ch]
.text$x:00005863                 mov     ecx, [edx-8]
.text$x:00005866                 xor     ecx, eax
.text$x:00005868                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000586D                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00005872                 jmp     ___CxxFrameHandler3
.text$x:00005872 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00005872
.text$x:00005872 ; ---------------------------------------------------------------------------
.text$x:00005877                 align 4
.text$x:00005877 _text$x         ends
.text$x:00005877
.text$mn:00005878 ; ===========================================================================
.text$mn:00005878
.text$mn:00005878 ; Segment type: Pure code
.text$mn:00005878 ; Segment permissions: Read/Execute
.text$mn:00005878 _text$mn        segment para public 'CODE' use32
.text$mn:00005878                 assume cs:_text$mn
.text$mn:00005878                 ;org 5878h
.text$mn:00005878 ; COMDAT (pick any)
.text$mn:00005878                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005878
.text$mn:00005878 ; =============== S U B R O U T I N E =======================================
.text$mn:00005878
.text$mn:00005878 ; Attributes: bp-based frame
.text$mn:00005878
.text$mn:00005878 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00005878                 public ??1error_category@std@@UAE@XZ
.text$mn:00005878 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00005878                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00005878
.text$mn:00005878 var_4           = dword ptr -4
.text$mn:00005878
.text$mn:00005878                 push    ebp
.text$mn:00005879                 mov     ebp, esp
.text$mn:0000587B                 push    ecx
.text$mn:0000587C                 mov     [ebp+var_4], ecx
.text$mn:0000587F                 mov     eax, [ebp+var_4]
.text$mn:00005882                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00005888                 mov     esp, ebp
.text$mn:0000588A                 pop     ebp
.text$mn:0000588B                 retn
.text$mn:0000588B ??1error_category@std@@UAE@XZ endp
.text$mn:0000588B
.text$mn:0000588B _text$mn        ends
.text$mn:0000588B
.text$mn:0000588C ; ===========================================================================
.text$mn:0000588C
.text$mn:0000588C ; Segment type: Pure code
.text$mn:0000588C ; Segment permissions: Read/Execute
.text$mn:0000588C _text$mn        segment para public 'CODE' use32
.text$mn:0000588C                 assume cs:_text$mn
.text$mn:0000588C                 ;org 588Ch
.text$mn:0000588C ; COMDAT (pick any)
.text$mn:0000588C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000588C
.text$mn:0000588C ; =============== S U B R O U T I N E =======================================
.text$mn:0000588C
.text$mn:0000588C ; Attributes: bp-based frame
.text$mn:0000588C
.text$mn:0000588C ; void *__cdecl operator new(unsigned int, void *)
.text$mn:0000588C                 public ??2@YAPAXIPAX@Z
.text$mn:0000588C ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<uchar>::construct<uchar,uchar>(uchar *,uchar &&)+2Ep
.text$mn:0000588C                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep ...
.text$mn:0000588C
.text$mn:0000588C arg_4           = dword ptr  0Ch
.text$mn:0000588C
.text$mn:0000588C                 push    ebp
.text$mn:0000588D                 mov     ebp, esp
.text$mn:0000588F                 mov     eax, [ebp+arg_4]
.text$mn:00005892                 pop     ebp
.text$mn:00005893                 retn
.text$mn:00005893 ??2@YAPAXIPAX@Z endp
.text$mn:00005893
.text$mn:00005893 _text$mn        ends
.text$mn:00005893
.text$mn:00005894 ; ===========================================================================
.text$mn:00005894
.text$mn:00005894 ; Segment type: Pure code
.text$mn:00005894 ; Segment permissions: Read/Execute
.text$mn:00005894 _text$mn        segment para public 'CODE' use32
.text$mn:00005894                 assume cs:_text$mn
.text$mn:00005894                 ;org 5894h
.text$mn:00005894 ; COMDAT (pick any)
.text$mn:00005894                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005894
.text$mn:00005894 ; =============== S U B R O U T I N E =======================================
.text$mn:00005894
.text$mn:00005894 ; Attributes: bp-based frame
.text$mn:00005894
.text$mn:00005894 ; void __cdecl operator delete(void *)
.text$mn:00005894                 public ??3@YAXPAX0@Z
.text$mn:00005894 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z$0+8p
.text$mn:00005894                                         ; __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p ...
.text$mn:00005894                 push    ebp
.text$mn:00005895                 mov     ebp, esp
.text$mn:00005897                 pop     ebp
.text$mn:00005898                 retn
.text$mn:00005898 ??3@YAXPAX0@Z   endp
.text$mn:00005898
.text$mn:00005898 ; ---------------------------------------------------------------------------
.text$mn:00005899                 align 4
.text$mn:00005899 _text$mn        ends
.text$mn:00005899
.text$mn:0000589C ; ===========================================================================
.text$mn:0000589C
.text$mn:0000589C ; Segment type: Pure code
.text$mn:0000589C ; Segment permissions: Read/Execute
.text$mn:0000589C _text$mn        segment para public 'CODE' use32
.text$mn:0000589C                 assume cs:_text$mn
.text$mn:0000589C                 ;org 589Ch
.text$mn:0000589C ; COMDAT (pick any)
.text$mn:0000589C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000589C
.text$mn:0000589C ; =============== S U B R O U T I N E =======================================
.text$mn:0000589C
.text$mn:0000589C ; Attributes: bp-based frame
.text$mn:0000589C
.text$mn:0000589C ; public: class std::vector<unsigned char, class std::allocator<unsigned char>> & __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::operator=(class std::vector<unsigned char, class std::allocator<unsigned char>> &&)
.text$mn:0000589C                 public ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z
.text$mn:0000589C ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z proc near
.text$mn:0000589C                                         ; CODE XREF: std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+2Fp
.text$mn:0000589C
.text$mn:0000589C var_8           = dword ptr -8
.text$mn:0000589C var_1           = byte ptr -1
.text$mn:0000589C arg_0           = dword ptr  8
.text$mn:0000589C
.text$mn:0000589C                 push    ebp
.text$mn:0000589D                 mov     ebp, esp
.text$mn:0000589F                 sub     esp, 8
.text$mn:000058A2                 mov     [ebp+var_8], ecx
.text$mn:000058A5                 mov     eax, [ebp+var_8]
.text$mn:000058A8                 cmp     eax, [ebp+arg_0]
.text$mn:000058AB                 jz      short loc_58E3
.text$mn:000058AD                 mov     ecx, [ebp+var_8]
.text$mn:000058B0                 call    ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Tidy(void)
.text$mn:000058B5                 xor     ecx, ecx
.text$mn:000058B7                 jz      short loc_58CE
.text$mn:000058B9                 lea     edx, [ebp+var_1]
.text$mn:000058BC                 push    edx
.text$mn:000058BD                 mov     ecx, [ebp+arg_0]
.text$mn:000058C0                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:000058C5                 push    eax
.text$mn:000058C6                 mov     ecx, [ebp+var_8]
.text$mn:000058C9                 call    ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<uchar>> const &)
.text$mn:000058CE
.text$mn:000058CE loc_58CE:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> &&)+1Bj
.text$mn:000058CE                 mov     eax, [ebp+arg_0]
.text$mn:000058D1                 push    eax
.text$mn:000058D2                 call    ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:000058D7                 add     esp, 4
.text$mn:000058DA                 push    eax
.text$mn:000058DB                 mov     ecx, [ebp+var_8]
.text$mn:000058DE                 call    ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@@Z ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&)
.text$mn:000058E3
.text$mn:000058E3 loc_58E3:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> &&)+Fj
.text$mn:000058E3                 mov     eax, [ebp+var_8]
.text$mn:000058E6                 mov     esp, ebp
.text$mn:000058E8                 pop     ebp
.text$mn:000058E9                 retn    4
.text$mn:000058E9 ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@$$QAV01@@Z endp
.text$mn:000058E9
.text$mn:000058E9 _text$mn        ends
.text$mn:000058E9
.text$mn:000058EC ; ===========================================================================
.text$mn:000058EC
.text$mn:000058EC ; Segment type: Pure code
.text$mn:000058EC ; Segment permissions: Read/Execute
.text$mn:000058EC _text$mn        segment para public 'CODE' use32
.text$mn:000058EC                 assume cs:_text$mn
.text$mn:000058EC                 ;org 58ECh
.text$mn:000058EC ; COMDAT (pick any)
.text$mn:000058EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000058EC
.text$mn:000058EC ; =============== S U B R O U T I N E =======================================
.text$mn:000058EC
.text$mn:000058EC ; Attributes: bp-based frame
.text$mn:000058EC
.text$mn:000058EC ; public: class std::vector<unsigned char, class std::allocator<unsigned char>> & __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::operator=(class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:000058EC                 public ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:000058EC ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$mn:000058EC                                         ; CODE XREF: std::_Copy_backward<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Nonscalar_ptr_iterator_tag)+24p
.text$mn:000058EC                                         ; std::_Fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+1Dp
.text$mn:000058EC
.text$mn:000058EC var_20          = dword ptr -20h
.text$mn:000058EC var_1C          = dword ptr -1Ch
.text$mn:000058EC var_18          = dword ptr -18h
.text$mn:000058EC var_14          = byte ptr -14h
.text$mn:000058EC var_13          = byte ptr -13h
.text$mn:000058EC var_12          = byte ptr -12h
.text$mn:000058EC var_11          = byte ptr -11h
.text$mn:000058EC var_10          = dword ptr -10h
.text$mn:000058EC var_C           = dword ptr -0Ch
.text$mn:000058EC var_4           = dword ptr -4
.text$mn:000058EC arg_0           = dword ptr  8
.text$mn:000058EC
.text$mn:000058EC ; FUNCTION CHUNK AT .text$mn:00005AFE SIZE 00000009 BYTES
.text$mn:000058EC ; FUNCTION CHUNK AT .text$mn:00005B0E SIZE 00000017 BYTES
.text$mn:000058EC
.text$mn:000058EC                 push    ebp
.text$mn:000058ED                 mov     ebp, esp
.text$mn:000058EF                 push    0FFFFFFFFh
.text$mn:000058F1                 push    offset __ehhandler$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:000058F6                 mov     eax, large fs:0
.text$mn:000058FC                 push    eax
.text$mn:000058FD                 push    ecx
.text$mn:000058FE                 sub     esp, 10h
.text$mn:00005901                 push    ebx
.text$mn:00005902                 push    esi
.text$mn:00005903                 push    edi
.text$mn:00005904                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005909                 xor     eax, ebp
.text$mn:0000590B                 push    eax
.text$mn:0000590C                 lea     eax, [ebp+var_C]
.text$mn:0000590F                 mov     large fs:0, eax
.text$mn:00005915                 mov     [ebp+var_10], esp
.text$mn:00005918                 mov     [ebp+var_18], ecx
.text$mn:0000591B                 mov     eax, [ebp+var_18]
.text$mn:0000591E                 cmp     eax, [ebp+arg_0]
.text$mn:00005921                 jz      loc_5B0E
.text$mn:00005927                 lea     ecx, [ebp+var_11]
.text$mn:0000592A                 push    ecx
.text$mn:0000592B                 mov     ecx, [ebp+arg_0]
.text$mn:0000592E                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00005933                 push    eax
.text$mn:00005934                 lea     edx, [ebp+var_12]
.text$mn:00005937                 push    edx
.text$mn:00005938                 mov     ecx, [ebp+var_18]
.text$mn:0000593B                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00005940                 push    eax
.text$mn:00005941                 call    ??$?9V?$allocator@E@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@E@std@@@0@0@Z ; std::operator!=<std::allocator<uchar>,std::allocator<uchar>>(std::_Wrap_alloc<std::allocator<uchar>> const &,std::_Wrap_alloc<std::allocator<uchar>> const &)
.text$mn:00005946                 add     esp, 8
.text$mn:00005949                 movzx   eax, al
.text$mn:0000594C                 test    eax, eax
.text$mn:0000594E                 jz      short loc_5971
.text$mn:00005950                 xor     ecx, ecx
.text$mn:00005952                 jz      short loc_5971
.text$mn:00005954                 mov     ecx, [ebp+var_18]
.text$mn:00005957                 call    ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Tidy(void)
.text$mn:0000595C                 lea     edx, [ebp+var_13]
.text$mn:0000595F                 push    edx
.text$mn:00005960                 mov     ecx, [ebp+arg_0]
.text$mn:00005963                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00005968                 push    eax
.text$mn:00005969                 mov     ecx, [ebp+var_18]
.text$mn:0000596C                 call    ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Change_alloc(std::_Wrap_alloc<std::allocator<uchar>> const &)
.text$mn:00005971
.text$mn:00005971 loc_5971:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+62j
.text$mn:00005971                                         ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+66j
.text$mn:00005971                 mov     ecx, [ebp+var_18] ; this
.text$mn:00005974                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00005979                 mov     ecx, [ebp+arg_0]
.text$mn:0000597C                 call    ?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ ; std::vector<uchar,std::allocator<uchar>>::empty(void)
.text$mn:00005981                 movzx   eax, al
.text$mn:00005984                 test    eax, eax
.text$mn:00005986                 jz      short loc_5995
.text$mn:00005988                 mov     ecx, [ebp+var_18]
.text$mn:0000598B                 call    ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ ; std::vector<uchar,std::allocator<uchar>>::clear(void)
.text$mn:00005990                 jmp     loc_5B0E
.text$mn:00005995 ; ---------------------------------------------------------------------------
.text$mn:00005995
.text$mn:00005995 loc_5995:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+9Aj
.text$mn:00005995                 mov     ecx, [ebp+arg_0]
.text$mn:00005998                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:0000599D                 mov     esi, eax
.text$mn:0000599F                 mov     ecx, [ebp+var_18]
.text$mn:000059A2                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:000059A7                 cmp     esi, eax
.text$mn:000059A9                 ja      short loc_59F7
.text$mn:000059AB                 mov     ecx, [ebp+var_18]
.text$mn:000059AE                 mov     edx, [ecx+4]
.text$mn:000059B1                 push    edx             ; Dst
.text$mn:000059B2                 mov     eax, [ebp+arg_0]
.text$mn:000059B5                 mov     ecx, [eax+8]
.text$mn:000059B8                 push    ecx             ; int
.text$mn:000059B9                 mov     edx, [ebp+arg_0]
.text$mn:000059BC                 mov     eax, [edx+4]
.text$mn:000059BF                 push    eax             ; Src
.text$mn:000059C0                 call    ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_impl<uchar *,uchar *>(uchar *,uchar *,uchar *)
.text$mn:000059C5                 add     esp, 0Ch
.text$mn:000059C8                 mov     [ebp+var_20], eax
.text$mn:000059CB                 mov     ecx, [ebp+var_18]
.text$mn:000059CE                 mov     edx, [ecx+8]
.text$mn:000059D1                 push    edx
.text$mn:000059D2                 mov     eax, [ebp+var_20]
.text$mn:000059D5                 push    eax
.text$mn:000059D6                 mov     ecx, [ebp+var_18]
.text$mn:000059D9                 call    ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<uchar,std::allocator<uchar>>::_Destroy(uchar *,uchar *)
.text$mn:000059DE                 mov     ecx, [ebp+arg_0]
.text$mn:000059E1                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:000059E6                 mov     ecx, [ebp+var_18]
.text$mn:000059E9                 add     eax, [ecx+4]
.text$mn:000059EC                 mov     edx, [ebp+var_18]
.text$mn:000059EF                 mov     [edx+8], eax
.text$mn:000059F2                 jmp     loc_5B0E
.text$mn:000059F7 ; ---------------------------------------------------------------------------
.text$mn:000059F7
.text$mn:000059F7 loc_59F7:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+BDj
.text$mn:000059F7                 mov     ecx, [ebp+arg_0]
.text$mn:000059FA                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:000059FF                 mov     esi, eax
.text$mn:00005A01                 mov     ecx, [ebp+var_18]
.text$mn:00005A04                 call    ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::capacity(void)
.text$mn:00005A09                 cmp     esi, eax
.text$mn:00005A0B                 ja      short loc_5A5D
.text$mn:00005A0D                 mov     ecx, [ebp+var_18]
.text$mn:00005A10                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00005A15                 mov     ecx, [ebp+arg_0]
.text$mn:00005A18                 add     eax, [ecx+4]
.text$mn:00005A1B                 mov     [ebp+var_1C], eax
.text$mn:00005A1E                 mov     edx, [ebp+var_18]
.text$mn:00005A21                 mov     eax, [edx+4]
.text$mn:00005A24                 push    eax             ; Dst
.text$mn:00005A25                 mov     ecx, [ebp+var_1C]
.text$mn:00005A28                 push    ecx             ; int
.text$mn:00005A29                 mov     edx, [ebp+arg_0]
.text$mn:00005A2C                 mov     eax, [edx+4]
.text$mn:00005A2F                 push    eax             ; Src
.text$mn:00005A30                 call    ??$_Copy_impl@PAEPAE@std@@YAPAEPAE00@Z ; std::_Copy_impl<uchar *,uchar *>(uchar *,uchar *,uchar *)
.text$mn:00005A35                 add     esp, 0Ch
.text$mn:00005A38                 mov     ecx, [ebp+var_18]
.text$mn:00005A3B                 mov     edx, [ecx+8]
.text$mn:00005A3E                 push    edx
.text$mn:00005A3F                 mov     eax, [ebp+arg_0]
.text$mn:00005A42                 mov     ecx, [eax+8]
.text$mn:00005A45                 push    ecx
.text$mn:00005A46                 mov     edx, [ebp+var_1C]
.text$mn:00005A49                 push    edx
.text$mn:00005A4A                 mov     ecx, [ebp+var_18]
.text$mn:00005A4D                 call    ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<uchar,std::allocator<uchar>>::_Ucopy<uchar *>(uchar *,uchar *,uchar *)
.text$mn:00005A52                 mov     ecx, [ebp+var_18]
.text$mn:00005A55                 mov     [ecx+8], eax
.text$mn:00005A58                 jmp     loc_5B0E
.text$mn:00005A5D ; ---------------------------------------------------------------------------
.text$mn:00005A5D
.text$mn:00005A5D loc_5A5D:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+11Fj
.text$mn:00005A5D                 mov     edx, [ebp+var_18]
.text$mn:00005A60                 cmp     dword ptr [edx+4], 0
.text$mn:00005A64                 jz      short loc_5AA3
.text$mn:00005A66                 mov     eax, [ebp+var_18]
.text$mn:00005A69                 mov     ecx, [eax+8]
.text$mn:00005A6C                 push    ecx
.text$mn:00005A6D                 mov     edx, [ebp+var_18]
.text$mn:00005A70                 mov     eax, [edx+4]
.text$mn:00005A73                 push    eax
.text$mn:00005A74                 mov     ecx, [ebp+var_18]
.text$mn:00005A77                 call    ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<uchar,std::allocator<uchar>>::_Destroy(uchar *,uchar *)
.text$mn:00005A7C                 mov     ecx, [ebp+var_18]
.text$mn:00005A7F                 mov     edx, [ebp+var_18]
.text$mn:00005A82                 mov     eax, [ecx+0Ch]
.text$mn:00005A85                 sub     eax, [edx+4]
.text$mn:00005A88                 push    eax             ; int
.text$mn:00005A89                 mov     ecx, [ebp+var_18]
.text$mn:00005A8C                 mov     edx, [ecx+4]
.text$mn:00005A8F                 push    edx             ; void *
.text$mn:00005A90                 lea     eax, [ebp+var_14]
.text$mn:00005A93                 push    eax
.text$mn:00005A94                 mov     ecx, [ebp+var_18]
.text$mn:00005A97                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00005A9C                 mov     ecx, eax
.text$mn:00005A9E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<std::allocator<uchar>>::deallocate(uchar *,uint)
.text$mn:00005AA3
.text$mn:00005AA3 loc_5AA3:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+178j
.text$mn:00005AA3                 mov     ecx, [ebp+arg_0]
.text$mn:00005AA6                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00005AAB                 push    eax
.text$mn:00005AAC                 mov     ecx, [ebp+var_18]
.text$mn:00005AAF                 call    ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z ; std::vector<uchar,std::allocator<uchar>>::_Buy(uint)
.text$mn:00005AB4                 movzx   ecx, al
.text$mn:00005AB7                 test    ecx, ecx
.text$mn:00005AB9                 jz      short loc_5B0E
.text$mn:00005ABB                 mov     [ebp+var_4], 0
.text$mn:00005AC2                 mov     edx, [ebp+var_18]
.text$mn:00005AC5                 mov     eax, [edx+4]
.text$mn:00005AC8                 push    eax
.text$mn:00005AC9                 mov     ecx, [ebp+arg_0]
.text$mn:00005ACC                 mov     edx, [ecx+8]
.text$mn:00005ACF                 push    edx
.text$mn:00005AD0                 mov     eax, [ebp+arg_0]
.text$mn:00005AD3                 mov     ecx, [eax+4]
.text$mn:00005AD6                 push    ecx
.text$mn:00005AD7                 mov     ecx, [ebp+var_18]
.text$mn:00005ADA                 call    ??$_Ucopy@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<uchar,std::allocator<uchar>>::_Ucopy<uchar *>(uchar *,uchar *,uchar *)
.text$mn:00005ADF                 mov     edx, [ebp+var_18]
.text$mn:00005AE2                 mov     [edx+8], eax
.text$mn:00005AE5                 jmp     short loc_5AFE
.text$mn:00005AE5 ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$mn:00005AE5
.text$mn:00005AE7
.text$mn:00005AE7 ; =============== S U B R O U T I N E =======================================
.text$mn:00005AE7
.text$mn:00005AE7 ; Attributes: noreturn
.text$mn:00005AE7
.text$mn:00005AE7 __catch$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z$0 proc near
.text$mn:00005AE7                                         ; DATA XREF: .xdata$x:0000985Co
.text$mn:00005AE7                 mov     ecx, [ebp-18h]
.text$mn:00005AEA                 call    ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Tidy(void)
.text$mn:00005AEF                 push    0
.text$mn:00005AF1                 push    0
.text$mn:00005AF3                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00005AF3 __catch$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z$0 endp
.text$mn:00005AF3
.text$mn:00005AF8 ; ---------------------------------------------------------------------------
.text$mn:00005AF8                 mov     eax, offset $LN17_0
.text$mn:00005AFD                 retn
.text$mn:00005AFE ; ---------------------------------------------------------------------------
.text$mn:00005AFE ; START OF FUNCTION CHUNK FOR ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00005AFE
.text$mn:00005AFE loc_5AFE:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+1F9j
.text$mn:00005AFE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005B05                 jmp     short loc_5B0E
.text$mn:00005B05 ; END OF FUNCTION CHUNK FOR ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00005B07
.text$mn:00005B07 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B07
.text$mn:00005B07
.text$mn:00005B07 $LN17_0         proc near               ; DATA XREF: .text$mn:00005AF8o
.text$mn:00005B07                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00005B07 $LN17_0         endp ; sp-analysis failed
.text$mn:00005B07
.text$mn:00005B0E ; START OF FUNCTION CHUNK FOR ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00005B0E
.text$mn:00005B0E loc_5B0E:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+35j
.text$mn:00005B0E                                         ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+A4j ...
.text$mn:00005B0E                 mov     eax, [ebp+var_18]
.text$mn:00005B11                 mov     ecx, [ebp+var_C]
.text$mn:00005B14                 mov     large fs:0, ecx
.text$mn:00005B1B                 pop     ecx
.text$mn:00005B1C                 pop     edi
.text$mn:00005B1D                 pop     esi
.text$mn:00005B1E                 pop     ebx
.text$mn:00005B1F                 mov     esp, ebp
.text$mn:00005B21                 pop     ebp
.text$mn:00005B22                 retn    4
.text$mn:00005B22 ; END OF FUNCTION CHUNK FOR ??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.text$mn:00005B22 ; ---------------------------------------------------------------------------
.text$mn:00005B25                 align 4
.text$mn:00005B25 _text$mn        ends
.text$mn:00005B25
.text$x:00005B28 ; ===========================================================================
.text$x:00005B28
.text$x:00005B28 ; Segment type: Pure code
.text$x:00005B28 ; Segment permissions: Read/Execute
.text$x:00005B28 _text$x         segment para public 'CODE' use32
.text$x:00005B28                 assume cs:_text$x
.text$x:00005B28                 ;org 5B28h
.text$x:00005B28 ; COMDAT (pick associative to section at 58EC)
.text$x:00005B28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005B28
.text$x:00005B28 ; =============== S U B R O U T I N E =======================================
.text$x:00005B28
.text$x:00005B28
.text$x:00005B28 __ehhandler$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z proc near
.text$x:00005B28                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+5o
.text$x:00005B28
.text$x:00005B28 arg_4           = dword ptr  8
.text$x:00005B28
.text$x:00005B28                 mov     edx, [esp+arg_4]
.text$x:00005B2C                 lea     eax, [edx+0Ch]
.text$x:00005B2F                 mov     ecx, [edx-24h]
.text$x:00005B32                 xor     ecx, eax
.text$x:00005B34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005B39                 mov     eax, offset __ehfuncinfo$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.text$x:00005B3E                 jmp     ___CxxFrameHandler3
.text$x:00005B3E __ehhandler$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z endp
.text$x:00005B3E
.text$x:00005B3E ; ---------------------------------------------------------------------------
.text$x:00005B43                 align 4
.text$x:00005B43 _text$x         ends
.text$x:00005B43
.text$mn:00005B44 ; ===========================================================================
.text$mn:00005B44
.text$mn:00005B44 ; Segment type: Pure code
.text$mn:00005B44 ; Segment permissions: Read/Execute
.text$mn:00005B44 _text$mn        segment para public 'CODE' use32
.text$mn:00005B44                 assume cs:_text$mn
.text$mn:00005B44                 ;org 5B44h
.text$mn:00005B44 ; COMDAT (pick any)
.text$mn:00005B44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005B44
.text$mn:00005B44 ; =============== S U B R O U T I N E =======================================
.text$mn:00005B44
.text$mn:00005B44 ; Attributes: bp-based frame
.text$mn:00005B44
.text$mn:00005B44 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00005B44                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00005B44 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00005B44                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00005B44
.text$mn:00005B44 var_14          = byte ptr -14h
.text$mn:00005B44 var_10          = dword ptr -10h
.text$mn:00005B44 var_C           = dword ptr -0Ch
.text$mn:00005B44 var_4           = dword ptr -4
.text$mn:00005B44 arg_0           = dword ptr  8
.text$mn:00005B44
.text$mn:00005B44                 push    ebp
.text$mn:00005B45                 mov     ebp, esp
.text$mn:00005B47                 push    0FFFFFFFFh
.text$mn:00005B49                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00005B4E                 mov     eax, large fs:0
.text$mn:00005B54                 push    eax
.text$mn:00005B55                 sub     esp, 8
.text$mn:00005B58                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005B5D                 xor     eax, ebp
.text$mn:00005B5F                 push    eax
.text$mn:00005B60                 lea     eax, [ebp+var_C]
.text$mn:00005B63                 mov     large fs:0, eax
.text$mn:00005B69                 mov     [ebp+var_10], ecx
.text$mn:00005B6C                 mov     eax, [ebp+var_10]
.text$mn:00005B6F                 mov     ecx, [ebp+arg_0]
.text$mn:00005B72                 mov     edx, [eax]
.text$mn:00005B74                 cmp     edx, [ecx]
.text$mn:00005B76                 jnz     short loc_5B7A
.text$mn:00005B78                 jmp     short loc_5BBC
.text$mn:00005B7A ; ---------------------------------------------------------------------------
.text$mn:00005B7A
.text$mn:00005B7A loc_5B7A:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00005B7A                 mov     eax, [ebp+arg_0]
.text$mn:00005B7D                 cmp     dword ptr [eax], 0
.text$mn:00005B80                 jz      short loc_5B94
.text$mn:00005B82                 mov     ecx, [ebp+arg_0]
.text$mn:00005B85                 mov     edx, [ecx]
.text$mn:00005B87                 mov     eax, [edx]
.text$mn:00005B89                 push    eax             ; struct std::_Container_base12 *
.text$mn:00005B8A                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005B8D                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:00005B92                 jmp     short loc_5BBC
.text$mn:00005B94 ; ---------------------------------------------------------------------------
.text$mn:00005B94
.text$mn:00005B94 loc_5B94:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00005B94                 push    3               ; int
.text$mn:00005B96                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005B99                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00005B9E                 mov     [ebp+var_4], 0
.text$mn:00005BA5                 mov     ecx, [ebp+var_10] ; this
.text$mn:00005BA8                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00005BAD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00005BB4                 lea     ecx, [ebp+var_14] ; this
.text$mn:00005BB7                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00005BBC
.text$mn:00005BBC loc_5BBC:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00005BBC                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00005BBC                 mov     eax, [ebp+var_10]
.text$mn:00005BBF                 mov     ecx, [ebp+var_C]
.text$mn:00005BC2                 mov     large fs:0, ecx
.text$mn:00005BC9                 pop     ecx
.text$mn:00005BCA                 mov     esp, ebp
.text$mn:00005BCC                 pop     ebp
.text$mn:00005BCD                 retn    4
.text$mn:00005BCD ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:00005BCD
.text$mn:00005BCD _text$mn        ends
.text$mn:00005BCD
.text$x:00005BD0 ; ===========================================================================
.text$x:00005BD0
.text$x:00005BD0 ; Segment type: Pure code
.text$x:00005BD0 ; Segment permissions: Read/Execute
.text$x:00005BD0 _text$x         segment para public 'CODE' use32
.text$x:00005BD0                 assume cs:_text$x
.text$x:00005BD0                 ;org 5BD0h
.text$x:00005BD0 ; COMDAT (pick associative to section at 5B44)
.text$x:00005BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00005BD0
.text$x:00005BD0 ; =============== S U B R O U T I N E =======================================
.text$x:00005BD0
.text$x:00005BD0
.text$x:00005BD0 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:00005BD0                                         ; DATA XREF: .xdata$x:00008F0Co
.text$x:00005BD0                 lea     ecx, [ebp-14h]  ; this
.text$x:00005BD3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00005BD3 __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:00005BD3
.text$x:00005BD8
.text$x:00005BD8 ; =============== S U B R O U T I N E =======================================
.text$x:00005BD8
.text$x:00005BD8
.text$x:00005BD8 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:00005BD8                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:00005BD8
.text$x:00005BD8 arg_4           = dword ptr  8
.text$x:00005BD8
.text$x:00005BD8                 mov     edx, [esp+arg_4]
.text$x:00005BDC                 lea     eax, [edx+0Ch]
.text$x:00005BDF                 mov     ecx, [edx-0Ch]
.text$x:00005BE2                 xor     ecx, eax
.text$x:00005BE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00005BE9                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:00005BEE                 jmp     ___CxxFrameHandler3
.text$x:00005BEE __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:00005BEE
.text$x:00005BEE ; ---------------------------------------------------------------------------
.text$x:00005BF3                 align 4
.text$x:00005BF3 _text$x         ends
.text$x:00005BF3
.text$mn:00005BF4 ; ===========================================================================
.text$mn:00005BF4
.text$mn:00005BF4 ; Segment type: Pure code
.text$mn:00005BF4 ; Segment permissions: Read/Execute
.text$mn:00005BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00005BF4                 assume cs:_text$mn
.text$mn:00005BF4                 ;org 5BF4h
.text$mn:00005BF4 ; COMDAT (pick any)
.text$mn:00005BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005BF4
.text$mn:00005BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005BF4
.text$mn:00005BF4 ; Attributes: bp-based frame
.text$mn:00005BF4
.text$mn:00005BF4 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::operator==(std::_Iterator_base12 *)
.text$mn:00005BF4                 public ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00005BF4 ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00005BF4                                         ; CODE XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::_Equal<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+4Bp
.text$mn:00005BF4
.text$mn:00005BF4 var_8           = dword ptr -8
.text$mn:00005BF4 var_4           = dword ptr -4
.text$mn:00005BF4 arg_0           = dword ptr  8
.text$mn:00005BF4
.text$mn:00005BF4                 push    ebp
.text$mn:00005BF5                 mov     ebp, esp
.text$mn:00005BF7                 sub     esp, 8
.text$mn:00005BFA                 mov     [ebp+var_4], ecx
.text$mn:00005BFD                 mov     eax, [ebp+arg_0]
.text$mn:00005C00                 push    eax             ; std::_Iterator_base12 *
.text$mn:00005C01                 mov     ecx, [ebp+var_4]
.text$mn:00005C04                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00005C09                 mov     ecx, [ebp+var_4]
.text$mn:00005C0C                 mov     edx, [ebp+arg_0]
.text$mn:00005C0F                 mov     eax, [ecx+8]
.text$mn:00005C12                 cmp     eax, [edx+8]
.text$mn:00005C15                 jnz     short loc_5C20
.text$mn:00005C17                 mov     [ebp+var_8], 1
.text$mn:00005C1E                 jmp     short loc_5C27
.text$mn:00005C20 ; ---------------------------------------------------------------------------
.text$mn:00005C20
.text$mn:00005C20 loc_5C20:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+21j
.text$mn:00005C20                 mov     [ebp+var_8], 0
.text$mn:00005C27
.text$mn:00005C27 loc_5C27:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+2Aj
.text$mn:00005C27                 mov     al, byte ptr [ebp+var_8]
.text$mn:00005C2A                 mov     esp, ebp
.text$mn:00005C2C                 pop     ebp
.text$mn:00005C2D                 retn    4
.text$mn:00005C2D ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:00005C2D
.text$mn:00005C2D _text$mn        ends
.text$mn:00005C2D
.text$mn:00005C30 ; ===========================================================================
.text$mn:00005C30
.text$mn:00005C30 ; Segment type: Pure code
.text$mn:00005C30 ; Segment permissions: Read/Execute
.text$mn:00005C30 _text$mn        segment para public 'CODE' use32
.text$mn:00005C30                 assume cs:_text$mn
.text$mn:00005C30                 ;org 5C30h
.text$mn:00005C30 ; COMDAT (pick any)
.text$mn:00005C30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C30
.text$mn:00005C30 ; =============== S U B R O U T I N E =======================================
.text$mn:00005C30
.text$mn:00005C30 ; Attributes: bp-based frame
.text$mn:00005C30
.text$mn:00005C30 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00005C30                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00005C30 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00005C30                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00005C30                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00005C30
.text$mn:00005C30 var_8           = dword ptr -8
.text$mn:00005C30 var_4           = dword ptr -4
.text$mn:00005C30 arg_0           = dword ptr  8
.text$mn:00005C30
.text$mn:00005C30                 push    ebp
.text$mn:00005C31                 mov     ebp, esp
.text$mn:00005C33                 sub     esp, 8
.text$mn:00005C36                 mov     [ebp+var_8], ecx
.text$mn:00005C39                 mov     eax, [ebp+var_8]
.text$mn:00005C3C                 cmp     eax, [ebp+arg_0]
.text$mn:00005C3F                 jnz     short loc_5C4A
.text$mn:00005C41                 mov     [ebp+var_4], 1
.text$mn:00005C48                 jmp     short loc_5C51
.text$mn:00005C4A ; ---------------------------------------------------------------------------
.text$mn:00005C4A
.text$mn:00005C4A loc_5C4A:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00005C4A                 mov     [ebp+var_4], 0
.text$mn:00005C51
.text$mn:00005C51 loc_5C51:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00005C51                 mov     al, byte ptr [ebp+var_4]
.text$mn:00005C54                 mov     esp, ebp
.text$mn:00005C56                 pop     ebp
.text$mn:00005C57                 retn    4
.text$mn:00005C57 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00005C57
.text$mn:00005C57 ; ---------------------------------------------------------------------------
.text$mn:00005C5A                 align 4
.text$mn:00005C5A _text$mn        ends
.text$mn:00005C5A
.text$mn:00005C5C ; ===========================================================================
.text$mn:00005C5C
.text$mn:00005C5C ; Segment type: Pure code
.text$mn:00005C5C ; Segment permissions: Read/Execute
.text$mn:00005C5C _text$mn        segment para public 'CODE' use32
.text$mn:00005C5C                 assume cs:_text$mn
.text$mn:00005C5C                 ;org 5C5Ch
.text$mn:00005C5C ; COMDAT (pick any)
.text$mn:00005C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005C5C
.text$mn:00005C5C ; =============== S U B R O U T I N E =======================================
.text$mn:00005C5C
.text$mn:00005C5C ; Attributes: bp-based frame
.text$mn:00005C5C
.text$mn:00005C5C ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00005C5C                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00005C5C ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00005C5C                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00005C5C
.text$mn:00005C5C var_8           = dword ptr -8
.text$mn:00005C5C var_4           = dword ptr -4
.text$mn:00005C5C arg_0           = dword ptr  8
.text$mn:00005C5C
.text$mn:00005C5C                 push    ebp
.text$mn:00005C5D                 mov     ebp, esp
.text$mn:00005C5F                 sub     esp, 8
.text$mn:00005C62                 push    esi
.text$mn:00005C63                 mov     [ebp+var_4], ecx
.text$mn:00005C66                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005C69                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00005C6E                 push    eax
.text$mn:00005C6F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005C72                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00005C77                 mov     ecx, eax
.text$mn:00005C79                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00005C7E                 movzx   eax, al
.text$mn:00005C81                 test    eax, eax
.text$mn:00005C83                 jz      short loc_5CA4
.text$mn:00005C85                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005C88                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00005C8D                 mov     esi, eax
.text$mn:00005C8F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00005C92                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00005C97                 cmp     esi, eax
.text$mn:00005C99                 jnz     short loc_5CA4
.text$mn:00005C9B                 mov     [ebp+var_8], 1
.text$mn:00005CA2                 jmp     short loc_5CAB
.text$mn:00005CA4 ; ---------------------------------------------------------------------------
.text$mn:00005CA4
.text$mn:00005CA4 loc_5CA4:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00005CA4                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00005CA4                 mov     [ebp+var_8], 0
.text$mn:00005CAB
.text$mn:00005CAB loc_5CAB:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00005CAB                 mov     al, byte ptr [ebp+var_8]
.text$mn:00005CAE                 pop     esi
.text$mn:00005CAF                 mov     esp, ebp
.text$mn:00005CB1                 pop     ebp
.text$mn:00005CB2                 retn    4
.text$mn:00005CB2 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00005CB2
.text$mn:00005CB2 ; ---------------------------------------------------------------------------
.text$mn:00005CB5                 align 4
.text$mn:00005CB5 _text$mn        ends
.text$mn:00005CB5
.text$mn:00005CB8 ; ===========================================================================
.text$mn:00005CB8
.text$mn:00005CB8 ; Segment type: Pure code
.text$mn:00005CB8 ; Segment permissions: Read/Execute
.text$mn:00005CB8 _text$mn        segment para public 'CODE' use32
.text$mn:00005CB8                 assume cs:_text$mn
.text$mn:00005CB8                 ;org 5CB8h
.text$mn:00005CB8 ; COMDAT (pick any)
.text$mn:00005CB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005CB8
.text$mn:00005CB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005CB8
.text$mn:00005CB8 ; Attributes: bp-based frame
.text$mn:00005CB8
.text$mn:00005CB8 ; public: unsigned char & __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::operator[](unsigned int)
.text$mn:00005CB8                 public ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z
.text$mn:00005CB8 ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z proc near
.text$mn:00005CB8                                         ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+8Fp
.text$mn:00005CB8                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+179p ...
.text$mn:00005CB8
.text$mn:00005CB8 var_4           = dword ptr -4
.text$mn:00005CB8 arg_0           = dword ptr  8
.text$mn:00005CB8
.text$mn:00005CB8                 push    ebp
.text$mn:00005CB9                 mov     ebp, esp
.text$mn:00005CBB                 push    ecx
.text$mn:00005CBC                 mov     [ebp+var_4], ecx
.text$mn:00005CBF                 mov     ecx, [ebp+var_4]
.text$mn:00005CC2                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00005CC7                 cmp     eax, [ebp+arg_0]
.text$mn:00005CCA                 ja      short loc_5D34
.text$mn:00005CCC                 push    4B1h            ; unsigned int
.text$mn:00005CD1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005CD6                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00005CDB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005CE0                 add     esp, 0Ch
.text$mn:00005CE3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005CE8                 test    eax, eax
.text$mn:00005CEA                 jz      short loc_5CF0
.text$mn:00005CEC                 xor     ecx, ecx
.text$mn:00005CEE                 jnz     short loc_5D16
.text$mn:00005CF0
.text$mn:00005CF0 loc_5CF0:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+32j
.text$mn:00005CF0                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005CF5                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005CFA                 push    0
.text$mn:00005CFC                 push    4B2h
.text$mn:00005D01                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005D06                 push    2
.text$mn:00005D08                 call    __CrtDbgReportW
.text$mn:00005D0D                 add     esp, 18h
.text$mn:00005D10                 cmp     eax, 1
.text$mn:00005D13                 jnz     short loc_5D16
.text$mn:00005D15                 int     3               ; Trap to Debugger
.text$mn:00005D16
.text$mn:00005D16 loc_5D16:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+36j
.text$mn:00005D16                                         ; std::vector<uchar,std::allocator<uchar>>::operator[](uint)+5Bj
.text$mn:00005D16                 push    0
.text$mn:00005D18                 push    4B2h
.text$mn:00005D1D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005D22                 push    offset ??_C@_1JK@PKCFAHNP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAr?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@ ; "std::vector<unsigned char,class std::al"...
.text$mn:00005D27                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005D2C                 call    __invalid_parameter
.text$mn:00005D31                 add     esp, 14h
.text$mn:00005D34
.text$mn:00005D34 loc_5D34:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+12j
.text$mn:00005D34                 mov     eax, [ebp+var_4]
.text$mn:00005D37                 mov     eax, [eax+4]
.text$mn:00005D3A                 add     eax, [ebp+arg_0]
.text$mn:00005D3D                 mov     esp, ebp
.text$mn:00005D3F                 pop     ebp
.text$mn:00005D40                 retn    4
.text$mn:00005D40 ??A?$vector@EV?$allocator@E@std@@@std@@QAEAAEI@Z endp
.text$mn:00005D40
.text$mn:00005D40 ; ---------------------------------------------------------------------------
.text$mn:00005D43                 align 4
.text$mn:00005D43 _text$mn        ends
.text$mn:00005D43
.text$mn:00005D44 ; ===========================================================================
.text$mn:00005D44
.text$mn:00005D44 ; Segment type: Pure code
.text$mn:00005D44 ; Segment permissions: Read/Execute
.text$mn:00005D44 _text$mn        segment para public 'CODE' use32
.text$mn:00005D44                 assume cs:_text$mn
.text$mn:00005D44                 ;org 5D44h
.text$mn:00005D44 ; COMDAT (pick any)
.text$mn:00005D44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005D44
.text$mn:00005D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00005D44
.text$mn:00005D44 ; Attributes: bp-based frame
.text$mn:00005D44
.text$mn:00005D44 ; public: class std::vector<unsigned char, class std::allocator<unsigned char>> & __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::operator[](unsigned int)
.text$mn:00005D44                 public ??A?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAEAAV?$vector@EV?$allocator@E@std@@@1@I@Z
.text$mn:00005D44 ??A?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAEAAV?$vector@EV?$allocator@E@std@@@1@I@Z proc near
.text$mn:00005D44                                         ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+7Bp
.text$mn:00005D44                                         ; ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+CDp ...
.text$mn:00005D44
.text$mn:00005D44 var_4           = dword ptr -4
.text$mn:00005D44 arg_0           = dword ptr  8
.text$mn:00005D44
.text$mn:00005D44                 push    ebp
.text$mn:00005D45                 mov     ebp, esp
.text$mn:00005D47                 push    ecx
.text$mn:00005D48                 mov     [ebp+var_4], ecx
.text$mn:00005D4B                 mov     ecx, [ebp+var_4]
.text$mn:00005D4E                 call    ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::size(void)
.text$mn:00005D53                 cmp     eax, [ebp+arg_0]
.text$mn:00005D56                 ja      short loc_5DC0
.text$mn:00005D58                 push    4B1h            ; unsigned int
.text$mn:00005D5D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005D62                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:00005D67                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005D6C                 add     esp, 0Ch
.text$mn:00005D6F                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005D74                 test    eax, eax
.text$mn:00005D76                 jz      short loc_5D7C
.text$mn:00005D78                 xor     ecx, ecx
.text$mn:00005D7A                 jnz     short loc_5DA2
.text$mn:00005D7C
.text$mn:00005D7C loc_5D7C:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+32j
.text$mn:00005D7C                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005D81                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005D86                 push    0
.text$mn:00005D88                 push    4B2h
.text$mn:00005D8D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005D92                 push    2
.text$mn:00005D94                 call    __CrtDbgReportW
.text$mn:00005D99                 add     esp, 18h
.text$mn:00005D9C                 cmp     eax, 1
.text$mn:00005D9F                 jnz     short loc_5DA2
.text$mn:00005DA1                 int     3               ; Trap to Debugger
.text$mn:00005DA2
.text$mn:00005DA2 loc_5DA2:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+36j
.text$mn:00005DA2                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+5Bj
.text$mn:00005DA2                 push    0
.text$mn:00005DA4                 push    4B2h
.text$mn:00005DA9                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005DAE                 push    offset ??_C@_1BHM@GCCEGIDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn@ ; "std::vector<class std::vector<unsigned "...
.text$mn:00005DB3                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005DB8                 call    __invalid_parameter
.text$mn:00005DBD                 add     esp, 14h
.text$mn:00005DC0
.text$mn:00005DC0 loc_5DC0:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+12j
.text$mn:00005DC0                 mov     eax, [ebp+arg_0]
.text$mn:00005DC3                 shl     eax, 4
.text$mn:00005DC6                 mov     ecx, [ebp+var_4]
.text$mn:00005DC9                 add     eax, [ecx+4]
.text$mn:00005DCC                 mov     esp, ebp
.text$mn:00005DCE                 pop     ebp
.text$mn:00005DCF                 retn    4
.text$mn:00005DCF ??A?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAEAAV?$vector@EV?$allocator@E@std@@@1@I@Z endp
.text$mn:00005DCF
.text$mn:00005DCF ; ---------------------------------------------------------------------------
.text$mn:00005DD2                 align 4
.text$mn:00005DD2 _text$mn        ends
.text$mn:00005DD2
.text$mn:00005DD4 ; ===========================================================================
.text$mn:00005DD4
.text$mn:00005DD4 ; Segment type: Pure code
.text$mn:00005DD4 ; Segment permissions: Read/Execute
.text$mn:00005DD4 _text$mn        segment para public 'CODE' use32
.text$mn:00005DD4                 assume cs:_text$mn
.text$mn:00005DD4                 ;org 5DD4h
.text$mn:00005DD4 ; COMDAT (pick any)
.text$mn:00005DD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005DD4
.text$mn:00005DD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00005DD4
.text$mn:00005DD4 ; Attributes: bp-based frame
.text$mn:00005DD4
.text$mn:00005DD4 ; public: unsigned char const & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>::operator*(void)const
.text$mn:00005DD4                 public ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEABEXZ
.text$mn:00005DD4 ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEABEXZ proc near
.text$mn:00005DD4                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+Ap
.text$mn:00005DD4
.text$mn:00005DD4 var_4           = dword ptr -4
.text$mn:00005DD4
.text$mn:00005DD4                 push    ebp
.text$mn:00005DD5                 mov     ebp, esp
.text$mn:00005DD7                 push    ecx
.text$mn:00005DD8                 mov     [ebp+var_4], ecx
.text$mn:00005DDB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005DDE                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005DE3                 test    eax, eax
.text$mn:00005DE5                 jz      short loc_5E16
.text$mn:00005DE7                 mov     eax, [ebp+var_4]
.text$mn:00005DEA                 cmp     dword ptr [eax+8], 0
.text$mn:00005DEE                 jz      short loc_5E16
.text$mn:00005DF0                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005DF3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005DF8                 mov     ecx, [ebp+var_4]
.text$mn:00005DFB                 mov     edx, [ecx+8]
.text$mn:00005DFE                 cmp     edx, [eax+4]
.text$mn:00005E01                 jb      short loc_5E16
.text$mn:00005E03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005E06                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005E0B                 mov     ecx, [ebp+var_4]
.text$mn:00005E0E                 mov     edx, [eax+8]
.text$mn:00005E11                 cmp     edx, [ecx+8]
.text$mn:00005E14                 ja      short loc_5E75
.text$mn:00005E16
.text$mn:00005E16 loc_5E16:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+11j
.text$mn:00005E16                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+1Aj ...
.text$mn:00005E16                 push    48h ; 'H'       ; unsigned int
.text$mn:00005E18                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005E1D                 push    offset ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; "vector iterator not dereferencable"
.text$mn:00005E22                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005E27                 add     esp, 0Ch
.text$mn:00005E2A                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005E2F                 test    eax, eax
.text$mn:00005E31                 jz      short loc_5E37
.text$mn:00005E33                 xor     ecx, ecx
.text$mn:00005E35                 jnz     short loc_5E5A
.text$mn:00005E37
.text$mn:00005E37 loc_5E37:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+5Dj
.text$mn:00005E37                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005E3C                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005E41                 push    0
.text$mn:00005E43                 push    49h ; 'I'
.text$mn:00005E45                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005E4A                 push    2
.text$mn:00005E4C                 call    __CrtDbgReportW
.text$mn:00005E51                 add     esp, 18h
.text$mn:00005E54                 cmp     eax, 1
.text$mn:00005E57                 jnz     short loc_5E5A
.text$mn:00005E59                 int     3               ; Trap to Debugger
.text$mn:00005E5A
.text$mn:00005E5A loc_5E5A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+61j
.text$mn:00005E5A                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+83j
.text$mn:00005E5A                 push    0
.text$mn:00005E5C                 push    49h ; 'I'
.text$mn:00005E5E                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005E63                 push    offset ??_C@_1NI@PPPKFEAA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00005E68                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005E6D                 call    __invalid_parameter
.text$mn:00005E72                 add     esp, 14h
.text$mn:00005E75
.text$mn:00005E75 loc_5E75:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+40j
.text$mn:00005E75                 mov     eax, [ebp+var_4]
.text$mn:00005E78                 mov     eax, [eax+8]
.text$mn:00005E7B                 mov     esp, ebp
.text$mn:00005E7D                 pop     ebp
.text$mn:00005E7E                 retn
.text$mn:00005E7E ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEABEXZ endp
.text$mn:00005E7E
.text$mn:00005E7E ; ---------------------------------------------------------------------------
.text$mn:00005E7F                 align 10h
.text$mn:00005E7F _text$mn        ends
.text$mn:00005E7F
.text$mn:00005E80 ; ===========================================================================
.text$mn:00005E80
.text$mn:00005E80 ; Segment type: Pure code
.text$mn:00005E80 ; Segment permissions: Read/Execute
.text$mn:00005E80 _text$mn        segment para public 'CODE' use32
.text$mn:00005E80                 assume cs:_text$mn
.text$mn:00005E80                 ;org 5E80h
.text$mn:00005E80 ; COMDAT (pick any)
.text$mn:00005E80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E80
.text$mn:00005E80 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E80
.text$mn:00005E80 ; Attributes: bp-based frame
.text$mn:00005E80
.text$mn:00005E80 ; public: unsigned char & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>::operator*(void)const
.text$mn:00005E80                 public ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEAAEXZ
.text$mn:00005E80 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEAAEXZ proc near
.text$mn:00005E80                                         ; CODE XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::operator*(void)+Ap
.text$mn:00005E80
.text$mn:00005E80 var_4           = dword ptr -4
.text$mn:00005E80
.text$mn:00005E80                 push    ebp
.text$mn:00005E81                 mov     ebp, esp
.text$mn:00005E83                 push    ecx
.text$mn:00005E84                 mov     [ebp+var_4], ecx
.text$mn:00005E87                 mov     ecx, [ebp+var_4]
.text$mn:00005E8A                 call    ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEABEXZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)
.text$mn:00005E8F                 mov     esp, ebp
.text$mn:00005E91                 pop     ebp
.text$mn:00005E92                 retn
.text$mn:00005E92 ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEAAEXZ endp
.text$mn:00005E92
.text$mn:00005E92 ; ---------------------------------------------------------------------------
.text$mn:00005E93                 align 4
.text$mn:00005E93 _text$mn        ends
.text$mn:00005E93
.text$mn:00005E94 ; ===========================================================================
.text$mn:00005E94
.text$mn:00005E94 ; Segment type: Pure code
.text$mn:00005E94 ; Segment permissions: Read/Execute
.text$mn:00005E94 _text$mn        segment para public 'CODE' use32
.text$mn:00005E94                 assume cs:_text$mn
.text$mn:00005E94                 ;org 5E94h
.text$mn:00005E94 ; COMDAT (pick any)
.text$mn:00005E94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005E94
.text$mn:00005E94 ; =============== S U B R O U T I N E =======================================
.text$mn:00005E94
.text$mn:00005E94 ; Attributes: bp-based frame
.text$mn:00005E94
.text$mn:00005E94 ; public: unsigned char && __thiscall std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>::operator*(void)const
.text$mn:00005E94                 public ??D?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE$$QAEXZ
.text$mn:00005E94 ??D?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE$$QAEXZ proc near
.text$mn:00005E94                                         ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+D2p
.text$mn:00005E94
.text$mn:00005E94 var_4           = dword ptr -4
.text$mn:00005E94
.text$mn:00005E94                 push    ebp
.text$mn:00005E95                 mov     ebp, esp
.text$mn:00005E97                 push    ecx
.text$mn:00005E98                 mov     [ebp+var_4], ecx
.text$mn:00005E9B                 mov     ecx, [ebp+var_4]
.text$mn:00005E9E                 call    ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEAAEXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)
.text$mn:00005EA3                 push    eax
.text$mn:00005EA4                 call    ??$move@AAE@std@@YA$$QAEAAE@Z ; std::move<uchar &>(uchar &)
.text$mn:00005EA9                 add     esp, 4
.text$mn:00005EAC                 mov     esp, ebp
.text$mn:00005EAE                 pop     ebp
.text$mn:00005EAF                 retn
.text$mn:00005EAF ??D?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE$$QAEXZ endp
.text$mn:00005EAF
.text$mn:00005EAF _text$mn        ends
.text$mn:00005EAF
.text$mn:00005EB0 ; ===========================================================================
.text$mn:00005EB0
.text$mn:00005EB0 ; Segment type: Pure code
.text$mn:00005EB0 ; Segment permissions: Read/Execute
.text$mn:00005EB0 _text$mn        segment para public 'CODE' use32
.text$mn:00005EB0                 assume cs:_text$mn
.text$mn:00005EB0                 ;org 5EB0h
.text$mn:00005EB0 ; COMDAT (pick any)
.text$mn:00005EB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005EB0
.text$mn:00005EB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00005EB0
.text$mn:00005EB0 ; Attributes: bp-based frame
.text$mn:00005EB0
.text$mn:00005EB0 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>::operator++(void)
.text$mn:00005EB0                 public ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00005EB0 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00005EB0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+Ap
.text$mn:00005EB0
.text$mn:00005EB0 var_4           = dword ptr -4
.text$mn:00005EB0
.text$mn:00005EB0                 push    ebp
.text$mn:00005EB1                 mov     ebp, esp
.text$mn:00005EB3                 push    ecx
.text$mn:00005EB4                 mov     [ebp+var_4], ecx
.text$mn:00005EB7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005EBA                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005EBF                 test    eax, eax
.text$mn:00005EC1                 jz      short loc_5EDF
.text$mn:00005EC3                 mov     eax, [ebp+var_4]
.text$mn:00005EC6                 cmp     dword ptr [eax+8], 0
.text$mn:00005ECA                 jz      short loc_5EDF
.text$mn:00005ECC                 mov     ecx, [ebp+var_4] ; this
.text$mn:00005ECF                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00005ED4                 mov     ecx, [ebp+var_4]
.text$mn:00005ED7                 mov     edx, [eax+8]
.text$mn:00005EDA                 cmp     edx, [ecx+8]
.text$mn:00005EDD                 ja      short loc_5F3E
.text$mn:00005EDF
.text$mn:00005EDF loc_5EDF:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+11j
.text$mn:00005EDF                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+1Aj
.text$mn:00005EDF                 push    65h ; 'e'       ; unsigned int
.text$mn:00005EE1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005EE6                 push    offset ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; "vector iterator not incrementable"
.text$mn:00005EEB                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00005EF0                 add     esp, 0Ch
.text$mn:00005EF3                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00005EF8                 test    eax, eax
.text$mn:00005EFA                 jz      short loc_5F00
.text$mn:00005EFC                 xor     ecx, ecx
.text$mn:00005EFE                 jnz     short loc_5F23
.text$mn:00005F00
.text$mn:00005F00 loc_5F00:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+4Aj
.text$mn:00005F00                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00005F05                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00005F0A                 push    0
.text$mn:00005F0C                 push    66h ; 'f'
.text$mn:00005F0E                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005F13                 push    2
.text$mn:00005F15                 call    __CrtDbgReportW
.text$mn:00005F1A                 add     esp, 18h
.text$mn:00005F1D                 cmp     eax, 1
.text$mn:00005F20                 jnz     short loc_5F23
.text$mn:00005F22                 int     3               ; Trap to Debugger
.text$mn:00005F23
.text$mn:00005F23 loc_5F23:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+4Ej
.text$mn:00005F23                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+70j
.text$mn:00005F23                 push    0
.text$mn:00005F25                 push    66h ; 'f'
.text$mn:00005F27                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00005F2C                 push    offset ??_C@_1NK@NAGJJBIN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00005F31                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00005F36                 call    __invalid_parameter
.text$mn:00005F3B                 add     esp, 14h
.text$mn:00005F3E
.text$mn:00005F3E loc_5F3E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+2Dj
.text$mn:00005F3E                 mov     eax, [ebp+var_4]
.text$mn:00005F41                 mov     ecx, [eax+8]
.text$mn:00005F44                 add     ecx, 1
.text$mn:00005F47                 mov     edx, [ebp+var_4]
.text$mn:00005F4A                 mov     [edx+8], ecx
.text$mn:00005F4D                 mov     eax, [ebp+var_4]
.text$mn:00005F50                 mov     esp, ebp
.text$mn:00005F52                 pop     ebp
.text$mn:00005F53                 retn
.text$mn:00005F53 ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00005F53
.text$mn:00005F53 _text$mn        ends
.text$mn:00005F53
.text$mn:00005F54 ; ===========================================================================
.text$mn:00005F54
.text$mn:00005F54 ; Segment type: Pure code
.text$mn:00005F54 ; Segment permissions: Read/Execute
.text$mn:00005F54 _text$mn        segment para public 'CODE' use32
.text$mn:00005F54                 assume cs:_text$mn
.text$mn:00005F54                 ;org 5F54h
.text$mn:00005F54 ; COMDAT (pick any)
.text$mn:00005F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F54
.text$mn:00005F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F54
.text$mn:00005F54 ; Attributes: bp-based frame
.text$mn:00005F54
.text$mn:00005F54 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>::operator++(void)
.text$mn:00005F54                 public ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00005F54 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00005F54                                         ; CODE XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::operator++(void)+Ap
.text$mn:00005F54
.text$mn:00005F54 var_4           = dword ptr -4
.text$mn:00005F54
.text$mn:00005F54                 push    ebp
.text$mn:00005F55                 mov     ebp, esp
.text$mn:00005F57                 push    ecx
.text$mn:00005F58                 mov     [ebp+var_4], ecx
.text$mn:00005F5B                 mov     ecx, [ebp+var_4]
.text$mn:00005F5E                 call    ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)
.text$mn:00005F63                 mov     eax, [ebp+var_4]
.text$mn:00005F66                 mov     esp, ebp
.text$mn:00005F68                 pop     ebp
.text$mn:00005F69                 retn
.text$mn:00005F69 ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00005F69
.text$mn:00005F69 ; ---------------------------------------------------------------------------
.text$mn:00005F6A                 align 4
.text$mn:00005F6A _text$mn        ends
.text$mn:00005F6A
.text$mn:00005F6C ; ===========================================================================
.text$mn:00005F6C
.text$mn:00005F6C ; Segment type: Pure code
.text$mn:00005F6C ; Segment permissions: Read/Execute
.text$mn:00005F6C _text$mn        segment para public 'CODE' use32
.text$mn:00005F6C                 assume cs:_text$mn
.text$mn:00005F6C                 ;org 5F6Ch
.text$mn:00005F6C ; COMDAT (pick any)
.text$mn:00005F6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F6C
.text$mn:00005F6C ; =============== S U B R O U T I N E =======================================
.text$mn:00005F6C
.text$mn:00005F6C ; Attributes: bp-based frame
.text$mn:00005F6C
.text$mn:00005F6C ; public: class std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>> & __thiscall std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>::operator++(void)
.text$mn:00005F6C                 public ??E?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAEAAV01@XZ
.text$mn:00005F6C ??E?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAEAAV01@XZ proc near
.text$mn:00005F6C                                         ; CODE XREF: std::_Uninit_copy<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::allocator<uchar>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Nonscalar_ptr_iterator_tag)+B3p
.text$mn:00005F6C
.text$mn:00005F6C var_4           = dword ptr -4
.text$mn:00005F6C
.text$mn:00005F6C                 push    ebp
.text$mn:00005F6D                 mov     ebp, esp
.text$mn:00005F6F                 push    ecx
.text$mn:00005F70                 mov     [ebp+var_4], ecx
.text$mn:00005F73                 mov     ecx, [ebp+var_4]
.text$mn:00005F76                 call    ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)
.text$mn:00005F7B                 mov     eax, [ebp+var_4]
.text$mn:00005F7E                 mov     esp, ebp
.text$mn:00005F80                 pop     ebp
.text$mn:00005F81                 retn
.text$mn:00005F81 ??E?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAEAAV01@XZ endp
.text$mn:00005F81
.text$mn:00005F81 ; ---------------------------------------------------------------------------
.text$mn:00005F82                 align 4
.text$mn:00005F82 _text$mn        ends
.text$mn:00005F82
.text$mn:00005F84 ; ===========================================================================
.text$mn:00005F84
.text$mn:00005F84 ; Segment type: Pure code
.text$mn:00005F84 ; Segment permissions: Read/Execute
.text$mn:00005F84 _text$mn        segment para public 'CODE' use32
.text$mn:00005F84                 assume cs:_text$mn
.text$mn:00005F84                 ;org 5F84h
.text$mn:00005F84 ; COMDAT (pick any)
.text$mn:00005F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005F84
.text$mn:00005F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00005F84
.text$mn:00005F84 ; Attributes: bp-based frame
.text$mn:00005F84
.text$mn:00005F84 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::operator-(std::_Iterator_base12 *)
.text$mn:00005F84                 public ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z
.text$mn:00005F84 ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z proc near
.text$mn:00005F84                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+Ep
.text$mn:00005F84
.text$mn:00005F84 var_4           = dword ptr -4
.text$mn:00005F84 arg_0           = dword ptr  8
.text$mn:00005F84
.text$mn:00005F84                 push    ebp
.text$mn:00005F85                 mov     ebp, esp
.text$mn:00005F87                 push    ecx
.text$mn:00005F88                 mov     [ebp+var_4], ecx
.text$mn:00005F8B                 mov     eax, [ebp+arg_0]
.text$mn:00005F8E                 push    eax             ; std::_Iterator_base12 *
.text$mn:00005F8F                 mov     ecx, [ebp+var_4]
.text$mn:00005F92                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00005F97                 mov     ecx, [ebp+var_4]
.text$mn:00005F9A                 mov     edx, [ebp+arg_0]
.text$mn:00005F9D                 mov     eax, [ecx+8]
.text$mn:00005FA0                 sub     eax, [edx+8]
.text$mn:00005FA3                 mov     esp, ebp
.text$mn:00005FA5                 pop     ebp
.text$mn:00005FA6                 retn    4
.text$mn:00005FA6 ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z endp
.text$mn:00005FA6
.text$mn:00005FA6 ; ---------------------------------------------------------------------------
.text$mn:00005FA9                 align 4
.text$mn:00005FA9 _text$mn        ends
.text$mn:00005FA9
.text$mn:00005FAC ; ===========================================================================
.text$mn:00005FAC
.text$mn:00005FAC ; Segment type: Pure code
.text$mn:00005FAC ; Segment permissions: Read/Execute
.text$mn:00005FAC _text$mn        segment para public 'CODE' use32
.text$mn:00005FAC                 assume cs:_text$mn
.text$mn:00005FAC                 ;org 5FACh
.text$mn:00005FAC ; COMDAT (pick any)
.text$mn:00005FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FAC
.text$mn:00005FAC ; =============== S U B R O U T I N E =======================================
.text$mn:00005FAC
.text$mn:00005FAC ; Attributes: bp-based frame
.text$mn:00005FAC
.text$mn:00005FAC ; int __stdcall std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::operator-(std::_Iterator_base12 *)
.text$mn:00005FAC                 public ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z
.text$mn:00005FAC ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z proc near
.text$mn:00005FAC                                         ; CODE XREF: std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+61p
.text$mn:00005FAC
.text$mn:00005FAC var_4           = dword ptr -4
.text$mn:00005FAC arg_0           = dword ptr  8
.text$mn:00005FAC
.text$mn:00005FAC                 push    ebp
.text$mn:00005FAD                 mov     ebp, esp
.text$mn:00005FAF                 push    ecx
.text$mn:00005FB0                 mov     [ebp+var_4], ecx
.text$mn:00005FB3                 mov     eax, [ebp+arg_0]
.text$mn:00005FB6                 push    eax             ; std::_Iterator_base12 *
.text$mn:00005FB7                 mov     ecx, [ebp+var_4]
.text$mn:00005FBA                 call    ??G?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00005FBF                 mov     esp, ebp
.text$mn:00005FC1                 pop     ebp
.text$mn:00005FC2                 retn    4
.text$mn:00005FC2 ??G?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEHABV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z endp
.text$mn:00005FC2
.text$mn:00005FC2 ; ---------------------------------------------------------------------------
.text$mn:00005FC5                 align 4
.text$mn:00005FC5 _text$mn        ends
.text$mn:00005FC5
.text$mn:00005FC8 ; ===========================================================================
.text$mn:00005FC8
.text$mn:00005FC8 ; Segment type: Pure code
.text$mn:00005FC8 ; Segment permissions: Read/Execute
.text$mn:00005FC8 _text$mn        segment para public 'CODE' use32
.text$mn:00005FC8                 assume cs:_text$mn
.text$mn:00005FC8                 ;org 5FC8h
.text$mn:00005FC8 ; COMDAT (pick any)
.text$mn:00005FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00005FC8
.text$mn:00005FC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00005FC8
.text$mn:00005FC8 ; Attributes: bp-based frame
.text$mn:00005FC8
.text$mn:00005FC8 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>::operator+(int)const
.text$mn:00005FC8                 public ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00005FC8 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$mn:00005FC8                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+B6p
.text$mn:00005FC8                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+447p
.text$mn:00005FC8
.text$mn:00005FC8 var_20          = byte ptr -20h
.text$mn:00005FC8 var_14          = dword ptr -14h
.text$mn:00005FC8 var_10          = dword ptr -10h
.text$mn:00005FC8 var_C           = dword ptr -0Ch
.text$mn:00005FC8 var_4           = dword ptr -4
.text$mn:00005FC8 arg_0           = dword ptr  8
.text$mn:00005FC8 arg_4           = dword ptr  0Ch
.text$mn:00005FC8
.text$mn:00005FC8                 push    ebp
.text$mn:00005FC9                 mov     ebp, esp
.text$mn:00005FCB                 push    0FFFFFFFFh
.text$mn:00005FCD                 push    offset __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$mn:00005FD2                 mov     eax, large fs:0
.text$mn:00005FD8                 push    eax
.text$mn:00005FD9                 sub     esp, 14h
.text$mn:00005FDC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00005FE1                 xor     eax, ebp
.text$mn:00005FE3                 push    eax
.text$mn:00005FE4                 lea     eax, [ebp+var_C]
.text$mn:00005FE7                 mov     large fs:0, eax
.text$mn:00005FED                 mov     [ebp+var_14], ecx
.text$mn:00005FF0                 mov     [ebp+var_10], 0
.text$mn:00005FF7                 mov     eax, [ebp+var_14]
.text$mn:00005FFA                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00005FFB                 lea     ecx, [ebp+var_20]
.text$mn:00005FFE                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)
.text$mn:00006003                 mov     [ebp+var_4], 1
.text$mn:0000600A                 mov     ecx, [ebp+arg_4]
.text$mn:0000600D                 push    ecx
.text$mn:0000600E                 lea     ecx, [ebp+var_20]
.text$mn:00006011                 call    ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)
.text$mn:00006016                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00006017                 mov     ecx, [ebp+arg_0]
.text$mn:0000601A                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)
.text$mn:0000601F                 mov     edx, [ebp+var_10]
.text$mn:00006022                 or      edx, 1
.text$mn:00006025                 mov     [ebp+var_10], edx
.text$mn:00006028                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000602C                 lea     ecx, [ebp+var_20]
.text$mn:0000602F                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:00006034                 mov     eax, [ebp+arg_0]
.text$mn:00006037                 mov     ecx, [ebp+var_C]
.text$mn:0000603A                 mov     large fs:0, ecx
.text$mn:00006041                 pop     ecx
.text$mn:00006042                 mov     esp, ebp
.text$mn:00006044                 pop     ebp
.text$mn:00006045                 retn    8
.text$mn:00006045 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$mn:00006045
.text$mn:00006045 _text$mn        ends
.text$mn:00006045
.text$x:00006048 ; ===========================================================================
.text$x:00006048
.text$x:00006048 ; Segment type: Pure code
.text$x:00006048 ; Segment permissions: Read/Execute
.text$x:00006048 _text$x         segment para public 'CODE' use32
.text$x:00006048                 assume cs:_text$x
.text$x:00006048                 ;org 6048h
.text$x:00006048 ; COMDAT (pick associative to section at 5FC8)
.text$x:00006048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006048
.text$x:00006048 ; =============== S U B R O U T I N E =======================================
.text$x:00006048
.text$x:00006048
.text$x:00006048 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$0 proc near
.text$x:00006048                                         ; DATA XREF: .xdata$x:00009B1Co
.text$x:00006048                 lea     ecx, [ebp-20h]
.text$x:0000604B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:0000604B __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$0 endp
.text$x:0000604B
.text$x:00006050
.text$x:00006050 ; =============== S U B R O U T I N E =======================================
.text$x:00006050
.text$x:00006050
.text$x:00006050 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1 proc near
.text$x:00006050                                         ; DATA XREF: .xdata$x:00009B14o
.text$x:00006050                 mov     eax, [ebp-10h]
.text$x:00006053                 and     eax, 1
.text$x:00006056                 jz      $LN5_0
.text$x:0000605C                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00006060                 mov     ecx, [ebp+8]
.text$x:00006063                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00006068 ; ---------------------------------------------------------------------------
.text$x:00006068
.text$x:00006068 $LN5_0:                                 ; CODE XREF: __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1+6j
.text$x:00006068                 retn
.text$x:00006068 __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1 endp
.text$x:00006068
.text$x:00006069
.text$x:00006069 ; =============== S U B R O U T I N E =======================================
.text$x:00006069
.text$x:00006069
.text$x:00006069 __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z proc near
.text$x:00006069                                         ; DATA XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+(int)+5o
.text$x:00006069
.text$x:00006069 arg_4           = dword ptr  8
.text$x:00006069
.text$x:00006069                 mov     edx, [esp+arg_4]
.text$x:0000606D                 lea     eax, [edx+0Ch]
.text$x:00006070                 mov     ecx, [edx-18h]
.text$x:00006073                 xor     ecx, eax
.text$x:00006075                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000607A                 mov     eax, offset __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.text$x:0000607F                 jmp     ___CxxFrameHandler3
.text$x:0000607F __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z endp
.text$x:0000607F
.text$x:0000607F _text$x         ends
.text$x:0000607F
.text$mn:00006084 ; ===========================================================================
.text$mn:00006084
.text$mn:00006084 ; Segment type: Pure code
.text$mn:00006084 ; Segment permissions: Read/Execute
.text$mn:00006084 _text$mn        segment para public 'CODE' use32
.text$mn:00006084                 assume cs:_text$mn
.text$mn:00006084                 ;org 6084h
.text$mn:00006084 ; COMDAT (pick any)
.text$mn:00006084                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006084
.text$mn:00006084 ; =============== S U B R O U T I N E =======================================
.text$mn:00006084
.text$mn:00006084 ; Attributes: bp-based frame
.text$mn:00006084
.text$mn:00006084 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::operator<(std::_Iterator_base12 *)
.text$mn:00006084                 public ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z
.text$mn:00006084 ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z proc near
.text$mn:00006084                                         ; CODE XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::_Less<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+4Bp
.text$mn:00006084
.text$mn:00006084 var_8           = dword ptr -8
.text$mn:00006084 var_4           = dword ptr -4
.text$mn:00006084 arg_0           = dword ptr  8
.text$mn:00006084
.text$mn:00006084                 push    ebp
.text$mn:00006085                 mov     ebp, esp
.text$mn:00006087                 sub     esp, 8
.text$mn:0000608A                 mov     [ebp+var_4], ecx
.text$mn:0000608D                 mov     eax, [ebp+arg_0]
.text$mn:00006090                 push    eax             ; std::_Iterator_base12 *
.text$mn:00006091                 mov     ecx, [ebp+var_4]
.text$mn:00006094                 call    ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00006099                 mov     ecx, [ebp+var_4]
.text$mn:0000609C                 mov     edx, [ebp+arg_0]
.text$mn:0000609F                 mov     eax, [ecx+8]
.text$mn:000060A2                 cmp     eax, [edx+8]
.text$mn:000060A5                 jnb     short loc_60B0
.text$mn:000060A7                 mov     [ebp+var_8], 1
.text$mn:000060AE                 jmp     short loc_60B7
.text$mn:000060B0 ; ---------------------------------------------------------------------------
.text$mn:000060B0
.text$mn:000060B0 loc_60B0:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+21j
.text$mn:000060B0                 mov     [ebp+var_8], 0
.text$mn:000060B7
.text$mn:000060B7 loc_60B7:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator<(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+2Aj
.text$mn:000060B7                 mov     al, byte ptr [ebp+var_8]
.text$mn:000060BA                 mov     esp, ebp
.text$mn:000060BC                 pop     ebp
.text$mn:000060BD                 retn    4
.text$mn:000060BD ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBE_NABV01@@Z endp
.text$mn:000060BD
.text$mn:000060BD _text$mn        ends
.text$mn:000060BD
.text$mn:000060C0 ; ===========================================================================
.text$mn:000060C0
.text$mn:000060C0 ; Segment type: Pure code
.text$mn:000060C0 ; Segment permissions: Read/Execute
.text$mn:000060C0 _text$mn        segment para public 'CODE' use32
.text$mn:000060C0                 assume cs:_text$mn
.text$mn:000060C0                 ;org 60C0h
.text$mn:000060C0 ; COMDAT (pick any)
.text$mn:000060C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000060C0
.text$mn:000060C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000060C0
.text$mn:000060C0 ; Attributes: bp-based frame
.text$mn:000060C0
.text$mn:000060C0 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> & __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>::operator+=(int)
.text$mn:000060C0                 public ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:000060C0 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:000060C0                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+Ep
.text$mn:000060C0
.text$mn:000060C0 var_4           = dword ptr -4
.text$mn:000060C0 arg_0           = dword ptr  8
.text$mn:000060C0
.text$mn:000060C0                 push    ebp
.text$mn:000060C1                 mov     ebp, esp
.text$mn:000060C3                 push    ecx
.text$mn:000060C4                 push    esi
.text$mn:000060C5                 mov     [ebp+var_4], ecx
.text$mn:000060C8                 mov     ecx, [ebp+var_4] ; this
.text$mn:000060CB                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000060D0                 test    eax, eax
.text$mn:000060D2                 jz      short loc_6106
.text$mn:000060D4                 mov     esi, [ebp+arg_0]
.text$mn:000060D7                 shl     esi, 4
.text$mn:000060DA                 mov     eax, [ebp+var_4]
.text$mn:000060DD                 add     esi, [eax+8]
.text$mn:000060E0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000060E3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000060E8                 cmp     esi, [eax+4]
.text$mn:000060EB                 jb      short loc_6106
.text$mn:000060ED                 mov     ecx, [ebp+var_4] ; this
.text$mn:000060F0                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000060F5                 mov     ecx, [ebp+arg_0]
.text$mn:000060F8                 shl     ecx, 4
.text$mn:000060FB                 mov     edx, [ebp+var_4]
.text$mn:000060FE                 add     ecx, [edx+8]
.text$mn:00006101                 cmp     [eax+8], ecx
.text$mn:00006104                 jnb     short loc_616E
.text$mn:00006106
.text$mn:00006106 loc_6106:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+12j
.text$mn:00006106                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+2Bj
.text$mn:00006106                 push    9Fh ; 'ƒ'       ; unsigned int
.text$mn:0000610B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006110                 push    offset ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@ ; "vector iterator + offset out of range"
.text$mn:00006115                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:0000611A                 add     esp, 0Ch
.text$mn:0000611D                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00006122                 test    eax, eax
.text$mn:00006124                 jz      short loc_612A
.text$mn:00006126                 xor     ecx, ecx
.text$mn:00006128                 jnz     short loc_6150
.text$mn:0000612A
.text$mn:0000612A loc_612A:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+64j
.text$mn:0000612A                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:0000612F                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00006134                 push    0
.text$mn:00006136                 push    0A0h ; 'á'
.text$mn:0000613B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006140                 push    2
.text$mn:00006142                 call    __CrtDbgReportW
.text$mn:00006147                 add     esp, 18h
.text$mn:0000614A                 cmp     eax, 1
.text$mn:0000614D                 jnz     short loc_6150
.text$mn:0000614F                 int     3               ; Trap to Debugger
.text$mn:00006150
.text$mn:00006150 loc_6150:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+68j
.text$mn:00006150                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+8Dj
.text$mn:00006150                 push    0
.text$mn:00006152                 push    0A0h ; 'á'
.text$mn:00006157                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000615C                 push    offset ??_C@_1BEM@BNCMPMLI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00006161                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:00006166                 call    __invalid_parameter
.text$mn:0000616B                 add     esp, 14h
.text$mn:0000616E
.text$mn:0000616E loc_616E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+44j
.text$mn:0000616E                 mov     eax, [ebp+arg_0]
.text$mn:00006171                 shl     eax, 4
.text$mn:00006174                 mov     ecx, [ebp+var_4]
.text$mn:00006177                 add     eax, [ecx+8]
.text$mn:0000617A                 mov     edx, [ebp+var_4]
.text$mn:0000617D                 mov     [edx+8], eax
.text$mn:00006180                 mov     eax, [ebp+var_4]
.text$mn:00006183                 pop     esi
.text$mn:00006184                 mov     esp, ebp
.text$mn:00006186                 pop     ebp
.text$mn:00006187                 retn    4
.text$mn:00006187 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:00006187
.text$mn:00006187 ; ---------------------------------------------------------------------------
.text$mn:0000618A                 align 4
.text$mn:0000618A _text$mn        ends
.text$mn:0000618A
.text$mn:0000618C ; ===========================================================================
.text$mn:0000618C
.text$mn:0000618C ; Segment type: Pure code
.text$mn:0000618C ; Segment permissions: Read/Execute
.text$mn:0000618C _text$mn        segment para public 'CODE' use32
.text$mn:0000618C                 assume cs:_text$mn
.text$mn:0000618C                 ;org 618Ch
.text$mn:0000618C ; COMDAT (pick any)
.text$mn:0000618C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000618C
.text$mn:0000618C ; =============== S U B R O U T I N E =======================================
.text$mn:0000618C
.text$mn:0000618C ; Attributes: bp-based frame
.text$mn:0000618C
.text$mn:0000618C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> & __thiscall std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>::operator+=(int)
.text$mn:0000618C                 public ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z
.text$mn:0000618C ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z proc near
.text$mn:0000618C                                         ; CODE XREF: std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+(int)+49p
.text$mn:0000618C
.text$mn:0000618C var_4           = dword ptr -4
.text$mn:0000618C arg_0           = dword ptr  8
.text$mn:0000618C
.text$mn:0000618C                 push    ebp
.text$mn:0000618D                 mov     ebp, esp
.text$mn:0000618F                 push    ecx
.text$mn:00006190                 mov     [ebp+var_4], ecx
.text$mn:00006193                 mov     eax, [ebp+arg_0]
.text$mn:00006196                 push    eax
.text$mn:00006197                 mov     ecx, [ebp+var_4]
.text$mn:0000619A                 call    ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)
.text$mn:0000619F                 mov     eax, [ebp+var_4]
.text$mn:000061A2                 mov     esp, ebp
.text$mn:000061A4                 pop     ebp
.text$mn:000061A5                 retn    4
.text$mn:000061A5 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAEAAV01@H@Z endp
.text$mn:000061A5
.text$mn:000061A5 _text$mn        ends
.text$mn:000061A5
.text$mn:000061A8 ; ===========================================================================
.text$mn:000061A8
.text$mn:000061A8 ; Segment type: Pure code
.text$mn:000061A8 ; Segment permissions: Read/Execute
.text$mn:000061A8 _text$mn        segment para public 'CODE' use32
.text$mn:000061A8                 assume cs:_text$mn
.text$mn:000061A8                 ;org 61A8h
.text$mn:000061A8 ; COMDAT (pick any)
.text$mn:000061A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061A8
.text$mn:000061A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000061A8
.text$mn:000061A8 ; Attributes: bp-based frame
.text$mn:000061A8
.text$mn:000061A8 ; public: void * __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::`scalar deleting destructor'(unsigned int)
.text$mn:000061A8                 public ??_G?$vector@EV?$allocator@E@std@@@std@@QAEPAXI@Z
.text$mn:000061A8 ??_G?$vector@EV?$allocator@E@std@@@std@@QAEPAXI@Z proc near
.text$mn:000061A8                                         ; CODE XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::destroy<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *)+Cp
.text$mn:000061A8
.text$mn:000061A8 var_4           = dword ptr -4
.text$mn:000061A8 arg_0           = dword ptr  8
.text$mn:000061A8
.text$mn:000061A8                 push    ebp
.text$mn:000061A9                 mov     ebp, esp
.text$mn:000061AB                 push    ecx
.text$mn:000061AC                 mov     [ebp+var_4], ecx
.text$mn:000061AF                 mov     ecx, [ebp+var_4]
.text$mn:000061B2                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:000061B7                 mov     eax, [ebp+arg_0]
.text$mn:000061BA                 and     eax, 1
.text$mn:000061BD                 jz      short loc_61CB
.text$mn:000061BF                 mov     ecx, [ebp+var_4]
.text$mn:000061C2                 push    ecx             ; void *
.text$mn:000061C3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000061C8                 add     esp, 4
.text$mn:000061CB
.text$mn:000061CB loc_61CB:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::`scalar deleting destructor'(uint)+15j
.text$mn:000061CB                 mov     eax, [ebp+var_4]
.text$mn:000061CE                 mov     esp, ebp
.text$mn:000061D0                 pop     ebp
.text$mn:000061D1                 retn    4
.text$mn:000061D1 ??_G?$vector@EV?$allocator@E@std@@@std@@QAEPAXI@Z endp
.text$mn:000061D1
.text$mn:000061D1 _text$mn        ends
.text$mn:000061D1
.text$mn:000061D4 ; ===========================================================================
.text$mn:000061D4
.text$mn:000061D4 ; Segment type: Pure code
.text$mn:000061D4 ; Segment permissions: Read/Execute
.text$mn:000061D4 _text$mn        segment para public 'CODE' use32
.text$mn:000061D4                 assume cs:_text$mn
.text$mn:000061D4                 ;org 61D4h
.text$mn:000061D4 ; COMDAT (pick any)
.text$mn:000061D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000061D4
.text$mn:000061D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000061D4
.text$mn:000061D4 ; Attributes: bp-based frame
.text$mn:000061D4
.text$mn:000061D4 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:000061D4                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:000061D4 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:000061D4
.text$mn:000061D4 var_4           = dword ptr -4
.text$mn:000061D4 arg_0           = dword ptr  8
.text$mn:000061D4
.text$mn:000061D4                 push    ebp
.text$mn:000061D5                 mov     ebp, esp
.text$mn:000061D7                 push    ecx
.text$mn:000061D8                 mov     [ebp+var_4], ecx
.text$mn:000061DB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000061DE                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:000061E3                 mov     eax, [ebp+arg_0]
.text$mn:000061E6                 and     eax, 1
.text$mn:000061E9                 jz      short loc_61F7
.text$mn:000061EB                 mov     ecx, [ebp+var_4]
.text$mn:000061EE                 push    ecx             ; void *
.text$mn:000061EF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000061F4                 add     esp, 4
.text$mn:000061F7
.text$mn:000061F7 loc_61F7:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000061F7                 mov     eax, [ebp+var_4]
.text$mn:000061FA                 mov     esp, ebp
.text$mn:000061FC                 pop     ebp
.text$mn:000061FD                 retn    4
.text$mn:000061FD ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:000061FD
.text$mn:000061FD _text$mn        ends
.text$mn:000061FD
.text$mn:00006200 ; ===========================================================================
.text$mn:00006200
.text$mn:00006200 ; Segment type: Pure code
.text$mn:00006200 ; Segment permissions: Read/Execute
.text$mn:00006200 _text$mn        segment para public 'CODE' use32
.text$mn:00006200                 assume cs:_text$mn
.text$mn:00006200                 ;org 6200h
.text$mn:00006200 ; COMDAT (pick any)
.text$mn:00006200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006200
.text$mn:00006200 ; =============== S U B R O U T I N E =======================================
.text$mn:00006200
.text$mn:00006200 ; Attributes: bp-based frame
.text$mn:00006200
.text$mn:00006200 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00006200                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00006200 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00006200
.text$mn:00006200 var_4           = dword ptr -4
.text$mn:00006200 arg_0           = dword ptr  8
.text$mn:00006200
.text$mn:00006200                 push    ebp
.text$mn:00006201                 mov     ebp, esp
.text$mn:00006203                 push    ecx
.text$mn:00006204                 mov     [ebp+var_4], ecx
.text$mn:00006207                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000620A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000620F                 mov     eax, [ebp+arg_0]
.text$mn:00006212                 and     eax, 1
.text$mn:00006215                 jz      short loc_6223
.text$mn:00006217                 mov     ecx, [ebp+var_4]
.text$mn:0000621A                 push    ecx             ; void *
.text$mn:0000621B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006220                 add     esp, 4
.text$mn:00006223
.text$mn:00006223 loc_6223:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00006223                 mov     eax, [ebp+var_4]
.text$mn:00006226                 mov     esp, ebp
.text$mn:00006228                 pop     ebp
.text$mn:00006229                 retn    4
.text$mn:00006229 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00006229
.text$mn:00006229 _text$mn        ends
.text$mn:00006229
.text$mn:0000622C ; ===========================================================================
.text$mn:0000622C
.text$mn:0000622C ; Segment type: Pure code
.text$mn:0000622C ; Segment permissions: Read/Execute
.text$mn:0000622C _text$mn        segment para public 'CODE' use32
.text$mn:0000622C                 assume cs:_text$mn
.text$mn:0000622C                 ;org 622Ch
.text$mn:0000622C ; COMDAT (pick any)
.text$mn:0000622C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000622C
.text$mn:0000622C ; =============== S U B R O U T I N E =======================================
.text$mn:0000622C
.text$mn:0000622C ; Attributes: bp-based frame
.text$mn:0000622C
.text$mn:0000622C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000622C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000622C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000622C
.text$mn:0000622C var_4           = dword ptr -4
.text$mn:0000622C arg_0           = dword ptr  8
.text$mn:0000622C
.text$mn:0000622C                 push    ebp
.text$mn:0000622D                 mov     ebp, esp
.text$mn:0000622F                 push    ecx
.text$mn:00006230                 mov     [ebp+var_4], ecx
.text$mn:00006233                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006236                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000623B                 mov     eax, [ebp+arg_0]
.text$mn:0000623E                 and     eax, 1
.text$mn:00006241                 jz      short loc_624F
.text$mn:00006243                 mov     ecx, [ebp+var_4]
.text$mn:00006246                 push    ecx             ; void *
.text$mn:00006247                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000624C                 add     esp, 4
.text$mn:0000624F
.text$mn:0000624F loc_624F:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000624F                 mov     eax, [ebp+var_4]
.text$mn:00006252                 mov     esp, ebp
.text$mn:00006254                 pop     ebp
.text$mn:00006255                 retn    4
.text$mn:00006255 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00006255
.text$mn:00006255 _text$mn        ends
.text$mn:00006255
.text$mn:00006258 ; ===========================================================================
.text$mn:00006258
.text$mn:00006258 ; Segment type: Pure code
.text$mn:00006258 ; Segment permissions: Read/Execute
.text$mn:00006258 _text$mn        segment para public 'CODE' use32
.text$mn:00006258                 assume cs:_text$mn
.text$mn:00006258                 ;org 6258h
.text$mn:00006258 ; COMDAT (pick any)
.text$mn:00006258                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006258
.text$mn:00006258 ; =============== S U B R O U T I N E =======================================
.text$mn:00006258
.text$mn:00006258 ; Attributes: bp-based frame
.text$mn:00006258
.text$mn:00006258 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00006258                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00006258 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00006258
.text$mn:00006258 var_4           = dword ptr -4
.text$mn:00006258 arg_0           = dword ptr  8
.text$mn:00006258
.text$mn:00006258                 push    ebp
.text$mn:00006259                 mov     ebp, esp
.text$mn:0000625B                 push    ecx
.text$mn:0000625C                 mov     [ebp+var_4], ecx
.text$mn:0000625F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006262                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00006267                 mov     eax, [ebp+arg_0]
.text$mn:0000626A                 and     eax, 1
.text$mn:0000626D                 jz      short loc_627B
.text$mn:0000626F                 mov     ecx, [ebp+var_4]
.text$mn:00006272                 push    ecx             ; void *
.text$mn:00006273                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00006278                 add     esp, 4
.text$mn:0000627B
.text$mn:0000627B loc_627B:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000627B                 mov     eax, [ebp+var_4]
.text$mn:0000627E                 mov     esp, ebp
.text$mn:00006280                 pop     ebp
.text$mn:00006281                 retn    4
.text$mn:00006281 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00006281
.text$mn:00006281 _text$mn        ends
.text$mn:00006281
.text$di:00006284 ; ===========================================================================
.text$di:00006284
.text$di:00006284 ; Segment type: Pure code
.text$di:00006284 ; Segment permissions: Read/Execute
.text$di:00006284 _text$di        segment para public 'CODE' use32
.text$di:00006284                 assume cs:_text$di
.text$di:00006284                 ;org 6284h
.text$di:00006284 ; COMDAT (pick any)
.text$di:00006284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00006284
.text$di:00006284 ; =============== S U B R O U T I N E =======================================
.text$di:00006284
.text$di:00006284 ; Attributes: bp-based frame
.text$di:00006284
.text$di:00006284 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00006284 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00006284                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00006284                 push    ebp
.text$di:00006285                 mov     ebp, esp
.text$di:00006287                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:0000628C                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00006291                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00006296                 call    _atexit
.text$di:0000629B                 add     esp, 4
.text$di:0000629E                 pop     ebp
.text$di:0000629F                 retn
.text$di:0000629F ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:0000629F
.text$di:0000629F _text$di        ends
.text$di:0000629F
.text$di:000062A0 ; ===========================================================================
.text$di:000062A0
.text$di:000062A0 ; Segment type: Pure code
.text$di:000062A0 ; Segment permissions: Read/Execute
.text$di:000062A0 _text$di        segment para public 'CODE' use32
.text$di:000062A0                 assume cs:_text$di
.text$di:000062A0                 ;org 62A0h
.text$di:000062A0 ; COMDAT (pick any)
.text$di:000062A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000062A0
.text$di:000062A0 ; =============== S U B R O U T I N E =======================================
.text$di:000062A0
.text$di:000062A0 ; Attributes: bp-based frame
.text$di:000062A0
.text$di:000062A0 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:000062A0 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:000062A0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:000062A0                 push    ebp
.text$di:000062A1                 mov     ebp, esp
.text$di:000062A3                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:000062A8                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:000062AD                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000062B2                 call    _atexit
.text$di:000062B7                 add     esp, 4
.text$di:000062BA                 pop     ebp
.text$di:000062BB                 retn
.text$di:000062BB ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:000062BB
.text$di:000062BB _text$di        ends
.text$di:000062BB
.text$di:000062BC ; ===========================================================================
.text$di:000062BC
.text$di:000062BC ; Segment type: Pure code
.text$di:000062BC ; Segment permissions: Read/Execute
.text$di:000062BC _text$di        segment para public 'CODE' use32
.text$di:000062BC                 assume cs:_text$di
.text$di:000062BC                 ;org 62BCh
.text$di:000062BC ; COMDAT (pick any)
.text$di:000062BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000062BC
.text$di:000062BC ; =============== S U B R O U T I N E =======================================
.text$di:000062BC
.text$di:000062BC ; Attributes: bp-based frame
.text$di:000062BC
.text$di:000062BC ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:000062BC ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:000062BC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:000062BC                 push    ebp
.text$di:000062BD                 mov     ebp, esp
.text$di:000062BF                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:000062C4                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:000062C9                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:000062CE                 call    _atexit
.text$di:000062D3                 add     esp, 4
.text$di:000062D6                 pop     ebp
.text$di:000062D7                 retn
.text$di:000062D7 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:000062D7
.text$di:000062D7 _text$di        ends
.text$di:000062D7
.text$di:000062D8 ; ===========================================================================
.text$di:000062D8
.text$di:000062D8 ; Segment type: Pure code
.text$di:000062D8 ; Segment permissions: Read/Execute
.text$di:000062D8 _text$di        segment para public 'CODE' use32
.text$di:000062D8                 assume cs:_text$di
.text$di:000062D8                 ;org 62D8h
.text$di:000062D8 ; COMDAT (pick any)
.text$di:000062D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000062D8
.text$di:000062D8 ; =============== S U B R O U T I N E =======================================
.text$di:000062D8
.text$di:000062D8 ; Attributes: bp-based frame
.text$di:000062D8
.text$di:000062D8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:000062D8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000062D8                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:000062D8                 push    ebp
.text$di:000062D9                 mov     ebp, esp
.text$di:000062DB                 push    0               ; unsigned int
.text$di:000062DD                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000062E2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000062E7                 pop     ebp
.text$di:000062E8                 retn
.text$di:000062E8 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000062E8
.text$di:000062E8 ; ---------------------------------------------------------------------------
.text$di:000062E9                 align 4
.text$di:000062E9 _text$di        ends
.text$di:000062E9
.text$di:000062EC ; ===========================================================================
.text$di:000062EC
.text$di:000062EC ; Segment type: Pure code
.text$di:000062EC ; Segment permissions: Read/Execute
.text$di:000062EC _text$di        segment para public 'CODE' use32
.text$di:000062EC                 assume cs:_text$di
.text$di:000062EC                 ;org 62ECh
.text$di:000062EC ; COMDAT (pick any)
.text$di:000062EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000062EC
.text$di:000062EC ; =============== S U B R O U T I N E =======================================
.text$di:000062EC
.text$di:000062EC ; Attributes: bp-based frame
.text$di:000062EC
.text$di:000062EC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:000062EC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:000062EC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:000062EC                 push    ebp
.text$di:000062ED                 mov     ebp, esp
.text$di:000062EF                 push    0               ; unsigned int
.text$di:000062F1                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:000062F6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:000062FB                 pop     ebp
.text$di:000062FC                 retn
.text$di:000062FC ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:000062FC
.text$di:000062FC ; ---------------------------------------------------------------------------
.text$di:000062FD                 align 10h
.text$di:000062FD _text$di        ends
.text$di:000062FD
.text$di:00006300 ; ===========================================================================
.text$di:00006300
.text$di:00006300 ; Segment type: Pure code
.text$di:00006300 ; Segment permissions: Read/Execute
.text$di:00006300 _text$di        segment para public 'CODE' use32
.text$di:00006300                 assume cs:_text$di
.text$di:00006300                 ;org 6300h
.text$di:00006300 ; COMDAT (pick any)
.text$di:00006300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00006300
.text$di:00006300 ; =============== S U B R O U T I N E =======================================
.text$di:00006300
.text$di:00006300 ; Attributes: bp-based frame
.text$di:00006300
.text$di:00006300 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00006300 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00006300                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00006300                 push    ebp
.text$di:00006301                 mov     ebp, esp
.text$di:00006303                 push    0               ; unsigned int
.text$di:00006305                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:0000630A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:0000630F                 pop     ebp
.text$di:00006310                 retn
.text$di:00006310 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00006310
.text$di:00006310 ; ---------------------------------------------------------------------------
.text$di:00006311                 align 4
.text$di:00006311 _text$di        ends
.text$di:00006311
.text$di:00006314 ; ===========================================================================
.text$di:00006314
.text$di:00006314 ; Segment type: Pure code
.text$di:00006314 ; Segment permissions: Read/Execute
.text$di:00006314 _text$di        segment para public 'CODE' use32
.text$di:00006314                 assume cs:_text$di
.text$di:00006314                 ;org 6314h
.text$di:00006314 ; COMDAT (pick any)
.text$di:00006314                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00006314
.text$di:00006314 ; =============== S U B R O U T I N E =======================================
.text$di:00006314
.text$di:00006314 ; Attributes: bp-based frame
.text$di:00006314
.text$di:00006314 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00006314 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00006314                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00006314                 push    ebp
.text$di:00006315                 mov     ebp, esp
.text$di:00006317                 push    0               ; unsigned int
.text$di:00006319                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:0000631E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00006323                 pop     ebp
.text$di:00006324                 retn
.text$di:00006324 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00006324
.text$di:00006324 ; ---------------------------------------------------------------------------
.text$di:00006325                 align 4
.text$di:00006325 _text$di        ends
.text$di:00006325
.text$di:00006328 ; ===========================================================================
.text$di:00006328
.text$di:00006328 ; Segment type: Pure code
.text$di:00006328 ; Segment permissions: Read/Execute
.text$di:00006328 _text$di        segment para public 'CODE' use32
.text$di:00006328                 assume cs:_text$di
.text$di:00006328                 ;org 6328h
.text$di:00006328 ; COMDAT (pick any)
.text$di:00006328                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00006328
.text$di:00006328 ; =============== S U B R O U T I N E =======================================
.text$di:00006328
.text$di:00006328 ; Attributes: bp-based frame
.text$di:00006328
.text$di:00006328 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00006328 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00006328
.text$di:00006328 var_1           = byte ptr -1
.text$di:00006328
.text$di:00006328                 push    ebp
.text$di:00006329                 mov     ebp, esp
.text$di:0000632B                 push    ecx
.text$di:0000632C                 xor     eax, eax
.text$di:0000632E                 mov     [ebp+var_1], al
.text$di:00006331                 mov     esp, ebp
.text$di:00006333                 pop     ebp
.text$di:00006334                 retn
.text$di:00006334 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00006334
.text$di:00006334 ; ---------------------------------------------------------------------------
.text$di:00006335                 align 4
.text$di:00006335 _text$di        ends
.text$di:00006335
.text$di:00006338 ; ===========================================================================
.text$di:00006338
.text$di:00006338 ; Segment type: Pure code
.text$di:00006338 ; Segment permissions: Read/Execute
.text$di:00006338 _text$di        segment para public 'CODE' use32
.text$di:00006338                 assume cs:_text$di
.text$di:00006338                 ;org 6338h
.text$di:00006338 ; COMDAT (pick any)
.text$di:00006338                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00006338
.text$di:00006338 ; =============== S U B R O U T I N E =======================================
.text$di:00006338
.text$di:00006338 ; Attributes: bp-based frame
.text$di:00006338
.text$di:00006338 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00006338 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00006338
.text$di:00006338 var_1           = byte ptr -1
.text$di:00006338
.text$di:00006338                 push    ebp
.text$di:00006339                 mov     ebp, esp
.text$di:0000633B                 push    ecx
.text$di:0000633C                 xor     eax, eax
.text$di:0000633E                 mov     [ebp+var_1], al
.text$di:00006341                 mov     esp, ebp
.text$di:00006343                 pop     ebp
.text$di:00006344                 retn
.text$di:00006344 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00006344
.text$di:00006344 ; ---------------------------------------------------------------------------
.text$di:00006345                 align 4
.text$di:00006345 _text$di        ends
.text$di:00006345
.text$di:00006348 ; ===========================================================================
.text$di:00006348
.text$di:00006348 ; Segment type: Pure code
.text$di:00006348 ; Segment permissions: Read/Execute
.text$di:00006348 _text$di        segment para public 'CODE' use32
.text$di:00006348                 assume cs:_text$di
.text$di:00006348                 ;org 6348h
.text$di:00006348 ; COMDAT (pick any)
.text$di:00006348                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00006348
.text$di:00006348 ; =============== S U B R O U T I N E =======================================
.text$di:00006348
.text$di:00006348 ; Attributes: bp-based frame
.text$di:00006348
.text$di:00006348 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00006348 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00006348                 push    ebp
.text$di:00006349                 mov     ebp, esp
.text$di:0000634B                 mov     ecx, offset _ignore ; this
.text$di:00006350                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00006355                 pop     ebp
.text$di:00006356                 retn
.text$di:00006356 ??__Eignore@std@@YAXXZ endp
.text$di:00006356
.text$di:00006356 ; ---------------------------------------------------------------------------
.text$di:00006357                 align 4
.text$di:00006357 _text$di        ends
.text$di:00006357
.text$di:00006358 ; ===========================================================================
.text$di:00006358
.text$di:00006358 ; Segment type: Pure code
.text$di:00006358 ; Segment permissions: Read/Execute
.text$di:00006358 _text$di        segment para public 'CODE' use32
.text$di:00006358                 assume cs:_text$di
.text$di:00006358                 ;org 6358h
.text$di:00006358 ; COMDAT (pick any)
.text$di:00006358                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00006358
.text$di:00006358 ; =============== S U B R O U T I N E =======================================
.text$di:00006358
.text$di:00006358 ; Attributes: bp-based frame
.text$di:00006358
.text$di:00006358 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00006358 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00006358                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00006358
.text$di:00006358 var_1           = byte ptr -1
.text$di:00006358
.text$di:00006358                 push    ebp
.text$di:00006359                 mov     ebp, esp
.text$di:0000635B                 push    ecx
.text$di:0000635C                 xor     eax, eax
.text$di:0000635E                 mov     [ebp+var_1], al
.text$di:00006361                 mov     esp, ebp
.text$di:00006363                 pop     ebp
.text$di:00006364                 retn
.text$di:00006364 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00006364
.text$di:00006364 ; ---------------------------------------------------------------------------
.text$di:00006365                 align 4
.text$di:00006365 _text$di        ends
.text$di:00006365
.text$yd:00006368 ; ===========================================================================
.text$yd:00006368
.text$yd:00006368 ; Segment type: Pure code
.text$yd:00006368 ; Segment permissions: Read/Execute
.text$yd:00006368 _text$yd        segment para public 'CODE' use32
.text$yd:00006368                 assume cs:_text$yd
.text$yd:00006368                 ;org 6368h
.text$yd:00006368 ; COMDAT (pick any)
.text$yd:00006368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00006368
.text$yd:00006368 ; =============== S U B R O U T I N E =======================================
.text$yd:00006368
.text$yd:00006368 ; Attributes: bp-based frame
.text$yd:00006368
.text$yd:00006368 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00006368 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00006368                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00006368                 push    ebp
.text$yd:00006369                 mov     ebp, esp
.text$yd:0000636B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00006370                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00006375                 pop     ebp
.text$yd:00006376                 retn
.text$yd:00006376 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00006376
.text$yd:00006376 ; ---------------------------------------------------------------------------
.text$yd:00006377                 align 4
.text$yd:00006377 _text$yd        ends
.text$yd:00006377
.text$yd:00006378 ; ===========================================================================
.text$yd:00006378
.text$yd:00006378 ; Segment type: Pure code
.text$yd:00006378 ; Segment permissions: Read/Execute
.text$yd:00006378 _text$yd        segment para public 'CODE' use32
.text$yd:00006378                 assume cs:_text$yd
.text$yd:00006378                 ;org 6378h
.text$yd:00006378 ; COMDAT (pick any)
.text$yd:00006378                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00006378
.text$yd:00006378 ; =============== S U B R O U T I N E =======================================
.text$yd:00006378
.text$yd:00006378 ; Attributes: bp-based frame
.text$yd:00006378
.text$yd:00006378 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00006378 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00006378                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00006378                 push    ebp
.text$yd:00006379                 mov     ebp, esp
.text$yd:0000637B                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00006380                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00006385                 pop     ebp
.text$yd:00006386                 retn
.text$yd:00006386 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00006386
.text$yd:00006386 ; ---------------------------------------------------------------------------
.text$yd:00006387                 align 4
.text$yd:00006387 _text$yd        ends
.text$yd:00006387
.text$yd:00006388 ; ===========================================================================
.text$yd:00006388
.text$yd:00006388 ; Segment type: Pure code
.text$yd:00006388 ; Segment permissions: Read/Execute
.text$yd:00006388 _text$yd        segment para public 'CODE' use32
.text$yd:00006388                 assume cs:_text$yd
.text$yd:00006388                 ;org 6388h
.text$yd:00006388 ; COMDAT (pick any)
.text$yd:00006388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00006388
.text$yd:00006388 ; =============== S U B R O U T I N E =======================================
.text$yd:00006388
.text$yd:00006388 ; Attributes: bp-based frame
.text$yd:00006388
.text$yd:00006388 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00006388 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00006388                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00006388                 push    ebp
.text$yd:00006389                 mov     ebp, esp
.text$yd:0000638B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00006390                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00006395                 pop     ebp
.text$yd:00006396                 retn
.text$yd:00006396 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00006396
.text$yd:00006396 ; ---------------------------------------------------------------------------
.text$yd:00006397                 align 4
.text$yd:00006397 _text$yd        ends
.text$yd:00006397
.text$mn:00006398 ; ===========================================================================
.text$mn:00006398
.text$mn:00006398 ; Segment type: Pure code
.text$mn:00006398 ; Segment permissions: Read/Execute
.text$mn:00006398 _text$mn        segment para public 'CODE' use32
.text$mn:00006398                 assume cs:_text$mn
.text$mn:00006398                 ;org 6398h
.text$mn:00006398 ; COMDAT (pick any)
.text$mn:00006398                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006398
.text$mn:00006398 ; =============== S U B R O U T I N E =======================================
.text$mn:00006398
.text$mn:00006398 ; Attributes: bp-based frame
.text$mn:00006398
.text$mn:00006398 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00006398                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00006398 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00006398                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)+45p
.text$mn:00006398                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)+45p ...
.text$mn:00006398
.text$mn:00006398 var_1C          = byte ptr -1Ch
.text$mn:00006398 var_18          = byte ptr -18h
.text$mn:00006398 var_14          = dword ptr -14h
.text$mn:00006398 var_10          = dword ptr -10h
.text$mn:00006398 var_C           = dword ptr -0Ch
.text$mn:00006398 var_4           = dword ptr -4
.text$mn:00006398 arg_0           = dword ptr  8
.text$mn:00006398
.text$mn:00006398                 push    ebp
.text$mn:00006399                 mov     ebp, esp
.text$mn:0000639B                 push    0FFFFFFFFh
.text$mn:0000639D                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:000063A2                 mov     eax, large fs:0
.text$mn:000063A8                 push    eax
.text$mn:000063A9                 sub     esp, 10h
.text$mn:000063AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000063B1                 xor     eax, ebp
.text$mn:000063B3                 push    eax
.text$mn:000063B4                 lea     eax, [ebp+var_C]
.text$mn:000063B7                 mov     large fs:0, eax
.text$mn:000063BD                 mov     [ebp+var_10], ecx
.text$mn:000063C0                 cmp     [ebp+arg_0], 0
.text$mn:000063C4                 jnz     short loc_63F0
.text$mn:000063C6                 push    3               ; int
.text$mn:000063C8                 lea     ecx, [ebp+var_18] ; this
.text$mn:000063CB                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000063D0                 mov     [ebp+var_4], 0
.text$mn:000063D7                 mov     ecx, [ebp+var_10] ; this
.text$mn:000063DA                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000063DF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000063E6                 lea     ecx, [ebp+var_18] ; this
.text$mn:000063E9                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000063EE                 jmp     short loc_6447
.text$mn:000063F0 ; ---------------------------------------------------------------------------
.text$mn:000063F0
.text$mn:000063F0 loc_63F0:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:000063F0                 mov     eax, [ebp+arg_0]
.text$mn:000063F3                 mov     ecx, [eax]
.text$mn:000063F5                 mov     [ebp+var_14], ecx
.text$mn:000063F8                 mov     edx, [ebp+var_10]
.text$mn:000063FB                 mov     eax, [edx]
.text$mn:000063FD                 cmp     eax, [ebp+var_14]
.text$mn:00006400                 jz      short loc_6447
.text$mn:00006402                 push    3               ; int
.text$mn:00006404                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00006407                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000640C                 mov     [ebp+var_4], 1
.text$mn:00006413                 mov     ecx, [ebp+var_10] ; this
.text$mn:00006416                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:0000641B                 mov     ecx, [ebp+var_10]
.text$mn:0000641E                 mov     edx, [ebp+var_14]
.text$mn:00006421                 mov     eax, [edx+4]
.text$mn:00006424                 mov     [ecx+4], eax
.text$mn:00006427                 mov     ecx, [ebp+var_14]
.text$mn:0000642A                 mov     edx, [ebp+var_10]
.text$mn:0000642D                 mov     [ecx+4], edx
.text$mn:00006430                 mov     eax, [ebp+var_10]
.text$mn:00006433                 mov     ecx, [ebp+var_14]
.text$mn:00006436                 mov     [eax], ecx
.text$mn:00006438                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000643F                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00006442                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00006447
.text$mn:00006447 loc_6447:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00006447                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00006447                 mov     ecx, [ebp+var_C]
.text$mn:0000644A                 mov     large fs:0, ecx
.text$mn:00006451                 pop     ecx
.text$mn:00006452                 mov     esp, ebp
.text$mn:00006454                 pop     ebp
.text$mn:00006455                 retn    4
.text$mn:00006455 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00006455
.text$mn:00006455 _text$mn        ends
.text$mn:00006455
.text$x:00006458 ; ===========================================================================
.text$x:00006458
.text$x:00006458 ; Segment type: Pure code
.text$x:00006458 ; Segment permissions: Read/Execute
.text$x:00006458 _text$x         segment para public 'CODE' use32
.text$x:00006458                 assume cs:_text$x
.text$x:00006458                 ;org 6458h
.text$x:00006458 ; COMDAT (pick associative to section at 6398)
.text$x:00006458                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00006458
.text$x:00006458 ; =============== S U B R O U T I N E =======================================
.text$x:00006458
.text$x:00006458
.text$x:00006458 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00006458                                         ; DATA XREF: .xdata$x:00008F64o
.text$x:00006458                 lea     ecx, [ebp-18h]  ; this
.text$x:0000645B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000645B __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:0000645B
.text$x:00006460
.text$x:00006460 ; =============== S U B R O U T I N E =======================================
.text$x:00006460
.text$x:00006460
.text$x:00006460 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00006460                                         ; DATA XREF: .xdata$x:00008F6Co
.text$x:00006460                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00006463                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00006463 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00006463
.text$x:00006468
.text$x:00006468 ; =============== S U B R O U T I N E =======================================
.text$x:00006468
.text$x:00006468
.text$x:00006468 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00006468                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00006468
.text$x:00006468 arg_4           = dword ptr  8
.text$x:00006468
.text$x:00006468                 mov     edx, [esp+arg_4]
.text$x:0000646C                 lea     eax, [edx+0Ch]
.text$x:0000646F                 mov     ecx, [edx-14h]
.text$x:00006472                 xor     ecx, eax
.text$x:00006474                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00006479                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:0000647E                 jmp     ___CxxFrameHandler3
.text$x:0000647E __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:0000647E
.text$x:0000647E ; ---------------------------------------------------------------------------
.text$x:00006483                 align 4
.text$x:00006483 _text$x         ends
.text$x:00006483
.text$mn:00006484 ; ===========================================================================
.text$mn:00006484
.text$mn:00006484 ; Segment type: Pure code
.text$mn:00006484 ; Segment permissions: Read/Execute
.text$mn:00006484 _text$mn        segment para public 'CODE' use32
.text$mn:00006484                 assume cs:_text$mn
.text$mn:00006484                 ;org 6484h
.text$mn:00006484 ; COMDAT (pick any)
.text$mn:00006484                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006484
.text$mn:00006484 ; =============== S U B R O U T I N E =======================================
.text$mn:00006484
.text$mn:00006484 ; Attributes: bp-based frame
.text$mn:00006484
.text$mn:00006484 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00006484                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00006484 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006484                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00006484
.text$mn:00006484 var_10          = byte ptr -10h
.text$mn:00006484 var_8           = dword ptr -8
.text$mn:00006484 var_1           = byte ptr -1
.text$mn:00006484
.text$mn:00006484                 push    ebp
.text$mn:00006485                 mov     ebp, esp
.text$mn:00006487                 sub     esp, 10h
.text$mn:0000648A                 mov     [ebp+var_8], ecx
.text$mn:0000648D                 lea     ecx, [ebp+var_1]
.text$mn:00006490                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006495                 push    1
.text$mn:00006497                 lea     ecx, [ebp+var_1]
.text$mn:0000649A                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:0000649F                 mov     ecx, [ebp+var_8]
.text$mn:000064A2                 mov     [ecx], eax
.text$mn:000064A4                 lea     ecx, [ebp+var_10] ; this
.text$mn:000064A7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000064AC                 push    eax             ; int
.text$mn:000064AD                 mov     edx, [ebp+var_8]
.text$mn:000064B0                 mov     eax, [edx]
.text$mn:000064B2                 push    eax             ; void *
.text$mn:000064B3                 lea     ecx, [ebp+var_1]
.text$mn:000064B6                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000064BB                 mov     ecx, [ebp+var_8]
.text$mn:000064BE                 mov     edx, [ecx]
.text$mn:000064C0                 mov     eax, [ebp+var_8]
.text$mn:000064C3                 mov     [edx], eax
.text$mn:000064C5                 mov     esp, ebp
.text$mn:000064C7                 pop     ebp
.text$mn:000064C8                 retn
.text$mn:000064C8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:000064C8
.text$mn:000064C8 ; ---------------------------------------------------------------------------
.text$mn:000064C9                 align 4
.text$mn:000064C9 _text$mn        ends
.text$mn:000064C9
.text$mn:000064CC ; ===========================================================================
.text$mn:000064CC
.text$mn:000064CC ; Segment type: Pure code
.text$mn:000064CC ; Segment permissions: Read/Execute
.text$mn:000064CC _text$mn        segment para public 'CODE' use32
.text$mn:000064CC                 assume cs:_text$mn
.text$mn:000064CC                 ;org 64CCh
.text$mn:000064CC ; COMDAT (pick any)
.text$mn:000064CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000064CC
.text$mn:000064CC ; =============== S U B R O U T I N E =======================================
.text$mn:000064CC
.text$mn:000064CC ; Attributes: bp-based frame
.text$mn:000064CC
.text$mn:000064CC ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>::_Alloc_proxy(void)
.text$mn:000064CC                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ
.text$mn:000064CC ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000064CC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(std::allocator<uchar> const &)+38p
.text$mn:000064CC
.text$mn:000064CC var_10          = byte ptr -10h
.text$mn:000064CC var_8           = dword ptr -8
.text$mn:000064CC var_1           = byte ptr -1
.text$mn:000064CC
.text$mn:000064CC                 push    ebp
.text$mn:000064CD                 mov     ebp, esp
.text$mn:000064CF                 sub     esp, 10h
.text$mn:000064D2                 mov     [ebp+var_8], ecx
.text$mn:000064D5                 lea     ecx, [ebp+var_1]
.text$mn:000064D8                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:000064DD                 push    1
.text$mn:000064DF                 lea     ecx, [ebp+var_1]
.text$mn:000064E2                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:000064E7                 mov     ecx, [ebp+var_8]
.text$mn:000064EA                 mov     [ecx], eax
.text$mn:000064EC                 lea     ecx, [ebp+var_10] ; this
.text$mn:000064EF                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000064F4                 push    eax             ; int
.text$mn:000064F5                 mov     edx, [ebp+var_8]
.text$mn:000064F8                 mov     eax, [edx]
.text$mn:000064FA                 push    eax             ; void *
.text$mn:000064FB                 lea     ecx, [ebp+var_1]
.text$mn:000064FE                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00006503                 mov     ecx, [ebp+var_8]
.text$mn:00006506                 mov     edx, [ecx]
.text$mn:00006508                 mov     eax, [ebp+var_8]
.text$mn:0000650B                 mov     [edx], eax
.text$mn:0000650D                 mov     esp, ebp
.text$mn:0000650F                 pop     ebp
.text$mn:00006510                 retn
.text$mn:00006510 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ endp
.text$mn:00006510
.text$mn:00006510 ; ---------------------------------------------------------------------------
.text$mn:00006511                 align 4
.text$mn:00006511 _text$mn        ends
.text$mn:00006511
.text$mn:00006514 ; ===========================================================================
.text$mn:00006514
.text$mn:00006514 ; Segment type: Pure code
.text$mn:00006514 ; Segment permissions: Read/Execute
.text$mn:00006514 _text$mn        segment para public 'CODE' use32
.text$mn:00006514                 assume cs:_text$mn
.text$mn:00006514                 ;org 6514h
.text$mn:00006514 ; COMDAT (pick any)
.text$mn:00006514                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006514
.text$mn:00006514 ; =============== S U B R O U T I N E =======================================
.text$mn:00006514
.text$mn:00006514 ; Attributes: bp-based frame
.text$mn:00006514
.text$mn:00006514 ; public: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Assign_rv(class std::vector<unsigned char, class std::allocator<unsigned char>> &&)
.text$mn:00006514                 public ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@@Z
.text$mn:00006514 ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@@Z proc near
.text$mn:00006514                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> &&)+42p
.text$mn:00006514
.text$mn:00006514 var_8           = dword ptr -8
.text$mn:00006514 var_1           = byte ptr -1
.text$mn:00006514 arg_0           = dword ptr  8
.text$mn:00006514
.text$mn:00006514                 push    ebp
.text$mn:00006515                 mov     ebp, esp
.text$mn:00006517                 sub     esp, 8
.text$mn:0000651A                 mov     [ebp+var_8], ecx
.text$mn:0000651D                 xor     eax, eax
.text$mn:0000651F                 mov     [ebp+var_1], al
.text$mn:00006522                 movzx   ecx, [ebp+var_1]
.text$mn:00006526                 push    ecx
.text$mn:00006527                 mov     edx, [ebp+arg_0]
.text$mn:0000652A                 push    edx
.text$mn:0000652B                 call    ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:00006530                 add     esp, 4
.text$mn:00006533                 push    eax
.text$mn:00006534                 mov     ecx, [ebp+var_8]
.text$mn:00006537                 call    ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)
.text$mn:0000653C                 mov     esp, ebp
.text$mn:0000653E                 pop     ebp
.text$mn:0000653F                 retn    4
.text$mn:0000653F ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@@Z endp
.text$mn:0000653F
.text$mn:0000653F ; ---------------------------------------------------------------------------
.text$mn:00006542                 align 4
.text$mn:00006542 _text$mn        ends
.text$mn:00006542
.text$mn:00006544 ; ===========================================================================
.text$mn:00006544
.text$mn:00006544 ; Segment type: Pure code
.text$mn:00006544 ; Segment permissions: Read/Execute
.text$mn:00006544 _text$mn        segment para public 'CODE' use32
.text$mn:00006544                 assume cs:_text$mn
.text$mn:00006544                 ;org 6544h
.text$mn:00006544 ; COMDAT (pick any)
.text$mn:00006544                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006544
.text$mn:00006544 ; =============== S U B R O U T I N E =======================================
.text$mn:00006544
.text$mn:00006544 ; Attributes: bp-based frame
.text$mn:00006544
.text$mn:00006544 ; int __stdcall std::vector<unsigned char,std::allocator<unsigned char>>::_Assign_rv(struct std::_Container_base12 *, int)
.text$mn:00006544                 public ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
.text$mn:00006544 ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z proc near
.text$mn:00006544                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> &&)+5Ep
.text$mn:00006544                                         ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+6Cp
.text$mn:00006544
.text$mn:00006544 var_4           = dword ptr -4
.text$mn:00006544 arg_0           = dword ptr  8
.text$mn:00006544
.text$mn:00006544                 push    ebp
.text$mn:00006545                 mov     ebp, esp
.text$mn:00006547                 push    ecx
.text$mn:00006548                 mov     [ebp+var_4], ecx
.text$mn:0000654B                 mov     eax, [ebp+arg_0]
.text$mn:0000654E                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000654F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00006552                 call    ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ; std::_Container_base12::_Swap_all(std::_Container_base12 &)
.text$mn:00006557                 mov     ecx, [ebp+var_4]
.text$mn:0000655A                 mov     edx, [ebp+arg_0]
.text$mn:0000655D                 mov     eax, [edx+4]
.text$mn:00006560                 mov     [ecx+4], eax
.text$mn:00006563                 mov     ecx, [ebp+var_4]
.text$mn:00006566                 mov     edx, [ebp+arg_0]
.text$mn:00006569                 mov     eax, [edx+8]
.text$mn:0000656C                 mov     [ecx+8], eax
.text$mn:0000656F                 mov     ecx, [ebp+var_4]
.text$mn:00006572                 mov     edx, [ebp+arg_0]
.text$mn:00006575                 mov     eax, [edx+0Ch]
.text$mn:00006578                 mov     [ecx+0Ch], eax
.text$mn:0000657B                 mov     ecx, [ebp+arg_0]
.text$mn:0000657E                 mov     dword ptr [ecx+4], 0
.text$mn:00006585                 mov     edx, [ebp+arg_0]
.text$mn:00006588                 mov     dword ptr [edx+8], 0
.text$mn:0000658F                 mov     eax, [ebp+arg_0]
.text$mn:00006592                 mov     dword ptr [eax+0Ch], 0
.text$mn:00006599                 mov     esp, ebp
.text$mn:0000659B                 pop     ebp
.text$mn:0000659C                 retn    8
.text$mn:0000659C ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z endp
.text$mn:0000659C
.text$mn:0000659C ; ---------------------------------------------------------------------------
.text$mn:0000659F                 align 10h
.text$mn:0000659F _text$mn        ends
.text$mn:0000659F
.text$mn:000065A0 ; ===========================================================================
.text$mn:000065A0
.text$mn:000065A0 ; Segment type: Pure code
.text$mn:000065A0 ; Segment permissions: Read/Execute
.text$mn:000065A0 _text$mn        segment para public 'CODE' use32
.text$mn:000065A0                 assume cs:_text$mn
.text$mn:000065A0                 ;org 65A0h
.text$mn:000065A0 ; COMDAT (pick any)
.text$mn:000065A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000065A0
.text$mn:000065A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000065A0
.text$mn:000065A0 ; Attributes: bp-based frame
.text$mn:000065A0
.text$mn:000065A0 ; public: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Assign_rv(class std::vector<unsigned char, class std::allocator<unsigned char>> &&, struct std::integral_constant<bool, 0>)
.text$mn:000065A0                 public ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z
.text$mn:000065A0 ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z proc near
.text$mn:000065A0                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&)+23p
.text$mn:000065A0
.text$mn:000065A0 var_44          = dword ptr -44h
.text$mn:000065A0 var_40          = dword ptr -40h
.text$mn:000065A0 var_3C          = dword ptr -3Ch
.text$mn:000065A0 var_38          = dword ptr -38h
.text$mn:000065A0 var_34          = dword ptr -34h
.text$mn:000065A0 var_30          = dword ptr -30h
.text$mn:000065A0 var_2C          = dword ptr -2Ch
.text$mn:000065A0 var_28          = dword ptr -28h
.text$mn:000065A0 var_24          = dword ptr -24h
.text$mn:000065A0 var_20          = dword ptr -20h
.text$mn:000065A0 var_1C          = dword ptr -1Ch
.text$mn:000065A0 var_18          = dword ptr -18h
.text$mn:000065A0 var_14          = dword ptr -14h
.text$mn:000065A0 var_F           = byte ptr -0Fh
.text$mn:000065A0 var_E           = byte ptr -0Eh
.text$mn:000065A0 var_D           = byte ptr -0Dh
.text$mn:000065A0 var_C           = dword ptr -0Ch
.text$mn:000065A0 var_4           = dword ptr -4
.text$mn:000065A0 arg_0           = dword ptr  8
.text$mn:000065A0
.text$mn:000065A0                 push    ebp
.text$mn:000065A1                 mov     ebp, esp
.text$mn:000065A3                 push    0FFFFFFFFh
.text$mn:000065A5                 push    offset __ehhandler$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z
.text$mn:000065AA                 mov     eax, large fs:0
.text$mn:000065B0                 push    eax
.text$mn:000065B1                 sub     esp, 38h
.text$mn:000065B4                 push    esi
.text$mn:000065B5                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000065BA                 xor     eax, ebp
.text$mn:000065BC                 push    eax
.text$mn:000065BD                 lea     eax, [ebp+var_C]
.text$mn:000065C0                 mov     large fs:0, eax
.text$mn:000065C6                 mov     [ebp+var_14], ecx
.text$mn:000065C9                 lea     eax, [ebp+var_E]
.text$mn:000065CC                 push    eax
.text$mn:000065CD                 mov     ecx, [ebp+arg_0]
.text$mn:000065D0                 call    ?get_allocator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$allocator@E@2@XZ ; std::vector<uchar,std::allocator<uchar>>::get_allocator(void)
.text$mn:000065D5                 push    eax
.text$mn:000065D6                 lea     ecx, [ebp+var_F]
.text$mn:000065D9                 push    ecx
.text$mn:000065DA                 mov     ecx, [ebp+var_14]
.text$mn:000065DD                 call    ?get_allocator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$allocator@E@2@XZ ; std::vector<uchar,std::allocator<uchar>>::get_allocator(void)
.text$mn:000065E2                 push    eax
.text$mn:000065E3                 call    ??$?8EE@std@@YA_NABV?$allocator@E@0@0@Z ; std::operator==<uchar,uchar>(std::allocator<uchar> const &,std::allocator<uchar> const &)
.text$mn:000065E8                 add     esp, 8
.text$mn:000065EB                 movzx   edx, al
.text$mn:000065EE                 test    edx, edx
.text$mn:000065F0                 jz      short loc_6616
.text$mn:000065F2                 xor     eax, eax
.text$mn:000065F4                 mov     [ebp+var_D], al
.text$mn:000065F7                 movzx   ecx, [ebp+var_D]
.text$mn:000065FB                 push    ecx             ; int
.text$mn:000065FC                 mov     edx, [ebp+arg_0]
.text$mn:000065FF                 push    edx
.text$mn:00006600                 call    ??$forward@V?$vector@EV?$allocator@E@std@@@std@@@std@@YA$$QAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::forward<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:00006605                 add     esp, 4
.text$mn:00006608                 push    eax             ; struct std::_Container_base12 *
.text$mn:00006609                 mov     ecx, [ebp+var_14]
.text$mn:0000660C                 call    ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,1>)
.text$mn:00006611                 jmp     loc_66AE
.text$mn:00006616 ; ---------------------------------------------------------------------------
.text$mn:00006616
.text$mn:00006616 loc_6616:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+50j
.text$mn:00006616                 sub     esp, 0Ch
.text$mn:00006619                 mov     esi, esp
.text$mn:0000661B                 mov     [ebp+var_28], esp
.text$mn:0000661E                 sub     esp, 0Ch
.text$mn:00006621                 mov     eax, esp
.text$mn:00006623                 mov     [ebp+var_2C], esp
.text$mn:00006626                 push    eax
.text$mn:00006627                 mov     ecx, [ebp+arg_0]
.text$mn:0000662A                 call    ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<uchar,std::allocator<uchar>>::end(void)
.text$mn:0000662F                 mov     [ebp+var_18], eax
.text$mn:00006632                 mov     ecx, [ebp+var_18]
.text$mn:00006635                 mov     [ebp+var_30], ecx
.text$mn:00006638                 mov     [ebp+var_4], 0
.text$mn:0000663F                 push    esi
.text$mn:00006640                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006647                 call    ??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::make_move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)
.text$mn:0000664C                 add     esp, 10h
.text$mn:0000664F                 mov     [ebp+var_1C], eax
.text$mn:00006652                 mov     edx, [ebp+var_1C]
.text$mn:00006655                 mov     [ebp+var_34], edx
.text$mn:00006658                 mov     [ebp+var_4], 1
.text$mn:0000665F                 sub     esp, 0Ch
.text$mn:00006662                 mov     esi, esp
.text$mn:00006664                 mov     [ebp+var_38], esp
.text$mn:00006667                 sub     esp, 0Ch
.text$mn:0000666A                 mov     eax, esp
.text$mn:0000666C                 mov     [ebp+var_3C], esp
.text$mn:0000666F                 push    eax
.text$mn:00006670                 mov     ecx, [ebp+arg_0]
.text$mn:00006673                 call    ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ ; std::vector<uchar,std::allocator<uchar>>::begin(void)
.text$mn:00006678                 mov     [ebp+var_20], eax
.text$mn:0000667B                 mov     ecx, [ebp+var_20]
.text$mn:0000667E                 mov     [ebp+var_40], ecx
.text$mn:00006681                 mov     byte ptr [ebp+var_4], 2
.text$mn:00006685                 push    esi
.text$mn:00006686                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000668A                 call    ??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z ; std::make_move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)
.text$mn:0000668F                 add     esp, 10h
.text$mn:00006692                 mov     [ebp+var_24], eax
.text$mn:00006695                 mov     edx, [ebp+var_24]
.text$mn:00006698                 mov     [ebp+var_44], edx
.text$mn:0000669B                 mov     byte ptr [ebp+var_4], 3
.text$mn:0000669F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000066A6                 mov     ecx, [ebp+var_14]
.text$mn:000066A9                 call    ??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z ; std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>)
.text$mn:000066AE
.text$mn:000066AE loc_66AE:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+71j
.text$mn:000066AE                 mov     ecx, [ebp+var_C]
.text$mn:000066B1                 mov     large fs:0, ecx
.text$mn:000066B8                 pop     ecx
.text$mn:000066B9                 pop     esi
.text$mn:000066BA                 mov     esp, ebp
.text$mn:000066BC                 pop     ebp
.text$mn:000066BD                 retn    8
.text$mn:000066BD ?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z endp
.text$mn:000066BD
.text$mn:000066BD _text$mn        ends
.text$mn:000066BD
.text$x:000066C0 ; ===========================================================================
.text$x:000066C0
.text$x:000066C0 ; Segment type: Pure code
.text$x:000066C0 ; Segment permissions: Read/Execute
.text$x:000066C0 _text$x         segment para public 'CODE' use32
.text$x:000066C0                 assume cs:_text$x
.text$x:000066C0                 ;org 66C0h
.text$x:000066C0 ; COMDAT (pick associative to section at 65A0)
.text$x:000066C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000066C0
.text$x:000066C0 ; =============== S U B R O U T I N E =======================================
.text$x:000066C0
.text$x:000066C0
.text$x:000066C0 __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$0 proc near
.text$x:000066C0                                         ; DATA XREF: .xdata$x:000097E4o
.text$x:000066C0                 mov     ecx, [ebp-2Ch]
.text$x:000066C3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:000066C3 __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$0 endp
.text$x:000066C3
.text$x:000066C8
.text$x:000066C8 ; =============== S U B R O U T I N E =======================================
.text$x:000066C8
.text$x:000066C8
.text$x:000066C8 __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$1 proc near
.text$x:000066C8                                         ; DATA XREF: .xdata$x:000097ECo
.text$x:000066C8                 mov     ecx, [ebp-28h]
.text$x:000066CB                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000066CB __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$1 endp
.text$x:000066CB
.text$x:000066D0
.text$x:000066D0 ; =============== S U B R O U T I N E =======================================
.text$x:000066D0
.text$x:000066D0
.text$x:000066D0 __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$2 proc near
.text$x:000066D0                                         ; DATA XREF: .xdata$x:000097F4o
.text$x:000066D0                 mov     ecx, [ebp-3Ch]
.text$x:000066D3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:000066D3 __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$2 endp
.text$x:000066D3
.text$x:000066D8
.text$x:000066D8 ; =============== S U B R O U T I N E =======================================
.text$x:000066D8
.text$x:000066D8
.text$x:000066D8 __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$3 proc near
.text$x:000066D8                                         ; DATA XREF: .xdata$x:000097FCo
.text$x:000066D8                 mov     ecx, [ebp-38h]
.text$x:000066DB                 jmp     ??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ ; std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::~move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(void)
.text$x:000066DB __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$3 endp
.text$x:000066DB
.text$x:000066E0
.text$x:000066E0 ; =============== S U B R O U T I N E =======================================
.text$x:000066E0
.text$x:000066E0
.text$x:000066E0 __ehhandler$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z proc near
.text$x:000066E0                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+5o
.text$x:000066E0
.text$x:000066E0 arg_4           = dword ptr  8
.text$x:000066E0
.text$x:000066E0                 mov     edx, [esp+arg_4]
.text$x:000066E4                 lea     eax, [edx+0Ch]
.text$x:000066E7                 mov     ecx, [edx-40h]
.text$x:000066EA                 xor     ecx, eax
.text$x:000066EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000066F1                 mov     eax, offset __ehfuncinfo$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z
.text$x:000066F6                 jmp     ___CxxFrameHandler3
.text$x:000066F6 __ehhandler$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z endp
.text$x:000066F6
.text$x:000066F6 ; ---------------------------------------------------------------------------
.text$x:000066FB                 align 4
.text$x:000066FB _text$x         ends
.text$x:000066FB
.text$mn:000066FC ; ===========================================================================
.text$mn:000066FC
.text$mn:000066FC ; Segment type: Pure code
.text$mn:000066FC ; Segment permissions: Read/Execute
.text$mn:000066FC _text$mn        segment para public 'CODE' use32
.text$mn:000066FC                 assume cs:_text$mn
.text$mn:000066FC                 ;org 66FCh
.text$mn:000066FC ; COMDAT (pick any)
.text$mn:000066FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000066FC
.text$mn:000066FC ; =============== S U B R O U T I N E =======================================
.text$mn:000066FC
.text$mn:000066FC ; Attributes: bp-based frame
.text$mn:000066FC
.text$mn:000066FC ; protected: bool __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Buy(unsigned int)
.text$mn:000066FC                 public ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z
.text$mn:000066FC ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z proc near
.text$mn:000066FC                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Construct<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::forward_iterator_tag)+88p
.text$mn:000066FC                                         ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+62p ...
.text$mn:000066FC
.text$mn:000066FC var_8           = dword ptr -8
.text$mn:000066FC var_1           = byte ptr -1
.text$mn:000066FC arg_0           = dword ptr  8
.text$mn:000066FC
.text$mn:000066FC                 push    ebp
.text$mn:000066FD                 mov     ebp, esp
.text$mn:000066FF                 sub     esp, 8
.text$mn:00006702                 mov     [ebp+var_8], ecx
.text$mn:00006705                 mov     eax, [ebp+var_8]
.text$mn:00006708                 mov     dword ptr [eax+4], 0
.text$mn:0000670F                 mov     ecx, [ebp+var_8]
.text$mn:00006712                 mov     dword ptr [ecx+8], 0
.text$mn:00006719                 mov     edx, [ebp+var_8]
.text$mn:0000671C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00006723                 cmp     [ebp+arg_0], 0
.text$mn:00006727                 jnz     short loc_672F
.text$mn:00006729                 xor     al, al
.text$mn:0000672B                 jmp     short loc_6780
.text$mn:0000672D ; ---------------------------------------------------------------------------
.text$mn:0000672D                 jmp     short loc_677E
.text$mn:0000672F ; ---------------------------------------------------------------------------
.text$mn:0000672F
.text$mn:0000672F loc_672F:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+2Bj
.text$mn:0000672F                 mov     ecx, [ebp+var_8]
.text$mn:00006732                 call    ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::max_size(void)
.text$mn:00006737                 cmp     eax, [ebp+arg_0]
.text$mn:0000673A                 jnb     short loc_6746
.text$mn:0000673C                 mov     ecx, [ebp+var_8]
.text$mn:0000673F                 call    ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Xlen(void)
.text$mn:00006744                 jmp     short loc_677E
.text$mn:00006746 ; ---------------------------------------------------------------------------
.text$mn:00006746
.text$mn:00006746 loc_6746:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+3Ej
.text$mn:00006746                 mov     eax, [ebp+arg_0]
.text$mn:00006749                 push    eax
.text$mn:0000674A                 lea     ecx, [ebp+var_1]
.text$mn:0000674D                 push    ecx
.text$mn:0000674E                 mov     ecx, [ebp+var_8]
.text$mn:00006751                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00006756                 mov     ecx, eax
.text$mn:00006758                 call    ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ; std::_Wrap_alloc<std::allocator<uchar>>::allocate(uint)
.text$mn:0000675D                 mov     edx, [ebp+var_8]
.text$mn:00006760                 mov     [edx+4], eax
.text$mn:00006763                 mov     eax, [ebp+var_8]
.text$mn:00006766                 mov     ecx, [ebp+var_8]
.text$mn:00006769                 mov     edx, [ecx+4]
.text$mn:0000676C                 mov     [eax+8], edx
.text$mn:0000676F                 mov     eax, [ebp+var_8]
.text$mn:00006772                 mov     ecx, [eax+4]
.text$mn:00006775                 add     ecx, [ebp+arg_0]
.text$mn:00006778                 mov     edx, [ebp+var_8]
.text$mn:0000677B                 mov     [edx+0Ch], ecx
.text$mn:0000677E
.text$mn:0000677E loc_677E:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+31j
.text$mn:0000677E                                         ; std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+48j
.text$mn:0000677E                 mov     al, 1
.text$mn:00006780
.text$mn:00006780 loc_6780:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+2Fj
.text$mn:00006780                 mov     esp, ebp
.text$mn:00006782                 pop     ebp
.text$mn:00006783                 retn    4
.text$mn:00006783 ?_Buy@?$vector@EV?$allocator@E@std@@@std@@IAE_NI@Z endp
.text$mn:00006783
.text$mn:00006783 ; ---------------------------------------------------------------------------
.text$mn:00006786                 align 4
.text$mn:00006786 _text$mn        ends
.text$mn:00006786
.text$mn:00006788 ; ===========================================================================
.text$mn:00006788
.text$mn:00006788 ; Segment type: Pure code
.text$mn:00006788 ; Segment permissions: Read/Execute
.text$mn:00006788 _text$mn        segment para public 'CODE' use32
.text$mn:00006788                 assume cs:_text$mn
.text$mn:00006788                 ;org 6788h
.text$mn:00006788 ; COMDAT (pick any)
.text$mn:00006788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006788
.text$mn:00006788 ; =============== S U B R O U T I N E =======================================
.text$mn:00006788
.text$mn:00006788 ; Attributes: bp-based frame
.text$mn:00006788
.text$mn:00006788 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>::_Change_alloc(struct std::_Wrap_alloc<class std::allocator<unsigned char>> const &)
.text$mn:00006788                 public ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z
.text$mn:00006788 ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z proc near
.text$mn:00006788                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> &&)+2Dp
.text$mn:00006788                                         ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+80p
.text$mn:00006788
.text$mn:00006788 var_4           = dword ptr -4
.text$mn:00006788
.text$mn:00006788                 push    ebp
.text$mn:00006789                 mov     ebp, esp
.text$mn:0000678B                 push    ecx
.text$mn:0000678C                 mov     [ebp+var_4], ecx
.text$mn:0000678F                 mov     esp, ebp
.text$mn:00006791                 pop     ebp
.text$mn:00006792                 retn    4
.text$mn:00006792 ?_Change_alloc@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@E@std@@@2@@Z endp
.text$mn:00006792
.text$mn:00006792 ; ---------------------------------------------------------------------------
.text$mn:00006795                 align 4
.text$mn:00006795 _text$mn        ends
.text$mn:00006795
.text$mn:00006798 ; ===========================================================================
.text$mn:00006798
.text$mn:00006798 ; Segment type: Pure code
.text$mn:00006798 ; Segment permissions: Read/Execute
.text$mn:00006798 _text$mn        segment para public 'CODE' use32
.text$mn:00006798                 assume cs:_text$mn
.text$mn:00006798                 ;org 6798h
.text$mn:00006798 ; COMDAT (pick any)
.text$mn:00006798                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006798
.text$mn:00006798 ; =============== S U B R O U T I N E =======================================
.text$mn:00006798
.text$mn:00006798 ; Attributes: bp-based frame
.text$mn:00006798
.text$mn:00006798 ; void __thiscall std::_Iterator_base12::_Clrcont(std::_Iterator_base12 *__hidden this)
.text$mn:00006798                 public ?_Clrcont@_Iterator_base12@std@@QAEXXZ
.text$mn:00006798 ?_Clrcont@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00006798                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+80p
.text$mn:00006798                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+80p
.text$mn:00006798
.text$mn:00006798 var_4           = dword ptr -4
.text$mn:00006798
.text$mn:00006798                 push    ebp
.text$mn:00006799                 mov     ebp, esp
.text$mn:0000679B                 push    ecx
.text$mn:0000679C                 mov     [ebp+var_4], ecx
.text$mn:0000679F                 mov     eax, [ebp+var_4]
.text$mn:000067A2                 mov     dword ptr [eax], 0
.text$mn:000067A8                 mov     esp, ebp
.text$mn:000067AA                 pop     ebp
.text$mn:000067AB                 retn
.text$mn:000067AB ?_Clrcont@_Iterator_base12@std@@QAEXXZ endp
.text$mn:000067AB
.text$mn:000067AB _text$mn        ends
.text$mn:000067AB
.text$mn:000067AC ; ===========================================================================
.text$mn:000067AC
.text$mn:000067AC ; Segment type: Pure code
.text$mn:000067AC ; Segment permissions: Read/Execute
.text$mn:000067AC _text$mn        segment para public 'CODE' use32
.text$mn:000067AC                 assume cs:_text$mn
.text$mn:000067AC                 ;org 67ACh
.text$mn:000067AC ; COMDAT (pick any)
.text$mn:000067AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000067AC
.text$mn:000067AC ; =============== S U B R O U T I N E =======================================
.text$mn:000067AC
.text$mn:000067AC ; Attributes: bp-based frame
.text$mn:000067AC
.text$mn:000067AC ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned char>>>::_Compat(std::_Iterator_base12 *)
.text$mn:000067AC                 public ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z
.text$mn:000067AC ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z proc near
.text$mn:000067AC                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator==(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+10p
.text$mn:000067AC                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator-(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+Ep ...
.text$mn:000067AC
.text$mn:000067AC var_4           = dword ptr -4
.text$mn:000067AC arg_0           = dword ptr  8
.text$mn:000067AC
.text$mn:000067AC                 push    ebp
.text$mn:000067AD                 mov     ebp, esp
.text$mn:000067AF                 push    ecx
.text$mn:000067B0                 push    esi
.text$mn:000067B1                 mov     [ebp+var_4], ecx
.text$mn:000067B4                 mov     ecx, [ebp+var_4] ; this
.text$mn:000067B7                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000067BC                 test    eax, eax
.text$mn:000067BE                 jz      short loc_67D6
.text$mn:000067C0                 mov     ecx, [ebp+var_4] ; this
.text$mn:000067C3                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000067C8                 mov     esi, eax
.text$mn:000067CA                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000067CD                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:000067D2                 cmp     esi, eax
.text$mn:000067D4                 jz      short loc_683E
.text$mn:000067D6
.text$mn:000067D6 loc_67D6:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+12j
.text$mn:000067D6                 push    0F0h ; '='      ; unsigned int
.text$mn:000067DB                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000067E0                 push    offset ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; "vector iterators incompatible"
.text$mn:000067E5                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000067EA                 add     esp, 0Ch
.text$mn:000067ED                 mov     eax, offset ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; "Standard C++ Libraries Invalid Argument"
.text$mn:000067F2                 test    eax, eax
.text$mn:000067F4                 jz      short loc_67FA
.text$mn:000067F6                 xor     ecx, ecx
.text$mn:000067F8                 jnz     short loc_6820
.text$mn:000067FA
.text$mn:000067FA loc_67FA:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+48j
.text$mn:000067FA                 push    offset ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; "\"Standard C++ Libraries Invalid Argume"...
.text$mn:000067FF                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:00006804                 push    0
.text$mn:00006806                 push    0F1h ; '±'
.text$mn:0000680B                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006810                 push    2
.text$mn:00006812                 call    __CrtDbgReportW
.text$mn:00006817                 add     esp, 18h
.text$mn:0000681A                 cmp     eax, 1
.text$mn:0000681D                 jnz     short loc_6820
.text$mn:0000681F                 int     3               ; Trap to Debugger
.text$mn:00006820
.text$mn:00006820 loc_6820:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+4Cj
.text$mn:00006820                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+71j
.text$mn:00006820                 push    0
.text$mn:00006822                 push    0F1h ; '±'
.text$mn:00006827                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000682C                 push    offset ??_C@_1NC@EDCKMCKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; "std::_Vector_const_iterator<class std::"...
.text$mn:00006831                 push    offset ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; "\"invalid argument\""
.text$mn:00006836                 call    __invalid_parameter
.text$mn:0000683B                 add     esp, 14h
.text$mn:0000683E
.text$mn:0000683E loc_683E:                               ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+28j
.text$mn:0000683E                 pop     esi
.text$mn:0000683F                 mov     esp, ebp
.text$mn:00006841                 pop     ebp
.text$mn:00006842                 retn    4
.text$mn:00006842 ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEXABV12@@Z endp
.text$mn:00006842
.text$mn:00006842 ; ---------------------------------------------------------------------------
.text$mn:00006845                 align 4
.text$mn:00006845 _text$mn        ends
.text$mn:00006845
.text$mn:00006848 ; ===========================================================================
.text$mn:00006848
.text$mn:00006848 ; Segment type: Pure code
.text$mn:00006848 ; Segment permissions: Read/Execute
.text$mn:00006848 _text$mn        segment para public 'CODE' use32
.text$mn:00006848                 assume cs:_text$mn
.text$mn:00006848                 ;org 6848h
.text$mn:00006848 ; COMDAT (pick any)
.text$mn:00006848                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006848
.text$mn:00006848 ; =============== S U B R O U T I N E =======================================
.text$mn:00006848
.text$mn:00006848 ; Attributes: bp-based frame
.text$mn:00006848
.text$mn:00006848 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00006848                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006848 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00006848                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00006848
.text$mn:00006848 var_20          = dword ptr -20h
.text$mn:00006848 var_1C          = dword ptr -1Ch
.text$mn:00006848 var_18          = dword ptr -18h
.text$mn:00006848 var_11          = byte ptr -11h
.text$mn:00006848 var_10          = dword ptr -10h
.text$mn:00006848 var_C           = byte ptr -0Ch
.text$mn:00006848 var_4           = dword ptr -4
.text$mn:00006848 arg_0           = dword ptr  8
.text$mn:00006848
.text$mn:00006848 ; FUNCTION CHUNK AT .text$mn:0000696A SIZE 00000009 BYTES
.text$mn:00006848
.text$mn:00006848                 push    ebp
.text$mn:00006849                 mov     ebp, esp
.text$mn:0000684B                 push    0FFFFFFFFh
.text$mn:0000684D                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006852                 mov     eax, large fs:0
.text$mn:00006858                 push    eax
.text$mn:00006859                 push    ecx
.text$mn:0000685A                 sub     esp, 10h
.text$mn:0000685D                 push    ebx
.text$mn:0000685E                 push    esi
.text$mn:0000685F                 push    edi
.text$mn:00006860                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006865                 xor     eax, ebp
.text$mn:00006867                 push    eax
.text$mn:00006868                 lea     eax, [ebp+var_C]
.text$mn:0000686B                 mov     large fs:0, eax
.text$mn:00006871                 mov     [ebp+var_10], esp
.text$mn:00006874                 mov     [ebp+var_18], ecx
.text$mn:00006877                 mov     eax, [ebp+arg_0]
.text$mn:0000687A                 or      eax, 0Fh
.text$mn:0000687D                 mov     [ebp+var_1C], eax
.text$mn:00006880                 mov     ecx, [ebp+var_18]
.text$mn:00006883                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00006888                 cmp     eax, [ebp+var_1C]
.text$mn:0000688B                 jnb     short loc_6895
.text$mn:0000688D                 mov     ecx, [ebp+arg_0]
.text$mn:00006890                 mov     [ebp+var_1C], ecx
.text$mn:00006893                 jmp     short loc_68E7
.text$mn:00006895 ; ---------------------------------------------------------------------------
.text$mn:00006895
.text$mn:00006895 loc_6895:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00006895                 mov     edx, [ebp+var_18]
.text$mn:00006898                 mov     ecx, [edx+18h]
.text$mn:0000689B                 shr     ecx, 1
.text$mn:0000689D                 mov     eax, [ebp+var_1C]
.text$mn:000068A0                 xor     edx, edx
.text$mn:000068A2                 mov     esi, 3
.text$mn:000068A7                 div     esi
.text$mn:000068A9                 cmp     ecx, eax
.text$mn:000068AB                 ja      short loc_68AF
.text$mn:000068AD                 jmp     short loc_68E7
.text$mn:000068AF ; ---------------------------------------------------------------------------
.text$mn:000068AF
.text$mn:000068AF loc_68AF:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:000068AF                 mov     ecx, [ebp+var_18]
.text$mn:000068B2                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000068B7                 mov     edx, [ebp+var_18]
.text$mn:000068BA                 mov     ecx, [edx+18h]
.text$mn:000068BD                 shr     ecx, 1
.text$mn:000068BF                 sub     eax, ecx
.text$mn:000068C1                 mov     edx, [ebp+var_18]
.text$mn:000068C4                 cmp     [edx+18h], eax
.text$mn:000068C7                 ja      short loc_68DC
.text$mn:000068C9                 mov     eax, [ebp+var_18]
.text$mn:000068CC                 mov     ecx, [eax+18h]
.text$mn:000068CF                 shr     ecx, 1
.text$mn:000068D1                 mov     edx, [ebp+var_18]
.text$mn:000068D4                 add     ecx, [edx+18h]
.text$mn:000068D7                 mov     [ebp+var_1C], ecx
.text$mn:000068DA                 jmp     short loc_68E7
.text$mn:000068DC ; ---------------------------------------------------------------------------
.text$mn:000068DC
.text$mn:000068DC loc_68DC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:000068DC                 mov     ecx, [ebp+var_18]
.text$mn:000068DF                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:000068E4                 mov     [ebp+var_1C], eax
.text$mn:000068E7
.text$mn:000068E7 loc_68E7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:000068E7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:000068E7                 mov     [ebp+var_4], 0
.text$mn:000068EE                 mov     eax, [ebp+var_1C]
.text$mn:000068F1                 add     eax, 1
.text$mn:000068F4                 push    eax
.text$mn:000068F5                 lea     ecx, [ebp+var_11]
.text$mn:000068F8                 push    ecx
.text$mn:000068F9                 mov     ecx, [ebp+var_18]
.text$mn:000068FC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00006901                 mov     ecx, eax
.text$mn:00006903                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00006908                 mov     [ebp+var_20], eax
.text$mn:0000690B                 jmp     short loc_696A
.text$mn:0000690B ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000690B
.text$mn:0000690D
.text$mn:0000690D ; =============== S U B R O U T I N E =======================================
.text$mn:0000690D
.text$mn:0000690D
.text$mn:0000690D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:0000690D                                         ; DATA XREF: .xdata$x:000090A8o
.text$mn:0000690D
.text$mn:0000690D ; FUNCTION CHUNK AT .text$mn:00006954 SIZE 00000009 BYTES
.text$mn:0000690D ; FUNCTION CHUNK AT .text$mn:00006964 SIZE 00000006 BYTES
.text$mn:0000690D
.text$mn:0000690D                 mov     [ebp-10h], esp
.text$mn:00006910                 mov     edx, [ebp+8]
.text$mn:00006913                 mov     [ebp-1Ch], edx
.text$mn:00006916                 mov     byte ptr [ebp-4], 2
.text$mn:0000691A                 mov     eax, [ebp-1Ch]
.text$mn:0000691D                 add     eax, 1
.text$mn:00006920                 push    eax
.text$mn:00006921                 lea     ecx, [ebp-12h]
.text$mn:00006924                 push    ecx
.text$mn:00006925                 mov     ecx, [ebp-18h]
.text$mn:00006928                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000692D                 mov     ecx, eax
.text$mn:0000692F                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00006934                 mov     [ebp-20h], eax
.text$mn:00006937                 jmp     short loc_6954
.text$mn:00006937 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00006937
.text$mn:00006939
.text$mn:00006939 ; =============== S U B R O U T I N E =======================================
.text$mn:00006939
.text$mn:00006939 ; Attributes: noreturn
.text$mn:00006939
.text$mn:00006939 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00006939                                         ; DATA XREF: .xdata$x:000090B8o
.text$mn:00006939                 push    0               ; Size
.text$mn:0000693B                 push    1               ; char
.text$mn:0000693D                 mov     ecx, [ebp-18h]
.text$mn:00006940                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006945                 push    0
.text$mn:00006947                 push    0
.text$mn:00006949                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006949 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00006949
.text$mn:0000694E ; ---------------------------------------------------------------------------
.text$mn:0000694E                 mov     eax, offset $LN17
.text$mn:00006953                 retn
.text$mn:00006954 ; ---------------------------------------------------------------------------
.text$mn:00006954 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006954
.text$mn:00006954 loc_6954:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00006954                 mov     dword ptr [ebp-4], 1
.text$mn:0000695B                 jmp     short loc_6964
.text$mn:0000695B ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000695D
.text$mn:0000695D ; =============== S U B R O U T I N E =======================================
.text$mn:0000695D
.text$mn:0000695D
.text$mn:0000695D $LN17           proc near               ; DATA XREF: .text$mn:0000694Eo
.text$mn:0000695D                 mov     dword ptr [ebp-4], 1
.text$mn:0000695D $LN17           endp ; sp-analysis failed
.text$mn:0000695D
.text$mn:00006964 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00006964
.text$mn:00006964 loc_6964:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00006964                 mov     eax, offset $LN19
.text$mn:00006969                 retn
.text$mn:00006969 ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000696A ; ---------------------------------------------------------------------------
.text$mn:0000696A ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000696A
.text$mn:0000696A loc_696A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000696A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00006971                 jmp     short loc_697A
.text$mn:00006971 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00006973
.text$mn:00006973 ; =============== S U B R O U T I N E =======================================
.text$mn:00006973
.text$mn:00006973
.text$mn:00006973 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_6964o
.text$mn:00006973                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000697A
.text$mn:0000697A loc_697A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000697A                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:0000697E                 jbe     short loc_6999
.text$mn:00006980                 mov     edx, [ebp+0Ch]
.text$mn:00006983                 push    edx             ; Size
.text$mn:00006984                 mov     ecx, [ebp-18h]
.text$mn:00006987                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000698C                 push    eax             ; Src
.text$mn:0000698D                 mov     eax, [ebp-20h]
.text$mn:00006990                 push    eax             ; Dst
.text$mn:00006991                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00006996                 add     esp, 0Ch
.text$mn:00006999
.text$mn:00006999 loc_6999:                               ; CODE XREF: $LN19+Bj
.text$mn:00006999                 push    0               ; Size
.text$mn:0000699B                 push    1               ; char
.text$mn:0000699D                 mov     ecx, [ebp-18h]
.text$mn:000069A0                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000069A5                 lea     ecx, [ebp-20h]
.text$mn:000069A8                 push    ecx             ; int
.text$mn:000069A9                 mov     edx, [ebp-18h]
.text$mn:000069AC                 add     edx, 4
.text$mn:000069AF                 push    edx             ; void *
.text$mn:000069B0                 lea     eax, [ebp-13h]
.text$mn:000069B3                 push    eax
.text$mn:000069B4                 mov     ecx, [ebp-18h]
.text$mn:000069B7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000069BC                 mov     ecx, eax
.text$mn:000069BE                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:000069C3                 mov     ecx, [ebp-18h]
.text$mn:000069C6                 mov     edx, [ebp-1Ch]
.text$mn:000069C9                 mov     [ecx+18h], edx
.text$mn:000069CC                 mov     eax, [ebp+0Ch]
.text$mn:000069CF                 push    eax
.text$mn:000069D0                 mov     ecx, [ebp-18h]
.text$mn:000069D3                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000069D8                 mov     ecx, [ebp-0Ch]
.text$mn:000069DB                 mov     large fs:0, ecx
.text$mn:000069E2                 pop     ecx
.text$mn:000069E3                 pop     edi
.text$mn:000069E4                 pop     esi
.text$mn:000069E5                 pop     ebx
.text$mn:000069E6                 mov     esp, ebp
.text$mn:000069E8                 pop     ebp
.text$mn:000069E9                 retn    8
.text$mn:000069E9 $LN19           endp ; sp-analysis failed
.text$mn:000069E9
.text$mn:000069E9 _text$mn        ends
.text$mn:000069E9
.text$x:000069EC ; ===========================================================================
.text$x:000069EC
.text$x:000069EC ; Segment type: Pure code
.text$x:000069EC ; Segment permissions: Read/Execute
.text$x:000069EC _text$x         segment para public 'CODE' use32
.text$x:000069EC                 assume cs:_text$x
.text$x:000069EC                 ;org 69ECh
.text$x:000069EC ; COMDAT (pick associative to section at 6848)
.text$x:000069EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000069EC
.text$x:000069EC ; =============== S U B R O U T I N E =======================================
.text$x:000069EC
.text$x:000069EC
.text$x:000069EC __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000069EC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000069EC
.text$x:000069EC arg_4           = dword ptr  8
.text$x:000069EC
.text$x:000069EC                 mov     edx, [esp+arg_4]
.text$x:000069F0                 lea     eax, [edx+0Ch]
.text$x:000069F3                 mov     ecx, [edx-24h]
.text$x:000069F6                 xor     ecx, eax
.text$x:000069F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000069FD                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00006A02                 jmp     ___CxxFrameHandler3
.text$x:00006A02 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00006A02
.text$x:00006A02 ; ---------------------------------------------------------------------------
.text$x:00006A07                 align 4
.text$x:00006A07 _text$x         ends
.text$x:00006A07
.text$mn:00006A08 ; ===========================================================================
.text$mn:00006A08
.text$mn:00006A08 ; Segment type: Pure code
.text$mn:00006A08 ; Segment permissions: Read/Execute
.text$mn:00006A08 _text$mn        segment para public 'CODE' use32
.text$mn:00006A08                 assume cs:_text$mn
.text$mn:00006A08                 ;org 6A08h
.text$mn:00006A08 ; COMDAT (pick any)
.text$mn:00006A08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A08
.text$mn:00006A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A08
.text$mn:00006A08 ; Attributes: bp-based frame
.text$mn:00006A08
.text$mn:00006A08 ; protected: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Destroy(unsigned char *, unsigned char *)
.text$mn:00006A08                 public ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z
.text$mn:00006A08 ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z proc near
.text$mn:00006A08                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+EDp
.text$mn:00006A08                                         ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+18Bp ...
.text$mn:00006A08
.text$mn:00006A08 var_8           = dword ptr -8
.text$mn:00006A08 var_1           = byte ptr -1
.text$mn:00006A08 arg_0           = dword ptr  8
.text$mn:00006A08 arg_4           = dword ptr  0Ch
.text$mn:00006A08
.text$mn:00006A08                 push    ebp
.text$mn:00006A09                 mov     ebp, esp
.text$mn:00006A0B                 sub     esp, 8
.text$mn:00006A0E                 mov     [ebp+var_8], ecx
.text$mn:00006A11                 lea     eax, [ebp+var_1]
.text$mn:00006A14                 push    eax
.text$mn:00006A15                 mov     ecx, [ebp+var_8]
.text$mn:00006A18                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00006A1D                 lea     ecx, [ebp+var_1]
.text$mn:00006A20                 push    ecx
.text$mn:00006A21                 mov     edx, [ebp+arg_4]
.text$mn:00006A24                 push    edx
.text$mn:00006A25                 mov     eax, [ebp+arg_0]
.text$mn:00006A28                 push    eax
.text$mn:00006A29                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@E@std@@@std@@@std@@YAXPAE0AAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<uchar>>>(uchar *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &)
.text$mn:00006A2E                 add     esp, 0Ch
.text$mn:00006A31                 mov     esp, ebp
.text$mn:00006A33                 pop     ebp
.text$mn:00006A34                 retn    8
.text$mn:00006A34 ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z endp
.text$mn:00006A34
.text$mn:00006A34 ; ---------------------------------------------------------------------------
.text$mn:00006A37                 align 4
.text$mn:00006A37 _text$mn        ends
.text$mn:00006A37
.text$mn:00006A38 ; ===========================================================================
.text$mn:00006A38
.text$mn:00006A38 ; Segment type: Pure code
.text$mn:00006A38 ; Segment permissions: Read/Execute
.text$mn:00006A38 _text$mn        segment para public 'CODE' use32
.text$mn:00006A38                 assume cs:_text$mn
.text$mn:00006A38                 ;org 6A38h
.text$mn:00006A38 ; COMDAT (pick any)
.text$mn:00006A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A38
.text$mn:00006A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A38
.text$mn:00006A38 ; Attributes: bp-based frame
.text$mn:00006A38
.text$mn:00006A38 ; protected: void __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Destroy(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *)
.text$mn:00006A38                 public ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z
.text$mn:00006A38 ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z proc near
.text$mn:00006A38                                         ; CODE XREF: __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0+17p
.text$mn:00006A38                                         ; __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0+41p ...
.text$mn:00006A38
.text$mn:00006A38 var_8           = dword ptr -8
.text$mn:00006A38 var_1           = byte ptr -1
.text$mn:00006A38 arg_0           = dword ptr  8
.text$mn:00006A38 arg_4           = dword ptr  0Ch
.text$mn:00006A38
.text$mn:00006A38                 push    ebp
.text$mn:00006A39                 mov     ebp, esp
.text$mn:00006A3B                 sub     esp, 8
.text$mn:00006A3E                 mov     [ebp+var_8], ecx
.text$mn:00006A41                 lea     eax, [ebp+var_1]
.text$mn:00006A44                 push    eax
.text$mn:00006A45                 mov     ecx, [ebp+var_8]
.text$mn:00006A48                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)
.text$mn:00006A4D                 lea     ecx, [ebp+var_1]
.text$mn:00006A50                 push    ecx
.text$mn:00006A51                 mov     edx, [ebp+arg_4]
.text$mn:00006A54                 push    edx
.text$mn:00006A55                 mov     eax, [ebp+arg_0]
.text$mn:00006A58                 push    eax
.text$mn:00006A59                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)
.text$mn:00006A5E                 add     esp, 0Ch
.text$mn:00006A61                 mov     esp, ebp
.text$mn:00006A63                 pop     ebp
.text$mn:00006A64                 retn    8
.text$mn:00006A64 ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z endp
.text$mn:00006A64
.text$mn:00006A64 ; ---------------------------------------------------------------------------
.text$mn:00006A67                 align 4
.text$mn:00006A67 _text$mn        ends
.text$mn:00006A67
.text$mn:00006A68 ; ===========================================================================
.text$mn:00006A68
.text$mn:00006A68 ; Segment type: Pure code
.text$mn:00006A68 ; Segment permissions: Read/Execute
.text$mn:00006A68 _text$mn        segment para public 'CODE' use32
.text$mn:00006A68                 assume cs:_text$mn
.text$mn:00006A68                 ;org 6A68h
.text$mn:00006A68 ; COMDAT (pick any)
.text$mn:00006A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A68
.text$mn:00006A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00006A68
.text$mn:00006A68 ; Attributes: bp-based frame
.text$mn:00006A68
.text$mn:00006A68 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00006A68                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00006A68 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00006A68                                         ; CODE XREF: $LN19+60p
.text$mn:00006A68                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00006A68
.text$mn:00006A68 var_8           = dword ptr -8
.text$mn:00006A68 var_1           = byte ptr -1
.text$mn:00006A68 arg_0           = dword ptr  8
.text$mn:00006A68
.text$mn:00006A68                 push    ebp
.text$mn:00006A69                 mov     ebp, esp
.text$mn:00006A6B                 sub     esp, 8
.text$mn:00006A6E                 mov     [ebp+var_8], ecx
.text$mn:00006A71                 mov     [ebp+var_1], 0
.text$mn:00006A75                 mov     eax, [ebp+var_8]
.text$mn:00006A78                 mov     ecx, [ebp+arg_0]
.text$mn:00006A7B                 mov     [eax+14h], ecx
.text$mn:00006A7E                 lea     edx, [ebp+var_1]
.text$mn:00006A81                 push    edx
.text$mn:00006A82                 mov     ecx, [ebp+var_8]
.text$mn:00006A85                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00006A8A                 add     eax, [ebp+arg_0]
.text$mn:00006A8D                 push    eax
.text$mn:00006A8E                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00006A93                 add     esp, 8
.text$mn:00006A96                 mov     esp, ebp
.text$mn:00006A98                 pop     ebp
.text$mn:00006A99                 retn    4
.text$mn:00006A99 ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00006A99
.text$mn:00006A99 _text$mn        ends
.text$mn:00006A99
.text$mn:00006A9C ; ===========================================================================
.text$mn:00006A9C
.text$mn:00006A9C ; Segment type: Pure code
.text$mn:00006A9C ; Segment permissions: Read/Execute
.text$mn:00006A9C _text$mn        segment para public 'CODE' use32
.text$mn:00006A9C                 assume cs:_text$mn
.text$mn:00006A9C                 ;org 6A9Ch
.text$mn:00006A9C ; COMDAT (pick any)
.text$mn:00006A9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006A9C
.text$mn:00006A9C ; =============== S U B R O U T I N E =======================================
.text$mn:00006A9C
.text$mn:00006A9C ; Attributes: bp-based frame
.text$mn:00006A9C
.text$mn:00006A9C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00006A9C                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00006A9C ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006A9C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00006A9C
.text$mn:00006A9C var_8           = dword ptr -8
.text$mn:00006A9C var_1           = byte ptr -1
.text$mn:00006A9C
.text$mn:00006A9C                 push    ebp
.text$mn:00006A9D                 mov     ebp, esp
.text$mn:00006A9F                 sub     esp, 8
.text$mn:00006AA2                 mov     [ebp+var_8], ecx
.text$mn:00006AA5                 lea     ecx, [ebp+var_1]
.text$mn:00006AA8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00006AAD                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006AB0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006AB5                 mov     eax, [ebp+var_8]
.text$mn:00006AB8                 mov     ecx, [eax]
.text$mn:00006ABA                 push    ecx
.text$mn:00006ABB                 lea     ecx, [ebp+var_1]
.text$mn:00006ABE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006AC3                 push    1               ; int
.text$mn:00006AC5                 mov     edx, [ebp+var_8]
.text$mn:00006AC8                 mov     eax, [edx]
.text$mn:00006ACA                 push    eax             ; void *
.text$mn:00006ACB                 lea     ecx, [ebp+var_1]
.text$mn:00006ACE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006AD3                 mov     ecx, [ebp+var_8]
.text$mn:00006AD6                 mov     dword ptr [ecx], 0
.text$mn:00006ADC                 mov     esp, ebp
.text$mn:00006ADE                 pop     ebp
.text$mn:00006ADF                 retn
.text$mn:00006ADF ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00006ADF
.text$mn:00006ADF _text$mn        ends
.text$mn:00006ADF
.text$mn:00006AE0 ; ===========================================================================
.text$mn:00006AE0
.text$mn:00006AE0 ; Segment type: Pure code
.text$mn:00006AE0 ; Segment permissions: Read/Execute
.text$mn:00006AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00006AE0                 assume cs:_text$mn
.text$mn:00006AE0                 ;org 6AE0h
.text$mn:00006AE0 ; COMDAT (pick any)
.text$mn:00006AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006AE0
.text$mn:00006AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00006AE0
.text$mn:00006AE0 ; Attributes: bp-based frame
.text$mn:00006AE0
.text$mn:00006AE0 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>::_Free_proxy(void)
.text$mn:00006AE0                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ
.text$mn:00006AE0 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00006AE0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::~_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>(void)+30p
.text$mn:00006AE0
.text$mn:00006AE0 var_8           = dword ptr -8
.text$mn:00006AE0 var_1           = byte ptr -1
.text$mn:00006AE0
.text$mn:00006AE0                 push    ebp
.text$mn:00006AE1                 mov     ebp, esp
.text$mn:00006AE3                 sub     esp, 8
.text$mn:00006AE6                 mov     [ebp+var_8], ecx
.text$mn:00006AE9                 lea     ecx, [ebp+var_1]
.text$mn:00006AEC                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00006AF1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00006AF4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006AF9                 mov     eax, [ebp+var_8]
.text$mn:00006AFC                 mov     ecx, [eax]
.text$mn:00006AFE                 push    ecx
.text$mn:00006AFF                 lea     ecx, [ebp+var_1]
.text$mn:00006B02                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00006B07                 push    1               ; int
.text$mn:00006B09                 mov     edx, [ebp+var_8]
.text$mn:00006B0C                 mov     eax, [edx]
.text$mn:00006B0E                 push    eax             ; void *
.text$mn:00006B0F                 lea     ecx, [ebp+var_1]
.text$mn:00006B12                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:00006B17                 mov     ecx, [ebp+var_8]
.text$mn:00006B1A                 mov     dword ptr [ecx], 0
.text$mn:00006B20                 mov     esp, ebp
.text$mn:00006B22                 pop     ebp
.text$mn:00006B23                 retn
.text$mn:00006B23 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAEXXZ endp
.text$mn:00006B23
.text$mn:00006B23 _text$mn        ends
.text$mn:00006B23
.text$mn:00006B24 ; ===========================================================================
.text$mn:00006B24
.text$mn:00006B24 ; Segment type: Pure code
.text$mn:00006B24 ; Segment permissions: Read/Execute
.text$mn:00006B24 _text$mn        segment para public 'CODE' use32
.text$mn:00006B24                 assume cs:_text$mn
.text$mn:00006B24                 ;org 6B24h
.text$mn:00006B24 ; COMDAT (pick any)
.text$mn:00006B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B24
.text$mn:00006B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B24
.text$mn:00006B24 ; Attributes: bp-based frame
.text$mn:00006B24
.text$mn:00006B24 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00006B24                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00006B24 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00006B24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00006B24                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00006B24
.text$mn:00006B24 var_4           = dword ptr -4
.text$mn:00006B24 arg_0           = dword ptr  8
.text$mn:00006B24
.text$mn:00006B24                 push    ebp
.text$mn:00006B25                 mov     ebp, esp
.text$mn:00006B27                 push    ecx
.text$mn:00006B28                 mov     [ebp+var_4], ecx
.text$mn:00006B2B                 mov     ecx, [ebp+arg_0]
.text$mn:00006B2E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00006B33                 mov     eax, [ebp+arg_0]
.text$mn:00006B36                 mov     esp, ebp
.text$mn:00006B38                 pop     ebp
.text$mn:00006B39                 retn    4
.text$mn:00006B39 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00006B39
.text$mn:00006B39 _text$mn        ends
.text$mn:00006B39
.text$mn:00006B3C ; ===========================================================================
.text$mn:00006B3C
.text$mn:00006B3C ; Segment type: Pure code
.text$mn:00006B3C ; Segment permissions: Read/Execute
.text$mn:00006B3C _text$mn        segment para public 'CODE' use32
.text$mn:00006B3C                 assume cs:_text$mn
.text$mn:00006B3C                 ;org 6B3Ch
.text$mn:00006B3C ; COMDAT (pick any)
.text$mn:00006B3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B3C
.text$mn:00006B3C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B3C
.text$mn:00006B3C ; Attributes: bp-based frame
.text$mn:00006B3C
.text$mn:00006B3C ; public: struct std::_Wrap_alloc<class std::allocator<unsigned char>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<unsigned char, class std::allocator<unsigned char>>>::_Getal(void)const
.text$mn:00006B3C                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ
.text$mn:00006B3C ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ proc near
.text$mn:00006B3C                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Ucopy<uchar *>(uchar *,uchar *,uchar *)+10p
.text$mn:00006B3C                                         ; std::vector<uchar,std::allocator<uchar>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,uchar *)+36p ...
.text$mn:00006B3C
.text$mn:00006B3C var_4           = dword ptr -4
.text$mn:00006B3C arg_0           = dword ptr  8
.text$mn:00006B3C
.text$mn:00006B3C                 push    ebp
.text$mn:00006B3D                 mov     ebp, esp
.text$mn:00006B3F                 push    ecx
.text$mn:00006B40                 mov     [ebp+var_4], ecx
.text$mn:00006B43                 mov     ecx, [ebp+arg_0]
.text$mn:00006B46                 call    ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<uchar>>::_Wrap_alloc<std::allocator<uchar>>(void)
.text$mn:00006B4B                 mov     eax, [ebp+arg_0]
.text$mn:00006B4E                 mov     esp, ebp
.text$mn:00006B50                 pop     ebp
.text$mn:00006B51                 retn    4
.text$mn:00006B51 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ endp
.text$mn:00006B51
.text$mn:00006B51 _text$mn        ends
.text$mn:00006B51
.text$mn:00006B54 ; ===========================================================================
.text$mn:00006B54
.text$mn:00006B54 ; Segment type: Pure code
.text$mn:00006B54 ; Segment permissions: Read/Execute
.text$mn:00006B54 _text$mn        segment para public 'CODE' use32
.text$mn:00006B54                 assume cs:_text$mn
.text$mn:00006B54                 ;org 6B54h
.text$mn:00006B54 ; COMDAT (pick any)
.text$mn:00006B54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B54
.text$mn:00006B54 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B54
.text$mn:00006B54 ; Attributes: bp-based frame
.text$mn:00006B54
.text$mn:00006B54 ; public: struct std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>::_Getal(void)const
.text$mn:00006B54                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ
.text$mn:00006B54 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ proc near
.text$mn:00006B54                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Umove<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+10p
.text$mn:00006B54                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Destroy(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+10p ...
.text$mn:00006B54
.text$mn:00006B54 var_4           = dword ptr -4
.text$mn:00006B54 arg_0           = dword ptr  8
.text$mn:00006B54
.text$mn:00006B54                 push    ebp
.text$mn:00006B55                 mov     ebp, esp
.text$mn:00006B57                 push    ecx
.text$mn:00006B58                 mov     [ebp+var_4], ecx
.text$mn:00006B5B                 mov     ecx, [ebp+arg_0]
.text$mn:00006B5E                 call    ??0?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>(void)
.text$mn:00006B63                 mov     eax, [ebp+arg_0]
.text$mn:00006B66                 mov     esp, ebp
.text$mn:00006B68                 pop     ebp
.text$mn:00006B69                 retn    4
.text$mn:00006B69 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ endp
.text$mn:00006B69
.text$mn:00006B69 _text$mn        ends
.text$mn:00006B69
.text$mn:00006B6C ; ===========================================================================
.text$mn:00006B6C
.text$mn:00006B6C ; Segment type: Pure code
.text$mn:00006B6C ; Segment permissions: Read/Execute
.text$mn:00006B6C _text$mn        segment para public 'CODE' use32
.text$mn:00006B6C                 assume cs:_text$mn
.text$mn:00006B6C                 ;org 6B6Ch
.text$mn:00006B6C ; COMDAT (pick any)
.text$mn:00006B6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B6C
.text$mn:00006B6C ; =============== S U B R O U T I N E =======================================
.text$mn:00006B6C
.text$mn:00006B6C ; Attributes: bp-based frame
.text$mn:00006B6C
.text$mn:00006B6C ; const struct std::_Container_base12 *__thiscall std::_Iterator_base12::_Getcont(std::_Iterator_base12 *__hidden this)
.text$mn:00006B6C                 public ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
.text$mn:00006B6C ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ proc near
.text$mn:00006B6C                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+Ap
.text$mn:00006B6C                                         ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+1Fp ...
.text$mn:00006B6C
.text$mn:00006B6C var_8           = dword ptr -8
.text$mn:00006B6C var_4           = dword ptr -4
.text$mn:00006B6C
.text$mn:00006B6C                 push    ebp
.text$mn:00006B6D                 mov     ebp, esp
.text$mn:00006B6F                 sub     esp, 8
.text$mn:00006B72                 mov     [ebp+var_4], ecx
.text$mn:00006B75                 mov     eax, [ebp+var_4]
.text$mn:00006B78                 cmp     dword ptr [eax], 0
.text$mn:00006B7B                 jnz     short loc_6B86
.text$mn:00006B7D                 mov     [ebp+var_8], 0
.text$mn:00006B84                 jmp     short loc_6B90
.text$mn:00006B86 ; ---------------------------------------------------------------------------
.text$mn:00006B86
.text$mn:00006B86 loc_6B86:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+Fj
.text$mn:00006B86                 mov     ecx, [ebp+var_4]
.text$mn:00006B89                 mov     edx, [ecx]
.text$mn:00006B8B                 mov     eax, [edx]
.text$mn:00006B8D                 mov     [ebp+var_8], eax
.text$mn:00006B90
.text$mn:00006B90 loc_6B90:                               ; CODE XREF: std::_Iterator_base12::_Getcont(void)+18j
.text$mn:00006B90                 mov     eax, [ebp+var_8]
.text$mn:00006B93                 mov     esp, ebp
.text$mn:00006B95                 pop     ebp
.text$mn:00006B96                 retn
.text$mn:00006B96 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ endp
.text$mn:00006B96
.text$mn:00006B96 ; ---------------------------------------------------------------------------
.text$mn:00006B97                 align 4
.text$mn:00006B97 _text$mn        ends
.text$mn:00006B97
.text$mn:00006B98 ; ===========================================================================
.text$mn:00006B98
.text$mn:00006B98 ; Segment type: Pure code
.text$mn:00006B98 ; Segment permissions: Read/Execute
.text$mn:00006B98 _text$mn        segment para public 'CODE' use32
.text$mn:00006B98                 assume cs:_text$mn
.text$mn:00006B98                 ;org 6B98h
.text$mn:00006B98 ; COMDAT (pick any)
.text$mn:00006B98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006B98
.text$mn:00006B98 ; =============== S U B R O U T I N E =======================================
.text$mn:00006B98
.text$mn:00006B98 ; Attributes: bp-based frame
.text$mn:00006B98
.text$mn:00006B98 ; struct std::_Iterator_base12 **__thiscall std::_Container_base12::_Getpfirst(std::_Container_base12 *__hidden this)
.text$mn:00006B98                 public ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
.text$mn:00006B98 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ proc near
.text$mn:00006B98                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+3Cp
.text$mn:00006B98                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+3Cp
.text$mn:00006B98
.text$mn:00006B98 var_8           = dword ptr -8
.text$mn:00006B98 var_4           = dword ptr -4
.text$mn:00006B98
.text$mn:00006B98                 push    ebp
.text$mn:00006B99                 mov     ebp, esp
.text$mn:00006B9B                 sub     esp, 8
.text$mn:00006B9E                 mov     [ebp+var_4], ecx
.text$mn:00006BA1                 mov     eax, [ebp+var_4]
.text$mn:00006BA4                 cmp     dword ptr [eax], 0
.text$mn:00006BA7                 jnz     short loc_6BB2
.text$mn:00006BA9                 mov     [ebp+var_8], 0
.text$mn:00006BB0                 jmp     short loc_6BBD
.text$mn:00006BB2 ; ---------------------------------------------------------------------------
.text$mn:00006BB2
.text$mn:00006BB2 loc_6BB2:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+Fj
.text$mn:00006BB2                 mov     ecx, [ebp+var_4]
.text$mn:00006BB5                 mov     edx, [ecx]
.text$mn:00006BB7                 add     edx, 4
.text$mn:00006BBA                 mov     [ebp+var_8], edx
.text$mn:00006BBD
.text$mn:00006BBD loc_6BBD:                               ; CODE XREF: std::_Container_base12::_Getpfirst(void)+18j
.text$mn:00006BBD                 mov     eax, [ebp+var_8]
.text$mn:00006BC0                 mov     esp, ebp
.text$mn:00006BC2                 pop     ebp
.text$mn:00006BC3                 retn
.text$mn:00006BC3 ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ endp
.text$mn:00006BC3
.text$mn:00006BC3 _text$mn        ends
.text$mn:00006BC3
.text$mn:00006BC4 ; ===========================================================================
.text$mn:00006BC4
.text$mn:00006BC4 ; Segment type: Pure code
.text$mn:00006BC4 ; Segment permissions: Read/Execute
.text$mn:00006BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00006BC4                 assume cs:_text$mn
.text$mn:00006BC4                 ;org 6BC4h
.text$mn:00006BC4 ; COMDAT (pick any)
.text$mn:00006BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BC4
.text$mn:00006BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BC4
.text$mn:00006BC4 ; Attributes: bp-based frame
.text$mn:00006BC4
.text$mn:00006BC4 ; struct std::_Iterator_base12 **__thiscall std::_Iterator_base12::_Getpnext(std::_Iterator_base12 *__hidden this)
.text$mn:00006BC4                 public ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
.text$mn:00006BC4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ proc near
.text$mn:00006BC4                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+71p
.text$mn:00006BC4                                         ; std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+8Ap ...
.text$mn:00006BC4
.text$mn:00006BC4 var_4           = dword ptr -4
.text$mn:00006BC4
.text$mn:00006BC4                 push    ebp
.text$mn:00006BC5                 mov     ebp, esp
.text$mn:00006BC7                 push    ecx
.text$mn:00006BC8                 mov     [ebp+var_4], ecx
.text$mn:00006BCB                 mov     eax, [ebp+var_4]
.text$mn:00006BCE                 add     eax, 4
.text$mn:00006BD1                 mov     esp, ebp
.text$mn:00006BD3                 pop     ebp
.text$mn:00006BD4                 retn
.text$mn:00006BD4 ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ endp
.text$mn:00006BD4
.text$mn:00006BD4 ; ---------------------------------------------------------------------------
.text$mn:00006BD5                 align 4
.text$mn:00006BD5 _text$mn        ends
.text$mn:00006BD5
.text$mn:00006BD8 ; ===========================================================================
.text$mn:00006BD8
.text$mn:00006BD8 ; Segment type: Pure code
.text$mn:00006BD8 ; Segment permissions: Read/Execute
.text$mn:00006BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00006BD8                 assume cs:_text$mn
.text$mn:00006BD8                 ;org 6BD8h
.text$mn:00006BD8 ; COMDAT (pick any)
.text$mn:00006BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006BD8
.text$mn:00006BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00006BD8
.text$mn:00006BD8 ; Attributes: bp-based frame
.text$mn:00006BD8
.text$mn:00006BD8 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00006BD8                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00006BD8 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00006BD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00006BD8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00006BD8
.text$mn:00006BD8 var_C           = dword ptr -0Ch
.text$mn:00006BD8 Size            = dword ptr -8
.text$mn:00006BD8 var_4           = dword ptr -4
.text$mn:00006BD8 arg_0           = dword ptr  8
.text$mn:00006BD8 arg_4           = byte ptr  0Ch
.text$mn:00006BD8
.text$mn:00006BD8                 push    ebp
.text$mn:00006BD9                 mov     ebp, esp
.text$mn:00006BDB                 sub     esp, 0Ch
.text$mn:00006BDE                 mov     [ebp+var_4], ecx
.text$mn:00006BE1                 mov     ecx, [ebp+var_4]
.text$mn:00006BE4                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00006BE9                 cmp     eax, [ebp+arg_0]
.text$mn:00006BEC                 jnb     short loc_6BF6
.text$mn:00006BEE                 mov     ecx, [ebp+var_4]
.text$mn:00006BF1                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00006BF6
.text$mn:00006BF6 loc_6BF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00006BF6                 mov     eax, [ebp+var_4]
.text$mn:00006BF9                 mov     ecx, [eax+18h]
.text$mn:00006BFC                 cmp     ecx, [ebp+arg_0]
.text$mn:00006BFF                 jnb     short loc_6C16
.text$mn:00006C01                 mov     edx, [ebp+var_4]
.text$mn:00006C04                 mov     eax, [edx+14h]
.text$mn:00006C07                 push    eax
.text$mn:00006C08                 mov     ecx, [ebp+arg_0]
.text$mn:00006C0B                 push    ecx
.text$mn:00006C0C                 mov     ecx, [ebp+var_4]
.text$mn:00006C0F                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00006C14                 jmp     short loc_6C60
.text$mn:00006C16 ; ---------------------------------------------------------------------------
.text$mn:00006C16
.text$mn:00006C16 loc_6C16:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:00006C16                 movzx   edx, [ebp+arg_4]
.text$mn:00006C1A                 test    edx, edx
.text$mn:00006C1C                 jz      short loc_6C50
.text$mn:00006C1E                 cmp     [ebp+arg_0], 10h
.text$mn:00006C22                 jnb     short loc_6C50
.text$mn:00006C24                 mov     eax, [ebp+var_4]
.text$mn:00006C27                 mov     ecx, [ebp+arg_0]
.text$mn:00006C2A                 cmp     ecx, [eax+14h]
.text$mn:00006C2D                 jnb     short loc_6C37
.text$mn:00006C2F                 mov     edx, [ebp+arg_0]
.text$mn:00006C32                 mov     [ebp+Size], edx
.text$mn:00006C35                 jmp     short loc_6C40
.text$mn:00006C37 ; ---------------------------------------------------------------------------
.text$mn:00006C37
.text$mn:00006C37 loc_6C37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:00006C37                 mov     eax, [ebp+var_4]
.text$mn:00006C3A                 mov     ecx, [eax+14h]
.text$mn:00006C3D                 mov     [ebp+Size], ecx
.text$mn:00006C40
.text$mn:00006C40 loc_6C40:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:00006C40                 mov     edx, [ebp+Size]
.text$mn:00006C43                 push    edx             ; Size
.text$mn:00006C44                 push    1               ; char
.text$mn:00006C46                 mov     ecx, [ebp+var_4]
.text$mn:00006C49                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00006C4E                 jmp     short loc_6C60
.text$mn:00006C50 ; ---------------------------------------------------------------------------
.text$mn:00006C50
.text$mn:00006C50 loc_6C50:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:00006C50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:00006C50                 cmp     [ebp+arg_0], 0
.text$mn:00006C54                 jnz     short loc_6C60
.text$mn:00006C56                 push    0
.text$mn:00006C58                 mov     ecx, [ebp+var_4]
.text$mn:00006C5B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00006C60
.text$mn:00006C60 loc_6C60:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00006C60                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00006C60                 cmp     [ebp+arg_0], 0
.text$mn:00006C64                 jbe     short loc_6C6F
.text$mn:00006C66                 mov     [ebp+var_C], 1
.text$mn:00006C6D                 jmp     short loc_6C76
.text$mn:00006C6F ; ---------------------------------------------------------------------------
.text$mn:00006C6F
.text$mn:00006C6F loc_6C6F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:00006C6F                 mov     [ebp+var_C], 0
.text$mn:00006C76
.text$mn:00006C76 loc_6C76:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00006C76                 mov     al, byte ptr [ebp+var_C]
.text$mn:00006C79                 mov     esp, ebp
.text$mn:00006C7B                 pop     ebp
.text$mn:00006C7C                 retn    8
.text$mn:00006C7C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00006C7C
.text$mn:00006C7C ; ---------------------------------------------------------------------------
.text$mn:00006C7F                 align 10h
.text$mn:00006C7F _text$mn        ends
.text$mn:00006C7F
.text$mn:00006C80 ; ===========================================================================
.text$mn:00006C80
.text$mn:00006C80 ; Segment type: Pure code
.text$mn:00006C80 ; Segment permissions: Read/Execute
.text$mn:00006C80 _text$mn        segment para public 'CODE' use32
.text$mn:00006C80                 assume cs:_text$mn
.text$mn:00006C80                 ;org 6C80h
.text$mn:00006C80 ; COMDAT (pick any)
.text$mn:00006C80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006C80
.text$mn:00006C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00006C80
.text$mn:00006C80 ; Attributes: bp-based frame
.text$mn:00006C80
.text$mn:00006C80 ; protected: unsigned int __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Grow_to(unsigned int)const
.text$mn:00006C80                 public ?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z
.text$mn:00006C80 ?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z proc near
.text$mn:00006C80                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)+45p
.text$mn:00006C80
.text$mn:00006C80 var_C           = dword ptr -0Ch
.text$mn:00006C80 var_8           = dword ptr -8
.text$mn:00006C80 var_4           = dword ptr -4
.text$mn:00006C80 arg_0           = dword ptr  8
.text$mn:00006C80
.text$mn:00006C80                 push    ebp
.text$mn:00006C81                 mov     ebp, esp
.text$mn:00006C83                 sub     esp, 0Ch
.text$mn:00006C86                 mov     [ebp+var_8], ecx
.text$mn:00006C89                 mov     ecx, [ebp+var_8]
.text$mn:00006C8C                 call    ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::capacity(void)
.text$mn:00006C91                 mov     [ebp+var_4], eax
.text$mn:00006C94                 mov     ecx, [ebp+var_8]
.text$mn:00006C97                 call    ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::max_size(void)
.text$mn:00006C9C                 mov     ecx, [ebp+var_4]
.text$mn:00006C9F                 shr     ecx, 1
.text$mn:00006CA1                 sub     eax, ecx
.text$mn:00006CA3                 cmp     eax, [ebp+var_4]
.text$mn:00006CA6                 jnb     short loc_6CB1
.text$mn:00006CA8                 mov     [ebp+var_C], 0
.text$mn:00006CAF                 jmp     short loc_6CBC
.text$mn:00006CB1 ; ---------------------------------------------------------------------------
.text$mn:00006CB1
.text$mn:00006CB1 loc_6CB1:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Grow_to(uint)+26j
.text$mn:00006CB1                 mov     edx, [ebp+var_4]
.text$mn:00006CB4                 shr     edx, 1
.text$mn:00006CB6                 add     edx, [ebp+var_4]
.text$mn:00006CB9                 mov     [ebp+var_C], edx
.text$mn:00006CBC
.text$mn:00006CBC loc_6CBC:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Grow_to(uint)+2Fj
.text$mn:00006CBC                 mov     eax, [ebp+var_C]
.text$mn:00006CBF                 mov     [ebp+var_4], eax
.text$mn:00006CC2                 mov     ecx, [ebp+var_4]
.text$mn:00006CC5                 cmp     ecx, [ebp+arg_0]
.text$mn:00006CC8                 jnb     short loc_6CD0
.text$mn:00006CCA                 mov     edx, [ebp+arg_0]
.text$mn:00006CCD                 mov     [ebp+var_4], edx
.text$mn:00006CD0
.text$mn:00006CD0 loc_6CD0:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Grow_to(uint)+48j
.text$mn:00006CD0                 mov     eax, [ebp+var_4]
.text$mn:00006CD3                 mov     esp, ebp
.text$mn:00006CD5                 pop     ebp
.text$mn:00006CD6                 retn    4
.text$mn:00006CD6 ?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z endp
.text$mn:00006CD6
.text$mn:00006CD6 ; ---------------------------------------------------------------------------
.text$mn:00006CD9                 align 4
.text$mn:00006CD9 _text$mn        ends
.text$mn:00006CD9
.text$mn:00006CDC ; ===========================================================================
.text$mn:00006CDC
.text$mn:00006CDC ; Segment type: Pure code
.text$mn:00006CDC ; Segment permissions: Read/Execute
.text$mn:00006CDC _text$mn        segment para public 'CODE' use32
.text$mn:00006CDC                 assume cs:_text$mn
.text$mn:00006CDC                 ;org 6CDCh
.text$mn:00006CDC ; COMDAT (pick any)
.text$mn:00006CDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006CDC
.text$mn:00006CDC ; =============== S U B R O U T I N E =======================================
.text$mn:00006CDC
.text$mn:00006CDC ; Attributes: bp-based frame
.text$mn:00006CDC
.text$mn:00006CDC ; protected: unsigned int __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Grow_to(unsigned int)const
.text$mn:00006CDC                 public ?_Grow_to@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEII@Z
.text$mn:00006CDC ?_Grow_to@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEII@Z proc near
.text$mn:00006CDC                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+D2p
.text$mn:00006CDC
.text$mn:00006CDC var_C           = dword ptr -0Ch
.text$mn:00006CDC var_8           = dword ptr -8
.text$mn:00006CDC var_4           = dword ptr -4
.text$mn:00006CDC arg_0           = dword ptr  8
.text$mn:00006CDC
.text$mn:00006CDC                 push    ebp
.text$mn:00006CDD                 mov     ebp, esp
.text$mn:00006CDF                 sub     esp, 0Ch
.text$mn:00006CE2                 mov     [ebp+var_8], ecx
.text$mn:00006CE5                 mov     ecx, [ebp+var_8]
.text$mn:00006CE8                 call    ?capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::capacity(void)
.text$mn:00006CED                 mov     [ebp+var_4], eax
.text$mn:00006CF0                 mov     ecx, [ebp+var_8]
.text$mn:00006CF3                 call    ?max_size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::max_size(void)
.text$mn:00006CF8                 mov     ecx, [ebp+var_4]
.text$mn:00006CFB                 shr     ecx, 1
.text$mn:00006CFD                 sub     eax, ecx
.text$mn:00006CFF                 cmp     eax, [ebp+var_4]
.text$mn:00006D02                 jnb     short loc_6D0D
.text$mn:00006D04                 mov     [ebp+var_C], 0
.text$mn:00006D0B                 jmp     short loc_6D18
.text$mn:00006D0D ; ---------------------------------------------------------------------------
.text$mn:00006D0D
.text$mn:00006D0D loc_6D0D:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Grow_to(uint)+26j
.text$mn:00006D0D                 mov     edx, [ebp+var_4]
.text$mn:00006D10                 shr     edx, 1
.text$mn:00006D12                 add     edx, [ebp+var_4]
.text$mn:00006D15                 mov     [ebp+var_C], edx
.text$mn:00006D18
.text$mn:00006D18 loc_6D18:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Grow_to(uint)+2Fj
.text$mn:00006D18                 mov     eax, [ebp+var_C]
.text$mn:00006D1B                 mov     [ebp+var_4], eax
.text$mn:00006D1E                 mov     ecx, [ebp+var_4]
.text$mn:00006D21                 cmp     ecx, [ebp+arg_0]
.text$mn:00006D24                 jnb     short loc_6D2C
.text$mn:00006D26                 mov     edx, [ebp+arg_0]
.text$mn:00006D29                 mov     [ebp+var_4], edx
.text$mn:00006D2C
.text$mn:00006D2C loc_6D2C:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Grow_to(uint)+48j
.text$mn:00006D2C                 mov     eax, [ebp+var_4]
.text$mn:00006D2F                 mov     esp, ebp
.text$mn:00006D31                 pop     ebp
.text$mn:00006D32                 retn    4
.text$mn:00006D32 ?_Grow_to@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEII@Z endp
.text$mn:00006D32
.text$mn:00006D32 ; ---------------------------------------------------------------------------
.text$mn:00006D35                 align 4
.text$mn:00006D35 _text$mn        ends
.text$mn:00006D35
.text$mn:00006D38 ; ===========================================================================
.text$mn:00006D38
.text$mn:00006D38 ; Segment type: Pure code
.text$mn:00006D38 ; Segment permissions: Read/Execute
.text$mn:00006D38 _text$mn        segment para public 'CODE' use32
.text$mn:00006D38                 assume cs:_text$mn
.text$mn:00006D38                 ;org 6D38h
.text$mn:00006D38 ; COMDAT (pick any)
.text$mn:00006D38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00006D38
.text$mn:00006D38 ; =============== S U B R O U T I N E =======================================
.text$mn:00006D38
.text$mn:00006D38 ; Attributes: bp-based frame
.text$mn:00006D38
.text$mn:00006D38 ; protected: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Insert_n(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>, unsigned int, class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:00006D38                 public ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00006D38 ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z proc near
.text$mn:00006D38                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::insert(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,std::vector<uchar,std::allocator<uchar>> const &)+65p
.text$mn:00006D38
.text$mn:00006D38 var_68          = byte ptr -68h
.text$mn:00006D38 var_58          = byte ptr -58h
.text$mn:00006D38 var_48          = byte ptr -48h
.text$mn:00006D38 var_3C          = dword ptr -3Ch
.text$mn:00006D38 var_38          = dword ptr -38h
.text$mn:00006D38 var_34          = dword ptr -34h
.text$mn:00006D38 var_30          = dword ptr -30h
.text$mn:00006D38 var_2C          = dword ptr -2Ch
.text$mn:00006D38 var_28          = dword ptr -28h
.text$mn:00006D38 var_24          = dword ptr -24h
.text$mn:00006D38 var_20          = dword ptr -20h
.text$mn:00006D38 var_1C          = dword ptr -1Ch
.text$mn:00006D38 var_18          = dword ptr -18h
.text$mn:00006D38 var_13          = byte ptr -13h
.text$mn:00006D38 var_11          = byte ptr -11h
.text$mn:00006D38 var_10          = dword ptr -10h
.text$mn:00006D38 var_C           = dword ptr -0Ch
.text$mn:00006D38 var_4           = dword ptr -4
.text$mn:00006D38 arg_0           = dword ptr  8
.text$mn:00006D38 arg_4           = byte ptr  0Ch
.text$mn:00006D38 arg_C           = dword ptr  14h
.text$mn:00006D38 arg_10          = dword ptr  18h
.text$mn:00006D38 arg_14          = dword ptr  1Ch
.text$mn:00006D38
.text$mn:00006D38 ; FUNCTION CHUNK AT .text$mn:00006F24 SIZE 00000009 BYTES
.text$mn:00006D38 ; FUNCTION CHUNK AT .text$mn:00006F34 SIZE 00000101 BYTES
.text$mn:00006D38 ; FUNCTION CHUNK AT .text$mn:00007063 SIZE 00000009 BYTES
.text$mn:00006D38 ; FUNCTION CHUNK AT .text$mn:00007073 SIZE 00000149 BYTES
.text$mn:00006D38
.text$mn:00006D38                 push    ebp
.text$mn:00006D39                 mov     ebp, esp
.text$mn:00006D3B                 push    0FFFFFFFFh
.text$mn:00006D3D                 push    offset __ehhandler$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00006D42                 mov     eax, large fs:0
.text$mn:00006D48                 push    eax
.text$mn:00006D49                 push    ecx
.text$mn:00006D4A                 sub     esp, 58h
.text$mn:00006D4D                 push    ebx
.text$mn:00006D4E                 push    esi
.text$mn:00006D4F                 push    edi
.text$mn:00006D50                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00006D55                 xor     eax, ebp
.text$mn:00006D57                 push    eax
.text$mn:00006D58                 lea     eax, [ebp+var_C]
.text$mn:00006D5B                 mov     large fs:0, eax
.text$mn:00006D61                 mov     [ebp+var_10], esp
.text$mn:00006D64                 mov     [ebp+var_18], ecx
.text$mn:00006D67                 mov     [ebp+var_30], 0
.text$mn:00006D6E                 mov     [ebp+var_4], 1
.text$mn:00006D75                 lea     ecx, [ebp+arg_4] ; this
.text$mn:00006D78                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00006D7D                 cmp     eax, [ebp+var_18]
.text$mn:00006D80                 jnz     short loc_6D98
.text$mn:00006D82                 mov     eax, [ebp+var_18]
.text$mn:00006D85                 mov     ecx, [ebp+arg_C]
.text$mn:00006D88                 cmp     ecx, [eax+4]
.text$mn:00006D8B                 jb      short loc_6D98
.text$mn:00006D8D                 mov     edx, [ebp+var_18]
.text$mn:00006D90                 mov     eax, [edx+8]
.text$mn:00006D93                 cmp     eax, [ebp+arg_C]
.text$mn:00006D96                 jnb     short loc_6DAF
.text$mn:00006D98
.text$mn:00006D98 loc_6D98:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+48j
.text$mn:00006D98                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+53j
.text$mn:00006D98                 push    67Ah            ; unsigned int
.text$mn:00006D9D                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00006DA2                 push    offset ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@ ; "vector insert iterator outside range"
.text$mn:00006DA7                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00006DAC                 add     esp, 0Ch
.text$mn:00006DAF
.text$mn:00006DAF loc_6DAF:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+5Ej
.text$mn:00006DAF                 mov     ecx, [ebp+var_18]
.text$mn:00006DB2                 mov     edx, [ebp+arg_C]
.text$mn:00006DB5                 sub     edx, [ecx+4]
.text$mn:00006DB8                 sar     edx, 4
.text$mn:00006DBB                 mov     [ebp+var_34], edx
.text$mn:00006DBE                 cmp     [ebp+arg_10], 0
.text$mn:00006DC2                 jnz     short loc_6DC9
.text$mn:00006DC4                 jmp     loc_715B
.text$mn:00006DC9 ; ---------------------------------------------------------------------------
.text$mn:00006DC9
.text$mn:00006DC9 loc_6DC9:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+8Aj
.text$mn:00006DC9                 mov     ecx, [ebp+var_18]
.text$mn:00006DCC                 call    ?_Unused_capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Unused_capacity(void)
.text$mn:00006DD1                 cmp     eax, [ebp+arg_10]
.text$mn:00006DD4                 jnb     loc_6FBF
.text$mn:00006DDA                 mov     ecx, [ebp+var_18]
.text$mn:00006DDD                 call    ?max_size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::max_size(void)
.text$mn:00006DE2                 mov     esi, eax
.text$mn:00006DE4                 mov     ecx, [ebp+var_18]
.text$mn:00006DE7                 call    ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::size(void)
.text$mn:00006DEC                 sub     esi, eax
.text$mn:00006DEE                 cmp     esi, [ebp+arg_10]
.text$mn:00006DF1                 jnb     short loc_6DFB
.text$mn:00006DF3                 mov     ecx, [ebp+var_18]
.text$mn:00006DF6                 call    ?_Xlen@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Xlen(void)
.text$mn:00006DFB
.text$mn:00006DFB loc_6DFB:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+B9j
.text$mn:00006DFB                 mov     ecx, [ebp+var_18]
.text$mn:00006DFE                 call    ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::size(void)
.text$mn:00006E03                 add     eax, [ebp+arg_10]
.text$mn:00006E06                 push    eax
.text$mn:00006E07                 mov     ecx, [ebp+var_18]
.text$mn:00006E0A                 call    ?_Grow_to@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEII@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Grow_to(uint)
.text$mn:00006E0F                 mov     [ebp+var_2C], eax
.text$mn:00006E12                 mov     eax, [ebp+var_2C]
.text$mn:00006E15                 push    eax
.text$mn:00006E16                 lea     ecx, [ebp+var_11]
.text$mn:00006E19                 push    ecx
.text$mn:00006E1A                 mov     ecx, [ebp+var_18]
.text$mn:00006E1D                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)
.text$mn:00006E22                 mov     ecx, eax
.text$mn:00006E24                 call    ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::allocate(uint)
.text$mn:00006E29                 mov     [ebp+var_1C], eax
.text$mn:00006E2C                 mov     edx, [ebp+var_18]
.text$mn:00006E2F                 mov     eax, [ebp+arg_C]
.text$mn:00006E32                 sub     eax, [edx+4]
.text$mn:00006E35                 sar     eax, 4
.text$mn:00006E38                 mov     [ebp+var_24], eax
.text$mn:00006E3B                 mov     [ebp+var_20], 0
.text$mn:00006E42                 mov     byte ptr [ebp+var_4], 2
.text$mn:00006E46                 mov     ecx, [ebp+arg_14]
.text$mn:00006E49                 push    ecx
.text$mn:00006E4A                 call    ??$addressof@$$CBV?$vector@EV?$allocator@E@std@@@std@@@std@@YAPBV?$vector@EV?$allocator@E@std@@@0@ABV10@@Z ; std::addressof<std::vector<uchar,std::allocator<uchar>> const>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00006E4F                 add     esp, 4
.text$mn:00006E52                 push    eax             ; int
.text$mn:00006E53                 mov     edx, [ebp+arg_10]
.text$mn:00006E56                 push    edx             ; int
.text$mn:00006E57                 mov     eax, [ebp+var_24]
.text$mn:00006E5A                 shl     eax, 4
.text$mn:00006E5D                 add     eax, [ebp+var_1C]
.text$mn:00006E60                 push    eax             ; void *
.text$mn:00006E61                 mov     ecx, [ebp+var_18]
.text$mn:00006E64                 call    ?_Ufill@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@2@PAV32@IPBV32@@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Ufill(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *)
.text$mn:00006E69                 mov     ecx, [ebp+var_20]
.text$mn:00006E6C                 add     ecx, 1
.text$mn:00006E6F                 mov     [ebp+var_20], ecx
.text$mn:00006E72                 mov     edx, [ebp+var_1C]
.text$mn:00006E75                 push    edx
.text$mn:00006E76                 mov     eax, [ebp+arg_C]
.text$mn:00006E79                 push    eax
.text$mn:00006E7A                 mov     ecx, [ebp+var_18]
.text$mn:00006E7D                 mov     edx, [ecx+4]
.text$mn:00006E80                 push    edx
.text$mn:00006E81                 mov     ecx, [ebp+var_18]
.text$mn:00006E84                 call    ??$_Umove@PAV?$vector@EV?$allocator@E@std@@@std@@@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@1@PAV21@00@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Umove<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00006E89                 mov     eax, [ebp+var_20]
.text$mn:00006E8C                 add     eax, 1
.text$mn:00006E8F                 mov     [ebp+var_20], eax
.text$mn:00006E92                 mov     ecx, [ebp+var_24]
.text$mn:00006E95                 add     ecx, [ebp+arg_10]
.text$mn:00006E98                 shl     ecx, 4
.text$mn:00006E9B                 add     ecx, [ebp+var_1C]
.text$mn:00006E9E                 push    ecx
.text$mn:00006E9F                 mov     edx, [ebp+var_18]
.text$mn:00006EA2                 mov     eax, [edx+8]
.text$mn:00006EA5                 push    eax
.text$mn:00006EA6                 mov     ecx, [ebp+arg_C]
.text$mn:00006EA9                 push    ecx
.text$mn:00006EAA                 mov     ecx, [ebp+var_18]
.text$mn:00006EAD                 call    ??$_Umove@PAV?$vector@EV?$allocator@E@std@@@std@@@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@1@PAV21@00@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Umove<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00006EB2                 jmp     short loc_6F24
.text$mn:00006EB2 ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z endp
.text$mn:00006EB2
.text$mn:00006EB4
.text$mn:00006EB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00006EB4
.text$mn:00006EB4 ; Attributes: noreturn
.text$mn:00006EB4
.text$mn:00006EB4 __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0 proc near
.text$mn:00006EB4                                         ; DATA XREF: .xdata$x:000095A4o
.text$mn:00006EB4                 cmp     dword ptr [ebp-20h], 1
.text$mn:00006EB8                 jle     short loc_6ED0
.text$mn:00006EBA                 mov     edx, [ebp-24h]
.text$mn:00006EBD                 shl     edx, 4
.text$mn:00006EC0                 add     edx, [ebp-1Ch]
.text$mn:00006EC3                 push    edx
.text$mn:00006EC4                 mov     eax, [ebp-1Ch]
.text$mn:00006EC7                 push    eax
.text$mn:00006EC8                 mov     ecx, [ebp-18h]
.text$mn:00006ECB                 call    ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Destroy(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00006ED0
.text$mn:00006ED0 loc_6ED0:                               ; CODE XREF: __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0+4j
.text$mn:00006ED0                 cmp     dword ptr [ebp-20h], 0
.text$mn:00006ED4                 jle     short loc_6EFA
.text$mn:00006ED6                 mov     ecx, [ebp-24h]
.text$mn:00006ED9                 shl     ecx, 4
.text$mn:00006EDC                 add     ecx, [ebp-1Ch]
.text$mn:00006EDF                 mov     edx, [ebp+18h]
.text$mn:00006EE2                 shl     edx, 4
.text$mn:00006EE5                 add     ecx, edx
.text$mn:00006EE7                 push    ecx
.text$mn:00006EE8                 mov     eax, [ebp-24h]
.text$mn:00006EEB                 shl     eax, 4
.text$mn:00006EEE                 add     eax, [ebp-1Ch]
.text$mn:00006EF1                 push    eax
.text$mn:00006EF2                 mov     ecx, [ebp-18h]
.text$mn:00006EF5                 call    ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Destroy(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00006EFA
.text$mn:00006EFA loc_6EFA:                               ; CODE XREF: __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0+20j
.text$mn:00006EFA                 mov     ecx, [ebp-2Ch]
.text$mn:00006EFD                 push    ecx             ; int
.text$mn:00006EFE                 mov     edx, [ebp-1Ch]
.text$mn:00006F01                 push    edx             ; void *
.text$mn:00006F02                 lea     eax, [ebp-12h]
.text$mn:00006F05                 push    eax
.text$mn:00006F06                 mov     ecx, [ebp-18h]
.text$mn:00006F09                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)
.text$mn:00006F0E                 mov     ecx, eax
.text$mn:00006F10                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::deallocate(std::vector<uchar,std::allocator<uchar>> *,uint)
.text$mn:00006F15                 push    0
.text$mn:00006F17                 push    0
.text$mn:00006F19                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00006F19 __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0 endp
.text$mn:00006F19
.text$mn:00006F1E ; ---------------------------------------------------------------------------
.text$mn:00006F1E                 mov     eax, offset $LN28
.text$mn:00006F23                 retn
.text$mn:00006F24 ; ---------------------------------------------------------------------------
.text$mn:00006F24 ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00006F24
.text$mn:00006F24 loc_6F24:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+17Aj
.text$mn:00006F24                 mov     [ebp+var_4], 1
.text$mn:00006F2B                 jmp     short loc_6F34
.text$mn:00006F2B ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00006F2D
.text$mn:00006F2D ; =============== S U B R O U T I N E =======================================
.text$mn:00006F2D
.text$mn:00006F2D
.text$mn:00006F2D $LN28           proc near               ; DATA XREF: .text$mn:00006F1Eo
.text$mn:00006F2D                 mov     dword ptr [ebp-4], 1
.text$mn:00006F2D $LN28           endp ; sp-analysis failed
.text$mn:00006F2D
.text$mn:00006F34 ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00006F34
.text$mn:00006F34 loc_6F34:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+1F3j
.text$mn:00006F34                 mov     ecx, [ebp+var_18]
.text$mn:00006F37                 call    ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::size(void)
.text$mn:00006F3C                 add     eax, [ebp+arg_10]
.text$mn:00006F3F                 mov     [ebp+arg_10], eax
.text$mn:00006F42                 mov     ecx, [ebp+var_18]
.text$mn:00006F45                 cmp     dword ptr [ecx+4], 0
.text$mn:00006F49                 jz      short loc_6F8B
.text$mn:00006F4B                 mov     edx, [ebp+var_18]
.text$mn:00006F4E                 mov     eax, [edx+8]
.text$mn:00006F51                 push    eax
.text$mn:00006F52                 mov     ecx, [ebp+var_18]
.text$mn:00006F55                 mov     edx, [ecx+4]
.text$mn:00006F58                 push    edx
.text$mn:00006F59                 mov     ecx, [ebp+var_18]
.text$mn:00006F5C                 call    ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Destroy(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00006F61                 mov     eax, [ebp+var_18]
.text$mn:00006F64                 mov     ecx, [ebp+var_18]
.text$mn:00006F67                 mov     edx, [eax+0Ch]
.text$mn:00006F6A                 sub     edx, [ecx+4]
.text$mn:00006F6D                 sar     edx, 4
.text$mn:00006F70                 push    edx             ; int
.text$mn:00006F71                 mov     eax, [ebp+var_18]
.text$mn:00006F74                 mov     ecx, [eax+4]
.text$mn:00006F77                 push    ecx             ; void *
.text$mn:00006F78                 lea     edx, [ebp+var_13]
.text$mn:00006F7B                 push    edx
.text$mn:00006F7C                 mov     ecx, [ebp+var_18]
.text$mn:00006F7F                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)
.text$mn:00006F84                 mov     ecx, eax
.text$mn:00006F86                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::deallocate(std::vector<uchar,std::allocator<uchar>> *,uint)
.text$mn:00006F8B
.text$mn:00006F8B loc_6F8B:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+211j
.text$mn:00006F8B                 mov     ecx, [ebp+var_18] ; this
.text$mn:00006F8E                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00006F93                 mov     eax, [ebp+var_2C]
.text$mn:00006F96                 shl     eax, 4
.text$mn:00006F99                 add     eax, [ebp+var_1C]
.text$mn:00006F9C                 mov     ecx, [ebp+var_18]
.text$mn:00006F9F                 mov     [ecx+0Ch], eax
.text$mn:00006FA2                 mov     edx, [ebp+arg_10]
.text$mn:00006FA5                 shl     edx, 4
.text$mn:00006FA8                 add     edx, [ebp+var_1C]
.text$mn:00006FAB                 mov     eax, [ebp+var_18]
.text$mn:00006FAE                 mov     [eax+8], edx
.text$mn:00006FB1                 mov     ecx, [ebp+var_18]
.text$mn:00006FB4                 mov     edx, [ebp+var_1C]
.text$mn:00006FB7                 mov     [ecx+4], edx
.text$mn:00006FBA                 jmp     loc_715B
.text$mn:00006FBF ; ---------------------------------------------------------------------------
.text$mn:00006FBF
.text$mn:00006FBF loc_6FBF:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+9Cj
.text$mn:00006FBF                 mov     eax, [ebp+var_18]
.text$mn:00006FC2                 mov     ecx, [eax+8]
.text$mn:00006FC5                 sub     ecx, [ebp+arg_C]
.text$mn:00006FC8                 sar     ecx, 4
.text$mn:00006FCB                 cmp     ecx, [ebp+arg_10]
.text$mn:00006FCE                 jnb     loc_70C8
.text$mn:00006FD4                 mov     edx, [ebp+arg_14]
.text$mn:00006FD7                 push    edx
.text$mn:00006FD8                 lea     ecx, [ebp+var_58]
.text$mn:00006FDB                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:00006FE0                 mov     byte ptr [ebp+var_4], 4
.text$mn:00006FE4                 mov     eax, [ebp+arg_10]
.text$mn:00006FE7                 shl     eax, 4
.text$mn:00006FEA                 add     eax, [ebp+arg_C]
.text$mn:00006FED                 push    eax
.text$mn:00006FEE                 mov     ecx, [ebp+var_18]
.text$mn:00006FF1                 mov     edx, [ecx+8]
.text$mn:00006FF4                 push    edx
.text$mn:00006FF5                 mov     eax, [ebp+arg_C]
.text$mn:00006FF8                 push    eax
.text$mn:00006FF9                 mov     ecx, [ebp+var_18]
.text$mn:00006FFC                 call    ??$_Umove@PAV?$vector@EV?$allocator@E@std@@@std@@@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@1@PAV21@00@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Umove<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00007001                 mov     byte ptr [ebp+var_4], 5
.text$mn:00007005                 lea     ecx, [ebp+var_58]
.text$mn:00007008                 push    ecx
.text$mn:00007009                 call    ??$addressof@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@AAV10@@Z ; std::addressof<std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> &)
.text$mn:0000700E                 add     esp, 4
.text$mn:00007011                 push    eax             ; int
.text$mn:00007012                 mov     edx, [ebp+var_18]
.text$mn:00007015                 mov     eax, [edx+8]
.text$mn:00007018                 sub     eax, [ebp+arg_C]
.text$mn:0000701B                 sar     eax, 4
.text$mn:0000701E                 mov     ecx, [ebp+arg_10]
.text$mn:00007021                 sub     ecx, eax
.text$mn:00007023                 push    ecx             ; int
.text$mn:00007024                 mov     edx, [ebp+var_18]
.text$mn:00007027                 mov     eax, [edx+8]
.text$mn:0000702A                 push    eax             ; void *
.text$mn:0000702B                 mov     ecx, [ebp+var_18]
.text$mn:0000702E                 call    ?_Ufill@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@2@PAV32@IPBV32@@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Ufill(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *)
.text$mn:00007033                 jmp     short loc_7063
.text$mn:00007033 ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00007035
.text$mn:00007035 ; =============== S U B R O U T I N E =======================================
.text$mn:00007035
.text$mn:00007035 ; Attributes: noreturn
.text$mn:00007035
.text$mn:00007035 __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$2 proc near
.text$mn:00007035                                         ; DATA XREF: .xdata$x:00009594o
.text$mn:00007035                 mov     ecx, [ebp+18h]
.text$mn:00007038                 shl     ecx, 4
.text$mn:0000703B                 mov     edx, [ebp-18h]
.text$mn:0000703E                 add     ecx, [edx+8]
.text$mn:00007041                 push    ecx
.text$mn:00007042                 mov     eax, [ebp+18h]
.text$mn:00007045                 shl     eax, 4
.text$mn:00007048                 add     eax, [ebp+14h]
.text$mn:0000704B                 push    eax
.text$mn:0000704C                 mov     ecx, [ebp-18h]
.text$mn:0000704F                 call    ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Destroy(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00007054                 push    0
.text$mn:00007056                 push    0
.text$mn:00007058                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007058 __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$2 endp
.text$mn:00007058
.text$mn:0000705D ; ---------------------------------------------------------------------------
.text$mn:0000705D                 mov     eax, offset $LN30
.text$mn:00007062                 retn
.text$mn:00007063 ; ---------------------------------------------------------------------------
.text$mn:00007063 ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00007063
.text$mn:00007063 loc_7063:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+2FBj
.text$mn:00007063                 mov     [ebp+var_4], 4
.text$mn:0000706A                 jmp     short loc_7073
.text$mn:0000706A ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:0000706C
.text$mn:0000706C ; =============== S U B R O U T I N E =======================================
.text$mn:0000706C
.text$mn:0000706C
.text$mn:0000706C $LN30           proc near               ; DATA XREF: .text$mn:0000705Do
.text$mn:0000706C                 mov     dword ptr [ebp-4], 4
.text$mn:0000706C $LN30           endp ; sp-analysis failed
.text$mn:0000706C
.text$mn:00007073 ; START OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00007073
.text$mn:00007073 loc_7073:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+332j
.text$mn:00007073                 mov     ecx, [ebp+arg_10]
.text$mn:00007076                 shl     ecx, 4
.text$mn:00007079                 mov     edx, [ebp+var_18]
.text$mn:0000707C                 add     ecx, [edx+8]
.text$mn:0000707F                 mov     eax, [ebp+var_18]
.text$mn:00007082                 mov     [eax+8], ecx
.text$mn:00007085                 mov     ecx, [ebp+var_18]
.text$mn:00007088                 mov     edx, [ecx+8]
.text$mn:0000708B                 push    edx
.text$mn:0000708C                 mov     eax, [ebp+arg_C]
.text$mn:0000708F                 push    eax
.text$mn:00007090                 mov     ecx, [ebp+var_18]
.text$mn:00007093                 call    ?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00007098                 lea     ecx, [ebp+var_58]
.text$mn:0000709B                 push    ecx
.text$mn:0000709C                 mov     edx, [ebp+arg_10]
.text$mn:0000709F                 shl     edx, 4
.text$mn:000070A2                 mov     eax, [ebp+var_18]
.text$mn:000070A5                 mov     ecx, [eax+8]
.text$mn:000070A8                 sub     ecx, edx
.text$mn:000070AA                 push    ecx
.text$mn:000070AB                 mov     edx, [ebp+arg_C]
.text$mn:000070AE                 push    edx
.text$mn:000070AF                 call    ??$fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z ; std::fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:000070B4                 add     esp, 0Ch
.text$mn:000070B7                 mov     byte ptr [ebp+var_4], 1
.text$mn:000070BB                 lea     ecx, [ebp+var_58]
.text$mn:000070BE                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:000070C3                 jmp     loc_715B
.text$mn:000070C8 ; ---------------------------------------------------------------------------
.text$mn:000070C8
.text$mn:000070C8 loc_70C8:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+296j
.text$mn:000070C8                 mov     eax, [ebp+arg_14]
.text$mn:000070CB                 push    eax
.text$mn:000070CC                 lea     ecx, [ebp+var_68]
.text$mn:000070CF                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:000070D4                 mov     byte ptr [ebp+var_4], 7
.text$mn:000070D8                 mov     ecx, [ebp+var_18]
.text$mn:000070DB                 mov     edx, [ecx+8]
.text$mn:000070DE                 mov     [ebp+var_28], edx
.text$mn:000070E1                 mov     eax, [ebp+var_18]
.text$mn:000070E4                 mov     ecx, [eax+8]
.text$mn:000070E7                 push    ecx
.text$mn:000070E8                 mov     edx, [ebp+var_28]
.text$mn:000070EB                 push    edx
.text$mn:000070EC                 mov     eax, [ebp+arg_10]
.text$mn:000070EF                 shl     eax, 4
.text$mn:000070F2                 mov     ecx, [ebp+var_28]
.text$mn:000070F5                 sub     ecx, eax
.text$mn:000070F7                 push    ecx
.text$mn:000070F8                 mov     ecx, [ebp+var_18]
.text$mn:000070FB                 call    ??$_Umove@PAV?$vector@EV?$allocator@E@std@@@std@@@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@1@PAV21@00@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Umove<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00007100                 mov     edx, [ebp+var_18]
.text$mn:00007103                 mov     [edx+8], eax
.text$mn:00007106                 mov     eax, [ebp+var_18]
.text$mn:00007109                 mov     ecx, [eax+8]
.text$mn:0000710C                 push    ecx
.text$mn:0000710D                 mov     edx, [ebp+arg_C]
.text$mn:00007110                 push    edx
.text$mn:00007111                 mov     ecx, [ebp+var_18]
.text$mn:00007114                 call    ?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00007119                 mov     eax, [ebp+var_28]
.text$mn:0000711C                 push    eax
.text$mn:0000711D                 mov     ecx, [ebp+arg_10]
.text$mn:00007120                 shl     ecx, 4
.text$mn:00007123                 mov     edx, [ebp+var_28]
.text$mn:00007126                 sub     edx, ecx
.text$mn:00007128                 push    edx
.text$mn:00007129                 mov     eax, [ebp+arg_C]
.text$mn:0000712C                 push    eax
.text$mn:0000712D                 call    ??$_Copy_backward@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z ; std::_Copy_backward<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00007132                 add     esp, 0Ch
.text$mn:00007135                 lea     ecx, [ebp+var_68]
.text$mn:00007138                 push    ecx
.text$mn:00007139                 mov     edx, [ebp+arg_10]
.text$mn:0000713C                 shl     edx, 4
.text$mn:0000713F                 add     edx, [ebp+arg_C]
.text$mn:00007142                 push    edx
.text$mn:00007143                 mov     eax, [ebp+arg_C]
.text$mn:00007146                 push    eax
.text$mn:00007147                 call    ??$fill@PAV?$vector@EV?$allocator@E@std@@@std@@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@0ABV10@@Z ; std::fill<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>>>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:0000714C                 add     esp, 0Ch
.text$mn:0000714F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007153                 lea     ecx, [ebp+var_68]
.text$mn:00007156                 call    ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$mn:0000715B
.text$mn:0000715B loc_715B:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+8Cj
.text$mn:0000715B                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+282j ...
.text$mn:0000715B                 mov     ecx, [ebp+var_34]
.text$mn:0000715E                 push    ecx
.text$mn:0000715F                 mov     edx, [ebp+arg_0]
.text$mn:00007162                 push    edx
.text$mn:00007163                 lea     eax, [ebp+var_48]
.text$mn:00007166                 push    eax
.text$mn:00007167                 mov     ecx, [ebp+var_18]
.text$mn:0000716A                 call    ?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::begin(void)
.text$mn:0000716F                 mov     [ebp+var_38], eax
.text$mn:00007172                 mov     ecx, [ebp+var_38]
.text$mn:00007175                 mov     [ebp+var_3C], ecx
.text$mn:00007178                 mov     byte ptr [ebp+var_4], 8
.text$mn:0000717C                 mov     ecx, [ebp+var_3C]
.text$mn:0000717F                 call    ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+(int)
.text$mn:00007184                 mov     edx, [ebp+var_30]
.text$mn:00007187                 or      edx, 1
.text$mn:0000718A                 mov     [ebp+var_30], edx
.text$mn:0000718D                 mov     byte ptr [ebp+var_4], 1
.text$mn:00007191                 lea     ecx, [ebp+var_48]
.text$mn:00007194                 call    ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:00007199                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000719D                 lea     ecx, [ebp+arg_4]
.text$mn:000071A0                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:000071A5                 mov     eax, [ebp+arg_0]
.text$mn:000071A8                 mov     ecx, [ebp+var_C]
.text$mn:000071AB                 mov     large fs:0, ecx
.text$mn:000071B2                 pop     ecx
.text$mn:000071B3                 pop     edi
.text$mn:000071B4                 pop     esi
.text$mn:000071B5                 pop     ebx
.text$mn:000071B6                 mov     esp, ebp
.text$mn:000071B8                 pop     ebp
.text$mn:000071B9                 retn    18h
.text$mn:000071B9 ; END OF FUNCTION CHUNK FOR ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:000071B9 _text$mn        ends
.text$mn:000071B9
.text$x:000071BC ; ===========================================================================
.text$x:000071BC
.text$x:000071BC ; Segment type: Pure code
.text$x:000071BC ; Segment permissions: Read/Execute
.text$x:000071BC _text$x         segment para public 'CODE' use32
.text$x:000071BC                 assume cs:_text$x
.text$x:000071BC                 ;org 71BCh
.text$x:000071BC ; COMDAT (pick associative to section at 6D38)
.text$x:000071BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000071BC
.text$x:000071BC ; =============== S U B R O U T I N E =======================================
.text$x:000071BC
.text$x:000071BC
.text$x:000071BC __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$4 proc near
.text$x:000071BC                                         ; DATA XREF: .xdata$x:00009600o
.text$x:000071BC                 lea     ecx, [ebp+0Ch]
.text$x:000071BF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000071BF __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$4 endp
.text$x:000071BF
.text$x:000071C4
.text$x:000071C4 ; =============== S U B R O U T I N E =======================================
.text$x:000071C4
.text$x:000071C4
.text$x:000071C4 __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$5 proc near
.text$x:000071C4                                         ; DATA XREF: .xdata$x:00009618o
.text$x:000071C4                 lea     ecx, [ebp-58h]
.text$x:000071C7                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:000071C7 __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$5 endp
.text$x:000071C7
.text$x:000071CC
.text$x:000071CC ; =============== S U B R O U T I N E =======================================
.text$x:000071CC
.text$x:000071CC
.text$x:000071CC __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$6 proc near
.text$x:000071CC                                         ; DATA XREF: .xdata$x:00009630o
.text$x:000071CC                 lea     ecx, [ebp-68h]
.text$x:000071CF                 jmp     ??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ ; std::vector<uchar,std::allocator<uchar>>::~vector<uchar,std::allocator<uchar>>(void)
.text$x:000071CF __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$6 endp
.text$x:000071CF
.text$x:000071D4
.text$x:000071D4 ; =============== S U B R O U T I N E =======================================
.text$x:000071D4
.text$x:000071D4
.text$x:000071D4 __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$7 proc near
.text$x:000071D4                                         ; DATA XREF: .xdata$x:00009638o
.text$x:000071D4                 lea     ecx, [ebp-48h]
.text$x:000071D7                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000071D7 __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$7 endp
.text$x:000071D7
.text$x:000071DC
.text$x:000071DC ; =============== S U B R O U T I N E =======================================
.text$x:000071DC
.text$x:000071DC
.text$x:000071DC __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$8 proc near
.text$x:000071DC                                         ; DATA XREF: .xdata$x:000095F8o
.text$x:000071DC                 mov     eax, [ebp-30h]
.text$x:000071DF                 and     eax, 1
.text$x:000071E2                 jz      $LN26
.text$x:000071E8                 and     dword ptr [ebp-30h], 0FFFFFFFEh
.text$x:000071EC                 mov     ecx, [ebp+8]
.text$x:000071EF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000071F4 ; ---------------------------------------------------------------------------
.text$x:000071F4
.text$x:000071F4 $LN26:                                  ; CODE XREF: __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$8+6j
.text$x:000071F4                 retn
.text$x:000071F4 __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$8 endp
.text$x:000071F4
.text$x:000071F5
.text$x:000071F5 ; =============== S U B R O U T I N E =======================================
.text$x:000071F5
.text$x:000071F5
.text$x:000071F5 __ehhandler$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z proc near
.text$x:000071F5                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+5o
.text$x:000071F5
.text$x:000071F5 arg_4           = dword ptr  8
.text$x:000071F5
.text$x:000071F5                 mov     edx, [esp+arg_4]
.text$x:000071F9                 lea     eax, [edx+0Ch]
.text$x:000071FC                 mov     ecx, [edx-6Ch]
.text$x:000071FF                 xor     ecx, eax
.text$x:00007201                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007206                 mov     eax, offset __ehfuncinfo$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$x:0000720B                 jmp     ___CxxFrameHandler3
.text$x:0000720B __ehhandler$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z endp
.text$x:0000720B
.text$x:0000720B _text$x         ends
.text$x:0000720B
.text$mn:00007210 ; ===========================================================================
.text$mn:00007210
.text$mn:00007210 ; Segment type: Pure code
.text$mn:00007210 ; Segment permissions: Read/Execute
.text$mn:00007210 _text$mn        segment para public 'CODE' use32
.text$mn:00007210                 assume cs:_text$mn
.text$mn:00007210                 ;org 7210h
.text$mn:00007210 ; COMDAT (pick any)
.text$mn:00007210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007210
.text$mn:00007210 ; =============== S U B R O U T I N E =======================================
.text$mn:00007210
.text$mn:00007210 ; Attributes: bp-based frame
.text$mn:00007210
.text$mn:00007210 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00007210                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00007210 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00007210                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00007210
.text$mn:00007210 var_4           = dword ptr -4
.text$mn:00007210 arg_0           = dword ptr  8
.text$mn:00007210
.text$mn:00007210                 push    ebp
.text$mn:00007211                 mov     ebp, esp
.text$mn:00007213                 push    ecx
.text$mn:00007214                 mov     [ebp+var_4], ecx
.text$mn:00007217                 cmp     [ebp+arg_0], 0
.text$mn:0000721B                 jz      short loc_723D
.text$mn:0000721D                 mov     ecx, [ebp+var_4]
.text$mn:00007220                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007225                 cmp     [ebp+arg_0], eax
.text$mn:00007228                 jb      short loc_723D
.text$mn:0000722A                 mov     ecx, [ebp+var_4]
.text$mn:0000722D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007232                 mov     ecx, [ebp+var_4]
.text$mn:00007235                 add     eax, [ecx+14h]
.text$mn:00007238                 cmp     eax, [ebp+arg_0]
.text$mn:0000723B                 ja      short loc_7243
.text$mn:0000723D
.text$mn:0000723D loc_723D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:0000723D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:0000723D                 xor     al, al
.text$mn:0000723F                 jmp     short loc_7245
.text$mn:00007241 ; ---------------------------------------------------------------------------
.text$mn:00007241                 jmp     short loc_7245
.text$mn:00007243 ; ---------------------------------------------------------------------------
.text$mn:00007243
.text$mn:00007243 loc_7243:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00007243                 mov     al, 1
.text$mn:00007245
.text$mn:00007245 loc_7245:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00007245                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00007245                 mov     esp, ebp
.text$mn:00007247                 pop     ebp
.text$mn:00007248                 retn    4
.text$mn:00007248 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00007248
.text$mn:00007248 ; ---------------------------------------------------------------------------
.text$mn:0000724B                 align 4
.text$mn:0000724B _text$mn        ends
.text$mn:0000724B
.text$mn:0000724C ; ===========================================================================
.text$mn:0000724C
.text$mn:0000724C ; Segment type: Pure code
.text$mn:0000724C ; Segment permissions: Read/Execute
.text$mn:0000724C _text$mn        segment para public 'CODE' use32
.text$mn:0000724C                 assume cs:_text$mn
.text$mn:0000724C                 ;org 724Ch
.text$mn:0000724C ; COMDAT (pick any)
.text$mn:0000724C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000724C
.text$mn:0000724C ; =============== S U B R O U T I N E =======================================
.text$mn:0000724C
.text$mn:0000724C ; Attributes: bp-based frame
.text$mn:0000724C
.text$mn:0000724C ; protected: bool __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Inside(unsigned char const *)const
.text$mn:0000724C                 public ?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z
.text$mn:0000724C ?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z proc near
.text$mn:0000724C                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+19p
.text$mn:0000724C
.text$mn:0000724C var_8           = dword ptr -8
.text$mn:0000724C var_4           = dword ptr -4
.text$mn:0000724C arg_0           = dword ptr  8
.text$mn:0000724C
.text$mn:0000724C                 push    ebp
.text$mn:0000724D                 mov     ebp, esp
.text$mn:0000724F                 sub     esp, 8
.text$mn:00007252                 mov     [ebp+var_4], ecx
.text$mn:00007255                 mov     eax, [ebp+var_4]
.text$mn:00007258                 mov     ecx, [ebp+arg_0]
.text$mn:0000725B                 cmp     ecx, [eax+8]
.text$mn:0000725E                 jnb     short loc_7274
.text$mn:00007260                 mov     edx, [ebp+var_4]
.text$mn:00007263                 mov     eax, [edx+4]
.text$mn:00007266                 cmp     eax, [ebp+arg_0]
.text$mn:00007269                 ja      short loc_7274
.text$mn:0000726B                 mov     [ebp+var_8], 1
.text$mn:00007272                 jmp     short loc_727B
.text$mn:00007274 ; ---------------------------------------------------------------------------
.text$mn:00007274
.text$mn:00007274 loc_7274:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Inside(uchar const *)+12j
.text$mn:00007274                                         ; std::vector<uchar,std::allocator<uchar>>::_Inside(uchar const *)+1Dj
.text$mn:00007274                 mov     [ebp+var_8], 0
.text$mn:0000727B
.text$mn:0000727B loc_727B:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Inside(uchar const *)+26j
.text$mn:0000727B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000727E                 mov     esp, ebp
.text$mn:00007280                 pop     ebp
.text$mn:00007281                 retn    4
.text$mn:00007281 ?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z endp
.text$mn:00007281
.text$mn:00007281 _text$mn        ends
.text$mn:00007281
.text$mn:00007284 ; ===========================================================================
.text$mn:00007284
.text$mn:00007284 ; Segment type: Pure code
.text$mn:00007284 ; Segment permissions: Read/Execute
.text$mn:00007284 _text$mn        segment para public 'CODE' use32
.text$mn:00007284                 assume cs:_text$mn
.text$mn:00007284                 ;org 7284h
.text$mn:00007284 ; COMDAT (pick any)
.text$mn:00007284                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007284
.text$mn:00007284 ; =============== S U B R O U T I N E =======================================
.text$mn:00007284
.text$mn:00007284 ; Attributes: bp-based frame
.text$mn:00007284
.text$mn:00007284 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Make_iter(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>)const
.text$mn:00007284                 public ?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.text$mn:00007284 ?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z proc near
.text$mn:00007284                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+EEp
.text$mn:00007284
.text$mn:00007284 var_14          = dword ptr -14h
.text$mn:00007284 var_10          = dword ptr -10h
.text$mn:00007284 var_C           = dword ptr -0Ch
.text$mn:00007284 var_4           = dword ptr -4
.text$mn:00007284 arg_0           = dword ptr  8
.text$mn:00007284 arg_4           = byte ptr  0Ch
.text$mn:00007284 arg_C           = dword ptr  14h
.text$mn:00007284
.text$mn:00007284                 push    ebp
.text$mn:00007285                 mov     ebp, esp
.text$mn:00007287                 push    0FFFFFFFFh
.text$mn:00007289                 push    offset __ehhandler$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.text$mn:0000728E                 mov     eax, large fs:0
.text$mn:00007294                 push    eax
.text$mn:00007295                 sub     esp, 8
.text$mn:00007298                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000729D                 xor     eax, ebp
.text$mn:0000729F                 push    eax
.text$mn:000072A0                 lea     eax, [ebp+var_C]
.text$mn:000072A3                 mov     large fs:0, eax
.text$mn:000072A9                 mov     [ebp+var_14], ecx
.text$mn:000072AC                 mov     [ebp+var_10], 0
.text$mn:000072B3                 mov     [ebp+var_4], 1
.text$mn:000072BA                 mov     eax, [ebp+var_14]
.text$mn:000072BD                 push    eax             ; struct std::_Container_base12 *
.text$mn:000072BE                 mov     ecx, [ebp+arg_C]
.text$mn:000072C1                 push    ecx             ; int
.text$mn:000072C2                 mov     ecx, [ebp+arg_0]
.text$mn:000072C5                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)
.text$mn:000072CA                 mov     edx, [ebp+var_10]
.text$mn:000072CD                 or      edx, 1
.text$mn:000072D0                 mov     [ebp+var_10], edx
.text$mn:000072D3                 mov     byte ptr [ebp+var_4], 0
.text$mn:000072D7                 lea     ecx, [ebp+arg_4]
.text$mn:000072DA                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:000072DF                 mov     eax, [ebp+arg_0]
.text$mn:000072E2                 mov     ecx, [ebp+var_C]
.text$mn:000072E5                 mov     large fs:0, ecx
.text$mn:000072EC                 pop     ecx
.text$mn:000072ED                 mov     esp, ebp
.text$mn:000072EF                 pop     ebp
.text$mn:000072F0                 retn    10h
.text$mn:000072F0 ?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z endp
.text$mn:000072F0
.text$mn:000072F0 ; ---------------------------------------------------------------------------
.text$mn:000072F3                 align 4
.text$mn:000072F3 _text$mn        ends
.text$mn:000072F3
.text$x:000072F4 ; ===========================================================================
.text$x:000072F4
.text$x:000072F4 ; Segment type: Pure code
.text$x:000072F4 ; Segment permissions: Read/Execute
.text$x:000072F4 _text$x         segment para public 'CODE' use32
.text$x:000072F4                 assume cs:_text$x
.text$x:000072F4                 ;org 72F4h
.text$x:000072F4 ; COMDAT (pick associative to section at 7284)
.text$x:000072F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000072F4
.text$x:000072F4 ; =============== S U B R O U T I N E =======================================
.text$x:000072F4
.text$x:000072F4
.text$x:000072F4 __unwindfunclet$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$0 proc near
.text$x:000072F4                                         ; DATA XREF: .xdata$x:000094E8o
.text$x:000072F4                 lea     ecx, [ebp+0Ch]
.text$x:000072F7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000072F7 __unwindfunclet$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$0 endp
.text$x:000072F7
.text$x:000072FC
.text$x:000072FC ; =============== S U B R O U T I N E =======================================
.text$x:000072FC
.text$x:000072FC
.text$x:000072FC __unwindfunclet$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$1 proc near
.text$x:000072FC                                         ; DATA XREF: .xdata$x:000094E0o
.text$x:000072FC                 mov     eax, [ebp-10h]
.text$x:000072FF                 and     eax, 1
.text$x:00007302                 jz      $LN5
.text$x:00007308                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:0000730C                 mov     ecx, [ebp+8]
.text$x:0000730F                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00007314 ; ---------------------------------------------------------------------------
.text$x:00007314
.text$x:00007314 $LN5:                                   ; CODE XREF: __unwindfunclet$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$1+6j
.text$x:00007314                 retn
.text$x:00007314 __unwindfunclet$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$1 endp
.text$x:00007314
.text$x:00007315
.text$x:00007315 ; =============== S U B R O U T I N E =======================================
.text$x:00007315
.text$x:00007315
.text$x:00007315 __ehhandler$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z proc near
.text$x:00007315                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+5o
.text$x:00007315
.text$x:00007315 arg_4           = dword ptr  8
.text$x:00007315
.text$x:00007315                 mov     edx, [esp+arg_4]
.text$x:00007319                 lea     eax, [edx+0Ch]
.text$x:0000731C                 mov     ecx, [edx-0Ch]
.text$x:0000731F                 xor     ecx, eax
.text$x:00007321                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007326                 mov     eax, offset __ehfuncinfo$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.text$x:0000732B                 jmp     ___CxxFrameHandler3
.text$x:0000732B __ehhandler$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z endp
.text$x:0000732B
.text$x:0000732B _text$x         ends
.text$x:0000732B
.text$mn:00007330 ; ===========================================================================
.text$mn:00007330
.text$mn:00007330 ; Segment type: Pure code
.text$mn:00007330 ; Segment permissions: Read/Execute
.text$mn:00007330 _text$mn        segment para public 'CODE' use32
.text$mn:00007330                 assume cs:_text$mn
.text$mn:00007330                 ;org 7330h
.text$mn:00007330 ; COMDAT (pick any)
.text$mn:00007330                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007330
.text$mn:00007330 ; =============== S U B R O U T I N E =======================================
.text$mn:00007330
.text$mn:00007330 ; Attributes: bp-based frame
.text$mn:00007330
.text$mn:00007330 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007330                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00007330 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00007330                                         ; CODE XREF: $LN19+14p
.text$mn:00007330                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00007330
.text$mn:00007330 var_8           = dword ptr -8
.text$mn:00007330 var_4           = dword ptr -4
.text$mn:00007330
.text$mn:00007330                 push    ebp
.text$mn:00007331                 mov     ebp, esp
.text$mn:00007333                 sub     esp, 8
.text$mn:00007336                 mov     [ebp+var_4], ecx
.text$mn:00007339                 mov     eax, [ebp+var_4]
.text$mn:0000733C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00007340                 jb      short loc_7356
.text$mn:00007342                 mov     ecx, [ebp+var_4]
.text$mn:00007345                 mov     edx, [ecx+4]
.text$mn:00007348                 push    edx
.text$mn:00007349                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000734E                 add     esp, 4
.text$mn:00007351                 mov     [ebp+var_8], eax
.text$mn:00007354                 jmp     short loc_735F
.text$mn:00007356 ; ---------------------------------------------------------------------------
.text$mn:00007356
.text$mn:00007356 loc_7356:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00007356                 mov     eax, [ebp+var_4]
.text$mn:00007359                 add     eax, 4
.text$mn:0000735C                 mov     [ebp+var_8], eax
.text$mn:0000735F
.text$mn:0000735F loc_735F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000735F                 mov     eax, [ebp+var_8]
.text$mn:00007362                 mov     esp, ebp
.text$mn:00007364                 pop     ebp
.text$mn:00007365                 retn
.text$mn:00007365 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00007365
.text$mn:00007365 ; ---------------------------------------------------------------------------
.text$mn:00007366                 align 4
.text$mn:00007366 _text$mn        ends
.text$mn:00007366
.text$mn:00007368 ; ===========================================================================
.text$mn:00007368
.text$mn:00007368 ; Segment type: Pure code
.text$mn:00007368 ; Segment permissions: Read/Execute
.text$mn:00007368 _text$mn        segment para public 'CODE' use32
.text$mn:00007368                 assume cs:_text$mn
.text$mn:00007368                 ;org 7368h
.text$mn:00007368 ; COMDAT (pick any)
.text$mn:00007368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007368
.text$mn:00007368 ; =============== S U B R O U T I N E =======================================
.text$mn:00007368
.text$mn:00007368 ; Attributes: bp-based frame
.text$mn:00007368
.text$mn:00007368 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00007368                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00007368 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00007368                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00007368
.text$mn:00007368 var_8           = dword ptr -8
.text$mn:00007368 var_4           = dword ptr -4
.text$mn:00007368
.text$mn:00007368                 push    ebp
.text$mn:00007369                 mov     ebp, esp
.text$mn:0000736B                 sub     esp, 8
.text$mn:0000736E                 mov     [ebp+var_4], ecx
.text$mn:00007371                 mov     eax, [ebp+var_4]
.text$mn:00007374                 cmp     dword ptr [eax+18h], 10h
.text$mn:00007378                 jb      short loc_738E
.text$mn:0000737A                 mov     ecx, [ebp+var_4]
.text$mn:0000737D                 mov     edx, [ecx+4]
.text$mn:00007380                 push    edx
.text$mn:00007381                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00007386                 add     esp, 4
.text$mn:00007389                 mov     [ebp+var_8], eax
.text$mn:0000738C                 jmp     short loc_7397
.text$mn:0000738E ; ---------------------------------------------------------------------------
.text$mn:0000738E
.text$mn:0000738E loc_738E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000738E                 mov     eax, [ebp+var_4]
.text$mn:00007391                 add     eax, 4
.text$mn:00007394                 mov     [ebp+var_8], eax
.text$mn:00007397
.text$mn:00007397 loc_7397:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00007397                 mov     eax, [ebp+var_8]
.text$mn:0000739A                 mov     esp, ebp
.text$mn:0000739C                 pop     ebp
.text$mn:0000739D                 retn
.text$mn:0000739D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000739D
.text$mn:0000739D ; ---------------------------------------------------------------------------
.text$mn:0000739E                 align 10h
.text$mn:0000739E _text$mn        ends
.text$mn:0000739E
.text$mn:000073A0 ; ===========================================================================
.text$mn:000073A0
.text$mn:000073A0 ; Segment type: Pure code
.text$mn:000073A0 ; Segment permissions: Read/Execute
.text$mn:000073A0 _text$mn        segment para public 'CODE' use32
.text$mn:000073A0                 assume cs:_text$mn
.text$mn:000073A0                 ;org 73A0h
.text$mn:000073A0 ; COMDAT (pick any)
.text$mn:000073A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000073A0
.text$mn:000073A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000073A0
.text$mn:000073A0 ; Attributes: bp-based frame
.text$mn:000073A0
.text$mn:000073A0 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000073A0                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000073A0 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000073A0                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000073A0                                         ; std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+88p ...
.text$mn:000073A0
.text$mn:000073A0 var_18          = byte ptr -18h
.text$mn:000073A0 var_14          = dword ptr -14h
.text$mn:000073A0 var_10          = dword ptr -10h
.text$mn:000073A0 var_C           = dword ptr -0Ch
.text$mn:000073A0 var_4           = dword ptr -4
.text$mn:000073A0
.text$mn:000073A0                 push    ebp
.text$mn:000073A1                 mov     ebp, esp
.text$mn:000073A3                 push    0FFFFFFFFh
.text$mn:000073A5                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000073AA                 mov     eax, large fs:0
.text$mn:000073B0                 push    eax
.text$mn:000073B1                 sub     esp, 0Ch
.text$mn:000073B4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000073B9                 xor     eax, ebp
.text$mn:000073BB                 push    eax
.text$mn:000073BC                 lea     eax, [ebp+var_C]
.text$mn:000073BF                 mov     large fs:0, eax
.text$mn:000073C5                 mov     [ebp+var_14], ecx
.text$mn:000073C8                 mov     eax, [ebp+var_14]
.text$mn:000073CB                 cmp     dword ptr [eax], 0
.text$mn:000073CE                 jz      short loc_742B
.text$mn:000073D0                 push    3               ; int
.text$mn:000073D2                 lea     ecx, [ebp+var_18] ; this
.text$mn:000073D5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000073DA                 mov     [ebp+var_4], 0
.text$mn:000073E1                 mov     ecx, [ebp+var_14]
.text$mn:000073E4                 mov     edx, [ecx]
.text$mn:000073E6                 add     edx, 4
.text$mn:000073E9                 mov     [ebp+var_10], edx
.text$mn:000073EC                 jmp     short loc_73FB
.text$mn:000073EE ; ---------------------------------------------------------------------------
.text$mn:000073EE
.text$mn:000073EE loc_73EE:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:000073EE                 mov     eax, [ebp+var_10]
.text$mn:000073F1                 mov     ecx, [eax]
.text$mn:000073F3                 mov     edx, [ebp+var_10]
.text$mn:000073F6                 mov     eax, [ecx+4]
.text$mn:000073F9                 mov     [edx], eax
.text$mn:000073FB
.text$mn:000073FB loc_73FB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:000073FB                 mov     ecx, [ebp+var_10]
.text$mn:000073FE                 cmp     dword ptr [ecx], 0
.text$mn:00007401                 jz      short loc_7410
.text$mn:00007403                 mov     edx, [ebp+var_10]
.text$mn:00007406                 mov     eax, [edx]
.text$mn:00007408                 mov     dword ptr [eax], 0
.text$mn:0000740E                 jmp     short loc_73EE
.text$mn:00007410 ; ---------------------------------------------------------------------------
.text$mn:00007410
.text$mn:00007410 loc_7410:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00007410                 mov     ecx, [ebp+var_14]
.text$mn:00007413                 mov     edx, [ecx]
.text$mn:00007415                 mov     dword ptr [edx+4], 0
.text$mn:0000741C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007423                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007426                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000742B
.text$mn:0000742B loc_742B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:0000742B                 mov     ecx, [ebp+var_C]
.text$mn:0000742E                 mov     large fs:0, ecx
.text$mn:00007435                 pop     ecx
.text$mn:00007436                 mov     esp, ebp
.text$mn:00007438                 pop     ebp
.text$mn:00007439                 retn
.text$mn:00007439 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00007439
.text$mn:00007439 ; ---------------------------------------------------------------------------
.text$mn:0000743A                 align 4
.text$mn:0000743A _text$mn        ends
.text$mn:0000743A
.text$x:0000743C ; ===========================================================================
.text$x:0000743C
.text$x:0000743C ; Segment type: Pure code
.text$x:0000743C ; Segment permissions: Read/Execute
.text$x:0000743C _text$x         segment para public 'CODE' use32
.text$x:0000743C                 assume cs:_text$x
.text$x:0000743C                 ;org 743Ch
.text$x:0000743C ; COMDAT (pick associative to section at 73A0)
.text$x:0000743C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000743C
.text$x:0000743C ; =============== S U B R O U T I N E =======================================
.text$x:0000743C
.text$x:0000743C
.text$x:0000743C __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:0000743C                                         ; DATA XREF: .xdata$x:00008EB4o
.text$x:0000743C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000743F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000743F __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000743F
.text$x:00007444
.text$x:00007444 ; =============== S U B R O U T I N E =======================================
.text$x:00007444
.text$x:00007444
.text$x:00007444 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00007444                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00007444
.text$x:00007444 arg_4           = dword ptr  8
.text$x:00007444
.text$x:00007444                 mov     edx, [esp+arg_4]
.text$x:00007448                 lea     eax, [edx+0Ch]
.text$x:0000744B                 mov     ecx, [edx-10h]
.text$x:0000744E                 xor     ecx, eax
.text$x:00007450                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007455                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:0000745A                 jmp     ___CxxFrameHandler3
.text$x:0000745A __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:0000745A
.text$x:0000745A ; ---------------------------------------------------------------------------
.text$x:0000745F                 align 10h
.text$x:0000745F _text$x         ends
.text$x:0000745F
.text$mn:00007460 ; ===========================================================================
.text$mn:00007460
.text$mn:00007460 ; Segment type: Pure code
.text$mn:00007460 ; Segment permissions: Read/Execute
.text$mn:00007460 _text$mn        segment para public 'CODE' use32
.text$mn:00007460                 assume cs:_text$mn
.text$mn:00007460                 ;org 7460h
.text$mn:00007460 ; COMDAT (pick any)
.text$mn:00007460                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007460
.text$mn:00007460 ; =============== S U B R O U T I N E =======================================
.text$mn:00007460
.text$mn:00007460 ; Attributes: bp-based frame
.text$mn:00007460
.text$mn:00007460 ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:00007460                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:00007460 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:00007460                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:00007460                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:00007460
.text$mn:00007460 var_8           = dword ptr -8
.text$mn:00007460 var_4           = dword ptr -4
.text$mn:00007460
.text$mn:00007460                 push    ebp
.text$mn:00007461                 mov     ebp, esp
.text$mn:00007463                 sub     esp, 8
.text$mn:00007466                 mov     [ebp+var_8], ecx
.text$mn:00007469                 mov     eax, [ebp+var_8]
.text$mn:0000746C                 cmp     dword ptr [eax], 0
.text$mn:0000746F                 jz      short loc_74CE
.text$mn:00007471                 mov     ecx, [ebp+var_8]
.text$mn:00007474                 mov     edx, [ecx]
.text$mn:00007476                 add     edx, 4
.text$mn:00007479                 mov     [ebp+var_4], edx
.text$mn:0000747C
.text$mn:0000747C loc_747C:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:0000747C                 mov     eax, [ebp+var_4]
.text$mn:0000747F                 cmp     dword ptr [eax], 0
.text$mn:00007482                 jz      short loc_749B
.text$mn:00007484                 mov     ecx, [ebp+var_4]
.text$mn:00007487                 mov     edx, [ecx]
.text$mn:00007489                 cmp     edx, [ebp+var_8]
.text$mn:0000748C                 jz      short loc_749B
.text$mn:0000748E                 mov     eax, [ebp+var_4]
.text$mn:00007491                 mov     ecx, [eax]
.text$mn:00007493                 add     ecx, 4
.text$mn:00007496                 mov     [ebp+var_4], ecx
.text$mn:00007499                 jmp     short loc_747C
.text$mn:0000749B ; ---------------------------------------------------------------------------
.text$mn:0000749B
.text$mn:0000749B loc_749B:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:0000749B                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:0000749B                 mov     edx, [ebp+var_4]
.text$mn:0000749E                 cmp     dword ptr [edx], 0
.text$mn:000074A1                 jnz     short loc_74BA
.text$mn:000074A3                 push    0C9h ; '+'      ; unsigned int
.text$mn:000074A8                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000074AD                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:000074B2                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000074B7                 add     esp, 0Ch
.text$mn:000074BA
.text$mn:000074BA loc_74BA:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:000074BA                 mov     eax, [ebp+var_4]
.text$mn:000074BD                 mov     ecx, [ebp+var_8]
.text$mn:000074C0                 mov     edx, [ecx+4]
.text$mn:000074C3                 mov     [eax], edx
.text$mn:000074C5                 mov     eax, [ebp+var_8]
.text$mn:000074C8                 mov     dword ptr [eax], 0
.text$mn:000074CE
.text$mn:000074CE loc_74CE:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:000074CE                 mov     esp, ebp
.text$mn:000074D0                 pop     ebp
.text$mn:000074D1                 retn
.text$mn:000074D1 ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:000074D1
.text$mn:000074D1 ; ---------------------------------------------------------------------------
.text$mn:000074D2                 align 4
.text$mn:000074D2 _text$mn        ends
.text$mn:000074D2
.text$mn:000074D4 ; ===========================================================================
.text$mn:000074D4
.text$mn:000074D4 ; Segment type: Pure code
.text$mn:000074D4 ; Segment permissions: Read/Execute
.text$mn:000074D4 _text$mn        segment para public 'CODE' use32
.text$mn:000074D4                 assume cs:_text$mn
.text$mn:000074D4                 ;org 74D4h
.text$mn:000074D4 ; COMDAT (pick any)
.text$mn:000074D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000074D4
.text$mn:000074D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000074D4
.text$mn:000074D4 ; Attributes: bp-based frame
.text$mn:000074D4
.text$mn:000074D4 ; protected: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Orphan_range(unsigned char *, unsigned char *)const
.text$mn:000074D4                 public ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z
.text$mn:000074D4 ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z proc near
.text$mn:000074D4                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+67p
.text$mn:000074D4                                         ; std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+D3p
.text$mn:000074D4
.text$mn:000074D4 var_18          = byte ptr -18h
.text$mn:000074D4 var_14          = dword ptr -14h
.text$mn:000074D4 var_10          = dword ptr -10h
.text$mn:000074D4 var_C           = dword ptr -0Ch
.text$mn:000074D4 var_4           = dword ptr -4
.text$mn:000074D4 arg_0           = dword ptr  8
.text$mn:000074D4 arg_4           = dword ptr  0Ch
.text$mn:000074D4
.text$mn:000074D4                 push    ebp
.text$mn:000074D5                 mov     ebp, esp
.text$mn:000074D7                 push    0FFFFFFFFh
.text$mn:000074D9                 push    offset __ehhandler$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z
.text$mn:000074DE                 mov     eax, large fs:0
.text$mn:000074E4                 push    eax
.text$mn:000074E5                 sub     esp, 0Ch
.text$mn:000074E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000074ED                 xor     eax, ebp
.text$mn:000074EF                 push    eax
.text$mn:000074F0                 lea     eax, [ebp+var_C]
.text$mn:000074F3                 mov     large fs:0, eax
.text$mn:000074F9                 mov     [ebp+var_14], ecx
.text$mn:000074FC                 push    3               ; int
.text$mn:000074FE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007501                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00007506                 mov     [ebp+var_4], 0
.text$mn:0000750D                 mov     ecx, [ebp+var_14] ; this
.text$mn:00007510                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:00007515                 mov     [ebp+var_10], eax
.text$mn:00007518                 cmp     [ebp+var_10], 0
.text$mn:0000751C                 jz      short loc_756C
.text$mn:0000751E
.text$mn:0000751E loc_751E:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *):loc_756Aj
.text$mn:0000751E                 mov     eax, [ebp+var_10]
.text$mn:00007521                 cmp     dword ptr [eax], 0
.text$mn:00007524                 jz      short loc_756C
.text$mn:00007526                 mov     ecx, [ebp+var_10]
.text$mn:00007529                 mov     edx, [ecx]
.text$mn:0000752B                 mov     eax, [edx+8]
.text$mn:0000752E                 cmp     eax, [ebp+arg_0]
.text$mn:00007531                 jb      short loc_7540
.text$mn:00007533                 mov     ecx, [ebp+var_10]
.text$mn:00007536                 mov     edx, [ecx]
.text$mn:00007538                 mov     eax, [ebp+arg_4]
.text$mn:0000753B                 cmp     eax, [edx+8]
.text$mn:0000753E                 jnb     short loc_754F
.text$mn:00007540
.text$mn:00007540 loc_7540:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+5Dj
.text$mn:00007540                 mov     ecx, [ebp+var_10]
.text$mn:00007543                 mov     ecx, [ecx]      ; this
.text$mn:00007545                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000754A                 mov     [ebp+var_10], eax
.text$mn:0000754D                 jmp     short loc_756A
.text$mn:0000754F ; ---------------------------------------------------------------------------
.text$mn:0000754F
.text$mn:0000754F loc_754F:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+6Aj
.text$mn:0000754F                 mov     edx, [ebp+var_10]
.text$mn:00007552                 mov     ecx, [edx]      ; this
.text$mn:00007554                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00007559                 mov     eax, [ebp+var_10]
.text$mn:0000755C                 mov     ecx, [eax]      ; this
.text$mn:0000755E                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00007563                 mov     ecx, [ebp+var_10]
.text$mn:00007566                 mov     edx, [eax]
.text$mn:00007568                 mov     [ecx], edx
.text$mn:0000756A
.text$mn:0000756A loc_756A:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+79j
.text$mn:0000756A                 jmp     short loc_751E
.text$mn:0000756C ; ---------------------------------------------------------------------------
.text$mn:0000756C
.text$mn:0000756C loc_756C:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+48j
.text$mn:0000756C                                         ; std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+50j
.text$mn:0000756C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007573                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007576                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:0000757B                 mov     ecx, [ebp+var_C]
.text$mn:0000757E                 mov     large fs:0, ecx
.text$mn:00007585                 pop     ecx
.text$mn:00007586                 mov     esp, ebp
.text$mn:00007588                 pop     ebp
.text$mn:00007589                 retn    8
.text$mn:00007589 ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z endp
.text$mn:00007589
.text$mn:00007589 _text$mn        ends
.text$mn:00007589
.text$x:0000758C ; ===========================================================================
.text$x:0000758C
.text$x:0000758C ; Segment type: Pure code
.text$x:0000758C ; Segment permissions: Read/Execute
.text$x:0000758C _text$x         segment para public 'CODE' use32
.text$x:0000758C                 assume cs:_text$x
.text$x:0000758C                 ;org 758Ch
.text$x:0000758C ; COMDAT (pick associative to section at 74D4)
.text$x:0000758C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000758C
.text$x:0000758C ; =============== S U B R O U T I N E =======================================
.text$x:0000758C
.text$x:0000758C
.text$x:0000758C __unwindfunclet$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z$0 proc near
.text$x:0000758C                                         ; DATA XREF: .xdata$x:000099B4o
.text$x:0000758C                 lea     ecx, [ebp-18h]  ; this
.text$x:0000758F                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000758F __unwindfunclet$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z$0 endp
.text$x:0000758F
.text$x:00007594
.text$x:00007594 ; =============== S U B R O U T I N E =======================================
.text$x:00007594
.text$x:00007594
.text$x:00007594 __ehhandler$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z proc near
.text$x:00007594                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)+5o
.text$x:00007594
.text$x:00007594 arg_4           = dword ptr  8
.text$x:00007594
.text$x:00007594                 mov     edx, [esp+arg_4]
.text$x:00007598                 lea     eax, [edx+0Ch]
.text$x:0000759B                 mov     ecx, [edx-10h]
.text$x:0000759E                 xor     ecx, eax
.text$x:000075A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000075A5                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z
.text$x:000075AA                 jmp     ___CxxFrameHandler3
.text$x:000075AA __ehhandler$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z endp
.text$x:000075AA
.text$x:000075AA ; ---------------------------------------------------------------------------
.text$x:000075AF                 align 10h
.text$x:000075AF _text$x         ends
.text$x:000075AF
.text$mn:000075B0 ; ===========================================================================
.text$mn:000075B0
.text$mn:000075B0 ; Segment type: Pure code
.text$mn:000075B0 ; Segment permissions: Read/Execute
.text$mn:000075B0 _text$mn        segment para public 'CODE' use32
.text$mn:000075B0                 assume cs:_text$mn
.text$mn:000075B0                 ;org 75B0h
.text$mn:000075B0 ; COMDAT (pick any)
.text$mn:000075B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000075B0
.text$mn:000075B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000075B0
.text$mn:000075B0 ; Attributes: bp-based frame
.text$mn:000075B0
.text$mn:000075B0 ; protected: void __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Orphan_range(class std::vector<unsigned char, class std::allocator<unsigned char>> *, class std::vector<unsigned char, class std::allocator<unsigned char>> *)const
.text$mn:000075B0                 public ?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z
.text$mn:000075B0 ?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z proc near
.text$mn:000075B0                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+35Bp
.text$mn:000075B0                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+3DCp ...
.text$mn:000075B0
.text$mn:000075B0 var_18          = byte ptr -18h
.text$mn:000075B0 var_14          = dword ptr -14h
.text$mn:000075B0 var_10          = dword ptr -10h
.text$mn:000075B0 var_C           = dword ptr -0Ch
.text$mn:000075B0 var_4           = dword ptr -4
.text$mn:000075B0 arg_0           = dword ptr  8
.text$mn:000075B0 arg_4           = dword ptr  0Ch
.text$mn:000075B0
.text$mn:000075B0                 push    ebp
.text$mn:000075B1                 mov     ebp, esp
.text$mn:000075B3                 push    0FFFFFFFFh
.text$mn:000075B5                 push    offset __ehhandler$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z
.text$mn:000075BA                 mov     eax, large fs:0
.text$mn:000075C0                 push    eax
.text$mn:000075C1                 sub     esp, 0Ch
.text$mn:000075C4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000075C9                 xor     eax, ebp
.text$mn:000075CB                 push    eax
.text$mn:000075CC                 lea     eax, [ebp+var_C]
.text$mn:000075CF                 mov     large fs:0, eax
.text$mn:000075D5                 mov     [ebp+var_14], ecx
.text$mn:000075D8                 push    3               ; int
.text$mn:000075DA                 lea     ecx, [ebp+var_18] ; this
.text$mn:000075DD                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000075E2                 mov     [ebp+var_4], 0
.text$mn:000075E9                 mov     ecx, [ebp+var_14] ; this
.text$mn:000075EC                 call    ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst(void)
.text$mn:000075F1                 mov     [ebp+var_10], eax
.text$mn:000075F4                 cmp     [ebp+var_10], 0
.text$mn:000075F8                 jz      short loc_7648
.text$mn:000075FA
.text$mn:000075FA loc_75FA:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *):loc_7646j
.text$mn:000075FA                 mov     eax, [ebp+var_10]
.text$mn:000075FD                 cmp     dword ptr [eax], 0
.text$mn:00007600                 jz      short loc_7648
.text$mn:00007602                 mov     ecx, [ebp+var_10]
.text$mn:00007605                 mov     edx, [ecx]
.text$mn:00007607                 mov     eax, [edx+8]
.text$mn:0000760A                 cmp     eax, [ebp+arg_0]
.text$mn:0000760D                 jb      short loc_761C
.text$mn:0000760F                 mov     ecx, [ebp+var_10]
.text$mn:00007612                 mov     edx, [ecx]
.text$mn:00007614                 mov     eax, [ebp+arg_4]
.text$mn:00007617                 cmp     eax, [edx+8]
.text$mn:0000761A                 jnb     short loc_762B
.text$mn:0000761C
.text$mn:0000761C loc_761C:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+5Dj
.text$mn:0000761C                 mov     ecx, [ebp+var_10]
.text$mn:0000761F                 mov     ecx, [ecx]      ; this
.text$mn:00007621                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:00007626                 mov     [ebp+var_10], eax
.text$mn:00007629                 jmp     short loc_7646
.text$mn:0000762B ; ---------------------------------------------------------------------------
.text$mn:0000762B
.text$mn:0000762B loc_762B:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+6Aj
.text$mn:0000762B                 mov     edx, [ebp+var_10]
.text$mn:0000762E                 mov     ecx, [edx]      ; this
.text$mn:00007630                 call    ?_Clrcont@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Clrcont(void)
.text$mn:00007635                 mov     eax, [ebp+var_10]
.text$mn:00007638                 mov     ecx, [eax]      ; this
.text$mn:0000763A                 call    ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext(void)
.text$mn:0000763F                 mov     ecx, [ebp+var_10]
.text$mn:00007642                 mov     edx, [eax]
.text$mn:00007644                 mov     [ecx], edx
.text$mn:00007646
.text$mn:00007646 loc_7646:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+79j
.text$mn:00007646                 jmp     short loc_75FA
.text$mn:00007648 ; ---------------------------------------------------------------------------
.text$mn:00007648
.text$mn:00007648 loc_7648:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+48j
.text$mn:00007648                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+50j
.text$mn:00007648                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000764F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007652                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00007657                 mov     ecx, [ebp+var_C]
.text$mn:0000765A                 mov     large fs:0, ecx
.text$mn:00007661                 pop     ecx
.text$mn:00007662                 mov     esp, ebp
.text$mn:00007664                 pop     ebp
.text$mn:00007665                 retn    8
.text$mn:00007665 ?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z endp
.text$mn:00007665
.text$mn:00007665 _text$mn        ends
.text$mn:00007665
.text$x:00007668 ; ===========================================================================
.text$x:00007668
.text$x:00007668 ; Segment type: Pure code
.text$x:00007668 ; Segment permissions: Read/Execute
.text$x:00007668 _text$x         segment para public 'CODE' use32
.text$x:00007668                 assume cs:_text$x
.text$x:00007668                 ;org 7668h
.text$x:00007668 ; COMDAT (pick associative to section at 75B0)
.text$x:00007668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007668
.text$x:00007668 ; =============== S U B R O U T I N E =======================================
.text$x:00007668
.text$x:00007668
.text$x:00007668 __unwindfunclet$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z$0 proc near
.text$x:00007668                                         ; DATA XREF: .xdata$x:00009640o
.text$x:00007668                 lea     ecx, [ebp-18h]  ; this
.text$x:0000766B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000766B __unwindfunclet$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z$0 endp
.text$x:0000766B
.text$x:00007670
.text$x:00007670 ; =============== S U B R O U T I N E =======================================
.text$x:00007670
.text$x:00007670
.text$x:00007670 __ehhandler$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z proc near
.text$x:00007670                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)+5o
.text$x:00007670
.text$x:00007670 arg_4           = dword ptr  8
.text$x:00007670
.text$x:00007670                 mov     edx, [esp+arg_4]
.text$x:00007674                 lea     eax, [edx+0Ch]
.text$x:00007677                 mov     ecx, [edx-10h]
.text$x:0000767A                 xor     ecx, eax
.text$x:0000767C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007681                 mov     eax, offset __ehfuncinfo$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z
.text$x:00007686                 jmp     ___CxxFrameHandler3
.text$x:00007686 __ehhandler$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z endp
.text$x:00007686
.text$x:00007686 ; ---------------------------------------------------------------------------
.text$x:0000768B                 align 4
.text$x:0000768B _text$x         ends
.text$x:0000768B
.text$mn:0000768C ; ===========================================================================
.text$mn:0000768C
.text$mn:0000768C ; Segment type: Pure code
.text$mn:0000768C ; Segment permissions: Read/Execute
.text$mn:0000768C _text$mn        segment para public 'CODE' use32
.text$mn:0000768C                 assume cs:_text$mn
.text$mn:0000768C                 ;org 768Ch
.text$mn:0000768C ; COMDAT (pick any)
.text$mn:0000768C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000768C
.text$mn:0000768C ; =============== S U B R O U T I N E =======================================
.text$mn:0000768C
.text$mn:0000768C ; Attributes: bp-based frame
.text$mn:0000768C
.text$mn:0000768C ; protected: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Reallocate(unsigned int)
.text$mn:0000768C                 public ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$mn:0000768C ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z proc near
.text$mn:0000768C                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)+4Ep
.text$mn:0000768C
.text$mn:0000768C var_20          = dword ptr -20h
.text$mn:0000768C var_1C          = dword ptr -1Ch
.text$mn:0000768C var_18          = dword ptr -18h
.text$mn:0000768C var_13          = byte ptr -13h
.text$mn:0000768C var_11          = byte ptr -11h
.text$mn:0000768C var_10          = dword ptr -10h
.text$mn:0000768C var_C           = dword ptr -0Ch
.text$mn:0000768C var_4           = dword ptr -4
.text$mn:0000768C arg_0           = dword ptr  8
.text$mn:0000768C
.text$mn:0000768C ; FUNCTION CHUNK AT .text$mn:00007722 SIZE 00000009 BYTES
.text$mn:0000768C ; FUNCTION CHUNK AT .text$mn:00007732 SIZE 0000008E BYTES
.text$mn:0000768C
.text$mn:0000768C                 push    ebp
.text$mn:0000768D                 mov     ebp, esp
.text$mn:0000768F                 push    0FFFFFFFFh
.text$mn:00007691                 push    offset __ehhandler$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$mn:00007696                 mov     eax, large fs:0
.text$mn:0000769C                 push    eax
.text$mn:0000769D                 push    ecx
.text$mn:0000769E                 sub     esp, 10h
.text$mn:000076A1                 push    ebx
.text$mn:000076A2                 push    esi
.text$mn:000076A3                 push    edi
.text$mn:000076A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000076A9                 xor     eax, ebp
.text$mn:000076AB                 push    eax
.text$mn:000076AC                 lea     eax, [ebp+var_C]
.text$mn:000076AF                 mov     large fs:0, eax
.text$mn:000076B5                 mov     [ebp+var_10], esp
.text$mn:000076B8                 mov     [ebp+var_18], ecx
.text$mn:000076BB                 mov     eax, [ebp+arg_0]
.text$mn:000076BE                 push    eax
.text$mn:000076BF                 lea     ecx, [ebp+var_11]
.text$mn:000076C2                 push    ecx
.text$mn:000076C3                 mov     ecx, [ebp+var_18]
.text$mn:000076C6                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:000076CB                 mov     ecx, eax
.text$mn:000076CD                 call    ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z ; std::_Wrap_alloc<std::allocator<uchar>>::allocate(uint)
.text$mn:000076D2                 mov     [ebp+var_1C], eax
.text$mn:000076D5                 mov     [ebp+var_4], 0
.text$mn:000076DC                 mov     edx, [ebp+var_1C]
.text$mn:000076DF                 push    edx
.text$mn:000076E0                 mov     eax, [ebp+var_18]
.text$mn:000076E3                 mov     ecx, [eax+8]
.text$mn:000076E6                 push    ecx
.text$mn:000076E7                 mov     edx, [ebp+var_18]
.text$mn:000076EA                 mov     eax, [edx+4]
.text$mn:000076ED                 push    eax
.text$mn:000076EE                 mov     ecx, [ebp+var_18]
.text$mn:000076F1                 call    ??$_Umove@PAE@?$vector@EV?$allocator@E@std@@@std@@IAEPAEPAE00@Z ; std::vector<uchar,std::allocator<uchar>>::_Umove<uchar *>(uchar *,uchar *,uchar *)
.text$mn:000076F6                 jmp     short loc_7722
.text$mn:000076F6 ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z endp
.text$mn:000076F6
.text$mn:000076F8
.text$mn:000076F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000076F8
.text$mn:000076F8 ; Attributes: noreturn
.text$mn:000076F8
.text$mn:000076F8 __catch$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z$0 proc near
.text$mn:000076F8                                         ; DATA XREF: .xdata$x:00009964o
.text$mn:000076F8                 mov     ecx, [ebp+8]
.text$mn:000076FB                 push    ecx             ; int
.text$mn:000076FC                 mov     edx, [ebp-1Ch]
.text$mn:000076FF                 push    edx             ; void *
.text$mn:00007700                 lea     eax, [ebp-12h]
.text$mn:00007703                 push    eax
.text$mn:00007704                 mov     ecx, [ebp-18h]
.text$mn:00007707                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:0000770C                 mov     ecx, eax
.text$mn:0000770E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<std::allocator<uchar>>::deallocate(uchar *,uint)
.text$mn:00007713                 push    0
.text$mn:00007715                 push    0
.text$mn:00007717                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00007717 __catch$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z$0 endp
.text$mn:00007717
.text$mn:0000771C ; ---------------------------------------------------------------------------
.text$mn:0000771C                 mov     eax, offset $LN8_0
.text$mn:00007721                 retn
.text$mn:00007722 ; ---------------------------------------------------------------------------
.text$mn:00007722 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$mn:00007722
.text$mn:00007722 loc_7722:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reallocate(uint)+6Aj
.text$mn:00007722                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00007729                 jmp     short loc_7732
.text$mn:00007729 ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$mn:0000772B
.text$mn:0000772B ; =============== S U B R O U T I N E =======================================
.text$mn:0000772B
.text$mn:0000772B
.text$mn:0000772B $LN8_0          proc near               ; DATA XREF: .text$mn:0000771Co
.text$mn:0000772B                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000772B $LN8_0          endp ; sp-analysis failed
.text$mn:0000772B
.text$mn:00007732 ; START OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$mn:00007732
.text$mn:00007732 loc_7732:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reallocate(uint)+9Dj
.text$mn:00007732                 mov     ecx, [ebp+var_18]
.text$mn:00007735                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:0000773A                 mov     [ebp+var_20], eax
.text$mn:0000773D                 mov     ecx, [ebp+var_18]
.text$mn:00007740                 cmp     dword ptr [ecx+4], 0
.text$mn:00007744                 jz      short loc_7783
.text$mn:00007746                 mov     edx, [ebp+var_18]
.text$mn:00007749                 mov     eax, [edx+8]
.text$mn:0000774C                 push    eax
.text$mn:0000774D                 mov     ecx, [ebp+var_18]
.text$mn:00007750                 mov     edx, [ecx+4]
.text$mn:00007753                 push    edx
.text$mn:00007754                 mov     ecx, [ebp+var_18]
.text$mn:00007757                 call    ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<uchar,std::allocator<uchar>>::_Destroy(uchar *,uchar *)
.text$mn:0000775C                 mov     eax, [ebp+var_18]
.text$mn:0000775F                 mov     ecx, [ebp+var_18]
.text$mn:00007762                 mov     edx, [eax+0Ch]
.text$mn:00007765                 sub     edx, [ecx+4]
.text$mn:00007768                 push    edx             ; int
.text$mn:00007769                 mov     eax, [ebp+var_18]
.text$mn:0000776C                 mov     ecx, [eax+4]
.text$mn:0000776F                 push    ecx             ; void *
.text$mn:00007770                 lea     edx, [ebp+var_13]
.text$mn:00007773                 push    edx
.text$mn:00007774                 mov     ecx, [ebp+var_18]
.text$mn:00007777                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:0000777C                 mov     ecx, eax
.text$mn:0000777E                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<std::allocator<uchar>>::deallocate(uchar *,uint)
.text$mn:00007783
.text$mn:00007783 loc_7783:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reallocate(uint)+B8j
.text$mn:00007783                 mov     ecx, [ebp+var_18] ; this
.text$mn:00007786                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000778B                 mov     eax, [ebp+var_1C]
.text$mn:0000778E                 add     eax, [ebp+arg_0]
.text$mn:00007791                 mov     ecx, [ebp+var_18]
.text$mn:00007794                 mov     [ecx+0Ch], eax
.text$mn:00007797                 mov     edx, [ebp+var_1C]
.text$mn:0000779A                 add     edx, [ebp+var_20]
.text$mn:0000779D                 mov     eax, [ebp+var_18]
.text$mn:000077A0                 mov     [eax+8], edx
.text$mn:000077A3                 mov     ecx, [ebp+var_18]
.text$mn:000077A6                 mov     edx, [ebp+var_1C]
.text$mn:000077A9                 mov     [ecx+4], edx
.text$mn:000077AC                 mov     ecx, [ebp+var_C]
.text$mn:000077AF                 mov     large fs:0, ecx
.text$mn:000077B6                 pop     ecx
.text$mn:000077B7                 pop     edi
.text$mn:000077B8                 pop     esi
.text$mn:000077B9                 pop     ebx
.text$mn:000077BA                 mov     esp, ebp
.text$mn:000077BC                 pop     ebp
.text$mn:000077BD                 retn    4
.text$mn:000077BD ; END OF FUNCTION CHUNK FOR ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$mn:000077BD _text$mn        ends
.text$mn:000077BD
.text$x:000077C0 ; ===========================================================================
.text$x:000077C0
.text$x:000077C0 ; Segment type: Pure code
.text$x:000077C0 ; Segment permissions: Read/Execute
.text$x:000077C0 _text$x         segment para public 'CODE' use32
.text$x:000077C0                 assume cs:_text$x
.text$x:000077C0                 ;org 77C0h
.text$x:000077C0 ; COMDAT (pick associative to section at 768C)
.text$x:000077C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000077C0
.text$x:000077C0 ; =============== S U B R O U T I N E =======================================
.text$x:000077C0
.text$x:000077C0
.text$x:000077C0 __ehhandler$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z proc near
.text$x:000077C0                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Reallocate(uint)+5o
.text$x:000077C0
.text$x:000077C0 arg_4           = dword ptr  8
.text$x:000077C0
.text$x:000077C0                 mov     edx, [esp+arg_4]
.text$x:000077C4                 lea     eax, [edx+0Ch]
.text$x:000077C7                 mov     ecx, [edx-24h]
.text$x:000077CA                 xor     ecx, eax
.text$x:000077CC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000077D1                 mov     eax, offset __ehfuncinfo$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$x:000077D6                 jmp     ___CxxFrameHandler3
.text$x:000077D6 __ehhandler$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z endp
.text$x:000077D6
.text$x:000077D6 ; ---------------------------------------------------------------------------
.text$x:000077DB                 align 4
.text$x:000077DB _text$x         ends
.text$x:000077DB
.text$mn:000077DC ; ===========================================================================
.text$mn:000077DC
.text$mn:000077DC ; Segment type: Pure code
.text$mn:000077DC ; Segment permissions: Read/Execute
.text$mn:000077DC _text$mn        segment para public 'CODE' use32
.text$mn:000077DC                 assume cs:_text$mn
.text$mn:000077DC                 ;org 77DCh
.text$mn:000077DC ; COMDAT (pick any)
.text$mn:000077DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000077DC
.text$mn:000077DC ; =============== S U B R O U T I N E =======================================
.text$mn:000077DC
.text$mn:000077DC ; Attributes: bp-based frame
.text$mn:000077DC
.text$mn:000077DC ; protected: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Reserve(unsigned int)
.text$mn:000077DC                 public ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.text$mn:000077DC ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z proc near
.text$mn:000077DC                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+51p
.text$mn:000077DC                                         ; std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+BDp
.text$mn:000077DC
.text$mn:000077DC var_4           = dword ptr -4
.text$mn:000077DC arg_0           = dword ptr  8
.text$mn:000077DC
.text$mn:000077DC                 push    ebp
.text$mn:000077DD                 mov     ebp, esp
.text$mn:000077DF                 push    ecx
.text$mn:000077E0                 push    esi
.text$mn:000077E1                 mov     [ebp+var_4], ecx
.text$mn:000077E4                 mov     ecx, [ebp+var_4]
.text$mn:000077E7                 call    ?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::_Unused_capacity(void)
.text$mn:000077EC                 cmp     eax, [ebp+arg_0]
.text$mn:000077EF                 jnb     short loc_782F
.text$mn:000077F1                 mov     ecx, [ebp+var_4]
.text$mn:000077F4                 call    ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::max_size(void)
.text$mn:000077F9                 mov     esi, eax
.text$mn:000077FB                 mov     ecx, [ebp+var_4]
.text$mn:000077FE                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:00007803                 sub     esi, eax
.text$mn:00007805                 cmp     esi, [ebp+arg_0]
.text$mn:00007808                 jnb     short loc_7812
.text$mn:0000780A                 mov     ecx, [ebp+var_4]
.text$mn:0000780D                 call    ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ ; std::vector<uchar,std::allocator<uchar>>::_Xlen(void)
.text$mn:00007812
.text$mn:00007812 loc_7812:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)+2Cj
.text$mn:00007812                 mov     ecx, [ebp+var_4]
.text$mn:00007815                 call    ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ ; std::vector<uchar,std::allocator<uchar>>::size(void)
.text$mn:0000781A                 add     eax, [ebp+arg_0]
.text$mn:0000781D                 push    eax
.text$mn:0000781E                 mov     ecx, [ebp+var_4]
.text$mn:00007821                 call    ?_Grow_to@?$vector@EV?$allocator@E@std@@@std@@IBEII@Z ; std::vector<uchar,std::allocator<uchar>>::_Grow_to(uint)
.text$mn:00007826                 push    eax
.text$mn:00007827                 mov     ecx, [ebp+var_4]
.text$mn:0000782A                 call    ?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<uchar,std::allocator<uchar>>::_Reallocate(uint)
.text$mn:0000782F
.text$mn:0000782F loc_782F:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)+13j
.text$mn:0000782F                 pop     esi
.text$mn:00007830                 mov     esp, ebp
.text$mn:00007832                 pop     ebp
.text$mn:00007833                 retn    4
.text$mn:00007833 ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z endp
.text$mn:00007833
.text$mn:00007833 ; ---------------------------------------------------------------------------
.text$mn:00007836                 align 4
.text$mn:00007836 _text$mn        ends
.text$mn:00007836
.text$mn:00007838 ; ===========================================================================
.text$mn:00007838
.text$mn:00007838 ; Segment type: Pure code
.text$mn:00007838 ; Segment permissions: Read/Execute
.text$mn:00007838 _text$mn        segment para public 'CODE' use32
.text$mn:00007838                 assume cs:_text$mn
.text$mn:00007838                 ;org 7838h
.text$mn:00007838 ; COMDAT (pick any)
.text$mn:00007838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007838
.text$mn:00007838 ; =============== S U B R O U T I N E =======================================
.text$mn:00007838
.text$mn:00007838 ; Attributes: bp-based frame
.text$mn:00007838
.text$mn:00007838 ; void __thiscall std::_Container_base12::_Swap_all(std::_Container_base12 *this, struct std::_Container_base12 *)
.text$mn:00007838                 public ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:00007838 ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$mn:00007838                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,1>)+Ep
.text$mn:00007838
.text$mn:00007838 var_18          = byte ptr -18h
.text$mn:00007838 var_14          = dword ptr -14h
.text$mn:00007838 var_10          = dword ptr -10h
.text$mn:00007838 var_C           = dword ptr -0Ch
.text$mn:00007838 var_4           = dword ptr -4
.text$mn:00007838 arg_0           = dword ptr  8
.text$mn:00007838
.text$mn:00007838                 push    ebp
.text$mn:00007839                 mov     ebp, esp
.text$mn:0000783B                 push    0FFFFFFFFh
.text$mn:0000783D                 push    offset __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$mn:00007842                 mov     eax, large fs:0
.text$mn:00007848                 push    eax
.text$mn:00007849                 sub     esp, 0Ch
.text$mn:0000784C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007851                 xor     eax, ebp
.text$mn:00007853                 push    eax
.text$mn:00007854                 lea     eax, [ebp+var_C]
.text$mn:00007857                 mov     large fs:0, eax
.text$mn:0000785D                 mov     [ebp+var_10], ecx
.text$mn:00007860                 push    3               ; int
.text$mn:00007862                 lea     ecx, [ebp+var_18] ; this
.text$mn:00007865                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000786A                 mov     [ebp+var_4], 0
.text$mn:00007871                 mov     eax, [ebp+var_10]
.text$mn:00007874                 mov     ecx, [eax]
.text$mn:00007876                 mov     [ebp+var_14], ecx
.text$mn:00007879                 mov     edx, [ebp+var_10]
.text$mn:0000787C                 mov     eax, [ebp+arg_0]
.text$mn:0000787F                 mov     ecx, [eax]
.text$mn:00007881                 mov     [edx], ecx
.text$mn:00007883                 mov     edx, [ebp+arg_0]
.text$mn:00007886                 mov     eax, [ebp+var_14]
.text$mn:00007889                 mov     [edx], eax
.text$mn:0000788B                 mov     ecx, [ebp+var_10]
.text$mn:0000788E                 cmp     dword ptr [ecx], 0
.text$mn:00007891                 jz      short loc_789D
.text$mn:00007893                 mov     edx, [ebp+var_10]
.text$mn:00007896                 mov     eax, [edx]
.text$mn:00007898                 mov     ecx, [ebp+var_10]
.text$mn:0000789B                 mov     [eax], ecx
.text$mn:0000789D
.text$mn:0000789D loc_789D:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+59j
.text$mn:0000789D                 mov     edx, [ebp+arg_0]
.text$mn:000078A0                 cmp     dword ptr [edx], 0
.text$mn:000078A3                 jz      short loc_78AF
.text$mn:000078A5                 mov     eax, [ebp+arg_0]
.text$mn:000078A8                 mov     ecx, [eax]
.text$mn:000078AA                 mov     edx, [ebp+arg_0]
.text$mn:000078AD                 mov     [ecx], edx
.text$mn:000078AF
.text$mn:000078AF loc_78AF:                               ; CODE XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+6Bj
.text$mn:000078AF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000078B6                 lea     ecx, [ebp+var_18] ; this
.text$mn:000078B9                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000078BE                 mov     ecx, [ebp+var_C]
.text$mn:000078C1                 mov     large fs:0, ecx
.text$mn:000078C8                 pop     ecx
.text$mn:000078C9                 mov     esp, ebp
.text$mn:000078CB                 pop     ebp
.text$mn:000078CC                 retn    4
.text$mn:000078CC ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$mn:000078CC
.text$mn:000078CC ; ---------------------------------------------------------------------------
.text$mn:000078CF                 align 10h
.text$mn:000078CF _text$mn        ends
.text$mn:000078CF
.text$x:000078D0 ; ===========================================================================
.text$x:000078D0
.text$x:000078D0 ; Segment type: Pure code
.text$x:000078D0 ; Segment permissions: Read/Execute
.text$x:000078D0 _text$x         segment para public 'CODE' use32
.text$x:000078D0                 assume cs:_text$x
.text$x:000078D0                 ;org 78D0h
.text$x:000078D0 ; COMDAT (pick associative to section at 7838)
.text$x:000078D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000078D0
.text$x:000078D0 ; =============== S U B R O U T I N E =======================================
.text$x:000078D0
.text$x:000078D0
.text$x:000078D0 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 proc near
.text$x:000078D0                                         ; DATA XREF: .xdata$x:00008EE0o
.text$x:000078D0                 lea     ecx, [ebp-18h]  ; this
.text$x:000078D3                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000078D3 __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0 endp
.text$x:000078D3
.text$x:000078D8
.text$x:000078D8 ; =============== S U B R O U T I N E =======================================
.text$x:000078D8
.text$x:000078D8
.text$x:000078D8 __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z proc near
.text$x:000078D8                                         ; DATA XREF: std::_Container_base12::_Swap_all(std::_Container_base12 &)+5o
.text$x:000078D8
.text$x:000078D8 arg_4           = dword ptr  8
.text$x:000078D8
.text$x:000078D8                 mov     edx, [esp+arg_4]
.text$x:000078DC                 lea     eax, [edx+0Ch]
.text$x:000078DF                 mov     ecx, [edx-10h]
.text$x:000078E2                 xor     ecx, eax
.text$x:000078E4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000078E9                 mov     eax, offset __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.text$x:000078EE                 jmp     ___CxxFrameHandler3
.text$x:000078EE __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z endp
.text$x:000078EE
.text$x:000078EE ; ---------------------------------------------------------------------------
.text$x:000078F3                 align 4
.text$x:000078F3 _text$x         ends
.text$x:000078F3
.text$mn:000078F4 ; ===========================================================================
.text$mn:000078F4
.text$mn:000078F4 ; Segment type: Pure code
.text$mn:000078F4 ; Segment permissions: Read/Execute
.text$mn:000078F4 _text$mn        segment para public 'CODE' use32
.text$mn:000078F4                 assume cs:_text$mn
.text$mn:000078F4                 ;org 78F4h
.text$mn:000078F4 ; COMDAT (pick any)
.text$mn:000078F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000078F4
.text$mn:000078F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000078F4
.text$mn:000078F4 ; Attributes: bp-based frame
.text$mn:000078F4
.text$mn:000078F4 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000078F4                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000078F4 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000078F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000078F4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000078F4
.text$mn:000078F4 var_C           = dword ptr -0Ch
.text$mn:000078F4 var_8           = dword ptr -8
.text$mn:000078F4 var_2           = byte ptr -2
.text$mn:000078F4 var_1           = byte ptr -1
.text$mn:000078F4 arg_0           = byte ptr  8
.text$mn:000078F4 Size            = dword ptr  0Ch
.text$mn:000078F4
.text$mn:000078F4                 push    ebp
.text$mn:000078F5                 mov     ebp, esp
.text$mn:000078F7                 sub     esp, 0Ch
.text$mn:000078FA                 mov     [ebp+var_8], ecx
.text$mn:000078FD                 movzx   eax, [ebp+arg_0]
.text$mn:00007901                 test    eax, eax
.text$mn:00007903                 jnz     short loc_7907
.text$mn:00007905                 jmp     short loc_797A
.text$mn:00007907 ; ---------------------------------------------------------------------------
.text$mn:00007907
.text$mn:00007907 loc_7907:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00007907                 mov     ecx, [ebp+var_8]
.text$mn:0000790A                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000790E                 jb      short loc_797A
.text$mn:00007910                 mov     edx, [ebp+var_8]
.text$mn:00007913                 mov     eax, [edx+4]
.text$mn:00007916                 mov     [ebp+var_C], eax
.text$mn:00007919                 mov     ecx, [ebp+var_8]
.text$mn:0000791C                 add     ecx, 4
.text$mn:0000791F                 push    ecx
.text$mn:00007920                 lea     edx, [ebp+var_1]
.text$mn:00007923                 push    edx
.text$mn:00007924                 mov     ecx, [ebp+var_8]
.text$mn:00007927                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000792C                 mov     ecx, eax
.text$mn:0000792E                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00007933                 cmp     [ebp+Size], 0
.text$mn:00007937                 jbe     short loc_7959
.text$mn:00007939                 mov     eax, [ebp+Size]
.text$mn:0000793C                 push    eax             ; Size
.text$mn:0000793D                 mov     ecx, [ebp+var_C]
.text$mn:00007940                 push    ecx
.text$mn:00007941                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00007946                 add     esp, 4
.text$mn:00007949                 push    eax             ; Src
.text$mn:0000794A                 mov     edx, [ebp+var_8]
.text$mn:0000794D                 add     edx, 4
.text$mn:00007950                 push    edx             ; Dst
.text$mn:00007951                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007956                 add     esp, 0Ch
.text$mn:00007959
.text$mn:00007959 loc_7959:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00007959                 mov     eax, [ebp+var_8]
.text$mn:0000795C                 mov     ecx, [eax+18h]
.text$mn:0000795F                 add     ecx, 1
.text$mn:00007962                 push    ecx             ; int
.text$mn:00007963                 mov     edx, [ebp+var_C]
.text$mn:00007966                 push    edx             ; void *
.text$mn:00007967                 lea     eax, [ebp+var_2]
.text$mn:0000796A                 push    eax
.text$mn:0000796B                 mov     ecx, [ebp+var_8]
.text$mn:0000796E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00007973                 mov     ecx, eax
.text$mn:00007975                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000797A
.text$mn:0000797A loc_797A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000797A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000797A                 mov     ecx, [ebp+var_8]
.text$mn:0000797D                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00007984                 mov     edx, [ebp+Size]
.text$mn:00007987                 push    edx
.text$mn:00007988                 mov     ecx, [ebp+var_8]
.text$mn:0000798B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007990                 mov     esp, ebp
.text$mn:00007992                 pop     ebp
.text$mn:00007993                 retn    8
.text$mn:00007993 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00007993
.text$mn:00007993 ; ---------------------------------------------------------------------------
.text$mn:00007996                 align 4
.text$mn:00007996 _text$mn        ends
.text$mn:00007996
.text$mn:00007998 ; ===========================================================================
.text$mn:00007998
.text$mn:00007998 ; Segment type: Pure code
.text$mn:00007998 ; Segment permissions: Read/Execute
.text$mn:00007998 _text$mn        segment para public 'CODE' use32
.text$mn:00007998                 assume cs:_text$mn
.text$mn:00007998                 ;org 7998h
.text$mn:00007998 ; COMDAT (pick any)
.text$mn:00007998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007998
.text$mn:00007998 ; =============== S U B R O U T I N E =======================================
.text$mn:00007998
.text$mn:00007998 ; Attributes: bp-based frame
.text$mn:00007998
.text$mn:00007998 ; protected: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Tidy(void)
.text$mn:00007998                 public ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ
.text$mn:00007998 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ proc near
.text$mn:00007998                                         ; CODE XREF: __catch$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0+3p
.text$mn:00007998                                         ; __catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$0+3p ...
.text$mn:00007998
.text$mn:00007998 var_8           = dword ptr -8
.text$mn:00007998 var_1           = byte ptr -1
.text$mn:00007998
.text$mn:00007998                 push    ebp
.text$mn:00007999                 mov     ebp, esp
.text$mn:0000799B                 sub     esp, 8
.text$mn:0000799E                 mov     [ebp+var_8], ecx
.text$mn:000079A1                 mov     eax, [ebp+var_8]
.text$mn:000079A4                 cmp     dword ptr [eax+4], 0
.text$mn:000079A8                 jz      short loc_7A0D
.text$mn:000079AA                 mov     ecx, [ebp+var_8] ; this
.text$mn:000079AD                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000079B2                 mov     ecx, [ebp+var_8]
.text$mn:000079B5                 mov     edx, [ecx+8]
.text$mn:000079B8                 push    edx
.text$mn:000079B9                 mov     eax, [ebp+var_8]
.text$mn:000079BC                 mov     ecx, [eax+4]
.text$mn:000079BF                 push    ecx
.text$mn:000079C0                 mov     ecx, [ebp+var_8]
.text$mn:000079C3                 call    ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<uchar,std::allocator<uchar>>::_Destroy(uchar *,uchar *)
.text$mn:000079C8                 mov     edx, [ebp+var_8]
.text$mn:000079CB                 mov     eax, [ebp+var_8]
.text$mn:000079CE                 mov     ecx, [edx+0Ch]
.text$mn:000079D1                 sub     ecx, [eax+4]
.text$mn:000079D4                 push    ecx             ; int
.text$mn:000079D5                 mov     edx, [ebp+var_8]
.text$mn:000079D8                 mov     eax, [edx+4]
.text$mn:000079DB                 push    eax             ; void *
.text$mn:000079DC                 lea     ecx, [ebp+var_1]
.text$mn:000079DF                 push    ecx
.text$mn:000079E0                 mov     ecx, [ebp+var_8]
.text$mn:000079E3                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:000079E8                 mov     ecx, eax
.text$mn:000079EA                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z ; std::_Wrap_alloc<std::allocator<uchar>>::deallocate(uchar *,uint)
.text$mn:000079EF                 mov     edx, [ebp+var_8]
.text$mn:000079F2                 mov     dword ptr [edx+4], 0
.text$mn:000079F9                 mov     eax, [ebp+var_8]
.text$mn:000079FC                 mov     dword ptr [eax+8], 0
.text$mn:00007A03                 mov     ecx, [ebp+var_8]
.text$mn:00007A06                 mov     dword ptr [ecx+0Ch], 0
.text$mn:00007A0D
.text$mn:00007A0D loc_7A0D:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Tidy(void)+10j
.text$mn:00007A0D                 mov     esp, ebp
.text$mn:00007A0F                 pop     ebp
.text$mn:00007A10                 retn
.text$mn:00007A10 ?_Tidy@?$vector@EV?$allocator@E@std@@@std@@IAEXXZ endp
.text$mn:00007A10
.text$mn:00007A10 ; ---------------------------------------------------------------------------
.text$mn:00007A11                 align 4
.text$mn:00007A11 _text$mn        ends
.text$mn:00007A11
.text$mn:00007A14 ; ===========================================================================
.text$mn:00007A14
.text$mn:00007A14 ; Segment type: Pure code
.text$mn:00007A14 ; Segment permissions: Read/Execute
.text$mn:00007A14 _text$mn        segment para public 'CODE' use32
.text$mn:00007A14                 assume cs:_text$mn
.text$mn:00007A14                 ;org 7A14h
.text$mn:00007A14 ; COMDAT (pick any)
.text$mn:00007A14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A14
.text$mn:00007A14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A14
.text$mn:00007A14 ; Attributes: bp-based frame
.text$mn:00007A14
.text$mn:00007A14 ; int __stdcall std::vector<std::vector<unsigned char,std::allocator<unsigned char>>,std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>::_Ufill(void *, int, int)
.text$mn:00007A14                 public ?_Ufill@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@2@PAV32@IPBV32@@Z
.text$mn:00007A14 ?_Ufill@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@2@PAV32@IPBV32@@Z proc near
.text$mn:00007A14                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+12Cp
.text$mn:00007A14                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+2F6p
.text$mn:00007A14
.text$mn:00007A14 var_8           = dword ptr -8
.text$mn:00007A14 var_1           = dword ptr -1
.text$mn:00007A14 arg_0           = dword ptr  8
.text$mn:00007A14 arg_4           = dword ptr  0Ch
.text$mn:00007A14 arg_8           = dword ptr  10h
.text$mn:00007A14
.text$mn:00007A14                 push    ebp
.text$mn:00007A15                 mov     ebp, esp
.text$mn:00007A17                 sub     esp, 8
.text$mn:00007A1A                 mov     [ebp+var_8], ecx
.text$mn:00007A1D                 lea     eax, [ebp+var_1]
.text$mn:00007A20                 push    eax
.text$mn:00007A21                 mov     ecx, [ebp+var_8]
.text$mn:00007A24                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)
.text$mn:00007A29                 lea     ecx, [ebp+var_1]
.text$mn:00007A2C                 push    ecx             ; int
.text$mn:00007A2D                 mov     edx, [ebp+arg_8]
.text$mn:00007A30                 push    edx             ; int
.text$mn:00007A31                 mov     eax, [ebp+arg_4]
.text$mn:00007A34                 push    eax             ; int
.text$mn:00007A35                 mov     ecx, [ebp+arg_0]
.text$mn:00007A38                 push    ecx             ; void *
.text$mn:00007A39                 call    ??$_Uninitialized_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@U?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@@Z ; std::_Uninitialized_fill_n<std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>>,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,uint,std::vector<uchar,std::allocator<uchar>> const *,std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>> &)
.text$mn:00007A3E                 add     esp, 10h
.text$mn:00007A41                 mov     eax, [ebp+arg_4]
.text$mn:00007A44                 shl     eax, 4
.text$mn:00007A47                 add     eax, [ebp+arg_0]
.text$mn:00007A4A                 mov     esp, ebp
.text$mn:00007A4C                 pop     ebp
.text$mn:00007A4D                 retn    0Ch
.text$mn:00007A4D ?_Ufill@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEPAV?$vector@EV?$allocator@E@std@@@2@PAV32@IPBV32@@Z endp
.text$mn:00007A4D
.text$mn:00007A4D _text$mn        ends
.text$mn:00007A4D
.text$mn:00007A50 ; ===========================================================================
.text$mn:00007A50
.text$mn:00007A50 ; Segment type: Pure code
.text$mn:00007A50 ; Segment permissions: Read/Execute
.text$mn:00007A50 _text$mn        segment para public 'CODE' use32
.text$mn:00007A50                 assume cs:_text$mn
.text$mn:00007A50                 ;org 7A50h
.text$mn:00007A50 ; COMDAT (pick any)
.text$mn:00007A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A50
.text$mn:00007A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A50
.text$mn:00007A50 ; Attributes: bp-based frame
.text$mn:00007A50
.text$mn:00007A50 ; public: unsigned char const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>::_Unchecked(void)const
.text$mn:00007A50                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPBEXZ
.text$mn:00007A50 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPBEXZ proc near
.text$mn:00007A50                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>)+2Dp
.text$mn:00007A50
.text$mn:00007A50 var_4           = dword ptr -4
.text$mn:00007A50
.text$mn:00007A50                 push    ebp
.text$mn:00007A51                 mov     ebp, esp
.text$mn:00007A53                 push    ecx
.text$mn:00007A54                 mov     [ebp+var_4], ecx
.text$mn:00007A57                 mov     eax, [ebp+var_4]
.text$mn:00007A5A                 mov     eax, [eax+8]
.text$mn:00007A5D                 mov     esp, ebp
.text$mn:00007A5F                 pop     ebp
.text$mn:00007A60                 retn
.text$mn:00007A60 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QBEPBEXZ endp
.text$mn:00007A60
.text$mn:00007A60 ; ---------------------------------------------------------------------------
.text$mn:00007A61                 align 4
.text$mn:00007A61 _text$mn        ends
.text$mn:00007A61
.text$mn:00007A64 ; ===========================================================================
.text$mn:00007A64
.text$mn:00007A64 ; Segment type: Pure code
.text$mn:00007A64 ; Segment permissions: Read/Execute
.text$mn:00007A64 _text$mn        segment para public 'CODE' use32
.text$mn:00007A64                 assume cs:_text$mn
.text$mn:00007A64                 ;org 7A64h
.text$mn:00007A64 ; COMDAT (pick any)
.text$mn:00007A64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A64
.text$mn:00007A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A64
.text$mn:00007A64 ; Attributes: bp-based frame
.text$mn:00007A64
.text$mn:00007A64 ; public: unsigned int __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Unused_capacity(void)const
.text$mn:00007A64                 public ?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
.text$mn:00007A64 ?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ proc near
.text$mn:00007A64                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)+Bp
.text$mn:00007A64
.text$mn:00007A64 var_4           = dword ptr -4
.text$mn:00007A64
.text$mn:00007A64                 push    ebp
.text$mn:00007A65                 mov     ebp, esp
.text$mn:00007A67                 push    ecx
.text$mn:00007A68                 mov     [ebp+var_4], ecx
.text$mn:00007A6B                 mov     eax, [ebp+var_4]
.text$mn:00007A6E                 mov     ecx, [ebp+var_4]
.text$mn:00007A71                 mov     eax, [eax+0Ch]
.text$mn:00007A74                 sub     eax, [ecx+8]
.text$mn:00007A77                 mov     esp, ebp
.text$mn:00007A79                 pop     ebp
.text$mn:00007A7A                 retn
.text$mn:00007A7A ?_Unused_capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ endp
.text$mn:00007A7A
.text$mn:00007A7A ; ---------------------------------------------------------------------------
.text$mn:00007A7B                 align 4
.text$mn:00007A7B _text$mn        ends
.text$mn:00007A7B
.text$mn:00007A7C ; ===========================================================================
.text$mn:00007A7C
.text$mn:00007A7C ; Segment type: Pure code
.text$mn:00007A7C ; Segment permissions: Read/Execute
.text$mn:00007A7C _text$mn        segment para public 'CODE' use32
.text$mn:00007A7C                 assume cs:_text$mn
.text$mn:00007A7C                 ;org 7A7Ch
.text$mn:00007A7C ; COMDAT (pick any)
.text$mn:00007A7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A7C
.text$mn:00007A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00007A7C
.text$mn:00007A7C ; Attributes: bp-based frame
.text$mn:00007A7C
.text$mn:00007A7C ; public: unsigned int __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Unused_capacity(void)const
.text$mn:00007A7C                 public ?_Unused_capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00007A7C ?_Unused_capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00007A7C                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+94p
.text$mn:00007A7C
.text$mn:00007A7C var_4           = dword ptr -4
.text$mn:00007A7C
.text$mn:00007A7C                 push    ebp
.text$mn:00007A7D                 mov     ebp, esp
.text$mn:00007A7F                 push    ecx
.text$mn:00007A80                 mov     [ebp+var_4], ecx
.text$mn:00007A83                 mov     eax, [ebp+var_4]
.text$mn:00007A86                 mov     ecx, [ebp+var_4]
.text$mn:00007A89                 mov     eax, [eax+0Ch]
.text$mn:00007A8C                 sub     eax, [ecx+8]
.text$mn:00007A8F                 sar     eax, 4
.text$mn:00007A92                 mov     esp, ebp
.text$mn:00007A94                 pop     ebp
.text$mn:00007A95                 retn
.text$mn:00007A95 ?_Unused_capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:00007A95
.text$mn:00007A95 ; ---------------------------------------------------------------------------
.text$mn:00007A96                 align 4
.text$mn:00007A96 _text$mn        ends
.text$mn:00007A96
.text$mn:00007A98 ; ===========================================================================
.text$mn:00007A98
.text$mn:00007A98 ; Segment type: Pure code
.text$mn:00007A98 ; Segment permissions: Read/Execute
.text$mn:00007A98 _text$mn        segment para public 'CODE' use32
.text$mn:00007A98                 assume cs:_text$mn
.text$mn:00007A98                 ;org 7A98h
.text$mn:00007A98 ; COMDAT (pick any)
.text$mn:00007A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007A98
.text$mn:00007A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00007A98
.text$mn:00007A98 ; Attributes: bp-based frame
.text$mn:00007A98
.text$mn:00007A98 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00007A98                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00007A98 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00007A98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00007A98
.text$mn:00007A98 var_4           = dword ptr -4
.text$mn:00007A98
.text$mn:00007A98                 push    ebp
.text$mn:00007A99                 mov     ebp, esp
.text$mn:00007A9B                 push    ecx
.text$mn:00007A9C                 mov     [ebp+var_4], ecx
.text$mn:00007A9F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00007AA4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007AA9                 mov     esp, ebp
.text$mn:00007AAB                 pop     ebp
.text$mn:00007AAC                 retn
.text$mn:00007AAC ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00007AAC
.text$mn:00007AAC ; ---------------------------------------------------------------------------
.text$mn:00007AAD                 align 10h
.text$mn:00007AAD _text$mn        ends
.text$mn:00007AAD
.text$mn:00007AB0 ; ===========================================================================
.text$mn:00007AB0
.text$mn:00007AB0 ; Segment type: Pure code
.text$mn:00007AB0 ; Segment permissions: Read/Execute
.text$mn:00007AB0 _text$mn        segment para public 'CODE' use32
.text$mn:00007AB0                 assume cs:_text$mn
.text$mn:00007AB0                 ;org 7AB0h
.text$mn:00007AB0 ; COMDAT (pick any)
.text$mn:00007AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AB0
.text$mn:00007AB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AB0
.text$mn:00007AB0 ; Attributes: bp-based frame
.text$mn:00007AB0
.text$mn:00007AB0 ; protected: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::_Xlen(void)const
.text$mn:00007AB0                 public ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ
.text$mn:00007AB0 ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ proc near
.text$mn:00007AB0                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+43p
.text$mn:00007AB0                                         ; std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)+31p
.text$mn:00007AB0
.text$mn:00007AB0 var_4           = dword ptr -4
.text$mn:00007AB0
.text$mn:00007AB0                 push    ebp
.text$mn:00007AB1                 mov     ebp, esp
.text$mn:00007AB3                 push    ecx
.text$mn:00007AB4                 mov     [ebp+var_4], ecx
.text$mn:00007AB7                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00007ABC                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007AC1                 mov     esp, ebp
.text$mn:00007AC3                 pop     ebp
.text$mn:00007AC4                 retn
.text$mn:00007AC4 ?_Xlen@?$vector@EV?$allocator@E@std@@@std@@IBEXXZ endp
.text$mn:00007AC4
.text$mn:00007AC4 ; ---------------------------------------------------------------------------
.text$mn:00007AC5                 align 4
.text$mn:00007AC5 _text$mn        ends
.text$mn:00007AC5
.text$mn:00007AC8 ; ===========================================================================
.text$mn:00007AC8
.text$mn:00007AC8 ; Segment type: Pure code
.text$mn:00007AC8 ; Segment permissions: Read/Execute
.text$mn:00007AC8 _text$mn        segment para public 'CODE' use32
.text$mn:00007AC8                 assume cs:_text$mn
.text$mn:00007AC8                 ;org 7AC8h
.text$mn:00007AC8 ; COMDAT (pick any)
.text$mn:00007AC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AC8
.text$mn:00007AC8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AC8
.text$mn:00007AC8 ; Attributes: bp-based frame
.text$mn:00007AC8
.text$mn:00007AC8 ; protected: void __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::_Xlen(void)const
.text$mn:00007AC8                 public ?_Xlen@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXXZ
.text$mn:00007AC8 ?_Xlen@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXXZ proc near
.text$mn:00007AC8                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+BEp
.text$mn:00007AC8
.text$mn:00007AC8 var_4           = dword ptr -4
.text$mn:00007AC8
.text$mn:00007AC8                 push    ebp
.text$mn:00007AC9                 mov     ebp, esp
.text$mn:00007ACB                 push    ecx
.text$mn:00007ACC                 mov     [ebp+var_4], ecx
.text$mn:00007ACF                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00007AD4                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00007AD9                 mov     esp, ebp
.text$mn:00007ADB                 pop     ebp
.text$mn:00007ADC                 retn
.text$mn:00007ADC ?_Xlen@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXXZ endp
.text$mn:00007ADC
.text$mn:00007ADC ; ---------------------------------------------------------------------------
.text$mn:00007ADD                 align 10h
.text$mn:00007ADD _text$mn        ends
.text$mn:00007ADD
.text$mn:00007AE0 ; ===========================================================================
.text$mn:00007AE0
.text$mn:00007AE0 ; Segment type: Pure code
.text$mn:00007AE0 ; Segment permissions: Read/Execute
.text$mn:00007AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00007AE0                 assume cs:_text$mn
.text$mn:00007AE0                 ;org 7AE0h
.text$mn:00007AE0 ; COMDAT (pick any)
.text$mn:00007AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AE0
.text$mn:00007AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AE0
.text$mn:00007AE0 ; Attributes: bp-based frame
.text$mn:00007AE0
.text$mn:00007AE0 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00007AE0                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00007AE0 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00007AE0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00007AE0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00007AE0
.text$mn:00007AE0 var_4           = dword ptr -4
.text$mn:00007AE0
.text$mn:00007AE0                 push    ebp
.text$mn:00007AE1                 mov     ebp, esp
.text$mn:00007AE3                 push    ecx
.text$mn:00007AE4                 mov     [ebp+var_4], ecx
.text$mn:00007AE7                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00007AEC                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00007AF1                 mov     esp, ebp
.text$mn:00007AF3                 pop     ebp
.text$mn:00007AF4                 retn
.text$mn:00007AF4 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00007AF4
.text$mn:00007AF4 ; ---------------------------------------------------------------------------
.text$mn:00007AF5                 align 4
.text$mn:00007AF5 _text$mn        ends
.text$mn:00007AF5
.text$mn:00007AF8 ; ===========================================================================
.text$mn:00007AF8
.text$mn:00007AF8 ; Segment type: Pure code
.text$mn:00007AF8 ; Segment permissions: Read/Execute
.text$mn:00007AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00007AF8                 assume cs:_text$mn
.text$mn:00007AF8                 ;org 7AF8h
.text$mn:00007AF8 ; COMDAT (pick any)
.text$mn:00007AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007AF8
.text$mn:00007AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007AF8
.text$mn:00007AF8 ; Attributes: bp-based frame
.text$mn:00007AF8
.text$mn:00007AF8 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00007AF8                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00007AF8 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00007AF8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00007AF8                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00007AF8
.text$mn:00007AF8 var_4           = dword ptr -4
.text$mn:00007AF8 arg_0           = dword ptr  8
.text$mn:00007AF8
.text$mn:00007AF8                 push    ebp
.text$mn:00007AF9                 mov     ebp, esp
.text$mn:00007AFB                 push    ecx
.text$mn:00007AFC                 mov     [ebp+var_4], ecx
.text$mn:00007AFF                 mov     eax, [ebp+arg_0]
.text$mn:00007B02                 push    eax
.text$mn:00007B03                 mov     ecx, [ebp+var_4]
.text$mn:00007B06                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00007B0B                 mov     esp, ebp
.text$mn:00007B0D                 pop     ebp
.text$mn:00007B0E                 retn    4
.text$mn:00007B0E ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00007B0E
.text$mn:00007B0E ; ---------------------------------------------------------------------------
.text$mn:00007B11                 align 4
.text$mn:00007B11 _text$mn        ends
.text$mn:00007B11
.text$mn:00007B14 ; ===========================================================================
.text$mn:00007B14
.text$mn:00007B14 ; Segment type: Pure code
.text$mn:00007B14 ; Segment permissions: Read/Execute
.text$mn:00007B14 _text$mn        segment para public 'CODE' use32
.text$mn:00007B14                 assume cs:_text$mn
.text$mn:00007B14                 ;org 7B14h
.text$mn:00007B14 ; COMDAT (pick any)
.text$mn:00007B14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B14
.text$mn:00007B14 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B14
.text$mn:00007B14 ; Attributes: bp-based frame
.text$mn:00007B14
.text$mn:00007B14 ; public: unsigned char * __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>>::allocate(unsigned int)
.text$mn:00007B14                 public ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z
.text$mn:00007B14 ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z proc near
.text$mn:00007B14                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+5Cp
.text$mn:00007B14                                         ; std::vector<uchar,std::allocator<uchar>>::_Reallocate(uint)+41p
.text$mn:00007B14
.text$mn:00007B14 var_4           = dword ptr -4
.text$mn:00007B14 arg_0           = dword ptr  8
.text$mn:00007B14
.text$mn:00007B14                 push    ebp
.text$mn:00007B15                 mov     ebp, esp
.text$mn:00007B17                 push    ecx
.text$mn:00007B18                 mov     [ebp+var_4], ecx
.text$mn:00007B1B                 mov     eax, [ebp+arg_0]
.text$mn:00007B1E                 push    eax
.text$mn:00007B1F                 mov     ecx, [ebp+var_4]
.text$mn:00007B22                 call    ?allocate@?$allocator@E@std@@QAEPAEI@Z ; std::allocator<uchar>::allocate(uint)
.text$mn:00007B27                 mov     esp, ebp
.text$mn:00007B29                 pop     ebp
.text$mn:00007B2A                 retn    4
.text$mn:00007B2A ?allocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEPAEI@Z endp
.text$mn:00007B2A
.text$mn:00007B2A ; ---------------------------------------------------------------------------
.text$mn:00007B2D                 align 10h
.text$mn:00007B2D _text$mn        ends
.text$mn:00007B2D
.text$mn:00007B30 ; ===========================================================================
.text$mn:00007B30
.text$mn:00007B30 ; Segment type: Pure code
.text$mn:00007B30 ; Segment permissions: Read/Execute
.text$mn:00007B30 _text$mn        segment para public 'CODE' use32
.text$mn:00007B30                 assume cs:_text$mn
.text$mn:00007B30                 ;org 7B30h
.text$mn:00007B30 ; COMDAT (pick any)
.text$mn:00007B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B30
.text$mn:00007B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B30
.text$mn:00007B30 ; Attributes: bp-based frame
.text$mn:00007B30
.text$mn:00007B30 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:00007B30                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00007B30 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00007B30                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Alloc_proxy(void)+16p
.text$mn:00007B30
.text$mn:00007B30 var_4           = dword ptr -4
.text$mn:00007B30 arg_0           = dword ptr  8
.text$mn:00007B30
.text$mn:00007B30                 push    ebp
.text$mn:00007B31                 mov     ebp, esp
.text$mn:00007B33                 push    ecx
.text$mn:00007B34                 mov     [ebp+var_4], ecx
.text$mn:00007B37                 mov     eax, [ebp+arg_0]
.text$mn:00007B3A                 push    eax
.text$mn:00007B3B                 mov     ecx, [ebp+var_4]
.text$mn:00007B3E                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00007B43                 mov     esp, ebp
.text$mn:00007B45                 pop     ebp
.text$mn:00007B46                 retn    4
.text$mn:00007B46 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007B46
.text$mn:00007B46 ; ---------------------------------------------------------------------------
.text$mn:00007B49                 align 4
.text$mn:00007B49 _text$mn        ends
.text$mn:00007B49
.text$mn:00007B4C ; ===========================================================================
.text$mn:00007B4C
.text$mn:00007B4C ; Segment type: Pure code
.text$mn:00007B4C ; Segment permissions: Read/Execute
.text$mn:00007B4C _text$mn        segment para public 'CODE' use32
.text$mn:00007B4C                 assume cs:_text$mn
.text$mn:00007B4C                 ;org 7B4Ch
.text$mn:00007B4C ; COMDAT (pick any)
.text$mn:00007B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B4C
.text$mn:00007B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00007B4C
.text$mn:00007B4C ; Attributes: bp-based frame
.text$mn:00007B4C
.text$mn:00007B4C ; public: class std::vector<unsigned char, class std::allocator<unsigned char>> * __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::allocate(unsigned int)
.text$mn:00007B4C                 public ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z
.text$mn:00007B4C ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z proc near
.text$mn:00007B4C                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+ECp
.text$mn:00007B4C
.text$mn:00007B4C var_4           = dword ptr -4
.text$mn:00007B4C arg_0           = dword ptr  8
.text$mn:00007B4C
.text$mn:00007B4C                 push    ebp
.text$mn:00007B4D                 mov     ebp, esp
.text$mn:00007B4F                 push    ecx
.text$mn:00007B50                 mov     [ebp+var_4], ecx
.text$mn:00007B53                 mov     eax, [ebp+arg_0]
.text$mn:00007B56                 push    eax
.text$mn:00007B57                 mov     ecx, [ebp+var_4]
.text$mn:00007B5A                 call    ?allocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::allocate(uint)
.text$mn:00007B5F                 mov     esp, ebp
.text$mn:00007B61                 pop     ebp
.text$mn:00007B62                 retn    4
.text$mn:00007B62 ?allocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z endp
.text$mn:00007B62
.text$mn:00007B62 ; ---------------------------------------------------------------------------
.text$mn:00007B65                 align 4
.text$mn:00007B65 _text$mn        ends
.text$mn:00007B65
.text$mn:00007B68 ; ===========================================================================
.text$mn:00007B68
.text$mn:00007B68 ; Segment type: Pure code
.text$mn:00007B68 ; Segment permissions: Read/Execute
.text$mn:00007B68 _text$mn        segment para public 'CODE' use32
.text$mn:00007B68                 assume cs:_text$mn
.text$mn:00007B68                 ;org 7B68h
.text$mn:00007B68 ; COMDAT (pick any)
.text$mn:00007B68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B68
.text$mn:00007B68 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B68
.text$mn:00007B68 ; Attributes: bp-based frame
.text$mn:00007B68
.text$mn:00007B68 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00007B68                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00007B68 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00007B68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00007B68
.text$mn:00007B68 var_4           = dword ptr -4
.text$mn:00007B68 arg_0           = dword ptr  8
.text$mn:00007B68
.text$mn:00007B68                 push    ebp
.text$mn:00007B69                 mov     ebp, esp
.text$mn:00007B6B                 push    ecx
.text$mn:00007B6C                 mov     [ebp+var_4], ecx
.text$mn:00007B6F                 push    0
.text$mn:00007B71                 mov     eax, [ebp+arg_0]
.text$mn:00007B74                 push    eax
.text$mn:00007B75                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00007B7A                 add     esp, 8
.text$mn:00007B7D                 mov     esp, ebp
.text$mn:00007B7F                 pop     ebp
.text$mn:00007B80                 retn    4
.text$mn:00007B80 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00007B80
.text$mn:00007B80 ; ---------------------------------------------------------------------------
.text$mn:00007B83                 align 4
.text$mn:00007B83 _text$mn        ends
.text$mn:00007B83
.text$mn:00007B84 ; ===========================================================================
.text$mn:00007B84
.text$mn:00007B84 ; Segment type: Pure code
.text$mn:00007B84 ; Segment permissions: Read/Execute
.text$mn:00007B84 _text$mn        segment para public 'CODE' use32
.text$mn:00007B84                 assume cs:_text$mn
.text$mn:00007B84                 ;org 7B84h
.text$mn:00007B84 ; COMDAT (pick any)
.text$mn:00007B84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007B84
.text$mn:00007B84 ; =============== S U B R O U T I N E =======================================
.text$mn:00007B84
.text$mn:00007B84 ; Attributes: bp-based frame
.text$mn:00007B84
.text$mn:00007B84 ; public: unsigned char * __thiscall std::allocator<unsigned char>::allocate(unsigned int)
.text$mn:00007B84                 public ?allocate@?$allocator@E@std@@QAEPAEI@Z
.text$mn:00007B84 ?allocate@?$allocator@E@std@@QAEPAEI@Z proc near
.text$mn:00007B84                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::allocate(uint)+Ep
.text$mn:00007B84
.text$mn:00007B84 var_4           = dword ptr -4
.text$mn:00007B84 arg_0           = dword ptr  8
.text$mn:00007B84
.text$mn:00007B84                 push    ebp
.text$mn:00007B85                 mov     ebp, esp
.text$mn:00007B87                 push    ecx
.text$mn:00007B88                 mov     [ebp+var_4], ecx
.text$mn:00007B8B                 push    0
.text$mn:00007B8D                 mov     eax, [ebp+arg_0]
.text$mn:00007B90                 push    eax
.text$mn:00007B91                 call    ??$_Allocate@E@std@@YAPAEIPAE@Z ; std::_Allocate<uchar>(uint,uchar *)
.text$mn:00007B96                 add     esp, 8
.text$mn:00007B99                 mov     esp, ebp
.text$mn:00007B9B                 pop     ebp
.text$mn:00007B9C                 retn    4
.text$mn:00007B9C ?allocate@?$allocator@E@std@@QAEPAEI@Z endp
.text$mn:00007B9C
.text$mn:00007B9C ; ---------------------------------------------------------------------------
.text$mn:00007B9F                 align 10h
.text$mn:00007B9F _text$mn        ends
.text$mn:00007B9F
.text$mn:00007BA0 ; ===========================================================================
.text$mn:00007BA0
.text$mn:00007BA0 ; Segment type: Pure code
.text$mn:00007BA0 ; Segment permissions: Read/Execute
.text$mn:00007BA0 _text$mn        segment para public 'CODE' use32
.text$mn:00007BA0                 assume cs:_text$mn
.text$mn:00007BA0                 ;org 7BA0h
.text$mn:00007BA0 ; COMDAT (pick any)
.text$mn:00007BA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BA0
.text$mn:00007BA0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BA0
.text$mn:00007BA0 ; Attributes: bp-based frame
.text$mn:00007BA0
.text$mn:00007BA0 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00007BA0                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00007BA0 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00007BA0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00007BA0                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+Ep
.text$mn:00007BA0
.text$mn:00007BA0 var_4           = dword ptr -4
.text$mn:00007BA0 arg_0           = dword ptr  8
.text$mn:00007BA0
.text$mn:00007BA0                 push    ebp
.text$mn:00007BA1                 mov     ebp, esp
.text$mn:00007BA3                 push    ecx
.text$mn:00007BA4                 mov     [ebp+var_4], ecx
.text$mn:00007BA7                 push    0
.text$mn:00007BA9                 mov     eax, [ebp+arg_0]
.text$mn:00007BAC                 push    eax
.text$mn:00007BAD                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00007BB2                 add     esp, 8
.text$mn:00007BB5                 mov     esp, ebp
.text$mn:00007BB7                 pop     ebp
.text$mn:00007BB8                 retn    4
.text$mn:00007BB8 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00007BB8
.text$mn:00007BB8 ; ---------------------------------------------------------------------------
.text$mn:00007BBB                 align 4
.text$mn:00007BBB _text$mn        ends
.text$mn:00007BBB
.text$mn:00007BBC ; ===========================================================================
.text$mn:00007BBC
.text$mn:00007BBC ; Segment type: Pure code
.text$mn:00007BBC ; Segment permissions: Read/Execute
.text$mn:00007BBC _text$mn        segment para public 'CODE' use32
.text$mn:00007BBC                 assume cs:_text$mn
.text$mn:00007BBC                 ;org 7BBCh
.text$mn:00007BBC ; COMDAT (pick any)
.text$mn:00007BBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BBC
.text$mn:00007BBC ; =============== S U B R O U T I N E =======================================
.text$mn:00007BBC
.text$mn:00007BBC ; Attributes: bp-based frame
.text$mn:00007BBC
.text$mn:00007BBC ; public: class std::vector<unsigned char, class std::allocator<unsigned char>> * __thiscall std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>::allocate(unsigned int)
.text$mn:00007BBC                 public ?allocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z
.text$mn:00007BBC ?allocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z proc near
.text$mn:00007BBC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::allocate(uint)+Ep
.text$mn:00007BBC
.text$mn:00007BBC var_4           = dword ptr -4
.text$mn:00007BBC arg_0           = dword ptr  8
.text$mn:00007BBC
.text$mn:00007BBC                 push    ebp
.text$mn:00007BBD                 mov     ebp, esp
.text$mn:00007BBF                 push    ecx
.text$mn:00007BC0                 mov     [ebp+var_4], ecx
.text$mn:00007BC3                 push    0
.text$mn:00007BC5                 mov     eax, [ebp+arg_0]
.text$mn:00007BC8                 push    eax
.text$mn:00007BC9                 call    ??$_Allocate@V?$vector@EV?$allocator@E@std@@@std@@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@IPAV10@@Z ; std::_Allocate<std::vector<uchar,std::allocator<uchar>>>(uint,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:00007BCE                 add     esp, 8
.text$mn:00007BD1                 mov     esp, ebp
.text$mn:00007BD3                 pop     ebp
.text$mn:00007BD4                 retn    4
.text$mn:00007BD4 ?allocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEPAV?$vector@EV?$allocator@E@std@@@2@I@Z endp
.text$mn:00007BD4
.text$mn:00007BD4 ; ---------------------------------------------------------------------------
.text$mn:00007BD7                 align 4
.text$mn:00007BD7 _text$mn        ends
.text$mn:00007BD7
.text$mn:00007BD8 ; ===========================================================================
.text$mn:00007BD8
.text$mn:00007BD8 ; Segment type: Pure code
.text$mn:00007BD8 ; Segment permissions: Read/Execute
.text$mn:00007BD8 _text$mn        segment para public 'CODE' use32
.text$mn:00007BD8                 assume cs:_text$mn
.text$mn:00007BD8                 ;org 7BD8h
.text$mn:00007BD8 ; COMDAT (pick any)
.text$mn:00007BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007BD8
.text$mn:00007BD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00007BD8
.text$mn:00007BD8 ; Attributes: bp-based frame
.text$mn:00007BD8
.text$mn:00007BD8 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00007BD8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00007BD8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00007BD8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00007BD8
.text$mn:00007BD8 Size            = dword ptr -8
.text$mn:00007BD8 var_4           = dword ptr -4
.text$mn:00007BD8 arg_0           = dword ptr  8
.text$mn:00007BD8 arg_4           = dword ptr  0Ch
.text$mn:00007BD8 arg_8           = dword ptr  10h
.text$mn:00007BD8
.text$mn:00007BD8                 push    ebp
.text$mn:00007BD9                 mov     ebp, esp
.text$mn:00007BDB                 sub     esp, 8
.text$mn:00007BDE                 mov     [ebp+var_4], ecx
.text$mn:00007BE1                 mov     ecx, [ebp+arg_0]
.text$mn:00007BE4                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007BE9                 cmp     eax, [ebp+arg_4]
.text$mn:00007BEC                 jnb     short loc_7BF6
.text$mn:00007BEE                 mov     ecx, [ebp+var_4]
.text$mn:00007BF1                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00007BF6
.text$mn:00007BF6 loc_7BF6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00007BF6                 mov     ecx, [ebp+arg_0]
.text$mn:00007BF9                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00007BFE                 sub     eax, [ebp+arg_4]
.text$mn:00007C01                 mov     [ebp+Size], eax
.text$mn:00007C04                 mov     eax, [ebp+arg_8]
.text$mn:00007C07                 cmp     eax, [ebp+Size]
.text$mn:00007C0A                 jnb     short loc_7C12
.text$mn:00007C0C                 mov     ecx, [ebp+arg_8]
.text$mn:00007C0F                 mov     [ebp+Size], ecx
.text$mn:00007C12
.text$mn:00007C12 loc_7C12:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00007C12                 mov     edx, [ebp+var_4]
.text$mn:00007C15                 cmp     edx, [ebp+arg_0]
.text$mn:00007C18                 jnz     short loc_7C39
.text$mn:00007C1A                 mov     eax, [ebp+arg_4]
.text$mn:00007C1D                 add     eax, [ebp+Size]
.text$mn:00007C20                 push    eax
.text$mn:00007C21                 mov     ecx, [ebp+var_4]
.text$mn:00007C24                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00007C29                 mov     ecx, [ebp+arg_4]
.text$mn:00007C2C                 push    ecx
.text$mn:00007C2D                 push    0
.text$mn:00007C2F                 mov     ecx, [ebp+var_4]
.text$mn:00007C32                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00007C37                 jmp     short loc_7C7B
.text$mn:00007C39 ; ---------------------------------------------------------------------------
.text$mn:00007C39
.text$mn:00007C39 loc_7C39:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00007C39                 push    0
.text$mn:00007C3B                 mov     edx, [ebp+Size]
.text$mn:00007C3E                 push    edx
.text$mn:00007C3F                 mov     ecx, [ebp+var_4]
.text$mn:00007C42                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00007C47                 movzx   eax, al
.text$mn:00007C4A                 test    eax, eax
.text$mn:00007C4C                 jz      short loc_7C7B
.text$mn:00007C4E                 mov     ecx, [ebp+Size]
.text$mn:00007C51                 push    ecx             ; Size
.text$mn:00007C52                 mov     ecx, [ebp+arg_0]
.text$mn:00007C55                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007C5A                 add     eax, [ebp+arg_4]
.text$mn:00007C5D                 push    eax             ; Src
.text$mn:00007C5E                 mov     ecx, [ebp+var_4]
.text$mn:00007C61                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007C66                 push    eax             ; Dst
.text$mn:00007C67                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007C6C                 add     esp, 0Ch
.text$mn:00007C6F                 mov     edx, [ebp+Size]
.text$mn:00007C72                 push    edx
.text$mn:00007C73                 mov     ecx, [ebp+var_4]
.text$mn:00007C76                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007C7B
.text$mn:00007C7B loc_7C7B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00007C7B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00007C7B                 mov     eax, [ebp+var_4]
.text$mn:00007C7E                 mov     esp, ebp
.text$mn:00007C80                 pop     ebp
.text$mn:00007C81                 retn    0Ch
.text$mn:00007C81 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00007C81
.text$mn:00007C81 _text$mn        ends
.text$mn:00007C81
.text$mn:00007C84 ; ===========================================================================
.text$mn:00007C84
.text$mn:00007C84 ; Segment type: Pure code
.text$mn:00007C84 ; Segment permissions: Read/Execute
.text$mn:00007C84 _text$mn        segment para public 'CODE' use32
.text$mn:00007C84                 assume cs:_text$mn
.text$mn:00007C84                 ;org 7C84h
.text$mn:00007C84 ; COMDAT (pick any)
.text$mn:00007C84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007C84
.text$mn:00007C84 ; =============== S U B R O U T I N E =======================================
.text$mn:00007C84
.text$mn:00007C84 ; Attributes: bp-based frame
.text$mn:00007C84
.text$mn:00007C84 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00007C84                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00007C84 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00007C84                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00007C84
.text$mn:00007C84 var_4           = dword ptr -4
.text$mn:00007C84 Str             = dword ptr  8
.text$mn:00007C84
.text$mn:00007C84                 push    ebp
.text$mn:00007C85                 mov     ebp, esp
.text$mn:00007C87                 push    ecx
.text$mn:00007C88                 mov     [ebp+var_4], ecx
.text$mn:00007C8B                 push    490h            ; unsigned int
.text$mn:00007C90                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007C95                 mov     eax, [ebp+Str]
.text$mn:00007C98                 push    eax             ; int
.text$mn:00007C99                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00007C9E                 add     esp, 0Ch
.text$mn:00007CA1                 mov     ecx, [ebp+Str]
.text$mn:00007CA4                 push    ecx             ; Str
.text$mn:00007CA5                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00007CAA                 add     esp, 4
.text$mn:00007CAD                 push    eax             ; Size
.text$mn:00007CAE                 mov     edx, [ebp+Str]
.text$mn:00007CB1                 push    edx             ; Src
.text$mn:00007CB2                 mov     ecx, [ebp+var_4]
.text$mn:00007CB5                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00007CBA                 mov     esp, ebp
.text$mn:00007CBC                 pop     ebp
.text$mn:00007CBD                 retn    4
.text$mn:00007CBD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00007CBD
.text$mn:00007CBD _text$mn        ends
.text$mn:00007CBD
.text$mn:00007CC0 ; ===========================================================================
.text$mn:00007CC0
.text$mn:00007CC0 ; Segment type: Pure code
.text$mn:00007CC0 ; Segment permissions: Read/Execute
.text$mn:00007CC0 _text$mn        segment para public 'CODE' use32
.text$mn:00007CC0                 assume cs:_text$mn
.text$mn:00007CC0                 ;org 7CC0h
.text$mn:00007CC0 ; COMDAT (pick any)
.text$mn:00007CC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007CC0
.text$mn:00007CC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00007CC0
.text$mn:00007CC0 ; Attributes: bp-based frame
.text$mn:00007CC0
.text$mn:00007CC0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00007CC0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00007CC0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00007CC0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00007CC0
.text$mn:00007CC0 var_4           = dword ptr -4
.text$mn:00007CC0 Src             = dword ptr  8
.text$mn:00007CC0 Size            = dword ptr  0Ch
.text$mn:00007CC0
.text$mn:00007CC0                 push    ebp
.text$mn:00007CC1                 mov     ebp, esp
.text$mn:00007CC3                 push    ecx
.text$mn:00007CC4                 mov     [ebp+var_4], ecx
.text$mn:00007CC7                 cmp     [ebp+Size], 0
.text$mn:00007CCB                 jz      short loc_7CE3
.text$mn:00007CCD                 push    47Fh            ; unsigned int
.text$mn:00007CD2                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00007CD7                 mov     eax, [ebp+Src]
.text$mn:00007CDA                 push    eax             ; int
.text$mn:00007CDB                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00007CE0                 add     esp, 0Ch
.text$mn:00007CE3
.text$mn:00007CE3 loc_7CE3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00007CE3                 mov     ecx, [ebp+Src]
.text$mn:00007CE6                 push    ecx
.text$mn:00007CE7                 mov     ecx, [ebp+var_4]
.text$mn:00007CEA                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00007CEF                 movzx   edx, al
.text$mn:00007CF2                 test    edx, edx
.text$mn:00007CF4                 jz      short loc_7D16
.text$mn:00007CF6                 mov     eax, [ebp+Size]
.text$mn:00007CF9                 push    eax
.text$mn:00007CFA                 mov     ecx, [ebp+var_4]
.text$mn:00007CFD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007D02                 mov     ecx, [ebp+Src]
.text$mn:00007D05                 sub     ecx, eax
.text$mn:00007D07                 push    ecx
.text$mn:00007D08                 mov     edx, [ebp+var_4]
.text$mn:00007D0B                 push    edx
.text$mn:00007D0C                 mov     ecx, [ebp+var_4]
.text$mn:00007D0F                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00007D14                 jmp     short loc_7D53
.text$mn:00007D16 ; ---------------------------------------------------------------------------
.text$mn:00007D16
.text$mn:00007D16 loc_7D16:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00007D16                 push    0
.text$mn:00007D18                 mov     eax, [ebp+Size]
.text$mn:00007D1B                 push    eax
.text$mn:00007D1C                 mov     ecx, [ebp+var_4]
.text$mn:00007D1F                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00007D24                 movzx   ecx, al
.text$mn:00007D27                 test    ecx, ecx
.text$mn:00007D29                 jz      short loc_7D50
.text$mn:00007D2B                 mov     edx, [ebp+Size]
.text$mn:00007D2E                 push    edx             ; Size
.text$mn:00007D2F                 mov     eax, [ebp+Src]
.text$mn:00007D32                 push    eax             ; Src
.text$mn:00007D33                 mov     ecx, [ebp+var_4]
.text$mn:00007D36                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00007D3B                 push    eax             ; Dst
.text$mn:00007D3C                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00007D41                 add     esp, 0Ch
.text$mn:00007D44                 mov     ecx, [ebp+Size]
.text$mn:00007D47                 push    ecx
.text$mn:00007D48                 mov     ecx, [ebp+var_4]
.text$mn:00007D4B                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00007D50
.text$mn:00007D50 loc_7D50:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00007D50                 mov     eax, [ebp+var_4]
.text$mn:00007D53
.text$mn:00007D53 loc_7D53:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00007D53                 mov     esp, ebp
.text$mn:00007D55                 pop     ebp
.text$mn:00007D56                 retn    8
.text$mn:00007D56 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00007D56
.text$mn:00007D56 ; ---------------------------------------------------------------------------
.text$mn:00007D59                 align 4
.text$mn:00007D59 _text$mn        ends
.text$mn:00007D59
.text$mn:00007D5C ; ===========================================================================
.text$mn:00007D5C
.text$mn:00007D5C ; Segment type: Pure code
.text$mn:00007D5C ; Segment permissions: Read/Execute
.text$mn:00007D5C _text$mn        segment para public 'CODE' use32
.text$mn:00007D5C                 assume cs:_text$mn
.text$mn:00007D5C                 ;org 7D5Ch
.text$mn:00007D5C ; COMDAT (pick any)
.text$mn:00007D5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D5C
.text$mn:00007D5C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D5C
.text$mn:00007D5C ; Attributes: bp-based frame
.text$mn:00007D5C
.text$mn:00007D5C ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00007D5C                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00007D5C ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00007D5C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00007D5C
.text$mn:00007D5C arg_0           = dword ptr  8
.text$mn:00007D5C arg_4           = dword ptr  0Ch
.text$mn:00007D5C
.text$mn:00007D5C                 push    ebp
.text$mn:00007D5D                 mov     ebp, esp
.text$mn:00007D5F                 mov     eax, [ebp+arg_0]
.text$mn:00007D62                 mov     ecx, [ebp+arg_4]
.text$mn:00007D65                 mov     dl, [ecx]
.text$mn:00007D67                 mov     [eax], dl
.text$mn:00007D69                 pop     ebp
.text$mn:00007D6A                 retn
.text$mn:00007D6A ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00007D6A
.text$mn:00007D6A ; ---------------------------------------------------------------------------
.text$mn:00007D6B                 align 4
.text$mn:00007D6B _text$mn        ends
.text$mn:00007D6B
.text$mn:00007D6C ; ===========================================================================
.text$mn:00007D6C
.text$mn:00007D6C ; Segment type: Pure code
.text$mn:00007D6C ; Segment permissions: Read/Execute
.text$mn:00007D6C _text$mn        segment para public 'CODE' use32
.text$mn:00007D6C                 assume cs:_text$mn
.text$mn:00007D6C                 ;org 7D6Ch
.text$mn:00007D6C ; COMDAT (pick any)
.text$mn:00007D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007D6C
.text$mn:00007D6C ; =============== S U B R O U T I N E =======================================
.text$mn:00007D6C
.text$mn:00007D6C ; Attributes: bp-based frame
.text$mn:00007D6C
.text$mn:00007D6C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>> __thiscall std::move_iterator<class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>>>::base(void)const
.text$mn:00007D6C                 public ?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00007D6C ?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$mn:00007D6C                                         ; CODE XREF: std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+2Cp
.text$mn:00007D6C                                         ; std::operator-<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>,std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> &,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>> const &)+4Cp ...
.text$mn:00007D6C
.text$mn:00007D6C var_14          = dword ptr -14h
.text$mn:00007D6C var_10          = dword ptr -10h
.text$mn:00007D6C var_C           = dword ptr -0Ch
.text$mn:00007D6C var_4           = dword ptr -4
.text$mn:00007D6C arg_0           = dword ptr  8
.text$mn:00007D6C
.text$mn:00007D6C                 push    ebp
.text$mn:00007D6D                 mov     ebp, esp
.text$mn:00007D6F                 push    0FFFFFFFFh
.text$mn:00007D71                 push    offset __ehhandler$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00007D76                 mov     eax, large fs:0
.text$mn:00007D7C                 push    eax
.text$mn:00007D7D                 sub     esp, 8
.text$mn:00007D80                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007D85                 xor     eax, ebp
.text$mn:00007D87                 push    eax
.text$mn:00007D88                 lea     eax, [ebp+var_C]
.text$mn:00007D8B                 mov     large fs:0, eax
.text$mn:00007D91                 mov     [ebp+var_14], ecx
.text$mn:00007D94                 mov     [ebp+var_10], 0
.text$mn:00007D9B                 mov     eax, [ebp+var_14]
.text$mn:00007D9E                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00007D9F                 mov     ecx, [ebp+arg_0]
.text$mn:00007DA2                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)
.text$mn:00007DA7                 mov     [ebp+var_4], 0
.text$mn:00007DAE                 mov     ecx, [ebp+var_10]
.text$mn:00007DB1                 or      ecx, 1
.text$mn:00007DB4                 mov     [ebp+var_10], ecx
.text$mn:00007DB7                 mov     eax, [ebp+arg_0]
.text$mn:00007DBA                 mov     ecx, [ebp+var_C]
.text$mn:00007DBD                 mov     large fs:0, ecx
.text$mn:00007DC4                 pop     ecx
.text$mn:00007DC5                 mov     esp, ebp
.text$mn:00007DC7                 pop     ebp
.text$mn:00007DC8                 retn    4
.text$mn:00007DC8 ?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$mn:00007DC8
.text$mn:00007DC8 ; ---------------------------------------------------------------------------
.text$mn:00007DCB                 align 4
.text$mn:00007DCB _text$mn        ends
.text$mn:00007DCB
.text$x:00007DCC ; ===========================================================================
.text$x:00007DCC
.text$x:00007DCC ; Segment type: Pure code
.text$x:00007DCC ; Segment permissions: Read/Execute
.text$x:00007DCC _text$x         segment para public 'CODE' use32
.text$x:00007DCC                 assume cs:_text$x
.text$x:00007DCC                 ;org 7DCCh
.text$x:00007DCC ; COMDAT (pick associative to section at 7D6C)
.text$x:00007DCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007DCC
.text$x:00007DCC ; =============== S U B R O U T I N E =======================================
.text$x:00007DCC
.text$x:00007DCC
.text$x:00007DCC __unwindfunclet$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 proc near
.text$x:00007DCC                                         ; DATA XREF: .xdata$x:00009F34o
.text$x:00007DCC                 mov     eax, [ebp-10h]
.text$x:00007DCF                 and     eax, 1
.text$x:00007DD2                 jz      $LN4_4
.text$x:00007DD8                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00007DDC                 mov     ecx, [ebp+8]
.text$x:00007DDF                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00007DE4 ; ---------------------------------------------------------------------------
.text$x:00007DE4
.text$x:00007DE4 $LN4_4:                                 ; CODE XREF: __unwindfunclet$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0+6j
.text$x:00007DE4                 retn
.text$x:00007DE4 __unwindfunclet$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 endp
.text$x:00007DE4
.text$x:00007DE5
.text$x:00007DE5 ; =============== S U B R O U T I N E =======================================
.text$x:00007DE5
.text$x:00007DE5
.text$x:00007DE5 __ehhandler$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$x:00007DE5                                         ; DATA XREF: std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>::base(void)+5o
.text$x:00007DE5
.text$x:00007DE5 arg_4           = dword ptr  8
.text$x:00007DE5
.text$x:00007DE5                 mov     edx, [esp+arg_4]
.text$x:00007DE9                 lea     eax, [edx+0Ch]
.text$x:00007DEC                 mov     ecx, [edx-0Ch]
.text$x:00007DEF                 xor     ecx, eax
.text$x:00007DF1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007DF6                 mov     eax, offset __ehfuncinfo$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$x:00007DFB                 jmp     ___CxxFrameHandler3
.text$x:00007DFB __ehhandler$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$x:00007DFB
.text$x:00007DFB _text$x         ends
.text$x:00007DFB
.text$mn:00007E00 ; ===========================================================================
.text$mn:00007E00
.text$mn:00007E00 ; Segment type: Pure code
.text$mn:00007E00 ; Segment permissions: Read/Execute
.text$mn:00007E00 _text$mn        segment para public 'CODE' use32
.text$mn:00007E00                 assume cs:_text$mn
.text$mn:00007E00                 ;org 7E00h
.text$mn:00007E00 ; COMDAT (pick any)
.text$mn:00007E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E00
.text$mn:00007E00 ; =============== S U B R O U T I N E =======================================
.text$mn:00007E00
.text$mn:00007E00 ; Attributes: bp-based frame
.text$mn:00007E00
.text$mn:00007E00 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>> __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::begin(void)
.text$mn:00007E00                 public ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00007E00 ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$mn:00007E00                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+D3p
.text$mn:00007E00
.text$mn:00007E00 var_14          = dword ptr -14h
.text$mn:00007E00 var_10          = dword ptr -10h
.text$mn:00007E00 var_C           = dword ptr -0Ch
.text$mn:00007E00 var_4           = dword ptr -4
.text$mn:00007E00 arg_0           = dword ptr  8
.text$mn:00007E00
.text$mn:00007E00                 push    ebp
.text$mn:00007E01                 mov     ebp, esp
.text$mn:00007E03                 push    0FFFFFFFFh
.text$mn:00007E05                 push    offset __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00007E0A                 mov     eax, large fs:0
.text$mn:00007E10                 push    eax
.text$mn:00007E11                 sub     esp, 8
.text$mn:00007E14                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007E19                 xor     eax, ebp
.text$mn:00007E1B                 push    eax
.text$mn:00007E1C                 lea     eax, [ebp+var_C]
.text$mn:00007E1F                 mov     large fs:0, eax
.text$mn:00007E25                 mov     [ebp+var_10], ecx
.text$mn:00007E28                 mov     [ebp+var_14], 0
.text$mn:00007E2F                 mov     eax, [ebp+var_10]
.text$mn:00007E32                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007E33                 mov     ecx, [ebp+var_10]
.text$mn:00007E36                 mov     edx, [ecx+4]
.text$mn:00007E39                 push    edx             ; int
.text$mn:00007E3A                 mov     ecx, [ebp+arg_0]
.text$mn:00007E3D                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)
.text$mn:00007E42                 mov     [ebp+var_4], 0
.text$mn:00007E49                 mov     eax, [ebp+var_14]
.text$mn:00007E4C                 or      eax, 1
.text$mn:00007E4F                 mov     [ebp+var_14], eax
.text$mn:00007E52                 mov     eax, [ebp+arg_0]
.text$mn:00007E55                 mov     ecx, [ebp+var_C]
.text$mn:00007E58                 mov     large fs:0, ecx
.text$mn:00007E5F                 pop     ecx
.text$mn:00007E60                 mov     esp, ebp
.text$mn:00007E62                 pop     ebp
.text$mn:00007E63                 retn    4
.text$mn:00007E63 ?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$mn:00007E63
.text$mn:00007E63 ; ---------------------------------------------------------------------------
.text$mn:00007E66                 align 4
.text$mn:00007E66 _text$mn        ends
.text$mn:00007E66
.text$x:00007E68 ; ===========================================================================
.text$x:00007E68
.text$x:00007E68 ; Segment type: Pure code
.text$x:00007E68 ; Segment permissions: Read/Execute
.text$x:00007E68 _text$x         segment para public 'CODE' use32
.text$x:00007E68                 assume cs:_text$x
.text$x:00007E68                 ;org 7E68h
.text$x:00007E68 ; COMDAT (pick associative to section at 7E00)
.text$x:00007E68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007E68
.text$x:00007E68 ; =============== S U B R O U T I N E =======================================
.text$x:00007E68
.text$x:00007E68
.text$x:00007E68 __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 proc near
.text$x:00007E68                                         ; DATA XREF: .xdata$x:000098ACo
.text$x:00007E68                 mov     eax, [ebp-14h]
.text$x:00007E6B                 and     eax, 1
.text$x:00007E6E                 jz      $LN4_0
.text$x:00007E74                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00007E78                 mov     ecx, [ebp+8]
.text$x:00007E7B                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00007E80 ; ---------------------------------------------------------------------------
.text$x:00007E80
.text$x:00007E80 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0+6j
.text$x:00007E80                 retn
.text$x:00007E80 __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 endp
.text$x:00007E80
.text$x:00007E81
.text$x:00007E81 ; =============== S U B R O U T I N E =======================================
.text$x:00007E81
.text$x:00007E81
.text$x:00007E81 __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$x:00007E81                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::begin(void)+5o
.text$x:00007E81
.text$x:00007E81 arg_4           = dword ptr  8
.text$x:00007E81
.text$x:00007E81                 mov     edx, [esp+arg_4]
.text$x:00007E85                 lea     eax, [edx+0Ch]
.text$x:00007E88                 mov     ecx, [edx-0Ch]
.text$x:00007E8B                 xor     ecx, eax
.text$x:00007E8D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007E92                 mov     eax, offset __ehfuncinfo$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$x:00007E97                 jmp     ___CxxFrameHandler3
.text$x:00007E97 __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$x:00007E97
.text$x:00007E97 _text$x         ends
.text$x:00007E97
.text$mn:00007E9C ; ===========================================================================
.text$mn:00007E9C
.text$mn:00007E9C ; Segment type: Pure code
.text$mn:00007E9C ; Segment permissions: Read/Execute
.text$mn:00007E9C _text$mn        segment para public 'CODE' use32
.text$mn:00007E9C                 assume cs:_text$mn
.text$mn:00007E9C                 ;org 7E9Ch
.text$mn:00007E9C ; COMDAT (pick any)
.text$mn:00007E9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007E9C
.text$mn:00007E9C ; =============== S U B R O U T I N E =======================================
.text$mn:00007E9C
.text$mn:00007E9C ; Attributes: bp-based frame
.text$mn:00007E9C
.text$mn:00007E9C ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>> __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::begin(void)const
.text$mn:00007E9C                 public ?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00007E9C ?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$mn:00007E9C                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+A7p
.text$mn:00007E9C
.text$mn:00007E9C var_14          = dword ptr -14h
.text$mn:00007E9C var_10          = dword ptr -10h
.text$mn:00007E9C var_C           = dword ptr -0Ch
.text$mn:00007E9C var_4           = dword ptr -4
.text$mn:00007E9C arg_0           = dword ptr  8
.text$mn:00007E9C
.text$mn:00007E9C                 push    ebp
.text$mn:00007E9D                 mov     ebp, esp
.text$mn:00007E9F                 push    0FFFFFFFFh
.text$mn:00007EA1                 push    offset __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00007EA6                 mov     eax, large fs:0
.text$mn:00007EAC                 push    eax
.text$mn:00007EAD                 sub     esp, 8
.text$mn:00007EB0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007EB5                 xor     eax, ebp
.text$mn:00007EB7                 push    eax
.text$mn:00007EB8                 lea     eax, [ebp+var_C]
.text$mn:00007EBB                 mov     large fs:0, eax
.text$mn:00007EC1                 mov     [ebp+var_10], ecx
.text$mn:00007EC4                 mov     [ebp+var_14], 0
.text$mn:00007ECB                 mov     eax, [ebp+var_10]
.text$mn:00007ECE                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007ECF                 mov     ecx, [ebp+var_10]
.text$mn:00007ED2                 mov     edx, [ecx+4]
.text$mn:00007ED5                 push    edx             ; int
.text$mn:00007ED6                 mov     ecx, [ebp+arg_0]
.text$mn:00007ED9                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)
.text$mn:00007EDE                 mov     [ebp+var_4], 0
.text$mn:00007EE5                 mov     eax, [ebp+var_14]
.text$mn:00007EE8                 or      eax, 1
.text$mn:00007EEB                 mov     [ebp+var_14], eax
.text$mn:00007EEE                 mov     eax, [ebp+arg_0]
.text$mn:00007EF1                 mov     ecx, [ebp+var_C]
.text$mn:00007EF4                 mov     large fs:0, ecx
.text$mn:00007EFB                 pop     ecx
.text$mn:00007EFC                 mov     esp, ebp
.text$mn:00007EFE                 pop     ebp
.text$mn:00007EFF                 retn    4
.text$mn:00007EFF ?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$mn:00007EFF
.text$mn:00007EFF ; ---------------------------------------------------------------------------
.text$mn:00007F02                 align 4
.text$mn:00007F02 _text$mn        ends
.text$mn:00007F02
.text$x:00007F04 ; ===========================================================================
.text$x:00007F04
.text$x:00007F04 ; Segment type: Pure code
.text$x:00007F04 ; Segment permissions: Read/Execute
.text$x:00007F04 _text$x         segment para public 'CODE' use32
.text$x:00007F04                 assume cs:_text$x
.text$x:00007F04                 ;org 7F04h
.text$x:00007F04 ; COMDAT (pick associative to section at 7E9C)
.text$x:00007F04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007F04
.text$x:00007F04 ; =============== S U B R O U T I N E =======================================
.text$x:00007F04
.text$x:00007F04
.text$x:00007F04 __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 proc near
.text$x:00007F04                                         ; DATA XREF: .xdata$x:000098D8o
.text$x:00007F04                 mov     eax, [ebp-14h]
.text$x:00007F07                 and     eax, 1
.text$x:00007F0A                 jz      $LN4_1
.text$x:00007F10                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00007F14                 mov     ecx, [ebp+8]
.text$x:00007F17                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:00007F1C ; ---------------------------------------------------------------------------
.text$x:00007F1C
.text$x:00007F1C $LN4_1:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0+6j
.text$x:00007F1C                 retn
.text$x:00007F1C __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 endp
.text$x:00007F1C
.text$x:00007F1D
.text$x:00007F1D ; =============== S U B R O U T I N E =======================================
.text$x:00007F1D
.text$x:00007F1D
.text$x:00007F1D __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$x:00007F1D                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::begin(void)+5o
.text$x:00007F1D
.text$x:00007F1D arg_4           = dword ptr  8
.text$x:00007F1D
.text$x:00007F1D                 mov     edx, [esp+arg_4]
.text$x:00007F21                 lea     eax, [edx+0Ch]
.text$x:00007F24                 mov     ecx, [edx-0Ch]
.text$x:00007F27                 xor     ecx, eax
.text$x:00007F29                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007F2E                 mov     eax, offset __ehfuncinfo$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$x:00007F33                 jmp     ___CxxFrameHandler3
.text$x:00007F33 __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$x:00007F33
.text$x:00007F33 _text$x         ends
.text$x:00007F33
.text$mn:00007F38 ; ===========================================================================
.text$mn:00007F38
.text$mn:00007F38 ; Segment type: Pure code
.text$mn:00007F38 ; Segment permissions: Read/Execute
.text$mn:00007F38 _text$mn        segment para public 'CODE' use32
.text$mn:00007F38                 assume cs:_text$mn
.text$mn:00007F38                 ;org 7F38h
.text$mn:00007F38 ; COMDAT (pick any)
.text$mn:00007F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007F38
.text$mn:00007F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00007F38
.text$mn:00007F38 ; Attributes: bp-based frame
.text$mn:00007F38
.text$mn:00007F38 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::begin(void)
.text$mn:00007F38                 public ?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00007F38 ?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ proc near
.text$mn:00007F38                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+A1p
.text$mn:00007F38                                         ; ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+156p ...
.text$mn:00007F38
.text$mn:00007F38 var_14          = dword ptr -14h
.text$mn:00007F38 var_10          = dword ptr -10h
.text$mn:00007F38 var_C           = dword ptr -0Ch
.text$mn:00007F38 var_4           = dword ptr -4
.text$mn:00007F38 arg_0           = dword ptr  8
.text$mn:00007F38
.text$mn:00007F38                 push    ebp
.text$mn:00007F39                 mov     ebp, esp
.text$mn:00007F3B                 push    0FFFFFFFFh
.text$mn:00007F3D                 push    offset __ehhandler$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ
.text$mn:00007F42                 mov     eax, large fs:0
.text$mn:00007F48                 push    eax
.text$mn:00007F49                 sub     esp, 8
.text$mn:00007F4C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00007F51                 xor     eax, ebp
.text$mn:00007F53                 push    eax
.text$mn:00007F54                 lea     eax, [ebp+var_C]
.text$mn:00007F57                 mov     large fs:0, eax
.text$mn:00007F5D                 mov     [ebp+var_10], ecx
.text$mn:00007F60                 mov     [ebp+var_14], 0
.text$mn:00007F67                 mov     eax, [ebp+var_10]
.text$mn:00007F6A                 push    eax             ; struct std::_Container_base12 *
.text$mn:00007F6B                 mov     ecx, [ebp+var_10]
.text$mn:00007F6E                 mov     edx, [ecx+4]
.text$mn:00007F71                 push    edx             ; int
.text$mn:00007F72                 mov     ecx, [ebp+arg_0]
.text$mn:00007F75                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::vector<uchar,std::allocator<uchar>> *,std::_Container_base12 const *)
.text$mn:00007F7A                 mov     [ebp+var_4], 0
.text$mn:00007F81                 mov     eax, [ebp+var_14]
.text$mn:00007F84                 or      eax, 1
.text$mn:00007F87                 mov     [ebp+var_14], eax
.text$mn:00007F8A                 mov     eax, [ebp+arg_0]
.text$mn:00007F8D                 mov     ecx, [ebp+var_C]
.text$mn:00007F90                 mov     large fs:0, ecx
.text$mn:00007F97                 pop     ecx
.text$mn:00007F98                 mov     esp, ebp
.text$mn:00007F9A                 pop     ebp
.text$mn:00007F9B                 retn    4
.text$mn:00007F9B ?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ endp
.text$mn:00007F9B
.text$mn:00007F9B ; ---------------------------------------------------------------------------
.text$mn:00007F9E                 align 10h
.text$mn:00007F9E _text$mn        ends
.text$mn:00007F9E
.text$x:00007FA0 ; ===========================================================================
.text$x:00007FA0
.text$x:00007FA0 ; Segment type: Pure code
.text$x:00007FA0 ; Segment permissions: Read/Execute
.text$x:00007FA0 _text$x         segment para public 'CODE' use32
.text$x:00007FA0                 assume cs:_text$x
.text$x:00007FA0                 ;org 7FA0h
.text$x:00007FA0 ; COMDAT (pick associative to section at 7F38)
.text$x:00007FA0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00007FA0
.text$x:00007FA0 ; =============== S U B R O U T I N E =======================================
.text$x:00007FA0
.text$x:00007FA0
.text$x:00007FA0 __unwindfunclet$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ$0 proc near
.text$x:00007FA0                                         ; DATA XREF: .xdata$x:000094B4o
.text$x:00007FA0                 mov     eax, [ebp-14h]
.text$x:00007FA3                 and     eax, 1
.text$x:00007FA6                 jz      $LN4
.text$x:00007FAC                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00007FB0                 mov     ecx, [ebp+8]
.text$x:00007FB3                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00007FB8 ; ---------------------------------------------------------------------------
.text$x:00007FB8
.text$x:00007FB8 $LN4:                                   ; CODE XREF: __unwindfunclet$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ$0+6j
.text$x:00007FB8                 retn
.text$x:00007FB8 __unwindfunclet$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ$0 endp
.text$x:00007FB8
.text$x:00007FB9
.text$x:00007FB9 ; =============== S U B R O U T I N E =======================================
.text$x:00007FB9
.text$x:00007FB9
.text$x:00007FB9 __ehhandler$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ proc near
.text$x:00007FB9                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::begin(void)+5o
.text$x:00007FB9
.text$x:00007FB9 arg_4           = dword ptr  8
.text$x:00007FB9
.text$x:00007FB9                 mov     edx, [esp+arg_4]
.text$x:00007FBD                 lea     eax, [edx+0Ch]
.text$x:00007FC0                 mov     ecx, [edx-0Ch]
.text$x:00007FC3                 xor     ecx, eax
.text$x:00007FC5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00007FCA                 mov     eax, offset __ehfuncinfo$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ
.text$x:00007FCF                 jmp     ___CxxFrameHandler3
.text$x:00007FCF __ehhandler$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ endp
.text$x:00007FCF
.text$x:00007FCF _text$x         ends
.text$x:00007FCF
.text$mn:00007FD4 ; ===========================================================================
.text$mn:00007FD4
.text$mn:00007FD4 ; Segment type: Pure code
.text$mn:00007FD4 ; Segment permissions: Read/Execute
.text$mn:00007FD4 _text$mn        segment para public 'CODE' use32
.text$mn:00007FD4                 assume cs:_text$mn
.text$mn:00007FD4                 ;org 7FD4h
.text$mn:00007FD4 ; COMDAT (pick any)
.text$mn:00007FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FD4
.text$mn:00007FD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00007FD4
.text$mn:00007FD4 ; Attributes: bp-based frame
.text$mn:00007FD4
.text$mn:00007FD4 ; public: unsigned int __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::capacity(void)const
.text$mn:00007FD4                 public ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
.text$mn:00007FD4 ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ proc near
.text$mn:00007FD4                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+118p
.text$mn:00007FD4                                         ; std::vector<uchar,std::allocator<uchar>>::_Grow_to(uint)+Cp
.text$mn:00007FD4
.text$mn:00007FD4 var_4           = dword ptr -4
.text$mn:00007FD4
.text$mn:00007FD4                 push    ebp
.text$mn:00007FD5                 mov     ebp, esp
.text$mn:00007FD7                 push    ecx
.text$mn:00007FD8                 mov     [ebp+var_4], ecx
.text$mn:00007FDB                 mov     eax, [ebp+var_4]
.text$mn:00007FDE                 mov     ecx, [ebp+var_4]
.text$mn:00007FE1                 mov     eax, [eax+0Ch]
.text$mn:00007FE4                 sub     eax, [ecx+4]
.text$mn:00007FE7                 mov     esp, ebp
.text$mn:00007FE9                 pop     ebp
.text$mn:00007FEA                 retn
.text$mn:00007FEA ?capacity@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ endp
.text$mn:00007FEA
.text$mn:00007FEA ; ---------------------------------------------------------------------------
.text$mn:00007FEB                 align 4
.text$mn:00007FEB _text$mn        ends
.text$mn:00007FEB
.text$mn:00007FEC ; ===========================================================================
.text$mn:00007FEC
.text$mn:00007FEC ; Segment type: Pure code
.text$mn:00007FEC ; Segment permissions: Read/Execute
.text$mn:00007FEC _text$mn        segment para public 'CODE' use32
.text$mn:00007FEC                 assume cs:_text$mn
.text$mn:00007FEC                 ;org 7FECh
.text$mn:00007FEC ; COMDAT (pick any)
.text$mn:00007FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00007FEC
.text$mn:00007FEC ; =============== S U B R O U T I N E =======================================
.text$mn:00007FEC
.text$mn:00007FEC ; Attributes: bp-based frame
.text$mn:00007FEC
.text$mn:00007FEC ; public: unsigned int __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::capacity(void)const
.text$mn:00007FEC                 public ?capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00007FEC ?capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00007FEC                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Grow_to(uint)+Cp
.text$mn:00007FEC
.text$mn:00007FEC var_4           = dword ptr -4
.text$mn:00007FEC
.text$mn:00007FEC                 push    ebp
.text$mn:00007FED                 mov     ebp, esp
.text$mn:00007FEF                 push    ecx
.text$mn:00007FF0                 mov     [ebp+var_4], ecx
.text$mn:00007FF3                 mov     eax, [ebp+var_4]
.text$mn:00007FF6                 mov     ecx, [ebp+var_4]
.text$mn:00007FF9                 mov     eax, [eax+0Ch]
.text$mn:00007FFC                 sub     eax, [ecx+4]
.text$mn:00007FFF                 sar     eax, 4
.text$mn:00008002                 mov     esp, ebp
.text$mn:00008004                 pop     ebp
.text$mn:00008005                 retn
.text$mn:00008005 ?capacity@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:00008005
.text$mn:00008005 ; ---------------------------------------------------------------------------
.text$mn:00008006                 align 4
.text$mn:00008006 _text$mn        ends
.text$mn:00008006
.text$mn:00008008 ; ===========================================================================
.text$mn:00008008
.text$mn:00008008 ; Segment type: Pure code
.text$mn:00008008 ; Segment permissions: Read/Execute
.text$mn:00008008 _text$mn        segment para public 'CODE' use32
.text$mn:00008008                 assume cs:_text$mn
.text$mn:00008008                 ;org 8008h
.text$mn:00008008 ; COMDAT (pick any)
.text$mn:00008008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008008
.text$mn:00008008 ; =============== S U B R O U T I N E =======================================
.text$mn:00008008
.text$mn:00008008 ; Attributes: bp-based frame
.text$mn:00008008
.text$mn:00008008 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00008008                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00008008 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00008008                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00008008
.text$mn:00008008 var_4           = dword ptr -4
.text$mn:00008008
.text$mn:00008008                 push    ebp
.text$mn:00008009                 mov     ebp, esp
.text$mn:0000800B                 push    ecx
.text$mn:0000800C                 mov     [ebp+var_4], ecx
.text$mn:0000800F                 mov     eax, [ebp+var_4]
.text$mn:00008012                 mov     eax, [eax+4]
.text$mn:00008015                 mov     esp, ebp
.text$mn:00008017                 pop     ebp
.text$mn:00008018                 retn
.text$mn:00008018 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00008018
.text$mn:00008018 ; ---------------------------------------------------------------------------
.text$mn:00008019                 align 4
.text$mn:00008019 _text$mn        ends
.text$mn:00008019
.text$mn:0000801C ; ===========================================================================
.text$mn:0000801C
.text$mn:0000801C ; Segment type: Pure code
.text$mn:0000801C ; Segment permissions: Read/Execute
.text$mn:0000801C _text$mn        segment para public 'CODE' use32
.text$mn:0000801C                 assume cs:_text$mn
.text$mn:0000801C                 ;org 801Ch
.text$mn:0000801C ; COMDAT (pick any)
.text$mn:0000801C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000801C
.text$mn:0000801C ; =============== S U B R O U T I N E =======================================
.text$mn:0000801C
.text$mn:0000801C ; Attributes: bp-based frame
.text$mn:0000801C
.text$mn:0000801C ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000801C                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000801C ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000801C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000801C                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000801C
.text$mn:0000801C var_4           = dword ptr -4
.text$mn:0000801C
.text$mn:0000801C                 push    ebp
.text$mn:0000801D                 mov     ebp, esp
.text$mn:0000801F                 push    ecx
.text$mn:00008020                 mov     [ebp+var_4], ecx
.text$mn:00008023                 mov     eax, [ebp+var_4]
.text$mn:00008026                 mov     eax, [eax+4]
.text$mn:00008029                 mov     esp, ebp
.text$mn:0000802B                 pop     ebp
.text$mn:0000802C                 retn
.text$mn:0000802C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000802C
.text$mn:0000802C ; ---------------------------------------------------------------------------
.text$mn:0000802D                 align 10h
.text$mn:0000802D _text$mn        ends
.text$mn:0000802D
.text$mn:00008030 ; ===========================================================================
.text$mn:00008030
.text$mn:00008030 ; Segment type: Pure code
.text$mn:00008030 ; Segment permissions: Read/Execute
.text$mn:00008030 _text$mn        segment para public 'CODE' use32
.text$mn:00008030                 assume cs:_text$mn
.text$mn:00008030                 ;org 8030h
.text$mn:00008030 ; COMDAT (pick any)
.text$mn:00008030                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008030
.text$mn:00008030 ; =============== S U B R O U T I N E =======================================
.text$mn:00008030
.text$mn:00008030 ; Attributes: bp-based frame
.text$mn:00008030
.text$mn:00008030 ; public: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::clear(void)
.text$mn:00008030                 public ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ
.text$mn:00008030 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ proc near
.text$mn:00008030                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+9Fp
.text$mn:00008030
.text$mn:00008030 var_4           = dword ptr -4
.text$mn:00008030
.text$mn:00008030                 push    ebp
.text$mn:00008031                 mov     ebp, esp
.text$mn:00008033                 push    ecx
.text$mn:00008034                 mov     [ebp+var_4], ecx
.text$mn:00008037                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000803A                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000803F                 mov     eax, [ebp+var_4]
.text$mn:00008042                 mov     ecx, [eax+8]
.text$mn:00008045                 push    ecx
.text$mn:00008046                 mov     edx, [ebp+var_4]
.text$mn:00008049                 mov     eax, [edx+4]
.text$mn:0000804C                 push    eax
.text$mn:0000804D                 mov     ecx, [ebp+var_4]
.text$mn:00008050                 call    ?_Destroy@?$vector@EV?$allocator@E@std@@@std@@IAEXPAE0@Z ; std::vector<uchar,std::allocator<uchar>>::_Destroy(uchar *,uchar *)
.text$mn:00008055                 mov     ecx, [ebp+var_4]
.text$mn:00008058                 mov     edx, [ebp+var_4]
.text$mn:0000805B                 mov     eax, [edx+4]
.text$mn:0000805E                 mov     [ecx+8], eax
.text$mn:00008061                 mov     esp, ebp
.text$mn:00008063                 pop     ebp
.text$mn:00008064                 retn
.text$mn:00008064 ?clear@?$vector@EV?$allocator@E@std@@@std@@QAEXXZ endp
.text$mn:00008064
.text$mn:00008064 ; ---------------------------------------------------------------------------
.text$mn:00008065                 align 4
.text$mn:00008065 _text$mn        ends
.text$mn:00008065
.text$mn:00008068 ; ===========================================================================
.text$mn:00008068
.text$mn:00008068 ; Segment type: Pure code
.text$mn:00008068 ; Segment permissions: Read/Execute
.text$mn:00008068 _text$mn        segment para public 'CODE' use32
.text$mn:00008068                 assume cs:_text$mn
.text$mn:00008068                 ;org 8068h
.text$mn:00008068 ; COMDAT (pick any)
.text$mn:00008068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008068
.text$mn:00008068 ; =============== S U B R O U T I N E =======================================
.text$mn:00008068
.text$mn:00008068 ; Attributes: bp-based frame
.text$mn:00008068
.text$mn:00008068 ; int __stdcall std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>::construct(void *, int)
.text$mn:00008068                 public ?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z
.text$mn:00008068 ?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z proc near
.text$mn:00008068                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::construct<std::vector<uchar,std::allocator<uchar>>,std::vector<uchar,std::allocator<uchar>> const &>(std::allocator<std::vector<uchar,std::allocator<uchar>>> &,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+17p
.text$mn:00008068
.text$mn:00008068 var_1C          = dword ptr -1Ch
.text$mn:00008068 var_18          = dword ptr -18h
.text$mn:00008068 var_14          = dword ptr -14h
.text$mn:00008068 var_10          = dword ptr -10h
.text$mn:00008068 var_C           = dword ptr -0Ch
.text$mn:00008068 var_4           = dword ptr -4
.text$mn:00008068 arg_0           = dword ptr  8
.text$mn:00008068 arg_4           = dword ptr  0Ch
.text$mn:00008068
.text$mn:00008068                 push    ebp
.text$mn:00008069                 mov     ebp, esp
.text$mn:0000806B                 push    0FFFFFFFFh
.text$mn:0000806D                 push    offset __ehhandler$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z
.text$mn:00008072                 mov     eax, large fs:0
.text$mn:00008078                 push    eax
.text$mn:00008079                 sub     esp, 10h
.text$mn:0000807C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008081                 xor     eax, ebp
.text$mn:00008083                 push    eax
.text$mn:00008084                 lea     eax, [ebp+var_C]
.text$mn:00008087                 mov     large fs:0, eax
.text$mn:0000808D                 mov     [ebp+var_18], ecx
.text$mn:00008090                 mov     eax, [ebp+arg_0]
.text$mn:00008093                 push    eax             ; void *
.text$mn:00008094                 push    10h             ; unsigned int
.text$mn:00008096                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000809B                 add     esp, 8
.text$mn:0000809E                 mov     [ebp+var_10], eax
.text$mn:000080A1                 mov     [ebp+var_4], 0
.text$mn:000080A8                 cmp     [ebp+var_10], 0
.text$mn:000080AC                 jz      short loc_80BF
.text$mn:000080AE                 mov     ecx, [ebp+arg_4]
.text$mn:000080B1                 push    ecx
.text$mn:000080B2                 mov     ecx, [ebp+var_10]
.text$mn:000080B5                 call    ??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z ; std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:000080BA                 mov     [ebp+var_14], eax
.text$mn:000080BD                 jmp     short loc_80C6
.text$mn:000080BF ; ---------------------------------------------------------------------------
.text$mn:000080BF
.text$mn:000080BF loc_80BF:                               ; CODE XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+44j
.text$mn:000080BF                 mov     [ebp+var_14], 0
.text$mn:000080C6
.text$mn:000080C6 loc_80C6:                               ; CODE XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+55j
.text$mn:000080C6                 mov     edx, [ebp+var_14]
.text$mn:000080C9                 mov     [ebp+var_1C], edx
.text$mn:000080CC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000080D3                 mov     ecx, [ebp+var_C]
.text$mn:000080D6                 mov     large fs:0, ecx
.text$mn:000080DD                 pop     ecx
.text$mn:000080DE                 mov     esp, ebp
.text$mn:000080E0                 pop     ebp
.text$mn:000080E1                 retn    8
.text$mn:000080E1 ?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z endp
.text$mn:000080E1
.text$mn:000080E1 _text$mn        ends
.text$mn:000080E1
.text$x:000080E4 ; ===========================================================================
.text$x:000080E4
.text$x:000080E4 ; Segment type: Pure code
.text$x:000080E4 ; Segment permissions: Read/Execute
.text$x:000080E4 _text$x         segment para public 'CODE' use32
.text$x:000080E4                 assume cs:_text$x
.text$x:000080E4                 ;org 80E4h
.text$x:000080E4 ; COMDAT (pick associative to section at 8068)
.text$x:000080E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000080E4
.text$x:000080E4 ; =============== S U B R O U T I N E =======================================
.text$x:000080E4
.text$x:000080E4
.text$x:000080E4 __unwindfunclet$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z$0 proc near
.text$x:000080E4                                         ; DATA XREF: .xdata$x:00009488o
.text$x:000080E4                 mov     eax, [ebp+8]
.text$x:000080E7                 push    eax
.text$x:000080E8                 mov     eax, [ebp-10h]
.text$x:000080EB                 push    eax             ; void *
.text$x:000080EC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000080F1                 add     esp, 8
.text$x:000080F4                 retn
.text$x:000080F4 __unwindfunclet$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z$0 endp
.text$x:000080F4
.text$x:000080F5
.text$x:000080F5 ; =============== S U B R O U T I N E =======================================
.text$x:000080F5
.text$x:000080F5
.text$x:000080F5 __ehhandler$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z proc near
.text$x:000080F5                                         ; DATA XREF: std::allocator<std::vector<uchar,std::allocator<uchar>>>::construct(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> const &)+5o
.text$x:000080F5
.text$x:000080F5 arg_4           = dword ptr  8
.text$x:000080F5
.text$x:000080F5                 mov     edx, [esp+arg_4]
.text$x:000080F9                 lea     eax, [edx+0Ch]
.text$x:000080FC                 mov     ecx, [edx-14h]
.text$x:000080FF                 xor     ecx, eax
.text$x:00008101                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008106                 mov     eax, offset __ehfuncinfo$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z
.text$x:0000810B                 jmp     ___CxxFrameHandler3
.text$x:0000810B __ehhandler$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z endp
.text$x:0000810B
.text$x:0000810B _text$x         ends
.text$x:0000810B
.text$mn:00008110 ; ===========================================================================
.text$mn:00008110
.text$mn:00008110 ; Segment type: Pure code
.text$mn:00008110 ; Segment permissions: Read/Execute
.text$mn:00008110 _text$mn        segment para public 'CODE' use32
.text$mn:00008110                 assume cs:_text$mn
.text$mn:00008110                 ;org 8110h
.text$mn:00008110 ; COMDAT (pick any)
.text$mn:00008110                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008110
.text$mn:00008110 ; =============== S U B R O U T I N E =======================================
.text$mn:00008110
.text$mn:00008110 ; Attributes: bp-based frame
.text$mn:00008110
.text$mn:00008110 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00008110                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00008110 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00008110                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00008110
.text$mn:00008110 var_4           = dword ptr -4
.text$mn:00008110 Dst             = dword ptr  8
.text$mn:00008110 Src             = dword ptr  0Ch
.text$mn:00008110 Size            = dword ptr  10h
.text$mn:00008110
.text$mn:00008110                 push    ebp
.text$mn:00008111                 mov     ebp, esp
.text$mn:00008113                 push    ecx
.text$mn:00008114                 cmp     [ebp+Size], 0
.text$mn:00008118                 jnz     short loc_8122
.text$mn:0000811A                 mov     eax, [ebp+Dst]
.text$mn:0000811D                 mov     [ebp+var_4], eax
.text$mn:00008120                 jmp     short loc_8139
.text$mn:00008122 ; ---------------------------------------------------------------------------
.text$mn:00008122
.text$mn:00008122 loc_8122:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00008122                 mov     ecx, [ebp+Size]
.text$mn:00008125                 push    ecx             ; Size
.text$mn:00008126                 mov     edx, [ebp+Src]
.text$mn:00008129                 push    edx             ; Src
.text$mn:0000812A                 mov     eax, [ebp+Dst]
.text$mn:0000812D                 push    eax             ; Dst
.text$mn:0000812E                 call    _memcpy
.text$mn:00008133                 add     esp, 0Ch
.text$mn:00008136                 mov     [ebp+var_4], eax
.text$mn:00008139
.text$mn:00008139 loc_8139:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00008139                 mov     eax, [ebp+var_4]
.text$mn:0000813C                 mov     esp, ebp
.text$mn:0000813E                 pop     ebp
.text$mn:0000813F                 retn
.text$mn:0000813F ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:0000813F
.text$mn:0000813F _text$mn        ends
.text$mn:0000813F
.text$mn:00008140 ; ===========================================================================
.text$mn:00008140
.text$mn:00008140 ; Segment type: Pure code
.text$mn:00008140 ; Segment permissions: Read/Execute
.text$mn:00008140 _text$mn        segment para public 'CODE' use32
.text$mn:00008140                 assume cs:_text$mn
.text$mn:00008140                 ;org 8140h
.text$mn:00008140 ; COMDAT (pick any)
.text$mn:00008140                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008140
.text$mn:00008140 ; =============== S U B R O U T I N E =======================================
.text$mn:00008140
.text$mn:00008140 ; Attributes: bp-based frame
.text$mn:00008140
.text$mn:00008140 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00008140                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00008140 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00008140                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00008140
.text$mn:00008140 var_4           = dword ptr -4
.text$mn:00008140 arg_0           = dword ptr  8
.text$mn:00008140 arg_4           = dword ptr  0Ch
.text$mn:00008140
.text$mn:00008140                 push    ebp
.text$mn:00008141                 mov     ebp, esp
.text$mn:00008143                 push    ecx
.text$mn:00008144                 mov     [ebp+var_4], ecx
.text$mn:00008147                 mov     eax, [ebp+arg_4]
.text$mn:0000814A                 push    eax             ; int
.text$mn:0000814B                 mov     ecx, [ebp+arg_0]
.text$mn:0000814E                 push    ecx             ; void *
.text$mn:0000814F                 mov     ecx, [ebp+var_4]
.text$mn:00008152                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00008157                 mov     esp, ebp
.text$mn:00008159                 pop     ebp
.text$mn:0000815A                 retn    8
.text$mn:0000815A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:0000815A
.text$mn:0000815A ; ---------------------------------------------------------------------------
.text$mn:0000815D                 align 10h
.text$mn:0000815D _text$mn        ends
.text$mn:0000815D
.text$mn:00008160 ; ===========================================================================
.text$mn:00008160
.text$mn:00008160 ; Segment type: Pure code
.text$mn:00008160 ; Segment permissions: Read/Execute
.text$mn:00008160 _text$mn        segment para public 'CODE' use32
.text$mn:00008160                 assume cs:_text$mn
.text$mn:00008160                 ;org 8160h
.text$mn:00008160 ; COMDAT (pick any)
.text$mn:00008160                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008160
.text$mn:00008160 ; =============== S U B R O U T I N E =======================================
.text$mn:00008160
.text$mn:00008160 ; Attributes: bp-based frame
.text$mn:00008160
.text$mn:00008160 ; int __stdcall std::_Wrap_alloc<std::allocator<unsigned char>>::deallocate(void *, int)
.text$mn:00008160                 public ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z
.text$mn:00008160 ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z proc near
.text$mn:00008160                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+1B2p
.text$mn:00008160                                         ; __catch$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z$0+16p ...
.text$mn:00008160
.text$mn:00008160 var_4           = dword ptr -4
.text$mn:00008160 arg_0           = dword ptr  8
.text$mn:00008160 arg_4           = dword ptr  0Ch
.text$mn:00008160
.text$mn:00008160                 push    ebp
.text$mn:00008161                 mov     ebp, esp
.text$mn:00008163                 push    ecx
.text$mn:00008164                 mov     [ebp+var_4], ecx
.text$mn:00008167                 mov     eax, [ebp+arg_4]
.text$mn:0000816A                 push    eax             ; int
.text$mn:0000816B                 mov     ecx, [ebp+arg_0]
.text$mn:0000816E                 push    ecx             ; void *
.text$mn:0000816F                 mov     ecx, [ebp+var_4]
.text$mn:00008172                 call    ?deallocate@?$allocator@E@std@@QAEXPAEI@Z ; std::allocator<uchar>::deallocate(uchar *,uint)
.text$mn:00008177                 mov     esp, ebp
.text$mn:00008179                 pop     ebp
.text$mn:0000817A                 retn    8
.text$mn:0000817A ?deallocate@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAEI@Z endp
.text$mn:0000817A
.text$mn:0000817A ; ---------------------------------------------------------------------------
.text$mn:0000817D                 align 10h
.text$mn:0000817D _text$mn        ends
.text$mn:0000817D
.text$mn:00008180 ; ===========================================================================
.text$mn:00008180
.text$mn:00008180 ; Segment type: Pure code
.text$mn:00008180 ; Segment permissions: Read/Execute
.text$mn:00008180 _text$mn        segment para public 'CODE' use32
.text$mn:00008180                 assume cs:_text$mn
.text$mn:00008180                 ;org 8180h
.text$mn:00008180 ; COMDAT (pick any)
.text$mn:00008180                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008180
.text$mn:00008180 ; =============== S U B R O U T I N E =======================================
.text$mn:00008180
.text$mn:00008180 ; Attributes: bp-based frame
.text$mn:00008180
.text$mn:00008180 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:00008180                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00008180 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00008180                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Free_proxy(void)+32p
.text$mn:00008180
.text$mn:00008180 var_4           = dword ptr -4
.text$mn:00008180 arg_0           = dword ptr  8
.text$mn:00008180 arg_4           = dword ptr  0Ch
.text$mn:00008180
.text$mn:00008180                 push    ebp
.text$mn:00008181                 mov     ebp, esp
.text$mn:00008183                 push    ecx
.text$mn:00008184                 mov     [ebp+var_4], ecx
.text$mn:00008187                 mov     eax, [ebp+arg_4]
.text$mn:0000818A                 push    eax             ; int
.text$mn:0000818B                 mov     ecx, [ebp+arg_0]
.text$mn:0000818E                 push    ecx             ; void *
.text$mn:0000818F                 mov     ecx, [ebp+var_4]
.text$mn:00008192                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00008197                 mov     esp, ebp
.text$mn:00008199                 pop     ebp
.text$mn:0000819A                 retn    8
.text$mn:0000819A ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000819A
.text$mn:0000819A ; ---------------------------------------------------------------------------
.text$mn:0000819D                 align 10h
.text$mn:0000819D _text$mn        ends
.text$mn:0000819D
.text$mn:000081A0 ; ===========================================================================
.text$mn:000081A0
.text$mn:000081A0 ; Segment type: Pure code
.text$mn:000081A0 ; Segment permissions: Read/Execute
.text$mn:000081A0 _text$mn        segment para public 'CODE' use32
.text$mn:000081A0                 assume cs:_text$mn
.text$mn:000081A0                 ;org 81A0h
.text$mn:000081A0 ; COMDAT (pick any)
.text$mn:000081A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081A0
.text$mn:000081A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000081A0
.text$mn:000081A0 ; Attributes: bp-based frame
.text$mn:000081A0
.text$mn:000081A0 ; int __stdcall std::_Wrap_alloc<std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>>::deallocate(void *, int)
.text$mn:000081A0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z
.text$mn:000081A0 ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z proc near
.text$mn:000081A0                                         ; CODE XREF: __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0+5Cp
.text$mn:000081A0                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+24Ep
.text$mn:000081A0
.text$mn:000081A0 var_4           = dword ptr -4
.text$mn:000081A0 arg_0           = dword ptr  8
.text$mn:000081A0 arg_4           = dword ptr  0Ch
.text$mn:000081A0
.text$mn:000081A0                 push    ebp
.text$mn:000081A1                 mov     ebp, esp
.text$mn:000081A3                 push    ecx
.text$mn:000081A4                 mov     [ebp+var_4], ecx
.text$mn:000081A7                 mov     eax, [ebp+arg_4]
.text$mn:000081AA                 push    eax             ; int
.text$mn:000081AB                 mov     ecx, [ebp+arg_0]
.text$mn:000081AE                 push    ecx             ; void *
.text$mn:000081AF                 mov     ecx, [ebp+var_4]
.text$mn:000081B2                 call    ?deallocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::deallocate(std::vector<uchar,std::allocator<uchar>> *,uint)
.text$mn:000081B7                 mov     esp, ebp
.text$mn:000081B9                 pop     ebp
.text$mn:000081BA                 retn    8
.text$mn:000081BA ?deallocate@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z endp
.text$mn:000081BA
.text$mn:000081BA ; ---------------------------------------------------------------------------
.text$mn:000081BD                 align 10h
.text$mn:000081BD _text$mn        ends
.text$mn:000081BD
.text$mn:000081C0 ; ===========================================================================
.text$mn:000081C0
.text$mn:000081C0 ; Segment type: Pure code
.text$mn:000081C0 ; Segment permissions: Read/Execute
.text$mn:000081C0 _text$mn        segment para public 'CODE' use32
.text$mn:000081C0                 assume cs:_text$mn
.text$mn:000081C0                 ;org 81C0h
.text$mn:000081C0 ; COMDAT (pick any)
.text$mn:000081C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081C0
.text$mn:000081C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000081C0
.text$mn:000081C0 ; Attributes: bp-based frame
.text$mn:000081C0
.text$mn:000081C0 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000081C0                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000081C0 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000081C0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000081C0
.text$mn:000081C0 var_4           = dword ptr -4
.text$mn:000081C0 arg_0           = dword ptr  8
.text$mn:000081C0
.text$mn:000081C0                 push    ebp
.text$mn:000081C1                 mov     ebp, esp
.text$mn:000081C3                 push    ecx
.text$mn:000081C4                 mov     [ebp+var_4], ecx
.text$mn:000081C7                 mov     eax, [ebp+arg_0]
.text$mn:000081CA                 push    eax             ; void *
.text$mn:000081CB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000081D0                 add     esp, 4
.text$mn:000081D3                 mov     esp, ebp
.text$mn:000081D5                 pop     ebp
.text$mn:000081D6                 retn    8
.text$mn:000081D6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000081D6
.text$mn:000081D6 ; ---------------------------------------------------------------------------
.text$mn:000081D9                 align 4
.text$mn:000081D9 _text$mn        ends
.text$mn:000081D9
.text$mn:000081DC ; ===========================================================================
.text$mn:000081DC
.text$mn:000081DC ; Segment type: Pure code
.text$mn:000081DC ; Segment permissions: Read/Execute
.text$mn:000081DC _text$mn        segment para public 'CODE' use32
.text$mn:000081DC                 assume cs:_text$mn
.text$mn:000081DC                 ;org 81DCh
.text$mn:000081DC ; COMDAT (pick any)
.text$mn:000081DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081DC
.text$mn:000081DC ; =============== S U B R O U T I N E =======================================
.text$mn:000081DC
.text$mn:000081DC ; Attributes: bp-based frame
.text$mn:000081DC
.text$mn:000081DC ; int __stdcall std::allocator<unsigned char>::deallocate(void *, int)
.text$mn:000081DC                 public ?deallocate@?$allocator@E@std@@QAEXPAEI@Z
.text$mn:000081DC ?deallocate@?$allocator@E@std@@QAEXPAEI@Z proc near
.text$mn:000081DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::deallocate(uchar *,uint)+12p
.text$mn:000081DC
.text$mn:000081DC var_4           = dword ptr -4
.text$mn:000081DC arg_0           = dword ptr  8
.text$mn:000081DC
.text$mn:000081DC                 push    ebp
.text$mn:000081DD                 mov     ebp, esp
.text$mn:000081DF                 push    ecx
.text$mn:000081E0                 mov     [ebp+var_4], ecx
.text$mn:000081E3                 mov     eax, [ebp+arg_0]
.text$mn:000081E6                 push    eax             ; void *
.text$mn:000081E7                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000081EC                 add     esp, 4
.text$mn:000081EF                 mov     esp, ebp
.text$mn:000081F1                 pop     ebp
.text$mn:000081F2                 retn    8
.text$mn:000081F2 ?deallocate@?$allocator@E@std@@QAEXPAEI@Z endp
.text$mn:000081F2
.text$mn:000081F2 ; ---------------------------------------------------------------------------
.text$mn:000081F5                 align 4
.text$mn:000081F5 _text$mn        ends
.text$mn:000081F5
.text$mn:000081F8 ; ===========================================================================
.text$mn:000081F8
.text$mn:000081F8 ; Segment type: Pure code
.text$mn:000081F8 ; Segment permissions: Read/Execute
.text$mn:000081F8 _text$mn        segment para public 'CODE' use32
.text$mn:000081F8                 assume cs:_text$mn
.text$mn:000081F8                 ;org 81F8h
.text$mn:000081F8 ; COMDAT (pick any)
.text$mn:000081F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000081F8
.text$mn:000081F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000081F8
.text$mn:000081F8 ; Attributes: bp-based frame
.text$mn:000081F8
.text$mn:000081F8 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000081F8                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000081F8 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000081F8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000081F8                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)+12p
.text$mn:000081F8
.text$mn:000081F8 var_4           = dword ptr -4
.text$mn:000081F8 arg_0           = dword ptr  8
.text$mn:000081F8
.text$mn:000081F8                 push    ebp
.text$mn:000081F9                 mov     ebp, esp
.text$mn:000081FB                 push    ecx
.text$mn:000081FC                 mov     [ebp+var_4], ecx
.text$mn:000081FF                 mov     eax, [ebp+arg_0]
.text$mn:00008202                 push    eax             ; void *
.text$mn:00008203                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008208                 add     esp, 4
.text$mn:0000820B                 mov     esp, ebp
.text$mn:0000820D                 pop     ebp
.text$mn:0000820E                 retn    8
.text$mn:0000820E ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000820E
.text$mn:0000820E ; ---------------------------------------------------------------------------
.text$mn:00008211                 align 4
.text$mn:00008211 _text$mn        ends
.text$mn:00008211
.text$mn:00008214 ; ===========================================================================
.text$mn:00008214
.text$mn:00008214 ; Segment type: Pure code
.text$mn:00008214 ; Segment permissions: Read/Execute
.text$mn:00008214 _text$mn        segment para public 'CODE' use32
.text$mn:00008214                 assume cs:_text$mn
.text$mn:00008214                 ;org 8214h
.text$mn:00008214 ; COMDAT (pick any)
.text$mn:00008214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008214
.text$mn:00008214 ; =============== S U B R O U T I N E =======================================
.text$mn:00008214
.text$mn:00008214 ; Attributes: bp-based frame
.text$mn:00008214
.text$mn:00008214 ; int __stdcall std::allocator<std::vector<unsigned char,std::allocator<unsigned char>>>::deallocate(void *, int)
.text$mn:00008214                 public ?deallocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z
.text$mn:00008214 ?deallocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z proc near
.text$mn:00008214                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::deallocate(std::vector<uchar,std::allocator<uchar>> *,uint)+12p
.text$mn:00008214
.text$mn:00008214 var_4           = dword ptr -4
.text$mn:00008214 arg_0           = dword ptr  8
.text$mn:00008214
.text$mn:00008214                 push    ebp
.text$mn:00008215                 mov     ebp, esp
.text$mn:00008217                 push    ecx
.text$mn:00008218                 mov     [ebp+var_4], ecx
.text$mn:0000821B                 mov     eax, [ebp+arg_0]
.text$mn:0000821E                 push    eax             ; void *
.text$mn:0000821F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00008224                 add     esp, 4
.text$mn:00008227                 mov     esp, ebp
.text$mn:00008229                 pop     ebp
.text$mn:0000822A                 retn    8
.text$mn:0000822A ?deallocate@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@I@Z endp
.text$mn:0000822A
.text$mn:0000822A ; ---------------------------------------------------------------------------
.text$mn:0000822D                 align 10h
.text$mn:0000822D _text$mn        ends
.text$mn:0000822D
.text$mn:00008230 ; ===========================================================================
.text$mn:00008230
.text$mn:00008230 ; Segment type: Pure code
.text$mn:00008230 ; Segment permissions: Read/Execute
.text$mn:00008230 _text$mn        segment para public 'CODE' use32
.text$mn:00008230                 assume cs:_text$mn
.text$mn:00008230                 ;org 8230h
.text$mn:00008230 ; COMDAT (pick any)
.text$mn:00008230                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008230
.text$mn:00008230 ; =============== S U B R O U T I N E =======================================
.text$mn:00008230
.text$mn:00008230 ; Attributes: bp-based frame
.text$mn:00008230
.text$mn:00008230 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00008230                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00008230 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00008230                                         ; DATA XREF: .rdata:0000A570o
.text$mn:00008230
.text$mn:00008230 var_4           = dword ptr -4
.text$mn:00008230 arg_0           = dword ptr  8
.text$mn:00008230 arg_4           = dword ptr  0Ch
.text$mn:00008230
.text$mn:00008230                 push    ebp
.text$mn:00008231                 mov     ebp, esp
.text$mn:00008233                 push    ecx
.text$mn:00008234                 mov     [ebp+var_4], ecx
.text$mn:00008237                 mov     eax, [ebp+arg_4]
.text$mn:0000823A                 push    eax             ; int
.text$mn:0000823B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00008240                 add     esp, 4
.text$mn:00008243                 test    eax, eax
.text$mn:00008245                 jz      short loc_8260
.text$mn:00008247                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000824C                 push    eax             ; struct std::error_category *
.text$mn:0000824D                 mov     ecx, [ebp+arg_4]
.text$mn:00008250                 push    ecx             ; int
.text$mn:00008251                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008254                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00008259                 mov     eax, [ebp+arg_0]
.text$mn:0000825C                 jmp     short loc_8275
.text$mn:0000825E ; ---------------------------------------------------------------------------
.text$mn:0000825E                 jmp     short loc_8275
.text$mn:00008260 ; ---------------------------------------------------------------------------
.text$mn:00008260
.text$mn:00008260 loc_8260:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00008260                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00008265                 push    eax             ; struct std::error_category *
.text$mn:00008266                 mov     edx, [ebp+arg_4]
.text$mn:00008269                 push    edx             ; int
.text$mn:0000826A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000826D                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00008272                 mov     eax, [ebp+arg_0]
.text$mn:00008275
.text$mn:00008275 loc_8275:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00008275                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00008275                 mov     esp, ebp
.text$mn:00008277                 pop     ebp
.text$mn:00008278                 retn    8
.text$mn:00008278 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00008278
.text$mn:00008278 ; ---------------------------------------------------------------------------
.text$mn:0000827B                 align 4
.text$mn:0000827B _text$mn        ends
.text$mn:0000827B
.text$mn:0000827C ; ===========================================================================
.text$mn:0000827C
.text$mn:0000827C ; Segment type: Pure code
.text$mn:0000827C ; Segment permissions: Read/Execute
.text$mn:0000827C _text$mn        segment para public 'CODE' use32
.text$mn:0000827C                 assume cs:_text$mn
.text$mn:0000827C                 ;org 827Ch
.text$mn:0000827C ; COMDAT (pick any)
.text$mn:0000827C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000827C
.text$mn:0000827C ; =============== S U B R O U T I N E =======================================
.text$mn:0000827C
.text$mn:0000827C ; Attributes: bp-based frame
.text$mn:0000827C
.text$mn:0000827C ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:0000827C                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:0000827C ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:0000827C                                         ; DATA XREF: .rdata:0000A4E0o
.text$mn:0000827C                                         ; .rdata:0000A4FCo ...
.text$mn:0000827C
.text$mn:0000827C var_4           = dword ptr -4
.text$mn:0000827C arg_0           = dword ptr  8
.text$mn:0000827C arg_4           = dword ptr  0Ch
.text$mn:0000827C
.text$mn:0000827C                 push    ebp
.text$mn:0000827D                 mov     ebp, esp
.text$mn:0000827F                 push    ecx
.text$mn:00008280                 mov     [ebp+var_4], ecx
.text$mn:00008283                 mov     eax, [ebp+var_4]
.text$mn:00008286                 push    eax             ; struct std::error_category *
.text$mn:00008287                 mov     ecx, [ebp+arg_4]
.text$mn:0000828A                 push    ecx             ; int
.text$mn:0000828B                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000828E                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00008293                 mov     eax, [ebp+arg_0]
.text$mn:00008296                 mov     esp, ebp
.text$mn:00008298                 pop     ebp
.text$mn:00008299                 retn    8
.text$mn:00008299 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00008299
.text$mn:00008299 _text$mn        ends
.text$mn:00008299
.text$mn:0000829C ; ===========================================================================
.text$mn:0000829C
.text$mn:0000829C ; Segment type: Pure code
.text$mn:0000829C ; Segment permissions: Read/Execute
.text$mn:0000829C _text$mn        segment para public 'CODE' use32
.text$mn:0000829C                 assume cs:_text$mn
.text$mn:0000829C                 ;org 829Ch
.text$mn:0000829C ; COMDAT (pick any)
.text$mn:0000829C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000829C
.text$mn:0000829C ; =============== S U B R O U T I N E =======================================
.text$mn:0000829C
.text$mn:0000829C ; Attributes: bp-based frame
.text$mn:0000829C
.text$mn:0000829C ; public: bool __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::empty(void)const
.text$mn:0000829C                 public ?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ
.text$mn:0000829C ?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ proc near
.text$mn:0000829C                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator=(std::vector<uchar,std::allocator<uchar>> const &)+90p
.text$mn:0000829C
.text$mn:0000829C var_8           = dword ptr -8
.text$mn:0000829C var_4           = dword ptr -4
.text$mn:0000829C
.text$mn:0000829C                 push    ebp
.text$mn:0000829D                 mov     ebp, esp
.text$mn:0000829F                 sub     esp, 8
.text$mn:000082A2                 mov     [ebp+var_4], ecx
.text$mn:000082A5                 mov     eax, [ebp+var_4]
.text$mn:000082A8                 mov     ecx, [ebp+var_4]
.text$mn:000082AB                 mov     edx, [eax+4]
.text$mn:000082AE                 cmp     edx, [ecx+8]
.text$mn:000082B1                 jnz     short loc_82BC
.text$mn:000082B3                 mov     [ebp+var_8], 1
.text$mn:000082BA                 jmp     short loc_82C3
.text$mn:000082BC ; ---------------------------------------------------------------------------
.text$mn:000082BC
.text$mn:000082BC loc_82BC:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::empty(void)+15j
.text$mn:000082BC                 mov     [ebp+var_8], 0
.text$mn:000082C3
.text$mn:000082C3 loc_82C3:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::empty(void)+1Ej
.text$mn:000082C3                 mov     al, byte ptr [ebp+var_8]
.text$mn:000082C6                 mov     esp, ebp
.text$mn:000082C8                 pop     ebp
.text$mn:000082C9                 retn
.text$mn:000082C9 ?empty@?$vector@EV?$allocator@E@std@@@std@@QBE_NXZ endp
.text$mn:000082C9
.text$mn:000082C9 ; ---------------------------------------------------------------------------
.text$mn:000082CA                 align 4
.text$mn:000082CA _text$mn        ends
.text$mn:000082CA
.text$mn:000082CC ; ===========================================================================
.text$mn:000082CC
.text$mn:000082CC ; Segment type: Pure code
.text$mn:000082CC ; Segment permissions: Read/Execute
.text$mn:000082CC _text$mn        segment para public 'CODE' use32
.text$mn:000082CC                 assume cs:_text$mn
.text$mn:000082CC                 ;org 82CCh
.text$mn:000082CC ; COMDAT (pick any)
.text$mn:000082CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000082CC
.text$mn:000082CC ; =============== S U B R O U T I N E =======================================
.text$mn:000082CC
.text$mn:000082CC ; Attributes: bp-based frame
.text$mn:000082CC
.text$mn:000082CC ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>> __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::end(void)
.text$mn:000082CC                 public ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:000082CC ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$mn:000082CC                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+8Ap
.text$mn:000082CC
.text$mn:000082CC var_14          = dword ptr -14h
.text$mn:000082CC var_10          = dword ptr -10h
.text$mn:000082CC var_C           = dword ptr -0Ch
.text$mn:000082CC var_4           = dword ptr -4
.text$mn:000082CC arg_0           = dword ptr  8
.text$mn:000082CC
.text$mn:000082CC                 push    ebp
.text$mn:000082CD                 mov     ebp, esp
.text$mn:000082CF                 push    0FFFFFFFFh
.text$mn:000082D1                 push    offset __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:000082D6                 mov     eax, large fs:0
.text$mn:000082DC                 push    eax
.text$mn:000082DD                 sub     esp, 8
.text$mn:000082E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000082E5                 xor     eax, ebp
.text$mn:000082E7                 push    eax
.text$mn:000082E8                 lea     eax, [ebp+var_C]
.text$mn:000082EB                 mov     large fs:0, eax
.text$mn:000082F1                 mov     [ebp+var_10], ecx
.text$mn:000082F4                 mov     [ebp+var_14], 0
.text$mn:000082FB                 mov     eax, [ebp+var_10]
.text$mn:000082FE                 push    eax             ; struct std::_Container_base12 *
.text$mn:000082FF                 mov     ecx, [ebp+var_10]
.text$mn:00008302                 mov     edx, [ecx+8]
.text$mn:00008305                 push    edx             ; int
.text$mn:00008306                 mov     ecx, [ebp+arg_0]
.text$mn:00008309                 call    ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)
.text$mn:0000830E                 mov     [ebp+var_4], 0
.text$mn:00008315                 mov     eax, [ebp+var_14]
.text$mn:00008318                 or      eax, 1
.text$mn:0000831B                 mov     [ebp+var_14], eax
.text$mn:0000831E                 mov     eax, [ebp+arg_0]
.text$mn:00008321                 mov     ecx, [ebp+var_C]
.text$mn:00008324                 mov     large fs:0, ecx
.text$mn:0000832B                 pop     ecx
.text$mn:0000832C                 mov     esp, ebp
.text$mn:0000832E                 pop     ebp
.text$mn:0000832F                 retn    4
.text$mn:0000832F ?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$mn:0000832F
.text$mn:0000832F ; ---------------------------------------------------------------------------
.text$mn:00008332                 align 4
.text$mn:00008332 _text$mn        ends
.text$mn:00008332
.text$x:00008334 ; ===========================================================================
.text$x:00008334
.text$x:00008334 ; Segment type: Pure code
.text$x:00008334 ; Segment permissions: Read/Execute
.text$x:00008334 _text$x         segment para public 'CODE' use32
.text$x:00008334                 assume cs:_text$x
.text$x:00008334                 ;org 8334h
.text$x:00008334 ; COMDAT (pick associative to section at 82CC)
.text$x:00008334                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008334
.text$x:00008334 ; =============== S U B R O U T I N E =======================================
.text$x:00008334
.text$x:00008334
.text$x:00008334 __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 proc near
.text$x:00008334                                         ; DATA XREF: .xdata$x:00009904o
.text$x:00008334                 mov     eax, [ebp-14h]
.text$x:00008337                 and     eax, 1
.text$x:0000833A                 jz      $LN4_2
.text$x:00008340                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008344                 mov     ecx, [ebp+8]
.text$x:00008347                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:0000834C ; ---------------------------------------------------------------------------
.text$x:0000834C
.text$x:0000834C $LN4_2:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0+6j
.text$x:0000834C                 retn
.text$x:0000834C __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 endp
.text$x:0000834C
.text$x:0000834D
.text$x:0000834D ; =============== S U B R O U T I N E =======================================
.text$x:0000834D
.text$x:0000834D
.text$x:0000834D __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$x:0000834D                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::end(void)+5o
.text$x:0000834D
.text$x:0000834D arg_4           = dword ptr  8
.text$x:0000834D
.text$x:0000834D                 mov     edx, [esp+arg_4]
.text$x:00008351                 lea     eax, [edx+0Ch]
.text$x:00008354                 mov     ecx, [edx-0Ch]
.text$x:00008357                 xor     ecx, eax
.text$x:00008359                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000835E                 mov     eax, offset __ehfuncinfo$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$x:00008363                 jmp     ___CxxFrameHandler3
.text$x:00008363 __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$x:00008363
.text$x:00008363 _text$x         ends
.text$x:00008363
.text$mn:00008368 ; ===========================================================================
.text$mn:00008368
.text$mn:00008368 ; Segment type: Pure code
.text$mn:00008368 ; Segment permissions: Read/Execute
.text$mn:00008368 _text$mn        segment para public 'CODE' use32
.text$mn:00008368                 assume cs:_text$mn
.text$mn:00008368                 ;org 8368h
.text$mn:00008368 ; COMDAT (pick any)
.text$mn:00008368                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008368
.text$mn:00008368 ; =============== S U B R O U T I N E =======================================
.text$mn:00008368
.text$mn:00008368 ; Attributes: bp-based frame
.text$mn:00008368
.text$mn:00008368 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<unsigned char>>> __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::end(void)const
.text$mn:00008368                 public ?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00008368 ?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$mn:00008368                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+89p
.text$mn:00008368
.text$mn:00008368 var_14          = dword ptr -14h
.text$mn:00008368 var_10          = dword ptr -10h
.text$mn:00008368 var_C           = dword ptr -0Ch
.text$mn:00008368 var_4           = dword ptr -4
.text$mn:00008368 arg_0           = dword ptr  8
.text$mn:00008368
.text$mn:00008368                 push    ebp
.text$mn:00008369                 mov     ebp, esp
.text$mn:0000836B                 push    0FFFFFFFFh
.text$mn:0000836D                 push    offset __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$mn:00008372                 mov     eax, large fs:0
.text$mn:00008378                 push    eax
.text$mn:00008379                 sub     esp, 8
.text$mn:0000837C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008381                 xor     eax, ebp
.text$mn:00008383                 push    eax
.text$mn:00008384                 lea     eax, [ebp+var_C]
.text$mn:00008387                 mov     large fs:0, eax
.text$mn:0000838D                 mov     [ebp+var_10], ecx
.text$mn:00008390                 mov     [ebp+var_14], 0
.text$mn:00008397                 mov     eax, [ebp+var_10]
.text$mn:0000839A                 push    eax             ; struct std::_Container_base12 *
.text$mn:0000839B                 mov     ecx, [ebp+var_10]
.text$mn:0000839E                 mov     edx, [ecx+8]
.text$mn:000083A1                 push    edx             ; int
.text$mn:000083A2                 mov     ecx, [ebp+arg_0]
.text$mn:000083A5                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(uchar *,std::_Container_base12 const *)
.text$mn:000083AA                 mov     [ebp+var_4], 0
.text$mn:000083B1                 mov     eax, [ebp+var_14]
.text$mn:000083B4                 or      eax, 1
.text$mn:000083B7                 mov     [ebp+var_14], eax
.text$mn:000083BA                 mov     eax, [ebp+arg_0]
.text$mn:000083BD                 mov     ecx, [ebp+var_C]
.text$mn:000083C0                 mov     large fs:0, ecx
.text$mn:000083C7                 pop     ecx
.text$mn:000083C8                 mov     esp, ebp
.text$mn:000083CA                 pop     ebp
.text$mn:000083CB                 retn    4
.text$mn:000083CB ?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$mn:000083CB
.text$mn:000083CB ; ---------------------------------------------------------------------------
.text$mn:000083CE                 align 10h
.text$mn:000083CE _text$mn        ends
.text$mn:000083CE
.text$x:000083D0 ; ===========================================================================
.text$x:000083D0
.text$x:000083D0 ; Segment type: Pure code
.text$x:000083D0 ; Segment permissions: Read/Execute
.text$x:000083D0 _text$x         segment para public 'CODE' use32
.text$x:000083D0                 assume cs:_text$x
.text$x:000083D0                 ;org 83D0h
.text$x:000083D0 ; COMDAT (pick associative to section at 8368)
.text$x:000083D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000083D0
.text$x:000083D0 ; =============== S U B R O U T I N E =======================================
.text$x:000083D0
.text$x:000083D0
.text$x:000083D0 __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 proc near
.text$x:000083D0                                         ; DATA XREF: .xdata$x:00009930o
.text$x:000083D0                 mov     eax, [ebp-14h]
.text$x:000083D3                 and     eax, 1
.text$x:000083D6                 jz      $LN4_3
.text$x:000083DC                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:000083E0                 mov     ecx, [ebp+8]
.text$x:000083E3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>(void)
.text$x:000083E8 ; ---------------------------------------------------------------------------
.text$x:000083E8
.text$x:000083E8 $LN4_3:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0+6j
.text$x:000083E8                 retn
.text$x:000083E8 __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0 endp
.text$x:000083E8
.text$x:000083E9
.text$x:000083E9 ; =============== S U B R O U T I N E =======================================
.text$x:000083E9
.text$x:000083E9
.text$x:000083E9 __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ proc near
.text$x:000083E9                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::end(void)+5o
.text$x:000083E9
.text$x:000083E9 arg_4           = dword ptr  8
.text$x:000083E9
.text$x:000083E9                 mov     edx, [esp+arg_4]
.text$x:000083ED                 lea     eax, [edx+0Ch]
.text$x:000083F0                 mov     ecx, [edx-0Ch]
.text$x:000083F3                 xor     ecx, eax
.text$x:000083F5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000083FA                 mov     eax, offset __ehfuncinfo$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.text$x:000083FF                 jmp     ___CxxFrameHandler3
.text$x:000083FF __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ endp
.text$x:000083FF
.text$x:000083FF _text$x         ends
.text$x:000083FF
.text$mn:00008404 ; ===========================================================================
.text$mn:00008404
.text$mn:00008404 ; Segment type: Pure code
.text$mn:00008404 ; Segment permissions: Read/Execute
.text$mn:00008404 _text$mn        segment para public 'CODE' use32
.text$mn:00008404                 assume cs:_text$mn
.text$mn:00008404                 ;org 8404h
.text$mn:00008404 ; COMDAT (pick any)
.text$mn:00008404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008404
.text$mn:00008404 ; =============== S U B R O U T I N E =======================================
.text$mn:00008404
.text$mn:00008404 ; Attributes: bp-based frame
.text$mn:00008404
.text$mn:00008404 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00008404                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00008404 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00008404                                         ; DATA XREF: .rdata:0000A4E4o
.text$mn:00008404                                         ; .rdata:0000A500o ...
.text$mn:00008404
.text$mn:00008404 var_8           = dword ptr -8
.text$mn:00008404 var_4           = dword ptr -4
.text$mn:00008404 arg_0           = dword ptr  8
.text$mn:00008404 arg_4           = dword ptr  0Ch
.text$mn:00008404
.text$mn:00008404                 push    ebp
.text$mn:00008405                 mov     ebp, esp
.text$mn:00008407                 sub     esp, 8
.text$mn:0000840A                 mov     [ebp+var_8], ecx
.text$mn:0000840D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008410                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00008415                 push    eax
.text$mn:00008416                 mov     ecx, [ebp+var_8]
.text$mn:00008419                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000841E                 movzx   eax, al
.text$mn:00008421                 test    eax, eax
.text$mn:00008423                 jz      short loc_843B
.text$mn:00008425                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00008428                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:0000842D                 cmp     eax, [ebp+arg_4]
.text$mn:00008430                 jnz     short loc_843B
.text$mn:00008432                 mov     [ebp+var_4], 1
.text$mn:00008439                 jmp     short loc_8442
.text$mn:0000843B ; ---------------------------------------------------------------------------
.text$mn:0000843B
.text$mn:0000843B loc_843B:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000843B                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000843B                 mov     [ebp+var_4], 0
.text$mn:00008442
.text$mn:00008442 loc_8442:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:00008442                 mov     al, byte ptr [ebp+var_4]
.text$mn:00008445                 mov     esp, ebp
.text$mn:00008447                 pop     ebp
.text$mn:00008448                 retn    8
.text$mn:00008448 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00008448
.text$mn:00008448 ; ---------------------------------------------------------------------------
.text$mn:0000844B                 align 4
.text$mn:0000844B _text$mn        ends
.text$mn:0000844B
.text$mn:0000844C ; ===========================================================================
.text$mn:0000844C
.text$mn:0000844C ; Segment type: Pure code
.text$mn:0000844C ; Segment permissions: Read/Execute
.text$mn:0000844C _text$mn        segment para public 'CODE' use32
.text$mn:0000844C                 assume cs:_text$mn
.text$mn:0000844C                 ;org 844Ch
.text$mn:0000844C ; COMDAT (pick any)
.text$mn:0000844C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000844C
.text$mn:0000844C ; =============== S U B R O U T I N E =======================================
.text$mn:0000844C
.text$mn:0000844C ; Attributes: bp-based frame
.text$mn:0000844C
.text$mn:0000844C ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:0000844C                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:0000844C ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:0000844C                                         ; DATA XREF: .rdata:0000A4E8o
.text$mn:0000844C                                         ; .rdata:0000A504o ...
.text$mn:0000844C
.text$mn:0000844C var_C           = byte ptr -0Ch
.text$mn:0000844C var_4           = dword ptr -4
.text$mn:0000844C arg_0           = dword ptr  8
.text$mn:0000844C arg_4           = dword ptr  0Ch
.text$mn:0000844C
.text$mn:0000844C                 push    ebp
.text$mn:0000844D                 mov     ebp, esp
.text$mn:0000844F                 sub     esp, 0Ch
.text$mn:00008452                 mov     [ebp+var_4], ecx
.text$mn:00008455                 mov     eax, [ebp+arg_4]
.text$mn:00008458                 push    eax             ; std::error_condition *
.text$mn:00008459                 mov     ecx, [ebp+arg_0]
.text$mn:0000845C                 push    ecx
.text$mn:0000845D                 lea     edx, [ebp+var_C]
.text$mn:00008460                 push    edx
.text$mn:00008461                 mov     eax, [ebp+var_4]
.text$mn:00008464                 mov     edx, [eax]
.text$mn:00008466                 mov     ecx, [ebp+var_4]
.text$mn:00008469                 mov     eax, [edx+0Ch]
.text$mn:0000846C                 call    eax
.text$mn:0000846E                 mov     ecx, eax
.text$mn:00008470                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00008475                 mov     esp, ebp
.text$mn:00008477                 pop     ebp
.text$mn:00008478                 retn    8
.text$mn:00008478 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00008478
.text$mn:00008478 ; ---------------------------------------------------------------------------
.text$mn:0000847B                 align 4
.text$mn:0000847B _text$mn        ends
.text$mn:0000847B
.text$mn:0000847C ; ===========================================================================
.text$mn:0000847C
.text$mn:0000847C ; Segment type: Pure code
.text$mn:0000847C ; Segment permissions: Read/Execute
.text$mn:0000847C _text$mn        segment para public 'CODE' use32
.text$mn:0000847C                 assume cs:_text$mn
.text$mn:0000847C                 ;org 847Ch
.text$mn:0000847C ; COMDAT (pick any)
.text$mn:0000847C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000847C
.text$mn:0000847C ; =============== S U B R O U T I N E =======================================
.text$mn:0000847C
.text$mn:0000847C ; Attributes: bp-based frame
.text$mn:0000847C
.text$mn:0000847C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:0000847C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:0000847C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:0000847C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:0000847C
.text$mn:0000847C var_4           = dword ptr -4
.text$mn:0000847C arg_0           = dword ptr  8
.text$mn:0000847C
.text$mn:0000847C                 push    ebp
.text$mn:0000847D                 mov     ebp, esp
.text$mn:0000847F                 push    ecx
.text$mn:00008480                 mov     [ebp+var_4], ecx
.text$mn:00008483                 mov     eax, [ebp+var_4]
.text$mn:00008486                 mov     ecx, [eax+14h]
.text$mn:00008489                 cmp     ecx, [ebp+arg_0]
.text$mn:0000848C                 jnb     short loc_8496
.text$mn:0000848E                 mov     ecx, [ebp+var_4]
.text$mn:00008491                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00008496
.text$mn:00008496 loc_8496:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00008496                 mov     edx, [ebp+arg_0]
.text$mn:00008499                 push    edx
.text$mn:0000849A                 mov     ecx, [ebp+var_4]
.text$mn:0000849D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000084A2                 mov     eax, [ebp+var_4]
.text$mn:000084A5                 mov     esp, ebp
.text$mn:000084A7                 pop     ebp
.text$mn:000084A8                 retn    4
.text$mn:000084A8 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:000084A8
.text$mn:000084A8 ; ---------------------------------------------------------------------------
.text$mn:000084AB                 align 4
.text$mn:000084AB _text$mn        ends
.text$mn:000084AB
.text$mn:000084AC ; ===========================================================================
.text$mn:000084AC
.text$mn:000084AC ; Segment type: Pure code
.text$mn:000084AC ; Segment permissions: Read/Execute
.text$mn:000084AC _text$mn        segment para public 'CODE' use32
.text$mn:000084AC                 assume cs:_text$mn
.text$mn:000084AC                 ;org 84ACh
.text$mn:000084AC ; COMDAT (pick any)
.text$mn:000084AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000084AC
.text$mn:000084AC ; =============== S U B R O U T I N E =======================================
.text$mn:000084AC
.text$mn:000084AC ; Attributes: bp-based frame
.text$mn:000084AC
.text$mn:000084AC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:000084AC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:000084AC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:000084AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:000084AC
.text$mn:000084AC var_C           = dword ptr -0Ch
.text$mn:000084AC Dst             = dword ptr -8
.text$mn:000084AC var_4           = dword ptr -4
.text$mn:000084AC arg_0           = dword ptr  8
.text$mn:000084AC arg_4           = dword ptr  0Ch
.text$mn:000084AC
.text$mn:000084AC                 push    ebp
.text$mn:000084AD                 mov     ebp, esp
.text$mn:000084AF                 sub     esp, 0Ch
.text$mn:000084B2                 mov     [ebp+var_4], ecx
.text$mn:000084B5                 mov     eax, [ebp+var_4]
.text$mn:000084B8                 mov     ecx, [eax+14h]
.text$mn:000084BB                 cmp     ecx, [ebp+arg_0]
.text$mn:000084BE                 jnb     short loc_84C8
.text$mn:000084C0                 mov     ecx, [ebp+var_4]
.text$mn:000084C3                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000084C8
.text$mn:000084C8 loc_84C8:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000084C8                 mov     edx, [ebp+var_4]
.text$mn:000084CB                 mov     eax, [edx+14h]
.text$mn:000084CE                 sub     eax, [ebp+arg_0]
.text$mn:000084D1                 cmp     eax, [ebp+arg_4]
.text$mn:000084D4                 ja      short loc_84E4
.text$mn:000084D6                 mov     ecx, [ebp+arg_0]
.text$mn:000084D9                 push    ecx
.text$mn:000084DA                 mov     ecx, [ebp+var_4]
.text$mn:000084DD                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000084E2                 jmp     short loc_852A
.text$mn:000084E4 ; ---------------------------------------------------------------------------
.text$mn:000084E4
.text$mn:000084E4 loc_84E4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000084E4                 cmp     [ebp+arg_4], 0
.text$mn:000084E8                 jbe     short loc_852A
.text$mn:000084EA                 mov     ecx, [ebp+var_4]
.text$mn:000084ED                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000084F2                 add     eax, [ebp+arg_0]
.text$mn:000084F5                 mov     [ebp+Dst], eax
.text$mn:000084F8                 mov     edx, [ebp+var_4]
.text$mn:000084FB                 mov     eax, [edx+14h]
.text$mn:000084FE                 sub     eax, [ebp+arg_4]
.text$mn:00008501                 mov     [ebp+var_C], eax
.text$mn:00008504                 mov     ecx, [ebp+var_C]
.text$mn:00008507                 sub     ecx, [ebp+arg_0]
.text$mn:0000850A                 push    ecx             ; Size
.text$mn:0000850B                 mov     edx, [ebp+Dst]
.text$mn:0000850E                 add     edx, [ebp+arg_4]
.text$mn:00008511                 push    edx             ; Src
.text$mn:00008512                 mov     eax, [ebp+Dst]
.text$mn:00008515                 push    eax             ; Dst
.text$mn:00008516                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000851B                 add     esp, 0Ch
.text$mn:0000851E                 mov     ecx, [ebp+var_C]
.text$mn:00008521                 push    ecx
.text$mn:00008522                 mov     ecx, [ebp+var_4]
.text$mn:00008525                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000852A
.text$mn:0000852A loc_852A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:0000852A                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:0000852A                 mov     eax, [ebp+var_4]
.text$mn:0000852D                 mov     esp, ebp
.text$mn:0000852F                 pop     ebp
.text$mn:00008530                 retn    8
.text$mn:00008530 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00008530
.text$mn:00008530 ; ---------------------------------------------------------------------------
.text$mn:00008533                 align 4
.text$mn:00008533 _text$mn        ends
.text$mn:00008533
.text$mn:00008534 ; ===========================================================================
.text$mn:00008534
.text$mn:00008534 ; Segment type: Pure code
.text$mn:00008534 ; Segment permissions: Read/Execute
.text$mn:00008534 _text$mn        segment para public 'CODE' use32
.text$mn:00008534                 assume cs:_text$mn
.text$mn:00008534                 ;org 8534h
.text$mn:00008534 ; COMDAT (pick any)
.text$mn:00008534                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008534
.text$mn:00008534 ; =============== S U B R O U T I N E =======================================
.text$mn:00008534
.text$mn:00008534 ; Attributes: bp-based frame
.text$mn:00008534
.text$mn:00008534 ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::erase(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>)
.text$mn:00008534                 public ?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.text$mn:00008534 ?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z proc near
.text$mn:00008534                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+F7p
.text$mn:00008534
.text$mn:00008534 var_24          = dword ptr -24h
.text$mn:00008534 var_20          = dword ptr -20h
.text$mn:00008534 var_1C          = dword ptr -1Ch
.text$mn:00008534 var_18          = dword ptr -18h
.text$mn:00008534 var_14          = dword ptr -14h
.text$mn:00008534 var_10          = dword ptr -10h
.text$mn:00008534 var_C           = dword ptr -0Ch
.text$mn:00008534 var_4           = dword ptr -4
.text$mn:00008534 arg_0           = dword ptr  8
.text$mn:00008534 arg_4           = byte ptr  0Ch
.text$mn:00008534 arg_C           = dword ptr  14h
.text$mn:00008534
.text$mn:00008534                 push    ebp
.text$mn:00008535                 mov     ebp, esp
.text$mn:00008537                 push    0FFFFFFFFh
.text$mn:00008539                 push    offset __ehhandler$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.text$mn:0000853E                 mov     eax, large fs:0
.text$mn:00008544                 push    eax
.text$mn:00008545                 sub     esp, 18h
.text$mn:00008548                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000854D                 xor     eax, ebp
.text$mn:0000854F                 push    eax
.text$mn:00008550                 lea     eax, [ebp+var_C]
.text$mn:00008553                 mov     large fs:0, eax
.text$mn:00008559                 mov     [ebp+var_10], ecx
.text$mn:0000855C                 mov     [ebp+var_14], 0
.text$mn:00008563                 mov     [ebp+var_4], 1
.text$mn:0000856A                 lea     ecx, [ebp+arg_4] ; this
.text$mn:0000856D                 call    ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont(void)
.text$mn:00008572                 cmp     eax, [ebp+var_10]
.text$mn:00008575                 jnz     short loc_858D
.text$mn:00008577                 mov     eax, [ebp+var_10]
.text$mn:0000857A                 mov     ecx, [ebp+arg_C]
.text$mn:0000857D                 cmp     ecx, [eax+4]
.text$mn:00008580                 jb      short loc_858D
.text$mn:00008582                 mov     edx, [ebp+var_10]
.text$mn:00008585                 mov     eax, [edx+8]
.text$mn:00008588                 cmp     eax, [ebp+arg_C]
.text$mn:0000858B                 ja      short loc_85A4
.text$mn:0000858D
.text$mn:0000858D loc_858D:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+41j
.text$mn:0000858D                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+4Cj
.text$mn:0000858D                 push    5A2h            ; unsigned int
.text$mn:00008592                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00008597                 push    offset ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; "vector erase iterator outside range"
.text$mn:0000859C                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000085A1                 add     esp, 0Ch
.text$mn:000085A4
.text$mn:000085A4 loc_85A4:                               ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+57j
.text$mn:000085A4                 mov     ecx, [ebp+arg_C]
.text$mn:000085A7                 push    ecx
.text$mn:000085A8                 mov     edx, [ebp+var_10]
.text$mn:000085AB                 mov     eax, [edx+8]
.text$mn:000085AE                 push    eax
.text$mn:000085AF                 mov     ecx, [ebp+arg_C]
.text$mn:000085B2                 add     ecx, 10h
.text$mn:000085B5                 push    ecx
.text$mn:000085B6                 call    ??$_Move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00@Z ; std::_Move<std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000085BB                 add     esp, 0Ch
.text$mn:000085BE                 mov     edx, [ebp+var_10]
.text$mn:000085C1                 mov     eax, [edx+8]
.text$mn:000085C4                 push    eax
.text$mn:000085C5                 mov     ecx, [ebp+var_10]
.text$mn:000085C8                 mov     edx, [ecx+8]
.text$mn:000085CB                 sub     edx, 10h
.text$mn:000085CE                 push    edx
.text$mn:000085CF                 mov     ecx, [ebp+var_10]
.text$mn:000085D2                 call    ?_Destroy@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Destroy(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000085D7                 mov     eax, [ebp+var_10]
.text$mn:000085DA                 mov     ecx, [eax+8]
.text$mn:000085DD                 push    ecx
.text$mn:000085DE                 mov     edx, [ebp+arg_C]
.text$mn:000085E1                 push    edx
.text$mn:000085E2                 mov     ecx, [ebp+var_10]
.text$mn:000085E5                 call    ?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Orphan_range(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *)
.text$mn:000085EA                 mov     eax, [ebp+var_10]
.text$mn:000085ED                 mov     ecx, [eax+8]
.text$mn:000085F0                 sub     ecx, 10h
.text$mn:000085F3                 mov     edx, [ebp+var_10]
.text$mn:000085F6                 mov     [edx+8], ecx
.text$mn:000085F9                 sub     esp, 0Ch
.text$mn:000085FC                 mov     ecx, esp
.text$mn:000085FE                 mov     [ebp+var_1C], esp
.text$mn:00008601                 lea     eax, [ebp+arg_4]
.text$mn:00008604                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00008605                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)
.text$mn:0000860A                 mov     [ebp+var_18], eax
.text$mn:0000860D                 mov     ecx, [ebp+var_18]
.text$mn:00008610                 mov     [ebp+var_20], ecx
.text$mn:00008613                 mov     byte ptr [ebp+var_4], 2
.text$mn:00008617                 mov     edx, [ebp+arg_0]
.text$mn:0000861A                 push    edx
.text$mn:0000861B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000861F                 mov     ecx, [ebp+var_10]
.text$mn:00008622                 call    ?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Make_iter(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)
.text$mn:00008627                 mov     [ebp+var_24], eax
.text$mn:0000862A                 mov     eax, [ebp+var_14]
.text$mn:0000862D                 or      eax, 1
.text$mn:00008630                 mov     [ebp+var_14], eax
.text$mn:00008633                 mov     byte ptr [ebp+var_4], 0
.text$mn:00008637                 lea     ecx, [ebp+arg_4]
.text$mn:0000863A                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:0000863F                 mov     eax, [ebp+arg_0]
.text$mn:00008642                 mov     ecx, [ebp+var_C]
.text$mn:00008645                 mov     large fs:0, ecx
.text$mn:0000864C                 pop     ecx
.text$mn:0000864D                 mov     esp, ebp
.text$mn:0000864F                 pop     ebp
.text$mn:00008650                 retn    10h
.text$mn:00008650 ?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z endp
.text$mn:00008650
.text$mn:00008650 ; ---------------------------------------------------------------------------
.text$mn:00008653                 align 4
.text$mn:00008653 _text$mn        ends
.text$mn:00008653
.text$x:00008654 ; ===========================================================================
.text$x:00008654
.text$x:00008654 ; Segment type: Pure code
.text$x:00008654 ; Segment permissions: Read/Execute
.text$x:00008654 _text$x         segment para public 'CODE' use32
.text$x:00008654                 assume cs:_text$x
.text$x:00008654                 ;org 8654h
.text$x:00008654 ; COMDAT (pick associative to section at 8534)
.text$x:00008654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008654
.text$x:00008654 ; =============== S U B R O U T I N E =======================================
.text$x:00008654
.text$x:00008654
.text$x:00008654 __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$0 proc near
.text$x:00008654                                         ; DATA XREF: .xdata$x:00009558o
.text$x:00008654                 lea     ecx, [ebp+0Ch]
.text$x:00008657                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:00008657 __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$0 endp
.text$x:00008657
.text$x:0000865C
.text$x:0000865C ; =============== S U B R O U T I N E =======================================
.text$x:0000865C
.text$x:0000865C
.text$x:0000865C __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$1 proc near
.text$x:0000865C                                         ; DATA XREF: .xdata$x:00009560o
.text$x:0000865C                 mov     ecx, [ebp-1Ch]
.text$x:0000865F                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:0000865F __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$1 endp
.text$x:0000865F
.text$x:00008664
.text$x:00008664 ; =============== S U B R O U T I N E =======================================
.text$x:00008664
.text$x:00008664
.text$x:00008664 __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$2 proc near
.text$x:00008664                                         ; DATA XREF: .xdata$x:00009550o
.text$x:00008664                 mov     eax, [ebp-14h]
.text$x:00008667                 and     eax, 1
.text$x:0000866A                 jz      $LN8
.text$x:00008670                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00008674                 mov     ecx, [ebp+8]
.text$x:00008677                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:0000867C ; ---------------------------------------------------------------------------
.text$x:0000867C
.text$x:0000867C $LN8:                                   ; CODE XREF: __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$2+6j
.text$x:0000867C                 retn
.text$x:0000867C __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$2 endp
.text$x:0000867C
.text$x:0000867D
.text$x:0000867D ; =============== S U B R O U T I N E =======================================
.text$x:0000867D
.text$x:0000867D
.text$x:0000867D __ehhandler$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z proc near
.text$x:0000867D                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+5o
.text$x:0000867D
.text$x:0000867D arg_4           = dword ptr  8
.text$x:0000867D
.text$x:0000867D                 mov     edx, [esp+arg_4]
.text$x:00008681                 lea     eax, [edx+0Ch]
.text$x:00008684                 mov     ecx, [edx-1Ch]
.text$x:00008687                 xor     ecx, eax
.text$x:00008689                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000868E                 mov     eax, offset __ehfuncinfo$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.text$x:00008693                 jmp     ___CxxFrameHandler3
.text$x:00008693 __ehhandler$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z endp
.text$x:00008693
.text$x:00008693 _text$x         ends
.text$x:00008693
.text$mn:00008698 ; ===========================================================================
.text$mn:00008698
.text$mn:00008698 ; Segment type: Pure code
.text$mn:00008698 ; Segment permissions: Read/Execute
.text$mn:00008698 _text$mn        segment para public 'CODE' use32
.text$mn:00008698                 assume cs:_text$mn
.text$mn:00008698                 ;org 8698h
.text$mn:00008698 ; COMDAT (pick any)
.text$mn:00008698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008698
.text$mn:00008698 ; =============== S U B R O U T I N E =======================================
.text$mn:00008698
.text$mn:00008698 ; Attributes: bp-based frame
.text$mn:00008698
.text$mn:00008698 ; __int32 __thiscall ScintillaEditView::execute(ScintillaEditView *this, unsigned int, unsigned int, __int32)
.text$mn:00008698                 public ?execute@ScintillaEditView@@QBEJIIJ@Z
.text$mn:00008698 ?execute@ScintillaEditView@@QBEJIIJ@Z proc near
.text$mn:00008698                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+240p
.text$mn:00008698                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+338p ...
.text$mn:00008698
.text$mn:00008698 var_4           = dword ptr -4
.text$mn:00008698 arg_0           = dword ptr  8
.text$mn:00008698 arg_4           = dword ptr  0Ch
.text$mn:00008698 arg_8           = dword ptr  10h
.text$mn:00008698
.text$mn:00008698                 push    ebp
.text$mn:00008699                 mov     ebp, esp
.text$mn:0000869B                 push    ecx
.text$mn:0000869C                 mov     [ebp+var_4], ecx
.text$mn:0000869F                 mov     eax, [ebp+arg_8]
.text$mn:000086A2                 push    eax
.text$mn:000086A3                 mov     ecx, [ebp+arg_4]
.text$mn:000086A6                 push    ecx
.text$mn:000086A7                 mov     edx, [ebp+arg_0]
.text$mn:000086AA                 push    edx
.text$mn:000086AB                 mov     eax, [ebp+var_4]
.text$mn:000086AE                 mov     ecx, [eax+14h]
.text$mn:000086B1                 push    ecx
.text$mn:000086B2                 mov     edx, [ebp+var_4]
.text$mn:000086B5                 mov     eax, [edx+10h]
.text$mn:000086B8                 call    eax
.text$mn:000086BA                 add     esp, 10h
.text$mn:000086BD                 mov     esp, ebp
.text$mn:000086BF                 pop     ebp
.text$mn:000086C0                 retn    0Ch
.text$mn:000086C0 ?execute@ScintillaEditView@@QBEJIIJ@Z endp
.text$mn:000086C0
.text$mn:000086C0 ; ---------------------------------------------------------------------------
.text$mn:000086C3                 align 4
.text$mn:000086C3 _text$mn        ends
.text$mn:000086C3
.text$mn:000086C4 ; ===========================================================================
.text$mn:000086C4
.text$mn:000086C4 ; Segment type: Pure code
.text$mn:000086C4 ; Segment permissions: Read/Execute
.text$mn:000086C4 _text$mn        segment para public 'CODE' use32
.text$mn:000086C4                 assume cs:_text$mn
.text$mn:000086C4                 ;org 86C4h
.text$mn:000086C4 ; COMDAT (pick any)
.text$mn:000086C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086C4
.text$mn:000086C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086C4
.text$mn:000086C4 ; Attributes: bp-based frame
.text$mn:000086C4
.text$mn:000086C4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000086C4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000086C4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000086C4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000086C4                 push    ebp
.text$mn:000086C5                 mov     ebp, esp
.text$mn:000086C7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000086CC                 pop     ebp
.text$mn:000086CD                 retn
.text$mn:000086CD ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000086CD
.text$mn:000086CD ; ---------------------------------------------------------------------------
.text$mn:000086CE                 align 10h
.text$mn:000086CE _text$mn        ends
.text$mn:000086CE
.text$mn:000086D0 ; ===========================================================================
.text$mn:000086D0
.text$mn:000086D0 ; Segment type: Pure code
.text$mn:000086D0 ; Segment permissions: Read/Execute
.text$mn:000086D0 _text$mn        segment para public 'CODE' use32
.text$mn:000086D0                 assume cs:_text$mn
.text$mn:000086D0                 ;org 86D0h
.text$mn:000086D0 ; COMDAT (pick any)
.text$mn:000086D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086D0
.text$mn:000086D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000086D0
.text$mn:000086D0 ; Attributes: bp-based frame
.text$mn:000086D0
.text$mn:000086D0 ; struct Buffer *__thiscall ScintillaEditView::getCurrentBuffer(ScintillaEditView *__hidden this)
.text$mn:000086D0                 public ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ
.text$mn:000086D0 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ proc near
.text$mn:000086D0                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+21Ap
.text$mn:000086D0
.text$mn:000086D0 var_4           = dword ptr -4
.text$mn:000086D0
.text$mn:000086D0                 push    ebp
.text$mn:000086D1                 mov     ebp, esp
.text$mn:000086D3                 push    ecx
.text$mn:000086D4                 mov     [ebp+var_4], ecx
.text$mn:000086D7                 mov     eax, [ebp+var_4]
.text$mn:000086DA                 mov     eax, [eax+20h]
.text$mn:000086DD                 mov     esp, ebp
.text$mn:000086DF                 pop     ebp
.text$mn:000086E0                 retn
.text$mn:000086E0 ?getCurrentBuffer@ScintillaEditView@@QAEPAVBuffer@@XZ endp
.text$mn:000086E0
.text$mn:000086E0 ; ---------------------------------------------------------------------------
.text$mn:000086E1                 align 4
.text$mn:000086E1 _text$mn        ends
.text$mn:000086E1
.text$mn:000086E4 ; ===========================================================================
.text$mn:000086E4
.text$mn:000086E4 ; Segment type: Pure code
.text$mn:000086E4 ; Segment permissions: Read/Execute
.text$mn:000086E4 _text$mn        segment para public 'CODE' use32
.text$mn:000086E4                 assume cs:_text$mn
.text$mn:000086E4                 ;org 86E4h
.text$mn:000086E4 ; COMDAT (pick any)
.text$mn:000086E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086E4
.text$mn:000086E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000086E4
.text$mn:000086E4 ; Attributes: bp-based frame
.text$mn:000086E4
.text$mn:000086E4 ; int __thiscall Buffer::getEncoding(Buffer *__hidden this)
.text$mn:000086E4                 public ?getEncoding@Buffer@@QBEHXZ
.text$mn:000086E4 ?getEncoding@Buffer@@QBEHXZ proc near   ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+221p
.text$mn:000086E4
.text$mn:000086E4 var_4           = dword ptr -4
.text$mn:000086E4
.text$mn:000086E4                 push    ebp
.text$mn:000086E5                 mov     ebp, esp
.text$mn:000086E7                 push    ecx
.text$mn:000086E8                 mov     [ebp+var_4], ecx
.text$mn:000086EB                 mov     eax, [ebp+var_4]
.text$mn:000086EE                 mov     eax, [eax+40h]
.text$mn:000086F1                 mov     esp, ebp
.text$mn:000086F3                 pop     ebp
.text$mn:000086F4                 retn
.text$mn:000086F4 ?getEncoding@Buffer@@QBEHXZ endp
.text$mn:000086F4
.text$mn:000086F4 ; ---------------------------------------------------------------------------
.text$mn:000086F5                 align 4
.text$mn:000086F5 _text$mn        ends
.text$mn:000086F5
.text$mn:000086F8 ; ===========================================================================
.text$mn:000086F8
.text$mn:000086F8 ; Segment type: Pure code
.text$mn:000086F8 ; Segment permissions: Read/Execute
.text$mn:000086F8 _text$mn        segment para public 'CODE' use32
.text$mn:000086F8                 assume cs:_text$mn
.text$mn:000086F8                 ;org 86F8h
.text$mn:000086F8 ; COMDAT (pick any)
.text$mn:000086F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000086F8
.text$mn:000086F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000086F8
.text$mn:000086F8 ; Attributes: bp-based frame
.text$mn:000086F8
.text$mn:000086F8 ; void __thiscall Window::getFocus(Window *__hidden this)
.text$mn:000086F8                 public ?getFocus@Window@@QBEXXZ
.text$mn:000086F8 ?getFocus@Window@@QBEXXZ proc near      ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+368p
.text$mn:000086F8
.text$mn:000086F8 var_4           = dword ptr -4
.text$mn:000086F8
.text$mn:000086F8                 push    ebp
.text$mn:000086F9                 mov     ebp, esp
.text$mn:000086FB                 push    ecx
.text$mn:000086FC                 mov     [ebp+var_4], ecx
.text$mn:000086FF                 mov     eax, [ebp+var_4]
.text$mn:00008702                 mov     ecx, [eax+0Ch]
.text$mn:00008705                 push    ecx             ; hWnd
.text$mn:00008706                 call    dword ptr ds:__imp__SetFocus@4 ; SetFocus(x)
.text$mn:0000870C                 mov     esp, ebp
.text$mn:0000870E                 pop     ebp
.text$mn:0000870F                 retn
.text$mn:0000870F ?getFocus@Window@@QBEXXZ endp
.text$mn:0000870F
.text$mn:0000870F _text$mn        ends
.text$mn:0000870F
.text$mn:00008710 ; ===========================================================================
.text$mn:00008710
.text$mn:00008710 ; Segment type: Pure code
.text$mn:00008710 ; Segment permissions: Read/Execute
.text$mn:00008710 _text$mn        segment para public 'CODE' use32
.text$mn:00008710                 assume cs:_text$mn
.text$mn:00008710                 ;org 8710h
.text$mn:00008710 ; COMDAT (pick any)
.text$mn:00008710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008710
.text$mn:00008710 ; =============== S U B R O U T I N E =======================================
.text$mn:00008710
.text$mn:00008710 ; Attributes: bp-based frame
.text$mn:00008710
.text$mn:00008710 ; unsigned int __thiscall ByteArray::getLength(ByteArray *__hidden this)
.text$mn:00008710                 public ?getLength@ByteArray@@QBEIXZ
.text$mn:00008710 ?getLength@ByteArray@@QBEIXZ proc near  ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+2C1p
.text$mn:00008710                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+309p
.text$mn:00008710
.text$mn:00008710 var_4           = dword ptr -4
.text$mn:00008710
.text$mn:00008710                 push    ebp
.text$mn:00008711                 mov     ebp, esp
.text$mn:00008713                 push    ecx
.text$mn:00008714                 mov     [ebp+var_4], ecx
.text$mn:00008717                 mov     eax, [ebp+var_4]
.text$mn:0000871A                 mov     eax, [eax+4]
.text$mn:0000871D                 mov     esp, ebp
.text$mn:0000871F                 pop     ebp
.text$mn:00008720                 retn
.text$mn:00008720 ?getLength@ByteArray@@QBEIXZ endp
.text$mn:00008720
.text$mn:00008720 ; ---------------------------------------------------------------------------
.text$mn:00008721                 align 4
.text$mn:00008721 _text$mn        ends
.text$mn:00008721
.text$mn:00008724 ; ===========================================================================
.text$mn:00008724
.text$mn:00008724 ; Segment type: Pure code
.text$mn:00008724 ; Segment permissions: Read/Execute
.text$mn:00008724 _text$mn        segment para public 'CODE' use32
.text$mn:00008724                 assume cs:_text$mn
.text$mn:00008724                 ;org 8724h
.text$mn:00008724 ; COMDAT (pick any)
.text$mn:00008724                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008724
.text$mn:00008724 ; =============== S U B R O U T I N E =======================================
.text$mn:00008724
.text$mn:00008724 ; Attributes: bp-based frame
.text$mn:00008724
.text$mn:00008724 ; const unsigned __int8 *__thiscall ByteArray::getPointer(ByteArray *__hidden this)
.text$mn:00008724                 public ?getPointer@ByteArray@@QBEPBEXZ
.text$mn:00008724 ?getPointer@ByteArray@@QBEPBEXZ proc near
.text$mn:00008724                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+1EFp
.text$mn:00008724                                         ; ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+DCp ...
.text$mn:00008724
.text$mn:00008724 var_4           = dword ptr -4
.text$mn:00008724
.text$mn:00008724                 push    ebp
.text$mn:00008725                 mov     ebp, esp
.text$mn:00008727                 push    ecx
.text$mn:00008728                 mov     [ebp+var_4], ecx
.text$mn:0000872B                 mov     eax, [ebp+var_4]
.text$mn:0000872E                 mov     eax, [eax]
.text$mn:00008730                 mov     esp, ebp
.text$mn:00008732                 pop     ebp
.text$mn:00008733                 retn
.text$mn:00008733 ?getPointer@ByteArray@@QBEPBEXZ endp
.text$mn:00008733
.text$mn:00008733 _text$mn        ends
.text$mn:00008733
.text$mn:00008734 ; ===========================================================================
.text$mn:00008734
.text$mn:00008734 ; Segment type: Pure code
.text$mn:00008734 ; Segment permissions: Read/Execute
.text$mn:00008734 _text$mn        segment para public 'CODE' use32
.text$mn:00008734                 assume cs:_text$mn
.text$mn:00008734                 ;org 8734h
.text$mn:00008734 ; COMDAT (pick any)
.text$mn:00008734                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008734
.text$mn:00008734 ; =============== S U B R O U T I N E =======================================
.text$mn:00008734
.text$mn:00008734 ; Attributes: bp-based frame
.text$mn:00008734
.text$mn:00008734 ; public: class std::allocator<unsigned char> __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::get_allocator(void)const
.text$mn:00008734                 public ?get_allocator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$allocator@E@2@XZ
.text$mn:00008734 ?get_allocator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$allocator@E@2@XZ proc near
.text$mn:00008734                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+30p
.text$mn:00008734                                         ; std::vector<uchar,std::allocator<uchar>>::_Assign_rv(std::vector<uchar,std::allocator<uchar>> &&,std::integral_constant<bool,0>)+3Dp
.text$mn:00008734
.text$mn:00008734 var_8           = dword ptr -8
.text$mn:00008734 var_1           = byte ptr -1
.text$mn:00008734 arg_0           = dword ptr  8
.text$mn:00008734
.text$mn:00008734                 push    ebp
.text$mn:00008735                 mov     ebp, esp
.text$mn:00008737                 sub     esp, 8
.text$mn:0000873A                 mov     [ebp+var_8], ecx
.text$mn:0000873D                 lea     eax, [ebp+var_1]
.text$mn:00008740                 push    eax
.text$mn:00008741                 mov     ecx, [ebp+var_8]
.text$mn:00008744                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00008749                 push    eax
.text$mn:0000874A                 mov     ecx, [ebp+arg_0]
.text$mn:0000874D                 call    ??0?$allocator@E@std@@QAE@ABV01@@Z ; std::allocator<uchar>::allocator<uchar>(std::allocator<uchar> const &)
.text$mn:00008752                 mov     eax, [ebp+arg_0]
.text$mn:00008755                 mov     esp, ebp
.text$mn:00008757                 pop     ebp
.text$mn:00008758                 retn    4
.text$mn:00008758 ?get_allocator@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$allocator@E@2@XZ endp
.text$mn:00008758
.text$mn:00008758 ; ---------------------------------------------------------------------------
.text$mn:0000875B                 align 4
.text$mn:0000875B _text$mn        ends
.text$mn:0000875B
.text$mn:0000875C ; ===========================================================================
.text$mn:0000875C
.text$mn:0000875C ; Segment type: Pure code
.text$mn:0000875C ; Segment permissions: Read/Execute
.text$mn:0000875C _text$mn        segment para public 'CODE' use32
.text$mn:0000875C                 assume cs:_text$mn
.text$mn:0000875C                 ;org 875Ch
.text$mn:0000875C ; COMDAT (pick any)
.text$mn:0000875C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000875C
.text$mn:0000875C ; =============== S U B R O U T I N E =======================================
.text$mn:0000875C
.text$mn:0000875C ; Attributes: bp-based frame
.text$mn:0000875C
.text$mn:0000875C ; public: class std::_Vector_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>> __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::insert(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class std::vector<unsigned char, class std::allocator<unsigned char>>>>>, class std::vector<unsigned char, class std::allocator<unsigned char>> const &)
.text$mn:0000875C                 public ?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:0000875C ?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z proc near
.text$mn:0000875C                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+197p
.text$mn:0000875C
.text$mn:0000875C var_24          = dword ptr -24h
.text$mn:0000875C var_20          = dword ptr -20h
.text$mn:0000875C var_1C          = dword ptr -1Ch
.text$mn:0000875C var_18          = dword ptr -18h
.text$mn:0000875C var_14          = dword ptr -14h
.text$mn:0000875C var_10          = dword ptr -10h
.text$mn:0000875C var_C           = dword ptr -0Ch
.text$mn:0000875C var_4           = dword ptr -4
.text$mn:0000875C arg_0           = dword ptr  8
.text$mn:0000875C arg_4           = byte ptr  0Ch
.text$mn:0000875C arg_10          = dword ptr  18h
.text$mn:0000875C
.text$mn:0000875C                 push    ebp
.text$mn:0000875D                 mov     ebp, esp
.text$mn:0000875F                 push    0FFFFFFFFh
.text$mn:00008761                 push    offset __ehhandler$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$mn:00008766                 mov     eax, large fs:0
.text$mn:0000876C                 push    eax
.text$mn:0000876D                 sub     esp, 18h
.text$mn:00008770                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008775                 xor     eax, ebp
.text$mn:00008777                 push    eax
.text$mn:00008778                 lea     eax, [ebp+var_C]
.text$mn:0000877B                 mov     large fs:0, eax
.text$mn:00008781                 mov     [ebp+var_18], ecx
.text$mn:00008784                 mov     [ebp+var_10], 0
.text$mn:0000878B                 mov     [ebp+var_4], 1
.text$mn:00008792                 mov     eax, [ebp+arg_10]
.text$mn:00008795                 push    eax
.text$mn:00008796                 push    1
.text$mn:00008798                 sub     esp, 0Ch
.text$mn:0000879B                 mov     ecx, esp
.text$mn:0000879D                 mov     [ebp+var_1C], esp
.text$mn:000087A0                 lea     edx, [ebp+arg_4]
.text$mn:000087A3                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:000087A4                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>> const &)
.text$mn:000087A9                 mov     [ebp+var_14], eax
.text$mn:000087AC                 mov     eax, [ebp+var_14]
.text$mn:000087AF                 mov     [ebp+var_20], eax
.text$mn:000087B2                 mov     byte ptr [ebp+var_4], 2
.text$mn:000087B6                 mov     ecx, [ebp+arg_0]
.text$mn:000087B9                 push    ecx
.text$mn:000087BA                 mov     byte ptr [ebp+var_4], 1
.text$mn:000087BE                 mov     ecx, [ebp+var_18]
.text$mn:000087C1                 call    ?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)
.text$mn:000087C6                 mov     [ebp+var_24], eax
.text$mn:000087C9                 mov     edx, [ebp+var_10]
.text$mn:000087CC                 or      edx, 1
.text$mn:000087CF                 mov     [ebp+var_10], edx
.text$mn:000087D2                 mov     byte ptr [ebp+var_4], 0
.text$mn:000087D6                 lea     ecx, [ebp+arg_4]
.text$mn:000087D9                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$mn:000087DE                 mov     eax, [ebp+arg_0]
.text$mn:000087E1                 mov     ecx, [ebp+var_C]
.text$mn:000087E4                 mov     large fs:0, ecx
.text$mn:000087EB                 pop     ecx
.text$mn:000087EC                 mov     esp, ebp
.text$mn:000087EE                 pop     ebp
.text$mn:000087EF                 retn    14h
.text$mn:000087EF ?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z endp
.text$mn:000087EF
.text$mn:000087EF ; ---------------------------------------------------------------------------
.text$mn:000087F2                 align 4
.text$mn:000087F2 _text$mn        ends
.text$mn:000087F2
.text$x:000087F4 ; ===========================================================================
.text$x:000087F4
.text$x:000087F4 ; Segment type: Pure code
.text$x:000087F4 ; Segment permissions: Read/Execute
.text$x:000087F4 _text$x         segment para public 'CODE' use32
.text$x:000087F4                 assume cs:_text$x
.text$x:000087F4                 ;org 87F4h
.text$x:000087F4 ; COMDAT (pick associative to section at 875C)
.text$x:000087F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000087F4
.text$x:000087F4 ; =============== S U B R O U T I N E =======================================
.text$x:000087F4
.text$x:000087F4
.text$x:000087F4 __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$0 proc near
.text$x:000087F4                                         ; DATA XREF: .xdata$x:0000951Co
.text$x:000087F4                 lea     ecx, [ebp+0Ch]
.text$x:000087F7                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000087F7 __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$0 endp
.text$x:000087F7
.text$x:000087FC
.text$x:000087FC ; =============== S U B R O U T I N E =======================================
.text$x:000087FC
.text$x:000087FC
.text$x:000087FC __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$1 proc near
.text$x:000087FC                                         ; DATA XREF: .xdata$x:00009524o
.text$x:000087FC                 mov     ecx, [ebp-1Ch]
.text$x:000087FF                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:000087FF __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$1 endp
.text$x:000087FF
.text$x:00008804
.text$x:00008804 ; =============== S U B R O U T I N E =======================================
.text$x:00008804
.text$x:00008804
.text$x:00008804 __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$2 proc near
.text$x:00008804                                         ; DATA XREF: .xdata$x:00009514o
.text$x:00008804                 mov     eax, [ebp-10h]
.text$x:00008807                 and     eax, 1
.text$x:0000880A                 jz      $LN6_2
.text$x:00008810                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008814                 mov     ecx, [ebp+8]
.text$x:00008817                 jmp     ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::~_Vector_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>(void)
.text$x:0000881C ; ---------------------------------------------------------------------------
.text$x:0000881C
.text$x:0000881C $LN6_2:                                 ; CODE XREF: __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$2+6j
.text$x:0000881C                 retn
.text$x:0000881C __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$2 endp
.text$x:0000881C
.text$x:0000881D
.text$x:0000881D ; =============== S U B R O U T I N E =======================================
.text$x:0000881D
.text$x:0000881D
.text$x:0000881D __ehhandler$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z proc near
.text$x:0000881D                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::insert(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,std::vector<uchar,std::allocator<uchar>> const &)+5o
.text$x:0000881D
.text$x:0000881D arg_4           = dword ptr  8
.text$x:0000881D
.text$x:0000881D                 mov     edx, [esp+arg_4]
.text$x:00008821                 lea     eax, [edx+0Ch]
.text$x:00008824                 mov     ecx, [edx-1Ch]
.text$x:00008827                 xor     ecx, eax
.text$x:00008829                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000882E                 mov     eax, offset __ehfuncinfo$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z
.text$x:00008833                 jmp     ___CxxFrameHandler3
.text$x:00008833 __ehhandler$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z endp
.text$x:00008833
.text$x:00008833 _text$x         ends
.text$x:00008833
.text$mn:00008838 ; ===========================================================================
.text$mn:00008838
.text$mn:00008838 ; Segment type: Pure code
.text$mn:00008838 ; Segment permissions: Read/Execute
.text$mn:00008838 _text$mn        segment para public 'CODE' use32
.text$mn:00008838                 assume cs:_text$mn
.text$mn:00008838                 ;org 8838h
.text$mn:00008838 ; COMDAT (pick any)
.text$mn:00008838                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008838
.text$mn:00008838 ; =============== S U B R O U T I N E =======================================
.text$mn:00008838
.text$mn:00008838 ; Attributes: bp-based frame
.text$mn:00008838
.text$mn:00008838 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00008838                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00008838 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00008838                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00008838
.text$mn:00008838 var_4           = dword ptr -4
.text$mn:00008838 Str             = dword ptr  8
.text$mn:00008838
.text$mn:00008838                 push    ebp
.text$mn:00008839                 mov     ebp, esp
.text$mn:0000883B                 push    ecx
.text$mn:0000883C                 mov     eax, [ebp+Str]
.text$mn:0000883F                 movsx   ecx, byte ptr [eax]
.text$mn:00008842                 test    ecx, ecx
.text$mn:00008844                 jnz     short loc_884F
.text$mn:00008846                 mov     [ebp+var_4], 0
.text$mn:0000884D                 jmp     short loc_885E
.text$mn:0000884F ; ---------------------------------------------------------------------------
.text$mn:0000884F
.text$mn:0000884F loc_884F:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:0000884F                 mov     edx, [ebp+Str]
.text$mn:00008852                 push    edx             ; Str
.text$mn:00008853                 call    _strlen
.text$mn:00008858                 add     esp, 4
.text$mn:0000885B                 mov     [ebp+var_4], eax
.text$mn:0000885E
.text$mn:0000885E loc_885E:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:0000885E                 mov     eax, [ebp+var_4]
.text$mn:00008861                 mov     esp, ebp
.text$mn:00008863                 pop     ebp
.text$mn:00008864                 retn
.text$mn:00008864 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00008864
.text$mn:00008864 ; ---------------------------------------------------------------------------
.text$mn:00008865                 align 4
.text$mn:00008865 _text$mn        ends
.text$mn:00008865
.text$mn:00008868 ; ===========================================================================
.text$mn:00008868
.text$mn:00008868 ; Segment type: Pure code
.text$mn:00008868 ; Segment permissions: Read/Execute
.text$mn:00008868 _text$mn        segment para public 'CODE' use32
.text$mn:00008868                 assume cs:_text$mn
.text$mn:00008868                 ;org 8868h
.text$mn:00008868 ; COMDAT (pick any)
.text$mn:00008868                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008868
.text$mn:00008868 ; =============== S U B R O U T I N E =======================================
.text$mn:00008868
.text$mn:00008868 ; Attributes: bp-based frame
.text$mn:00008868
.text$mn:00008868 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00008868                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00008868 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00008868                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00008868
.text$mn:00008868 var_4           = dword ptr -4
.text$mn:00008868
.text$mn:00008868                 push    ebp
.text$mn:00008869                 mov     ebp, esp
.text$mn:0000886B                 push    ecx
.text$mn:0000886C                 mov     [ebp+var_4], ecx
.text$mn:0000886F                 mov     eax, [ebp+var_4]
.text$mn:00008872                 push    eax
.text$mn:00008873                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00008878                 add     esp, 4
.text$mn:0000887B                 mov     esp, ebp
.text$mn:0000887D                 pop     ebp
.text$mn:0000887E                 retn
.text$mn:0000887E ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:0000887E
.text$mn:0000887E ; ---------------------------------------------------------------------------
.text$mn:0000887F                 align 10h
.text$mn:0000887F _text$mn        ends
.text$mn:0000887F
.text$mn:00008880 ; ===========================================================================
.text$mn:00008880
.text$mn:00008880 ; Segment type: Pure code
.text$mn:00008880 ; Segment permissions: Read/Execute
.text$mn:00008880 _text$mn        segment para public 'CODE' use32
.text$mn:00008880                 assume cs:_text$mn
.text$mn:00008880                 ;org 8880h
.text$mn:00008880 ; COMDAT (pick any)
.text$mn:00008880                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008880
.text$mn:00008880 ; =============== S U B R O U T I N E =======================================
.text$mn:00008880
.text$mn:00008880 ; Attributes: bp-based frame
.text$mn:00008880
.text$mn:00008880 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>>::max_size(void)const
.text$mn:00008880                 public ?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ
.text$mn:00008880 ?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ proc near
.text$mn:00008880                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::max_size(void)+17p
.text$mn:00008880
.text$mn:00008880 var_4           = dword ptr -4
.text$mn:00008880
.text$mn:00008880                 push    ebp
.text$mn:00008881                 mov     ebp, esp
.text$mn:00008883                 push    ecx
.text$mn:00008884                 mov     [ebp+var_4], ecx
.text$mn:00008887                 mov     eax, [ebp+var_4]
.text$mn:0000888A                 push    eax
.text$mn:0000888B                 call    ?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z ; std::allocator_traits<std::allocator<uchar>>::max_size(std::allocator<uchar> const &)
.text$mn:00008890                 add     esp, 4
.text$mn:00008893                 mov     esp, ebp
.text$mn:00008895                 pop     ebp
.text$mn:00008896                 retn
.text$mn:00008896 ?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ endp
.text$mn:00008896
.text$mn:00008896 ; ---------------------------------------------------------------------------
.text$mn:00008897                 align 4
.text$mn:00008897 _text$mn        ends
.text$mn:00008897
.text$mn:00008898 ; ===========================================================================
.text$mn:00008898
.text$mn:00008898 ; Segment type: Pure code
.text$mn:00008898 ; Segment permissions: Read/Execute
.text$mn:00008898 _text$mn        segment para public 'CODE' use32
.text$mn:00008898                 assume cs:_text$mn
.text$mn:00008898                 ;org 8898h
.text$mn:00008898 ; COMDAT (pick any)
.text$mn:00008898                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008898
.text$mn:00008898 ; =============== S U B R O U T I N E =======================================
.text$mn:00008898
.text$mn:00008898 ; Attributes: bp-based frame
.text$mn:00008898
.text$mn:00008898 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::max_size(void)const
.text$mn:00008898                 public ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QBEIXZ
.text$mn:00008898 ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QBEIXZ proc near
.text$mn:00008898                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::max_size(void)+17p
.text$mn:00008898
.text$mn:00008898 var_4           = dword ptr -4
.text$mn:00008898
.text$mn:00008898                 push    ebp
.text$mn:00008899                 mov     ebp, esp
.text$mn:0000889B                 push    ecx
.text$mn:0000889C                 mov     [ebp+var_4], ecx
.text$mn:0000889F                 mov     eax, [ebp+var_4]
.text$mn:000088A2                 push    eax
.text$mn:000088A3                 call    ?max_size@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@Z ; std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::max_size(std::allocator<std::vector<uchar,std::allocator<uchar>>> const &)
.text$mn:000088A8                 add     esp, 4
.text$mn:000088AB                 mov     esp, ebp
.text$mn:000088AD                 pop     ebp
.text$mn:000088AE                 retn
.text$mn:000088AE ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QBEIXZ endp
.text$mn:000088AE
.text$mn:000088AE ; ---------------------------------------------------------------------------
.text$mn:000088AF                 align 10h
.text$mn:000088AF _text$mn        ends
.text$mn:000088AF
.text$mn:000088B0 ; ===========================================================================
.text$mn:000088B0
.text$mn:000088B0 ; Segment type: Pure code
.text$mn:000088B0 ; Segment permissions: Read/Execute
.text$mn:000088B0 _text$mn        segment para public 'CODE' use32
.text$mn:000088B0                 assume cs:_text$mn
.text$mn:000088B0                 ;org 88B0h
.text$mn:000088B0 ; COMDAT (pick any)
.text$mn:000088B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088B0
.text$mn:000088B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088B0
.text$mn:000088B0 ; Attributes: bp-based frame
.text$mn:000088B0
.text$mn:000088B0 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000088B0                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000088B0 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000088B0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000088B0
.text$mn:000088B0 var_4           = dword ptr -4
.text$mn:000088B0
.text$mn:000088B0                 push    ebp
.text$mn:000088B1                 mov     ebp, esp
.text$mn:000088B3                 push    ecx
.text$mn:000088B4                 mov     [ebp+var_4], ecx
.text$mn:000088B7                 or      eax, 0FFFFFFFFh
.text$mn:000088BA                 mov     esp, ebp
.text$mn:000088BC                 pop     ebp
.text$mn:000088BD                 retn
.text$mn:000088BD ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000088BD
.text$mn:000088BD ; ---------------------------------------------------------------------------
.text$mn:000088BE                 align 10h
.text$mn:000088BE _text$mn        ends
.text$mn:000088BE
.text$mn:000088C0 ; ===========================================================================
.text$mn:000088C0
.text$mn:000088C0 ; Segment type: Pure code
.text$mn:000088C0 ; Segment permissions: Read/Execute
.text$mn:000088C0 _text$mn        segment para public 'CODE' use32
.text$mn:000088C0                 assume cs:_text$mn
.text$mn:000088C0                 ;org 88C0h
.text$mn:000088C0 ; COMDAT (pick any)
.text$mn:000088C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088C0
.text$mn:000088C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088C0
.text$mn:000088C0 ; Attributes: bp-based frame
.text$mn:000088C0
.text$mn:000088C0 ; public: unsigned int __thiscall std::allocator<unsigned char>::max_size(void)const
.text$mn:000088C0                 public ?max_size@?$allocator@E@std@@QBEIXZ
.text$mn:000088C0 ?max_size@?$allocator@E@std@@QBEIXZ proc near
.text$mn:000088C0                                         ; CODE XREF: std::allocator_traits<std::allocator<uchar>>::max_size(std::allocator<uchar> const &)+6p
.text$mn:000088C0
.text$mn:000088C0 var_4           = dword ptr -4
.text$mn:000088C0
.text$mn:000088C0                 push    ebp
.text$mn:000088C1                 mov     ebp, esp
.text$mn:000088C3                 push    ecx
.text$mn:000088C4                 mov     [ebp+var_4], ecx
.text$mn:000088C7                 or      eax, 0FFFFFFFFh
.text$mn:000088CA                 mov     esp, ebp
.text$mn:000088CC                 pop     ebp
.text$mn:000088CD                 retn
.text$mn:000088CD ?max_size@?$allocator@E@std@@QBEIXZ endp
.text$mn:000088CD
.text$mn:000088CD ; ---------------------------------------------------------------------------
.text$mn:000088CE                 align 10h
.text$mn:000088CE _text$mn        ends
.text$mn:000088CE
.text$mn:000088D0 ; ===========================================================================
.text$mn:000088D0
.text$mn:000088D0 ; Segment type: Pure code
.text$mn:000088D0 ; Segment permissions: Read/Execute
.text$mn:000088D0 _text$mn        segment para public 'CODE' use32
.text$mn:000088D0                 assume cs:_text$mn
.text$mn:000088D0                 ;org 88D0h
.text$mn:000088D0 ; COMDAT (pick any)
.text$mn:000088D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088D0
.text$mn:000088D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088D0
.text$mn:000088D0 ; Attributes: bp-based frame
.text$mn:000088D0
.text$mn:000088D0 ; public: unsigned int __thiscall std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>::max_size(void)const
.text$mn:000088D0                 public ?max_size@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QBEIXZ
.text$mn:000088D0 ?max_size@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QBEIXZ proc near
.text$mn:000088D0                                         ; CODE XREF: std::allocator_traits<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::max_size(std::allocator<std::vector<uchar,std::allocator<uchar>>> const &)+6p
.text$mn:000088D0
.text$mn:000088D0 var_4           = dword ptr -4
.text$mn:000088D0
.text$mn:000088D0                 push    ebp
.text$mn:000088D1                 mov     ebp, esp
.text$mn:000088D3                 push    ecx
.text$mn:000088D4                 mov     [ebp+var_4], ecx
.text$mn:000088D7                 mov     eax, 0FFFFFFFh
.text$mn:000088DC                 mov     esp, ebp
.text$mn:000088DE                 pop     ebp
.text$mn:000088DF                 retn
.text$mn:000088DF ?max_size@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QBEIXZ endp
.text$mn:000088DF
.text$mn:000088DF _text$mn        ends
.text$mn:000088DF
.text$mn:000088E0 ; ===========================================================================
.text$mn:000088E0
.text$mn:000088E0 ; Segment type: Pure code
.text$mn:000088E0 ; Segment permissions: Read/Execute
.text$mn:000088E0 _text$mn        segment para public 'CODE' use32
.text$mn:000088E0                 assume cs:_text$mn
.text$mn:000088E0                 ;org 88E0h
.text$mn:000088E0 ; COMDAT (pick any)
.text$mn:000088E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088E0
.text$mn:000088E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088E0
.text$mn:000088E0 ; Attributes: bp-based frame
.text$mn:000088E0
.text$mn:000088E0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000088E0                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000088E0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000088E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000088E0
.text$mn:000088E0 arg_0           = dword ptr  8
.text$mn:000088E0
.text$mn:000088E0                 push    ebp
.text$mn:000088E1                 mov     ebp, esp
.text$mn:000088E3                 mov     ecx, [ebp+arg_0]
.text$mn:000088E6                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000088EB                 pop     ebp
.text$mn:000088EC                 retn
.text$mn:000088EC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000088EC
.text$mn:000088EC ; ---------------------------------------------------------------------------
.text$mn:000088ED                 align 10h
.text$mn:000088ED _text$mn        ends
.text$mn:000088ED
.text$mn:000088F0 ; ===========================================================================
.text$mn:000088F0
.text$mn:000088F0 ; Segment type: Pure code
.text$mn:000088F0 ; Segment permissions: Read/Execute
.text$mn:000088F0 _text$mn        segment para public 'CODE' use32
.text$mn:000088F0                 assume cs:_text$mn
.text$mn:000088F0                 ;org 88F0h
.text$mn:000088F0 ; COMDAT (pick any)
.text$mn:000088F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000088F0
.text$mn:000088F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000088F0
.text$mn:000088F0 ; Attributes: bp-based frame
.text$mn:000088F0
.text$mn:000088F0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<unsigned char>>::max_size(class std::allocator<unsigned char> const &)
.text$mn:000088F0                 public ?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z
.text$mn:000088F0 ?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z proc near
.text$mn:000088F0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::max_size(void)+Bp
.text$mn:000088F0
.text$mn:000088F0 arg_0           = dword ptr  8
.text$mn:000088F0
.text$mn:000088F0                 push    ebp
.text$mn:000088F1                 mov     ebp, esp
.text$mn:000088F3                 mov     ecx, [ebp+arg_0]
.text$mn:000088F6                 call    ?max_size@?$allocator@E@std@@QBEIXZ ; std::allocator<uchar>::max_size(void)
.text$mn:000088FB                 pop     ebp
.text$mn:000088FC                 retn
.text$mn:000088FC ?max_size@?$allocator_traits@V?$allocator@E@std@@@std@@SAIABV?$allocator@E@2@@Z endp
.text$mn:000088FC
.text$mn:000088FC ; ---------------------------------------------------------------------------
.text$mn:000088FD                 align 10h
.text$mn:000088FD _text$mn        ends
.text$mn:000088FD
.text$mn:00008900 ; ===========================================================================
.text$mn:00008900
.text$mn:00008900 ; Segment type: Pure code
.text$mn:00008900 ; Segment permissions: Read/Execute
.text$mn:00008900 _text$mn        segment para public 'CODE' use32
.text$mn:00008900                 assume cs:_text$mn
.text$mn:00008900                 ;org 8900h
.text$mn:00008900 ; COMDAT (pick any)
.text$mn:00008900                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008900
.text$mn:00008900 ; =============== S U B R O U T I N E =======================================
.text$mn:00008900
.text$mn:00008900 ; Attributes: bp-based frame
.text$mn:00008900
.text$mn:00008900 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::max_size(class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>> const &)
.text$mn:00008900                 public ?max_size@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@Z
.text$mn:00008900 ?max_size@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@Z proc near
.text$mn:00008900                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::max_size(void)+Bp
.text$mn:00008900
.text$mn:00008900 arg_0           = dword ptr  8
.text$mn:00008900
.text$mn:00008900                 push    ebp
.text$mn:00008901                 mov     ebp, esp
.text$mn:00008903                 mov     ecx, [ebp+arg_0]
.text$mn:00008906                 call    ?max_size@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QBEIXZ ; std::allocator<std::vector<uchar,std::allocator<uchar>>>::max_size(void)
.text$mn:0000890B                 pop     ebp
.text$mn:0000890C                 retn
.text$mn:0000890C ?max_size@?$allocator_traits@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@Z endp
.text$mn:0000890C
.text$mn:0000890C ; ---------------------------------------------------------------------------
.text$mn:0000890D                 align 10h
.text$mn:0000890D _text$mn        ends
.text$mn:0000890D
.text$mn:00008910 ; ===========================================================================
.text$mn:00008910
.text$mn:00008910 ; Segment type: Pure code
.text$mn:00008910 ; Segment permissions: Read/Execute
.text$mn:00008910 _text$mn        segment para public 'CODE' use32
.text$mn:00008910                 assume cs:_text$mn
.text$mn:00008910                 ;org 8910h
.text$mn:00008910 ; COMDAT (pick any)
.text$mn:00008910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008910
.text$mn:00008910 ; =============== S U B R O U T I N E =======================================
.text$mn:00008910
.text$mn:00008910 ; Attributes: bp-based frame
.text$mn:00008910
.text$mn:00008910 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00008910                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00008910 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00008910                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00008910                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00008910
.text$mn:00008910 var_10          = dword ptr -10h
.text$mn:00008910 var_C           = dword ptr -0Ch
.text$mn:00008910 var_8           = dword ptr -8
.text$mn:00008910 var_1           = byte ptr -1
.text$mn:00008910
.text$mn:00008910                 push    ebp
.text$mn:00008911                 mov     ebp, esp
.text$mn:00008913                 sub     esp, 10h
.text$mn:00008916                 mov     [ebp+var_10], ecx
.text$mn:00008919                 lea     eax, [ebp+var_1]
.text$mn:0000891C                 push    eax
.text$mn:0000891D                 mov     ecx, [ebp+var_10]
.text$mn:00008920                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00008925                 mov     ecx, eax
.text$mn:00008927                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:0000892C                 mov     [ebp+var_8], eax
.text$mn:0000892F                 cmp     [ebp+var_8], 1
.text$mn:00008933                 ja      short loc_893E
.text$mn:00008935                 mov     [ebp+var_C], 1
.text$mn:0000893C                 jmp     short loc_8947
.text$mn:0000893E ; ---------------------------------------------------------------------------
.text$mn:0000893E
.text$mn:0000893E loc_893E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000893E                 mov     ecx, [ebp+var_8]
.text$mn:00008941                 sub     ecx, 1
.text$mn:00008944                 mov     [ebp+var_C], ecx
.text$mn:00008947
.text$mn:00008947 loc_8947:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00008947                 mov     eax, [ebp+var_C]
.text$mn:0000894A                 mov     esp, ebp
.text$mn:0000894C                 pop     ebp
.text$mn:0000894D                 retn
.text$mn:0000894D ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:0000894D
.text$mn:0000894D ; ---------------------------------------------------------------------------
.text$mn:0000894E                 align 10h
.text$mn:0000894E _text$mn        ends
.text$mn:0000894E
.text$mn:00008950 ; ===========================================================================
.text$mn:00008950
.text$mn:00008950 ; Segment type: Pure code
.text$mn:00008950 ; Segment permissions: Read/Execute
.text$mn:00008950 _text$mn        segment para public 'CODE' use32
.text$mn:00008950                 assume cs:_text$mn
.text$mn:00008950                 ;org 8950h
.text$mn:00008950 ; COMDAT (pick any)
.text$mn:00008950                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008950
.text$mn:00008950 ; =============== S U B R O U T I N E =======================================
.text$mn:00008950
.text$mn:00008950 ; Attributes: bp-based frame
.text$mn:00008950
.text$mn:00008950 ; public: unsigned int __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::max_size(void)const
.text$mn:00008950                 public ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
.text$mn:00008950 ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ proc near
.text$mn:00008950                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::_Buy(uint)+36p
.text$mn:00008950                                         ; std::vector<uchar,std::allocator<uchar>>::_Grow_to(uint)+17p ...
.text$mn:00008950
.text$mn:00008950 var_8           = dword ptr -8
.text$mn:00008950 var_1           = byte ptr -1
.text$mn:00008950
.text$mn:00008950                 push    ebp
.text$mn:00008951                 mov     ebp, esp
.text$mn:00008953                 sub     esp, 8
.text$mn:00008956                 mov     [ebp+var_8], ecx
.text$mn:00008959                 lea     eax, [ebp+var_1]
.text$mn:0000895C                 push    eax
.text$mn:0000895D                 mov     ecx, [ebp+var_8]
.text$mn:00008960                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00008965                 mov     ecx, eax
.text$mn:00008967                 call    ?max_size@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<uchar>>::max_size(void)
.text$mn:0000896C                 mov     esp, ebp
.text$mn:0000896E                 pop     ebp
.text$mn:0000896F                 retn
.text$mn:0000896F ?max_size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ endp
.text$mn:0000896F
.text$mn:0000896F _text$mn        ends
.text$mn:0000896F
.text$mn:00008970 ; ===========================================================================
.text$mn:00008970
.text$mn:00008970 ; Segment type: Pure code
.text$mn:00008970 ; Segment permissions: Read/Execute
.text$mn:00008970 _text$mn        segment para public 'CODE' use32
.text$mn:00008970                 assume cs:_text$mn
.text$mn:00008970                 ;org 8970h
.text$mn:00008970 ; COMDAT (pick any)
.text$mn:00008970                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008970
.text$mn:00008970 ; =============== S U B R O U T I N E =======================================
.text$mn:00008970
.text$mn:00008970 ; Attributes: bp-based frame
.text$mn:00008970
.text$mn:00008970 ; public: unsigned int __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::max_size(void)const
.text$mn:00008970                 public ?max_size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00008970 ?max_size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00008970                                         ; CODE XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Grow_to(uint)+17p
.text$mn:00008970                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+A5p
.text$mn:00008970
.text$mn:00008970 var_8           = dword ptr -8
.text$mn:00008970 var_1           = byte ptr -1
.text$mn:00008970
.text$mn:00008970                 push    ebp
.text$mn:00008971                 mov     ebp, esp
.text$mn:00008973                 sub     esp, 8
.text$mn:00008976                 mov     [ebp+var_8], ecx
.text$mn:00008979                 lea     eax, [ebp+var_1]
.text$mn:0000897C                 push    eax
.text$mn:0000897D                 mov     ecx, [ebp+var_8]
.text$mn:00008980                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>>::_Getal(void)
.text$mn:00008985                 mov     ecx, eax
.text$mn:00008987                 call    ?max_size@?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<std::vector<uchar,std::allocator<uchar>>>>::max_size(void)
.text$mn:0000898C                 mov     esp, ebp
.text$mn:0000898E                 pop     ebp
.text$mn:0000898F                 retn
.text$mn:0000898F ?max_size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:0000898F
.text$mn:0000898F _text$mn        ends
.text$mn:0000898F
.text$mn:00008990 ; ===========================================================================
.text$mn:00008990
.text$mn:00008990 ; Segment type: Pure code
.text$mn:00008990 ; Segment permissions: Read/Execute
.text$mn:00008990 _text$mn        segment para public 'CODE' use32
.text$mn:00008990                 assume cs:_text$mn
.text$mn:00008990                 ;org 8990h
.text$mn:00008990 ; COMDAT (pick any)
.text$mn:00008990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008990
.text$mn:00008990 ; =============== S U B R O U T I N E =======================================
.text$mn:00008990
.text$mn:00008990 ; Attributes: bp-based frame
.text$mn:00008990
.text$mn:00008990 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00008990                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008990 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00008990                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00008990                                         ; DATA XREF: .rdata:0000A4F8o
.text$mn:00008990
.text$mn:00008990 var_1C          = dword ptr -1Ch
.text$mn:00008990 var_18          = dword ptr -18h
.text$mn:00008990 Str             = dword ptr -14h
.text$mn:00008990 var_10          = dword ptr -10h
.text$mn:00008990 var_C           = dword ptr -0Ch
.text$mn:00008990 var_4           = dword ptr -4
.text$mn:00008990 arg_0           = dword ptr  8
.text$mn:00008990 arg_4           = dword ptr  0Ch
.text$mn:00008990
.text$mn:00008990                 push    ebp
.text$mn:00008991                 mov     ebp, esp
.text$mn:00008993                 push    0FFFFFFFFh
.text$mn:00008995                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000899A                 mov     eax, large fs:0
.text$mn:000089A0                 push    eax
.text$mn:000089A1                 sub     esp, 10h
.text$mn:000089A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000089A9                 xor     eax, ebp
.text$mn:000089AB                 push    eax
.text$mn:000089AC                 lea     eax, [ebp+var_C]
.text$mn:000089AF                 mov     large fs:0, eax
.text$mn:000089B5                 mov     [ebp+var_1C], ecx
.text$mn:000089B8                 mov     [ebp+var_18], 0
.text$mn:000089BF                 mov     eax, [ebp+arg_4]
.text$mn:000089C2                 push    eax             ; int
.text$mn:000089C3                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000089C8                 add     esp, 4
.text$mn:000089CB                 mov     [ebp+var_10], eax
.text$mn:000089CE                 cmp     [ebp+var_10], 0
.text$mn:000089D2                 jz      short loc_89DC
.text$mn:000089D4                 mov     ecx, [ebp+var_10]
.text$mn:000089D7                 mov     [ebp+Str], ecx
.text$mn:000089DA                 jmp     short loc_89E3
.text$mn:000089DC ; ---------------------------------------------------------------------------
.text$mn:000089DC
.text$mn:000089DC loc_89DC:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000089DC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000089E3
.text$mn:000089E3 loc_89E3:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000089E3                 mov     edx, [ebp+Str]
.text$mn:000089E6                 push    edx             ; Str
.text$mn:000089E7                 mov     ecx, [ebp+arg_0]
.text$mn:000089EA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000089EF                 mov     [ebp+var_4], 0
.text$mn:000089F6                 mov     eax, [ebp+var_18]
.text$mn:000089F9                 or      eax, 1
.text$mn:000089FC                 mov     [ebp+var_18], eax
.text$mn:000089FF                 mov     eax, [ebp+arg_0]
.text$mn:00008A02                 mov     ecx, [ebp+var_C]
.text$mn:00008A05                 mov     large fs:0, ecx
.text$mn:00008A0C                 pop     ecx
.text$mn:00008A0D                 mov     esp, ebp
.text$mn:00008A0F                 pop     ebp
.text$mn:00008A10                 retn    8
.text$mn:00008A10 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00008A10
.text$mn:00008A10 ; ---------------------------------------------------------------------------
.text$mn:00008A13                 align 4
.text$mn:00008A13 _text$mn        ends
.text$mn:00008A13
.text$x:00008A14 ; ===========================================================================
.text$x:00008A14
.text$x:00008A14 ; Segment type: Pure code
.text$x:00008A14 ; Segment permissions: Read/Execute
.text$x:00008A14 _text$x         segment para public 'CODE' use32
.text$x:00008A14                 assume cs:_text$x
.text$x:00008A14                 ;org 8A14h
.text$x:00008A14 ; COMDAT (pick associative to section at 8990)
.text$x:00008A14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008A14
.text$x:00008A14 ; =============== S U B R O U T I N E =======================================
.text$x:00008A14
.text$x:00008A14
.text$x:00008A14 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00008A14                                         ; DATA XREF: .xdata$x:00009158o
.text$x:00008A14                 mov     eax, [ebp-18h]
.text$x:00008A17                 and     eax, 1
.text$x:00008A1A                 jz      $LN6
.text$x:00008A20                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00008A24                 mov     ecx, [ebp+8]
.text$x:00008A27                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008A2C ; ---------------------------------------------------------------------------
.text$x:00008A2C
.text$x:00008A2C $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008A2C                 retn
.text$x:00008A2C __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008A2C
.text$x:00008A2D
.text$x:00008A2D ; =============== S U B R O U T I N E =======================================
.text$x:00008A2D
.text$x:00008A2D
.text$x:00008A2D __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008A2D                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00008A2D
.text$x:00008A2D arg_4           = dword ptr  8
.text$x:00008A2D
.text$x:00008A2D                 mov     edx, [esp+arg_4]
.text$x:00008A31                 lea     eax, [edx+0Ch]
.text$x:00008A34                 mov     ecx, [edx-14h]
.text$x:00008A37                 xor     ecx, eax
.text$x:00008A39                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008A3E                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00008A43                 jmp     ___CxxFrameHandler3
.text$x:00008A43 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00008A43
.text$x:00008A43 _text$x         ends
.text$x:00008A43
.text$mn:00008A48 ; ===========================================================================
.text$mn:00008A48
.text$mn:00008A48 ; Segment type: Pure code
.text$mn:00008A48 ; Segment permissions: Read/Execute
.text$mn:00008A48 _text$mn        segment para public 'CODE' use32
.text$mn:00008A48                 assume cs:_text$mn
.text$mn:00008A48                 ;org 8A48h
.text$mn:00008A48 ; COMDAT (pick any)
.text$mn:00008A48                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008A48
.text$mn:00008A48 ; =============== S U B R O U T I N E =======================================
.text$mn:00008A48
.text$mn:00008A48 ; Attributes: bp-based frame
.text$mn:00008A48
.text$mn:00008A48 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00008A48                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008A48 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00008A48                                         ; DATA XREF: .rdata:0000A52Co
.text$mn:00008A48
.text$mn:00008A48 var_14          = dword ptr -14h
.text$mn:00008A48 var_10          = dword ptr -10h
.text$mn:00008A48 var_C           = dword ptr -0Ch
.text$mn:00008A48 var_4           = dword ptr -4
.text$mn:00008A48 arg_0           = dword ptr  8
.text$mn:00008A48 arg_4           = dword ptr  0Ch
.text$mn:00008A48
.text$mn:00008A48                 push    ebp
.text$mn:00008A49                 mov     ebp, esp
.text$mn:00008A4B                 push    0FFFFFFFFh
.text$mn:00008A4D                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008A52                 mov     eax, large fs:0
.text$mn:00008A58                 push    eax
.text$mn:00008A59                 sub     esp, 8
.text$mn:00008A5C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008A61                 xor     eax, ebp
.text$mn:00008A63                 push    eax
.text$mn:00008A64                 lea     eax, [ebp+var_C]
.text$mn:00008A67                 mov     large fs:0, eax
.text$mn:00008A6D                 mov     [ebp+var_14], ecx
.text$mn:00008A70                 mov     [ebp+var_10], 0
.text$mn:00008A77                 cmp     [ebp+arg_4], 1
.text$mn:00008A7B                 jnz     short loc_8AA1
.text$mn:00008A7D                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00008A82                 mov     ecx, [ebp+arg_0]
.text$mn:00008A85                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00008A8A                 mov     [ebp+var_4], 0
.text$mn:00008A91                 mov     eax, [ebp+var_10]
.text$mn:00008A94                 or      eax, 1
.text$mn:00008A97                 mov     [ebp+var_10], eax
.text$mn:00008A9A                 mov     eax, [ebp+arg_0]
.text$mn:00008A9D                 jmp     short loc_8AC4
.text$mn:00008A9F ; ---------------------------------------------------------------------------
.text$mn:00008A9F                 jmp     short loc_8AC4
.text$mn:00008AA1 ; ---------------------------------------------------------------------------
.text$mn:00008AA1
.text$mn:00008AA1 loc_8AA1:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00008AA1                 mov     ecx, [ebp+arg_4]
.text$mn:00008AA4                 push    ecx
.text$mn:00008AA5                 mov     edx, [ebp+arg_0]
.text$mn:00008AA8                 push    edx
.text$mn:00008AA9                 mov     ecx, [ebp+var_14]
.text$mn:00008AAC                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00008AB1                 mov     [ebp+var_4], 0
.text$mn:00008AB8                 mov     eax, [ebp+var_10]
.text$mn:00008ABB                 or      eax, 1
.text$mn:00008ABE                 mov     [ebp+var_10], eax
.text$mn:00008AC1                 mov     eax, [ebp+arg_0]
.text$mn:00008AC4
.text$mn:00008AC4 loc_8AC4:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00008AC4                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00008AC4                 mov     ecx, [ebp+var_C]
.text$mn:00008AC7                 mov     large fs:0, ecx
.text$mn:00008ACE                 pop     ecx
.text$mn:00008ACF                 mov     esp, ebp
.text$mn:00008AD1                 pop     ebp
.text$mn:00008AD2                 retn    8
.text$mn:00008AD2 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00008AD2
.text$mn:00008AD2 ; ---------------------------------------------------------------------------
.text$mn:00008AD5                 align 4
.text$mn:00008AD5 _text$mn        ends
.text$mn:00008AD5
.text$x:00008AD8 ; ===========================================================================
.text$x:00008AD8
.text$x:00008AD8 ; Segment type: Pure code
.text$x:00008AD8 ; Segment permissions: Read/Execute
.text$x:00008AD8 _text$x         segment para public 'CODE' use32
.text$x:00008AD8                 assume cs:_text$x
.text$x:00008AD8                 ;org 8AD8h
.text$x:00008AD8 ; COMDAT (pick associative to section at 8A48)
.text$x:00008AD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008AD8
.text$x:00008AD8 ; =============== S U B R O U T I N E =======================================
.text$x:00008AD8
.text$x:00008AD8
.text$x:00008AD8 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00008AD8                                         ; DATA XREF: .xdata$x:000091DCo
.text$x:00008AD8                 mov     eax, [ebp-10h]
.text$x:00008ADB                 and     eax, 1
.text$x:00008ADE                 jz      $LN6_0
.text$x:00008AE4                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00008AE8                 mov     ecx, [ebp+8]
.text$x:00008AEB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008AF0 ; ---------------------------------------------------------------------------
.text$x:00008AF0
.text$x:00008AF0 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008AF0                 retn
.text$x:00008AF0 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008AF0
.text$x:00008AF1
.text$x:00008AF1 ; =============== S U B R O U T I N E =======================================
.text$x:00008AF1
.text$x:00008AF1
.text$x:00008AF1 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008AF1                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00008AF1
.text$x:00008AF1 arg_4           = dword ptr  8
.text$x:00008AF1
.text$x:00008AF1                 mov     edx, [esp+arg_4]
.text$x:00008AF5                 lea     eax, [edx+0Ch]
.text$x:00008AF8                 mov     ecx, [edx-0Ch]
.text$x:00008AFB                 xor     ecx, eax
.text$x:00008AFD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008B02                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00008B07                 jmp     ___CxxFrameHandler3
.text$x:00008B07 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00008B07
.text$x:00008B07 _text$x         ends
.text$x:00008B07
.text$mn:00008B0C ; ===========================================================================
.text$mn:00008B0C
.text$mn:00008B0C ; Segment type: Pure code
.text$mn:00008B0C ; Segment permissions: Read/Execute
.text$mn:00008B0C _text$mn        segment para public 'CODE' use32
.text$mn:00008B0C                 assume cs:_text$mn
.text$mn:00008B0C                 ;org 8B0Ch
.text$mn:00008B0C ; COMDAT (pick any)
.text$mn:00008B0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008B0C
.text$mn:00008B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00008B0C
.text$mn:00008B0C ; Attributes: bp-based frame
.text$mn:00008B0C
.text$mn:00008B0C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00008B0C                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008B0C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00008B0C                                         ; DATA XREF: .rdata:0000A56Co
.text$mn:00008B0C
.text$mn:00008B0C var_1C          = dword ptr -1Ch
.text$mn:00008B0C var_18          = dword ptr -18h
.text$mn:00008B0C Str             = dword ptr -14h
.text$mn:00008B0C var_10          = dword ptr -10h
.text$mn:00008B0C var_C           = dword ptr -0Ch
.text$mn:00008B0C var_4           = dword ptr -4
.text$mn:00008B0C arg_0           = dword ptr  8
.text$mn:00008B0C arg_4           = dword ptr  0Ch
.text$mn:00008B0C
.text$mn:00008B0C                 push    ebp
.text$mn:00008B0D                 mov     ebp, esp
.text$mn:00008B0F                 push    0FFFFFFFFh
.text$mn:00008B11                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00008B16                 mov     eax, large fs:0
.text$mn:00008B1C                 push    eax
.text$mn:00008B1D                 sub     esp, 10h
.text$mn:00008B20                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00008B25                 xor     eax, ebp
.text$mn:00008B27                 push    eax
.text$mn:00008B28                 lea     eax, [ebp+var_C]
.text$mn:00008B2B                 mov     large fs:0, eax
.text$mn:00008B31                 mov     [ebp+var_1C], ecx
.text$mn:00008B34                 mov     [ebp+var_18], 0
.text$mn:00008B3B                 mov     eax, [ebp+arg_4]
.text$mn:00008B3E                 push    eax             ; int
.text$mn:00008B3F                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00008B44                 add     esp, 4
.text$mn:00008B47                 mov     [ebp+var_10], eax
.text$mn:00008B4A                 cmp     [ebp+var_10], 0
.text$mn:00008B4E                 jz      short loc_8B58
.text$mn:00008B50                 mov     ecx, [ebp+var_10]
.text$mn:00008B53                 mov     [ebp+Str], ecx
.text$mn:00008B56                 jmp     short loc_8B5F
.text$mn:00008B58 ; ---------------------------------------------------------------------------
.text$mn:00008B58
.text$mn:00008B58 loc_8B58:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00008B58                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00008B5F
.text$mn:00008B5F loc_8B5F:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00008B5F                 mov     edx, [ebp+Str]
.text$mn:00008B62                 push    edx             ; Str
.text$mn:00008B63                 mov     ecx, [ebp+arg_0]
.text$mn:00008B66                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00008B6B                 mov     [ebp+var_4], 0
.text$mn:00008B72                 mov     eax, [ebp+var_18]
.text$mn:00008B75                 or      eax, 1
.text$mn:00008B78                 mov     [ebp+var_18], eax
.text$mn:00008B7B                 mov     eax, [ebp+arg_0]
.text$mn:00008B7E                 mov     ecx, [ebp+var_C]
.text$mn:00008B81                 mov     large fs:0, ecx
.text$mn:00008B88                 pop     ecx
.text$mn:00008B89                 mov     esp, ebp
.text$mn:00008B8B                 pop     ebp
.text$mn:00008B8C                 retn    8
.text$mn:00008B8C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00008B8C
.text$mn:00008B8C ; ---------------------------------------------------------------------------
.text$mn:00008B8F                 align 10h
.text$mn:00008B8F _text$mn        ends
.text$mn:00008B8F
.text$x:00008B90 ; ===========================================================================
.text$x:00008B90
.text$x:00008B90 ; Segment type: Pure code
.text$x:00008B90 ; Segment permissions: Read/Execute
.text$x:00008B90 _text$x         segment para public 'CODE' use32
.text$x:00008B90                 assume cs:_text$x
.text$x:00008B90                 ;org 8B90h
.text$x:00008B90 ; COMDAT (pick associative to section at 8B0C)
.text$x:00008B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00008B90
.text$x:00008B90 ; =============== S U B R O U T I N E =======================================
.text$x:00008B90
.text$x:00008B90
.text$x:00008B90 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00008B90                                         ; DATA XREF: .xdata$x:00009260o
.text$x:00008B90                 mov     eax, [ebp-18h]
.text$x:00008B93                 and     eax, 1
.text$x:00008B96                 jz      $LN6_1
.text$x:00008B9C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00008BA0                 mov     ecx, [ebp+8]
.text$x:00008BA3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00008BA8 ; ---------------------------------------------------------------------------
.text$x:00008BA8
.text$x:00008BA8 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00008BA8                 retn
.text$x:00008BA8 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00008BA8
.text$x:00008BA9
.text$x:00008BA9 ; =============== S U B R O U T I N E =======================================
.text$x:00008BA9
.text$x:00008BA9
.text$x:00008BA9 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00008BA9                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00008BA9
.text$x:00008BA9 arg_4           = dword ptr  8
.text$x:00008BA9
.text$x:00008BA9                 mov     edx, [esp+arg_4]
.text$x:00008BAD                 lea     eax, [edx+0Ch]
.text$x:00008BB0                 mov     ecx, [edx-14h]
.text$x:00008BB3                 xor     ecx, eax
.text$x:00008BB5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00008BBA                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00008BBF                 jmp     ___CxxFrameHandler3
.text$x:00008BBF __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00008BBF
.text$x:00008BBF _text$x         ends
.text$x:00008BBF
.text$mn:00008BC4 ; ===========================================================================
.text$mn:00008BC4
.text$mn:00008BC4 ; Segment type: Pure code
.text$mn:00008BC4 ; Segment permissions: Read/Execute
.text$mn:00008BC4 _text$mn        segment para public 'CODE' use32
.text$mn:00008BC4                 assume cs:_text$mn
.text$mn:00008BC4                 ;org 8BC4h
.text$mn:00008BC4 ; COMDAT (pick any)
.text$mn:00008BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008BC4
.text$mn:00008BC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008BC4
.text$mn:00008BC4 ; Attributes: bp-based frame
.text$mn:00008BC4
.text$mn:00008BC4 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00008BC4                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00008BC4 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00008BC4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00008BC4
.text$mn:00008BC4 var_4           = dword ptr -4
.text$mn:00008BC4 Dst             = dword ptr  8
.text$mn:00008BC4 Src             = dword ptr  0Ch
.text$mn:00008BC4 Size            = dword ptr  10h
.text$mn:00008BC4
.text$mn:00008BC4                 push    ebp
.text$mn:00008BC5                 mov     ebp, esp
.text$mn:00008BC7                 push    ecx
.text$mn:00008BC8                 cmp     [ebp+Size], 0
.text$mn:00008BCC                 jnz     short loc_8BD6
.text$mn:00008BCE                 mov     eax, [ebp+Dst]
.text$mn:00008BD1                 mov     [ebp+var_4], eax
.text$mn:00008BD4                 jmp     short loc_8BED
.text$mn:00008BD6 ; ---------------------------------------------------------------------------
.text$mn:00008BD6
.text$mn:00008BD6 loc_8BD6:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00008BD6                 mov     ecx, [ebp+Size]
.text$mn:00008BD9                 push    ecx             ; Size
.text$mn:00008BDA                 mov     edx, [ebp+Src]
.text$mn:00008BDD                 push    edx             ; Src
.text$mn:00008BDE                 mov     eax, [ebp+Dst]
.text$mn:00008BE1                 push    eax             ; Dst
.text$mn:00008BE2                 call    _memmove
.text$mn:00008BE7                 add     esp, 0Ch
.text$mn:00008BEA                 mov     [ebp+var_4], eax
.text$mn:00008BED
.text$mn:00008BED loc_8BED:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00008BED                 mov     eax, [ebp+var_4]
.text$mn:00008BF0                 mov     esp, ebp
.text$mn:00008BF2                 pop     ebp
.text$mn:00008BF3                 retn
.text$mn:00008BF3 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00008BF3
.text$mn:00008BF3 _text$mn        ends
.text$mn:00008BF3
.text$mn:00008BF4 ; ===========================================================================
.text$mn:00008BF4
.text$mn:00008BF4 ; Segment type: Pure code
.text$mn:00008BF4 ; Segment permissions: Read/Execute
.text$mn:00008BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00008BF4                 assume cs:_text$mn
.text$mn:00008BF4                 ;org 8BF4h
.text$mn:00008BF4 ; COMDAT (pick any)
.text$mn:00008BF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008BF4
.text$mn:00008BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008BF4
.text$mn:00008BF4 ; Attributes: bp-based frame
.text$mn:00008BF4
.text$mn:00008BF4 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00008BF4                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00008BF4 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00008BF4                                         ; DATA XREF: .rdata:0000A4F4o
.text$mn:00008BF4
.text$mn:00008BF4 var_4           = dword ptr -4
.text$mn:00008BF4
.text$mn:00008BF4                 push    ebp
.text$mn:00008BF5                 mov     ebp, esp
.text$mn:00008BF7                 push    ecx
.text$mn:00008BF8                 mov     [ebp+var_4], ecx
.text$mn:00008BFB                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00008C00                 mov     esp, ebp
.text$mn:00008C02                 pop     ebp
.text$mn:00008C03                 retn
.text$mn:00008C03 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00008C03
.text$mn:00008C03 _text$mn        ends
.text$mn:00008C03
.text$mn:00008C04 ; ===========================================================================
.text$mn:00008C04
.text$mn:00008C04 ; Segment type: Pure code
.text$mn:00008C04 ; Segment permissions: Read/Execute
.text$mn:00008C04 _text$mn        segment para public 'CODE' use32
.text$mn:00008C04                 assume cs:_text$mn
.text$mn:00008C04                 ;org 8C04h
.text$mn:00008C04 ; COMDAT (pick any)
.text$mn:00008C04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008C04
.text$mn:00008C04 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C04
.text$mn:00008C04 ; Attributes: bp-based frame
.text$mn:00008C04
.text$mn:00008C04 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00008C04                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00008C04 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00008C04                                         ; DATA XREF: .rdata:0000A528o
.text$mn:00008C04
.text$mn:00008C04 var_4           = dword ptr -4
.text$mn:00008C04
.text$mn:00008C04                 push    ebp
.text$mn:00008C05                 mov     ebp, esp
.text$mn:00008C07                 push    ecx
.text$mn:00008C08                 mov     [ebp+var_4], ecx
.text$mn:00008C0B                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00008C10                 mov     esp, ebp
.text$mn:00008C12                 pop     ebp
.text$mn:00008C13                 retn
.text$mn:00008C13 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00008C13
.text$mn:00008C13 _text$mn        ends
.text$mn:00008C13
.text$mn:00008C14 ; ===========================================================================
.text$mn:00008C14
.text$mn:00008C14 ; Segment type: Pure code
.text$mn:00008C14 ; Segment permissions: Read/Execute
.text$mn:00008C14 _text$mn        segment para public 'CODE' use32
.text$mn:00008C14                 assume cs:_text$mn
.text$mn:00008C14                 ;org 8C14h
.text$mn:00008C14 ; COMDAT (pick any)
.text$mn:00008C14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008C14
.text$mn:00008C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C14
.text$mn:00008C14 ; Attributes: bp-based frame
.text$mn:00008C14
.text$mn:00008C14 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00008C14                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00008C14 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00008C14                                         ; DATA XREF: .rdata:0000A568o
.text$mn:00008C14
.text$mn:00008C14 var_4           = dword ptr -4
.text$mn:00008C14
.text$mn:00008C14                 push    ebp
.text$mn:00008C15                 mov     ebp, esp
.text$mn:00008C17                 push    ecx
.text$mn:00008C18                 mov     [ebp+var_4], ecx
.text$mn:00008C1B                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00008C20                 mov     esp, ebp
.text$mn:00008C22                 pop     ebp
.text$mn:00008C23                 retn
.text$mn:00008C23 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00008C23
.text$mn:00008C23 _text$mn        ends
.text$mn:00008C23
.text$mn:00008C24 ; ===========================================================================
.text$mn:00008C24
.text$mn:00008C24 ; Segment type: Pure code
.text$mn:00008C24 ; Segment permissions: Read/Execute
.text$mn:00008C24 _text$mn        segment para public 'CODE' use32
.text$mn:00008C24                 assume cs:_text$mn
.text$mn:00008C24                 ;org 8C24h
.text$mn:00008C24 ; COMDAT (pick any)
.text$mn:00008C24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008C24
.text$mn:00008C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00008C24
.text$mn:00008C24 ; Attributes: bp-based frame
.text$mn:00008C24
.text$mn:00008C24 ; public: void __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::push_back(unsigned char &&)
.text$mn:00008C24                 public ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z
.text$mn:00008C24 ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z proc near
.text$mn:00008C24                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+151p
.text$mn:00008C24                                         ; ClipboardHistoryPanel::getClipboadData(void)+1A1p
.text$mn:00008C24
.text$mn:00008C24 var_C           = dword ptr -0Ch
.text$mn:00008C24 var_8           = dword ptr -8
.text$mn:00008C24 var_2           = byte ptr -2
.text$mn:00008C24 var_1           = byte ptr -1
.text$mn:00008C24 arg_0           = dword ptr  8
.text$mn:00008C24
.text$mn:00008C24                 push    ebp
.text$mn:00008C25                 mov     ebp, esp
.text$mn:00008C27                 sub     esp, 0Ch
.text$mn:00008C2A                 mov     [ebp+var_8], ecx
.text$mn:00008C2D                 mov     eax, [ebp+arg_0]
.text$mn:00008C30                 push    eax
.text$mn:00008C31                 call    ??$addressof@E@std@@YAPAEAAE@Z ; std::addressof<uchar>(uchar &)
.text$mn:00008C36                 add     esp, 4
.text$mn:00008C39                 push    eax
.text$mn:00008C3A                 mov     ecx, [ebp+var_8]
.text$mn:00008C3D                 call    ?_Inside@?$vector@EV?$allocator@E@std@@@std@@IBE_NPBE@Z ; std::vector<uchar,std::allocator<uchar>>::_Inside(uchar const *)
.text$mn:00008C42                 movzx   ecx, al
.text$mn:00008C45                 test    ecx, ecx
.text$mn:00008C47                 jz      loc_8CCE
.text$mn:00008C4D                 mov     edx, [ebp+arg_0]
.text$mn:00008C50                 push    edx
.text$mn:00008C51                 call    ??$addressof@E@std@@YAPAEAAE@Z ; std::addressof<uchar>(uchar &)
.text$mn:00008C56                 add     esp, 4
.text$mn:00008C59                 mov     ecx, [ebp+var_8]
.text$mn:00008C5C                 sub     eax, [ecx+4]
.text$mn:00008C5F                 mov     [ebp+var_C], eax
.text$mn:00008C62                 mov     edx, [ebp+var_8]
.text$mn:00008C65                 mov     eax, [ebp+var_8]
.text$mn:00008C68                 mov     ecx, [edx+8]
.text$mn:00008C6B                 cmp     ecx, [eax+0Ch]
.text$mn:00008C6E                 jnz     short loc_8C7A
.text$mn:00008C70                 push    1
.text$mn:00008C72                 mov     ecx, [ebp+var_8]
.text$mn:00008C75                 call    ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)
.text$mn:00008C7A
.text$mn:00008C7A loc_8C7A:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+4Aj
.text$mn:00008C7A                 mov     edx, [ebp+var_8]
.text$mn:00008C7D                 mov     eax, [edx+8]
.text$mn:00008C80                 push    eax
.text$mn:00008C81                 mov     ecx, [ebp+var_8]
.text$mn:00008C84                 mov     edx, [ecx+8]
.text$mn:00008C87                 push    edx
.text$mn:00008C88                 mov     ecx, [ebp+var_8]
.text$mn:00008C8B                 call    ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z ; std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)
.text$mn:00008C90                 mov     eax, [ebp+var_8]
.text$mn:00008C93                 mov     ecx, [eax+4]
.text$mn:00008C96                 add     ecx, [ebp+var_C]
.text$mn:00008C99                 push    ecx
.text$mn:00008C9A                 call    ??$forward@E@std@@YA$$QAEAAE@Z ; std::forward<uchar>(uchar &)
.text$mn:00008C9F                 add     esp, 4
.text$mn:00008CA2                 push    eax             ; int
.text$mn:00008CA3                 mov     edx, [ebp+var_8]
.text$mn:00008CA6                 mov     eax, [edx+8]
.text$mn:00008CA9                 push    eax             ; void *
.text$mn:00008CAA                 lea     ecx, [ebp+var_1]
.text$mn:00008CAD                 push    ecx
.text$mn:00008CAE                 mov     ecx, [ebp+var_8]
.text$mn:00008CB1                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00008CB6                 mov     ecx, eax
.text$mn:00008CB8                 call    ??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z ; std::_Wrap_alloc<std::allocator<uchar>>::construct<uchar,uchar>(uchar *,uchar &&)
.text$mn:00008CBD                 mov     edx, [ebp+var_8]
.text$mn:00008CC0                 mov     eax, [edx+8]
.text$mn:00008CC3                 add     eax, 1
.text$mn:00008CC6                 mov     ecx, [ebp+var_8]
.text$mn:00008CC9                 mov     [ecx+8], eax
.text$mn:00008CCC                 jmp     short loc_8D32
.text$mn:00008CCE ; ---------------------------------------------------------------------------
.text$mn:00008CCE
.text$mn:00008CCE loc_8CCE:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+23j
.text$mn:00008CCE                 mov     edx, [ebp+var_8]
.text$mn:00008CD1                 mov     eax, [ebp+var_8]
.text$mn:00008CD4                 mov     ecx, [edx+8]
.text$mn:00008CD7                 cmp     ecx, [eax+0Ch]
.text$mn:00008CDA                 jnz     short loc_8CE6
.text$mn:00008CDC                 push    1
.text$mn:00008CDE                 mov     ecx, [ebp+var_8]
.text$mn:00008CE1                 call    ?_Reserve@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z ; std::vector<uchar,std::allocator<uchar>>::_Reserve(uint)
.text$mn:00008CE6
.text$mn:00008CE6 loc_8CE6:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+B6j
.text$mn:00008CE6                 mov     edx, [ebp+var_8]
.text$mn:00008CE9                 mov     eax, [edx+8]
.text$mn:00008CEC                 push    eax
.text$mn:00008CED                 mov     ecx, [ebp+var_8]
.text$mn:00008CF0                 mov     edx, [ecx+8]
.text$mn:00008CF3                 push    edx
.text$mn:00008CF4                 mov     ecx, [ebp+var_8]
.text$mn:00008CF7                 call    ?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z ; std::vector<uchar,std::allocator<uchar>>::_Orphan_range(uchar *,uchar *)
.text$mn:00008CFC                 mov     eax, [ebp+arg_0]
.text$mn:00008CFF                 push    eax
.text$mn:00008D00                 call    ??$forward@E@std@@YA$$QAEAAE@Z ; std::forward<uchar>(uchar &)
.text$mn:00008D05                 add     esp, 4
.text$mn:00008D08                 push    eax             ; int
.text$mn:00008D09                 mov     ecx, [ebp+var_8]
.text$mn:00008D0C                 mov     edx, [ecx+8]
.text$mn:00008D0F                 push    edx             ; void *
.text$mn:00008D10                 lea     eax, [ebp+var_2]
.text$mn:00008D13                 push    eax
.text$mn:00008D14                 mov     ecx, [ebp+var_8]
.text$mn:00008D17                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@E@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<uchar,std::allocator<uchar>>>::_Getal(void)
.text$mn:00008D1C                 mov     ecx, eax
.text$mn:00008D1E                 call    ??$construct@EE@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAEXPAE$$QAE@Z ; std::_Wrap_alloc<std::allocator<uchar>>::construct<uchar,uchar>(uchar *,uchar &&)
.text$mn:00008D23                 mov     ecx, [ebp+var_8]
.text$mn:00008D26                 mov     edx, [ecx+8]
.text$mn:00008D29                 add     edx, 1
.text$mn:00008D2C                 mov     eax, [ebp+var_8]
.text$mn:00008D2F                 mov     [eax+8], edx
.text$mn:00008D32
.text$mn:00008D32 loc_8D32:                               ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::push_back(uchar &&)+A8j
.text$mn:00008D32                 mov     esp, ebp
.text$mn:00008D34                 pop     ebp
.text$mn:00008D35                 retn    4
.text$mn:00008D35 ?push_back@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAE@Z endp
.text$mn:00008D35
.text$mn:00008D35 _text$mn        ends
.text$mn:00008D35
.text$mn:00008D38 ; ===========================================================================
.text$mn:00008D38
.text$mn:00008D38 ; Segment type: Pure code
.text$mn:00008D38 ; Segment permissions: Read/Execute
.text$mn:00008D38 _text$mn        segment para public 'CODE' use32
.text$mn:00008D38                 assume cs:_text$mn
.text$mn:00008D38                 ;org 8D38h
.text$mn:00008D38 ; COMDAT (pick any)
.text$mn:00008D38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008D38
.text$mn:00008D38 ; =============== S U B R O U T I N E =======================================
.text$mn:00008D38
.text$mn:00008D38 ; Attributes: bp-based frame
.text$mn:00008D38
.text$mn:00008D38 ; int __stdcall DockingDlgInterface::run_dlgProc(DockingDlgInterface *this, unsigned int, unsigned int, __int32)
.text$mn:00008D38                 public ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z
.text$mn:00008D38 ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z proc near
.text$mn:00008D38                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+424p
.text$mn:00008D38                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+43Bp
.text$mn:00008D38
.text$mn:00008D38 var_C           = dword ptr -0Ch
.text$mn:00008D38 var_8           = dword ptr -8
.text$mn:00008D38 var_4           = dword ptr -4
.text$mn:00008D38 this            = dword ptr  8
.text$mn:00008D38 arg_4           = dword ptr  0Ch
.text$mn:00008D38 arg_C           = dword ptr  14h
.text$mn:00008D38
.text$mn:00008D38                 push    ebp
.text$mn:00008D39                 mov     ebp, esp
.text$mn:00008D3B                 sub     esp, 0Ch
.text$mn:00008D3E                 mov     eax, [ebp+arg_4]
.text$mn:00008D41                 mov     [ebp+var_C], eax
.text$mn:00008D44                 cmp     [ebp+var_C], 4Eh ; 'N'
.text$mn:00008D48                 jz      short loc_8D4C
.text$mn:00008D4A                 jmp     short loc_8DAE
.text$mn:00008D4C ; ---------------------------------------------------------------------------
.text$mn:00008D4C
.text$mn:00008D4C loc_8D4C:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+10j
.text$mn:00008D4C                 mov     ecx, [ebp+arg_C]
.text$mn:00008D4F                 mov     [ebp+var_4], ecx
.text$mn:00008D52                 mov     edx, [ebp+var_4]
.text$mn:00008D55                 mov     eax, [ebp+this]
.text$mn:00008D58                 mov     ecx, [edx]
.text$mn:00008D5A                 cmp     ecx, [eax+8]
.text$mn:00008D5D                 jnz     short loc_8DAE
.text$mn:00008D5F                 mov     edx, [ebp+var_4]
.text$mn:00008D62                 mov     eax, [edx+8]
.text$mn:00008D65                 and     eax, 0FFFFh
.text$mn:00008D6A                 movzx   ecx, ax
.text$mn:00008D6D                 mov     [ebp+var_8], ecx
.text$mn:00008D70                 cmp     [ebp+var_8], 41Ch
.text$mn:00008D77                 jz      short loc_8D8F
.text$mn:00008D79                 cmp     [ebp+var_8], 41Dh
.text$mn:00008D80                 jz      short loc_8D86
.text$mn:00008D82                 jmp     short loc_8DAE
.text$mn:00008D84 ; ---------------------------------------------------------------------------
.text$mn:00008D84                 jmp     short loc_8DAE
.text$mn:00008D86 ; ---------------------------------------------------------------------------
.text$mn:00008D86
.text$mn:00008D86 loc_8D86:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+48j
.text$mn:00008D86                 mov     edx, [ebp+this]
.text$mn:00008D89                 mov     byte ptr [edx+28h], 1
.text$mn:00008D8D                 jmp     short loc_8DAE
.text$mn:00008D8F ; ---------------------------------------------------------------------------
.text$mn:00008D8F
.text$mn:00008D8F loc_8D8F:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+3Fj
.text$mn:00008D8F                 mov     eax, [ebp+var_4]
.text$mn:00008D92                 mov     ecx, [eax+8]
.text$mn:00008D95                 shr     ecx, 10h
.text$mn:00008D98                 and     ecx, 0FFFFh
.text$mn:00008D9E                 movzx   edx, cx
.text$mn:00008DA1                 mov     eax, [ebp+this]
.text$mn:00008DA4                 mov     [eax+2Ch], edx
.text$mn:00008DA7                 mov     ecx, [ebp+this]
.text$mn:00008DAA                 mov     byte ptr [ecx+28h], 0
.text$mn:00008DAE
.text$mn:00008DAE loc_8DAE:                               ; CODE XREF: DockingDlgInterface::run_dlgProc(uint,uint,long)+12j
.text$mn:00008DAE                                         ; DockingDlgInterface::run_dlgProc(uint,uint,long)+25j ...
.text$mn:00008DAE                 xor     eax, eax
.text$mn:00008DB0                 mov     esp, ebp
.text$mn:00008DB2                 pop     ebp
.text$mn:00008DB3                 retn    10h
.text$mn:00008DB3 ?run_dlgProc@DockingDlgInterface@@MAGHIIJ@Z endp
.text$mn:00008DB3
.text$mn:00008DB3 ; ---------------------------------------------------------------------------
.text$mn:00008DB6                 align 4
.text$mn:00008DB6 _text$mn        ends
.text$mn:00008DB6
.text$mn:00008DB8 ; ===========================================================================
.text$mn:00008DB8
.text$mn:00008DB8 ; Segment type: Pure code
.text$mn:00008DB8 ; Segment permissions: Read/Execute
.text$mn:00008DB8 _text$mn        segment para public 'CODE' use32
.text$mn:00008DB8                 assume cs:_text$mn
.text$mn:00008DB8                 ;org 8DB8h
.text$mn:00008DB8 ; COMDAT (pick any)
.text$mn:00008DB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008DB8
.text$mn:00008DB8 ; =============== S U B R O U T I N E =======================================
.text$mn:00008DB8
.text$mn:00008DB8 ; Attributes: bp-based frame
.text$mn:00008DB8
.text$mn:00008DB8 ; public: struct std::_Wrap_alloc<class std::allocator<unsigned char>> __thiscall std::_Wrap_alloc<class std::allocator<unsigned char>>::select_on_container_copy_construction(void)const
.text$mn:00008DB8                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBE?AU12@XZ
.text$mn:00008DB8 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00008DB8                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::vector<uchar,std::allocator<uchar>>(std::vector<uchar,std::allocator<uchar>> const &)+41p
.text$mn:00008DB8
.text$mn:00008DB8 var_8           = dword ptr -8
.text$mn:00008DB8 var_1           = byte ptr -1
.text$mn:00008DB8 arg_0           = dword ptr  8
.text$mn:00008DB8
.text$mn:00008DB8                 push    ebp
.text$mn:00008DB9                 mov     ebp, esp
.text$mn:00008DBB                 sub     esp, 8
.text$mn:00008DBE                 mov     [ebp+var_8], ecx
.text$mn:00008DC1                 mov     eax, [ebp+var_8]
.text$mn:00008DC4                 push    eax
.text$mn:00008DC5                 lea     ecx, [ebp+var_1]
.text$mn:00008DC8                 push    ecx
.text$mn:00008DC9                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z ; std::allocator_traits<std::allocator<uchar>>::select_on_container_copy_construction(std::allocator<uchar> const &)
.text$mn:00008DCE                 add     esp, 8
.text$mn:00008DD1                 push    eax
.text$mn:00008DD2                 mov     ecx, [ebp+arg_0]
.text$mn:00008DD5                 call    ??0?$_Wrap_alloc@V?$allocator@E@std@@@std@@QAE@ABV?$allocator@E@1@@Z ; std::_Wrap_alloc<std::allocator<uchar>>::_Wrap_alloc<std::allocator<uchar>>(std::allocator<uchar> const &)
.text$mn:00008DDA                 mov     eax, [ebp+arg_0]
.text$mn:00008DDD                 mov     esp, ebp
.text$mn:00008DDF                 pop     ebp
.text$mn:00008DE0                 retn    4
.text$mn:00008DE0 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@E@std@@@std@@QBE?AU12@XZ endp
.text$mn:00008DE0
.text$mn:00008DE0 ; ---------------------------------------------------------------------------
.text$mn:00008DE3                 align 4
.text$mn:00008DE3 _text$mn        ends
.text$mn:00008DE3
.text$mn:00008DE4 ; ===========================================================================
.text$mn:00008DE4
.text$mn:00008DE4 ; Segment type: Pure code
.text$mn:00008DE4 ; Segment permissions: Read/Execute
.text$mn:00008DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00008DE4                 assume cs:_text$mn
.text$mn:00008DE4                 ;org 8DE4h
.text$mn:00008DE4 ; COMDAT (pick any)
.text$mn:00008DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008DE4
.text$mn:00008DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00008DE4
.text$mn:00008DE4 ; Attributes: bp-based frame
.text$mn:00008DE4
.text$mn:00008DE4 ; public: class std::allocator<unsigned char> __thiscall std::allocator<unsigned char>::select_on_container_copy_construction(void)const
.text$mn:00008DE4                 public ?select_on_container_copy_construction@?$allocator@E@std@@QBE?AV12@XZ
.text$mn:00008DE4 ?select_on_container_copy_construction@?$allocator@E@std@@QBE?AV12@XZ proc near
.text$mn:00008DE4                                         ; CODE XREF: std::allocator_traits<std::allocator<uchar>>::select_on_container_copy_construction(std::allocator<uchar> const &)+Ap
.text$mn:00008DE4
.text$mn:00008DE4 var_4           = dword ptr -4
.text$mn:00008DE4 arg_0           = dword ptr  8
.text$mn:00008DE4
.text$mn:00008DE4                 push    ebp
.text$mn:00008DE5                 mov     ebp, esp
.text$mn:00008DE7                 push    ecx
.text$mn:00008DE8                 mov     [ebp+var_4], ecx
.text$mn:00008DEB                 mov     eax, [ebp+var_4]
.text$mn:00008DEE                 push    eax
.text$mn:00008DEF                 mov     ecx, [ebp+arg_0]
.text$mn:00008DF2                 call    ??0?$allocator@E@std@@QAE@ABV01@@Z ; std::allocator<uchar>::allocator<uchar>(std::allocator<uchar> const &)
.text$mn:00008DF7                 mov     eax, [ebp+arg_0]
.text$mn:00008DFA                 mov     esp, ebp
.text$mn:00008DFC                 pop     ebp
.text$mn:00008DFD                 retn    4
.text$mn:00008DFD ?select_on_container_copy_construction@?$allocator@E@std@@QBE?AV12@XZ endp
.text$mn:00008DFD
.text$mn:00008DFD _text$mn        ends
.text$mn:00008DFD
.text$mn:00008E00 ; ===========================================================================
.text$mn:00008E00
.text$mn:00008E00 ; Segment type: Pure code
.text$mn:00008E00 ; Segment permissions: Read/Execute
.text$mn:00008E00 _text$mn        segment para public 'CODE' use32
.text$mn:00008E00                 assume cs:_text$mn
.text$mn:00008E00                 ;org 8E00h
.text$mn:00008E00 ; COMDAT (pick any)
.text$mn:00008E00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E00
.text$mn:00008E00 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E00
.text$mn:00008E00 ; Attributes: bp-based frame
.text$mn:00008E00
.text$mn:00008E00 ; public: static class std::allocator<unsigned char> __cdecl std::allocator_traits<class std::allocator<unsigned char>>::select_on_container_copy_construction(class std::allocator<unsigned char> const &)
.text$mn:00008E00                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z
.text$mn:00008E00 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z proc near
.text$mn:00008E00                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<uchar>>::select_on_container_copy_construction(void)+11p
.text$mn:00008E00
.text$mn:00008E00 arg_0           = dword ptr  8
.text$mn:00008E00 arg_4           = dword ptr  0Ch
.text$mn:00008E00
.text$mn:00008E00                 push    ebp
.text$mn:00008E01                 mov     ebp, esp
.text$mn:00008E03                 mov     eax, [ebp+arg_0]
.text$mn:00008E06                 push    eax
.text$mn:00008E07                 mov     ecx, [ebp+arg_4]
.text$mn:00008E0A                 call    ?select_on_container_copy_construction@?$allocator@E@std@@QBE?AV12@XZ ; std::allocator<uchar>::select_on_container_copy_construction(void)
.text$mn:00008E0F                 mov     eax, [ebp+arg_0]
.text$mn:00008E12                 pop     ebp
.text$mn:00008E13                 retn
.text$mn:00008E13 ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@E@std@@@std@@SA?AV?$allocator@E@2@ABV32@@Z endp
.text$mn:00008E13
.text$mn:00008E13 _text$mn        ends
.text$mn:00008E13
.text$mn:00008E14 ; ===========================================================================
.text$mn:00008E14
.text$mn:00008E14 ; Segment type: Pure code
.text$mn:00008E14 ; Segment permissions: Read/Execute
.text$mn:00008E14 _text$mn        segment para public 'CODE' use32
.text$mn:00008E14                 assume cs:_text$mn
.text$mn:00008E14                 ;org 8E14h
.text$mn:00008E14 ; COMDAT (pick any)
.text$mn:00008E14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E14
.text$mn:00008E14 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E14
.text$mn:00008E14 ; Attributes: bp-based frame
.text$mn:00008E14
.text$mn:00008E14 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00008E14                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00008E14 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00008E14                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00008E14                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00008E14
.text$mn:00008E14 var_4           = dword ptr -4
.text$mn:00008E14
.text$mn:00008E14                 push    ebp
.text$mn:00008E15                 mov     ebp, esp
.text$mn:00008E17                 push    ecx
.text$mn:00008E18                 mov     [ebp+var_4], ecx
.text$mn:00008E1B                 mov     eax, [ebp+var_4]
.text$mn:00008E1E                 mov     eax, [eax+14h]
.text$mn:00008E21                 mov     esp, ebp
.text$mn:00008E23                 pop     ebp
.text$mn:00008E24                 retn
.text$mn:00008E24 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00008E24
.text$mn:00008E24 ; ---------------------------------------------------------------------------
.text$mn:00008E25                 align 4
.text$mn:00008E25 _text$mn        ends
.text$mn:00008E25
.text$mn:00008E28 ; ===========================================================================
.text$mn:00008E28
.text$mn:00008E28 ; Segment type: Pure code
.text$mn:00008E28 ; Segment permissions: Read/Execute
.text$mn:00008E28 _text$mn        segment para public 'CODE' use32
.text$mn:00008E28                 assume cs:_text$mn
.text$mn:00008E28                 ;org 8E28h
.text$mn:00008E28 ; COMDAT (pick any)
.text$mn:00008E28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E28
.text$mn:00008E28 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E28
.text$mn:00008E28 ; Attributes: bp-based frame
.text$mn:00008E28
.text$mn:00008E28 ; public: unsigned int __thiscall std::vector<unsigned char, class std::allocator<unsigned char>>::size(void)const
.text$mn:00008E28                 public ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ
.text$mn:00008E28 ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ proc near
.text$mn:00008E28                                         ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+32p
.text$mn:00008E28                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+3Ep ...
.text$mn:00008E28
.text$mn:00008E28 var_4           = dword ptr -4
.text$mn:00008E28
.text$mn:00008E28                 push    ebp
.text$mn:00008E29                 mov     ebp, esp
.text$mn:00008E2B                 push    ecx
.text$mn:00008E2C                 mov     [ebp+var_4], ecx
.text$mn:00008E2F                 mov     eax, [ebp+var_4]
.text$mn:00008E32                 mov     ecx, [ebp+var_4]
.text$mn:00008E35                 mov     eax, [eax+8]
.text$mn:00008E38                 sub     eax, [ecx+4]
.text$mn:00008E3B                 mov     esp, ebp
.text$mn:00008E3D                 pop     ebp
.text$mn:00008E3E                 retn
.text$mn:00008E3E ?size@?$vector@EV?$allocator@E@std@@@std@@QBEIXZ endp
.text$mn:00008E3E
.text$mn:00008E3E ; ---------------------------------------------------------------------------
.text$mn:00008E3F                 align 10h
.text$mn:00008E3F _text$mn        ends
.text$mn:00008E3F
.text$mn:00008E40 ; ===========================================================================
.text$mn:00008E40
.text$mn:00008E40 ; Segment type: Pure code
.text$mn:00008E40 ; Segment permissions: Read/Execute
.text$mn:00008E40 _text$mn        segment para public 'CODE' use32
.text$mn:00008E40                 assume cs:_text$mn
.text$mn:00008E40                 ;org 8E40h
.text$mn:00008E40 ; COMDAT (pick any)
.text$mn:00008E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E40
.text$mn:00008E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E40
.text$mn:00008E40 ; Attributes: bp-based frame
.text$mn:00008E40
.text$mn:00008E40 ; public: unsigned int __thiscall std::vector<class std::vector<unsigned char, class std::allocator<unsigned char>>, class std::allocator<class std::vector<unsigned char, class std::allocator<unsigned char>>>>::size(void)const
.text$mn:00008E40                 public ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ
.text$mn:00008E40 ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ proc near
.text$mn:00008E40                                         ; CODE XREF: ClipboardHistoryPanel::getClipboardDataIndex(std::vector<uchar,std::allocator<uchar>>)+48p
.text$mn:00008E40                                         ; ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+2Ep ...
.text$mn:00008E40
.text$mn:00008E40 var_4           = dword ptr -4
.text$mn:00008E40
.text$mn:00008E40                 push    ebp
.text$mn:00008E41                 mov     ebp, esp
.text$mn:00008E43                 push    ecx
.text$mn:00008E44                 mov     [ebp+var_4], ecx
.text$mn:00008E47                 mov     eax, [ebp+var_4]
.text$mn:00008E4A                 mov     ecx, [ebp+var_4]
.text$mn:00008E4D                 mov     eax, [eax+8]
.text$mn:00008E50                 sub     eax, [ecx+4]
.text$mn:00008E53                 sar     eax, 4
.text$mn:00008E56                 mov     esp, ebp
.text$mn:00008E58                 pop     ebp
.text$mn:00008E59                 retn
.text$mn:00008E59 ?size@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBEIXZ endp
.text$mn:00008E59
.text$mn:00008E59 ; ---------------------------------------------------------------------------
.text$mn:00008E5A                 align 4
.text$mn:00008E5A _text$mn        ends
.text$mn:00008E5A
.text$mn:00008E5C ; ===========================================================================
.text$mn:00008E5C
.text$mn:00008E5C ; Segment type: Pure code
.text$mn:00008E5C ; Segment permissions: Read/Execute
.text$mn:00008E5C _text$mn        segment para public 'CODE' use32
.text$mn:00008E5C                 assume cs:_text$mn
.text$mn:00008E5C                 ;org 8E5Ch
.text$mn:00008E5C ; COMDAT (pick any)
.text$mn:00008E5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E5C
.text$mn:00008E5C ; =============== S U B R O U T I N E =======================================
.text$mn:00008E5C
.text$mn:00008E5C ; Attributes: bp-based frame
.text$mn:00008E5C
.text$mn:00008E5C ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00008E5C                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00008E5C ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00008E5C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_8260p
.text$mn:00008E5C                 push    ebp
.text$mn:00008E5D                 mov     ebp, esp
.text$mn:00008E5F                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00008E64                 pop     ebp
.text$mn:00008E65                 retn
.text$mn:00008E65 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00008E65
.text$mn:00008E65 ; ---------------------------------------------------------------------------
.text$mn:00008E66                 align 4
.text$mn:00008E66 _text$mn        ends
.text$mn:00008E66
.text$mn:00008E68 ; ===========================================================================
.text$mn:00008E68
.text$mn:00008E68 ; Segment type: Pure code
.text$mn:00008E68 ; Segment permissions: Read/Execute
.text$mn:00008E68 _text$mn        segment para public 'CODE' use32
.text$mn:00008E68                 assume cs:_text$mn
.text$mn:00008E68                 ;org 8E68h
.text$mn:00008E68 ; COMDAT (pick any)
.text$mn:00008E68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E68
.text$mn:00008E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E68
.text$mn:00008E68 ; Attributes: bp-based frame
.text$mn:00008E68
.text$mn:00008E68 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00008E68                 public ?value@error_code@std@@QBEHXZ
.text$mn:00008E68 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00008E68
.text$mn:00008E68 var_4           = dword ptr -4
.text$mn:00008E68
.text$mn:00008E68                 push    ebp
.text$mn:00008E69                 mov     ebp, esp
.text$mn:00008E6B                 push    ecx
.text$mn:00008E6C                 mov     [ebp+var_4], ecx
.text$mn:00008E6F                 mov     eax, [ebp+var_4]
.text$mn:00008E72                 mov     eax, [eax]
.text$mn:00008E74                 mov     esp, ebp
.text$mn:00008E76                 pop     ebp
.text$mn:00008E77                 retn
.text$mn:00008E77 ?value@error_code@std@@QBEHXZ endp
.text$mn:00008E77
.text$mn:00008E77 _text$mn        ends
.text$mn:00008E77
.text$mn:00008E78 ; ===========================================================================
.text$mn:00008E78
.text$mn:00008E78 ; Segment type: Pure code
.text$mn:00008E78 ; Segment permissions: Read/Execute
.text$mn:00008E78 _text$mn        segment para public 'CODE' use32
.text$mn:00008E78                 assume cs:_text$mn
.text$mn:00008E78                 ;org 8E78h
.text$mn:00008E78 ; COMDAT (pick any)
.text$mn:00008E78                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E78
.text$mn:00008E78 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E78
.text$mn:00008E78 ; Attributes: bp-based frame
.text$mn:00008E78
.text$mn:00008E78 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00008E78                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00008E78 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00008E78                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00008E78                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00008E78
.text$mn:00008E78 var_4           = dword ptr -4
.text$mn:00008E78
.text$mn:00008E78                 push    ebp
.text$mn:00008E79                 mov     ebp, esp
.text$mn:00008E7B                 push    ecx
.text$mn:00008E7C                 mov     [ebp+var_4], ecx
.text$mn:00008E7F                 mov     eax, [ebp+var_4]
.text$mn:00008E82                 mov     eax, [eax]
.text$mn:00008E84                 mov     esp, ebp
.text$mn:00008E86                 pop     ebp
.text$mn:00008E87                 retn
.text$mn:00008E87 ?value@error_condition@std@@QBEHXZ endp
.text$mn:00008E87
.text$mn:00008E87 _text$mn        ends
.text$mn:00008E87
.text$mn:00008E88 ; ===========================================================================
.text$mn:00008E88
.text$mn:00008E88 ; Segment type: Pure code
.text$mn:00008E88 ; Segment permissions: Read/Execute
.text$mn:00008E88 _text$mn        segment para public 'CODE' use32
.text$mn:00008E88                 assume cs:_text$mn
.text$mn:00008E88                 ;org 8E88h
.text$mn:00008E88 ; COMDAT (pick any)
.text$mn:00008E88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00008E88
.text$mn:00008E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00008E88
.text$mn:00008E88 ; Attributes: bp-based frame
.text$mn:00008E88
.text$mn:00008E88                 public _hypot
.text$mn:00008E88 _hypot          proc near
.text$mn:00008E88
.text$mn:00008E88 var_10          = qword ptr -10h
.text$mn:00008E88 var_8           = qword ptr -8
.text$mn:00008E88 arg_0           = qword ptr  8
.text$mn:00008E88 arg_8           = qword ptr  10h
.text$mn:00008E88
.text$mn:00008E88                 push    ebp
.text$mn:00008E89                 mov     ebp, esp
.text$mn:00008E8B                 sub     esp, 8
.text$mn:00008E8E                 movsd   xmm0, [ebp+arg_8]
.text$mn:00008E93                 movsd   [esp+8+var_8], xmm0
.text$mn:00008E98                 sub     esp, 8
.text$mn:00008E9B                 movsd   xmm0, [ebp+arg_0]
.text$mn:00008EA0                 movsd   [esp+10h+var_10], xmm0
.text$mn:00008EA5                 call    __hypot
.text$mn:00008EAA                 add     esp, 10h
.text$mn:00008EAD                 pop     ebp
.text$mn:00008EAE                 retn
.text$mn:00008EAE _hypot          endp
.text$mn:00008EAE
.text$mn:00008EAE ; ---------------------------------------------------------------------------
.text$mn:00008EAF                 align 10h
.text$mn:00008EAF _text$mn        ends
.text$mn:00008EAF
.xdata$x:00008EB0 ; ===========================================================================
.xdata$x:00008EB0
.xdata$x:00008EB0 ; Segment type: Pure data
.xdata$x:00008EB0 ; Segment permissions: Read
.xdata$x:00008EB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008EB0                 assume cs:_xdata$x
.xdata$x:00008EB0                 ;org 8EB0h
.xdata$x:00008EB0 ; COMDAT (pick associative to section at 73A0)
.xdata$x:00008EB0 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00008EB0                                         ; DATA XREF: .xdata$x:00008EC0o
.xdata$x:00008EB1                 db 0FFh
.xdata$x:00008EB2                 db 0FFh
.xdata$x:00008EB3                 db 0FFh
.xdata$x:00008EB4                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00008EB8 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00008EB8                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00008EB9                 db    5
.xdata$x:00008EBA                 db  93h ; ô
.xdata$x:00008EBB                 db  19h
.xdata$x:00008EBC                 db    1
.xdata$x:00008EBD                 db    0
.xdata$x:00008EBE                 db    0
.xdata$x:00008EBF                 db    0
.xdata$x:00008EC0                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00008EC4                 db    0
.xdata$x:00008EC5                 db    0
.xdata$x:00008EC6                 db    0
.xdata$x:00008EC7                 db    0
.xdata$x:00008EC8                 db    0
.xdata$x:00008EC9                 db    0
.xdata$x:00008ECA                 db    0
.xdata$x:00008ECB                 db    0
.xdata$x:00008ECC                 db    0
.xdata$x:00008ECD                 db    0
.xdata$x:00008ECE                 db    0
.xdata$x:00008ECF                 db    0
.xdata$x:00008ED0                 db    0
.xdata$x:00008ED1                 db    0
.xdata$x:00008ED2                 db    0
.xdata$x:00008ED3                 db    0
.xdata$x:00008ED4                 db    0
.xdata$x:00008ED5                 db    0
.xdata$x:00008ED6                 db    0
.xdata$x:00008ED7                 db    0
.xdata$x:00008ED8                 db    0
.xdata$x:00008ED9                 db    0
.xdata$x:00008EDA                 db    0
.xdata$x:00008EDB                 db    0
.xdata$x:00008EDB _xdata$x        ends
.xdata$x:00008EDB
.xdata$x:00008EDC ; ===========================================================================
.xdata$x:00008EDC
.xdata$x:00008EDC ; Segment type: Pure data
.xdata$x:00008EDC ; Segment permissions: Read
.xdata$x:00008EDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008EDC                 assume cs:_xdata$x
.xdata$x:00008EDC                 ;org 8EDCh
.xdata$x:00008EDC ; COMDAT (pick associative to section at 7838)
.xdata$x:00008EDC __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db 0FFh
.xdata$x:00008EDC                                         ; DATA XREF: .xdata$x:00008EECo
.xdata$x:00008EDD                 db 0FFh
.xdata$x:00008EDE                 db 0FFh
.xdata$x:00008EDF                 db 0FFh
.xdata$x:00008EE0                 dd offset __unwindfunclet$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z$0
.xdata$x:00008EE4 __ehfuncinfo$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z db  22h ; "
.xdata$x:00008EE4                                         ; DATA XREF: __ehhandler$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z+11o
.xdata$x:00008EE5                 db    5
.xdata$x:00008EE6                 db  93h ; ô
.xdata$x:00008EE7                 db  19h
.xdata$x:00008EE8                 db    1
.xdata$x:00008EE9                 db    0
.xdata$x:00008EEA                 db    0
.xdata$x:00008EEB                 db    0
.xdata$x:00008EEC                 dd offset __unwindtable$?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
.xdata$x:00008EF0                 db    0
.xdata$x:00008EF1                 db    0
.xdata$x:00008EF2                 db    0
.xdata$x:00008EF3                 db    0
.xdata$x:00008EF4                 db    0
.xdata$x:00008EF5                 db    0
.xdata$x:00008EF6                 db    0
.xdata$x:00008EF7                 db    0
.xdata$x:00008EF8                 db    0
.xdata$x:00008EF9                 db    0
.xdata$x:00008EFA                 db    0
.xdata$x:00008EFB                 db    0
.xdata$x:00008EFC                 db    0
.xdata$x:00008EFD                 db    0
.xdata$x:00008EFE                 db    0
.xdata$x:00008EFF                 db    0
.xdata$x:00008F00                 db    0
.xdata$x:00008F01                 db    0
.xdata$x:00008F02                 db    0
.xdata$x:00008F03                 db    0
.xdata$x:00008F04                 db    0
.xdata$x:00008F05                 db    0
.xdata$x:00008F06                 db    0
.xdata$x:00008F07                 db    0
.xdata$x:00008F07 _xdata$x        ends
.xdata$x:00008F07
.xdata$x:00008F08 ; ===========================================================================
.xdata$x:00008F08
.xdata$x:00008F08 ; Segment type: Pure data
.xdata$x:00008F08 ; Segment permissions: Read
.xdata$x:00008F08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F08                 assume cs:_xdata$x
.xdata$x:00008F08                 ;org 8F08h
.xdata$x:00008F08 ; COMDAT (pick associative to section at 5B44)
.xdata$x:00008F08 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00008F08                                         ; DATA XREF: .xdata$x:00008F18o
.xdata$x:00008F09                 db 0FFh
.xdata$x:00008F0A                 db 0FFh
.xdata$x:00008F0B                 db 0FFh
.xdata$x:00008F0C                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:00008F10 __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:00008F10                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:00008F11                 db    5
.xdata$x:00008F12                 db  93h ; ô
.xdata$x:00008F13                 db  19h
.xdata$x:00008F14                 db    1
.xdata$x:00008F15                 db    0
.xdata$x:00008F16                 db    0
.xdata$x:00008F17                 db    0
.xdata$x:00008F18                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00008F1C                 db    0
.xdata$x:00008F1D                 db    0
.xdata$x:00008F1E                 db    0
.xdata$x:00008F1F                 db    0
.xdata$x:00008F20                 db    0
.xdata$x:00008F21                 db    0
.xdata$x:00008F22                 db    0
.xdata$x:00008F23                 db    0
.xdata$x:00008F24                 db    0
.xdata$x:00008F25                 db    0
.xdata$x:00008F26                 db    0
.xdata$x:00008F27                 db    0
.xdata$x:00008F28                 db    0
.xdata$x:00008F29                 db    0
.xdata$x:00008F2A                 db    0
.xdata$x:00008F2B                 db    0
.xdata$x:00008F2C                 db    0
.xdata$x:00008F2D                 db    0
.xdata$x:00008F2E                 db    0
.xdata$x:00008F2F                 db    0
.xdata$x:00008F30                 db    0
.xdata$x:00008F31                 db    0
.xdata$x:00008F32                 db    0
.xdata$x:00008F33                 db    0
.xdata$x:00008F33 _xdata$x        ends
.xdata$x:00008F33
.xdata$x:00008F34 ; ===========================================================================
.xdata$x:00008F34
.xdata$x:00008F34 ; Segment type: Pure data
.xdata$x:00008F34 ; Segment permissions: Read
.xdata$x:00008F34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F34                 assume cs:_xdata$x
.xdata$x:00008F34                 ;org 8F34h
.xdata$x:00008F34 ; COMDAT (pick associative to section at 5784)
.xdata$x:00008F34 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00008F34                                         ; DATA XREF: .xdata$x:00008F44o
.xdata$x:00008F35                 db 0FFh
.xdata$x:00008F36                 db 0FFh
.xdata$x:00008F37                 db 0FFh
.xdata$x:00008F38                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00008F3C __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00008F3C                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00008F3D                 db    5
.xdata$x:00008F3E                 db  93h ; ô
.xdata$x:00008F3F                 db  19h
.xdata$x:00008F40                 db    1
.xdata$x:00008F41                 db    0
.xdata$x:00008F42                 db    0
.xdata$x:00008F43                 db    0
.xdata$x:00008F44                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00008F48                 align 20h
.xdata$x:00008F48 _xdata$x        ends
.xdata$x:00008F48
.xdata$x:00008F60 ; ===========================================================================
.xdata$x:00008F60
.xdata$x:00008F60 ; Segment type: Pure data
.xdata$x:00008F60 ; Segment permissions: Read
.xdata$x:00008F60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F60                 assume cs:_xdata$x
.xdata$x:00008F60                 ;org 8F60h
.xdata$x:00008F60 ; COMDAT (pick associative to section at 6398)
.xdata$x:00008F60 __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:00008F60                                         ; DATA XREF: .xdata$x:00008F78o
.xdata$x:00008F61                 db 0FFh
.xdata$x:00008F62                 db 0FFh
.xdata$x:00008F63                 db 0FFh
.xdata$x:00008F64                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:00008F68                 db 0FFh
.xdata$x:00008F69                 db 0FFh
.xdata$x:00008F6A                 db 0FFh
.xdata$x:00008F6B                 db 0FFh
.xdata$x:00008F6C                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:00008F70 __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:00008F70                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:00008F71                 db    5
.xdata$x:00008F72                 db  93h ; ô
.xdata$x:00008F73                 db  19h
.xdata$x:00008F74                 db    2
.xdata$x:00008F75                 db    0
.xdata$x:00008F76                 db    0
.xdata$x:00008F77                 db    0
.xdata$x:00008F78                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:00008F7C                 db    0
.xdata$x:00008F7D                 db    0
.xdata$x:00008F7E                 db    0
.xdata$x:00008F7F                 db    0
.xdata$x:00008F80                 db    0
.xdata$x:00008F81                 db    0
.xdata$x:00008F82                 db    0
.xdata$x:00008F83                 db    0
.xdata$x:00008F84                 db    0
.xdata$x:00008F85                 db    0
.xdata$x:00008F86                 db    0
.xdata$x:00008F87                 db    0
.xdata$x:00008F88                 db    0
.xdata$x:00008F89                 db    0
.xdata$x:00008F8A                 db    0
.xdata$x:00008F8B                 db    0
.xdata$x:00008F8C                 db    0
.xdata$x:00008F8D                 db    0
.xdata$x:00008F8E                 db    0
.xdata$x:00008F8F                 db    0
.xdata$x:00008F90                 db    0
.xdata$x:00008F91                 db    0
.xdata$x:00008F92                 db    0
.xdata$x:00008F93                 db    0
.xdata$x:00008F93 _xdata$x        ends
.xdata$x:00008F93
.xdata$x:00008F94 ; ===========================================================================
.xdata$x:00008F94
.xdata$x:00008F94 ; Segment type: Pure data
.xdata$x:00008F94 ; Segment permissions: Read
.xdata$x:00008F94 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008F94                 assume cs:_xdata$x
.xdata$x:00008F94                 ;org 8F94h
.xdata$x:00008F94 ; COMDAT (pick associative to section at 4310)
.xdata$x:00008F94 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008F94                                         ; DATA XREF: .xdata$x:00008FA4o
.xdata$x:00008F95                 db 0FFh
.xdata$x:00008F96                 db 0FFh
.xdata$x:00008F97                 db 0FFh
.xdata$x:00008F98                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00008F9C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008F9C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00008F9D                 db    5
.xdata$x:00008F9E                 db  93h ; ô
.xdata$x:00008F9F                 db  19h
.xdata$x:00008FA0                 db    1
.xdata$x:00008FA1                 db    0
.xdata$x:00008FA2                 db    0
.xdata$x:00008FA3                 db    0
.xdata$x:00008FA4                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00008FA8                 align 20h
.xdata$x:00008FA8 _xdata$x        ends
.xdata$x:00008FA8
.xdata$x:00008FC0 ; ===========================================================================
.xdata$x:00008FC0
.xdata$x:00008FC0 ; Segment type: Pure data
.xdata$x:00008FC0 ; Segment permissions: Read
.xdata$x:00008FC0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008FC0                 assume cs:_xdata$x
.xdata$x:00008FC0                 ;org 8FC0h
.xdata$x:00008FC0 ; COMDAT (pick associative to section at 5168)
.xdata$x:00008FC0 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00008FC0                                         ; DATA XREF: .xdata$x:00008FD0o
.xdata$x:00008FC1                 db 0FFh
.xdata$x:00008FC2                 db 0FFh
.xdata$x:00008FC3                 db 0FFh
.xdata$x:00008FC4                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00008FC8 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00008FC8                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00008FC9                 db    5
.xdata$x:00008FCA                 db  93h ; ô
.xdata$x:00008FCB                 db  19h
.xdata$x:00008FCC                 db    1
.xdata$x:00008FCD                 db    0
.xdata$x:00008FCE                 db    0
.xdata$x:00008FCF                 db    0
.xdata$x:00008FD0                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00008FD4                 db    0
.xdata$x:00008FD5                 db    0
.xdata$x:00008FD6                 db    0
.xdata$x:00008FD7                 db    0
.xdata$x:00008FD8                 db    0
.xdata$x:00008FD9                 db    0
.xdata$x:00008FDA                 db    0
.xdata$x:00008FDB                 db    0
.xdata$x:00008FDC                 db    0
.xdata$x:00008FDD                 db    0
.xdata$x:00008FDE                 db    0
.xdata$x:00008FDF                 db    0
.xdata$x:00008FE0                 db    0
.xdata$x:00008FE1                 db    0
.xdata$x:00008FE2                 db    0
.xdata$x:00008FE3                 db    0
.xdata$x:00008FE4                 db    0
.xdata$x:00008FE5                 db    0
.xdata$x:00008FE6                 db    0
.xdata$x:00008FE7                 db    0
.xdata$x:00008FE8                 db    0
.xdata$x:00008FE9                 db    0
.xdata$x:00008FEA                 db    0
.xdata$x:00008FEB                 db    0
.xdata$x:00008FEB _xdata$x        ends
.xdata$x:00008FEB
.xdata$x:00008FEC ; ===========================================================================
.xdata$x:00008FEC
.xdata$x:00008FEC ; Segment type: Pure data
.xdata$x:00008FEC ; Segment permissions: Read
.xdata$x:00008FEC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00008FEC                 assume cs:_xdata$x
.xdata$x:00008FEC                 ;org 8FECh
.xdata$x:00008FEC ; COMDAT (pick associative to section at 4294)
.xdata$x:00008FEC __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00008FEC                                         ; DATA XREF: .xdata$x:00008FFCo
.xdata$x:00008FED                 db 0FFh
.xdata$x:00008FEE                 db 0FFh
.xdata$x:00008FEF                 db 0FFh
.xdata$x:00008FF0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00008FF4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00008FF4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00008FF5                 db    5
.xdata$x:00008FF6                 db  93h ; ô
.xdata$x:00008FF7                 db  19h
.xdata$x:00008FF8                 db    1
.xdata$x:00008FF9                 db    0
.xdata$x:00008FFA                 db    0
.xdata$x:00008FFB                 db    0
.xdata$x:00008FFC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00009000                 db    0
.xdata$x:00009001                 db    0
.xdata$x:00009002                 db    0
.xdata$x:00009003                 db    0
.xdata$x:00009004                 db    0
.xdata$x:00009005                 db    0
.xdata$x:00009006                 db    0
.xdata$x:00009007                 db    0
.xdata$x:00009008                 db    0
.xdata$x:00009009                 db    0
.xdata$x:0000900A                 db    0
.xdata$x:0000900B                 db    0
.xdata$x:0000900C                 db    0
.xdata$x:0000900D                 db    0
.xdata$x:0000900E                 db    0
.xdata$x:0000900F                 db    0
.xdata$x:00009010                 db    0
.xdata$x:00009011                 db    0
.xdata$x:00009012                 db    0
.xdata$x:00009013                 db    0
.xdata$x:00009014                 db    0
.xdata$x:00009015                 db    0
.xdata$x:00009016                 db    0
.xdata$x:00009017                 db    0
.xdata$x:00009017 _xdata$x        ends
.xdata$x:00009017
.xdata$x:00009018 ; ===========================================================================
.xdata$x:00009018
.xdata$x:00009018 ; Segment type: Pure data
.xdata$x:00009018 ; Segment permissions: Read
.xdata$x:00009018 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009018                 assume cs:_xdata$x
.xdata$x:00009018                 ;org 9018h
.xdata$x:00009018 ; COMDAT (pick associative to section at 50F0)
.xdata$x:00009018 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009018                                         ; DATA XREF: .xdata$x:00009028o
.xdata$x:00009019                 db 0FFh
.xdata$x:0000901A                 db 0FFh
.xdata$x:0000901B                 db 0FFh
.xdata$x:0000901C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009020 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009020                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009021                 db    5
.xdata$x:00009022                 db  93h ; ô
.xdata$x:00009023                 db  19h
.xdata$x:00009024                 db    1
.xdata$x:00009025                 db    0
.xdata$x:00009026                 db    0
.xdata$x:00009027                 db    0
.xdata$x:00009028                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:0000902C                 db    0
.xdata$x:0000902D                 db    0
.xdata$x:0000902E                 db    0
.xdata$x:0000902F                 db    0
.xdata$x:00009030                 db    0
.xdata$x:00009031                 db    0
.xdata$x:00009032                 db    0
.xdata$x:00009033                 db    0
.xdata$x:00009034                 db    0
.xdata$x:00009035                 db    0
.xdata$x:00009036                 db    0
.xdata$x:00009037                 db    0
.xdata$x:00009038                 db    0
.xdata$x:00009039                 db    0
.xdata$x:0000903A                 db    0
.xdata$x:0000903B                 db    0
.xdata$x:0000903C                 db    0
.xdata$x:0000903D                 db    0
.xdata$x:0000903E                 db    0
.xdata$x:0000903F                 db    0
.xdata$x:00009040                 db    0
.xdata$x:00009041                 db    0
.xdata$x:00009042                 db    0
.xdata$x:00009043                 db    0
.xdata$x:00009043 _xdata$x        ends
.xdata$x:00009043
.xdata$x:00009044 ; ===========================================================================
.xdata$x:00009044
.xdata$x:00009044 ; Segment type: Pure data
.xdata$x:00009044 ; Segment permissions: Read
.xdata$x:00009044 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009044                 assume cs:_xdata$x
.xdata$x:00009044                 ;org 9044h
.xdata$x:00009044 ; COMDAT (pick associative to section at 4978)
.xdata$x:00009044 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00009044                                         ; DATA XREF: .xdata$x:00009054o
.xdata$x:00009045                 db 0FFh
.xdata$x:00009046                 db 0FFh
.xdata$x:00009047                 db 0FFh
.xdata$x:00009048                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:0000904C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000904C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:0000904D                 db    5
.xdata$x:0000904E                 db  93h ; ô
.xdata$x:0000904F                 db  19h
.xdata$x:00009050                 db    1
.xdata$x:00009051                 db    0
.xdata$x:00009052                 db    0
.xdata$x:00009053                 db    0
.xdata$x:00009054                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00009058                 db    0
.xdata$x:00009059                 db    0
.xdata$x:0000905A                 db    0
.xdata$x:0000905B                 db    0
.xdata$x:0000905C                 db    0
.xdata$x:0000905D                 db    0
.xdata$x:0000905E                 db    0
.xdata$x:0000905F                 db    0
.xdata$x:00009060                 db    0
.xdata$x:00009061                 db    0
.xdata$x:00009062                 db    0
.xdata$x:00009063                 db    0
.xdata$x:00009064                 db    0
.xdata$x:00009065                 db    0
.xdata$x:00009066                 db    0
.xdata$x:00009067                 db    0
.xdata$x:00009068                 db    0
.xdata$x:00009069                 db    0
.xdata$x:0000906A                 db    0
.xdata$x:0000906B                 db    0
.xdata$x:0000906C                 db    0
.xdata$x:0000906D                 db    0
.xdata$x:0000906E                 db    0
.xdata$x:0000906F                 db    0
.xdata$x:0000906F _xdata$x        ends
.xdata$x:0000906F
.xdata$x:00009070 ; ===========================================================================
.xdata$x:00009070
.xdata$x:00009070 ; Segment type: Pure data
.xdata$x:00009070 ; Segment permissions: Read
.xdata$x:00009070 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009070                 assume cs:_xdata$x
.xdata$x:00009070                 ;org 9070h
.xdata$x:00009070 ; COMDAT (pick associative to section at 5480)
.xdata$x:00009070 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009070                                         ; DATA XREF: .xdata$x:00009080o
.xdata$x:00009071                 db 0FFh
.xdata$x:00009072                 db 0FFh
.xdata$x:00009073                 db 0FFh
.xdata$x:00009074                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00009078 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009078                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00009079                 db    5
.xdata$x:0000907A                 db  93h ; ô
.xdata$x:0000907B                 db  19h
.xdata$x:0000907C                 db    1
.xdata$x:0000907D                 db    0
.xdata$x:0000907E                 db    0
.xdata$x:0000907F                 db    0
.xdata$x:00009080                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00009084                 db    0
.xdata$x:00009085                 db    0
.xdata$x:00009086                 db    0
.xdata$x:00009087                 db    0
.xdata$x:00009088                 db    0
.xdata$x:00009089                 db    0
.xdata$x:0000908A                 db    0
.xdata$x:0000908B                 db    0
.xdata$x:0000908C                 db    0
.xdata$x:0000908D                 db    0
.xdata$x:0000908E                 db    0
.xdata$x:0000908F                 db    0
.xdata$x:00009090                 db    0
.xdata$x:00009091                 db    0
.xdata$x:00009092                 db    0
.xdata$x:00009093                 db    0
.xdata$x:00009094                 db    0
.xdata$x:00009095                 db    0
.xdata$x:00009096                 db    0
.xdata$x:00009097                 db    0
.xdata$x:00009098                 db    0
.xdata$x:00009099                 db    0
.xdata$x:0000909A                 db    0
.xdata$x:0000909B                 db    0
.xdata$x:0000909B _xdata$x        ends
.xdata$x:0000909B
.xdata$x:0000909C ; ===========================================================================
.xdata$x:0000909C
.xdata$x:0000909C ; Segment type: Pure data
.xdata$x:0000909C ; Segment permissions: Read
.xdata$x:0000909C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000909C                 assume cs:_xdata$x
.xdata$x:0000909C                 ;org 909Ch
.xdata$x:0000909C ; COMDAT (pick associative to section at 6848)
.xdata$x:0000909C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:0000909C                                         ; DATA XREF: .xdata$x:00009124o
.xdata$x:0000909D                 db    0
.xdata$x:0000909E                 db    0
.xdata$x:0000909F                 db    0
.xdata$x:000090A0                 db    0
.xdata$x:000090A1                 db    0
.xdata$x:000090A2                 db    0
.xdata$x:000090A3                 db    0
.xdata$x:000090A4                 db    0
.xdata$x:000090A5                 db    0
.xdata$x:000090A6                 db    0
.xdata$x:000090A7                 db    0
.xdata$x:000090A8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000090AC __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000090AC                                         ; DATA XREF: .xdata$x:00009110o
.xdata$x:000090AD                 db    0
.xdata$x:000090AE                 db    0
.xdata$x:000090AF                 db    0
.xdata$x:000090B0                 db    0
.xdata$x:000090B1                 db    0
.xdata$x:000090B2                 db    0
.xdata$x:000090B3                 db    0
.xdata$x:000090B4                 db    0
.xdata$x:000090B5                 db    0
.xdata$x:000090B6                 db    0
.xdata$x:000090B7                 db    0
.xdata$x:000090B8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:000090BC __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000090BC                                         ; DATA XREF: .xdata$x:000090E4o
.xdata$x:000090BD                 db 0FFh
.xdata$x:000090BE                 db 0FFh
.xdata$x:000090BF                 db 0FFh
.xdata$x:000090C0                 db    0
.xdata$x:000090C1                 db    0
.xdata$x:000090C2                 db    0
.xdata$x:000090C3                 db    0
.xdata$x:000090C4                 db 0FFh
.xdata$x:000090C5                 db 0FFh
.xdata$x:000090C6                 db 0FFh
.xdata$x:000090C7                 db 0FFh
.xdata$x:000090C8                 db    0
.xdata$x:000090C9                 db    0
.xdata$x:000090CA                 db    0
.xdata$x:000090CB                 db    0
.xdata$x:000090CC                 db    1
.xdata$x:000090CD                 db    0
.xdata$x:000090CE                 db    0
.xdata$x:000090CF                 db    0
.xdata$x:000090D0                 db    0
.xdata$x:000090D1                 db    0
.xdata$x:000090D2                 db    0
.xdata$x:000090D3                 db    0
.xdata$x:000090D4                 db    1
.xdata$x:000090D5                 db    0
.xdata$x:000090D6                 db    0
.xdata$x:000090D7                 db    0
.xdata$x:000090D8                 db    0
.xdata$x:000090D9                 db    0
.xdata$x:000090DA                 db    0
.xdata$x:000090DB                 db    0
.xdata$x:000090DC __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000090DC                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000090DD                 db    5
.xdata$x:000090DE                 db  93h ; ô
.xdata$x:000090DF                 db  19h
.xdata$x:000090E0                 db    4
.xdata$x:000090E1                 db    0
.xdata$x:000090E2                 db    0
.xdata$x:000090E3                 db    0
.xdata$x:000090E4                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000090E8                 db    2
.xdata$x:000090E9                 db    0
.xdata$x:000090EA                 db    0
.xdata$x:000090EB                 db    0
.xdata$x:000090EC                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000090F0                 align 20h
.xdata$x:00009100 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00009100                                         ; DATA XREF: .xdata$x:000090ECo
.xdata$x:00009101                 db    0
.xdata$x:00009102                 db    0
.xdata$x:00009103                 db    0
.xdata$x:00009104                 db    2
.xdata$x:00009105                 db    0
.xdata$x:00009106                 db    0
.xdata$x:00009107                 db    0
.xdata$x:00009108                 db    3
.xdata$x:00009109                 db    0
.xdata$x:0000910A                 db    0
.xdata$x:0000910B                 db    0
.xdata$x:0000910C                 db    1
.xdata$x:0000910D                 db    0
.xdata$x:0000910E                 db    0
.xdata$x:0000910F                 db    0
.xdata$x:00009110                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00009114                 db    0
.xdata$x:00009115                 db    0
.xdata$x:00009116                 db    0
.xdata$x:00009117                 db    0
.xdata$x:00009118                 db    0
.xdata$x:00009119                 db    0
.xdata$x:0000911A                 db    0
.xdata$x:0000911B                 db    0
.xdata$x:0000911C                 db    3
.xdata$x:0000911D                 db    0
.xdata$x:0000911E                 db    0
.xdata$x:0000911F                 db    0
.xdata$x:00009120                 db    1
.xdata$x:00009121                 db    0
.xdata$x:00009122                 db    0
.xdata$x:00009123                 db    0
.xdata$x:00009124                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00009124 _xdata$x        ends
.xdata$x:00009124
.xdata$x:00009128 ; ===========================================================================
.xdata$x:00009128
.xdata$x:00009128 ; Segment type: Pure data
.xdata$x:00009128 ; Segment permissions: Read
.xdata$x:00009128 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009128                 assume cs:_xdata$x
.xdata$x:00009128                 ;org 9128h
.xdata$x:00009128 ; COMDAT (pick associative to section at 4DE4)
.xdata$x:00009128 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00009128                                         ; DATA XREF: .xdata$x:00009138o
.xdata$x:00009129                 db 0FFh
.xdata$x:0000912A                 db 0FFh
.xdata$x:0000912B                 db 0FFh
.xdata$x:0000912C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00009130 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00009130                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00009131                 db    5
.xdata$x:00009132                 db  93h ; ô
.xdata$x:00009133                 db  19h
.xdata$x:00009134                 db    1
.xdata$x:00009135                 db    0
.xdata$x:00009136                 db    0
.xdata$x:00009137                 db    0
.xdata$x:00009138                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000913C                 db    0
.xdata$x:0000913D                 db    0
.xdata$x:0000913E                 db    0
.xdata$x:0000913F                 db    0
.xdata$x:00009140                 db    0
.xdata$x:00009141                 db    0
.xdata$x:00009142                 db    0
.xdata$x:00009143                 db    0
.xdata$x:00009144                 db    0
.xdata$x:00009145                 db    0
.xdata$x:00009146                 db    0
.xdata$x:00009147                 db    0
.xdata$x:00009148                 db    0
.xdata$x:00009149                 db    0
.xdata$x:0000914A                 db    0
.xdata$x:0000914B                 db    0
.xdata$x:0000914C                 db    0
.xdata$x:0000914D                 db    0
.xdata$x:0000914E                 db    0
.xdata$x:0000914F                 db    0
.xdata$x:00009150                 db    0
.xdata$x:00009151                 db    0
.xdata$x:00009152                 db    0
.xdata$x:00009153                 db    0
.xdata$x:00009153 _xdata$x        ends
.xdata$x:00009153
.xdata$x:00009154 ; ===========================================================================
.xdata$x:00009154
.xdata$x:00009154 ; Segment type: Pure data
.xdata$x:00009154 ; Segment permissions: Read
.xdata$x:00009154 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009154                 assume cs:_xdata$x
.xdata$x:00009154                 ;org 9154h
.xdata$x:00009154 ; COMDAT (pick associative to section at 8990)
.xdata$x:00009154 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00009154                                         ; DATA XREF: .xdata$x:00009164o
.xdata$x:00009155                 db 0FFh
.xdata$x:00009156                 db 0FFh
.xdata$x:00009157                 db 0FFh
.xdata$x:00009158                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000915C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000915C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000915D                 db    5
.xdata$x:0000915E                 db  93h ; ô
.xdata$x:0000915F                 db  19h
.xdata$x:00009160                 db    1
.xdata$x:00009161                 db    0
.xdata$x:00009162                 db    0
.xdata$x:00009163                 db    0
.xdata$x:00009164                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00009168                 align 20h
.xdata$x:00009168 _xdata$x        ends
.xdata$x:00009168
.xdata$x:00009180 ; ===========================================================================
.xdata$x:00009180
.xdata$x:00009180 ; Segment type: Pure data
.xdata$x:00009180 ; Segment permissions: Read
.xdata$x:00009180 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009180                 assume cs:_xdata$x
.xdata$x:00009180                 ;org 9180h
.xdata$x:00009180 ; COMDAT (pick associative to section at 56A4)
.xdata$x:00009180 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009180                                         ; DATA XREF: .xdata$x:00009190o
.xdata$x:00009181                 db 0FFh
.xdata$x:00009182                 db 0FFh
.xdata$x:00009183                 db 0FFh
.xdata$x:00009184                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00009188 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00009188                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00009189                 db    5
.xdata$x:0000918A                 db  93h ; ô
.xdata$x:0000918B                 db  19h
.xdata$x:0000918C                 db    1
.xdata$x:0000918D                 db    0
.xdata$x:0000918E                 db    0
.xdata$x:0000918F                 db    0
.xdata$x:00009190                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00009194                 db    0
.xdata$x:00009195                 db    0
.xdata$x:00009196                 db    0
.xdata$x:00009197                 db    0
.xdata$x:00009198                 db    0
.xdata$x:00009199                 db    0
.xdata$x:0000919A                 db    0
.xdata$x:0000919B                 db    0
.xdata$x:0000919C                 db    0
.xdata$x:0000919D                 db    0
.xdata$x:0000919E                 db    0
.xdata$x:0000919F                 db    0
.xdata$x:000091A0                 db    0
.xdata$x:000091A1                 db    0
.xdata$x:000091A2                 db    0
.xdata$x:000091A3                 db    0
.xdata$x:000091A4                 db    0
.xdata$x:000091A5                 db    0
.xdata$x:000091A6                 db    0
.xdata$x:000091A7                 db    0
.xdata$x:000091A8                 db    0
.xdata$x:000091A9                 db    0
.xdata$x:000091AA                 db    0
.xdata$x:000091AB                 db    0
.xdata$x:000091AB _xdata$x        ends
.xdata$x:000091AB
.xdata$x:000091AC ; ===========================================================================
.xdata$x:000091AC
.xdata$x:000091AC ; Segment type: Pure data
.xdata$x:000091AC ; Segment permissions: Read
.xdata$x:000091AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000091AC                 assume cs:_xdata$x
.xdata$x:000091AC                 ;org 91ACh
.xdata$x:000091AC ; COMDAT (pick associative to section at 4E70)
.xdata$x:000091AC __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000091AC                                         ; DATA XREF: .xdata$x:000091BCo
.xdata$x:000091AD                 db 0FFh
.xdata$x:000091AE                 db 0FFh
.xdata$x:000091AF                 db 0FFh
.xdata$x:000091B0                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:000091B4 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000091B4                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:000091B5                 db    5
.xdata$x:000091B6                 db  93h ; ô
.xdata$x:000091B7                 db  19h
.xdata$x:000091B8                 db    1
.xdata$x:000091B9                 db    0
.xdata$x:000091BA                 db    0
.xdata$x:000091BB                 db    0
.xdata$x:000091BC                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:000091C0                 db    0
.xdata$x:000091C1                 db    0
.xdata$x:000091C2                 db    0
.xdata$x:000091C3                 db    0
.xdata$x:000091C4                 db    0
.xdata$x:000091C5                 db    0
.xdata$x:000091C6                 db    0
.xdata$x:000091C7                 db    0
.xdata$x:000091C8                 db    0
.xdata$x:000091C9                 db    0
.xdata$x:000091CA                 db    0
.xdata$x:000091CB                 db    0
.xdata$x:000091CC                 db    0
.xdata$x:000091CD                 db    0
.xdata$x:000091CE                 db    0
.xdata$x:000091CF                 db    0
.xdata$x:000091D0                 db    0
.xdata$x:000091D1                 db    0
.xdata$x:000091D2                 db    0
.xdata$x:000091D3                 db    0
.xdata$x:000091D4                 db    0
.xdata$x:000091D5                 db    0
.xdata$x:000091D6                 db    0
.xdata$x:000091D7                 db    0
.xdata$x:000091D7 _xdata$x        ends
.xdata$x:000091D7
.xdata$x:000091D8 ; ===========================================================================
.xdata$x:000091D8
.xdata$x:000091D8 ; Segment type: Pure data
.xdata$x:000091D8 ; Segment permissions: Read
.xdata$x:000091D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000091D8                 assume cs:_xdata$x
.xdata$x:000091D8                 ;org 91D8h
.xdata$x:000091D8 ; COMDAT (pick associative to section at 8A48)
.xdata$x:000091D8 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000091D8                                         ; DATA XREF: .xdata$x:000091E8o
.xdata$x:000091D9                 db 0FFh
.xdata$x:000091DA                 db 0FFh
.xdata$x:000091DB                 db 0FFh
.xdata$x:000091DC                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000091E0 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000091E0                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000091E1                 db    5
.xdata$x:000091E2                 db  93h ; ô
.xdata$x:000091E3                 db  19h
.xdata$x:000091E4                 db    1
.xdata$x:000091E5                 db    0
.xdata$x:000091E6                 db    0
.xdata$x:000091E7                 db    0
.xdata$x:000091E8                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000091EC                 db    0
.xdata$x:000091ED                 db    0
.xdata$x:000091EE                 db    0
.xdata$x:000091EF                 db    0
.xdata$x:000091F0                 db    0
.xdata$x:000091F1                 db    0
.xdata$x:000091F2                 db    0
.xdata$x:000091F3                 db    0
.xdata$x:000091F4                 db    0
.xdata$x:000091F5                 db    0
.xdata$x:000091F6                 db    0
.xdata$x:000091F7                 db    0
.xdata$x:000091F8                 db    0
.xdata$x:000091F9                 db    0
.xdata$x:000091FA                 db    0
.xdata$x:000091FB                 db    0
.xdata$x:000091FC                 db    0
.xdata$x:000091FD                 db    0
.xdata$x:000091FE                 db    0
.xdata$x:000091FF                 db    0
.xdata$x:00009200                 db    0
.xdata$x:00009201                 db    0
.xdata$x:00009202                 db    0
.xdata$x:00009203                 db    0
.xdata$x:00009203 _xdata$x        ends
.xdata$x:00009203
.xdata$x:00009204 ; ===========================================================================
.xdata$x:00009204
.xdata$x:00009204 ; Segment type: Pure data
.xdata$x:00009204 ; Segment permissions: Read
.xdata$x:00009204 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009204                 assume cs:_xdata$x
.xdata$x:00009204                 ;org 9204h
.xdata$x:00009204 ; COMDAT (pick associative to section at 5714)
.xdata$x:00009204 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009204                                         ; DATA XREF: .xdata$x:00009214o
.xdata$x:00009205                 db 0FFh
.xdata$x:00009206                 db 0FFh
.xdata$x:00009207                 db 0FFh
.xdata$x:00009208                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:0000920C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:0000920C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:0000920D                 db    5
.xdata$x:0000920E                 db  93h ; ô
.xdata$x:0000920F                 db  19h
.xdata$x:00009210                 db    1
.xdata$x:00009211                 db    0
.xdata$x:00009212                 db    0
.xdata$x:00009213                 db    0
.xdata$x:00009214                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00009218                 db    0
.xdata$x:00009219                 db    0
.xdata$x:0000921A                 db    0
.xdata$x:0000921B                 db    0
.xdata$x:0000921C                 db    0
.xdata$x:0000921D                 db    0
.xdata$x:0000921E                 db    0
.xdata$x:0000921F                 db    0
.xdata$x:00009220                 db    0
.xdata$x:00009221                 db    0
.xdata$x:00009222                 db    0
.xdata$x:00009223                 db    0
.xdata$x:00009224                 db    0
.xdata$x:00009225                 db    0
.xdata$x:00009226                 db    0
.xdata$x:00009227                 db    0
.xdata$x:00009228                 db    0
.xdata$x:00009229                 db    0
.xdata$x:0000922A                 db    0
.xdata$x:0000922B                 db    0
.xdata$x:0000922C                 db    0
.xdata$x:0000922D                 db    0
.xdata$x:0000922E                 db    0
.xdata$x:0000922F                 db    0
.xdata$x:0000922F _xdata$x        ends
.xdata$x:0000922F
.xdata$x:00009230 ; ===========================================================================
.xdata$x:00009230
.xdata$x:00009230 ; Segment type: Pure data
.xdata$x:00009230 ; Segment permissions: Read
.xdata$x:00009230 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009230                 assume cs:_xdata$x
.xdata$x:00009230                 ;org 9230h
.xdata$x:00009230 ; COMDAT (pick associative to section at 4F40)
.xdata$x:00009230 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00009230                                         ; DATA XREF: .xdata$x:00009240o
.xdata$x:00009231                 db 0FFh
.xdata$x:00009232                 db 0FFh
.xdata$x:00009233                 db 0FFh
.xdata$x:00009234                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00009238 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00009238                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00009239                 db    5
.xdata$x:0000923A                 db  93h ; ô
.xdata$x:0000923B                 db  19h
.xdata$x:0000923C                 db    1
.xdata$x:0000923D                 db    0
.xdata$x:0000923E                 db    0
.xdata$x:0000923F                 db    0
.xdata$x:00009240                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00009244                 db    0
.xdata$x:00009245                 db    0
.xdata$x:00009246                 db    0
.xdata$x:00009247                 db    0
.xdata$x:00009248                 db    0
.xdata$x:00009249                 db    0
.xdata$x:0000924A                 db    0
.xdata$x:0000924B                 db    0
.xdata$x:0000924C                 db    0
.xdata$x:0000924D                 db    0
.xdata$x:0000924E                 db    0
.xdata$x:0000924F                 db    0
.xdata$x:00009250                 db    0
.xdata$x:00009251                 db    0
.xdata$x:00009252                 db    0
.xdata$x:00009253                 db    0
.xdata$x:00009254                 db    0
.xdata$x:00009255                 db    0
.xdata$x:00009256                 db    0
.xdata$x:00009257                 db    0
.xdata$x:00009258                 db    0
.xdata$x:00009259                 db    0
.xdata$x:0000925A                 db    0
.xdata$x:0000925B                 db    0
.xdata$x:0000925B _xdata$x        ends
.xdata$x:0000925B
.xdata$x:0000925C ; ===========================================================================
.xdata$x:0000925C
.xdata$x:0000925C ; Segment type: Pure data
.xdata$x:0000925C ; Segment permissions: Read
.xdata$x:0000925C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000925C                 assume cs:_xdata$x
.xdata$x:0000925C                 ;org 925Ch
.xdata$x:0000925C ; COMDAT (pick associative to section at 8B0C)
.xdata$x:0000925C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000925C                                         ; DATA XREF: .xdata$x:0000926Co
.xdata$x:0000925D                 db 0FFh
.xdata$x:0000925E                 db 0FFh
.xdata$x:0000925F                 db 0FFh
.xdata$x:00009260                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00009264 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00009264                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00009265                 db    5
.xdata$x:00009266                 db  93h ; ô
.xdata$x:00009267                 db  19h
.xdata$x:00009268                 db    1
.xdata$x:00009269                 db    0
.xdata$x:0000926A                 db    0
.xdata$x:0000926B                 db    0
.xdata$x:0000926C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00009270                 db    0
.xdata$x:00009271                 db    0
.xdata$x:00009272                 db    0
.xdata$x:00009273                 db    0
.xdata$x:00009274                 db    0
.xdata$x:00009275                 db    0
.xdata$x:00009276                 db    0
.xdata$x:00009277                 db    0
.xdata$x:00009278                 db    0
.xdata$x:00009279                 db    0
.xdata$x:0000927A                 db    0
.xdata$x:0000927B                 db    0
.xdata$x:0000927C                 db    0
.xdata$x:0000927D                 db    0
.xdata$x:0000927E                 db    0
.xdata$x:0000927F                 db    0
.xdata$x:00009280                 db    0
.xdata$x:00009281                 db    0
.xdata$x:00009282                 db    0
.xdata$x:00009283                 db    0
.xdata$x:00009284                 db    0
.xdata$x:00009285                 db    0
.xdata$x:00009286                 db    0
.xdata$x:00009287                 db    0
.xdata$x:00009287 _xdata$x        ends
.xdata$x:00009287
.xdata$x:00009288 ; ===========================================================================
.xdata$x:00009288
.xdata$x:00009288 ; Segment type: Pure data
.xdata$x:00009288 ; Segment permissions: Read
.xdata$x:00009288 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009288                 assume cs:_xdata$x
.xdata$x:00009288                 ;org 9288h
.xdata$x:00009288 ; COMDAT (pick associative to section at 5808)
.xdata$x:00009288 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00009288                                         ; DATA XREF: .xdata$x:00009298o
.xdata$x:00009289                 db 0FFh
.xdata$x:0000928A                 db 0FFh
.xdata$x:0000928B                 db 0FFh
.xdata$x:0000928C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00009290 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00009290                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00009291                 db    5
.xdata$x:00009292                 db  93h ; ô
.xdata$x:00009293                 db  19h
.xdata$x:00009294                 db    1
.xdata$x:00009295                 db    0
.xdata$x:00009296                 db    0
.xdata$x:00009297                 db    0
.xdata$x:00009298                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000929C                 db    0
.xdata$x:0000929D                 db    0
.xdata$x:0000929E                 db    0
.xdata$x:0000929F                 db    0
.xdata$x:000092A0                 db    0
.xdata$x:000092A1                 db    0
.xdata$x:000092A2                 db    0
.xdata$x:000092A3                 db    0
.xdata$x:000092A4                 db    0
.xdata$x:000092A5                 db    0
.xdata$x:000092A6                 db    0
.xdata$x:000092A7                 db    0
.xdata$x:000092A8                 db    0
.xdata$x:000092A9                 db    0
.xdata$x:000092AA                 db    0
.xdata$x:000092AB                 db    0
.xdata$x:000092AC                 db    0
.xdata$x:000092AD                 db    0
.xdata$x:000092AE                 db    0
.xdata$x:000092AF                 db    0
.xdata$x:000092B0                 db    0
.xdata$x:000092B1                 db    0
.xdata$x:000092B2                 db    0
.xdata$x:000092B3                 db    0
.xdata$x:000092B3 _xdata$x        ends
.xdata$x:000092B3
.xdata$x:000092B4 ; ===========================================================================
.xdata$x:000092B4
.xdata$x:000092B4 ; Segment type: Pure data
.xdata$x:000092B4 ; Segment permissions: Read
.xdata$x:000092B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000092B4                 assume cs:_xdata$x
.xdata$x:000092B4                 ;org 92B4h
.xdata$x:000092B4 __unwindtable$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z db 0FFh
.xdata$x:000092B4                                         ; DATA XREF: .xdata$x:00009364o
.xdata$x:000092B5                 db 0FFh
.xdata$x:000092B6                 db 0FFh
.xdata$x:000092B7                 db 0FFh
.xdata$x:000092B8                 dd offset __unwindfunclet$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z$0
.xdata$x:000092BC __unwindtable$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z db 0FFh
.xdata$x:000092BC                                         ; DATA XREF: .xdata$x:000093F4o
.xdata$x:000092BD                 db 0FFh
.xdata$x:000092BE                 db 0FFh
.xdata$x:000092BF                 db 0FFh
.xdata$x:000092C0                 dd offset __unwindfunclet$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z$0
.xdata$x:000092C4 __unwindtable$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z db 0FFh
.xdata$x:000092C4                                         ; DATA XREF: .xdata$x:00009340o
.xdata$x:000092C5                 db 0FFh
.xdata$x:000092C6                 db 0FFh
.xdata$x:000092C7                 db 0FFh
.xdata$x:000092C8                 dd offset __unwindfunclet$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z$0
.xdata$x:000092CC                 db 0FFh
.xdata$x:000092CD                 db 0FFh
.xdata$x:000092CE                 db 0FFh
.xdata$x:000092CF                 db 0FFh
.xdata$x:000092D0                 dd offset __unwindfunclet$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z$1
.xdata$x:000092D4 __unwindtable$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ db 0FFh
.xdata$x:000092D4                                         ; DATA XREF: .xdata$x:000093ACo
.xdata$x:000092D5                 db 0FFh
.xdata$x:000092D6                 db 0FFh
.xdata$x:000092D7                 db 0FFh
.xdata$x:000092D8                 dd offset __unwindfunclet$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ$1
.xdata$x:000092DC                 align 10h
.xdata$x:000092E0                 dd offset __unwindfunclet$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ$0
.xdata$x:000092E4 __unwindtable$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z db 0FFh
.xdata$x:000092E4                                         ; DATA XREF: .xdata$x:000093D0o
.xdata$x:000092E5                 db 0FFh
.xdata$x:000092E6                 db 0FFh
.xdata$x:000092E7                 db 0FFh
.xdata$x:000092E8                 dd offset __unwindfunclet$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z$0
.xdata$x:000092EC                 align 10h
.xdata$x:000092F0                 dd offset __unwindfunclet$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z$1
.xdata$x:000092F4 __unwindtable$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z db 0FFh
.xdata$x:000092F4                                         ; DATA XREF: .xdata$x:0000931Co
.xdata$x:000092F5                 db 0FFh
.xdata$x:000092F6                 db 0FFh
.xdata$x:000092F7                 db 0FFh
.xdata$x:000092F8                 dd offset __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$0
.xdata$x:000092FC                 align 10h
.xdata$x:00009300                 dd offset __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$1
.xdata$x:00009304                 db 0FFh
.xdata$x:00009305                 db 0FFh
.xdata$x:00009306                 db 0FFh
.xdata$x:00009307                 db 0FFh
.xdata$x:00009308                 dd offset __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$2
.xdata$x:0000930C                 db 0FFh
.xdata$x:0000930D                 db 0FFh
.xdata$x:0000930E                 db 0FFh
.xdata$x:0000930F                 db 0FFh
.xdata$x:00009310                 dd offset __unwindfunclet$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z$3
.xdata$x:00009314 __ehfuncinfo$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z db  22h ; "
.xdata$x:00009314                                         ; DATA XREF: __ehhandler$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z+11o
.xdata$x:00009315                 db    5
.xdata$x:00009316                 db  93h ; ô
.xdata$x:00009317                 db  19h
.xdata$x:00009318                 db    4
.xdata$x:00009319                 db    0
.xdata$x:0000931A                 db    0
.xdata$x:0000931B                 db    0
.xdata$x:0000931C                 dd offset __unwindtable$?run_dlgProc@ClipboardHistoryPanel@@MAGHIIJ@Z
.xdata$x:00009320                 db    0
.xdata$x:00009321                 db    0
.xdata$x:00009322                 db    0
.xdata$x:00009323                 db    0
.xdata$x:00009324                 db    0
.xdata$x:00009325                 db    0
.xdata$x:00009326                 db    0
.xdata$x:00009327                 db    0
.xdata$x:00009328                 db    0
.xdata$x:00009329                 db    0
.xdata$x:0000932A                 db    0
.xdata$x:0000932B                 db    0
.xdata$x:0000932C                 db    0
.xdata$x:0000932D                 db    0
.xdata$x:0000932E                 db    0
.xdata$x:0000932F                 db    0
.xdata$x:00009330                 db    0
.xdata$x:00009331                 db    0
.xdata$x:00009332                 db    0
.xdata$x:00009333                 db    0
.xdata$x:00009334                 db    0
.xdata$x:00009335                 db    0
.xdata$x:00009336                 db    0
.xdata$x:00009337                 db    0
.xdata$x:00009338 __ehfuncinfo$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z db  22h ; "
.xdata$x:00009338                                         ; DATA XREF: __ehhandler$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z+11o
.xdata$x:00009339                 db    5
.xdata$x:0000933A                 db  93h ; ô
.xdata$x:0000933B                 db  19h
.xdata$x:0000933C                 db    2
.xdata$x:0000933D                 db    0
.xdata$x:0000933E                 db    0
.xdata$x:0000933F                 db    0
.xdata$x:00009340                 dd offset __unwindtable$?drawItem@ClipboardHistoryPanel@@QAEXPAUtagDRAWITEMSTRUCT@@@Z
.xdata$x:00009344                 db    0
.xdata$x:00009345                 db    0
.xdata$x:00009346                 db    0
.xdata$x:00009347                 db    0
.xdata$x:00009348                 db    0
.xdata$x:00009349                 db    0
.xdata$x:0000934A                 db    0
.xdata$x:0000934B                 db    0
.xdata$x:0000934C                 db    0
.xdata$x:0000934D                 db    0
.xdata$x:0000934E                 db    0
.xdata$x:0000934F                 db    0
.xdata$x:00009350                 db    0
.xdata$x:00009351                 db    0
.xdata$x:00009352                 db    0
.xdata$x:00009353                 db    0
.xdata$x:00009354                 db    0
.xdata$x:00009355                 db    0
.xdata$x:00009356                 db    0
.xdata$x:00009357                 db    0
.xdata$x:00009358                 db    0
.xdata$x:00009359                 db    0
.xdata$x:0000935A                 db    0
.xdata$x:0000935B                 db    0
.xdata$x:0000935C __ehfuncinfo$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z db  22h ; "
.xdata$x:0000935C                                         ; DATA XREF: __ehhandler$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z+11o
.xdata$x:0000935D                 db    5
.xdata$x:0000935E                 db  93h ; ô
.xdata$x:0000935F                 db  19h
.xdata$x:00009360                 db    1
.xdata$x:00009361                 db    0
.xdata$x:00009362                 db    0
.xdata$x:00009363                 db    0
.xdata$x:00009364                 dd offset __unwindtable$?getClipboardDataIndex@ClipboardHistoryPanel@@QAEHV?$vector@EV?$allocator@E@std@@@std@@@Z
.xdata$x:00009368                 align 20h
.xdata$x:00009380 __ehfuncinfo$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z db  22h ; "
.xdata$x:00009380                                         ; DATA XREF: __ehhandler$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z+14o
.xdata$x:00009381                 db    5
.xdata$x:00009382                 db  93h ; ô
.xdata$x:00009383                 db  19h
.xdata$x:00009384                 db    9
.xdata$x:00009385                 db    0
.xdata$x:00009386                 db    0
.xdata$x:00009387                 db    0
.xdata$x:00009388                 dd offset __unwindtable$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z
.xdata$x:0000938C                 db    0
.xdata$x:0000938D                 db    0
.xdata$x:0000938E                 db    0
.xdata$x:0000938F                 db    0
.xdata$x:00009390                 db    0
.xdata$x:00009391                 db    0
.xdata$x:00009392                 db    0
.xdata$x:00009393                 db    0
.xdata$x:00009394                 db    0
.xdata$x:00009395                 db    0
.xdata$x:00009396                 db    0
.xdata$x:00009397                 db    0
.xdata$x:00009398                 db    0
.xdata$x:00009399                 db    0
.xdata$x:0000939A                 db    0
.xdata$x:0000939B                 db    0
.xdata$x:0000939C                 db    0
.xdata$x:0000939D                 db    0
.xdata$x:0000939E                 db    0
.xdata$x:0000939F                 db    0
.xdata$x:000093A0                 db    0
.xdata$x:000093A1                 db    0
.xdata$x:000093A2                 db    0
.xdata$x:000093A3                 db    0
.xdata$x:000093A4 __ehfuncinfo$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ db  22h ; "
.xdata$x:000093A4                                         ; DATA XREF: __ehhandler$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ+11o
.xdata$x:000093A5                 db    5
.xdata$x:000093A6                 db  93h ; ô
.xdata$x:000093A7                 db  19h
.xdata$x:000093A8                 db    2
.xdata$x:000093A9                 db    0
.xdata$x:000093AA                 db    0
.xdata$x:000093AB                 db    0
.xdata$x:000093AC                 dd offset __unwindtable$?getClipboadData@ClipboardHistoryPanel@@QAE?AV?$vector@EV?$allocator@E@std@@@std@@XZ
.xdata$x:000093B0                 db    0
.xdata$x:000093B1                 db    0
.xdata$x:000093B2                 db    0
.xdata$x:000093B3                 db    0
.xdata$x:000093B4                 db    0
.xdata$x:000093B5                 db    0
.xdata$x:000093B6                 db    0
.xdata$x:000093B7                 db    0
.xdata$x:000093B8                 db    0
.xdata$x:000093B9                 db    0
.xdata$x:000093BA                 db    0
.xdata$x:000093BB                 db    0
.xdata$x:000093BC                 db    0
.xdata$x:000093BD                 db    0
.xdata$x:000093BE                 db    0
.xdata$x:000093BF                 db    0
.xdata$x:000093C0                 db    0
.xdata$x:000093C1                 db    0
.xdata$x:000093C2                 db    0
.xdata$x:000093C3                 db    0
.xdata$x:000093C4                 db    0
.xdata$x:000093C5                 db    0
.xdata$x:000093C6                 db    0
.xdata$x:000093C7                 db    0
.xdata$x:000093C8 __ehfuncinfo$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z db  22h ; "
.xdata$x:000093C8                                         ; DATA XREF: __ehhandler$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z+11o
.xdata$x:000093C9                 db    5
.xdata$x:000093CA                 db  93h ; ô
.xdata$x:000093CB                 db  19h
.xdata$x:000093CC                 db    2
.xdata$x:000093CD                 db    0
.xdata$x:000093CE                 db    0
.xdata$x:000093CF                 db    0
.xdata$x:000093D0                 dd offset __unwindtable$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z
.xdata$x:000093D4                 db    0
.xdata$x:000093D5                 db    0
.xdata$x:000093D6                 db    0
.xdata$x:000093D7                 db    0
.xdata$x:000093D8                 db    0
.xdata$x:000093D9                 db    0
.xdata$x:000093DA                 db    0
.xdata$x:000093DB                 db    0
.xdata$x:000093DC                 db    0
.xdata$x:000093DD                 db    0
.xdata$x:000093DE                 db    0
.xdata$x:000093DF                 db    0
.xdata$x:000093E0                 db    0
.xdata$x:000093E1                 db    0
.xdata$x:000093E2                 db    0
.xdata$x:000093E3                 db    0
.xdata$x:000093E4                 db    0
.xdata$x:000093E5                 db    0
.xdata$x:000093E6                 db    0
.xdata$x:000093E7                 db    0
.xdata$x:000093E8                 db    0
.xdata$x:000093E9                 db    0
.xdata$x:000093EA                 db    0
.xdata$x:000093EB                 db    0
.xdata$x:000093EC __ehfuncinfo$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z db  22h ; "
.xdata$x:000093EC                                         ; DATA XREF: __ehhandler$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z+11o
.xdata$x:000093ED                 db    5
.xdata$x:000093EE                 db  93h ; ô
.xdata$x:000093EF                 db  19h
.xdata$x:000093F0                 db    1
.xdata$x:000093F1                 db    0
.xdata$x:000093F2                 db    0
.xdata$x:000093F3                 db    0
.xdata$x:000093F4                 dd offset __unwindtable$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z
.xdata$x:000093F8                 db    0
.xdata$x:000093F9                 db    0
.xdata$x:000093FA                 db    0
.xdata$x:000093FB                 db    0
.xdata$x:000093FC                 db    0
.xdata$x:000093FD                 db    0
.xdata$x:000093FE                 db    0
.xdata$x:000093FF                 db    0
.xdata$x:00009400                 db    0
.xdata$x:00009401                 db    0
.xdata$x:00009402                 db    0
.xdata$x:00009403                 db    0
.xdata$x:00009404                 db    0
.xdata$x:00009405                 db    0
.xdata$x:00009406                 db    0
.xdata$x:00009407                 db    0
.xdata$x:00009408                 db    0
.xdata$x:00009409                 db    0
.xdata$x:0000940A                 db    0
.xdata$x:0000940B                 db    0
.xdata$x:0000940C                 db    0
.xdata$x:0000940D                 db    0
.xdata$x:0000940E                 db    0
.xdata$x:0000940F                 db    0
.xdata$x:00009410 __unwindtable$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z db 0FFh
.xdata$x:00009410                                         ; DATA XREF: .xdata$x:00009388o
.xdata$x:00009411                 db 0FFh
.xdata$x:00009412                 db 0FFh
.xdata$x:00009413                 db 0FFh
.xdata$x:00009414                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$0
.xdata$x:00009418                 db    0
.xdata$x:00009419                 db    0
.xdata$x:0000941A                 db    0
.xdata$x:0000941B                 db    0
.xdata$x:0000941C                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$1
.xdata$x:00009420                 db    0
.xdata$x:00009421                 db    0
.xdata$x:00009422                 db    0
.xdata$x:00009423                 db    0
.xdata$x:00009424                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$2
.xdata$x:00009428                 db    2
.xdata$x:00009429                 db    0
.xdata$x:0000942A                 db    0
.xdata$x:0000942B                 db    0
.xdata$x:0000942C                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$3
.xdata$x:00009430                 db    3
.xdata$x:00009431                 db    0
.xdata$x:00009432                 db    0
.xdata$x:00009433                 db    0
.xdata$x:00009434                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$4
.xdata$x:00009438                 db    0
.xdata$x:00009439                 db    0
.xdata$x:0000943A                 db    0
.xdata$x:0000943B                 db    0
.xdata$x:0000943C                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$6
.xdata$x:00009440                 db    5
.xdata$x:00009441                 db    0
.xdata$x:00009442                 db    0
.xdata$x:00009443                 db    0
.xdata$x:00009444                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$7
.xdata$x:00009448                 db    0
.xdata$x:00009449                 db    0
.xdata$x:0000944A                 db    0
.xdata$x:0000944B                 db    0
.xdata$x:0000944C                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$9
.xdata$x:00009450                 db    0
.xdata$x:00009451                 db    0
.xdata$x:00009452                 db    0
.xdata$x:00009453                 db    0
.xdata$x:00009454                 dd offset __unwindfunclet$?addToClipboadHistory@ClipboardHistoryPanel@@QAEXV?$vector@EV?$allocator@E@std@@@std@@@Z$10
.xdata$x:00009454 _xdata$x        ends
.xdata$x:00009454
.xdata$x:00009458 ; ===========================================================================
.xdata$x:00009458
.xdata$x:00009458 ; Segment type: Pure data
.xdata$x:00009458 ; Segment permissions: Read
.xdata$x:00009458 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009458                 assume cs:_xdata$x
.xdata$x:00009458                 ;org 9458h
.xdata$x:00009458 ; COMDAT (pick associative to section at 5620)
.xdata$x:00009458 __unwindtable$??1StringArray@@QAE@XZ db 0FFh
.xdata$x:00009458                                         ; DATA XREF: .xdata$x:00009468o
.xdata$x:00009459                 db 0FFh
.xdata$x:0000945A                 db 0FFh
.xdata$x:0000945B                 db 0FFh
.xdata$x:0000945C                 dd offset __unwindfunclet$??1StringArray@@QAE@XZ$0
.xdata$x:00009460 __ehfuncinfo$??1StringArray@@QAE@XZ db  22h ; "
.xdata$x:00009460                                         ; DATA XREF: __ehhandler$??1StringArray@@QAE@XZ+11o
.xdata$x:00009461                 db    5
.xdata$x:00009462                 db  93h ; ô
.xdata$x:00009463                 db  19h
.xdata$x:00009464                 db    1
.xdata$x:00009465                 db    0
.xdata$x:00009466                 db    0
.xdata$x:00009467                 db    0
.xdata$x:00009468                 dd offset __unwindtable$??1StringArray@@QAE@XZ
.xdata$x:0000946C                 db    0
.xdata$x:0000946D                 db    0
.xdata$x:0000946E                 db    0
.xdata$x:0000946F                 db    0
.xdata$x:00009470                 db    0
.xdata$x:00009471                 db    0
.xdata$x:00009472                 db    0
.xdata$x:00009473                 db    0
.xdata$x:00009474                 db    0
.xdata$x:00009475                 db    0
.xdata$x:00009476                 db    0
.xdata$x:00009477                 db    0
.xdata$x:00009478                 db    0
.xdata$x:00009479                 db    0
.xdata$x:0000947A                 db    0
.xdata$x:0000947B                 db    0
.xdata$x:0000947C                 db    0
.xdata$x:0000947D                 db    0
.xdata$x:0000947E                 db    0
.xdata$x:0000947F                 db    0
.xdata$x:00009480                 db    0
.xdata$x:00009481                 db    0
.xdata$x:00009482                 db    0
.xdata$x:00009483                 db    0
.xdata$x:00009483 _xdata$x        ends
.xdata$x:00009483
.xdata$x:00009484 ; ===========================================================================
.xdata$x:00009484
.xdata$x:00009484 ; Segment type: Pure data
.xdata$x:00009484 ; Segment permissions: Read
.xdata$x:00009484 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009484                 assume cs:_xdata$x
.xdata$x:00009484                 ;org 9484h
.xdata$x:00009484 ; COMDAT (pick associative to section at 8068)
.xdata$x:00009484 __unwindtable$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z db 0FFh
.xdata$x:00009484                                         ; DATA XREF: .xdata$x:00009494o
.xdata$x:00009485                 db 0FFh
.xdata$x:00009486                 db 0FFh
.xdata$x:00009487                 db 0FFh
.xdata$x:00009488                 dd offset __unwindfunclet$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z$0
.xdata$x:0000948C __ehfuncinfo$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z db  22h ; "
.xdata$x:0000948C                                         ; DATA XREF: __ehhandler$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z+11o
.xdata$x:0000948D                 db    5
.xdata$x:0000948E                 db  93h ; ô
.xdata$x:0000948F                 db  19h
.xdata$x:00009490                 db    1
.xdata$x:00009491                 db    0
.xdata$x:00009492                 db    0
.xdata$x:00009493                 db    0
.xdata$x:00009494                 dd offset __unwindtable$?construct@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@2@ABV32@@Z
.xdata$x:00009498                 db    0
.xdata$x:00009499                 db    0
.xdata$x:0000949A                 db    0
.xdata$x:0000949B                 db    0
.xdata$x:0000949C                 db    0
.xdata$x:0000949D                 db    0
.xdata$x:0000949E                 db    0
.xdata$x:0000949F                 db    0
.xdata$x:000094A0                 db    0
.xdata$x:000094A1                 db    0
.xdata$x:000094A2                 db    0
.xdata$x:000094A3                 db    0
.xdata$x:000094A4                 db    0
.xdata$x:000094A5                 db    0
.xdata$x:000094A6                 db    0
.xdata$x:000094A7                 db    0
.xdata$x:000094A8                 db    0
.xdata$x:000094A9                 db    0
.xdata$x:000094AA                 db    0
.xdata$x:000094AB                 db    0
.xdata$x:000094AC                 db    0
.xdata$x:000094AD                 db    0
.xdata$x:000094AE                 db    0
.xdata$x:000094AF                 db    0
.xdata$x:000094AF _xdata$x        ends
.xdata$x:000094AF
.xdata$x:000094B0 ; ===========================================================================
.xdata$x:000094B0
.xdata$x:000094B0 ; Segment type: Pure data
.xdata$x:000094B0 ; Segment permissions: Read
.xdata$x:000094B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000094B0                 assume cs:_xdata$x
.xdata$x:000094B0                 ;org 94B0h
.xdata$x:000094B0 ; COMDAT (pick associative to section at 7F38)
.xdata$x:000094B0 __unwindtable$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:000094B0                                         ; DATA XREF: .xdata$x:000094C0o
.xdata$x:000094B1                 db 0FFh
.xdata$x:000094B2                 db 0FFh
.xdata$x:000094B3                 db 0FFh
.xdata$x:000094B4                 dd offset __unwindfunclet$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ$0
.xdata$x:000094B8 __ehfuncinfo$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000094B8                                         ; DATA XREF: __ehhandler$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ+11o
.xdata$x:000094B9                 db    5
.xdata$x:000094BA                 db  93h ; ô
.xdata$x:000094BB                 db  19h
.xdata$x:000094BC                 db    1
.xdata$x:000094BD                 db    0
.xdata$x:000094BE                 db    0
.xdata$x:000094BF                 db    0
.xdata$x:000094C0                 dd offset __unwindtable$?begin@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@XZ
.xdata$x:000094C4                 db    0
.xdata$x:000094C5                 db    0
.xdata$x:000094C6                 db    0
.xdata$x:000094C7                 db    0
.xdata$x:000094C8                 db    0
.xdata$x:000094C9                 db    0
.xdata$x:000094CA                 db    0
.xdata$x:000094CB                 db    0
.xdata$x:000094CC                 db    0
.xdata$x:000094CD                 db    0
.xdata$x:000094CE                 db    0
.xdata$x:000094CF                 db    0
.xdata$x:000094D0                 db    0
.xdata$x:000094D1                 db    0
.xdata$x:000094D2                 db    0
.xdata$x:000094D3                 db    0
.xdata$x:000094D4                 db    0
.xdata$x:000094D5                 db    0
.xdata$x:000094D6                 db    0
.xdata$x:000094D7                 db    0
.xdata$x:000094D8                 db    0
.xdata$x:000094D9                 db    0
.xdata$x:000094DA                 db    0
.xdata$x:000094DB                 db    0
.xdata$x:000094DB _xdata$x        ends
.xdata$x:000094DB
.xdata$x:000094DC ; ===========================================================================
.xdata$x:000094DC
.xdata$x:000094DC ; Segment type: Pure data
.xdata$x:000094DC ; Segment permissions: Read
.xdata$x:000094DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000094DC                 assume cs:_xdata$x
.xdata$x:000094DC                 ;org 94DCh
.xdata$x:000094DC ; COMDAT (pick associative to section at 7284)
.xdata$x:000094DC __unwindtable$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:000094DC                                         ; DATA XREF: .xdata$x:000094F4o
.xdata$x:000094DD                 db 0FFh
.xdata$x:000094DE                 db 0FFh
.xdata$x:000094DF                 db 0FFh
.xdata$x:000094E0                 dd offset __unwindfunclet$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$1
.xdata$x:000094E4                 align 8
.xdata$x:000094E8                 dd offset __unwindfunclet$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$0
.xdata$x:000094EC __ehfuncinfo$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:000094EC                                         ; DATA XREF: __ehhandler$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z+11o
.xdata$x:000094ED                 db    5
.xdata$x:000094EE                 db  93h ; ô
.xdata$x:000094EF                 db  19h
.xdata$x:000094F0                 db    2
.xdata$x:000094F1                 db    0
.xdata$x:000094F2                 db    0
.xdata$x:000094F3                 db    0
.xdata$x:000094F4                 dd offset __unwindtable$?_Make_iter@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.xdata$x:000094F8                 db    0
.xdata$x:000094F9                 db    0
.xdata$x:000094FA                 db    0
.xdata$x:000094FB                 db    0
.xdata$x:000094FC                 db    0
.xdata$x:000094FD                 db    0
.xdata$x:000094FE                 db    0
.xdata$x:000094FF                 db    0
.xdata$x:00009500                 db    0
.xdata$x:00009501                 db    0
.xdata$x:00009502                 db    0
.xdata$x:00009503                 db    0
.xdata$x:00009504                 db    0
.xdata$x:00009505                 db    0
.xdata$x:00009506                 db    0
.xdata$x:00009507                 db    0
.xdata$x:00009508                 db    0
.xdata$x:00009509                 db    0
.xdata$x:0000950A                 db    0
.xdata$x:0000950B                 db    0
.xdata$x:0000950C                 db    0
.xdata$x:0000950D                 db    0
.xdata$x:0000950E                 db    0
.xdata$x:0000950F                 db    0
.xdata$x:0000950F _xdata$x        ends
.xdata$x:0000950F
.xdata$x:00009510 ; ===========================================================================
.xdata$x:00009510
.xdata$x:00009510 ; Segment type: Pure data
.xdata$x:00009510 ; Segment permissions: Read
.xdata$x:00009510 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009510                 assume cs:_xdata$x
.xdata$x:00009510                 ;org 9510h
.xdata$x:00009510 ; COMDAT (pick associative to section at 875C)
.xdata$x:00009510 __unwindtable$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z db 0FFh
.xdata$x:00009510                                         ; DATA XREF: .xdata$x:00009530o
.xdata$x:00009511                 db 0FFh
.xdata$x:00009512                 db 0FFh
.xdata$x:00009513                 db 0FFh
.xdata$x:00009514                 dd offset __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$2
.xdata$x:00009518                 db    0
.xdata$x:00009519                 db    0
.xdata$x:0000951A                 db    0
.xdata$x:0000951B                 db    0
.xdata$x:0000951C                 dd offset __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$0
.xdata$x:00009520                 db    1
.xdata$x:00009521                 db    0
.xdata$x:00009522                 db    0
.xdata$x:00009523                 db    0
.xdata$x:00009524                 dd offset __unwindfunclet$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z$1
.xdata$x:00009528 __ehfuncinfo$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z db  22h ; "
.xdata$x:00009528                                         ; DATA XREF: __ehhandler$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z+11o
.xdata$x:00009529                 db    5
.xdata$x:0000952A                 db  93h ; ô
.xdata$x:0000952B                 db  19h
.xdata$x:0000952C                 db    3
.xdata$x:0000952D                 db    0
.xdata$x:0000952E                 db    0
.xdata$x:0000952F                 db    0
.xdata$x:00009530                 dd offset __unwindtable$?insert@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@ABV?$vector@EV?$allocator@E@std@@@2@@Z
.xdata$x:00009534                 db    0
.xdata$x:00009535                 db    0
.xdata$x:00009536                 db    0
.xdata$x:00009537                 db    0
.xdata$x:00009538                 db    0
.xdata$x:00009539                 db    0
.xdata$x:0000953A                 db    0
.xdata$x:0000953B                 db    0
.xdata$x:0000953C                 db    0
.xdata$x:0000953D                 db    0
.xdata$x:0000953E                 db    0
.xdata$x:0000953F                 db    0
.xdata$x:00009540                 db    0
.xdata$x:00009541                 db    0
.xdata$x:00009542                 db    0
.xdata$x:00009543                 db    0
.xdata$x:00009544                 db    0
.xdata$x:00009545                 db    0
.xdata$x:00009546                 db    0
.xdata$x:00009547                 db    0
.xdata$x:00009548                 db    0
.xdata$x:00009549                 db    0
.xdata$x:0000954A                 db    0
.xdata$x:0000954B                 db    0
.xdata$x:0000954B _xdata$x        ends
.xdata$x:0000954B
.xdata$x:0000954C ; ===========================================================================
.xdata$x:0000954C
.xdata$x:0000954C ; Segment type: Pure data
.xdata$x:0000954C ; Segment permissions: Read
.xdata$x:0000954C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000954C                 assume cs:_xdata$x
.xdata$x:0000954C                 ;org 954Ch
.xdata$x:0000954C ; COMDAT (pick associative to section at 8534)
.xdata$x:0000954C __unwindtable$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z db 0FFh
.xdata$x:0000954C                                         ; DATA XREF: .xdata$x:0000956Co
.xdata$x:0000954D                 db 0FFh
.xdata$x:0000954E                 db 0FFh
.xdata$x:0000954F                 db 0FFh
.xdata$x:00009550                 dd offset __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$2
.xdata$x:00009554                 align 8
.xdata$x:00009558                 dd offset __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$0
.xdata$x:0000955C                 db    1
.xdata$x:0000955D                 db    0
.xdata$x:0000955E                 db    0
.xdata$x:0000955F                 db    0
.xdata$x:00009560                 dd offset __unwindfunclet$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z$1
.xdata$x:00009564 __ehfuncinfo$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z db  22h ; "
.xdata$x:00009564                                         ; DATA XREF: __ehhandler$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z+11o
.xdata$x:00009565                 db    5
.xdata$x:00009566                 db  93h ; ô
.xdata$x:00009567                 db  19h
.xdata$x:00009568                 db    3
.xdata$x:00009569                 db    0
.xdata$x:0000956A                 db    0
.xdata$x:0000956B                 db    0
.xdata$x:0000956C                 dd offset __unwindtable$?erase@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@@Z
.xdata$x:00009570                 db    0
.xdata$x:00009571                 db    0
.xdata$x:00009572                 db    0
.xdata$x:00009573                 db    0
.xdata$x:00009574                 db    0
.xdata$x:00009575                 db    0
.xdata$x:00009576                 db    0
.xdata$x:00009577                 db    0
.xdata$x:00009578                 db    0
.xdata$x:00009579                 db    0
.xdata$x:0000957A                 db    0
.xdata$x:0000957B                 db    0
.xdata$x:0000957C                 db    0
.xdata$x:0000957D                 db    0
.xdata$x:0000957E                 db    0
.xdata$x:0000957F                 db    0
.xdata$x:00009580                 db    0
.xdata$x:00009581                 db    0
.xdata$x:00009582                 db    0
.xdata$x:00009583                 db    0
.xdata$x:00009584                 db    0
.xdata$x:00009585                 db    0
.xdata$x:00009586                 db    0
.xdata$x:00009587                 db    0
.xdata$x:00009587 _xdata$x        ends
.xdata$x:00009587
.xdata$x:00009588 ; ===========================================================================
.xdata$x:00009588
.xdata$x:00009588 ; Segment type: Pure data
.xdata$x:00009588 ; Segment permissions: Read
.xdata$x:00009588 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009588                 assume cs:_xdata$x
.xdata$x:00009588                 ;org 9588h
.xdata$x:00009588 ; COMDAT (pick associative to section at 6D38)
.xdata$x:00009588 __catchsym$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$10 db    0
.xdata$x:00009588                                         ; DATA XREF: .xdata$x:000095F0o
.xdata$x:00009589                 db    0
.xdata$x:0000958A                 db    0
.xdata$x:0000958B                 db    0
.xdata$x:0000958C                 db    0
.xdata$x:0000958D                 db    0
.xdata$x:0000958E                 db    0
.xdata$x:0000958F                 db    0
.xdata$x:00009590                 db    0
.xdata$x:00009591                 db    0
.xdata$x:00009592                 db    0
.xdata$x:00009593                 db    0
.xdata$x:00009594                 dd offset __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$2
.xdata$x:00009598 __catchsym$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$9 db    0
.xdata$x:00009598                                         ; DATA XREF: .xdata$x:000095DCo
.xdata$x:00009599                 db    0
.xdata$x:0000959A                 db    0
.xdata$x:0000959B                 db    0
.xdata$x:0000959C                 db    0
.xdata$x:0000959D                 db    0
.xdata$x:0000959E                 db    0
.xdata$x:0000959F                 db    0
.xdata$x:000095A0                 db    0
.xdata$x:000095A1                 db    0
.xdata$x:000095A2                 db    0
.xdata$x:000095A3                 db    0
.xdata$x:000095A4                 dd offset __catch$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$0
.xdata$x:000095A8 __ehfuncinfo$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z db  22h ; "
.xdata$x:000095A8                                         ; DATA XREF: __ehhandler$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z+11o
.xdata$x:000095A9                 db    5
.xdata$x:000095AA                 db  93h ; ô
.xdata$x:000095AB                 db  19h
.xdata$x:000095AC                 db    9
.xdata$x:000095AD                 db    0
.xdata$x:000095AE                 db    0
.xdata$x:000095AF                 db    0
.xdata$x:000095B0                 dd offset __unwindtable$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.xdata$x:000095B4                 db    2
.xdata$x:000095B5                 db    0
.xdata$x:000095B6                 db    0
.xdata$x:000095B7                 db    0
.xdata$x:000095B8                 dd offset __tryblocktable$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z
.xdata$x:000095BC                 db    0
.xdata$x:000095BD                 db    0
.xdata$x:000095BE                 db    0
.xdata$x:000095BF                 db    0
.xdata$x:000095C0                 db    0
.xdata$x:000095C1                 db    0
.xdata$x:000095C2                 db    0
.xdata$x:000095C3                 db    0
.xdata$x:000095C4                 db    0
.xdata$x:000095C5                 db    0
.xdata$x:000095C6                 db    0
.xdata$x:000095C7                 db    0
.xdata$x:000095C8                 db    0
.xdata$x:000095C9                 db    0
.xdata$x:000095CA                 db    0
.xdata$x:000095CB                 db    0
.xdata$x:000095CC __tryblocktable$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z db    2
.xdata$x:000095CC                                         ; DATA XREF: .xdata$x:000095B8o
.xdata$x:000095CD                 db    0
.xdata$x:000095CE                 db    0
.xdata$x:000095CF                 db    0
.xdata$x:000095D0                 db    2
.xdata$x:000095D1                 db    0
.xdata$x:000095D2                 db    0
.xdata$x:000095D3                 db    0
.xdata$x:000095D4                 db    3
.xdata$x:000095D5                 db    0
.xdata$x:000095D6                 db    0
.xdata$x:000095D7                 db    0
.xdata$x:000095D8                 db    1
.xdata$x:000095D9                 db    0
.xdata$x:000095DA                 db    0
.xdata$x:000095DB                 db    0
.xdata$x:000095DC                 dd offset __catchsym$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$9
.xdata$x:000095E0                 db    5
.xdata$x:000095E1                 db    0
.xdata$x:000095E2                 db    0
.xdata$x:000095E3                 db    0
.xdata$x:000095E4                 db    5
.xdata$x:000095E5                 db    0
.xdata$x:000095E6                 db    0
.xdata$x:000095E7                 db    0
.xdata$x:000095E8                 db    6
.xdata$x:000095E9                 db    0
.xdata$x:000095EA                 db    0
.xdata$x:000095EB                 db    0
.xdata$x:000095EC                 db    1
.xdata$x:000095ED                 db    0
.xdata$x:000095EE                 db    0
.xdata$x:000095EF                 db    0
.xdata$x:000095F0                 dd offset __catchsym$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$10
.xdata$x:000095F4 __unwindtable$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z db 0FFh
.xdata$x:000095F4                                         ; DATA XREF: .xdata$x:000095B0o
.xdata$x:000095F5                 db 0FFh
.xdata$x:000095F6                 db 0FFh
.xdata$x:000095F7                 db 0FFh
.xdata$x:000095F8                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$8
.xdata$x:000095FC                 align 10h
.xdata$x:00009600                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$4
.xdata$x:00009604                 db    1
.xdata$x:00009605                 db    0
.xdata$x:00009606                 db    0
.xdata$x:00009607                 db    0
.xdata$x:00009608                 db    0
.xdata$x:00009609                 db    0
.xdata$x:0000960A                 db    0
.xdata$x:0000960B                 db    0
.xdata$x:0000960C                 db    1
.xdata$x:0000960D                 db    0
.xdata$x:0000960E                 db    0
.xdata$x:0000960F                 db    0
.xdata$x:00009610                 db    0
.xdata$x:00009611                 db    0
.xdata$x:00009612                 db    0
.xdata$x:00009613                 db    0
.xdata$x:00009614                 db    1
.xdata$x:00009615                 db    0
.xdata$x:00009616                 db    0
.xdata$x:00009617                 db    0
.xdata$x:00009618                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$5
.xdata$x:0000961C                 db    4
.xdata$x:0000961D                 db    0
.xdata$x:0000961E                 db    0
.xdata$x:0000961F                 db    0
.xdata$x:00009620                 db    0
.xdata$x:00009621                 db    0
.xdata$x:00009622                 db    0
.xdata$x:00009623                 db    0
.xdata$x:00009624                 db    4
.xdata$x:00009625                 db    0
.xdata$x:00009626                 db    0
.xdata$x:00009627                 db    0
.xdata$x:00009628                 db    0
.xdata$x:00009629                 db    0
.xdata$x:0000962A                 db    0
.xdata$x:0000962B                 db    0
.xdata$x:0000962C                 db    1
.xdata$x:0000962D                 db    0
.xdata$x:0000962E                 db    0
.xdata$x:0000962F                 db    0
.xdata$x:00009630                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$6
.xdata$x:00009634                 db    1
.xdata$x:00009635                 db    0
.xdata$x:00009636                 db    0
.xdata$x:00009637                 db    0
.xdata$x:00009638                 dd offset __unwindfunclet$?_Insert_n@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@2@IABV?$vector@EV?$allocator@E@std@@@2@@Z$7
.xdata$x:00009638 _xdata$x        ends
.xdata$x:00009638
.xdata$x:0000963C ; ===========================================================================
.xdata$x:0000963C
.xdata$x:0000963C ; Segment type: Pure data
.xdata$x:0000963C ; Segment permissions: Read
.xdata$x:0000963C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000963C                 assume cs:_xdata$x
.xdata$x:0000963C                 ;org 963Ch
.xdata$x:0000963C ; COMDAT (pick associative to section at 75B0)
.xdata$x:0000963C __unwindtable$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z db 0FFh
.xdata$x:0000963C                                         ; DATA XREF: .xdata$x:0000964Co
.xdata$x:0000963D                 db 0FFh
.xdata$x:0000963E                 db 0FFh
.xdata$x:0000963F                 db 0FFh
.xdata$x:00009640                 dd offset __unwindfunclet$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z$0
.xdata$x:00009644 __ehfuncinfo$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z db  22h ; "
.xdata$x:00009644                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z+11o
.xdata$x:00009645                 db    5
.xdata$x:00009646                 db  93h ; ô
.xdata$x:00009647                 db  19h
.xdata$x:00009648                 db    1
.xdata$x:00009649                 db    0
.xdata$x:0000964A                 db    0
.xdata$x:0000964B                 db    0
.xdata$x:0000964C                 dd offset __unwindtable$?_Orphan_range@?$vector@V?$vector@EV?$allocator@E@std@@@std@@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@@std@@IBEXPAV?$vector@EV?$allocator@E@std@@@2@0@Z
.xdata$x:00009650                 db    0
.xdata$x:00009651                 db    0
.xdata$x:00009652                 db    0
.xdata$x:00009653                 db    0
.xdata$x:00009654                 db    0
.xdata$x:00009655                 db    0
.xdata$x:00009656                 db    0
.xdata$x:00009657                 db    0
.xdata$x:00009658                 db    0
.xdata$x:00009659                 db    0
.xdata$x:0000965A                 db    0
.xdata$x:0000965B                 db    0
.xdata$x:0000965C                 db    0
.xdata$x:0000965D                 db    0
.xdata$x:0000965E                 db    0
.xdata$x:0000965F                 db    0
.xdata$x:00009660                 db    0
.xdata$x:00009661                 db    0
.xdata$x:00009662                 db    0
.xdata$x:00009663                 db    0
.xdata$x:00009664                 db    0
.xdata$x:00009665                 db    0
.xdata$x:00009666                 db    0
.xdata$x:00009667                 db    0
.xdata$x:00009667 _xdata$x        ends
.xdata$x:00009667
.xdata$x:00009668 ; ===========================================================================
.xdata$x:00009668
.xdata$x:00009668 ; Segment type: Pure data
.xdata$x:00009668 ; Segment permissions: Read
.xdata$x:00009668 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009668                 assume cs:_xdata$x
.xdata$x:00009668                 ;org 9668h
.xdata$x:00009668 ; COMDAT (pick associative to section at 481C)
.xdata$x:00009668 __unwindtable$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009668                                         ; DATA XREF: .xdata$x:00009678o
.xdata$x:00009669                 db 0FFh
.xdata$x:0000966A                 db 0FFh
.xdata$x:0000966B                 db 0FFh
.xdata$x:0000966C                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ$0
.xdata$x:00009670 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009670                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ+11o
.xdata$x:00009671                 db    5
.xdata$x:00009672                 db  93h ; ô
.xdata$x:00009673                 db  19h
.xdata$x:00009674                 db    1
.xdata$x:00009675                 db    0
.xdata$x:00009676                 db    0
.xdata$x:00009677                 db    0
.xdata$x:00009678                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.xdata$x:0000967C                 db    0
.xdata$x:0000967D                 db    0
.xdata$x:0000967E                 db    0
.xdata$x:0000967F                 db    0
.xdata$x:00009680                 db    0
.xdata$x:00009681                 db    0
.xdata$x:00009682                 db    0
.xdata$x:00009683                 db    0
.xdata$x:00009684                 db    0
.xdata$x:00009685                 db    0
.xdata$x:00009686                 db    0
.xdata$x:00009687                 db    0
.xdata$x:00009688                 db    0
.xdata$x:00009689                 db    0
.xdata$x:0000968A                 db    0
.xdata$x:0000968B                 db    0
.xdata$x:0000968C                 db    0
.xdata$x:0000968D                 db    0
.xdata$x:0000968E                 db    0
.xdata$x:0000968F                 db    0
.xdata$x:00009690                 db    0
.xdata$x:00009691                 db    0
.xdata$x:00009692                 db    0
.xdata$x:00009693                 db    0
.xdata$x:00009693 _xdata$x        ends
.xdata$x:00009693
.xdata$x:00009694 ; ===========================================================================
.xdata$x:00009694
.xdata$x:00009694 ; Segment type: Pure data
.xdata$x:00009694 ; Segment permissions: Read
.xdata$x:00009694 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009694                 assume cs:_xdata$x
.xdata$x:00009694                 ;org 9694h
.xdata$x:00009694 ; COMDAT (pick associative to section at 5410)
.xdata$x:00009694 __unwindtable$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009694                                         ; DATA XREF: .xdata$x:000096A4o
.xdata$x:00009695                 db 0FFh
.xdata$x:00009696                 db 0FFh
.xdata$x:00009697                 db 0FFh
.xdata$x:00009698                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ$0
.xdata$x:0000969C __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000969C                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ+11o
.xdata$x:0000969D                 db    5
.xdata$x:0000969E                 db  93h ; ô
.xdata$x:0000969F                 db  19h
.xdata$x:000096A0                 db    1
.xdata$x:000096A1                 db    0
.xdata$x:000096A2                 db    0
.xdata$x:000096A3                 db    0
.xdata$x:000096A4                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@E@std@@@std@@QAE@XZ
.xdata$x:000096A8                 align 20h
.xdata$x:000096A8 _xdata$x        ends
.xdata$x:000096A8
.xdata$x:000096C0 ; ===========================================================================
.xdata$x:000096C0
.xdata$x:000096C0 ; Segment type: Pure data
.xdata$x:000096C0 ; Segment permissions: Read
.xdata$x:000096C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000096C0                 assume cs:_xdata$x
.xdata$x:000096C0                 ;org 96C0h
.xdata$x:000096C0 ; COMDAT (pick associative to section at 4398)
.xdata$x:000096C0 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z db 0FFh
.xdata$x:000096C0                                         ; DATA XREF: .xdata$x:000096D0o
.xdata$x:000096C1                 db 0FFh
.xdata$x:000096C2                 db 0FFh
.xdata$x:000096C3                 db 0FFh
.xdata$x:000096C4                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z$0
.xdata$x:000096C8 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z db  22h ; "
.xdata$x:000096C8                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z+11o
.xdata$x:000096C9                 db    5
.xdata$x:000096CA                 db  93h ; ô
.xdata$x:000096CB                 db  19h
.xdata$x:000096CC                 db    1
.xdata$x:000096CD                 db    0
.xdata$x:000096CE                 db    0
.xdata$x:000096CF                 db    0
.xdata$x:000096D0                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@ABV?$allocator@E@1@@Z
.xdata$x:000096D4                 db    0
.xdata$x:000096D5                 db    0
.xdata$x:000096D6                 db    0
.xdata$x:000096D7                 db    0
.xdata$x:000096D8                 db    0
.xdata$x:000096D9                 db    0
.xdata$x:000096DA                 db    0
.xdata$x:000096DB                 db    0
.xdata$x:000096DC                 db    0
.xdata$x:000096DD                 db    0
.xdata$x:000096DE                 db    0
.xdata$x:000096DF                 db    0
.xdata$x:000096E0                 db    0
.xdata$x:000096E1                 db    0
.xdata$x:000096E2                 db    0
.xdata$x:000096E3                 db    0
.xdata$x:000096E4                 db    0
.xdata$x:000096E5                 db    0
.xdata$x:000096E6                 db    0
.xdata$x:000096E7                 db    0
.xdata$x:000096E8                 db    0
.xdata$x:000096E9                 db    0
.xdata$x:000096EA                 db    0
.xdata$x:000096EB                 db    0
.xdata$x:000096EB _xdata$x        ends
.xdata$x:000096EB
.xdata$x:000096EC ; ===========================================================================
.xdata$x:000096EC
.xdata$x:000096EC ; Segment type: Pure data
.xdata$x:000096EC ; Segment permissions: Read
.xdata$x:000096EC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000096EC                 assume cs:_xdata$x
.xdata$x:000096EC                 ;org 96ECh
.xdata$x:000096EC ; COMDAT (pick associative to section at 51D8)
.xdata$x:000096EC __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000096EC                                         ; DATA XREF: .xdata$x:000096FCo
.xdata$x:000096ED                 db 0FFh
.xdata$x:000096EE                 db 0FFh
.xdata$x:000096EF                 db 0FFh
.xdata$x:000096F0                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ$0
.xdata$x:000096F4 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000096F4                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:000096F5                 db    5
.xdata$x:000096F6                 db  93h ; ô
.xdata$x:000096F7                 db  19h
.xdata$x:000096F8                 db    1
.xdata$x:000096F9                 db    0
.xdata$x:000096FA                 db    0
.xdata$x:000096FB                 db    0
.xdata$x:000096FC                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@EV?$allocator@E@std@@@std@@@std@@QAE@XZ
.xdata$x:00009700                 db    0
.xdata$x:00009701                 db    0
.xdata$x:00009702                 db    0
.xdata$x:00009703                 db    0
.xdata$x:00009704                 db    0
.xdata$x:00009705                 db    0
.xdata$x:00009706                 db    0
.xdata$x:00009707                 db    0
.xdata$x:00009708                 db    0
.xdata$x:00009709                 db    0
.xdata$x:0000970A                 db    0
.xdata$x:0000970B                 db    0
.xdata$x:0000970C                 db    0
.xdata$x:0000970D                 db    0
.xdata$x:0000970E                 db    0
.xdata$x:0000970F                 db    0
.xdata$x:00009710                 db    0
.xdata$x:00009711                 db    0
.xdata$x:00009712                 db    0
.xdata$x:00009713                 db    0
.xdata$x:00009714                 db    0
.xdata$x:00009715                 db    0
.xdata$x:00009716                 db    0
.xdata$x:00009717                 db    0
.xdata$x:00009717 _xdata$x        ends
.xdata$x:00009717
.xdata$x:00009718 ; ===========================================================================
.xdata$x:00009718
.xdata$x:00009718 ; Segment type: Pure data
.xdata$x:00009718 ; Segment permissions: Read
.xdata$x:00009718 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009718                 assume cs:_xdata$x
.xdata$x:00009718                 ;org 9718h
.xdata$x:00009718 ; COMDAT (pick associative to section at 4D04)
.xdata$x:00009718 __unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009718                                         ; DATA XREF: .xdata$x:00009728o
.xdata$x:00009719                 db 0FFh
.xdata$x:0000971A                 db 0FFh
.xdata$x:0000971B                 db 0FFh
.xdata$x:0000971C                 dd offset __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0
.xdata$x:00009720 __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009720                                         ; DATA XREF: __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ+11o
.xdata$x:00009721                 db    5
.xdata$x:00009722                 db  93h ; ô
.xdata$x:00009723                 db  19h
.xdata$x:00009724                 db    1
.xdata$x:00009725                 db    0
.xdata$x:00009726                 db    0
.xdata$x:00009727                 db    0
.xdata$x:00009728                 dd offset __unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.xdata$x:0000972C                 db    0
.xdata$x:0000972D                 db    0
.xdata$x:0000972E                 db    0
.xdata$x:0000972F                 db    0
.xdata$x:00009730                 db    0
.xdata$x:00009731                 db    0
.xdata$x:00009732                 db    0
.xdata$x:00009733                 db    0
.xdata$x:00009734                 db    0
.xdata$x:00009735                 db    0
.xdata$x:00009736                 db    0
.xdata$x:00009737                 db    0
.xdata$x:00009738                 db    0
.xdata$x:00009739                 db    0
.xdata$x:0000973A                 db    0
.xdata$x:0000973B                 db    0
.xdata$x:0000973C                 db    0
.xdata$x:0000973D                 db    0
.xdata$x:0000973E                 db    0
.xdata$x:0000973F                 db    0
.xdata$x:00009740                 db    0
.xdata$x:00009741                 db    0
.xdata$x:00009742                 db    0
.xdata$x:00009743                 db    0
.xdata$x:00009743 _xdata$x        ends
.xdata$x:00009743
.xdata$x:00009744 ; ===========================================================================
.xdata$x:00009744
.xdata$x:00009744 ; Segment type: Pure data
.xdata$x:00009744 ; Segment permissions: Read
.xdata$x:00009744 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009744                 assume cs:_xdata$x
.xdata$x:00009744                 ;org 9744h
.xdata$x:00009744 ; COMDAT (pick associative to section at 4BB8)
.xdata$x:00009744 __catchsym$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:00009744                                         ; DATA XREF: .xdata$x:00009764o
.xdata$x:00009745                 db    0
.xdata$x:00009746                 db    0
.xdata$x:00009747                 db    0
.xdata$x:00009748                 db    0
.xdata$x:00009749                 db    0
.xdata$x:0000974A                 db    0
.xdata$x:0000974B                 db    0
.xdata$x:0000974C                 db    0
.xdata$x:0000974D                 db    0
.xdata$x:0000974E                 db    0
.xdata$x:0000974F                 db    0
.xdata$x:00009750                 dd offset __catch$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009754 __tryblocktable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:00009754                                         ; DATA XREF: .xdata$x:00009778o
.xdata$x:00009755                 db    0
.xdata$x:00009756                 db    0
.xdata$x:00009757                 db    0
.xdata$x:00009758                 db    3
.xdata$x:00009759                 db    0
.xdata$x:0000975A                 db    0
.xdata$x:0000975B                 db    0
.xdata$x:0000975C                 db    4
.xdata$x:0000975D                 db    0
.xdata$x:0000975E                 db    0
.xdata$x:0000975F                 db    0
.xdata$x:00009760                 db    1
.xdata$x:00009761                 db    0
.xdata$x:00009762                 db    0
.xdata$x:00009763                 db    0
.xdata$x:00009764                 dd offset __catchsym$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:00009768 __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009768                                         ; DATA XREF: __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009769                 db    5
.xdata$x:0000976A                 db  93h ; ô
.xdata$x:0000976B                 db  19h
.xdata$x:0000976C                 db    5
.xdata$x:0000976D                 db    0
.xdata$x:0000976E                 db    0
.xdata$x:0000976F                 db    0
.xdata$x:00009770                 dd offset __unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009774                 db    1
.xdata$x:00009775                 db    0
.xdata$x:00009776                 db    0
.xdata$x:00009777                 db    0
.xdata$x:00009778                 dd offset __tryblocktable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000977C                 db    0
.xdata$x:0000977D                 db    0
.xdata$x:0000977E                 db    0
.xdata$x:0000977F                 db    0
.xdata$x:00009780                 db    0
.xdata$x:00009781                 db    0
.xdata$x:00009782                 db    0
.xdata$x:00009783                 db    0
.xdata$x:00009784                 db    0
.xdata$x:00009785                 db    0
.xdata$x:00009786                 db    0
.xdata$x:00009787                 db    0
.xdata$x:00009788                 db    0
.xdata$x:00009789                 db    0
.xdata$x:0000978A                 db    0
.xdata$x:0000978B                 db    0
.xdata$x:0000978C __unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000978C                                         ; DATA XREF: .xdata$x:00009770o
.xdata$x:0000978D                 db 0FFh
.xdata$x:0000978E                 db 0FFh
.xdata$x:0000978F                 db 0FFh
.xdata$x:00009790                 dd offset __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:00009794                 db    0
.xdata$x:00009795                 db    0
.xdata$x:00009796                 db    0
.xdata$x:00009797                 db    0
.xdata$x:00009798                 db    0
.xdata$x:00009799                 db    0
.xdata$x:0000979A                 db    0
.xdata$x:0000979B                 db    0
.xdata$x:0000979C                 db    1
.xdata$x:0000979D                 db    0
.xdata$x:0000979E                 db    0
.xdata$x:0000979F                 db    0
.xdata$x:000097A0                 dd offset __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:000097A4                 db    2
.xdata$x:000097A5                 db    0
.xdata$x:000097A6                 db    0
.xdata$x:000097A7                 db    0
.xdata$x:000097A8                 dd offset __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:000097AC                 db    0
.xdata$x:000097AD                 db    0
.xdata$x:000097AE                 db    0
.xdata$x:000097AF                 db    0
.xdata$x:000097B0                 db    0
.xdata$x:000097B1                 db    0
.xdata$x:000097B2                 db    0
.xdata$x:000097B3                 db    0
.xdata$x:000097B3 _xdata$x        ends
.xdata$x:000097B3
.xdata$x:000097B4 ; ===========================================================================
.xdata$x:000097B4
.xdata$x:000097B4 ; Segment type: Pure data
.xdata$x:000097B4 ; Segment permissions: Read
.xdata$x:000097B4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097B4                 assume cs:_xdata$x
.xdata$x:000097B4                 ;org 97B4h
.xdata$x:000097B4 ; COMDAT (pick associative to section at 4B14)
.xdata$x:000097B4 __unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z db 0FFh
.xdata$x:000097B4                                         ; DATA XREF: .xdata$x:000097C4o
.xdata$x:000097B5                 db 0FFh
.xdata$x:000097B6                 db 0FFh
.xdata$x:000097B7                 db 0FFh
.xdata$x:000097B8                 dd offset __unwindfunclet$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z$0
.xdata$x:000097BC __ehfuncinfo$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z db  22h ; "
.xdata$x:000097BC                                         ; DATA XREF: __ehhandler$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z+11o
.xdata$x:000097BD                 db    5
.xdata$x:000097BE                 db  93h ; ô
.xdata$x:000097BF                 db  19h
.xdata$x:000097C0                 db    1
.xdata$x:000097C1                 db    0
.xdata$x:000097C2                 db    0
.xdata$x:000097C3                 db    0
.xdata$x:000097C4                 dd offset __unwindtable$??0?$vector@EV?$allocator@E@std@@@std@@QAE@$$QAV01@@Z
.xdata$x:000097C8                 align 20h
.xdata$x:000097C8 _xdata$x        ends
.xdata$x:000097C8
.xdata$x:000097E0 ; ===========================================================================
.xdata$x:000097E0
.xdata$x:000097E0 ; Segment type: Pure data
.xdata$x:000097E0 ; Segment permissions: Read
.xdata$x:000097E0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000097E0                 assume cs:_xdata$x
.xdata$x:000097E0                 ;org 97E0h
.xdata$x:000097E0 ; COMDAT (pick associative to section at 65A0)
.xdata$x:000097E0 __unwindtable$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z db 0FFh
.xdata$x:000097E0                                         ; DATA XREF: .xdata$x:00009808o
.xdata$x:000097E1                 db 0FFh
.xdata$x:000097E2                 db 0FFh
.xdata$x:000097E3                 db 0FFh
.xdata$x:000097E4                 dd offset __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$0
.xdata$x:000097E8                 db 0FFh
.xdata$x:000097E9                 db 0FFh
.xdata$x:000097EA                 db 0FFh
.xdata$x:000097EB                 db 0FFh
.xdata$x:000097EC                 dd offset __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$1
.xdata$x:000097F0                 db    1
.xdata$x:000097F1                 db    0
.xdata$x:000097F2                 db    0
.xdata$x:000097F3                 db    0
.xdata$x:000097F4                 dd offset __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$2
.xdata$x:000097F8                 db    1
.xdata$x:000097F9                 db    0
.xdata$x:000097FA                 db    0
.xdata$x:000097FB                 db    0
.xdata$x:000097FC                 dd offset __unwindfunclet$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z$3
.xdata$x:00009800 __ehfuncinfo$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z db  22h ; "
.xdata$x:00009800                                         ; DATA XREF: __ehhandler$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z+11o
.xdata$x:00009801                 db    5
.xdata$x:00009802                 db  93h ; ô
.xdata$x:00009803                 db  19h
.xdata$x:00009804                 db    4
.xdata$x:00009805                 db    0
.xdata$x:00009806                 db    0
.xdata$x:00009807                 db    0
.xdata$x:00009808                 dd offset __unwindtable$?_Assign_rv@?$vector@EV?$allocator@E@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$0A@@2@@Z
.xdata$x:0000980C                 db    0
.xdata$x:0000980D                 db    0
.xdata$x:0000980E                 db    0
.xdata$x:0000980F                 db    0
.xdata$x:00009810                 db    0
.xdata$x:00009811                 db    0
.xdata$x:00009812                 db    0
.xdata$x:00009813                 db    0
.xdata$x:00009814                 db    0
.xdata$x:00009815                 db    0
.xdata$x:00009816                 db    0
.xdata$x:00009817                 db    0
.xdata$x:00009818                 db    0
.xdata$x:00009819                 db    0
.xdata$x:0000981A                 db    0
.xdata$x:0000981B                 db    0
.xdata$x:0000981C                 db    0
.xdata$x:0000981D                 db    0
.xdata$x:0000981E                 db    0
.xdata$x:0000981F                 db    0
.xdata$x:00009820                 db    0
.xdata$x:00009821                 db    0
.xdata$x:00009822                 db    0
.xdata$x:00009823                 db    0
.xdata$x:00009823 _xdata$x        ends
.xdata$x:00009823
.xdata$x:00009824 ; ===========================================================================
.xdata$x:00009824
.xdata$x:00009824 ; Segment type: Pure data
.xdata$x:00009824 ; Segment permissions: Read
.xdata$x:00009824 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009824                 assume cs:_xdata$x
.xdata$x:00009824                 ;org 9824h
.xdata$x:00009824 ; COMDAT (pick associative to section at 556C)
.xdata$x:00009824 __unwindtable$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009824                                         ; DATA XREF: .xdata$x:00009834o
.xdata$x:00009825                 db 0FFh
.xdata$x:00009826                 db 0FFh
.xdata$x:00009827                 db 0FFh
.xdata$x:00009828                 dd offset __unwindfunclet$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ$0
.xdata$x:0000982C __ehfuncinfo$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000982C                                         ; DATA XREF: __ehhandler$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ+11o
.xdata$x:0000982D                 db    5
.xdata$x:0000982E                 db  93h ; ô
.xdata$x:0000982F                 db  19h
.xdata$x:00009830                 db    1
.xdata$x:00009831                 db    0
.xdata$x:00009832                 db    0
.xdata$x:00009833                 db    0
.xdata$x:00009834                 dd offset __unwindtable$??1?$vector@EV?$allocator@E@std@@@std@@QAE@XZ
.xdata$x:00009838                 db    0
.xdata$x:00009839                 db    0
.xdata$x:0000983A                 db    0
.xdata$x:0000983B                 db    0
.xdata$x:0000983C                 db    0
.xdata$x:0000983D                 db    0
.xdata$x:0000983E                 db    0
.xdata$x:0000983F                 db    0
.xdata$x:00009840                 db    0
.xdata$x:00009841                 db    0
.xdata$x:00009842                 db    0
.xdata$x:00009843                 db    0
.xdata$x:00009844                 db    0
.xdata$x:00009845                 db    0
.xdata$x:00009846                 db    0
.xdata$x:00009847                 db    0
.xdata$x:00009848                 db    0
.xdata$x:00009849                 db    0
.xdata$x:0000984A                 db    0
.xdata$x:0000984B                 db    0
.xdata$x:0000984C                 db    0
.xdata$x:0000984D                 db    0
.xdata$x:0000984E                 db    0
.xdata$x:0000984F                 db    0
.xdata$x:0000984F _xdata$x        ends
.xdata$x:0000984F
.xdata$x:00009850 ; ===========================================================================
.xdata$x:00009850
.xdata$x:00009850 ; Segment type: Pure data
.xdata$x:00009850 ; Segment permissions: Read
.xdata$x:00009850 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009850                 assume cs:_xdata$x
.xdata$x:00009850                 ;org 9850h
.xdata$x:00009850 ; COMDAT (pick associative to section at 58EC)
.xdata$x:00009850 __catchsym$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z$2 db    0
.xdata$x:00009850                                         ; DATA XREF: .xdata$x:00009880o
.xdata$x:00009851                 db    0
.xdata$x:00009852                 db    0
.xdata$x:00009853                 db    0
.xdata$x:00009854                 db    0
.xdata$x:00009855                 db    0
.xdata$x:00009856                 db    0
.xdata$x:00009857                 db    0
.xdata$x:00009858                 db    0
.xdata$x:00009859                 db    0
.xdata$x:0000985A                 db    0
.xdata$x:0000985B                 db    0
.xdata$x:0000985C                 dd offset __catch$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z$0
.xdata$x:00009860 __unwindtable$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z db 0FFh
.xdata$x:00009860                                         ; DATA XREF: .xdata$x:0000988Co
.xdata$x:00009861                 db 0FFh
.xdata$x:00009862                 db 0FFh
.xdata$x:00009863                 db 0FFh
.xdata$x:00009864                 db    0
.xdata$x:00009865                 db    0
.xdata$x:00009866                 db    0
.xdata$x:00009867                 db    0
.xdata$x:00009868                 db 0FFh
.xdata$x:00009869                 db 0FFh
.xdata$x:0000986A                 db 0FFh
.xdata$x:0000986B                 db 0FFh
.xdata$x:0000986C                 db    0
.xdata$x:0000986D                 db    0
.xdata$x:0000986E                 db    0
.xdata$x:0000986F                 db    0
.xdata$x:00009870 __tryblocktable$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z db    0
.xdata$x:00009870                                         ; DATA XREF: .xdata$x:00009894o
.xdata$x:00009871                 db    0
.xdata$x:00009872                 db    0
.xdata$x:00009873                 db    0
.xdata$x:00009874                 db    0
.xdata$x:00009875                 db    0
.xdata$x:00009876                 db    0
.xdata$x:00009877                 db    0
.xdata$x:00009878                 db    1
.xdata$x:00009879                 db    0
.xdata$x:0000987A                 db    0
.xdata$x:0000987B                 db    0
.xdata$x:0000987C                 db    1
.xdata$x:0000987D                 db    0
.xdata$x:0000987E                 db    0
.xdata$x:0000987F                 db    0
.xdata$x:00009880                 dd offset __catchsym$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z$2
.xdata$x:00009884 __ehfuncinfo$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z db  22h ; "
.xdata$x:00009884                                         ; DATA XREF: __ehhandler$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z+11o
.xdata$x:00009885                 db    5
.xdata$x:00009886                 db  93h ; ô
.xdata$x:00009887                 db  19h
.xdata$x:00009888                 db    2
.xdata$x:00009889                 db    0
.xdata$x:0000988A                 db    0
.xdata$x:0000988B                 db    0
.xdata$x:0000988C                 dd offset __unwindtable$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:00009890                 db    1
.xdata$x:00009891                 db    0
.xdata$x:00009892                 db    0
.xdata$x:00009893                 db    0
.xdata$x:00009894                 dd offset __tryblocktable$??4?$vector@EV?$allocator@E@std@@@std@@QAEAAV01@ABV01@@Z
.xdata$x:00009898                 db    0
.xdata$x:00009899                 db    0
.xdata$x:0000989A                 db    0
.xdata$x:0000989B                 db    0
.xdata$x:0000989C                 db    0
.xdata$x:0000989D                 db    0
.xdata$x:0000989E                 db    0
.xdata$x:0000989F                 db    0
.xdata$x:000098A0                 db    0
.xdata$x:000098A1                 db    0
.xdata$x:000098A2                 db    0
.xdata$x:000098A3                 db    0
.xdata$x:000098A4                 db    0
.xdata$x:000098A5                 db    0
.xdata$x:000098A6                 db    0
.xdata$x:000098A7                 db    0
.xdata$x:000098A7 _xdata$x        ends
.xdata$x:000098A7
.xdata$x:000098A8 ; ===========================================================================
.xdata$x:000098A8
.xdata$x:000098A8 ; Segment type: Pure data
.xdata$x:000098A8 ; Segment permissions: Read
.xdata$x:000098A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098A8                 assume cs:_xdata$x
.xdata$x:000098A8                 ;org 98A8h
.xdata$x:000098A8 ; COMDAT (pick associative to section at 7E00)
.xdata$x:000098A8 __unwindtable$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db 0FFh
.xdata$x:000098A8                                         ; DATA XREF: .xdata$x:000098B8o
.xdata$x:000098A9                 db 0FFh
.xdata$x:000098AA                 db 0FFh
.xdata$x:000098AB                 db 0FFh
.xdata$x:000098AC                 dd offset __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0
.xdata$x:000098B0 __ehfuncinfo$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000098B0                                         ; DATA XREF: __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ+11o
.xdata$x:000098B1                 db    5
.xdata$x:000098B2                 db  93h ; ô
.xdata$x:000098B3                 db  19h
.xdata$x:000098B4                 db    1
.xdata$x:000098B5                 db    0
.xdata$x:000098B6                 db    0
.xdata$x:000098B7                 db    0
.xdata$x:000098B8                 dd offset __unwindtable$?begin@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.xdata$x:000098BC                 db    0
.xdata$x:000098BD                 db    0
.xdata$x:000098BE                 db    0
.xdata$x:000098BF                 db    0
.xdata$x:000098C0                 db    0
.xdata$x:000098C1                 db    0
.xdata$x:000098C2                 db    0
.xdata$x:000098C3                 db    0
.xdata$x:000098C4                 db    0
.xdata$x:000098C5                 db    0
.xdata$x:000098C6                 db    0
.xdata$x:000098C7                 db    0
.xdata$x:000098C8                 db    0
.xdata$x:000098C9                 db    0
.xdata$x:000098CA                 db    0
.xdata$x:000098CB                 db    0
.xdata$x:000098CC                 db    0
.xdata$x:000098CD                 db    0
.xdata$x:000098CE                 db    0
.xdata$x:000098CF                 db    0
.xdata$x:000098D0                 db    0
.xdata$x:000098D1                 db    0
.xdata$x:000098D2                 db    0
.xdata$x:000098D3                 db    0
.xdata$x:000098D3 _xdata$x        ends
.xdata$x:000098D3
.xdata$x:000098D4 ; ===========================================================================
.xdata$x:000098D4
.xdata$x:000098D4 ; Segment type: Pure data
.xdata$x:000098D4 ; Segment permissions: Read
.xdata$x:000098D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000098D4                 assume cs:_xdata$x
.xdata$x:000098D4                 ;org 98D4h
.xdata$x:000098D4 ; COMDAT (pick associative to section at 7E9C)
.xdata$x:000098D4 __unwindtable$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db 0FFh
.xdata$x:000098D4                                         ; DATA XREF: .xdata$x:000098E4o
.xdata$x:000098D5                 db 0FFh
.xdata$x:000098D6                 db 0FFh
.xdata$x:000098D7                 db 0FFh
.xdata$x:000098D8                 dd offset __unwindfunclet$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0
.xdata$x:000098DC __ehfuncinfo$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db  22h ; "
.xdata$x:000098DC                                         ; DATA XREF: __ehhandler$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ+11o
.xdata$x:000098DD                 db    5
.xdata$x:000098DE                 db  93h ; ô
.xdata$x:000098DF                 db  19h
.xdata$x:000098E0                 db    1
.xdata$x:000098E1                 db    0
.xdata$x:000098E2                 db    0
.xdata$x:000098E3                 db    0
.xdata$x:000098E4                 dd offset __unwindtable$?begin@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.xdata$x:000098E8                 align 20h
.xdata$x:000098E8 _xdata$x        ends
.xdata$x:000098E8
.xdata$x:00009900 ; ===========================================================================
.xdata$x:00009900
.xdata$x:00009900 ; Segment type: Pure data
.xdata$x:00009900 ; Segment permissions: Read
.xdata$x:00009900 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009900                 assume cs:_xdata$x
.xdata$x:00009900                 ;org 9900h
.xdata$x:00009900 ; COMDAT (pick associative to section at 82CC)
.xdata$x:00009900 __unwindtable$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db 0FFh
.xdata$x:00009900                                         ; DATA XREF: .xdata$x:00009910o
.xdata$x:00009901                 db 0FFh
.xdata$x:00009902                 db 0FFh
.xdata$x:00009903                 db 0FFh
.xdata$x:00009904                 dd offset __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0
.xdata$x:00009908 __ehfuncinfo$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00009908                                         ; DATA XREF: __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ+11o
.xdata$x:00009909                 db    5
.xdata$x:0000990A                 db  93h ; ô
.xdata$x:0000990B                 db  19h
.xdata$x:0000990C                 db    1
.xdata$x:0000990D                 db    0
.xdata$x:0000990E                 db    0
.xdata$x:0000990F                 db    0
.xdata$x:00009910                 dd offset __unwindtable$?end@?$vector@EV?$allocator@E@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.xdata$x:00009914                 db    0
.xdata$x:00009915                 db    0
.xdata$x:00009916                 db    0
.xdata$x:00009917                 db    0
.xdata$x:00009918                 db    0
.xdata$x:00009919                 db    0
.xdata$x:0000991A                 db    0
.xdata$x:0000991B                 db    0
.xdata$x:0000991C                 db    0
.xdata$x:0000991D                 db    0
.xdata$x:0000991E                 db    0
.xdata$x:0000991F                 db    0
.xdata$x:00009920                 db    0
.xdata$x:00009921                 db    0
.xdata$x:00009922                 db    0
.xdata$x:00009923                 db    0
.xdata$x:00009924                 db    0
.xdata$x:00009925                 db    0
.xdata$x:00009926                 db    0
.xdata$x:00009927                 db    0
.xdata$x:00009928                 db    0
.xdata$x:00009929                 db    0
.xdata$x:0000992A                 db    0
.xdata$x:0000992B                 db    0
.xdata$x:0000992B _xdata$x        ends
.xdata$x:0000992B
.xdata$x:0000992C ; ===========================================================================
.xdata$x:0000992C
.xdata$x:0000992C ; Segment type: Pure data
.xdata$x:0000992C ; Segment permissions: Read
.xdata$x:0000992C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000992C                 assume cs:_xdata$x
.xdata$x:0000992C                 ;org 992Ch
.xdata$x:0000992C ; COMDAT (pick associative to section at 8368)
.xdata$x:0000992C __unwindtable$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db 0FFh
.xdata$x:0000992C                                         ; DATA XREF: .xdata$x:0000993Co
.xdata$x:0000992D                 db 0FFh
.xdata$x:0000992E                 db 0FFh
.xdata$x:0000992F                 db 0FFh
.xdata$x:00009930                 dd offset __unwindfunclet$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0
.xdata$x:00009934 __ehfuncinfo$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00009934                                         ; DATA XREF: __ehhandler$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ+11o
.xdata$x:00009935                 db    5
.xdata$x:00009936                 db  93h ; ô
.xdata$x:00009937                 db  19h
.xdata$x:00009938                 db    1
.xdata$x:00009939                 db    0
.xdata$x:0000993A                 db    0
.xdata$x:0000993B                 db    0
.xdata$x:0000993C                 dd offset __unwindtable$?end@?$vector@EV?$allocator@E@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.xdata$x:00009940                 db    0
.xdata$x:00009941                 db    0
.xdata$x:00009942                 db    0
.xdata$x:00009943                 db    0
.xdata$x:00009944                 db    0
.xdata$x:00009945                 db    0
.xdata$x:00009946                 db    0
.xdata$x:00009947                 db    0
.xdata$x:00009948                 db    0
.xdata$x:00009949                 db    0
.xdata$x:0000994A                 db    0
.xdata$x:0000994B                 db    0
.xdata$x:0000994C                 db    0
.xdata$x:0000994D                 db    0
.xdata$x:0000994E                 db    0
.xdata$x:0000994F                 db    0
.xdata$x:00009950                 db    0
.xdata$x:00009951                 db    0
.xdata$x:00009952                 db    0
.xdata$x:00009953                 db    0
.xdata$x:00009954                 db    0
.xdata$x:00009955                 db    0
.xdata$x:00009956                 db    0
.xdata$x:00009957                 db    0
.xdata$x:00009957 _xdata$x        ends
.xdata$x:00009957
.xdata$x:00009958 ; ===========================================================================
.xdata$x:00009958
.xdata$x:00009958 ; Segment type: Pure data
.xdata$x:00009958 ; Segment permissions: Read
.xdata$x:00009958 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009958                 assume cs:_xdata$x
.xdata$x:00009958                 ;org 9958h
.xdata$x:00009958 ; COMDAT (pick associative to section at 768C)
.xdata$x:00009958 __catchsym$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z$2 db    0
.xdata$x:00009958                                         ; DATA XREF: .xdata$x:00009988o
.xdata$x:00009959                 db    0
.xdata$x:0000995A                 db    0
.xdata$x:0000995B                 db    0
.xdata$x:0000995C                 db    0
.xdata$x:0000995D                 db    0
.xdata$x:0000995E                 db    0
.xdata$x:0000995F                 db    0
.xdata$x:00009960                 db    0
.xdata$x:00009961                 db    0
.xdata$x:00009962                 db    0
.xdata$x:00009963                 db    0
.xdata$x:00009964                 dd offset __catch$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z$0
.xdata$x:00009968 __unwindtable$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z db 0FFh
.xdata$x:00009968                                         ; DATA XREF: .xdata$x:00009994o
.xdata$x:00009969                 db 0FFh
.xdata$x:0000996A                 db 0FFh
.xdata$x:0000996B                 db 0FFh
.xdata$x:0000996C                 db    0
.xdata$x:0000996D                 db    0
.xdata$x:0000996E                 db    0
.xdata$x:0000996F                 db    0
.xdata$x:00009970                 db 0FFh
.xdata$x:00009971                 db 0FFh
.xdata$x:00009972                 db 0FFh
.xdata$x:00009973                 db 0FFh
.xdata$x:00009974                 db    0
.xdata$x:00009975                 db    0
.xdata$x:00009976                 db    0
.xdata$x:00009977                 db    0
.xdata$x:00009978 __tryblocktable$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z db    0
.xdata$x:00009978                                         ; DATA XREF: .xdata$x:0000999Co
.xdata$x:00009979                 db    0
.xdata$x:0000997A                 db    0
.xdata$x:0000997B                 db    0
.xdata$x:0000997C                 db    0
.xdata$x:0000997D                 db    0
.xdata$x:0000997E                 db    0
.xdata$x:0000997F                 db    0
.xdata$x:00009980                 db    1
.xdata$x:00009981                 db    0
.xdata$x:00009982                 db    0
.xdata$x:00009983                 db    0
.xdata$x:00009984                 db    1
.xdata$x:00009985                 db    0
.xdata$x:00009986                 db    0
.xdata$x:00009987                 db    0
.xdata$x:00009988                 dd offset __catchsym$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z$2
.xdata$x:0000998C __ehfuncinfo$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z db  22h ; "
.xdata$x:0000998C                                         ; DATA XREF: __ehhandler$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z+11o
.xdata$x:0000998D                 db    5
.xdata$x:0000998E                 db  93h ; ô
.xdata$x:0000998F                 db  19h
.xdata$x:00009990                 db    2
.xdata$x:00009991                 db    0
.xdata$x:00009992                 db    0
.xdata$x:00009993                 db    0
.xdata$x:00009994                 dd offset __unwindtable$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.xdata$x:00009998                 db    1
.xdata$x:00009999                 db    0
.xdata$x:0000999A                 db    0
.xdata$x:0000999B                 db    0
.xdata$x:0000999C                 dd offset __tryblocktable$?_Reallocate@?$vector@EV?$allocator@E@std@@@std@@IAEXI@Z
.xdata$x:000099A0                 db    0
.xdata$x:000099A1                 db    0
.xdata$x:000099A2                 db    0
.xdata$x:000099A3                 db    0
.xdata$x:000099A4                 db    0
.xdata$x:000099A5                 db    0
.xdata$x:000099A6                 db    0
.xdata$x:000099A7                 db    0
.xdata$x:000099A8                 db    0
.xdata$x:000099A9                 db    0
.xdata$x:000099AA                 db    0
.xdata$x:000099AB                 db    0
.xdata$x:000099AC                 db    0
.xdata$x:000099AD                 db    0
.xdata$x:000099AE                 db    0
.xdata$x:000099AF                 db    0
.xdata$x:000099AF _xdata$x        ends
.xdata$x:000099AF
.xdata$x:000099B0 ; ===========================================================================
.xdata$x:000099B0
.xdata$x:000099B0 ; Segment type: Pure data
.xdata$x:000099B0 ; Segment permissions: Read
.xdata$x:000099B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099B0                 assume cs:_xdata$x
.xdata$x:000099B0                 ;org 99B0h
.xdata$x:000099B0 ; COMDAT (pick associative to section at 74D4)
.xdata$x:000099B0 __unwindtable$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z db 0FFh
.xdata$x:000099B0                                         ; DATA XREF: .xdata$x:000099C0o
.xdata$x:000099B1                 db 0FFh
.xdata$x:000099B2                 db 0FFh
.xdata$x:000099B3                 db 0FFh
.xdata$x:000099B4                 dd offset __unwindfunclet$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z$0
.xdata$x:000099B8 __ehfuncinfo$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z db  22h ; "
.xdata$x:000099B8                                         ; DATA XREF: __ehhandler$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z+11o
.xdata$x:000099B9                 db    5
.xdata$x:000099BA                 db  93h ; ô
.xdata$x:000099BB                 db  19h
.xdata$x:000099BC                 db    1
.xdata$x:000099BD                 db    0
.xdata$x:000099BE                 db    0
.xdata$x:000099BF                 db    0
.xdata$x:000099C0                 dd offset __unwindtable$?_Orphan_range@?$vector@EV?$allocator@E@std@@@std@@IBEXPAE0@Z
.xdata$x:000099C4                 db    0
.xdata$x:000099C5                 db    0
.xdata$x:000099C6                 db    0
.xdata$x:000099C7                 db    0
.xdata$x:000099C8                 db    0
.xdata$x:000099C9                 db    0
.xdata$x:000099CA                 db    0
.xdata$x:000099CB                 db    0
.xdata$x:000099CC                 db    0
.xdata$x:000099CD                 db    0
.xdata$x:000099CE                 db    0
.xdata$x:000099CF                 db    0
.xdata$x:000099D0                 db    0
.xdata$x:000099D1                 db    0
.xdata$x:000099D2                 db    0
.xdata$x:000099D3                 db    0
.xdata$x:000099D4                 db    0
.xdata$x:000099D5                 db    0
.xdata$x:000099D6                 db    0
.xdata$x:000099D7                 db    0
.xdata$x:000099D8                 db    0
.xdata$x:000099D9                 db    0
.xdata$x:000099DA                 db    0
.xdata$x:000099DB                 db    0
.xdata$x:000099DB _xdata$x        ends
.xdata$x:000099DB
.xdata$x:000099DC ; ===========================================================================
.xdata$x:000099DC
.xdata$x:000099DC ; Segment type: Pure data
.xdata$x:000099DC ; Segment permissions: Read
.xdata$x:000099DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000099DC                 assume cs:_xdata$x
.xdata$x:000099DC                 ;org 99DCh
.xdata$x:000099DC ; COMDAT (pick associative to section at 4220)
.xdata$x:000099DC __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:000099DC                                         ; DATA XREF: .xdata$x:000099ECo
.xdata$x:000099DD                 db 0FFh
.xdata$x:000099DE                 db 0FFh
.xdata$x:000099DF                 db 0FFh
.xdata$x:000099E0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:000099E4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000099E4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:000099E5                 db    5
.xdata$x:000099E6                 db  93h ; ô
.xdata$x:000099E7                 db  19h
.xdata$x:000099E8                 db    1
.xdata$x:000099E9                 db    0
.xdata$x:000099EA                 db    0
.xdata$x:000099EB                 db    0
.xdata$x:000099EC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:000099F0                 db    0
.xdata$x:000099F1                 db    0
.xdata$x:000099F2                 db    0
.xdata$x:000099F3                 db    0
.xdata$x:000099F4                 db    0
.xdata$x:000099F5                 db    0
.xdata$x:000099F6                 db    0
.xdata$x:000099F7                 db    0
.xdata$x:000099F8                 db    0
.xdata$x:000099F9                 db    0
.xdata$x:000099FA                 db    0
.xdata$x:000099FB                 db    0
.xdata$x:000099FC                 db    0
.xdata$x:000099FD                 db    0
.xdata$x:000099FE                 db    0
.xdata$x:000099FF                 db    0
.xdata$x:00009A00                 db    0
.xdata$x:00009A01                 db    0
.xdata$x:00009A02                 db    0
.xdata$x:00009A03                 db    0
.xdata$x:00009A04                 db    0
.xdata$x:00009A05                 db    0
.xdata$x:00009A06                 db    0
.xdata$x:00009A07                 db    0
.xdata$x:00009A07 _xdata$x        ends
.xdata$x:00009A07
.xdata$x:00009A08 ; ===========================================================================
.xdata$x:00009A08
.xdata$x:00009A08 ; Segment type: Pure data
.xdata$x:00009A08 ; Segment permissions: Read
.xdata$x:00009A08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A08                 assume cs:_xdata$x
.xdata$x:00009A08                 ;org 9A08h
.xdata$x:00009A08 ; COMDAT (pick associative to section at 5080)
.xdata$x:00009A08 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009A08                                         ; DATA XREF: .xdata$x:00009A18o
.xdata$x:00009A09                 db 0FFh
.xdata$x:00009A0A                 db 0FFh
.xdata$x:00009A0B                 db 0FFh
.xdata$x:00009A0C                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009A10 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009A10                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009A11                 db    5
.xdata$x:00009A12                 db  93h ; ô
.xdata$x:00009A13                 db  19h
.xdata$x:00009A14                 db    1
.xdata$x:00009A15                 db    0
.xdata$x:00009A16                 db    0
.xdata$x:00009A17                 db    0
.xdata$x:00009A18                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009A1C                 db    0
.xdata$x:00009A1D                 db    0
.xdata$x:00009A1E                 db    0
.xdata$x:00009A1F                 db    0
.xdata$x:00009A20                 db    0
.xdata$x:00009A21                 db    0
.xdata$x:00009A22                 db    0
.xdata$x:00009A23                 db    0
.xdata$x:00009A24                 db    0
.xdata$x:00009A25                 db    0
.xdata$x:00009A26                 db    0
.xdata$x:00009A27                 db    0
.xdata$x:00009A28                 db    0
.xdata$x:00009A29                 db    0
.xdata$x:00009A2A                 db    0
.xdata$x:00009A2B                 db    0
.xdata$x:00009A2C                 db    0
.xdata$x:00009A2D                 db    0
.xdata$x:00009A2E                 db    0
.xdata$x:00009A2F                 db    0
.xdata$x:00009A30                 db    0
.xdata$x:00009A31                 db    0
.xdata$x:00009A32                 db    0
.xdata$x:00009A33                 db    0
.xdata$x:00009A33 _xdata$x        ends
.xdata$x:00009A33
.xdata$x:00009A34 ; ===========================================================================
.xdata$x:00009A34
.xdata$x:00009A34 ; Segment type: Pure data
.xdata$x:00009A34 ; Segment permissions: Read
.xdata$x:00009A34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A34                 assume cs:_xdata$x
.xdata$x:00009A34                 ;org 9A34h
.xdata$x:00009A34 ; COMDAT (pick associative to section at 41A8)
.xdata$x:00009A34 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00009A34                                         ; DATA XREF: .xdata$x:00009A44o
.xdata$x:00009A35                 db 0FFh
.xdata$x:00009A36                 db 0FFh
.xdata$x:00009A37                 db 0FFh
.xdata$x:00009A38                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00009A3C __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00009A3C                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00009A3D                 db    5
.xdata$x:00009A3E                 db  93h ; ô
.xdata$x:00009A3F                 db  19h
.xdata$x:00009A40                 db    1
.xdata$x:00009A41                 db    0
.xdata$x:00009A42                 db    0
.xdata$x:00009A43                 db    0
.xdata$x:00009A44                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@V?$vector@EV?$allocator@E@std@@@2@HPBV32@ABV32@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00009A48                 align 20h
.xdata$x:00009A48 _xdata$x        ends
.xdata$x:00009A48
.xdata$x:00009A60 ; ===========================================================================
.xdata$x:00009A60
.xdata$x:00009A60 ; Segment type: Pure data
.xdata$x:00009A60 ; Segment permissions: Read
.xdata$x:00009A60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A60                 assume cs:_xdata$x
.xdata$x:00009A60                 ;org 9A60h
.xdata$x:00009A60 ; COMDAT (pick associative to section at 45A8)
.xdata$x:00009A60 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009A60                                         ; DATA XREF: .xdata$x:00009A70o
.xdata$x:00009A61                 db 0FFh
.xdata$x:00009A62                 db 0FFh
.xdata$x:00009A63                 db 0FFh
.xdata$x:00009A64                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z$0
.xdata$x:00009A68 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00009A68                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z+11o
.xdata$x:00009A69                 db    5
.xdata$x:00009A6A                 db  93h ; ô
.xdata$x:00009A6B                 db  19h
.xdata$x:00009A6C                 db    1
.xdata$x:00009A6D                 db    0
.xdata$x:00009A6E                 db    0
.xdata$x:00009A6F                 db    0
.xdata$x:00009A70                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.xdata$x:00009A74                 db    0
.xdata$x:00009A75                 db    0
.xdata$x:00009A76                 db    0
.xdata$x:00009A77                 db    0
.xdata$x:00009A78                 db    0
.xdata$x:00009A79                 db    0
.xdata$x:00009A7A                 db    0
.xdata$x:00009A7B                 db    0
.xdata$x:00009A7C                 db    0
.xdata$x:00009A7D                 db    0
.xdata$x:00009A7E                 db    0
.xdata$x:00009A7F                 db    0
.xdata$x:00009A80                 db    0
.xdata$x:00009A81                 db    0
.xdata$x:00009A82                 db    0
.xdata$x:00009A83                 db    0
.xdata$x:00009A84                 db    0
.xdata$x:00009A85                 db    0
.xdata$x:00009A86                 db    0
.xdata$x:00009A87                 db    0
.xdata$x:00009A88                 db    0
.xdata$x:00009A89                 db    0
.xdata$x:00009A8A                 db    0
.xdata$x:00009A8B                 db    0
.xdata$x:00009A8B _xdata$x        ends
.xdata$x:00009A8B
.xdata$x:00009A8C ; ===========================================================================
.xdata$x:00009A8C
.xdata$x:00009A8C ; Segment type: Pure data
.xdata$x:00009A8C ; Segment permissions: Read
.xdata$x:00009A8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009A8C                 assume cs:_xdata$x
.xdata$x:00009A8C                 ;org 9A8Ch
.xdata$x:00009A8C ; COMDAT (pick associative to section at 52C0)
.xdata$x:00009A8C __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009A8C                                         ; DATA XREF: .xdata$x:00009A9Co
.xdata$x:00009A8D                 db 0FFh
.xdata$x:00009A8E                 db 0FFh
.xdata$x:00009A8F                 db 0FFh
.xdata$x:00009A90                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009A94 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009A94                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009A95                 db    5
.xdata$x:00009A96                 db  93h ; ô
.xdata$x:00009A97                 db  19h
.xdata$x:00009A98                 db    1
.xdata$x:00009A99                 db    0
.xdata$x:00009A9A                 db    0
.xdata$x:00009A9B                 db    0
.xdata$x:00009A9C                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009AA0                 db    0
.xdata$x:00009AA1                 db    0
.xdata$x:00009AA2                 db    0
.xdata$x:00009AA3                 db    0
.xdata$x:00009AA4                 db    0
.xdata$x:00009AA5                 db    0
.xdata$x:00009AA6                 db    0
.xdata$x:00009AA7                 db    0
.xdata$x:00009AA8                 db    0
.xdata$x:00009AA9                 db    0
.xdata$x:00009AAA                 db    0
.xdata$x:00009AAB                 db    0
.xdata$x:00009AAC                 db    0
.xdata$x:00009AAD                 db    0
.xdata$x:00009AAE                 db    0
.xdata$x:00009AAF                 db    0
.xdata$x:00009AB0                 db    0
.xdata$x:00009AB1                 db    0
.xdata$x:00009AB2                 db    0
.xdata$x:00009AB3                 db    0
.xdata$x:00009AB4                 db    0
.xdata$x:00009AB5                 db    0
.xdata$x:00009AB6                 db    0
.xdata$x:00009AB7                 db    0
.xdata$x:00009AB7 _xdata$x        ends
.xdata$x:00009AB7
.xdata$x:00009AB8 ; ===========================================================================
.xdata$x:00009AB8
.xdata$x:00009AB8 ; Segment type: Pure data
.xdata$x:00009AB8 ; Segment permissions: Read
.xdata$x:00009AB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009AB8                 assume cs:_xdata$x
.xdata$x:00009AB8                 ;org 9AB8h
.xdata$x:00009AB8 ; COMDAT (pick associative to section at 4524)
.xdata$x:00009AB8 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009AB8                                         ; DATA XREF: .xdata$x:00009AC8o
.xdata$x:00009AB9                 db 0FFh
.xdata$x:00009ABA                 db 0FFh
.xdata$x:00009ABB                 db 0FFh
.xdata$x:00009ABC                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009AC0 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009AC0                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009AC1                 db    5
.xdata$x:00009AC2                 db  93h ; ô
.xdata$x:00009AC3                 db  19h
.xdata$x:00009AC4                 db    1
.xdata$x:00009AC5                 db    0
.xdata$x:00009AC6                 db    0
.xdata$x:00009AC7                 db    0
.xdata$x:00009AC8                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009ACC                 db    0
.xdata$x:00009ACD                 db    0
.xdata$x:00009ACE                 db    0
.xdata$x:00009ACF                 db    0
.xdata$x:00009AD0                 db    0
.xdata$x:00009AD1                 db    0
.xdata$x:00009AD2                 db    0
.xdata$x:00009AD3                 db    0
.xdata$x:00009AD4                 db    0
.xdata$x:00009AD5                 db    0
.xdata$x:00009AD6                 db    0
.xdata$x:00009AD7                 db    0
.xdata$x:00009AD8                 db    0
.xdata$x:00009AD9                 db    0
.xdata$x:00009ADA                 db    0
.xdata$x:00009ADB                 db    0
.xdata$x:00009ADC                 db    0
.xdata$x:00009ADD                 db    0
.xdata$x:00009ADE                 db    0
.xdata$x:00009ADF                 db    0
.xdata$x:00009AE0                 db    0
.xdata$x:00009AE1                 db    0
.xdata$x:00009AE2                 db    0
.xdata$x:00009AE3                 db    0
.xdata$x:00009AE3 _xdata$x        ends
.xdata$x:00009AE3
.xdata$x:00009AE4 ; ===========================================================================
.xdata$x:00009AE4
.xdata$x:00009AE4 ; Segment type: Pure data
.xdata$x:00009AE4 ; Segment permissions: Read
.xdata$x:00009AE4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009AE4                 assume cs:_xdata$x
.xdata$x:00009AE4                 ;org 9AE4h
.xdata$x:00009AE4 ; COMDAT (pick associative to section at 47A0)
.xdata$x:00009AE4 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009AE4                                         ; DATA XREF: .xdata$x:00009AF4o
.xdata$x:00009AE5                 db 0FFh
.xdata$x:00009AE6                 db 0FFh
.xdata$x:00009AE7                 db 0FFh
.xdata$x:00009AE8                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z$0
.xdata$x:00009AEC __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00009AEC                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z+11o
.xdata$x:00009AED                 db    5
.xdata$x:00009AEE                 db  93h ; ô
.xdata$x:00009AEF                 db  19h
.xdata$x:00009AF0                 db    1
.xdata$x:00009AF1                 db    0
.xdata$x:00009AF2                 db    0
.xdata$x:00009AF3                 db    0
.xdata$x:00009AF4                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@PAV?$vector@EV?$allocator@E@std@@@1@PBU_Container_base12@1@@Z
.xdata$x:00009AF8                 db    0
.xdata$x:00009AF9                 db    0
.xdata$x:00009AFA                 db    0
.xdata$x:00009AFB                 db    0
.xdata$x:00009AFC                 db    0
.xdata$x:00009AFD                 db    0
.xdata$x:00009AFE                 db    0
.xdata$x:00009AFF                 db    0
.xdata$x:00009B00                 db    0
.xdata$x:00009B01                 db    0
.xdata$x:00009B02                 db    0
.xdata$x:00009B03                 db    0
.xdata$x:00009B04                 db    0
.xdata$x:00009B05                 db    0
.xdata$x:00009B06                 db    0
.xdata$x:00009B07                 db    0
.xdata$x:00009B08                 db    0
.xdata$x:00009B09                 db    0
.xdata$x:00009B0A                 db    0
.xdata$x:00009B0B                 db    0
.xdata$x:00009B0C                 db    0
.xdata$x:00009B0D                 db    0
.xdata$x:00009B0E                 db    0
.xdata$x:00009B0F                 db    0
.xdata$x:00009B0F _xdata$x        ends
.xdata$x:00009B0F
.xdata$x:00009B10 ; ===========================================================================
.xdata$x:00009B10
.xdata$x:00009B10 ; Segment type: Pure data
.xdata$x:00009B10 ; Segment permissions: Read
.xdata$x:00009B10 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B10                 assume cs:_xdata$x
.xdata$x:00009B10                 ;org 9B10h
.xdata$x:00009B10 ; COMDAT (pick associative to section at 5FC8)
.xdata$x:00009B10 __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z db 0FFh
.xdata$x:00009B10                                         ; DATA XREF: .xdata$x:00009B28o
.xdata$x:00009B11                 db 0FFh
.xdata$x:00009B12                 db 0FFh
.xdata$x:00009B13                 db 0FFh
.xdata$x:00009B14                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$1
.xdata$x:00009B18                 db    0
.xdata$x:00009B19                 db    0
.xdata$x:00009B1A                 db    0
.xdata$x:00009B1B                 db    0
.xdata$x:00009B1C                 dd offset __unwindfunclet$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z$0
.xdata$x:00009B20 __ehfuncinfo$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z db  22h ; "
.xdata$x:00009B20                                         ; DATA XREF: __ehhandler$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z+11o
.xdata$x:00009B21                 db    5
.xdata$x:00009B22                 db  93h ; ô
.xdata$x:00009B23                 db  19h
.xdata$x:00009B24                 db    2
.xdata$x:00009B25                 db    0
.xdata$x:00009B26                 db    0
.xdata$x:00009B27                 db    0
.xdata$x:00009B28                 dd offset __unwindtable$??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QBE?AV01@H@Z
.xdata$x:00009B2C                 db    0
.xdata$x:00009B2D                 db    0
.xdata$x:00009B2E                 db    0
.xdata$x:00009B2F                 db    0
.xdata$x:00009B30                 db    0
.xdata$x:00009B31                 db    0
.xdata$x:00009B32                 db    0
.xdata$x:00009B33                 db    0
.xdata$x:00009B34                 db    0
.xdata$x:00009B35                 db    0
.xdata$x:00009B36                 db    0
.xdata$x:00009B37                 db    0
.xdata$x:00009B38                 db    0
.xdata$x:00009B39                 db    0
.xdata$x:00009B3A                 db    0
.xdata$x:00009B3B                 db    0
.xdata$x:00009B3C                 db    0
.xdata$x:00009B3D                 db    0
.xdata$x:00009B3E                 db    0
.xdata$x:00009B3F                 db    0
.xdata$x:00009B40                 db    0
.xdata$x:00009B41                 db    0
.xdata$x:00009B42                 db    0
.xdata$x:00009B43                 db    0
.xdata$x:00009B43 _xdata$x        ends
.xdata$x:00009B43
.xdata$x:00009B44 ; ===========================================================================
.xdata$x:00009B44
.xdata$x:00009B44 ; Segment type: Pure data
.xdata$x:00009B44 ; Segment permissions: Read
.xdata$x:00009B44 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B44                 assume cs:_xdata$x
.xdata$x:00009B44                 ;org 9B44h
.xdata$x:00009B44 ; COMDAT (pick associative to section at 53A0)
.xdata$x:00009B44 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009B44                                         ; DATA XREF: .xdata$x:00009B54o
.xdata$x:00009B45                 db 0FFh
.xdata$x:00009B46                 db 0FFh
.xdata$x:00009B47                 db 0FFh
.xdata$x:00009B48                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009B4C __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009B4C                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009B4D                 db    5
.xdata$x:00009B4E                 db  93h ; ô
.xdata$x:00009B4F                 db  19h
.xdata$x:00009B50                 db    1
.xdata$x:00009B51                 db    0
.xdata$x:00009B52                 db    0
.xdata$x:00009B53                 db    0
.xdata$x:00009B54                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009B58                 db    0
.xdata$x:00009B59                 db    0
.xdata$x:00009B5A                 db    0
.xdata$x:00009B5B                 db    0
.xdata$x:00009B5C                 db    0
.xdata$x:00009B5D                 db    0
.xdata$x:00009B5E                 db    0
.xdata$x:00009B5F                 db    0
.xdata$x:00009B60                 db    0
.xdata$x:00009B61                 db    0
.xdata$x:00009B62                 db    0
.xdata$x:00009B63                 db    0
.xdata$x:00009B64                 db    0
.xdata$x:00009B65                 db    0
.xdata$x:00009B66                 db    0
.xdata$x:00009B67                 db    0
.xdata$x:00009B68                 db    0
.xdata$x:00009B69                 db    0
.xdata$x:00009B6A                 db    0
.xdata$x:00009B6B                 db    0
.xdata$x:00009B6C                 db    0
.xdata$x:00009B6D                 db    0
.xdata$x:00009B6E                 db    0
.xdata$x:00009B6F                 db    0
.xdata$x:00009B6F _xdata$x        ends
.xdata$x:00009B6F
.xdata$x:00009B70 ; ===========================================================================
.xdata$x:00009B70
.xdata$x:00009B70 ; Segment type: Pure data
.xdata$x:00009B70 ; Segment permissions: Read
.xdata$x:00009B70 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B70                 assume cs:_xdata$x
.xdata$x:00009B70                 ;org 9B70h
.xdata$x:00009B70 ; COMDAT (pick associative to section at 4728)
.xdata$x:00009B70 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009B70                                         ; DATA XREF: .xdata$x:00009B80o
.xdata$x:00009B71                 db 0FFh
.xdata$x:00009B72                 db 0FFh
.xdata$x:00009B73                 db 0FFh
.xdata$x:00009B74                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009B78 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009B78                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009B79                 db    5
.xdata$x:00009B7A                 db  93h ; ô
.xdata$x:00009B7B                 db  19h
.xdata$x:00009B7C                 db    1
.xdata$x:00009B7D                 db    0
.xdata$x:00009B7E                 db    0
.xdata$x:00009B7F                 db    0
.xdata$x:00009B80                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$vector@EV?$allocator@E@std@@@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009B84                 db    0
.xdata$x:00009B85                 db    0
.xdata$x:00009B86                 db    0
.xdata$x:00009B87                 db    0
.xdata$x:00009B88                 db    0
.xdata$x:00009B89                 db    0
.xdata$x:00009B8A                 db    0
.xdata$x:00009B8B                 db    0
.xdata$x:00009B8C                 db    0
.xdata$x:00009B8D                 db    0
.xdata$x:00009B8E                 db    0
.xdata$x:00009B8F                 db    0
.xdata$x:00009B90                 db    0
.xdata$x:00009B91                 db    0
.xdata$x:00009B92                 db    0
.xdata$x:00009B93                 db    0
.xdata$x:00009B94                 db    0
.xdata$x:00009B95                 db    0
.xdata$x:00009B96                 db    0
.xdata$x:00009B97                 db    0
.xdata$x:00009B98                 db    0
.xdata$x:00009B99                 db    0
.xdata$x:00009B9A                 db    0
.xdata$x:00009B9B                 db    0
.xdata$x:00009B9B _xdata$x        ends
.xdata$x:00009B9B
.xdata$x:00009B9C ; ===========================================================================
.xdata$x:00009B9C
.xdata$x:00009B9C ; Segment type: Pure data
.xdata$x:00009B9C ; Segment permissions: Read
.xdata$x:00009B9C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009B9C                 assume cs:_xdata$x
.xdata$x:00009B9C                 ;org 9B9Ch
.xdata$x:00009B9C ; COMDAT (pick associative to section at 4134)
.xdata$x:00009B9C __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009B9C                                         ; DATA XREF: .xdata$x:00009BACo
.xdata$x:00009B9D                 db 0FFh
.xdata$x:00009B9E                 db 0FFh
.xdata$x:00009B9F                 db 0FFh
.xdata$x:00009BA0                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009BA4 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009BA4                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009BA5                 db    5
.xdata$x:00009BA6                 db  93h ; ô
.xdata$x:00009BA7                 db  19h
.xdata$x:00009BA8                 db    1
.xdata$x:00009BA9                 db    0
.xdata$x:00009BAA                 db    0
.xdata$x:00009BAB                 db    0
.xdata$x:00009BAC                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009BB0                 db    0
.xdata$x:00009BB1                 db    0
.xdata$x:00009BB2                 db    0
.xdata$x:00009BB3                 db    0
.xdata$x:00009BB4                 db    0
.xdata$x:00009BB5                 db    0
.xdata$x:00009BB6                 db    0
.xdata$x:00009BB7                 db    0
.xdata$x:00009BB8                 db    0
.xdata$x:00009BB9                 db    0
.xdata$x:00009BBA                 db    0
.xdata$x:00009BBB                 db    0
.xdata$x:00009BBC                 db    0
.xdata$x:00009BBD                 db    0
.xdata$x:00009BBE                 db    0
.xdata$x:00009BBF                 db    0
.xdata$x:00009BC0                 db    0
.xdata$x:00009BC1                 db    0
.xdata$x:00009BC2                 db    0
.xdata$x:00009BC3                 db    0
.xdata$x:00009BC4                 db    0
.xdata$x:00009BC5                 db    0
.xdata$x:00009BC6                 db    0
.xdata$x:00009BC7                 db    0
.xdata$x:00009BC7 _xdata$x        ends
.xdata$x:00009BC7
.xdata$x:00009BC8 ; ===========================================================================
.xdata$x:00009BC8
.xdata$x:00009BC8 ; Segment type: Pure data
.xdata$x:00009BC8 ; Segment permissions: Read
.xdata$x:00009BC8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009BC8                 assume cs:_xdata$x
.xdata$x:00009BC8                 ;org 9BC8h
.xdata$x:00009BC8 ; COMDAT (pick associative to section at 5010)
.xdata$x:00009BC8 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:00009BC8                                         ; DATA XREF: .xdata$x:00009BD8o
.xdata$x:00009BC9                 db 0FFh
.xdata$x:00009BCA                 db 0FFh
.xdata$x:00009BCB                 db 0FFh
.xdata$x:00009BCC                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00009BD0 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00009BD0                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00009BD1                 db    5
.xdata$x:00009BD2                 db  93h ; ô
.xdata$x:00009BD3                 db  19h
.xdata$x:00009BD4                 db    1
.xdata$x:00009BD5                 db    0
.xdata$x:00009BD6                 db    0
.xdata$x:00009BD7                 db    0
.xdata$x:00009BD8                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00009BDC                 db    0
.xdata$x:00009BDD                 db    0
.xdata$x:00009BDE                 db    0
.xdata$x:00009BDF                 db    0
.xdata$x:00009BE0                 db    0
.xdata$x:00009BE1                 db    0
.xdata$x:00009BE2                 db    0
.xdata$x:00009BE3                 db    0
.xdata$x:00009BE4                 db    0
.xdata$x:00009BE5                 db    0
.xdata$x:00009BE6                 db    0
.xdata$x:00009BE7                 db    0
.xdata$x:00009BE8                 db    0
.xdata$x:00009BE9                 db    0
.xdata$x:00009BEA                 db    0
.xdata$x:00009BEB                 db    0
.xdata$x:00009BEC                 db    0
.xdata$x:00009BED                 db    0
.xdata$x:00009BEE                 db    0
.xdata$x:00009BEF                 db    0
.xdata$x:00009BF0                 db    0
.xdata$x:00009BF1                 db    0
.xdata$x:00009BF2                 db    0
.xdata$x:00009BF3                 db    0
.xdata$x:00009BF3 _xdata$x        ends
.xdata$x:00009BF3
.xdata$x:00009BF4 ; ===========================================================================
.xdata$x:00009BF4
.xdata$x:00009BF4 ; Segment type: Pure data
.xdata$x:00009BF4 ; Segment permissions: Read
.xdata$x:00009BF4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009BF4                 assume cs:_xdata$x
.xdata$x:00009BF4                 ;org 9BF4h
.xdata$x:00009BF4 ; COMDAT (pick associative to section at 40BC)
.xdata$x:00009BF4 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:00009BF4                                         ; DATA XREF: .xdata$x:00009C04o
.xdata$x:00009BF5                 db 0FFh
.xdata$x:00009BF6                 db 0FFh
.xdata$x:00009BF7                 db 0FFh
.xdata$x:00009BF8                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:00009BFC __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:00009BFC                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:00009BFD                 db    5
.xdata$x:00009BFE                 db  93h ; ô
.xdata$x:00009BFF                 db  19h
.xdata$x:00009C00                 db    1
.xdata$x:00009C01                 db    0
.xdata$x:00009C02                 db    0
.xdata$x:00009C03                 db    0
.xdata$x:00009C04                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@EHPBEABEU_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:00009C08                 align 20h
.xdata$x:00009C08 _xdata$x        ends
.xdata$x:00009C08
.xdata$x:00009C20 ; ===========================================================================
.xdata$x:00009C20
.xdata$x:00009C20 ; Segment type: Pure data
.xdata$x:00009C20 ; Segment permissions: Read
.xdata$x:00009C20 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C20                 assume cs:_xdata$x
.xdata$x:00009C20                 ;org 9C20h
.xdata$x:00009C20 ; COMDAT (pick associative to section at 4498)
.xdata$x:00009C20 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009C20                                         ; DATA XREF: .xdata$x:00009C30o
.xdata$x:00009C21                 db 0FFh
.xdata$x:00009C22                 db 0FFh
.xdata$x:00009C23                 db 0FFh
.xdata$x:00009C24                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z$0
.xdata$x:00009C28 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00009C28                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z+11o
.xdata$x:00009C29                 db    5
.xdata$x:00009C2A                 db  93h ; ô
.xdata$x:00009C2B                 db  19h
.xdata$x:00009C2C                 db    1
.xdata$x:00009C2D                 db    0
.xdata$x:00009C2E                 db    0
.xdata$x:00009C2F                 db    0
.xdata$x:00009C30                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.xdata$x:00009C34                 db    0
.xdata$x:00009C35                 db    0
.xdata$x:00009C36                 db    0
.xdata$x:00009C37                 db    0
.xdata$x:00009C38                 db    0
.xdata$x:00009C39                 db    0
.xdata$x:00009C3A                 db    0
.xdata$x:00009C3B                 db    0
.xdata$x:00009C3C                 db    0
.xdata$x:00009C3D                 db    0
.xdata$x:00009C3E                 db    0
.xdata$x:00009C3F                 db    0
.xdata$x:00009C40                 db    0
.xdata$x:00009C41                 db    0
.xdata$x:00009C42                 db    0
.xdata$x:00009C43                 db    0
.xdata$x:00009C44                 db    0
.xdata$x:00009C45                 db    0
.xdata$x:00009C46                 db    0
.xdata$x:00009C47                 db    0
.xdata$x:00009C48                 db    0
.xdata$x:00009C49                 db    0
.xdata$x:00009C4A                 db    0
.xdata$x:00009C4B                 db    0
.xdata$x:00009C4B _xdata$x        ends
.xdata$x:00009C4B
.xdata$x:00009C4C ; ===========================================================================
.xdata$x:00009C4C
.xdata$x:00009C4C ; Segment type: Pure data
.xdata$x:00009C4C ; Segment permissions: Read
.xdata$x:00009C4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C4C                 assume cs:_xdata$x
.xdata$x:00009C4C                 ;org 9C4Ch
.xdata$x:00009C4C ; COMDAT (pick associative to section at 5250)
.xdata$x:00009C4C __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009C4C                                         ; DATA XREF: .xdata$x:00009C5Co
.xdata$x:00009C4D                 db 0FFh
.xdata$x:00009C4E                 db 0FFh
.xdata$x:00009C4F                 db 0FFh
.xdata$x:00009C50                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009C54 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009C54                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009C55                 db    5
.xdata$x:00009C56                 db  93h ; ô
.xdata$x:00009C57                 db  19h
.xdata$x:00009C58                 db    1
.xdata$x:00009C59                 db    0
.xdata$x:00009C5A                 db    0
.xdata$x:00009C5B                 db    0
.xdata$x:00009C5C                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.xdata$x:00009C60                 db    0
.xdata$x:00009C61                 db    0
.xdata$x:00009C62                 db    0
.xdata$x:00009C63                 db    0
.xdata$x:00009C64                 db    0
.xdata$x:00009C65                 db    0
.xdata$x:00009C66                 db    0
.xdata$x:00009C67                 db    0
.xdata$x:00009C68                 db    0
.xdata$x:00009C69                 db    0
.xdata$x:00009C6A                 db    0
.xdata$x:00009C6B                 db    0
.xdata$x:00009C6C                 db    0
.xdata$x:00009C6D                 db    0
.xdata$x:00009C6E                 db    0
.xdata$x:00009C6F                 db    0
.xdata$x:00009C70                 db    0
.xdata$x:00009C71                 db    0
.xdata$x:00009C72                 db    0
.xdata$x:00009C73                 db    0
.xdata$x:00009C74                 db    0
.xdata$x:00009C75                 db    0
.xdata$x:00009C76                 db    0
.xdata$x:00009C77                 db    0
.xdata$x:00009C77 _xdata$x        ends
.xdata$x:00009C77
.xdata$x:00009C78 ; ===========================================================================
.xdata$x:00009C78
.xdata$x:00009C78 ; Segment type: Pure data
.xdata$x:00009C78 ; Segment permissions: Read
.xdata$x:00009C78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009C78                 assume cs:_xdata$x
.xdata$x:00009C78                 ;org 9C78h
.xdata$x:00009C78 ; COMDAT (pick associative to section at 4414)
.xdata$x:00009C78 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009C78                                         ; DATA XREF: .xdata$x:00009C88o
.xdata$x:00009C79                 db 0FFh
.xdata$x:00009C7A                 db 0FFh
.xdata$x:00009C7B                 db 0FFh
.xdata$x:00009C7C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009C80 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009C80                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009C81                 db    5
.xdata$x:00009C82                 db  93h ; ô
.xdata$x:00009C83                 db  19h
.xdata$x:00009C84                 db    1
.xdata$x:00009C85                 db    0
.xdata$x:00009C86                 db    0
.xdata$x:00009C87                 db    0
.xdata$x:00009C88                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009C8C                 db    0
.xdata$x:00009C8D                 db    0
.xdata$x:00009C8E                 db    0
.xdata$x:00009C8F                 db    0
.xdata$x:00009C90                 db    0
.xdata$x:00009C91                 db    0
.xdata$x:00009C92                 db    0
.xdata$x:00009C93                 db    0
.xdata$x:00009C94                 db    0
.xdata$x:00009C95                 db    0
.xdata$x:00009C96                 db    0
.xdata$x:00009C97                 db    0
.xdata$x:00009C98                 db    0
.xdata$x:00009C99                 db    0
.xdata$x:00009C9A                 db    0
.xdata$x:00009C9B                 db    0
.xdata$x:00009C9C                 db    0
.xdata$x:00009C9D                 db    0
.xdata$x:00009C9E                 db    0
.xdata$x:00009C9F                 db    0
.xdata$x:00009CA0                 db    0
.xdata$x:00009CA1                 db    0
.xdata$x:00009CA2                 db    0
.xdata$x:00009CA3                 db    0
.xdata$x:00009CA3 _xdata$x        ends
.xdata$x:00009CA3
.xdata$x:00009CA4 ; ===========================================================================
.xdata$x:00009CA4
.xdata$x:00009CA4 ; Segment type: Pure data
.xdata$x:00009CA4 ; Segment permissions: Read
.xdata$x:00009CA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CA4                 assume cs:_xdata$x
.xdata$x:00009CA4                 ;org 9CA4h
.xdata$x:00009CA4 ; COMDAT (pick associative to section at 2AE8)
.xdata$x:00009CA4 __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z db 0FFh
.xdata$x:00009CA4                                         ; DATA XREF: .xdata$x:00009CCCo
.xdata$x:00009CA5                 db 0FFh
.xdata$x:00009CA6                 db 0FFh
.xdata$x:00009CA7                 db 0FFh
.xdata$x:00009CA8                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$0
.xdata$x:00009CAC                 align 10h
.xdata$x:00009CB0                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$1
.xdata$x:00009CB4                 db    1
.xdata$x:00009CB5                 db    0
.xdata$x:00009CB6                 db    0
.xdata$x:00009CB7                 db    0
.xdata$x:00009CB8                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$2
.xdata$x:00009CBC                 db    2
.xdata$x:00009CBD                 db    0
.xdata$x:00009CBE                 db    0
.xdata$x:00009CBF                 db    0
.xdata$x:00009CC0                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z$3
.xdata$x:00009CC4 __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z db  22h ; "
.xdata$x:00009CC4                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z+11o
.xdata$x:00009CC5                 db    5
.xdata$x:00009CC6                 db  93h ; ô
.xdata$x:00009CC7                 db  19h
.xdata$x:00009CC8                 db    4
.xdata$x:00009CC9                 db    0
.xdata$x:00009CCA                 db    0
.xdata$x:00009CCB                 db    0
.xdata$x:00009CCC                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@0PAE@Z
.xdata$x:00009CD0                 db    0
.xdata$x:00009CD1                 db    0
.xdata$x:00009CD2                 db    0
.xdata$x:00009CD3                 db    0
.xdata$x:00009CD4                 db    0
.xdata$x:00009CD5                 db    0
.xdata$x:00009CD6                 db    0
.xdata$x:00009CD7                 db    0
.xdata$x:00009CD8                 db    0
.xdata$x:00009CD9                 db    0
.xdata$x:00009CDA                 db    0
.xdata$x:00009CDB                 db    0
.xdata$x:00009CDC                 db    0
.xdata$x:00009CDD                 db    0
.xdata$x:00009CDE                 db    0
.xdata$x:00009CDF                 db    0
.xdata$x:00009CE0                 db    0
.xdata$x:00009CE1                 db    0
.xdata$x:00009CE2                 db    0
.xdata$x:00009CE3                 db    0
.xdata$x:00009CE4                 db    0
.xdata$x:00009CE5                 db    0
.xdata$x:00009CE6                 db    0
.xdata$x:00009CE7                 db    0
.xdata$x:00009CE7 _xdata$x        ends
.xdata$x:00009CE7
.xdata$x:00009CE8 ; ===========================================================================
.xdata$x:00009CE8
.xdata$x:00009CE8 ; Segment type: Pure data
.xdata$x:00009CE8 ; Segment permissions: Read
.xdata$x:00009CE8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009CE8                 assume cs:_xdata$x
.xdata$x:00009CE8                 ;org 9CE8h
.xdata$x:00009CE8 ; COMDAT (pick associative to section at 3B04)
.xdata$x:00009CE8 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00009CE8                                         ; DATA XREF: .xdata$x:00009CF8o
.xdata$x:00009CE9                 db 0FFh
.xdata$x:00009CEA                 db 0FFh
.xdata$x:00009CEB                 db 0FFh
.xdata$x:00009CEC                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00009CF0 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00009CF0                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00009CF1                 db    5
.xdata$x:00009CF2                 db  93h ; ô
.xdata$x:00009CF3                 db  19h
.xdata$x:00009CF4                 db    1
.xdata$x:00009CF5                 db    0
.xdata$x:00009CF6                 db    0
.xdata$x:00009CF7                 db    0
.xdata$x:00009CF8                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00009CFC                 db    0
.xdata$x:00009CFD                 db    0
.xdata$x:00009CFE                 db    0
.xdata$x:00009CFF                 db    0
.xdata$x:00009D00                 db    0
.xdata$x:00009D01                 db    0
.xdata$x:00009D02                 db    0
.xdata$x:00009D03                 db    0
.xdata$x:00009D04                 db    0
.xdata$x:00009D05                 db    0
.xdata$x:00009D06                 db    0
.xdata$x:00009D07                 db    0
.xdata$x:00009D08                 db    0
.xdata$x:00009D09                 db    0
.xdata$x:00009D0A                 db    0
.xdata$x:00009D0B                 db    0
.xdata$x:00009D0C                 db    0
.xdata$x:00009D0D                 db    0
.xdata$x:00009D0E                 db    0
.xdata$x:00009D0F                 db    0
.xdata$x:00009D10                 db    0
.xdata$x:00009D11                 db    0
.xdata$x:00009D12                 db    0
.xdata$x:00009D13                 db    0
.xdata$x:00009D13 _xdata$x        ends
.xdata$x:00009D13
.xdata$x:00009D14 ; ===========================================================================
.xdata$x:00009D14
.xdata$x:00009D14 ; Segment type: Pure data
.xdata$x:00009D14 ; Segment permissions: Read
.xdata$x:00009D14 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D14                 assume cs:_xdata$x
.xdata$x:00009D14                 ;org 9D14h
.xdata$x:00009D14 ; COMDAT (pick associative to section at 354C)
.xdata$x:00009D14 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z db 0FFh
.xdata$x:00009D14                                         ; DATA XREF: .xdata$x:00009D3Co
.xdata$x:00009D15                 db 0FFh
.xdata$x:00009D16                 db 0FFh
.xdata$x:00009D17                 db 0FFh
.xdata$x:00009D18                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0
.xdata$x:00009D1C                 align 10h
.xdata$x:00009D20                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1
.xdata$x:00009D24                 db    1
.xdata$x:00009D25                 db    0
.xdata$x:00009D26                 db    0
.xdata$x:00009D27                 db    0
.xdata$x:00009D28                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2
.xdata$x:00009D2C                 db    1
.xdata$x:00009D2D                 db    0
.xdata$x:00009D2E                 db    0
.xdata$x:00009D2F                 db    0
.xdata$x:00009D30                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3
.xdata$x:00009D34 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z db  22h ; "
.xdata$x:00009D34                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z+11o
.xdata$x:00009D35                 db    5
.xdata$x:00009D36                 db  93h ; ô
.xdata$x:00009D37                 db  19h
.xdata$x:00009D38                 db    4
.xdata$x:00009D39                 db    0
.xdata$x:00009D3A                 db    0
.xdata$x:00009D3B                 db    0
.xdata$x:00009D3C                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.xdata$x:00009D40                 db    0
.xdata$x:00009D41                 db    0
.xdata$x:00009D42                 db    0
.xdata$x:00009D43                 db    0
.xdata$x:00009D44                 db    0
.xdata$x:00009D45                 db    0
.xdata$x:00009D46                 db    0
.xdata$x:00009D47                 db    0
.xdata$x:00009D48                 db    0
.xdata$x:00009D49                 db    0
.xdata$x:00009D4A                 db    0
.xdata$x:00009D4B                 db    0
.xdata$x:00009D4C                 db    0
.xdata$x:00009D4D                 db    0
.xdata$x:00009D4E                 db    0
.xdata$x:00009D4F                 db    0
.xdata$x:00009D50                 db    0
.xdata$x:00009D51                 db    0
.xdata$x:00009D52                 db    0
.xdata$x:00009D53                 db    0
.xdata$x:00009D54                 db    0
.xdata$x:00009D55                 db    0
.xdata$x:00009D56                 db    0
.xdata$x:00009D57                 db    0
.xdata$x:00009D57 _xdata$x        ends
.xdata$x:00009D57
.xdata$x:00009D58 ; ===========================================================================
.xdata$x:00009D58
.xdata$x:00009D58 ; Segment type: Pure data
.xdata$x:00009D58 ; Segment permissions: Read
.xdata$x:00009D58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009D58                 assume cs:_xdata$x
.xdata$x:00009D58                 ;org 9D58h
.xdata$x:00009D58 ; COMDAT (pick associative to section at 3240)
.xdata$x:00009D58 __catchsym$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:00009D58                                         ; DATA XREF: .xdata$x:00009D88o
.xdata$x:00009D59                 db    0
.xdata$x:00009D5A                 db    0
.xdata$x:00009D5B                 db    0
.xdata$x:00009D5C                 db    0
.xdata$x:00009D5D                 db    0
.xdata$x:00009D5E                 db    0
.xdata$x:00009D5F                 db    0
.xdata$x:00009D60                 db    0
.xdata$x:00009D61                 db    0
.xdata$x:00009D62                 db    0
.xdata$x:00009D63                 db    0
.xdata$x:00009D64                 dd offset __catch$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:00009D68 __unwindtable$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:00009D68                                         ; DATA XREF: .xdata$x:00009D94o
.xdata$x:00009D69                 db 0FFh
.xdata$x:00009D6A                 db 0FFh
.xdata$x:00009D6B                 db 0FFh
.xdata$x:00009D6C                 db    0
.xdata$x:00009D6D                 db    0
.xdata$x:00009D6E                 db    0
.xdata$x:00009D6F                 db    0
.xdata$x:00009D70                 db 0FFh
.xdata$x:00009D71                 db 0FFh
.xdata$x:00009D72                 db 0FFh
.xdata$x:00009D73                 db 0FFh
.xdata$x:00009D74                 db    0
.xdata$x:00009D75                 db    0
.xdata$x:00009D76                 db    0
.xdata$x:00009D77                 db    0
.xdata$x:00009D78 __tryblocktable$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:00009D78                                         ; DATA XREF: .xdata$x:00009D9Co
.xdata$x:00009D79                 db    0
.xdata$x:00009D7A                 db    0
.xdata$x:00009D7B                 db    0
.xdata$x:00009D7C                 db    0
.xdata$x:00009D7D                 db    0
.xdata$x:00009D7E                 db    0
.xdata$x:00009D7F                 db    0
.xdata$x:00009D80                 db    1
.xdata$x:00009D81                 db    0
.xdata$x:00009D82                 db    0
.xdata$x:00009D83                 db    0
.xdata$x:00009D84                 db    1
.xdata$x:00009D85                 db    0
.xdata$x:00009D86                 db    0
.xdata$x:00009D87                 db    0
.xdata$x:00009D88                 dd offset __catchsym$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:00009D8C __ehfuncinfo$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:00009D8C                                         ; DATA XREF: __ehhandler$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:00009D8D                 db    5
.xdata$x:00009D8E                 db  93h ; ô
.xdata$x:00009D8F                 db  19h
.xdata$x:00009D90                 db    2
.xdata$x:00009D91                 db    0
.xdata$x:00009D92                 db    0
.xdata$x:00009D93                 db    0
.xdata$x:00009D94                 dd offset __unwindtable$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00009D98                 db    1
.xdata$x:00009D99                 db    0
.xdata$x:00009D9A                 db    0
.xdata$x:00009D9B                 db    0
.xdata$x:00009D9C                 dd offset __tryblocktable$??$_Uninit_fill_n@PAV?$vector@EV?$allocator@E@std@@@std@@IV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAXPAV?$vector@EV?$allocator@E@std@@@0@IPBV10@AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:00009DA0                 db    0
.xdata$x:00009DA1                 db    0
.xdata$x:00009DA2                 db    0
.xdata$x:00009DA3                 db    0
.xdata$x:00009DA4                 db    0
.xdata$x:00009DA5                 db    0
.xdata$x:00009DA6                 db    0
.xdata$x:00009DA7                 db    0
.xdata$x:00009DA8                 db    0
.xdata$x:00009DA9                 db    0
.xdata$x:00009DAA                 db    0
.xdata$x:00009DAB                 db    0
.xdata$x:00009DAC                 db    0
.xdata$x:00009DAD                 db    0
.xdata$x:00009DAE                 db    0
.xdata$x:00009DAF                 db    0
.xdata$x:00009DAF _xdata$x        ends
.xdata$x:00009DAF
.xdata$x:00009DB0 ; ===========================================================================
.xdata$x:00009DB0
.xdata$x:00009DB0 ; Segment type: Pure data
.xdata$x:00009DB0 ; Segment permissions: Read
.xdata$x:00009DB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009DB0                 assume cs:_xdata$x
.xdata$x:00009DB0                 ;org 9DB0h
.xdata$x:00009DB0 ; COMDAT (pick associative to section at 2D60)
.xdata$x:00009DB0 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z db 0FFh
.xdata$x:00009DB0                                         ; DATA XREF: .xdata$x:00009DC0o
.xdata$x:00009DB1                 db 0FFh
.xdata$x:00009DB2                 db 0FFh
.xdata$x:00009DB3                 db 0FFh
.xdata$x:00009DB4                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$0
.xdata$x:00009DB8 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z db  22h ; "
.xdata$x:00009DB8                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z+11o
.xdata$x:00009DB9                 db    5
.xdata$x:00009DBA                 db  93h ; ô
.xdata$x:00009DBB                 db  19h
.xdata$x:00009DBC                 db    1
.xdata$x:00009DBD                 db    0
.xdata$x:00009DBE                 db    0
.xdata$x:00009DBF                 db    0
.xdata$x:00009DC0                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@YAPBEV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.xdata$x:00009DC4                 db    0
.xdata$x:00009DC5                 db    0
.xdata$x:00009DC6                 db    0
.xdata$x:00009DC7                 db    0
.xdata$x:00009DC8                 db    0
.xdata$x:00009DC9                 db    0
.xdata$x:00009DCA                 db    0
.xdata$x:00009DCB                 db    0
.xdata$x:00009DCC                 db    0
.xdata$x:00009DCD                 db    0
.xdata$x:00009DCE                 db    0
.xdata$x:00009DCF                 db    0
.xdata$x:00009DD0                 db    0
.xdata$x:00009DD1                 db    0
.xdata$x:00009DD2                 db    0
.xdata$x:00009DD3                 db    0
.xdata$x:00009DD4                 db    0
.xdata$x:00009DD5                 db    0
.xdata$x:00009DD6                 db    0
.xdata$x:00009DD7                 db    0
.xdata$x:00009DD8                 db    0
.xdata$x:00009DD9                 db    0
.xdata$x:00009DDA                 db    0
.xdata$x:00009DDB                 db    0
.xdata$x:00009DDB _xdata$x        ends
.xdata$x:00009DDB
.xdata$x:00009DDC ; ===========================================================================
.xdata$x:00009DDC
.xdata$x:00009DDC ; Segment type: Pure data
.xdata$x:00009DDC ; Segment permissions: Read
.xdata$x:00009DDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009DDC                 assume cs:_xdata$x
.xdata$x:00009DDC                 ;org 9DDCh
.xdata$x:00009DDC ; COMDAT (pick associative to section at 3904)
.xdata$x:00009DDC __unwindtable$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z db 0FFh
.xdata$x:00009DDC                                         ; DATA XREF: .xdata$x:00009DECo
.xdata$x:00009DDD                 db 0FFh
.xdata$x:00009DDE                 db 0FFh
.xdata$x:00009DDF                 db 0FFh
.xdata$x:00009DE0                 dd offset __unwindfunclet$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z$0
.xdata$x:00009DE4 __ehfuncinfo$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z db  22h ; "
.xdata$x:00009DE4                                         ; DATA XREF: __ehhandler$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z+11o
.xdata$x:00009DE5                 db    5
.xdata$x:00009DE6                 db  93h ; ô
.xdata$x:00009DE7                 db  19h
.xdata$x:00009DE8                 db    1
.xdata$x:00009DE9                 db    0
.xdata$x:00009DEA                 db    0
.xdata$x:00009DEB                 db    0
.xdata$x:00009DEC                 dd offset __unwindtable$??$construct@EE@?$allocator@E@std@@QAEXPAE$$QAE@Z
.xdata$x:00009DF0                 db    0
.xdata$x:00009DF1                 db    0
.xdata$x:00009DF2                 db    0
.xdata$x:00009DF3                 db    0
.xdata$x:00009DF4                 db    0
.xdata$x:00009DF5                 db    0
.xdata$x:00009DF6                 db    0
.xdata$x:00009DF7                 db    0
.xdata$x:00009DF8                 db    0
.xdata$x:00009DF9                 db    0
.xdata$x:00009DFA                 db    0
.xdata$x:00009DFB                 db    0
.xdata$x:00009DFC                 db    0
.xdata$x:00009DFD                 db    0
.xdata$x:00009DFE                 db    0
.xdata$x:00009DFF                 db    0
.xdata$x:00009E00                 db    0
.xdata$x:00009E01                 db    0
.xdata$x:00009E02                 db    0
.xdata$x:00009E03                 db    0
.xdata$x:00009E04                 db    0
.xdata$x:00009E05                 db    0
.xdata$x:00009E06                 db    0
.xdata$x:00009E07                 db    0
.xdata$x:00009E07 _xdata$x        ends
.xdata$x:00009E07
.xdata$x:00009E08 ; ===========================================================================
.xdata$x:00009E08
.xdata$x:00009E08 ; Segment type: Pure data
.xdata$x:00009E08 ; Segment permissions: Read
.xdata$x:00009E08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E08                 assume cs:_xdata$x
.xdata$x:00009E08                 ;org 9E08h
.xdata$x:00009E08 ; COMDAT (pick associative to section at 3A04)
.xdata$x:00009E08 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00009E08                                         ; DATA XREF: .xdata$x:00009E18o
.xdata$x:00009E09                 db 0FFh
.xdata$x:00009E0A                 db 0FFh
.xdata$x:00009E0B                 db 0FFh
.xdata$x:00009E0C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00009E10 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00009E10                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00009E11                 db    5
.xdata$x:00009E12                 db  93h ; ô
.xdata$x:00009E13                 db  19h
.xdata$x:00009E14                 db    1
.xdata$x:00009E15                 db    0
.xdata$x:00009E16                 db    0
.xdata$x:00009E17                 db    0
.xdata$x:00009E18                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00009E1C                 db    0
.xdata$x:00009E1D                 db    0
.xdata$x:00009E1E                 db    0
.xdata$x:00009E1F                 db    0
.xdata$x:00009E20                 db    0
.xdata$x:00009E21                 db    0
.xdata$x:00009E22                 db    0
.xdata$x:00009E23                 db    0
.xdata$x:00009E24                 db    0
.xdata$x:00009E25                 db    0
.xdata$x:00009E26                 db    0
.xdata$x:00009E27                 db    0
.xdata$x:00009E28                 db    0
.xdata$x:00009E29                 db    0
.xdata$x:00009E2A                 db    0
.xdata$x:00009E2B                 db    0
.xdata$x:00009E2C                 db    0
.xdata$x:00009E2D                 db    0
.xdata$x:00009E2E                 db    0
.xdata$x:00009E2F                 db    0
.xdata$x:00009E30                 db    0
.xdata$x:00009E31                 db    0
.xdata$x:00009E32                 db    0
.xdata$x:00009E33                 db    0
.xdata$x:00009E33 _xdata$x        ends
.xdata$x:00009E33
.xdata$x:00009E34 ; ===========================================================================
.xdata$x:00009E34
.xdata$x:00009E34 ; Segment type: Pure data
.xdata$x:00009E34 ; Segment permissions: Read
.xdata$x:00009E34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E34                 assume cs:_xdata$x
.xdata$x:00009E34                 ;org 9E34h
.xdata$x:00009E34 ; COMDAT (pick associative to section at 46AC)
.xdata$x:00009E34 __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z db 0FFh
.xdata$x:00009E34                                         ; DATA XREF: .xdata$x:00009E44o
.xdata$x:00009E35                 db 0FFh
.xdata$x:00009E36                 db 0FFh
.xdata$x:00009E37                 db 0FFh
.xdata$x:00009E38                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z$0
.xdata$x:00009E3C __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00009E3C                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z+11o
.xdata$x:00009E3D                 db    5
.xdata$x:00009E3E                 db  93h ; ô
.xdata$x:00009E3F                 db  19h
.xdata$x:00009E40                 db    1
.xdata$x:00009E41                 db    0
.xdata$x:00009E42                 db    0
.xdata$x:00009E43                 db    0
.xdata$x:00009E44                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@PAEPBU_Container_base12@1@@Z
.xdata$x:00009E48                 align 20h
.xdata$x:00009E48 _xdata$x        ends
.xdata$x:00009E48
.xdata$x:00009E60 ; ===========================================================================
.xdata$x:00009E60
.xdata$x:00009E60 ; Segment type: Pure data
.xdata$x:00009E60 ; Segment permissions: Read
.xdata$x:00009E60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E60                 assume cs:_xdata$x
.xdata$x:00009E60                 ;org 9E60h
.xdata$x:00009E60 ; COMDAT (pick associative to section at 5330)
.xdata$x:00009E60 __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009E60                                         ; DATA XREF: .xdata$x:00009E70o
.xdata$x:00009E61                 db 0FFh
.xdata$x:00009E62                 db 0FFh
.xdata$x:00009E63                 db 0FFh
.xdata$x:00009E64                 dd offset __unwindfunclet$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009E68 __ehfuncinfo$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009E68                                         ; DATA XREF: __ehhandler$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009E69                 db    5
.xdata$x:00009E6A                 db  93h ; ô
.xdata$x:00009E6B                 db  19h
.xdata$x:00009E6C                 db    1
.xdata$x:00009E6D                 db    0
.xdata$x:00009E6E                 db    0
.xdata$x:00009E6F                 db    0
.xdata$x:00009E70                 dd offset __unwindtable$??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@XZ
.xdata$x:00009E74                 db    0
.xdata$x:00009E75                 db    0
.xdata$x:00009E76                 db    0
.xdata$x:00009E77                 db    0
.xdata$x:00009E78                 db    0
.xdata$x:00009E79                 db    0
.xdata$x:00009E7A                 db    0
.xdata$x:00009E7B                 db    0
.xdata$x:00009E7C                 db    0
.xdata$x:00009E7D                 db    0
.xdata$x:00009E7E                 db    0
.xdata$x:00009E7F                 db    0
.xdata$x:00009E80                 db    0
.xdata$x:00009E81                 db    0
.xdata$x:00009E82                 db    0
.xdata$x:00009E83                 db    0
.xdata$x:00009E84                 db    0
.xdata$x:00009E85                 db    0
.xdata$x:00009E86                 db    0
.xdata$x:00009E87                 db    0
.xdata$x:00009E88                 db    0
.xdata$x:00009E89                 db    0
.xdata$x:00009E8A                 db    0
.xdata$x:00009E8B                 db    0
.xdata$x:00009E8B _xdata$x        ends
.xdata$x:00009E8B
.xdata$x:00009E8C ; ===========================================================================
.xdata$x:00009E8C
.xdata$x:00009E8C ; Segment type: Pure data
.xdata$x:00009E8C ; Segment permissions: Read
.xdata$x:00009E8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009E8C                 assume cs:_xdata$x
.xdata$x:00009E8C                 ;org 9E8Ch
.xdata$x:00009E8C ; COMDAT (pick associative to section at 4634)
.xdata$x:00009E8C __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009E8C                                         ; DATA XREF: .xdata$x:00009E9Co
.xdata$x:00009E8D                 db 0FFh
.xdata$x:00009E8E                 db 0FFh
.xdata$x:00009E8F                 db 0FFh
.xdata$x:00009E90                 dd offset __unwindfunclet$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009E94 __ehfuncinfo$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009E94                                         ; DATA XREF: __ehhandler$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009E95                 db    5
.xdata$x:00009E96                 db  93h ; ô
.xdata$x:00009E97                 db  19h
.xdata$x:00009E98                 db    1
.xdata$x:00009E99                 db    0
.xdata$x:00009E9A                 db    0
.xdata$x:00009E9B                 db    0
.xdata$x:00009E9C                 dd offset __unwindtable$??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009EA0                 db    0
.xdata$x:00009EA1                 db    0
.xdata$x:00009EA2                 db    0
.xdata$x:00009EA3                 db    0
.xdata$x:00009EA4                 db    0
.xdata$x:00009EA5                 db    0
.xdata$x:00009EA6                 db    0
.xdata$x:00009EA7                 db    0
.xdata$x:00009EA8                 db    0
.xdata$x:00009EA9                 db    0
.xdata$x:00009EAA                 db    0
.xdata$x:00009EAB                 db    0
.xdata$x:00009EAC                 db    0
.xdata$x:00009EAD                 db    0
.xdata$x:00009EAE                 db    0
.xdata$x:00009EAF                 db    0
.xdata$x:00009EB0                 db    0
.xdata$x:00009EB1                 db    0
.xdata$x:00009EB2                 db    0
.xdata$x:00009EB3                 db    0
.xdata$x:00009EB4                 db    0
.xdata$x:00009EB5                 db    0
.xdata$x:00009EB6                 db    0
.xdata$x:00009EB7                 db    0
.xdata$x:00009EB7 _xdata$x        ends
.xdata$x:00009EB7
.xdata$x:00009EB8 ; ===========================================================================
.xdata$x:00009EB8
.xdata$x:00009EB8 ; Segment type: Pure data
.xdata$x:00009EB8 ; Segment permissions: Read
.xdata$x:00009EB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009EB8                 assume cs:_xdata$x
.xdata$x:00009EB8                 ;org 9EB8h
.xdata$x:00009EB8 ; COMDAT (pick associative to section at 3FB4)
.xdata$x:00009EB8 __unwindtable$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z db 0FFh
.xdata$x:00009EB8                                         ; DATA XREF: .xdata$x:00009EE0o
.xdata$x:00009EB9                 db 0FFh
.xdata$x:00009EBA                 db 0FFh
.xdata$x:00009EBB                 db 0FFh
.xdata$x:00009EBC                 dd offset __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$3
.xdata$x:00009EC0                 db    0
.xdata$x:00009EC1                 db    0
.xdata$x:00009EC2                 db    0
.xdata$x:00009EC3                 db    0
.xdata$x:00009EC4                 dd offset __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$0
.xdata$x:00009EC8                 db    1
.xdata$x:00009EC9                 db    0
.xdata$x:00009ECA                 db    0
.xdata$x:00009ECB                 db    0
.xdata$x:00009ECC                 dd offset __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$1
.xdata$x:00009ED0                 db    1
.xdata$x:00009ED1                 db    0
.xdata$x:00009ED2                 db    0
.xdata$x:00009ED3                 db    0
.xdata$x:00009ED4                 dd offset __unwindfunclet$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z$2
.xdata$x:00009ED8 __ehfuncinfo$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z db  22h ; "
.xdata$x:00009ED8                                         ; DATA XREF: __ehhandler$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z+11o
.xdata$x:00009ED9                 db    5
.xdata$x:00009EDA                 db  93h ; ô
.xdata$x:00009EDB                 db  19h
.xdata$x:00009EDC                 db    4
.xdata$x:00009EDD                 db    0
.xdata$x:00009EDE                 db    0
.xdata$x:00009EDF                 db    0
.xdata$x:00009EE0                 dd offset __unwindtable$??$make_move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@0@@Z
.xdata$x:00009EE4                 db    0
.xdata$x:00009EE5                 db    0
.xdata$x:00009EE6                 db    0
.xdata$x:00009EE7                 db    0
.xdata$x:00009EE8                 db    0
.xdata$x:00009EE9                 db    0
.xdata$x:00009EEA                 db    0
.xdata$x:00009EEB                 db    0
.xdata$x:00009EEC                 db    0
.xdata$x:00009EED                 db    0
.xdata$x:00009EEE                 db    0
.xdata$x:00009EEF                 db    0
.xdata$x:00009EF0                 db    0
.xdata$x:00009EF1                 db    0
.xdata$x:00009EF2                 db    0
.xdata$x:00009EF3                 db    0
.xdata$x:00009EF4                 db    0
.xdata$x:00009EF5                 db    0
.xdata$x:00009EF6                 db    0
.xdata$x:00009EF7                 db    0
.xdata$x:00009EF8                 db    0
.xdata$x:00009EF9                 db    0
.xdata$x:00009EFA                 db    0
.xdata$x:00009EFB                 db    0
.xdata$x:00009EFB _xdata$x        ends
.xdata$x:00009EFB
.xdata$x:00009EFC ; ===========================================================================
.xdata$x:00009EFC
.xdata$x:00009EFC ; Segment type: Pure data
.xdata$x:00009EFC ; Segment permissions: Read
.xdata$x:00009EFC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009EFC                 assume cs:_xdata$x
.xdata$x:00009EFC                 ;org 9EFCh
.xdata$x:00009EFC ; COMDAT (pick associative to section at 4A88)
.xdata$x:00009EFC __unwindtable$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z db 0FFh
.xdata$x:00009EFC                                         ; DATA XREF: .xdata$x:00009F14o
.xdata$x:00009EFD                 db 0FFh
.xdata$x:00009EFE                 db 0FFh
.xdata$x:00009EFF                 db 0FFh
.xdata$x:00009F00                 dd offset __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z$0
.xdata$x:00009F04                 align 8
.xdata$x:00009F08                 dd offset __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z$1
.xdata$x:00009F0C __ehfuncinfo$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z db  22h ; "
.xdata$x:00009F0C                                         ; DATA XREF: __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z+11o
.xdata$x:00009F0D                 db    5
.xdata$x:00009F0E                 db  93h ; ô
.xdata$x:00009F0F                 db  19h
.xdata$x:00009F10                 db    2
.xdata$x:00009F11                 db    0
.xdata$x:00009F12                 db    0
.xdata$x:00009F13                 db    0
.xdata$x:00009F14                 dd offset __unwindtable$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@1@@Z
.xdata$x:00009F18                 db    0
.xdata$x:00009F19                 db    0
.xdata$x:00009F1A                 db    0
.xdata$x:00009F1B                 db    0
.xdata$x:00009F1C                 db    0
.xdata$x:00009F1D                 db    0
.xdata$x:00009F1E                 db    0
.xdata$x:00009F1F                 db    0
.xdata$x:00009F20                 db    0
.xdata$x:00009F21                 db    0
.xdata$x:00009F22                 db    0
.xdata$x:00009F23                 db    0
.xdata$x:00009F24                 db    0
.xdata$x:00009F25                 db    0
.xdata$x:00009F26                 db    0
.xdata$x:00009F27                 db    0
.xdata$x:00009F28                 db    0
.xdata$x:00009F29                 db    0
.xdata$x:00009F2A                 db    0
.xdata$x:00009F2B                 db    0
.xdata$x:00009F2C                 db    0
.xdata$x:00009F2D                 db    0
.xdata$x:00009F2E                 db    0
.xdata$x:00009F2F                 db    0
.xdata$x:00009F2F _xdata$x        ends
.xdata$x:00009F2F
.xdata$x:00009F30 ; ===========================================================================
.xdata$x:00009F30
.xdata$x:00009F30 ; Segment type: Pure data
.xdata$x:00009F30 ; Segment permissions: Read
.xdata$x:00009F30 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F30                 assume cs:_xdata$x
.xdata$x:00009F30                 ;org 9F30h
.xdata$x:00009F30 ; COMDAT (pick associative to section at 7D6C)
.xdata$x:00009F30 __unwindtable$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db 0FFh
.xdata$x:00009F30                                         ; DATA XREF: .xdata$x:00009F40o
.xdata$x:00009F31                 db 0FFh
.xdata$x:00009F32                 db 0FFh
.xdata$x:00009F33                 db 0FFh
.xdata$x:00009F34                 dd offset __unwindfunclet$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ$0
.xdata$x:00009F38 __ehfuncinfo$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00009F38                                         ; DATA XREF: __ehhandler$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ+11o
.xdata$x:00009F39                 db    5
.xdata$x:00009F3A                 db  93h ; ô
.xdata$x:00009F3B                 db  19h
.xdata$x:00009F3C                 db    1
.xdata$x:00009F3D                 db    0
.xdata$x:00009F3E                 db    0
.xdata$x:00009F3F                 db    0
.xdata$x:00009F40                 dd offset __unwindtable$?base@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@2@XZ
.xdata$x:00009F44                 db    0
.xdata$x:00009F45                 db    0
.xdata$x:00009F46                 db    0
.xdata$x:00009F47                 db    0
.xdata$x:00009F48                 db    0
.xdata$x:00009F49                 db    0
.xdata$x:00009F4A                 db    0
.xdata$x:00009F4B                 db    0
.xdata$x:00009F4C                 db    0
.xdata$x:00009F4D                 db    0
.xdata$x:00009F4E                 db    0
.xdata$x:00009F4F                 db    0
.xdata$x:00009F50                 db    0
.xdata$x:00009F51                 db    0
.xdata$x:00009F52                 db    0
.xdata$x:00009F53                 db    0
.xdata$x:00009F54                 db    0
.xdata$x:00009F55                 db    0
.xdata$x:00009F56                 db    0
.xdata$x:00009F57                 db    0
.xdata$x:00009F58                 db    0
.xdata$x:00009F59                 db    0
.xdata$x:00009F5A                 db    0
.xdata$x:00009F5B                 db    0
.xdata$x:00009F5B _xdata$x        ends
.xdata$x:00009F5B
.xdata$x:00009F5C ; ===========================================================================
.xdata$x:00009F5C
.xdata$x:00009F5C ; Segment type: Pure data
.xdata$x:00009F5C ; Segment permissions: Read
.xdata$x:00009F5C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F5C                 assume cs:_xdata$x
.xdata$x:00009F5C                 ;org 9F5Ch
.xdata$x:00009F5C ; COMDAT (pick associative to section at 54FC)
.xdata$x:00009F5C __unwindtable$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00009F5C                                         ; DATA XREF: .xdata$x:00009F6Co
.xdata$x:00009F5D                 db 0FFh
.xdata$x:00009F5E                 db 0FFh
.xdata$x:00009F5F                 db 0FFh
.xdata$x:00009F60                 dd offset __unwindfunclet$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00009F64 __ehfuncinfo$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00009F64                                         ; DATA XREF: __ehhandler$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00009F65                 db    5
.xdata$x:00009F66                 db  93h ; ô
.xdata$x:00009F67                 db  19h
.xdata$x:00009F68                 db    1
.xdata$x:00009F69                 db    0
.xdata$x:00009F6A                 db    0
.xdata$x:00009F6B                 db    0
.xdata$x:00009F6C                 dd offset __unwindtable$??1?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00009F70                 db    0
.xdata$x:00009F71                 db    0
.xdata$x:00009F72                 db    0
.xdata$x:00009F73                 db    0
.xdata$x:00009F74                 db    0
.xdata$x:00009F75                 db    0
.xdata$x:00009F76                 db    0
.xdata$x:00009F77                 db    0
.xdata$x:00009F78                 db    0
.xdata$x:00009F79                 db    0
.xdata$x:00009F7A                 db    0
.xdata$x:00009F7B                 db    0
.xdata$x:00009F7C                 db    0
.xdata$x:00009F7D                 db    0
.xdata$x:00009F7E                 db    0
.xdata$x:00009F7F                 db    0
.xdata$x:00009F80                 db    0
.xdata$x:00009F81                 db    0
.xdata$x:00009F82                 db    0
.xdata$x:00009F83                 db    0
.xdata$x:00009F84                 db    0
.xdata$x:00009F85                 db    0
.xdata$x:00009F86                 db    0
.xdata$x:00009F87                 db    0
.xdata$x:00009F87 _xdata$x        ends
.xdata$x:00009F87
.xdata$x:00009F88 ; ===========================================================================
.xdata$x:00009F88
.xdata$x:00009F88 ; Segment type: Pure data
.xdata$x:00009F88 ; Segment permissions: Read
.xdata$x:00009F88 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009F88                 assume cs:_xdata$x
.xdata$x:00009F88                 ;org 9F88h
.xdata$x:00009F88 ; COMDAT (pick associative to section at 4A10)
.xdata$x:00009F88 __unwindtable$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00009F88                                         ; DATA XREF: .xdata$x:00009F98o
.xdata$x:00009F89                 db 0FFh
.xdata$x:00009F8A                 db 0FFh
.xdata$x:00009F8B                 db 0FFh
.xdata$x:00009F8C                 dd offset __unwindfunclet$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00009F90 __ehfuncinfo$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00009F90                                         ; DATA XREF: __ehhandler$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00009F91                 db    5
.xdata$x:00009F92                 db  93h ; ô
.xdata$x:00009F93                 db  19h
.xdata$x:00009F94                 db    1
.xdata$x:00009F95                 db    0
.xdata$x:00009F96                 db    0
.xdata$x:00009F97                 db    0
.xdata$x:00009F98                 dd offset __unwindtable$??0?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:00009F9C                 db    0
.xdata$x:00009F9D                 db    0
.xdata$x:00009F9E                 db    0
.xdata$x:00009F9F                 db    0
.xdata$x:00009FA0                 db    0
.xdata$x:00009FA1                 db    0
.xdata$x:00009FA2                 db    0
.xdata$x:00009FA3                 db    0
.xdata$x:00009FA4                 db    0
.xdata$x:00009FA5                 db    0
.xdata$x:00009FA6                 db    0
.xdata$x:00009FA7                 db    0
.xdata$x:00009FA8                 db    0
.xdata$x:00009FA9                 db    0
.xdata$x:00009FAA                 db    0
.xdata$x:00009FAB                 db    0
.xdata$x:00009FAC                 db    0
.xdata$x:00009FAD                 db    0
.xdata$x:00009FAE                 db    0
.xdata$x:00009FAF                 db    0
.xdata$x:00009FB0                 db    0
.xdata$x:00009FB1                 db    0
.xdata$x:00009FB2                 db    0
.xdata$x:00009FB3                 db    0
.xdata$x:00009FB3 _xdata$x        ends
.xdata$x:00009FB3
.xdata$x:00009FB4 ; ===========================================================================
.xdata$x:00009FB4
.xdata$x:00009FB4 ; Segment type: Pure data
.xdata$x:00009FB4 ; Segment permissions: Read
.xdata$x:00009FB4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FB4                 assume cs:_xdata$x
.xdata$x:00009FB4                 ;org 9FB4h
.xdata$x:00009FB4 ; COMDAT (pick associative to section at 1F64)
.xdata$x:00009FB4 __unwindtable$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z db 0FFh
.xdata$x:00009FB4                                         ; DATA XREF: .xdata$x:00009FDCo
.xdata$x:00009FB5                 db 0FFh
.xdata$x:00009FB6                 db 0FFh
.xdata$x:00009FB7                 db 0FFh
.xdata$x:00009FB8                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$0
.xdata$x:00009FBC                 align 10h
.xdata$x:00009FC0                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$1
.xdata$x:00009FC4                 db    1
.xdata$x:00009FC5                 db    0
.xdata$x:00009FC6                 db    0
.xdata$x:00009FC7                 db    0
.xdata$x:00009FC8                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$2
.xdata$x:00009FCC                 db    2
.xdata$x:00009FCD                 db    0
.xdata$x:00009FCE                 db    0
.xdata$x:00009FCF                 db    0
.xdata$x:00009FD0                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z$3
.xdata$x:00009FD4 __ehfuncinfo$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z db  22h ; "
.xdata$x:00009FD4                                         ; DATA XREF: __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z+11o
.xdata$x:00009FD5                 db    5
.xdata$x:00009FD6                 db  93h ; ô
.xdata$x:00009FD7                 db  19h
.xdata$x:00009FD8                 db    4
.xdata$x:00009FD9                 db    0
.xdata$x:00009FDA                 db    0
.xdata$x:00009FDB                 db    0
.xdata$x:00009FDC                 dd offset __unwindtable$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0@Z
.xdata$x:00009FE0                 db    0
.xdata$x:00009FE1                 db    0
.xdata$x:00009FE2                 db    0
.xdata$x:00009FE3                 db    0
.xdata$x:00009FE4                 db    0
.xdata$x:00009FE5                 db    0
.xdata$x:00009FE6                 db    0
.xdata$x:00009FE7                 db    0
.xdata$x:00009FE8                 db    0
.xdata$x:00009FE9                 db    0
.xdata$x:00009FEA                 db    0
.xdata$x:00009FEB                 db    0
.xdata$x:00009FEC                 db    0
.xdata$x:00009FED                 db    0
.xdata$x:00009FEE                 db    0
.xdata$x:00009FEF                 db    0
.xdata$x:00009FF0                 db    0
.xdata$x:00009FF1                 db    0
.xdata$x:00009FF2                 db    0
.xdata$x:00009FF3                 db    0
.xdata$x:00009FF4                 db    0
.xdata$x:00009FF5                 db    0
.xdata$x:00009FF6                 db    0
.xdata$x:00009FF7                 db    0
.xdata$x:00009FF7 _xdata$x        ends
.xdata$x:00009FF7
.xdata$x:00009FF8 ; ===========================================================================
.xdata$x:00009FF8
.xdata$x:00009FF8 ; Segment type: Pure data
.xdata$x:00009FF8 ; Segment permissions: Read
.xdata$x:00009FF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00009FF8                 assume cs:_xdata$x
.xdata$x:00009FF8                 ;org 9FF8h
.xdata$x:00009FF8 ; COMDAT (pick associative to section at 33FC)
.xdata$x:00009FF8 __catchsym$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2 db    0
.xdata$x:00009FF8                                         ; DATA XREF: .xdata$x:0000A028o
.xdata$x:00009FF9                 db    0
.xdata$x:00009FFA                 db    0
.xdata$x:00009FFB                 db    0
.xdata$x:00009FFC                 db    0
.xdata$x:00009FFD                 db    0
.xdata$x:00009FFE                 db    0
.xdata$x:00009FFF                 db    0
.xdata$x:0000A000                 db    0
.xdata$x:0000A001                 db    0
.xdata$x:0000A002                 db    0
.xdata$x:0000A003                 db    0
.xdata$x:0000A004                 dd offset __catch$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000A008 __unwindtable$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000A008                                         ; DATA XREF: .xdata$x:0000A034o
.xdata$x:0000A009                 db 0FFh
.xdata$x:0000A00A                 db 0FFh
.xdata$x:0000A00B                 db 0FFh
.xdata$x:0000A00C                 db    0
.xdata$x:0000A00D                 db    0
.xdata$x:0000A00E                 db    0
.xdata$x:0000A00F                 db    0
.xdata$x:0000A010                 db 0FFh
.xdata$x:0000A011                 db 0FFh
.xdata$x:0000A012                 db 0FFh
.xdata$x:0000A013                 db 0FFh
.xdata$x:0000A014                 db    0
.xdata$x:0000A015                 db    0
.xdata$x:0000A016                 db    0
.xdata$x:0000A017                 db    0
.xdata$x:0000A018 __tryblocktable$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db    0
.xdata$x:0000A018                                         ; DATA XREF: .xdata$x:0000A03Co
.xdata$x:0000A019                 db    0
.xdata$x:0000A01A                 db    0
.xdata$x:0000A01B                 db    0
.xdata$x:0000A01C                 db    0
.xdata$x:0000A01D                 db    0
.xdata$x:0000A01E                 db    0
.xdata$x:0000A01F                 db    0
.xdata$x:0000A020                 db    1
.xdata$x:0000A021                 db    0
.xdata$x:0000A022                 db    0
.xdata$x:0000A023                 db    0
.xdata$x:0000A024                 db    1
.xdata$x:0000A025                 db    0
.xdata$x:0000A026                 db    0
.xdata$x:0000A027                 db    0
.xdata$x:0000A028                 dd offset __catchsym$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000A02C __ehfuncinfo$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000A02C                                         ; DATA XREF: __ehhandler$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000A02D                 db    5
.xdata$x:0000A02E                 db  93h ; ô
.xdata$x:0000A02F                 db  19h
.xdata$x:0000A030                 db    2
.xdata$x:0000A031                 db    0
.xdata$x:0000A032                 db    0
.xdata$x:0000A033                 db    0
.xdata$x:0000A034                 dd offset __unwindtable$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A038                 db    1
.xdata$x:0000A039                 db    0
.xdata$x:0000A03A                 db    0
.xdata$x:0000A03B                 db    0
.xdata$x:0000A03C                 dd offset __tryblocktable$??$_Uninit_move@PAV?$vector@EV?$allocator@E@std@@@std@@PAV12@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@2@V12@@std@@YAPAV?$vector@EV?$allocator@E@std@@@0@PAV10@00AAU?$_Wrap_alloc@V?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@@0@0U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A040                 db    0
.xdata$x:0000A041                 db    0
.xdata$x:0000A042                 db    0
.xdata$x:0000A043                 db    0
.xdata$x:0000A044                 db    0
.xdata$x:0000A045                 db    0
.xdata$x:0000A046                 db    0
.xdata$x:0000A047                 db    0
.xdata$x:0000A048                 db    0
.xdata$x:0000A049                 db    0
.xdata$x:0000A04A                 db    0
.xdata$x:0000A04B                 db    0
.xdata$x:0000A04C                 db    0
.xdata$x:0000A04D                 db    0
.xdata$x:0000A04E                 db    0
.xdata$x:0000A04F                 db    0
.xdata$x:0000A04F _xdata$x        ends
.xdata$x:0000A04F
.xdata$x:0000A050 ; ===========================================================================
.xdata$x:0000A050
.xdata$x:0000A050 ; Segment type: Pure data
.xdata$x:0000A050 ; Segment permissions: Read
.xdata$x:0000A050 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A050                 assume cs:_xdata$x
.xdata$x:0000A050                 ;org 0A050h
.xdata$x:0000A050 ; COMDAT (pick associative to section at 2060)
.xdata$x:0000A050 __catchsym$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$8 db    0
.xdata$x:0000A050                                         ; DATA XREF: .xdata$x:0000A070o
.xdata$x:0000A051                 db    0
.xdata$x:0000A052                 db    0
.xdata$x:0000A053                 db    0
.xdata$x:0000A054                 db    0
.xdata$x:0000A055                 db    0
.xdata$x:0000A056                 db    0
.xdata$x:0000A057                 db    0
.xdata$x:0000A058                 db    0
.xdata$x:0000A059                 db    0
.xdata$x:0000A05A                 db    0
.xdata$x:0000A05B                 db    0
.xdata$x:0000A05C                 dd offset __catch$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0
.xdata$x:0000A060 __tryblocktable$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db    4
.xdata$x:0000A060                                         ; DATA XREF: .xdata$x:0000A084o
.xdata$x:0000A061                 db    0
.xdata$x:0000A062                 db    0
.xdata$x:0000A063                 db    0
.xdata$x:0000A064                 db    6
.xdata$x:0000A065                 db    0
.xdata$x:0000A066                 db    0
.xdata$x:0000A067                 db    0
.xdata$x:0000A068                 db    7
.xdata$x:0000A069                 db    0
.xdata$x:0000A06A                 db    0
.xdata$x:0000A06B                 db    0
.xdata$x:0000A06C                 db    1
.xdata$x:0000A06D                 db    0
.xdata$x:0000A06E                 db    0
.xdata$x:0000A06F                 db    0
.xdata$x:0000A070                 dd offset __catchsym$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$8
.xdata$x:0000A074 __ehfuncinfo$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db  22h ; "
.xdata$x:0000A074                                         ; DATA XREF: __ehhandler$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z+11o
.xdata$x:0000A075                 db    5
.xdata$x:0000A076                 db  93h ; ô
.xdata$x:0000A077                 db  19h
.xdata$x:0000A078                 db    8
.xdata$x:0000A079                 db    0
.xdata$x:0000A07A                 db    0
.xdata$x:0000A07B                 db    0
.xdata$x:0000A07C                 dd offset __unwindtable$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.xdata$x:0000A080                 db    1
.xdata$x:0000A081                 db    0
.xdata$x:0000A082                 db    0
.xdata$x:0000A083                 db    0
.xdata$x:0000A084                 dd offset __tryblocktable$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z
.xdata$x:0000A088                 db    0
.xdata$x:0000A089                 db    0
.xdata$x:0000A08A                 db    0
.xdata$x:0000A08B                 db    0
.xdata$x:0000A08C                 db    0
.xdata$x:0000A08D                 db    0
.xdata$x:0000A08E                 db    0
.xdata$x:0000A08F                 db    0
.xdata$x:0000A090                 db    0
.xdata$x:0000A091                 db    0
.xdata$x:0000A092                 db    0
.xdata$x:0000A093                 db    0
.xdata$x:0000A094                 db    0
.xdata$x:0000A095                 db    0
.xdata$x:0000A096                 db    0
.xdata$x:0000A097                 db    0
.xdata$x:0000A098 __unwindtable$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z db 0FFh
.xdata$x:0000A098                                         ; DATA XREF: .xdata$x:0000A07Co
.xdata$x:0000A099                 db 0FFh
.xdata$x:0000A09A                 db 0FFh
.xdata$x:0000A09B                 db 0FFh
.xdata$x:0000A09C                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$2
.xdata$x:0000A0A0                 db    0
.xdata$x:0000A0A1                 db    0
.xdata$x:0000A0A2                 db    0
.xdata$x:0000A0A3                 db    0
.xdata$x:0000A0A4                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$3
.xdata$x:0000A0A8                 db    1
.xdata$x:0000A0A9                 db    0
.xdata$x:0000A0AA                 db    0
.xdata$x:0000A0AB                 db    0
.xdata$x:0000A0AC                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$4
.xdata$x:0000A0B0                 db    2
.xdata$x:0000A0B1                 db    0
.xdata$x:0000A0B2                 db    0
.xdata$x:0000A0B3                 db    0
.xdata$x:0000A0B4                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$5
.xdata$x:0000A0B8                 db    1
.xdata$x:0000A0B9                 db    0
.xdata$x:0000A0BA                 db    0
.xdata$x:0000A0BB                 db    0
.xdata$x:0000A0BC                 db    0
.xdata$x:0000A0BD                 db    0
.xdata$x:0000A0BE                 db    0
.xdata$x:0000A0BF                 db    0
.xdata$x:0000A0C0                 db    4
.xdata$x:0000A0C1                 db    0
.xdata$x:0000A0C2                 db    0
.xdata$x:0000A0C3                 db    0
.xdata$x:0000A0C4                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$6
.xdata$x:0000A0C8                 db    5
.xdata$x:0000A0C9                 db    0
.xdata$x:0000A0CA                 db    0
.xdata$x:0000A0CB                 db    0
.xdata$x:0000A0CC                 dd offset __unwindfunclet$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$7
.xdata$x:0000A0D0                 db    1
.xdata$x:0000A0D1                 db    0
.xdata$x:0000A0D2                 db    0
.xdata$x:0000A0D3                 db    0
.xdata$x:0000A0D4                 db    0
.xdata$x:0000A0D5                 db    0
.xdata$x:0000A0D6                 db    0
.xdata$x:0000A0D7                 db    0
.xdata$x:0000A0D7 _xdata$x        ends
.xdata$x:0000A0D7
.xdata$x:0000A0D8 ; ===========================================================================
.xdata$x:0000A0D8
.xdata$x:0000A0D8 ; Segment type: Pure data
.xdata$x:0000A0D8 ; Segment permissions: Read
.xdata$x:0000A0D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A0D8                 assume cs:_xdata$x
.xdata$x:0000A0D8                 ;org 0A0D8h
.xdata$x:0000A0D8 ; COMDAT (pick associative to section at 3E40)
.xdata$x:0000A0D8 __unwindtable$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z db 0FFh
.xdata$x:0000A0D8                                         ; DATA XREF: .xdata$x:0000A100o
.xdata$x:0000A0D9                 db 0FFh
.xdata$x:0000A0DA                 db 0FFh
.xdata$x:0000A0DB                 db 0FFh
.xdata$x:0000A0DC                 dd offset __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$0
.xdata$x:0000A0E0                 db    0
.xdata$x:0000A0E1                 db    0
.xdata$x:0000A0E2                 db    0
.xdata$x:0000A0E3                 db    0
.xdata$x:0000A0E4                 dd offset __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$1
.xdata$x:0000A0E8                 db    1
.xdata$x:0000A0E9                 db    0
.xdata$x:0000A0EA                 db    0
.xdata$x:0000A0EB                 db    0
.xdata$x:0000A0EC                 dd offset __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$2
.xdata$x:0000A0F0                 db    2
.xdata$x:0000A0F1                 db    0
.xdata$x:0000A0F2                 db    0
.xdata$x:0000A0F3                 db    0
.xdata$x:0000A0F4                 dd offset __unwindfunclet$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z$3
.xdata$x:0000A0F8 __ehfuncinfo$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z db  22h ; "
.xdata$x:0000A0F8                                         ; DATA XREF: __ehhandler$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z+11o
.xdata$x:0000A0F9                 db    5
.xdata$x:0000A0FA                 db  93h ; ô
.xdata$x:0000A0FB                 db  19h
.xdata$x:0000A0FC                 db    4
.xdata$x:0000A0FD                 db    0
.xdata$x:0000A0FE                 db    0
.xdata$x:0000A0FF                 db    0
.xdata$x:0000A100                 dd offset __unwindtable$??$distance@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAHV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0@Z
.xdata$x:0000A104                 db    0
.xdata$x:0000A105                 db    0
.xdata$x:0000A106                 db    0
.xdata$x:0000A107                 db    0
.xdata$x:0000A108                 db    0
.xdata$x:0000A109                 db    0
.xdata$x:0000A10A                 db    0
.xdata$x:0000A10B                 db    0
.xdata$x:0000A10C                 db    0
.xdata$x:0000A10D                 db    0
.xdata$x:0000A10E                 db    0
.xdata$x:0000A10F                 db    0
.xdata$x:0000A110                 db    0
.xdata$x:0000A111                 db    0
.xdata$x:0000A112                 db    0
.xdata$x:0000A113                 db    0
.xdata$x:0000A114                 db    0
.xdata$x:0000A115                 db    0
.xdata$x:0000A116                 db    0
.xdata$x:0000A117                 db    0
.xdata$x:0000A118                 db    0
.xdata$x:0000A119                 db    0
.xdata$x:0000A11A                 db    0
.xdata$x:0000A11B                 db    0
.xdata$x:0000A11B _xdata$x        ends
.xdata$x:0000A11B
.xdata$x:0000A11C ; ===========================================================================
.xdata$x:0000A11C
.xdata$x:0000A11C ; Segment type: Pure data
.xdata$x:0000A11C ; Segment permissions: Read
.xdata$x:0000A11C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A11C                 assume cs:_xdata$x
.xdata$x:0000A11C                 ;org 0A11Ch
.xdata$x:0000A11C ; COMDAT (pick associative to section at 2BE8)
.xdata$x:0000A11C __unwindtable$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z db 0FFh
.xdata$x:0000A11C                                         ; DATA XREF: .xdata$x:0000A144o
.xdata$x:0000A11D                 db 0FFh
.xdata$x:0000A11E                 db 0FFh
.xdata$x:0000A11F                 db 0FFh
.xdata$x:0000A120                 dd offset __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$0
.xdata$x:0000A124                 align 8
.xdata$x:0000A128                 dd offset __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$1
.xdata$x:0000A12C                 db    1
.xdata$x:0000A12D                 db    0
.xdata$x:0000A12E                 db    0
.xdata$x:0000A12F                 db    0
.xdata$x:0000A130                 dd offset __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$2
.xdata$x:0000A134                 db    2
.xdata$x:0000A135                 db    0
.xdata$x:0000A136                 db    0
.xdata$x:0000A137                 db    0
.xdata$x:0000A138                 dd offset __unwindfunclet$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z$3
.xdata$x:0000A13C __ehfuncinfo$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z db  22h ; "
.xdata$x:0000A13C                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z+11o
.xdata$x:0000A13D                 db    5
.xdata$x:0000A13E                 db  93h ; ô
.xdata$x:0000A13F                 db  19h
.xdata$x:0000A140                 db    4
.xdata$x:0000A141                 db    0
.xdata$x:0000A142                 db    0
.xdata$x:0000A143                 db    0
.xdata$x:0000A144                 dd offset __unwindtable$??$_Ucopy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@IAEPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0PAE@Z
.xdata$x:0000A148                 align 20h
.xdata$x:0000A148 _xdata$x        ends
.xdata$x:0000A148
.xdata$x:0000A160 ; ===========================================================================
.xdata$x:0000A160
.xdata$x:0000A160 ; Segment type: Pure data
.xdata$x:0000A160 ; Segment permissions: Read
.xdata$x:0000A160 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A160                 assume cs:_xdata$x
.xdata$x:0000A160                 ;org 0A160h
.xdata$x:0000A160 ; COMDAT (pick associative to section at 2768)
.xdata$x:0000A160 __unwindtable$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000A160                                         ; DATA XREF: .xdata$x:0000A178o
.xdata$x:0000A161                 db 0FFh
.xdata$x:0000A162                 db 0FFh
.xdata$x:0000A163                 db 0FFh
.xdata$x:0000A164                 dd offset __unwindfunclet$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000A168                 db    0
.xdata$x:0000A169                 db    0
.xdata$x:0000A16A                 db    0
.xdata$x:0000A16B                 db    0
.xdata$x:0000A16C                 dd offset __unwindfunclet$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000A170 __ehfuncinfo$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000A170                                         ; DATA XREF: __ehhandler$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000A171                 db    5
.xdata$x:0000A172                 db  93h ; ô
.xdata$x:0000A173                 db  19h
.xdata$x:0000A174                 db    2
.xdata$x:0000A175                 db    0
.xdata$x:0000A176                 db    0
.xdata$x:0000A177                 db    0
.xdata$x:0000A178                 dd offset __unwindtable$??$_Distance2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@H@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0AAHUrandom_access_iterator_tag@0@@Z
.xdata$x:0000A17C                 db    0
.xdata$x:0000A17D                 db    0
.xdata$x:0000A17E                 db    0
.xdata$x:0000A17F                 db    0
.xdata$x:0000A180                 db    0
.xdata$x:0000A181                 db    0
.xdata$x:0000A182                 db    0
.xdata$x:0000A183                 db    0
.xdata$x:0000A184                 db    0
.xdata$x:0000A185                 db    0
.xdata$x:0000A186                 db    0
.xdata$x:0000A187                 db    0
.xdata$x:0000A188                 db    0
.xdata$x:0000A189                 db    0
.xdata$x:0000A18A                 db    0
.xdata$x:0000A18B                 db    0
.xdata$x:0000A18C                 db    0
.xdata$x:0000A18D                 db    0
.xdata$x:0000A18E                 db    0
.xdata$x:0000A18F                 db    0
.xdata$x:0000A190                 db    0
.xdata$x:0000A191                 db    0
.xdata$x:0000A192                 db    0
.xdata$x:0000A193                 db    0
.xdata$x:0000A193 _xdata$x        ends
.xdata$x:0000A193
.xdata$x:0000A194 ; ===========================================================================
.xdata$x:0000A194
.xdata$x:0000A194 ; Segment type: Pure data
.xdata$x:0000A194 ; Segment permissions: Read
.xdata$x:0000A194 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A194                 assume cs:_xdata$x
.xdata$x:0000A194                 ;org 0A194h
.xdata$x:0000A194 ; COMDAT (pick associative to section at 3674)
.xdata$x:0000A194 __ehfuncinfo$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z db  22h ; "
.xdata$x:0000A194                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z+11o
.xdata$x:0000A195                 db    5
.xdata$x:0000A196                 db  93h ; ô
.xdata$x:0000A197                 db  19h
.xdata$x:0000A198                 db    6
.xdata$x:0000A199                 db    0
.xdata$x:0000A19A                 db    0
.xdata$x:0000A19B                 db    0
.xdata$x:0000A19C                 dd offset __unwindtable$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.xdata$x:0000A1A0                 db    0
.xdata$x:0000A1A1                 db    0
.xdata$x:0000A1A2                 db    0
.xdata$x:0000A1A3                 db    0
.xdata$x:0000A1A4                 db    0
.xdata$x:0000A1A5                 db    0
.xdata$x:0000A1A6                 db    0
.xdata$x:0000A1A7                 db    0
.xdata$x:0000A1A8                 db    0
.xdata$x:0000A1A9                 db    0
.xdata$x:0000A1AA                 db    0
.xdata$x:0000A1AB                 db    0
.xdata$x:0000A1AC                 db    0
.xdata$x:0000A1AD                 db    0
.xdata$x:0000A1AE                 db    0
.xdata$x:0000A1AF                 db    0
.xdata$x:0000A1B0                 db    0
.xdata$x:0000A1B1                 db    0
.xdata$x:0000A1B2                 db    0
.xdata$x:0000A1B3                 db    0
.xdata$x:0000A1B4                 db    0
.xdata$x:0000A1B5                 db    0
.xdata$x:0000A1B6                 db    0
.xdata$x:0000A1B7                 db    0
.xdata$x:0000A1B8 __unwindtable$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z db 0FFh
.xdata$x:0000A1B8                                         ; DATA XREF: .xdata$x:0000A19Co
.xdata$x:0000A1B9                 db 0FFh
.xdata$x:0000A1BA                 db 0FFh
.xdata$x:0000A1BB                 db 0FFh
.xdata$x:0000A1BC                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0
.xdata$x:0000A1C0                 db    0
.xdata$x:0000A1C1                 db    0
.xdata$x:0000A1C2                 db    0
.xdata$x:0000A1C3                 db    0
.xdata$x:0000A1C4                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1
.xdata$x:0000A1C8                 db    1
.xdata$x:0000A1C9                 db    0
.xdata$x:0000A1CA                 db    0
.xdata$x:0000A1CB                 db    0
.xdata$x:0000A1CC                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2
.xdata$x:0000A1D0                 db    1
.xdata$x:0000A1D1                 db    0
.xdata$x:0000A1D2                 db    0
.xdata$x:0000A1D3                 db    0
.xdata$x:0000A1D4                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3
.xdata$x:0000A1D8                 db    3
.xdata$x:0000A1D9                 db    0
.xdata$x:0000A1DA                 db    0
.xdata$x:0000A1DB                 db    0
.xdata$x:0000A1DC                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$4
.xdata$x:0000A1E0                 db    3
.xdata$x:0000A1E1                 db    0
.xdata$x:0000A1E2                 db    0
.xdata$x:0000A1E3                 db    0
.xdata$x:0000A1E4                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$5
.xdata$x:0000A1E4 _xdata$x        ends
.xdata$x:0000A1E4
.xdata$x:0000A1E8 ; ===========================================================================
.xdata$x:0000A1E8
.xdata$x:0000A1E8 ; Segment type: Pure data
.xdata$x:0000A1E8 ; Segment permissions: Read
.xdata$x:0000A1E8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A1E8                 assume cs:_xdata$x
.xdata$x:0000A1E8                 ;org 0A1E8h
.xdata$x:0000A1E8 ; COMDAT (pick associative to section at 3C54)
.xdata$x:0000A1E8 __unwindtable$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z db 0FFh
.xdata$x:0000A1E8                                         ; DATA XREF: .xdata$x:0000A1F8o
.xdata$x:0000A1E9                 db 0FFh
.xdata$x:0000A1EA                 db 0FFh
.xdata$x:0000A1EB                 db 0FFh
.xdata$x:0000A1EC                 dd offset __unwindfunclet$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z$0
.xdata$x:0000A1F0 __ehfuncinfo$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z db  22h ; "
.xdata$x:0000A1F0                                         ; DATA XREF: __ehhandler$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z+11o
.xdata$x:0000A1F1                 db    5
.xdata$x:0000A1F2                 db  93h ; ô
.xdata$x:0000A1F3                 db  19h
.xdata$x:0000A1F4                 db    1
.xdata$x:0000A1F5                 db    0
.xdata$x:0000A1F6                 db    0
.xdata$x:0000A1F7                 db    0
.xdata$x:0000A1F8                 dd offset __unwindtable$??$construct@V?$vector@EV?$allocator@E@std@@@std@@V12@@?$allocator@V?$vector@EV?$allocator@E@std@@@std@@@std@@QAEXPAV?$vector@EV?$allocator@E@std@@@1@$$QAV21@@Z
.xdata$x:0000A1FC                 db    0
.xdata$x:0000A1FD                 db    0
.xdata$x:0000A1FE                 db    0
.xdata$x:0000A1FF                 db    0
.xdata$x:0000A200                 db    0
.xdata$x:0000A201                 db    0
.xdata$x:0000A202                 db    0
.xdata$x:0000A203                 db    0
.xdata$x:0000A204                 db    0
.xdata$x:0000A205                 db    0
.xdata$x:0000A206                 db    0
.xdata$x:0000A207                 db    0
.xdata$x:0000A208                 db    0
.xdata$x:0000A209                 db    0
.xdata$x:0000A20A                 db    0
.xdata$x:0000A20B                 db    0
.xdata$x:0000A20C                 db    0
.xdata$x:0000A20D                 db    0
.xdata$x:0000A20E                 db    0
.xdata$x:0000A20F                 db    0
.xdata$x:0000A210                 db    0
.xdata$x:0000A211                 db    0
.xdata$x:0000A212                 db    0
.xdata$x:0000A213                 db    0
.xdata$x:0000A213 _xdata$x        ends
.xdata$x:0000A213
.xdata$x:0000A214 ; ===========================================================================
.xdata$x:0000A214
.xdata$x:0000A214 ; Segment type: Pure data
.xdata$x:0000A214 ; Segment permissions: Read
.xdata$x:0000A214 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A214                 assume cs:_xdata$x
.xdata$x:0000A214                 ;org 0A214h
.xdata$x:0000A214 ; COMDAT (pick associative to section at 1D94)
.xdata$x:0000A214 __unwindtable$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z db 0FFh
.xdata$x:0000A214                                         ; DATA XREF: .xdata$x:0000A22Co
.xdata$x:0000A215                 db 0FFh
.xdata$x:0000A216                 db 0FFh
.xdata$x:0000A217                 db 0FFh
.xdata$x:0000A218                 dd offset __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z$0
.xdata$x:0000A21C                 align 10h
.xdata$x:0000A220                 dd offset __unwindfunclet$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z$1
.xdata$x:0000A224 __ehfuncinfo$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z db  22h ; "
.xdata$x:0000A224                                         ; DATA XREF: __ehhandler$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z+11o
.xdata$x:0000A225                 db    5
.xdata$x:0000A226                 db  93h ; ô
.xdata$x:0000A227                 db  19h
.xdata$x:0000A228                 db    2
.xdata$x:0000A229                 db    0
.xdata$x:0000A22A                 db    0
.xdata$x:0000A22B                 db    0
.xdata$x:0000A22C                 dd offset __unwindtable$??$?GV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@V01@@std@@YAHAAV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@ABV10@@Z
.xdata$x:0000A230                 db    0
.xdata$x:0000A231                 db    0
.xdata$x:0000A232                 db    0
.xdata$x:0000A233                 db    0
.xdata$x:0000A234                 db    0
.xdata$x:0000A235                 db    0
.xdata$x:0000A236                 db    0
.xdata$x:0000A237                 db    0
.xdata$x:0000A238                 db    0
.xdata$x:0000A239                 db    0
.xdata$x:0000A23A                 db    0
.xdata$x:0000A23B                 db    0
.xdata$x:0000A23C                 db    0
.xdata$x:0000A23D                 db    0
.xdata$x:0000A23E                 db    0
.xdata$x:0000A23F                 db    0
.xdata$x:0000A240                 db    0
.xdata$x:0000A241                 db    0
.xdata$x:0000A242                 db    0
.xdata$x:0000A243                 db    0
.xdata$x:0000A244                 db    0
.xdata$x:0000A245                 db    0
.xdata$x:0000A246                 db    0
.xdata$x:0000A247                 db    0
.xdata$x:0000A247 _xdata$x        ends
.xdata$x:0000A247
.xdata$x:0000A248 ; ===========================================================================
.xdata$x:0000A248
.xdata$x:0000A248 ; Segment type: Pure data
.xdata$x:0000A248 ; Segment permissions: Read
.xdata$x:0000A248 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A248                 assume cs:_xdata$x
.xdata$x:0000A248                 ;org 0A248h
.xdata$x:0000A248 ; COMDAT (pick associative to section at 2DDC)
.xdata$x:0000A248 __unwindtable$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z db 0FFh
.xdata$x:0000A248                                         ; DATA XREF: .xdata$x:0000A260o
.xdata$x:0000A249                 db 0FFh
.xdata$x:0000A24A                 db 0FFh
.xdata$x:0000A24B                 db 0FFh
.xdata$x:0000A24C                 dd offset __unwindfunclet$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z$1
.xdata$x:0000A250                 db    0
.xdata$x:0000A251                 db    0
.xdata$x:0000A252                 db    0
.xdata$x:0000A253                 db    0
.xdata$x:0000A254                 dd offset __unwindfunclet$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z$0
.xdata$x:0000A258 __ehfuncinfo$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z db  22h ; "
.xdata$x:0000A258                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z+11o
.xdata$x:0000A259                 db    5
.xdata$x:0000A25A                 db  93h ; ô
.xdata$x:0000A25B                 db  19h
.xdata$x:0000A25C                 db    2
.xdata$x:0000A25D                 db    0
.xdata$x:0000A25E                 db    0
.xdata$x:0000A25F                 db    0
.xdata$x:0000A260                 dd offset __unwindtable$??$_Unchecked@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YA?AV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@V10@@Z
.xdata$x:0000A264                 db    0
.xdata$x:0000A265                 db    0
.xdata$x:0000A266                 db    0
.xdata$x:0000A267                 db    0
.xdata$x:0000A268                 db    0
.xdata$x:0000A269                 db    0
.xdata$x:0000A26A                 db    0
.xdata$x:0000A26B                 db    0
.xdata$x:0000A26C                 db    0
.xdata$x:0000A26D                 db    0
.xdata$x:0000A26E                 db    0
.xdata$x:0000A26F                 db    0
.xdata$x:0000A270                 db    0
.xdata$x:0000A271                 db    0
.xdata$x:0000A272                 db    0
.xdata$x:0000A273                 db    0
.xdata$x:0000A274                 db    0
.xdata$x:0000A275                 db    0
.xdata$x:0000A276                 db    0
.xdata$x:0000A277                 db    0
.xdata$x:0000A278                 db    0
.xdata$x:0000A279                 db    0
.xdata$x:0000A27A                 db    0
.xdata$x:0000A27B                 db    0
.xdata$x:0000A27B _xdata$x        ends
.xdata$x:0000A27B
.xdata$x:0000A27C ; ===========================================================================
.xdata$x:0000A27C
.xdata$x:0000A27C ; Segment type: Pure data
.xdata$x:0000A27C ; Segment permissions: Read
.xdata$x:0000A27C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A27C                 assume cs:_xdata$x
.xdata$x:0000A27C                 ;org 0A27Ch
.xdata$x:0000A27C ; COMDAT (pick associative to section at 2F9C)
.xdata$x:0000A27C __unwindtable$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z db 0FFh
.xdata$x:0000A27C                                         ; DATA XREF: .xdata$x:0000A2A4o
.xdata$x:0000A27D                 db 0FFh
.xdata$x:0000A27E                 db 0FFh
.xdata$x:0000A27F                 db 0FFh
.xdata$x:0000A280                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$0
.xdata$x:0000A284                 align 8
.xdata$x:0000A288                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$1
.xdata$x:0000A28C                 db    1
.xdata$x:0000A28D                 db    0
.xdata$x:0000A28E                 db    0
.xdata$x:0000A28F                 db    0
.xdata$x:0000A290                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$2
.xdata$x:0000A294                 db    2
.xdata$x:0000A295                 db    0
.xdata$x:0000A296                 db    0
.xdata$x:0000A297                 db    0
.xdata$x:0000A298                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z$3
.xdata$x:0000A29C __ehfuncinfo$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z db  22h ; "
.xdata$x:0000A29C                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z+11o
.xdata$x:0000A29D                 db    5
.xdata$x:0000A29E                 db  93h ; ô
.xdata$x:0000A29F                 db  19h
.xdata$x:0000A2A0                 db    4
.xdata$x:0000A2A1                 db    0
.xdata$x:0000A2A2                 db    0
.xdata$x:0000A2A3                 db    0
.xdata$x:0000A2A4                 dd offset __unwindtable$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEU?$_Wrap_alloc@V?$allocator@E@std@@@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@@Z
.xdata$x:0000A2A8                 align 20h
.xdata$x:0000A2A8 _xdata$x        ends
.xdata$x:0000A2A8
.xdata$x:0000A2C0 ; ===========================================================================
.xdata$x:0000A2C0
.xdata$x:0000A2C0 ; Segment type: Pure data
.xdata$x:0000A2C0 ; Segment permissions: Read
.xdata$x:0000A2C0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A2C0                 assume cs:_xdata$x
.xdata$x:0000A2C0                 ;org 0A2C0h
.xdata$x:0000A2C0 ; COMDAT (pick associative to section at 30A4)
.xdata$x:0000A2C0 __catchsym$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$6 db    0
.xdata$x:0000A2C0                                         ; DATA XREF: .xdata$x:0000A2E0o
.xdata$x:0000A2C1                 db    0
.xdata$x:0000A2C2                 db    0
.xdata$x:0000A2C3                 db    0
.xdata$x:0000A2C4                 db    0
.xdata$x:0000A2C5                 db    0
.xdata$x:0000A2C6                 db    0
.xdata$x:0000A2C7                 db    0
.xdata$x:0000A2C8                 db    0
.xdata$x:0000A2C9                 db    0
.xdata$x:0000A2CA                 db    0
.xdata$x:0000A2CB                 db    0
.xdata$x:0000A2CC                 dd offset __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0
.xdata$x:0000A2D0 __tryblocktable$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db    4
.xdata$x:0000A2D0                                         ; DATA XREF: .xdata$x:0000A2F4o
.xdata$x:0000A2D1                 db    0
.xdata$x:0000A2D2                 db    0
.xdata$x:0000A2D3                 db    0
.xdata$x:0000A2D4                 db    4
.xdata$x:0000A2D5                 db    0
.xdata$x:0000A2D6                 db    0
.xdata$x:0000A2D7                 db    0
.xdata$x:0000A2D8                 db    5
.xdata$x:0000A2D9                 db    0
.xdata$x:0000A2DA                 db    0
.xdata$x:0000A2DB                 db    0
.xdata$x:0000A2DC                 db    1
.xdata$x:0000A2DD                 db    0
.xdata$x:0000A2DE                 db    0
.xdata$x:0000A2DF                 db    0
.xdata$x:0000A2E0                 dd offset __catchsym$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$6
.xdata$x:0000A2E4 __ehfuncinfo$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000A2E4                                         ; DATA XREF: __ehhandler$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z+11o
.xdata$x:0000A2E5                 db    5
.xdata$x:0000A2E6                 db  93h ; ô
.xdata$x:0000A2E7                 db  19h
.xdata$x:0000A2E8                 db    6
.xdata$x:0000A2E9                 db    0
.xdata$x:0000A2EA                 db    0
.xdata$x:0000A2EB                 db    0
.xdata$x:0000A2EC                 dd offset __unwindtable$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A2F0                 db    1
.xdata$x:0000A2F1                 db    0
.xdata$x:0000A2F2                 db    0
.xdata$x:0000A2F3                 db    0
.xdata$x:0000A2F4                 dd offset __tryblocktable$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
.xdata$x:0000A2F8                 db    0
.xdata$x:0000A2F9                 db    0
.xdata$x:0000A2FA                 db    0
.xdata$x:0000A2FB                 db    0
.xdata$x:0000A2FC                 db    0
.xdata$x:0000A2FD                 db    0
.xdata$x:0000A2FE                 db    0
.xdata$x:0000A2FF                 db    0
.xdata$x:0000A300                 db    0
.xdata$x:0000A301                 db    0
.xdata$x:0000A302                 db    0
.xdata$x:0000A303                 db    0
.xdata$x:0000A304                 db    0
.xdata$x:0000A305                 db    0
.xdata$x:0000A306                 db    0
.xdata$x:0000A307                 db    0
.xdata$x:0000A308 __unwindtable$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z db 0FFh
.xdata$x:0000A308                                         ; DATA XREF: .xdata$x:0000A2ECo
.xdata$x:0000A309                 db 0FFh
.xdata$x:0000A30A                 db 0FFh
.xdata$x:0000A30B                 db 0FFh
.xdata$x:0000A30C                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$2
.xdata$x:0000A310                 db    0
.xdata$x:0000A311                 db    0
.xdata$x:0000A312                 db    0
.xdata$x:0000A313                 db    0
.xdata$x:0000A314                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$3
.xdata$x:0000A318                 db    1
.xdata$x:0000A319                 db    0
.xdata$x:0000A31A                 db    0
.xdata$x:0000A31B                 db    0
.xdata$x:0000A31C                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$4
.xdata$x:0000A320                 db    2
.xdata$x:0000A321                 db    0
.xdata$x:0000A322                 db    0
.xdata$x:0000A323                 db    0
.xdata$x:0000A324                 dd offset __unwindfunclet$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$5
.xdata$x:0000A328                 db    1
.xdata$x:0000A329                 db    0
.xdata$x:0000A32A                 db    0
.xdata$x:0000A32B                 db    0
.xdata$x:0000A32C                 db    0
.xdata$x:0000A32D                 db    0
.xdata$x:0000A32E                 db    0
.xdata$x:0000A32F                 db    0
.xdata$x:0000A330                 db    1
.xdata$x:0000A331                 db    0
.xdata$x:0000A332                 db    0
.xdata$x:0000A333                 db    0
.xdata$x:0000A334                 db    0
.xdata$x:0000A335                 db    0
.xdata$x:0000A336                 db    0
.xdata$x:0000A337                 db    0
.xdata$x:0000A337 _xdata$x        ends
.xdata$x:0000A337
.xdata$x:0000A338 ; ===========================================================================
.xdata$x:0000A338
.xdata$x:0000A338 ; Segment type: Pure data
.xdata$x:0000A338 ; Segment permissions: Read
.xdata$x:0000A338 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A338                 assume cs:_xdata$x
.xdata$x:0000A338                 ;org 0A338h
.xdata$x:0000A338 ; COMDAT (pick associative to section at 2844)
.xdata$x:0000A338 __unwindtable$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z db 0FFh
.xdata$x:0000A338                                         ; DATA XREF: .xdata$x:0000A348o
.xdata$x:0000A339                 db 0FFh
.xdata$x:0000A33A                 db 0FFh
.xdata$x:0000A33B                 db 0FFh
.xdata$x:0000A33C                 dd offset __unwindfunclet$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z$0
.xdata$x:0000A340 __ehfuncinfo$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z db  22h ; "
.xdata$x:0000A340                                         ; DATA XREF: __ehhandler$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z+11o
.xdata$x:0000A341                 db    5
.xdata$x:0000A342                 db  93h ; ô
.xdata$x:0000A343                 db  19h
.xdata$x:0000A344                 db    1
.xdata$x:0000A345                 db    0
.xdata$x:0000A346                 db    0
.xdata$x:0000A347                 db    0
.xdata$x:0000A348                 dd offset __unwindtable$??$_Equal@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.xdata$x:0000A34C                 db    0
.xdata$x:0000A34D                 db    0
.xdata$x:0000A34E                 db    0
.xdata$x:0000A34F                 db    0
.xdata$x:0000A350                 db    0
.xdata$x:0000A351                 db    0
.xdata$x:0000A352                 db    0
.xdata$x:0000A353                 db    0
.xdata$x:0000A354                 db    0
.xdata$x:0000A355                 db    0
.xdata$x:0000A356                 db    0
.xdata$x:0000A357                 db    0
.xdata$x:0000A358                 db    0
.xdata$x:0000A359                 db    0
.xdata$x:0000A35A                 db    0
.xdata$x:0000A35B                 db    0
.xdata$x:0000A35C                 db    0
.xdata$x:0000A35D                 db    0
.xdata$x:0000A35E                 db    0
.xdata$x:0000A35F                 db    0
.xdata$x:0000A360                 db    0
.xdata$x:0000A361                 db    0
.xdata$x:0000A362                 db    0
.xdata$x:0000A363                 db    0
.xdata$x:0000A363 _xdata$x        ends
.xdata$x:0000A363
.xdata$x:0000A364 ; ===========================================================================
.xdata$x:0000A364
.xdata$x:0000A364 ; Segment type: Pure data
.xdata$x:0000A364 ; Segment permissions: Read
.xdata$x:0000A364 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A364                 assume cs:_xdata$x
.xdata$x:0000A364                 ;org 0A364h
.xdata$x:0000A364 ; COMDAT (pick associative to section at 25D8)
.xdata$x:0000A364 __unwindtable$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z db 0FFh
.xdata$x:0000A364                                         ; DATA XREF: .xdata$x:0000A38Co
.xdata$x:0000A365                 db 0FFh
.xdata$x:0000A366                 db 0FFh
.xdata$x:0000A367                 db 0FFh
.xdata$x:0000A368                 dd offset __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$0
.xdata$x:0000A36C                 align 10h
.xdata$x:0000A370                 dd offset __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$1
.xdata$x:0000A374                 db    1
.xdata$x:0000A375                 db    0
.xdata$x:0000A376                 db    0
.xdata$x:0000A377                 db    0
.xdata$x:0000A378                 dd offset __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$2
.xdata$x:0000A37C                 db    2
.xdata$x:0000A37D                 db    0
.xdata$x:0000A37E                 db    0
.xdata$x:0000A37F                 db    0
.xdata$x:0000A380                 dd offset __unwindfunclet$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z$3
.xdata$x:0000A384 __ehfuncinfo$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z db  22h ; "
.xdata$x:0000A384                                         ; DATA XREF: __ehhandler$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z+11o
.xdata$x:0000A385                 db    5
.xdata$x:0000A386                 db  93h ; ô
.xdata$x:0000A387                 db  19h
.xdata$x:0000A388                 db    4
.xdata$x:0000A389                 db    0
.xdata$x:0000A38A                 db    0
.xdata$x:0000A38B                 db    0
.xdata$x:0000A38C                 dd offset __unwindtable$??$_Debug_range@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WI@Z
.xdata$x:0000A390                 db    0
.xdata$x:0000A391                 db    0
.xdata$x:0000A392                 db    0
.xdata$x:0000A393                 db    0
.xdata$x:0000A394                 db    0
.xdata$x:0000A395                 db    0
.xdata$x:0000A396                 db    0
.xdata$x:0000A397                 db    0
.xdata$x:0000A398                 db    0
.xdata$x:0000A399                 db    0
.xdata$x:0000A39A                 db    0
.xdata$x:0000A39B                 db    0
.xdata$x:0000A39C                 db    0
.xdata$x:0000A39D                 db    0
.xdata$x:0000A39E                 db    0
.xdata$x:0000A39F                 db    0
.xdata$x:0000A3A0                 db    0
.xdata$x:0000A3A1                 db    0
.xdata$x:0000A3A2                 db    0
.xdata$x:0000A3A3                 db    0
.xdata$x:0000A3A4                 db    0
.xdata$x:0000A3A5                 db    0
.xdata$x:0000A3A6                 db    0
.xdata$x:0000A3A7                 db    0
.xdata$x:0000A3A7 _xdata$x        ends
.xdata$x:0000A3A7
.xdata$x:0000A3A8 ; ===========================================================================
.xdata$x:0000A3A8
.xdata$x:0000A3A8 ; Segment type: Pure data
.xdata$x:0000A3A8 ; Segment permissions: Read
.xdata$x:0000A3A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A3A8                 assume cs:_xdata$x
.xdata$x:0000A3A8                 ;org 0A3A8h
.xdata$x:0000A3A8 ; COMDAT (pick associative to section at 2444)
.xdata$x:0000A3A8 __unwindtable$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db 0FFh
.xdata$x:0000A3A8                                         ; DATA XREF: .xdata$x:0000A3C0o
.xdata$x:0000A3A9                 db 0FFh
.xdata$x:0000A3AA                 db 0FFh
.xdata$x:0000A3AB                 db 0FFh
.xdata$x:0000A3AC                 dd offset __unwindfunclet$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
.xdata$x:0000A3B0                 db    0
.xdata$x:0000A3B1                 db    0
.xdata$x:0000A3B2                 db    0
.xdata$x:0000A3B3                 db    0
.xdata$x:0000A3B4                 dd offset __unwindfunclet$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
.xdata$x:0000A3B8 __ehfuncinfo$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z db  22h ; "
.xdata$x:0000A3B8                                         ; DATA XREF: __ehhandler$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z+11o
.xdata$x:0000A3B9                 db    5
.xdata$x:0000A3BA                 db  93h ; ô
.xdata$x:0000A3BB                 db  19h
.xdata$x:0000A3BC                 db    2
.xdata$x:0000A3BD                 db    0
.xdata$x:0000A3BE                 db    0
.xdata$x:0000A3BF                 db    0
.xdata$x:0000A3C0                 dd offset __unwindtable$??$_Debug_range2@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@std@@YAXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
.xdata$x:0000A3C4                 db    0
.xdata$x:0000A3C5                 db    0
.xdata$x:0000A3C6                 db    0
.xdata$x:0000A3C7                 db    0
.xdata$x:0000A3C8                 db    0
.xdata$x:0000A3C9                 db    0
.xdata$x:0000A3CA                 db    0
.xdata$x:0000A3CB                 db    0
.xdata$x:0000A3CC                 db    0
.xdata$x:0000A3CD                 db    0
.xdata$x:0000A3CE                 db    0
.xdata$x:0000A3CF                 db    0
.xdata$x:0000A3D0                 db    0
.xdata$x:0000A3D1                 db    0
.xdata$x:0000A3D2                 db    0
.xdata$x:0000A3D3                 db    0
.xdata$x:0000A3D4                 db    0
.xdata$x:0000A3D5                 db    0
.xdata$x:0000A3D6                 db    0
.xdata$x:0000A3D7                 db    0
.xdata$x:0000A3D8                 db    0
.xdata$x:0000A3D9                 db    0
.xdata$x:0000A3DA                 db    0
.xdata$x:0000A3DB                 db    0
.xdata$x:0000A3DB _xdata$x        ends
.xdata$x:0000A3DB
.xdata$x:0000A3DC ; ===========================================================================
.xdata$x:0000A3DC
.xdata$x:0000A3DC ; Segment type: Pure data
.xdata$x:0000A3DC ; Segment permissions: Read
.xdata$x:0000A3DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000A3DC                 assume cs:_xdata$x
.xdata$x:0000A3DC                 ;org 0A3DCh
.xdata$x:0000A3DC ; COMDAT (pick associative to section at 2958)
.xdata$x:0000A3DC __unwindtable$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z db 0FFh
.xdata$x:0000A3DC                                         ; DATA XREF: .xdata$x:0000A3ECo
.xdata$x:0000A3DD                 db 0FFh
.xdata$x:0000A3DE                 db 0FFh
.xdata$x:0000A3DF                 db 0FFh
.xdata$x:0000A3E0                 dd offset __unwindfunclet$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z$0
.xdata$x:0000A3E4 __ehfuncinfo$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z db  22h ; "
.xdata$x:0000A3E4                                         ; DATA XREF: __ehhandler$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z+11o
.xdata$x:0000A3E5                 db    5
.xdata$x:0000A3E6                 db  93h ; ô
.xdata$x:0000A3E7                 db  19h
.xdata$x:0000A3E8                 db    1
.xdata$x:0000A3E9                 db    0
.xdata$x:0000A3EA                 db    0
.xdata$x:0000A3EB                 db    0
.xdata$x:0000A3EC                 dd offset __unwindtable$??$_Less@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@QBE_NABV01@@Z
.xdata$x:0000A3F0                 db    0
.xdata$x:0000A3F1                 db    0
.xdata$x:0000A3F2                 db    0
.xdata$x:0000A3F3                 db    0
.xdata$x:0000A3F4                 db    0
.xdata$x:0000A3F5                 db    0
.xdata$x:0000A3F6                 db    0
.xdata$x:0000A3F7                 db    0
.xdata$x:0000A3F8                 db    0
.xdata$x:0000A3F9                 db    0
.xdata$x:0000A3FA                 db    0
.xdata$x:0000A3FB                 db    0
.xdata$x:0000A3FC                 db    0
.xdata$x:0000A3FD                 db    0
.xdata$x:0000A3FE                 db    0
.xdata$x:0000A3FF                 db    0
.xdata$x:0000A400                 db    0
.xdata$x:0000A401                 db    0
.xdata$x:0000A402                 db    0
.xdata$x:0000A403                 db    0
.xdata$x:0000A404                 db    0
.xdata$x:0000A405                 db    0
.xdata$x:0000A406                 db    0
.xdata$x:0000A407                 db    0
.xdata$x:0000A407 _xdata$x        ends
.xdata$x:0000A407
.bss:0000A408 ; ===========================================================================
.bss:0000A408
.bss:0000A408 ; Segment type: Uninitialized
.bss:0000A408 ; Segment permissions: Read/Write
.bss:0000A408 _bss            segment byte public 'BSS' use32
.bss:0000A408                 assume cs:_bss
.bss:0000A408                 ;org 0A408h
.bss:0000A408                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A408 __Tuple_alloc   db    ? ;
.bss:0000A409 ; std::_Ignore ignore
.bss:0000A409 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:0000A40A _allocator_arg  db    ? ;
.bss:0000A40B _piecewise_construct db    ? ;
.bss:0000A40B _bss            ends
.bss:0000A40B
.rdata:0000A40C ; ===========================================================================
.rdata:0000A40C
.rdata:0000A40C ; Segment type: Pure data
.rdata:0000A40C ; Segment permissions: Read
.rdata:0000A40C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A40C _rdata          segment para public 'DATA' use32
.rdata:0000A40C                 assume cs:_rdata
.rdata:0000A40C                 ;org 0A40Ch
.rdata:0000A40C ; COMDAT (pick any)
.rdata:0000A40C                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A40C ; wchar_t `string'
.rdata:0000A40C ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A40C                                         ; DATA XREF: std::_Distance2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int &,std::random_access_iterator_tag)+45o
.rdata:0000A40C                                         ; std::_Distance2<std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int>(std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,std::move_iterator<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<uchar>>>>,int &,std::random_access_iterator_tag)+5Bo ...
.rdata:0000A40C                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A40C                 unicode 0, <clude\xutility>,0
.rdata:0000A40C _rdata          ends
.rdata:0000A40C
.rdata:0000A49C ; ===========================================================================
.rdata:0000A49C
.rdata:0000A49C ; Segment type: Pure data
.rdata:0000A49C ; Segment permissions: Read
.rdata:0000A49C _rdata          segment dword public 'DATA' use32
.rdata:0000A49C                 assume cs:_rdata
.rdata:0000A49C                 ;org 0A49Ch
.rdata:0000A49C ; COMDAT (pick any)
.rdata:0000A49C                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:0000A49C ; wchar_t `string'
.rdata:0000A49C ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:0000A49C                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:0000A49C                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:0000A4CE                 align 10h
.rdata:0000A4CE _rdata          ends
.rdata:0000A4CE
.rdata:0000A4D0 ; ===========================================================================
.rdata:0000A4D0
.rdata:0000A4D0 ; Segment type: Pure data
.rdata:0000A4D0 ; Segment permissions: Read
.rdata:0000A4D0 _rdata          segment dword public 'DATA' use32
.rdata:0000A4D0                 assume cs:_rdata
.rdata:0000A4D0                 ;org 0A4D0h
.rdata:0000A4D0 ; COMDAT (pick largest)
.rdata:0000A4D0                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:0000A4D4                 public ??_7error_category@std@@6B@
.rdata:0000A4D4 ; const std::error_category::`vftable'
.rdata:0000A4D4 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:0000A4D4                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:0000A4D4                                         ; std::error_category::~error_category(void)+Ao
.rdata:0000A4D4                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:0000A4D8                 dd offset __purecall
.rdata:0000A4DC                 dd offset __purecall
.rdata:0000A4E0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000A4E4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A4E8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A4E8 _rdata          ends
.rdata:0000A4E8
.rdata:0000A4EC ; ===========================================================================
.rdata:0000A4EC
.rdata:0000A4EC ; Segment type: Pure data
.rdata:0000A4EC ; Segment permissions: Read
.rdata:0000A4EC _rdata          segment dword public 'DATA' use32
.rdata:0000A4EC                 assume cs:_rdata
.rdata:0000A4EC                 ;org 0A4ECh
.rdata:0000A4EC ; COMDAT (pick largest)
.rdata:0000A4EC                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000A4F0                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000A4F0 ; const std::_Generic_error_category::`vftable'
.rdata:0000A4F0 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000A4F0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000A4F0                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:0000A4F4                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:0000A4F8                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:0000A4FC                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000A500                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A504                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A504 _rdata          ends
.rdata:0000A504
.rdata:0000A508 ; ===========================================================================
.rdata:0000A508
.rdata:0000A508 ; Segment type: Pure data
.rdata:0000A508 ; Segment permissions: Read
.rdata:0000A508 _rdata          segment dword public 'DATA' use32
.rdata:0000A508                 assume cs:_rdata
.rdata:0000A508                 ;org 0A508h
.rdata:0000A508 ; COMDAT (pick any)
.rdata:0000A508                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:0000A508 ; `string'
.rdata:0000A508 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:0000A508                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:0000A508 _rdata          ends
.rdata:0000A508
.rdata:0000A510 ; ===========================================================================
.rdata:0000A510
.rdata:0000A510 ; Segment type: Pure data
.rdata:0000A510 ; Segment permissions: Read
.rdata:0000A510 _rdata          segment dword public 'DATA' use32
.rdata:0000A510                 assume cs:_rdata
.rdata:0000A510                 ;org 0A510h
.rdata:0000A510 ; COMDAT (pick any)
.rdata:0000A510                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000A510 ; `string'
.rdata:0000A510 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000A510                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_89DCo
.rdata:0000A510                                         ; std::_System_error_category::message(int):loc_8B58o
.rdata:0000A51E                 align 10h
.rdata:0000A51E _rdata          ends
.rdata:0000A51E
.rdata:0000A520 ; ===========================================================================
.rdata:0000A520
.rdata:0000A520 ; Segment type: Pure data
.rdata:0000A520 ; Segment permissions: Read
.rdata:0000A520 _rdata          segment dword public 'DATA' use32
.rdata:0000A520                 assume cs:_rdata
.rdata:0000A520                 ;org 0A520h
.rdata:0000A520 ; COMDAT (pick largest)
.rdata:0000A520                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:0000A524                 public ??_7_Iostream_error_category@std@@6B@
.rdata:0000A524 ; const std::_Iostream_error_category::`vftable'
.rdata:0000A524 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:0000A524                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:0000A524                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:0000A528                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:0000A52C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000A530                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000A534                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A538                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A538 _rdata          ends
.rdata:0000A538
.rdata:0000A53C ; ===========================================================================
.rdata:0000A53C
.rdata:0000A53C ; Segment type: Pure data
.rdata:0000A53C ; Segment permissions: Read
.rdata:0000A53C _rdata          segment dword public 'DATA' use32
.rdata:0000A53C                 assume cs:_rdata
.rdata:0000A53C                 ;org 0A53Ch
.rdata:0000A53C ; COMDAT (pick any)
.rdata:0000A53C                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:0000A53C ; `string'
.rdata:0000A53C ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:0000A53C                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:0000A545                 align 4
.rdata:0000A545 _rdata          ends
.rdata:0000A545
.rdata:0000A548 ; ===========================================================================
.rdata:0000A548
.rdata:0000A548 ; Segment type: Pure data
.rdata:0000A548 ; Segment permissions: Read
.rdata:0000A548 _rdata          segment dword public 'DATA' use32
.rdata:0000A548                 assume cs:_rdata
.rdata:0000A548                 ;org 0A548h
.rdata:0000A548 ; COMDAT (pick any)
.rdata:0000A548                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:0000A548 ; char `string'[]
.rdata:0000A548 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:0000A548                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000A55E                 align 10h
.rdata:0000A55E _rdata          ends
.rdata:0000A55E
.rdata:0000A560 ; ===========================================================================
.rdata:0000A560
.rdata:0000A560 ; Segment type: Pure data
.rdata:0000A560 ; Segment permissions: Read
.rdata:0000A560 _rdata          segment dword public 'DATA' use32
.rdata:0000A560                 assume cs:_rdata
.rdata:0000A560                 ;org 0A560h
.rdata:0000A560 ; COMDAT (pick largest)
.rdata:0000A560                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:0000A564                 public ??_7_System_error_category@std@@6B@
.rdata:0000A564 ; const std::_System_error_category::`vftable'
.rdata:0000A564 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:0000A564                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:0000A564                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:0000A568                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:0000A56C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000A570                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:0000A574                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:0000A578                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:0000A578 _rdata          ends
.rdata:0000A578
.rdata:0000A57C ; ===========================================================================
.rdata:0000A57C
.rdata:0000A57C ; Segment type: Pure data
.rdata:0000A57C ; Segment permissions: Read
.rdata:0000A57C _rdata          segment dword public 'DATA' use32
.rdata:0000A57C                 assume cs:_rdata
.rdata:0000A57C                 ;org 0A57Ch
.rdata:0000A57C ; COMDAT (pick any)
.rdata:0000A57C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:0000A57C ; `string'
.rdata:0000A57C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:0000A57C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:0000A583                 align 4
.rdata:0000A583 _rdata          ends
.rdata:0000A583
.bss:0000A584 ; ===========================================================================
.bss:0000A584
.bss:0000A584 ; Segment type: Uninitialized
.bss:0000A584 ; Segment permissions: Read/Write
.bss:0000A584 _bss            segment dword public 'BSS' use32
.bss:0000A584                 assume cs:_bss
.bss:0000A584                 ;org 0A584h
.bss:0000A584 ; COMDAT (pick any)
.bss:0000A584                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A584                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:0000A584 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:0000A584 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:0000A584                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:0000A584                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:0000A585                 db    ? ;
.bss:0000A586                 db    ? ;
.bss:0000A587                 db    ? ;
.bss:0000A587 _bss            ends
.bss:0000A587
.bss:0000A588 ; ===========================================================================
.bss:0000A588
.bss:0000A588 ; Segment type: Uninitialized
.bss:0000A588 ; Segment permissions: Read/Write
.bss:0000A588 _bss            segment dword public 'BSS' use32
.bss:0000A588                 assume cs:_bss
.bss:0000A588                 ;org 0A588h
.bss:0000A588 ; COMDAT (pick any)
.bss:0000A588                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A588                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:0000A588 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:0000A588 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:0000A588                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000A588                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:0000A589                 db    ? ;
.bss:0000A58A                 db    ? ;
.bss:0000A58B                 db    ? ;
.bss:0000A58B _bss            ends
.bss:0000A58B
.bss:0000A58C ; ===========================================================================
.bss:0000A58C
.bss:0000A58C ; Segment type: Uninitialized
.bss:0000A58C ; Segment permissions: Read/Write
.bss:0000A58C _bss            segment dword public 'BSS' use32
.bss:0000A58C                 assume cs:_bss
.bss:0000A58C                 ;org 0A58Ch
.bss:0000A58C ; COMDAT (pick any)
.bss:0000A58C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A58C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:0000A58C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:0000A58C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:0000A58C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:0000A58C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:0000A58D                 db    ? ;
.bss:0000A58E                 db    ? ;
.bss:0000A58F                 db    ? ;
.bss:0000A58F _bss            ends
.bss:0000A58F
.bss:0000A590 ; ===========================================================================
.bss:0000A590
.bss:0000A590 ; Segment type: Uninitialized
.bss:0000A590 ; Segment permissions: Read/Write
.bss:0000A590 _bss            segment dword public 'BSS' use32
.bss:0000A590                 assume cs:_bss
.bss:0000A590                 ;org 0A590h
.bss:0000A590 ; COMDAT (pick any)
.bss:0000A590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A590                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000A590 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:0000A590 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000A590                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:0000A591                 db    ? ;
.bss:0000A592                 db    ? ;
.bss:0000A593                 db    ? ;
.bss:0000A593 _bss            ends
.bss:0000A593
.bss:0000A594 ; ===========================================================================
.bss:0000A594
.bss:0000A594 ; Segment type: Uninitialized
.bss:0000A594 ; Segment permissions: Read/Write
.bss:0000A594 _bss            segment dword public 'BSS' use32
.bss:0000A594                 assume cs:_bss
.bss:0000A594                 ;org 0A594h
.bss:0000A594 ; COMDAT (pick any)
.bss:0000A594                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A594                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:0000A594 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:0000A594 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:0000A594                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:0000A595                 db    ? ;
.bss:0000A596                 db    ? ;
.bss:0000A597                 db    ? ;
.bss:0000A597 _bss            ends
.bss:0000A597
.rdata:0000A598 ; ===========================================================================
.rdata:0000A598
.rdata:0000A598 ; Segment type: Pure data
.rdata:0000A598 ; Segment permissions: Read
.rdata:0000A598 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A598 _rdata          segment para public 'DATA' use32
.rdata:0000A598                 assume cs:_rdata
.rdata:0000A598                 ;org 0A598h
.rdata:0000A598 ; COMDAT (pick any)
.rdata:0000A598                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A598 ; wchar_t `string'
.rdata:0000A598 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A598                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:0000A598                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:0000A598                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A598                 unicode 0, <clude\xstring>,0
.rdata:0000A626                 align 4
.rdata:0000A626 _rdata          ends
.rdata:0000A626
.bss:0000A628 ; ===========================================================================
.bss:0000A628
.bss:0000A628 ; Segment type: Uninitialized
.bss:0000A628 ; Segment permissions: Read/Write
.bss:0000A628 _bss            segment dword public 'BSS' use32
.bss:0000A628                 assume cs:_bss
.bss:0000A628                 ;org 0A628h
.bss:0000A628 ; COMDAT (pick any)
.bss:0000A628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A628                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:0000A628 ; std::locale::id std::numpunct<char>::id
.bss:0000A628 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:0000A628                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:0000A629                 db    ? ;
.bss:0000A62A                 db    ? ;
.bss:0000A62B                 db    ? ;
.bss:0000A62B _bss            ends
.bss:0000A62B
.bss:0000A62C ; ===========================================================================
.bss:0000A62C
.bss:0000A62C ; Segment type: Uninitialized
.bss:0000A62C ; Segment permissions: Read/Write
.bss:0000A62C _bss            segment dword public 'BSS' use32
.bss:0000A62C                 assume cs:_bss
.bss:0000A62C                 ;org 0A62Ch
.bss:0000A62C ; COMDAT (pick any)
.bss:0000A62C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:0000A62C                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:0000A62C ; std::locale::id std::numpunct<wchar_t>::id
.bss:0000A62C ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:0000A62C                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:0000A62D                 db    ? ;
.bss:0000A62E                 db    ? ;
.bss:0000A62F                 db    ? ;
.bss:0000A62F _bss            ends
.bss:0000A62F
.rdata:0000A630 ; ===========================================================================
.rdata:0000A630
.rdata:0000A630 ; Segment type: Pure data
.rdata:0000A630 ; Segment permissions: Read
.rdata:0000A630 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A630 _rdata          segment para public 'DATA' use32
.rdata:0000A630                 assume cs:_rdata
.rdata:0000A630                 ;org 0A630h
.rdata:0000A630 ; COMDAT (pick any)
.rdata:0000A630                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000A630 ; wchar_t `string'
.rdata:0000A630 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000A630                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+19o
.rdata:0000A630                                         ; std::vector<uchar,std::allocator<uchar>>::operator[](uint)+49o ...
.rdata:0000A630                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000A630                 unicode 0, <clude\vector>,0
.rdata:0000A630 _rdata          ends
.rdata:0000A630
.rdata:0000A6BC ; ===========================================================================
.rdata:0000A6BC
.rdata:0000A6BC ; Segment type: Pure data
.rdata:0000A6BC ; Segment permissions: Read
.rdata:0000A6BC _rdata          segment dword public 'DATA' use32
.rdata:0000A6BC                 assume cs:_rdata
.rdata:0000A6BC                 ;org 0A6BCh
.rdata:0000A6BC ; COMDAT (pick any)
.rdata:0000A6BC                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000A6BC ; wchar_t `string'
.rdata:0000A6BC ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000A6BC                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+1Eo
.rdata:0000A6BC                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+1Eo
.rdata:0000A6BC                 unicode 0, <vector subscript out of range>,0
.rdata:0000A6BC _rdata          ends
.rdata:0000A6BC
.rdata:0000A6F8 ; ===========================================================================
.rdata:0000A6F8
.rdata:0000A6F8 ; Segment type: Pure data
.rdata:0000A6F8 ; Segment permissions: Read
.rdata:0000A6F8 _rdata          segment dword public 'DATA' use32
.rdata:0000A6F8                 assume cs:_rdata
.rdata:0000A6F8                 ;org 0A6F8h
.rdata:0000A6F8 ; COMDAT (pick any)
.rdata:0000A6F8                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:0000A6F8 ; `string'
.rdata:0000A6F8 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:0000A6F8                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+2Bo
.rdata:0000A6F8                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+2Bo ...
.rdata:0000A6F8 _rdata          ends
.rdata:0000A6F8
.rdata:0000A71C ; ===========================================================================
.rdata:0000A71C
.rdata:0000A71C ; Segment type: Pure data
.rdata:0000A71C ; Segment permissions: Read
.rdata:0000A71C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A71C _rdata          segment para public 'DATA' use32
.rdata:0000A71C                 assume cs:_rdata
.rdata:0000A71C                 ;org 0A71Ch
.rdata:0000A71C ; COMDAT (pick any)
.rdata:0000A71C                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:0000A71C ; `string'
.rdata:0000A71C ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:0000A71C                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint):loc_5CF0o
.rdata:0000A71C                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint):loc_5D7Co ...
.rdata:0000A71C                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:0000A772                 align 4
.rdata:0000A772 _rdata          ends
.rdata:0000A772
.rdata:0000A774 ; ===========================================================================
.rdata:0000A774
.rdata:0000A774 ; Segment type: Pure data
.rdata:0000A774 ; Segment permissions: Read
.rdata:0000A774 _rdata          segment dword public 'DATA' use32
.rdata:0000A774                 assume cs:_rdata
.rdata:0000A774                 ;org 0A774h
.rdata:0000A774 ; COMDAT (pick any)
.rdata:0000A774                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:0000A774 ; `string'
.rdata:0000A774 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:0000A774                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+3Do
.rdata:0000A774                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+3Do ...
.rdata:0000A774                 unicode 0, <%s>,0
.rdata:0000A77A                 align 4
.rdata:0000A77A _rdata          ends
.rdata:0000A77A
.rdata:0000A77C ; ===========================================================================
.rdata:0000A77C
.rdata:0000A77C ; Segment type: Pure data
.rdata:0000A77C ; Segment permissions: Read
.rdata:0000A77C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A77C _rdata          segment para public 'DATA' use32
.rdata:0000A77C                 assume cs:_rdata
.rdata:0000A77C                 ;org 0A77Ch
.rdata:0000A77C ; COMDAT (pick any)
.rdata:0000A77C                 public ??_C@_1BHM@GCCEGIDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn@
.rdata:0000A77C ; `string'
.rdata:0000A77C ??_C@_1BHM@GCCEGIDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn@:
.rdata:0000A77C                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+6Ao
.rdata:0000A77C                 unicode 0, <std::vector>
.rdata:0000A77C                 dw 3Ch
.rdata:0000A77C                 unicode 0, <class std::vector>
.rdata:0000A77C                 dw 3Ch
.rdata:0000A77C                 unicode 0, <unsigned char,class std::allocator>
.rdata:0000A77C                 dw 3Ch
.rdata:0000A77C                 unicode 0, <unsigned char>
.rdata:0000A77C                 dw 3Eh
.rdata:0000A77C                 unicode 0, < >
.rdata:0000A77C                 dw 3Eh
.rdata:0000A77C                 unicode 0, <,class std::allocator>
.rdata:0000A77C                 dw 3Ch
.rdata:0000A77C                 unicode 0, <class std::vector>
.rdata:0000A77C                 dw 3Ch
.rdata:0000A77C                 unicode 0, <unsigned char,class std::allocator>
.rdata:0000A77C                 dw 3Ch
.rdata:0000A77C                 unicode 0, <unsigned char>
.rdata:0000A77C                 dw 3Eh
.rdata:0000A77C                 unicode 0, < >
.rdata:0000A77C                 dw 3Eh
.rdata:0000A77C                 unicode 0, < >
.rdata:0000A77C                 dw 3Eh
.rdata:0000A77C                 unicode 0, < >
.rdata:0000A77C                 dw 3Eh
.rdata:0000A77C                 unicode 0, <::operator []>,0
.rdata:0000A77C _rdata          ends
.rdata:0000A77C
.rdata:0000A8F8 ; ===========================================================================
.rdata:0000A8F8
.rdata:0000A8F8 ; Segment type: Pure data
.rdata:0000A8F8 ; Segment permissions: Read
.rdata:0000A8F8 _rdata          segment dword public 'DATA' use32
.rdata:0000A8F8                 assume cs:_rdata
.rdata:0000A8F8                 ;org 0A8F8h
.rdata:0000A8F8 ; COMDAT (pick any)
.rdata:0000A8F8                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:0000A8F8 ; `string'
.rdata:0000A8F8 ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:0000A8F8                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+6Fo
.rdata:0000A8F8                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+6Fo ...
.rdata:0000A8F8                 unicode 0, <"out of range">,0
.rdata:0000A916                 align 4
.rdata:0000A916 _rdata          ends
.rdata:0000A916
.rdata:0000A918 ; ===========================================================================
.rdata:0000A918
.rdata:0000A918 ; Segment type: Pure data
.rdata:0000A918 ; Segment permissions: Read
.rdata:0000A918 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A918 _rdata          segment para public 'DATA' use32
.rdata:0000A918                 assume cs:_rdata
.rdata:0000A918                 ;org 0A918h
.rdata:0000A918 ; COMDAT (pick any)
.rdata:0000A918                 public ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
.rdata:0000A918 ; wchar_t `string'
.rdata:0000A918 ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@:
.rdata:0000A918                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::erase(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>)+63o
.rdata:0000A918                 unicode 0, <vector erase iterator outside range>,0
.rdata:0000A918 _rdata          ends
.rdata:0000A918
.rdata:0000A960 ; ===========================================================================
.rdata:0000A960
.rdata:0000A960 ; Segment type: Pure data
.rdata:0000A960 ; Segment permissions: Read
.rdata:0000A960 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A960 _rdata          segment para public 'DATA' use32
.rdata:0000A960                 assume cs:_rdata
.rdata:0000A960                 ;org 0A960h
.rdata:0000A960 ; COMDAT (pick any)
.rdata:0000A960                 public ??_C@_1JK@PKCFAHNP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAr?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@
.rdata:0000A960 ; `string'
.rdata:0000A960 ??_C@_1JK@PKCFAHNP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs?$AAi?$AAg?$AAn?$AAe?$AAd?$AA?5?$AAc?$AAh?$AAa?$AAr?$AA?0?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5@:
.rdata:0000A960                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+6Ao
.rdata:0000A960                 unicode 0, <std::vector>
.rdata:0000A960                 dw 3Ch
.rdata:0000A960                 unicode 0, <unsigned char,class std::allocator>
.rdata:0000A960                 dw 3Ch
.rdata:0000A960                 unicode 0, <unsigned char>
.rdata:0000A960                 dw 3Eh
.rdata:0000A960                 unicode 0, < >
.rdata:0000A960                 dw 3Eh
.rdata:0000A960                 unicode 0, <::operator []>,0
.rdata:0000A9FA                 align 4
.rdata:0000A9FA _rdata          ends
.rdata:0000A9FA
.rdata:0000A9FC ; ===========================================================================
.rdata:0000A9FC
.rdata:0000A9FC ; Segment type: Pure data
.rdata:0000A9FC ; Segment permissions: Read
.rdata:0000A9FC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000A9FC _rdata          segment para public 'DATA' use32
.rdata:0000A9FC                 assume cs:_rdata
.rdata:0000A9FC                 ;org 0A9FCh
.rdata:0000A9FC ; COMDAT (pick any)
.rdata:0000A9FC                 public ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@
.rdata:0000A9FC ; wchar_t `string'
.rdata:0000A9FC ??_C@_1EK@EEHFMKDC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAn?$AAs?$AAe?$AAr?$AAt?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr@:
.rdata:0000A9FC                                         ; DATA XREF: std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Insert_n(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>,uint,std::vector<uchar,std::allocator<uchar>> const &)+6Ao
.rdata:0000A9FC                 unicode 0, <vector insert iterator outside range>,0
.rdata:0000AA46                 align 4
.rdata:0000AA46 _rdata          ends
.rdata:0000AA46
.rdata:0000AA48 ; ===========================================================================
.rdata:0000AA48
.rdata:0000AA48 ; Segment type: Pure data
.rdata:0000AA48 ; Segment permissions: Read
.rdata:0000AA48 _rdata          segment dword public 'DATA' use32
.rdata:0000AA48                 assume cs:_rdata
.rdata:0000AA48                 ;org 0AA48h
.rdata:0000AA48 ; COMDAT (pick any)
.rdata:0000AA48                 public ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
.rdata:0000AA48 ; `string'
.rdata:0000AA48 ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ db 'Standard C++ Libraries Invalid Argument',0
.rdata:0000AA48                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+41o
.rdata:0000AA48 _rdata          ends
.rdata:0000AA48
.rdata:0000AA70 ; ===========================================================================
.rdata:0000AA70
.rdata:0000AA70 ; Segment type: Pure data
.rdata:0000AA70 ; Segment permissions: Read
.rdata:0000AA70 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AA70 _rdata          segment para public 'DATA' use32
.rdata:0000AA70                 assume cs:_rdata
.rdata:0000AA70                 ;org 0AA70h
.rdata:0000AA70 ; COMDAT (pick any)
.rdata:0000AA70                 public ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
.rdata:0000AA70 ; `string'
.rdata:0000AA70 ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@:
.rdata:0000AA70                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &):loc_67FAo
.rdata:0000AA70                 unicode 0, <"Standard C++ Libraries Invalid Argument" && 0>,0
.rdata:0000AACE                 align 10h
.rdata:0000AACE _rdata          ends
.rdata:0000AACE
.rdata:0000AAD0 ; ===========================================================================
.rdata:0000AAD0
.rdata:0000AAD0 ; Segment type: Pure data
.rdata:0000AAD0 ; Segment permissions: Read
.rdata:0000AAD0 _rdata          segment dword public 'DATA' use32
.rdata:0000AAD0                 assume cs:_rdata
.rdata:0000AAD0                 ;org 0AAD0h
.rdata:0000AAD0 ; COMDAT (pick any)
.rdata:0000AAD0                 public ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
.rdata:0000AAD0 ; `string'
.rdata:0000AAD0 ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@:
.rdata:0000AAD0                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+85o
.rdata:0000AAD0                 unicode 0, <"invalid argument">,0
.rdata:0000AAF6                 align 4
.rdata:0000AAF6 _rdata          ends
.rdata:0000AAF6
.rdata:0000AAF8 ; ===========================================================================
.rdata:0000AAF8
.rdata:0000AAF8 ; Segment type: Pure data
.rdata:0000AAF8 ; Segment permissions: Read
.rdata:0000AAF8 _rdata          segment dword public 'DATA' use32
.rdata:0000AAF8                 assume cs:_rdata
.rdata:0000AAF8                 ;org 0AAF8h
.rdata:0000AAF8 ; COMDAT (pick any)
.rdata:0000AAF8                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000AAF8 ; char `string'[]
.rdata:0000AAF8 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000AAF8                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000AAF8 _rdata          ends
.rdata:0000AAF8
.rdata:0000AB08 ; ===========================================================================
.rdata:0000AB08
.rdata:0000AB08 ; Segment type: Pure data
.rdata:0000AB08 ; Segment permissions: Read
.rdata:0000AB08 _rdata          segment dword public 'DATA' use32
.rdata:0000AB08                 assume cs:_rdata
.rdata:0000AB08                 ;org 0AB08h
.rdata:0000AB08 ; COMDAT (pick any)
.rdata:0000AB08                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000AB08 ; char `string'[]
.rdata:0000AB08 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000AB08                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000AB08 _rdata          ends
.rdata:0000AB08
.rdata:0000AB20 ; ===========================================================================
.rdata:0000AB20
.rdata:0000AB20 ; Segment type: Pure data
.rdata:0000AB20 ; Segment permissions: Read
.rdata:0000AB20 _rdata          segment dword public 'DATA' use32
.rdata:0000AB20                 assume cs:_rdata
.rdata:0000AB20                 ;org 0AB20h
.rdata:0000AB20 ; COMDAT (pick any)
.rdata:0000AB20                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:0000AB20 ; char `string'[]
.rdata:0000AB20 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:0000AB20                                         ; DATA XREF: std::vector<uchar,std::allocator<uchar>>::_Xlen(void)+7o
.rdata:0000AB20                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::_Xlen(void)+7o
.rdata:0000AB33                 align 4
.rdata:0000AB33 _rdata          ends
.rdata:0000AB33
.rdata:0000AB34 ; ===========================================================================
.rdata:0000AB34
.rdata:0000AB34 ; Segment type: Pure data
.rdata:0000AB34 ; Segment permissions: Read
.rdata:0000AB34 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AB34 _rdata          segment para public 'DATA' use32
.rdata:0000AB34                 assume cs:_rdata
.rdata:0000AB34                 ;org 0AB34h
.rdata:0000AB34 ; COMDAT (pick any)
.rdata:0000AB34                 public ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@
.rdata:0000AB34 ; wchar_t `string'
.rdata:0000AB34 ??_C@_1EM@FKAOCOMF@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AA?$CL?$AA?5?$AAo?$AAf?$AAf?$AAs?$AAe?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5@:
.rdata:0000AB34                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+50o
.rdata:0000AB34                 unicode 0, <vector iterator + offset out of range>,0
.rdata:0000AB34 _rdata          ends
.rdata:0000AB34
.rdata:0000AB80 ; ===========================================================================
.rdata:0000AB80
.rdata:0000AB80 ; Segment type: Pure data
.rdata:0000AB80 ; Segment permissions: Read
.rdata:0000AB80 _rdata          segment dword public 'DATA' use32
.rdata:0000AB80                 assume cs:_rdata
.rdata:0000AB80                 ;org 0AB80h
.rdata:0000AB80 ; COMDAT (pick any)
.rdata:0000AB80                 public ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
.rdata:0000AB80 ; wchar_t `string'
.rdata:0000AB80 ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@:
.rdata:0000AB80                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+34o
.rdata:0000AB80                 unicode 0, <vector iterators incompatible>,0
.rdata:0000AB80 _rdata          ends
.rdata:0000AB80
.rdata:0000ABBC ; ===========================================================================
.rdata:0000ABBC
.rdata:0000ABBC ; Segment type: Pure data
.rdata:0000ABBC ; Segment permissions: Read
.rdata:0000ABBC ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000ABBC _rdata          segment para public 'DATA' use32
.rdata:0000ABBC                 assume cs:_rdata
.rdata:0000ABBC                 ;org 0ABBCh
.rdata:0000ABBC ; COMDAT (pick any)
.rdata:0000ABBC                 public ??_C@_1BEM@BNCMPMLI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000ABBC ; `string'
.rdata:0000ABBC ??_C@_1BEM@BNCMPMLI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000ABBC                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::vector<uchar,std::allocator<uchar>>>>>::operator+=(int)+9Co
.rdata:0000ABBC                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000ABBC                 dw 3Ch
.rdata:0000ABBC                 unicode 0, <class std::_Vector_val>
.rdata:0000ABBC                 dw 3Ch
.rdata:0000ABBC                 unicode 0, <struct std::_Simple_types>
.rdata:0000ABBC                 dw 3Ch
.rdata:0000ABBC                 unicode 0, <class std::vector>
.rdata:0000ABBC                 dw 3Ch
.rdata:0000ABBC                 unicode 0, <unsigned char,class std::allocator>
.rdata:0000ABBC                 dw 3Ch
.rdata:0000ABBC                 unicode 0, <unsigned char>
.rdata:0000ABBC                 dw 3Eh
.rdata:0000ABBC                 unicode 0, < >
.rdata:0000ABBC                 dw 3Eh
.rdata:0000ABBC                 unicode 0, < >
.rdata:0000ABBC                 dw 3Eh
.rdata:0000ABBC                 unicode 0, < >
.rdata:0000ABBC                 dw 3Eh
.rdata:0000ABBC                 unicode 0, < >
.rdata:0000ABBC                 dw 3Eh
.rdata:0000ABBC                 unicode 0, <::operator +=>,0
.rdata:0000ABBC _rdata          ends
.rdata:0000ABBC
.rdata:0000AD08 ; ===========================================================================
.rdata:0000AD08
.rdata:0000AD08 ; Segment type: Pure data
.rdata:0000AD08 ; Segment permissions: Read
.rdata:0000AD08 _rdata          segment dword public 'DATA' use32
.rdata:0000AD08                 assume cs:_rdata
.rdata:0000AD08                 ;org 0AD08h
.rdata:0000AD08 ; COMDAT (pick any)
.rdata:0000AD08                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:0000AD08 ; wchar_t `string'
.rdata:0000AD08 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:0000AD08                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:0000AD08                                         ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)+11o ...
.rdata:0000AD08                 unicode 0, <invalid null pointer>,0
.rdata:0000AD32                 align 4
.rdata:0000AD32 _rdata          ends
.rdata:0000AD32
.rdata:0000AD34 ; ===========================================================================
.rdata:0000AD34
.rdata:0000AD34 ; Segment type: Pure data
.rdata:0000AD34 ; Segment permissions: Read
.rdata:0000AD34 _rdata          segment dword public 'DATA' use32
.rdata:0000AD34                 assume cs:_rdata
.rdata:0000AD34                 ;org 0AD34h
.rdata:0000AD34 ; COMDAT (pick any)
.rdata:0000AD34                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:0000AD34 ; wchar_t `string'
.rdata:0000AD34 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:0000AD34                                         ; DATA XREF: std::_Debug_range2<uchar *>(uchar *,uchar *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:0000AD34                                         ; std::_Debug_range2<std::vector<uchar,std::allocator<uchar>> *>(std::vector<uchar,std::allocator<uchar>> *,std::vector<uchar,std::allocator<uchar>> *,wchar_t const *,uint,std::random_access_iterator_tag)+43o ...
.rdata:0000AD34                 unicode 0, <invalid iterator range>,0
.rdata:0000AD62                 align 4
.rdata:0000AD62 _rdata          ends
.rdata:0000AD62
.rdata:0000AD64 ; ===========================================================================
.rdata:0000AD64
.rdata:0000AD64 ; Segment type: Pure data
.rdata:0000AD64 ; Segment permissions: Read
.rdata:0000AD64 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AD64 _rdata          segment para public 'DATA' use32
.rdata:0000AD64                 assume cs:_rdata
.rdata:0000AD64                 ;org 0AD64h
.rdata:0000AD64 ; COMDAT (pick any)
.rdata:0000AD64                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:0000AD64 ; wchar_t `string'
.rdata:0000AD64 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:0000AD64                                         ; DATA XREF: std::_Uninit_copy<uchar const,uchar>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:0000AD64                                         ; std::_Uninit_copy<uchar const,uchar>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)+23o ...
.rdata:0000AD64                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:0000AD64                 unicode 0, <clude\xmemory>,0
.rdata:0000ADF2                 align 4
.rdata:0000ADF2 _rdata          ends
.rdata:0000ADF2
.rdata:0000ADF4 ; ===========================================================================
.rdata:0000ADF4
.rdata:0000ADF4 ; Segment type: Pure data
.rdata:0000ADF4 ; Segment permissions: Read
.rdata:0000ADF4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000ADF4 _rdata          segment para public 'DATA' use32
.rdata:0000ADF4                 assume cs:_rdata
.rdata:0000ADF4                 ;org 0ADF4h
.rdata:0000ADF4 ; COMDAT (pick any)
.rdata:0000ADF4                 public ??_C@_1NC@EDCKMCKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000ADF4 ; `string'
.rdata:0000ADF4 ??_C@_1NC@EDCKMCKF@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000ADF4                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::_Compat(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>> const &)+80o
.rdata:0000ADF4                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000ADF4                 dw 3Ch
.rdata:0000ADF4                 unicode 0, <class std::_Vector_val>
.rdata:0000ADF4                 dw 3Ch
.rdata:0000ADF4                 unicode 0, <struct std::_Simple_types>
.rdata:0000ADF4                 dw 3Ch
.rdata:0000ADF4                 unicode 0, <unsigned char>
.rdata:0000ADF4                 dw 3Eh
.rdata:0000ADF4                 unicode 0, < >
.rdata:0000ADF4                 dw 3Eh
.rdata:0000ADF4                 unicode 0, < >
.rdata:0000ADF4                 dw 3Eh
.rdata:0000ADF4                 unicode 0, <::_Compat>,0
.rdata:0000AEC6                 align 4
.rdata:0000AEC6 _rdata          ends
.rdata:0000AEC6
.rdata:0000AEC8 ; ===========================================================================
.rdata:0000AEC8
.rdata:0000AEC8 ; Segment type: Pure data
.rdata:0000AEC8 ; Segment permissions: Read
.rdata:0000AEC8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AEC8 _rdata          segment para public 'DATA' use32
.rdata:0000AEC8                 assume cs:_rdata
.rdata:0000AEC8                 ;org 0AEC8h
.rdata:0000AEC8 ; COMDAT (pick any)
.rdata:0000AEC8                 public ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
.rdata:0000AEC8 ; wchar_t `string'
.rdata:0000AEC8 ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@:
.rdata:0000AEC8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+49o
.rdata:0000AEC8                 unicode 0, <vector iterator not dereferencable>,0
.rdata:0000AF0E                 align 10h
.rdata:0000AF0E _rdata          ends
.rdata:0000AF0E
.rdata:0000AF10 ; ===========================================================================
.rdata:0000AF10
.rdata:0000AF10 ; Segment type: Pure data
.rdata:0000AF10 ; Segment permissions: Read
.rdata:0000AF10 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AF10 _rdata          segment para public 'DATA' use32
.rdata:0000AF10                 assume cs:_rdata
.rdata:0000AF10                 ;org 0AF10h
.rdata:0000AF10 ; COMDAT (pick any)
.rdata:0000AF10                 public ??_C@_1NI@PPPKFEAA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000AF10 ; `string'
.rdata:0000AF10 ??_C@_1NI@PPPKFEAA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000AF10                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator*(void)+8Fo
.rdata:0000AF10                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000AF10                 dw 3Ch
.rdata:0000AF10                 unicode 0, <class std::_Vector_val>
.rdata:0000AF10                 dw 3Ch
.rdata:0000AF10                 unicode 0, <struct std::_Simple_types>
.rdata:0000AF10                 dw 3Ch
.rdata:0000AF10                 unicode 0, <unsigned char>
.rdata:0000AF10                 dw 3Eh
.rdata:0000AF10                 unicode 0, < >
.rdata:0000AF10                 dw 3Eh
.rdata:0000AF10                 unicode 0, < >
.rdata:0000AF10                 dw 3Eh
.rdata:0000AF10                 unicode 0, <::operator *>,0
.rdata:0000AF10 _rdata          ends
.rdata:0000AF10
.rdata:0000AFE8 ; ===========================================================================
.rdata:0000AFE8
.rdata:0000AFE8 ; Segment type: Pure data
.rdata:0000AFE8 ; Segment permissions: Read
.rdata:0000AFE8 ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000AFE8 _rdata          segment para public 'DATA' use32
.rdata:0000AFE8                 assume cs:_rdata
.rdata:0000AFE8                 ;org 0AFE8h
.rdata:0000AFE8 ; COMDAT (pick any)
.rdata:0000AFE8                 public ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
.rdata:0000AFE8 ; wchar_t `string'
.rdata:0000AFE8 ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@:
.rdata:0000AFE8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+36o
.rdata:0000AFE8                 unicode 0, <vector iterator not incrementable>,0
.rdata:0000AFE8 _rdata          ends
.rdata:0000AFE8
.rdata:0000B02C ; ===========================================================================
.rdata:0000B02C
.rdata:0000B02C ; Segment type: Pure data
.rdata:0000B02C ; Segment permissions: Read
.rdata:0000B02C ; Segment alignment 'qword' can not be represented in assembly
.rdata:0000B02C _rdata          segment para public 'DATA' use32
.rdata:0000B02C                 assume cs:_rdata
.rdata:0000B02C                 ;org 0B02Ch
.rdata:0000B02C ; COMDAT (pick any)
.rdata:0000B02C                 public ??_C@_1NK@NAGJJBIN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
.rdata:0000B02C ; `string'
.rdata:0000B02C ??_C@_1NK@NAGJJBIN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@:
.rdata:0000B02C                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<uchar>>>::operator++(void)+7Co
.rdata:0000B02C                 unicode 0, <std::_Vector_const_iterator>
.rdata:0000B02C                 dw 3Ch
.rdata:0000B02C                 unicode 0, <class std::_Vector_val>
.rdata:0000B02C                 dw 3Ch
.rdata:0000B02C                 unicode 0, <struct std::_Simple_types>
.rdata:0000B02C                 dw 3Ch
.rdata:0000B02C                 unicode 0, <unsigned char>
.rdata:0000B02C                 dw 3Eh
.rdata:0000B02C                 unicode 0, < >
.rdata:0000B02C                 dw 3Eh
.rdata:0000B02C                 unicode 0, < >
.rdata:0000B02C                 dw 3Eh
.rdata:0000B02C                 unicode 0, <::operator ++>,0
.rdata:0000B106                 align 4
.rdata:0000B106 _rdata          ends
.rdata:0000B106
.rdata$r:0000B108 ; ===========================================================================
.rdata$r:0000B108
.rdata$r:0000B108 ; Segment type: Pure data
.rdata$r:0000B108 ; Segment permissions: Read
.rdata$r:0000B108 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B108                 assume cs:_rdata$r
.rdata$r:0000B108                 ;org 0B108h
.rdata$r:0000B108 ; COMDAT (pick any)
.rdata$r:0000B108                 public ??_R4error_category@std@@6B@
.rdata$r:0000B108 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:0000B108 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:0000A4D0o
.rdata$r:0000B109                 db    0
.rdata$r:0000B10A                 db    0
.rdata$r:0000B10B                 db    0
.rdata$r:0000B10C                 db    0
.rdata$r:0000B10D                 db    0
.rdata$r:0000B10E                 db    0
.rdata$r:0000B10F                 db    0
.rdata$r:0000B110                 db    0
.rdata$r:0000B111                 db    0
.rdata$r:0000B112                 db    0
.rdata$r:0000B113                 db    0
.rdata$r:0000B114                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000B118                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B118 _rdata$r        ends
.rdata$r:0000B118
.data$r:0000B11C ; ===========================================================================
.data$r:0000B11C
.data$r:0000B11C ; Segment type: Pure data
.data$r:0000B11C ; Segment permissions: Read/Write
.data$r:0000B11C _data$r         segment dword public 'DATA' use32
.data$r:0000B11C                 assume cs:_data$r
.data$r:0000B11C                 ;org 0B11Ch
.data$r:0000B11C ; COMDAT (pick any)
.data$r:0000B11C                 public ??_R0?AVerror_category@std@@@8
.data$r:0000B11C ; class std::error_category `RTTI Type Descriptor'
.data$r:0000B11C ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000B11C                                         ; DATA XREF: .rdata$r:0000B114o
.data$r:0000B11C                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000B11C                                         ; const type_info::`vftable'
.data$r:0000B120                 db    0
.data$r:0000B121                 db    0
.data$r:0000B122                 db    0
.data$r:0000B123                 db    0
.data$r:0000B124                 db  2Eh ; .
.data$r:0000B125                 db  3Fh ; ?
.data$r:0000B126                 db  41h ; A
.data$r:0000B127                 db  56h ; V
.data$r:0000B128                 db  65h ; e
.data$r:0000B129                 db  72h ; r
.data$r:0000B12A                 db  72h ; r
.data$r:0000B12B                 db  6Fh ; o
.data$r:0000B12C                 db  72h ; r
.data$r:0000B12D                 db  5Fh ; _
.data$r:0000B12E                 db  63h ; c
.data$r:0000B12F                 db  61h ; a
.data$r:0000B130                 db  74h ; t
.data$r:0000B131                 db  65h ; e
.data$r:0000B132                 db  67h ; g
.data$r:0000B133                 db  6Fh ; o
.data$r:0000B134                 db  72h ; r
.data$r:0000B135                 db  79h ; y
.data$r:0000B136                 db  40h ; @
.data$r:0000B137                 db  73h ; s
.data$r:0000B138                 db  74h ; t
.data$r:0000B139                 db  64h ; d
.data$r:0000B13A                 db  40h ; @
.data$r:0000B13B                 db  40h ; @
.data$r:0000B13C                 db    0
.data$r:0000B13D                 align 10h
.data$r:0000B13D _data$r         ends
.data$r:0000B13D
.rdata$r:0000B140 ; ===========================================================================
.rdata$r:0000B140
.rdata$r:0000B140 ; Segment type: Pure data
.rdata$r:0000B140 ; Segment permissions: Read
.rdata$r:0000B140 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B140                 assume cs:_rdata$r
.rdata$r:0000B140                 ;org 0B140h
.rdata$r:0000B140 ; COMDAT (pick any)
.rdata$r:0000B140                 public ??_R3error_category@std@@8
.rdata$r:0000B140 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B140 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:0000B118o
.rdata$r:0000B140                                         ; .rdata$r:0000B170o
.rdata$r:0000B141                 db    0
.rdata$r:0000B142                 db    0
.rdata$r:0000B143                 db    0
.rdata$r:0000B144                 db    0
.rdata$r:0000B145                 db    0
.rdata$r:0000B146                 db    0
.rdata$r:0000B147                 db    0
.rdata$r:0000B148                 db    1
.rdata$r:0000B149                 db    0
.rdata$r:0000B14A                 db    0
.rdata$r:0000B14B                 db    0
.rdata$r:0000B14C                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000B14C _rdata$r        ends
.rdata$r:0000B14C
.rdata$r:0000B150 ; ===========================================================================
.rdata$r:0000B150
.rdata$r:0000B150 ; Segment type: Pure data
.rdata$r:0000B150 ; Segment permissions: Read
.rdata$r:0000B150 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B150                 assume cs:_rdata$r
.rdata$r:0000B150                 ;org 0B150h
.rdata$r:0000B150 ; COMDAT (pick any)
.rdata$r:0000B150                 public ??_R2error_category@std@@8
.rdata$r:0000B150 ; std::error_category::`RTTI Base Class Array'
.rdata$r:0000B150 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000B150                                         ; DATA XREF: .rdata$r:0000B14Co
.rdata$r:0000B150                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B154                 db    0
.rdata$r:0000B155                 align 4
.rdata$r:0000B155 _rdata$r        ends
.rdata$r:0000B155
.rdata$r:0000B158 ; ===========================================================================
.rdata$r:0000B158
.rdata$r:0000B158 ; Segment type: Pure data
.rdata$r:0000B158 ; Segment permissions: Read
.rdata$r:0000B158 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B158                 assume cs:_rdata$r
.rdata$r:0000B158                 ;org 0B158h
.rdata$r:0000B158 ; COMDAT (pick any)
.rdata$r:0000B158                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:0000B158 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B158 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:0000B158                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:0000B158                                         ; .rdata$r:0000B1C8o ...
.rdata$r:0000B158                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:0000B15C                 db    0
.rdata$r:0000B15D                 db    0
.rdata$r:0000B15E                 db    0
.rdata$r:0000B15F                 db    0
.rdata$r:0000B160                 db    0
.rdata$r:0000B161                 db    0
.rdata$r:0000B162                 db    0
.rdata$r:0000B163                 db    0
.rdata$r:0000B164                 db 0FFh
.rdata$r:0000B165                 db 0FFh
.rdata$r:0000B166                 db 0FFh
.rdata$r:0000B167                 db 0FFh
.rdata$r:0000B168                 db    0
.rdata$r:0000B169                 db    0
.rdata$r:0000B16A                 db    0
.rdata$r:0000B16B                 db    0
.rdata$r:0000B16C                 db  40h ; @
.rdata$r:0000B16D                 db    0
.rdata$r:0000B16E                 db    0
.rdata$r:0000B16F                 db    0
.rdata$r:0000B170                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B170 _rdata$r        ends
.rdata$r:0000B170
.rdata$r:0000B174 ; ===========================================================================
.rdata$r:0000B174
.rdata$r:0000B174 ; Segment type: Pure data
.rdata$r:0000B174 ; Segment permissions: Read
.rdata$r:0000B174 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B174                 assume cs:_rdata$r
.rdata$r:0000B174                 ;org 0B174h
.rdata$r:0000B174 ; COMDAT (pick any)
.rdata$r:0000B174                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000B174 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000B174 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000B174                                         ; DATA XREF: .rdata:0000A4ECo
.rdata$r:0000B175                 db    0
.rdata$r:0000B176                 db    0
.rdata$r:0000B177                 db    0
.rdata$r:0000B178                 db    0
.rdata$r:0000B179                 db    0
.rdata$r:0000B17A                 db    0
.rdata$r:0000B17B                 db    0
.rdata$r:0000B17C                 db    0
.rdata$r:0000B17D                 db    0
.rdata$r:0000B17E                 db    0
.rdata$r:0000B17F                 db    0
.rdata$r:0000B180                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000B184                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B184 _rdata$r        ends
.rdata$r:0000B184
.data$r:0000B188 ; ===========================================================================
.data$r:0000B188
.data$r:0000B188 ; Segment type: Pure data
.data$r:0000B188 ; Segment permissions: Read/Write
.data$r:0000B188 _data$r         segment dword public 'DATA' use32
.data$r:0000B188                 assume cs:_data$r
.data$r:0000B188                 ;org 0B188h
.data$r:0000B188 ; COMDAT (pick any)
.data$r:0000B188                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:0000B188 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:0000B188 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000B188                                         ; DATA XREF: .rdata$r:0000B180o
.data$r:0000B188                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000B188                                         ; const type_info::`vftable'
.data$r:0000B18C                 align 10h
.data$r:0000B190 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:0000B1B2                 align 4
.data$r:0000B1B2 _data$r         ends
.data$r:0000B1B2
.rdata$r:0000B1B4 ; ===========================================================================
.rdata$r:0000B1B4
.rdata$r:0000B1B4 ; Segment type: Pure data
.rdata$r:0000B1B4 ; Segment permissions: Read
.rdata$r:0000B1B4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B1B4                 assume cs:_rdata$r
.rdata$r:0000B1B4                 ;org 0B1B4h
.rdata$r:0000B1B4 ; COMDAT (pick any)
.rdata$r:0000B1B4                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000B1B4 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B1B4 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000B1B4                                         ; DATA XREF: .rdata$r:0000B184o
.rdata$r:0000B1B4                                         ; .rdata$r:0000B1E8o
.rdata$r:0000B1B5                 db    0
.rdata$r:0000B1B6                 db    0
.rdata$r:0000B1B7                 db    0
.rdata$r:0000B1B8                 db    0
.rdata$r:0000B1B9                 db    0
.rdata$r:0000B1BA                 db    0
.rdata$r:0000B1BB                 db    0
.rdata$r:0000B1BC                 db    2
.rdata$r:0000B1BD                 db    0
.rdata$r:0000B1BE                 db    0
.rdata$r:0000B1BF                 db    0
.rdata$r:0000B1C0                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000B1C0 _rdata$r        ends
.rdata$r:0000B1C0
.rdata$r:0000B1C4 ; ===========================================================================
.rdata$r:0000B1C4
.rdata$r:0000B1C4 ; Segment type: Pure data
.rdata$r:0000B1C4 ; Segment permissions: Read
.rdata$r:0000B1C4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B1C4                 assume cs:_rdata$r
.rdata$r:0000B1C4                 ;org 0B1C4h
.rdata$r:0000B1C4 ; COMDAT (pick any)
.rdata$r:0000B1C4                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000B1C4 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000B1C4 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000B1C4                                         ; DATA XREF: .rdata$r:0000B1C0o
.rdata$r:0000B1C4                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B1C8                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B1CC                 db    0
.rdata$r:0000B1CD                 align 10h
.rdata$r:0000B1CD _rdata$r        ends
.rdata$r:0000B1CD
.rdata$r:0000B1D0 ; ===========================================================================
.rdata$r:0000B1D0
.rdata$r:0000B1D0 ; Segment type: Pure data
.rdata$r:0000B1D0 ; Segment permissions: Read
.rdata$r:0000B1D0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B1D0                 assume cs:_rdata$r
.rdata$r:0000B1D0                 ;org 0B1D0h
.rdata$r:0000B1D0 ; COMDAT (pick any)
.rdata$r:0000B1D0                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000B1D0 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B1D0 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000B1D0                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000B1D0                                         ; .rdata$r:0000B240o ...
.rdata$r:0000B1D0                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000B1D4                 db    1
.rdata$r:0000B1D5                 db    0
.rdata$r:0000B1D6                 db    0
.rdata$r:0000B1D7                 db    0
.rdata$r:0000B1D8                 db    0
.rdata$r:0000B1D9                 db    0
.rdata$r:0000B1DA                 db    0
.rdata$r:0000B1DB                 db    0
.rdata$r:0000B1DC                 db 0FFh
.rdata$r:0000B1DD                 db 0FFh
.rdata$r:0000B1DE                 db 0FFh
.rdata$r:0000B1DF                 db 0FFh
.rdata$r:0000B1E0                 db    0
.rdata$r:0000B1E1                 db    0
.rdata$r:0000B1E2                 db    0
.rdata$r:0000B1E3                 db    0
.rdata$r:0000B1E4                 db  40h ; @
.rdata$r:0000B1E5                 db    0
.rdata$r:0000B1E6                 db    0
.rdata$r:0000B1E7                 db    0
.rdata$r:0000B1E8                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B1E8 _rdata$r        ends
.rdata$r:0000B1E8
.rdata$r:0000B1EC ; ===========================================================================
.rdata$r:0000B1EC
.rdata$r:0000B1EC ; Segment type: Pure data
.rdata$r:0000B1EC ; Segment permissions: Read
.rdata$r:0000B1EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B1EC                 assume cs:_rdata$r
.rdata$r:0000B1EC                 ;org 0B1ECh
.rdata$r:0000B1EC ; COMDAT (pick any)
.rdata$r:0000B1EC                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000B1EC ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000B1EC ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000B1EC                                         ; DATA XREF: .rdata:0000A520o
.rdata$r:0000B1ED                 db    0
.rdata$r:0000B1EE                 db    0
.rdata$r:0000B1EF                 db    0
.rdata$r:0000B1F0                 db    0
.rdata$r:0000B1F1                 db    0
.rdata$r:0000B1F2                 db    0
.rdata$r:0000B1F3                 db    0
.rdata$r:0000B1F4                 db    0
.rdata$r:0000B1F5                 db    0
.rdata$r:0000B1F6                 db    0
.rdata$r:0000B1F7                 db    0
.rdata$r:0000B1F8                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000B1FC                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B1FC _rdata$r        ends
.rdata$r:0000B1FC
.data$r:0000B200 ; ===========================================================================
.data$r:0000B200
.data$r:0000B200 ; Segment type: Pure data
.data$r:0000B200 ; Segment permissions: Read/Write
.data$r:0000B200 _data$r         segment dword public 'DATA' use32
.data$r:0000B200                 assume cs:_data$r
.data$r:0000B200                 ;org 0B200h
.data$r:0000B200 ; COMDAT (pick any)
.data$r:0000B200                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000B200 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000B200 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000B200                                         ; DATA XREF: .rdata$r:0000B1F8o
.data$r:0000B200                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000B200                                         ; const type_info::`vftable'
.data$r:0000B204                 align 8
.data$r:0000B208 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:0000B22B                 align 4
.data$r:0000B22B _data$r         ends
.data$r:0000B22B
.rdata$r:0000B22C ; ===========================================================================
.rdata$r:0000B22C
.rdata$r:0000B22C ; Segment type: Pure data
.rdata$r:0000B22C ; Segment permissions: Read
.rdata$r:0000B22C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B22C                 assume cs:_rdata$r
.rdata$r:0000B22C                 ;org 0B22Ch
.rdata$r:0000B22C ; COMDAT (pick any)
.rdata$r:0000B22C                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:0000B22C ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B22C ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:0000B22C                                         ; DATA XREF: .rdata$r:0000B1FCo
.rdata$r:0000B22C                                         ; .rdata$r:0000B264o
.rdata$r:0000B22D                 db    0
.rdata$r:0000B22E                 db    0
.rdata$r:0000B22F                 db    0
.rdata$r:0000B230                 db    0
.rdata$r:0000B231                 db    0
.rdata$r:0000B232                 db    0
.rdata$r:0000B233                 db    0
.rdata$r:0000B234                 db    3
.rdata$r:0000B235                 db    0
.rdata$r:0000B236                 db    0
.rdata$r:0000B237                 db    0
.rdata$r:0000B238                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000B238 _rdata$r        ends
.rdata$r:0000B238
.rdata$r:0000B23C ; ===========================================================================
.rdata$r:0000B23C
.rdata$r:0000B23C ; Segment type: Pure data
.rdata$r:0000B23C ; Segment permissions: Read
.rdata$r:0000B23C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B23C                 assume cs:_rdata$r
.rdata$r:0000B23C                 ;org 0B23Ch
.rdata$r:0000B23C ; COMDAT (pick any)
.rdata$r:0000B23C                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:0000B23C ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:0000B23C ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000B23C                                         ; DATA XREF: .rdata$r:0000B238o
.rdata$r:0000B23C                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B240                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B244                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B248                 db    0
.rdata$r:0000B249                 align 4
.rdata$r:0000B249 _rdata$r        ends
.rdata$r:0000B249
.rdata$r:0000B24C ; ===========================================================================
.rdata$r:0000B24C
.rdata$r:0000B24C ; Segment type: Pure data
.rdata$r:0000B24C ; Segment permissions: Read
.rdata$r:0000B24C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B24C                 assume cs:_rdata$r
.rdata$r:0000B24C                 ;org 0B24Ch
.rdata$r:0000B24C ; COMDAT (pick any)
.rdata$r:0000B24C                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:0000B24C ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B24C ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:0000B24C                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:0000B24C                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000B250                 db    2
.rdata$r:0000B251                 db    0
.rdata$r:0000B252                 db    0
.rdata$r:0000B253                 db    0
.rdata$r:0000B254                 db    0
.rdata$r:0000B255                 db    0
.rdata$r:0000B256                 db    0
.rdata$r:0000B257                 db    0
.rdata$r:0000B258                 db 0FFh
.rdata$r:0000B259                 db 0FFh
.rdata$r:0000B25A                 db 0FFh
.rdata$r:0000B25B                 db 0FFh
.rdata$r:0000B25C                 db    0
.rdata$r:0000B25D                 db    0
.rdata$r:0000B25E                 db    0
.rdata$r:0000B25F                 db    0
.rdata$r:0000B260                 db  40h ; @
.rdata$r:0000B261                 db    0
.rdata$r:0000B262                 db    0
.rdata$r:0000B263                 db    0
.rdata$r:0000B264                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B264 _rdata$r        ends
.rdata$r:0000B264
.rdata$r:0000B268 ; ===========================================================================
.rdata$r:0000B268
.rdata$r:0000B268 ; Segment type: Pure data
.rdata$r:0000B268 ; Segment permissions: Read
.rdata$r:0000B268 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B268                 assume cs:_rdata$r
.rdata$r:0000B268                 ;org 0B268h
.rdata$r:0000B268 ; COMDAT (pick any)
.rdata$r:0000B268                 public ??_R4_System_error_category@std@@6B@
.rdata$r:0000B268 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:0000B268 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000A560o
.rdata$r:0000B269                 db    0
.rdata$r:0000B26A                 db    0
.rdata$r:0000B26B                 db    0
.rdata$r:0000B26C                 db    0
.rdata$r:0000B26D                 db    0
.rdata$r:0000B26E                 db    0
.rdata$r:0000B26F                 db    0
.rdata$r:0000B270                 db    0
.rdata$r:0000B271                 db    0
.rdata$r:0000B272                 db    0
.rdata$r:0000B273                 db    0
.rdata$r:0000B274                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000B278                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B278 _rdata$r        ends
.rdata$r:0000B278
.data$r:0000B27C ; ===========================================================================
.data$r:0000B27C
.data$r:0000B27C ; Segment type: Pure data
.data$r:0000B27C ; Segment permissions: Read/Write
.data$r:0000B27C _data$r         segment dword public 'DATA' use32
.data$r:0000B27C                 assume cs:_data$r
.data$r:0000B27C                 ;org 0B27Ch
.data$r:0000B27C ; COMDAT (pick any)
.data$r:0000B27C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000B27C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000B27C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000B27C                                         ; DATA XREF: .rdata$r:0000B274o
.data$r:0000B27C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000B27C                                         ; const type_info::`vftable'
.data$r:0000B280                 db    0
.data$r:0000B281                 db    0
.data$r:0000B282                 db    0
.data$r:0000B283                 db    0
.data$r:0000B284                 db  2Eh ; .
.data$r:0000B285                 db  3Fh ; ?
.data$r:0000B286                 db  41h ; A
.data$r:0000B287                 db  56h ; V
.data$r:0000B288                 db  5Fh ; _
.data$r:0000B289                 db  53h ; S
.data$r:0000B28A                 db  79h ; y
.data$r:0000B28B                 db  73h ; s
.data$r:0000B28C                 db  74h ; t
.data$r:0000B28D                 db  65h ; e
.data$r:0000B28E                 db  6Dh ; m
.data$r:0000B28F                 db  5Fh ; _
.data$r:0000B290                 db  65h ; e
.data$r:0000B291                 db  72h ; r
.data$r:0000B292                 db  72h ; r
.data$r:0000B293                 db  6Fh ; o
.data$r:0000B294                 db  72h ; r
.data$r:0000B295                 db  5Fh ; _
.data$r:0000B296                 db  63h ; c
.data$r:0000B297                 db  61h ; a
.data$r:0000B298                 db  74h ; t
.data$r:0000B299                 db  65h ; e
.data$r:0000B29A                 db  67h ; g
.data$r:0000B29B                 db  6Fh ; o
.data$r:0000B29C                 db  72h ; r
.data$r:0000B29D                 db  79h ; y
.data$r:0000B29E                 db  40h ; @
.data$r:0000B29F                 db  73h ; s
.data$r:0000B2A0                 db  74h ; t
.data$r:0000B2A1                 db  64h ; d
.data$r:0000B2A2                 db  40h ; @
.data$r:0000B2A3                 db  40h ; @
.data$r:0000B2A4                 db    0
.data$r:0000B2A5                 align 4
.data$r:0000B2A5 _data$r         ends
.data$r:0000B2A5
.rdata$r:0000B2A8 ; ===========================================================================
.rdata$r:0000B2A8
.rdata$r:0000B2A8 ; Segment type: Pure data
.rdata$r:0000B2A8 ; Segment permissions: Read
.rdata$r:0000B2A8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B2A8                 assume cs:_rdata$r
.rdata$r:0000B2A8                 ;org 0B2A8h
.rdata$r:0000B2A8 ; COMDAT (pick any)
.rdata$r:0000B2A8                 public ??_R3_System_error_category@std@@8
.rdata$r:0000B2A8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B2A8 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:0000B278o
.rdata$r:0000B2A8                                         ; .rdata$r:0000B2E0o
.rdata$r:0000B2A9                 db    0
.rdata$r:0000B2AA                 db    0
.rdata$r:0000B2AB                 db    0
.rdata$r:0000B2AC                 db    0
.rdata$r:0000B2AD                 db    0
.rdata$r:0000B2AE                 db    0
.rdata$r:0000B2AF                 db    0
.rdata$r:0000B2B0                 db    3
.rdata$r:0000B2B1                 db    0
.rdata$r:0000B2B2                 db    0
.rdata$r:0000B2B3                 db    0
.rdata$r:0000B2B4                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000B2B4 _rdata$r        ends
.rdata$r:0000B2B4
.rdata$r:0000B2B8 ; ===========================================================================
.rdata$r:0000B2B8
.rdata$r:0000B2B8 ; Segment type: Pure data
.rdata$r:0000B2B8 ; Segment permissions: Read
.rdata$r:0000B2B8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B2B8                 assume cs:_rdata$r
.rdata$r:0000B2B8                 ;org 0B2B8h
.rdata$r:0000B2B8 ; COMDAT (pick any)
.rdata$r:0000B2B8                 public ??_R2_System_error_category@std@@8
.rdata$r:0000B2B8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000B2B8 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000B2B8                                         ; DATA XREF: .rdata$r:0000B2B4o
.rdata$r:0000B2B8                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B2BC                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B2C0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000B2C4                 db    0
.rdata$r:0000B2C5                 align 4
.rdata$r:0000B2C5 _rdata$r        ends
.rdata$r:0000B2C5
.rdata$r:0000B2C8 ; ===========================================================================
.rdata$r:0000B2C8
.rdata$r:0000B2C8 ; Segment type: Pure data
.rdata$r:0000B2C8 ; Segment permissions: Read
.rdata$r:0000B2C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000B2C8                 assume cs:_rdata$r
.rdata$r:0000B2C8                 ;org 0B2C8h
.rdata$r:0000B2C8 ; COMDAT (pick any)
.rdata$r:0000B2C8                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:0000B2C8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000B2C8 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:0000B2C8                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:0000B2C8                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000B2CC                 db    2
.rdata$r:0000B2CD                 db    0
.rdata$r:0000B2CE                 db    0
.rdata$r:0000B2CF                 db    0
.rdata$r:0000B2D0                 db    0
.rdata$r:0000B2D1                 db    0
.rdata$r:0000B2D2                 db    0
.rdata$r:0000B2D3                 db    0
.rdata$r:0000B2D4                 db 0FFh
.rdata$r:0000B2D5                 db 0FFh
.rdata$r:0000B2D6                 db 0FFh
.rdata$r:0000B2D7                 db 0FFh
.rdata$r:0000B2D8                 db    0
.rdata$r:0000B2D9                 db    0
.rdata$r:0000B2DA                 db    0
.rdata$r:0000B2DB                 db    0
.rdata$r:0000B2DC                 db  40h ; @
.rdata$r:0000B2DD                 db    0
.rdata$r:0000B2DE                 db    0
.rdata$r:0000B2DF                 db    0
.rdata$r:0000B2E0                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000B2E0 _rdata$r        ends
.rdata$r:0000B2E0
.CRT$XCU:0000B2E4 ; ===========================================================================
.CRT$XCU:0000B2E4
.CRT$XCU:0000B2E4 ; Segment type: Pure data
.CRT$XCU:0000B2E4 ; Segment permissions: Read
.CRT$XCU:0000B2E4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B2E4                 assume cs:_CRT$XCU
.CRT$XCU:0000B2E4                 ;org 0B2E4h
.CRT$XCU:0000B2E4 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:0000B2E8 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:0000B2EC _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:0000B2F0 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:0000B2F0 _CRT$XCU        ends
.CRT$XCU:0000B2F0
.CRT$XCU:0000B2F4 ; ===========================================================================
.CRT$XCU:0000B2F4
.CRT$XCU:0000B2F4 ; Segment type: Pure data
.CRT$XCU:0000B2F4 ; Segment permissions: Read
.CRT$XCU:0000B2F4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B2F4                 assume cs:_CRT$XCU
.CRT$XCU:0000B2F4                 ;org 0B2F4h
.CRT$XCU:0000B2F4 ; COMDAT (pick associative to section at A584)
.CRT$XCU:0000B2F4 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000B2F4 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000B2F4 _CRT$XCU        ends
.CRT$XCU:0000B2F4
.CRT$XCU:0000B2F8 ; ===========================================================================
.CRT$XCU:0000B2F8
.CRT$XCU:0000B2F8 ; Segment type: Pure data
.CRT$XCU:0000B2F8 ; Segment permissions: Read
.CRT$XCU:0000B2F8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B2F8                 assume cs:_CRT$XCU
.CRT$XCU:0000B2F8                 ;org 0B2F8h
.CRT$XCU:0000B2F8 ; COMDAT (pick associative to section at A588)
.CRT$XCU:0000B2F8 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000B2F8 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000B2F8 _CRT$XCU        ends
.CRT$XCU:0000B2F8
.CRT$XCU:0000B2FC ; ===========================================================================
.CRT$XCU:0000B2FC
.CRT$XCU:0000B2FC ; Segment type: Pure data
.CRT$XCU:0000B2FC ; Segment permissions: Read
.CRT$XCU:0000B2FC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B2FC                 assume cs:_CRT$XCU
.CRT$XCU:0000B2FC                 ;org 0B2FCh
.CRT$XCU:0000B2FC ; COMDAT (pick associative to section at A58C)
.CRT$XCU:0000B2FC ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:0000B2FC ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:0000B2FC _CRT$XCU        ends
.CRT$XCU:0000B2FC
.CRT$XCU:0000B300 ; ===========================================================================
.CRT$XCU:0000B300
.CRT$XCU:0000B300 ; Segment type: Pure data
.CRT$XCU:0000B300 ; Segment permissions: Read
.CRT$XCU:0000B300 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B300                 assume cs:_CRT$XCU
.CRT$XCU:0000B300                 ;org 0B300h
.CRT$XCU:0000B300 ; COMDAT (pick associative to section at A590)
.CRT$XCU:0000B300 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:0000B300 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:0000B300 _CRT$XCU        ends
.CRT$XCU:0000B300
.CRT$XCU:0000B304 ; ===========================================================================
.CRT$XCU:0000B304
.CRT$XCU:0000B304 ; Segment type: Pure data
.CRT$XCU:0000B304 ; Segment permissions: Read
.CRT$XCU:0000B304 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B304                 assume cs:_CRT$XCU
.CRT$XCU:0000B304                 ;org 0B304h
.CRT$XCU:0000B304 ; COMDAT (pick associative to section at A594)
.CRT$XCU:0000B304 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000B304 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000B304 _CRT$XCU        ends
.CRT$XCU:0000B304
.CRT$XCU:0000B308 ; ===========================================================================
.CRT$XCU:0000B308
.CRT$XCU:0000B308 ; Segment type: Pure data
.CRT$XCU:0000B308 ; Segment permissions: Read
.CRT$XCU:0000B308 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B308                 assume cs:_CRT$XCU
.CRT$XCU:0000B308                 ;org 0B308h
.CRT$XCU:0000B308 ; COMDAT (pick associative to section at A628)
.CRT$XCU:0000B308 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000B308 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000B308 _CRT$XCU        ends
.CRT$XCU:0000B308
.CRT$XCU:0000B30C ; ===========================================================================
.CRT$XCU:0000B30C
.CRT$XCU:0000B30C ; Segment type: Pure data
.CRT$XCU:0000B30C ; Segment permissions: Read
.CRT$XCU:0000B30C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000B30C                 assume cs:_CRT$XCU
.CRT$XCU:0000B30C                 ;org 0B30Ch
.CRT$XCU:0000B30C ; COMDAT (pick associative to section at A62C)
.CRT$XCU:0000B30C ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:0000B30C ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:0000B30C _CRT$XCU        ends
.CRT$XCU:0000B30C
UNDEF:0000B310 ; ===========================================================================
UNDEF:0000B310
UNDEF:0000B310 ; Segment type: Externs
UNDEF:0000B310 ; UNDEF
UNDEF:0000B310                 extrn __purecall:near   ; DATA XREF: .rdata:0000A4D8o
UNDEF:0000B310                                         ; .rdata:0000A4DCo
UNDEF:0000B314 ; void *__cdecl operator new(unsigned int)
UNDEF:0000B314                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:0000B314                                         ; std::_Allocate<uchar>(uint,uchar *)+1Dp ...
UNDEF:0000B318 ; void __cdecl operator delete(void *)
UNDEF:0000B318                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::`scalar deleting destructor'(uint)+1Bp
UNDEF:0000B318                                         ; std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:0000B31C ; int __cdecl atexit(void (__cdecl *)())
UNDEF:0000B31C                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:0000B31C                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:0000B320                 extrn __invalid_parameter:near
UNDEF:0000B320                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+74p
UNDEF:0000B320                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+74p ...
UNDEF:0000B324 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:0000B324                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:0000B328 ; size_t __cdecl strlen(const char *Str)
UNDEF:0000B328                 extrn _strlen:near      ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+345p
UNDEF:0000B328                                         ; std::char_traits<char>::length(char const *)+1Bp
UNDEF:0000B32C ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:0000B32C                 extrn _memmove:near     ; CODE XREF: std::_Copy_impl<uchar *,uchar *>(uchar *,uchar *,uchar *,std::_Scalar_ptr_iterator_tag)+19p
UNDEF:0000B32C                                         ; std::_Uninit_copy<uchar const,uchar>(uchar const *,uchar const *,uchar *,std::_Wrap_alloc<std::allocator<uchar>> &,std::_Scalar_ptr_iterator_tag)+49p ...
UNDEF:0000B330 ; LPVOID __stdcall GlobalLock(HGLOBAL hMem)
UNDEF:0000B330                 extrn __imp__GlobalLock@4:near
UNDEF:0000B330                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+C1p
UNDEF:0000B330                                         ; ClipboardHistoryPanel::getClipboadData(void)+CEp ...
UNDEF:0000B334 ; BOOL __stdcall GlobalUnlock(HGLOBAL hMem)
UNDEF:0000B334                 extrn __imp__GlobalUnlock@4:near
UNDEF:0000B334                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+15Cp
UNDEF:0000B334                                         ; ClipboardHistoryPanel::getClipboadData(void)+1ACp
UNDEF:0000B334                                         ; DATA XREF: ...
UNDEF:0000B338 ; int __stdcall lstrlenW(LPCWSTR lpString)
UNDEF:0000B338                 extrn __imp__lstrlenW@4:near
UNDEF:0000B338                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+168p
UNDEF:0000B338                                         ; ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+113p
UNDEF:0000B338                                         ; DATA XREF: ...
UNDEF:0000B33C ; HBRUSH __stdcall CreateSolidBrush(COLORREF color)
UNDEF:0000B33C                 extrn __imp__CreateSolidBrush@4:near
UNDEF:0000B33C                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3FCp
UNDEF:0000B33C                                         ; DATA XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3FCr
UNDEF:0000B340 ; COLORREF __stdcall SetBkColor(HDC hdc, COLORREF color)
UNDEF:0000B340                 extrn __imp__SetBkColor@8:near
UNDEF:0000B340                                         ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+100p
UNDEF:0000B340                                         ; DATA XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+100r
UNDEF:0000B344 ; COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color)
UNDEF:0000B344                 extrn __imp__SetTextColor@8:near
UNDEF:0000B344                                         ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+EFp
UNDEF:0000B344                                         ; DATA XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+EFr
UNDEF:0000B348 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000B348                 extrn __imp__SendMessageW@16:near
UNDEF:0000B348                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+FAp
UNDEF:0000B348                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+175p
UNDEF:0000B348                                         ; DATA XREF: ...
UNDEF:0000B34C ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:0000B34C                 extrn __imp__MoveWindow@24:near
UNDEF:0000B34C                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3DEp
UNDEF:0000B34C                                         ; DATA XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3DEr
UNDEF:0000B350 ; HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem)
UNDEF:0000B350                 extrn __imp__GetDlgItem@8:near
UNDEF:0000B350                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3D7p
UNDEF:0000B350                                         ; DATA XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+3D7r
UNDEF:0000B354 ; LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:0000B354                 extrn __imp__SendDlgItemMessageW@20:near
UNDEF:0000B354                                         ; CODE XREF: ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+13Fp
UNDEF:0000B354                                         ; ClipboardHistoryPanel::addToClipboadHistory(std::vector<uchar,std::allocator<uchar>>)+20Ep ...
UNDEF:0000B358 ; BOOL __stdcall OpenClipboard(HWND hWndNewOwner)
UNDEF:0000B358                 extrn __imp__OpenClipboard@4:near
UNDEF:0000B358                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+75p
UNDEF:0000B358                                         ; DATA XREF: ClipboardHistoryPanel::getClipboadData(void)+75r
UNDEF:0000B35C ; BOOL __stdcall CloseClipboard()
UNDEF:0000B35C                 extrn __imp__CloseClipboard@0:near
UNDEF:0000B35C                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void):loc_120Ep
UNDEF:0000B35C                                         ; DATA XREF: ClipboardHistoryPanel::getClipboadData(void):loc_120Er
UNDEF:0000B360 ; HWND __stdcall SetClipboardViewer(HWND hWndNewViewer)
UNDEF:0000B360                 extrn __imp__SetClipboardViewer@4:near
UNDEF:0000B360                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+A3p
UNDEF:0000B360                                         ; DATA XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+A3r
UNDEF:0000B364 ; BOOL __stdcall ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext)
UNDEF:0000B364                 extrn __imp__ChangeClipboardChain@8:near
UNDEF:0000B364                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+1AAp
UNDEF:0000B364                                         ; DATA XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+1AAr
UNDEF:0000B368 ; HANDLE __stdcall GetClipboardData(UINT uFormat)
UNDEF:0000B368                 extrn __imp__GetClipboardData@4:near
UNDEF:0000B368                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+AAp
UNDEF:0000B368                                         ; ClipboardHistoryPanel::getClipboadData(void)+101p
UNDEF:0000B368                                         ; DATA XREF: ...
UNDEF:0000B36C ; UINT __stdcall RegisterClipboardFormatW(LPCWSTR lpszFormat)
UNDEF:0000B36C                 extrn __imp__RegisterClipboardFormatW@4:near
UNDEF:0000B36C                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+E6p
UNDEF:0000B36C                                         ; DATA XREF: ClipboardHistoryPanel::getClipboadData(void)+E6r
UNDEF:0000B370 ; BOOL __stdcall IsClipboardFormatAvailable(UINT format)
UNDEF:0000B370                 extrn __imp__IsClipboardFormatAvailable@4:near
UNDEF:0000B370                                         ; CODE XREF: ClipboardHistoryPanel::getClipboadData(void)+40p
UNDEF:0000B370                                         ; ClipboardHistoryPanel::getClipboadData(void)+F3p
UNDEF:0000B370                                         ; DATA XREF: ...
UNDEF:0000B374 ; HWND __stdcall SetFocus(HWND hWnd)
UNDEF:0000B374                 extrn __imp__SetFocus@4:near
UNDEF:0000B374                                         ; CODE XREF: Window::getFocus(void)+Ep
UNDEF:0000B374                                         ; DATA XREF: Window::getFocus(void)+Er
UNDEF:0000B378 ; int __stdcall DrawTextW(HDC hdc, LPCWSTR lpchText, int cchText, LPRECT lprc, UINT format)
UNDEF:0000B378                 extrn __imp__DrawTextW@20:near
UNDEF:0000B378                                         ; CODE XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+125p
UNDEF:0000B378                                         ; DATA XREF: ClipboardHistoryPanel::drawItem(tagDRAWITEMSTRUCT *)+125r
UNDEF:0000B37C ; int __stdcall WideCharToMultiByte(UINT CodePage, DWORD dwFlags, LPCWSTR lpWideCharStr, int cchWideChar, LPSTR lpMultiByteStr, int cbMultiByte, LPCSTR lpDefaultChar, LPBOOL lpUsedDefaultChar)
UNDEF:0000B37C                 extrn __imp__WideCharToMultiByte@32:near
UNDEF:0000B37C                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+2D6p
UNDEF:0000B37C                                         ; ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+31Ep
UNDEF:0000B37C                                         ; DATA XREF: ...
UNDEF:0000B380 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:0000B380                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:0000B380                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:0000B380                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:0000B384 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:0000B384                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:0000B384                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:0000B384                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000B388                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:0000B38C ; void __cdecl operator delete[](void *)
UNDEF:0000B38C                 extrn ??_V@YAXPAX@Z:near
UNDEF:0000B38C                                         ; CODE XREF: ClipboardHistoryPanel::run_dlgProc(uint,uint,long)+377p
UNDEF:0000B38C                                         ; ByteArray::~ByteArray(void)+1Dp
UNDEF:0000B390 ; void *__cdecl operator new[](unsigned int)
UNDEF:0000B390                 extrn ??_U@YAPAXI@Z:near
UNDEF:0000B390                                         ; CODE XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+58p
UNDEF:0000B390                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+BEp ...
UNDEF:0000B394                 extrn __CrtDbgReportW:near
UNDEF:0000B394                                         ; CODE XREF: std::vector<uchar,std::allocator<uchar>>::operator[](uint)+50p
UNDEF:0000B394                                         ; std::vector<std::vector<uchar,std::allocator<uchar>>,std::allocator<std::vector<uchar,std::allocator<uchar>>>>::operator[](uint)+50p ...
UNDEF:0000B398 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:0000B398                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:0000B398                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:0000B398                                         ; std::_Debug_pointer<uchar>(uchar *,wchar_t const *,uint)+16p ...
UNDEF:0000B39C ; void __cdecl std::_Xbad_alloc()
UNDEF:0000B39C                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:0000B39C                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1E9Ap
UNDEF:0000B39C                                         ; std::_Allocate<uchar>(uint,uchar *):loc_1ED6p ...
UNDEF:0000B3A0 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000B3A0                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000B3A0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000B3A0                                         ; std::vector<uchar,std::allocator<uchar>>::_Xlen(void)+Cp ...
UNDEF:0000B3A4 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000B3A4                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000B3A4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000B3A8 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000B3A8                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000B3A8                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000B3AC ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000B3AC                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000B3AC                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000B3AC                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000B3B0 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000B3B0                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000B3B0                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:0000B3B4 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000B3B4                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000B3B4                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000B3B8 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000B3B8                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000B3B8                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:0000B3BC ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000B3BC                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000B3BC                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000B3C0 ; __fastcall __security_check_cookie(x)
UNDEF:0000B3C0                 extrn @__security_check_cookie@4:near
UNDEF:0000B3C0                                         ; CODE XREF: __ehhandler$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z+Cp
UNDEF:0000B3C0                                         ; __ehhandler$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z+Cp ...
UNDEF:0000B3C4 ; __stdcall _CxxThrowException(x, x)
UNDEF:0000B3C4                 extrn __CxxThrowException@8:near
UNDEF:0000B3C4                                         ; CODE XREF: __catch$??$_Construct@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@@?$vector@EV?$allocator@E@std@@@std@@QAEXV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@1@0Uforward_iterator_tag@1@@Z$0+Cp
UNDEF:0000B3C4                                         ; __catch$??$_Uninit_copy@V?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@std@@PAEV?$allocator@E@2@@std@@YAPAEV?$move_iterator@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@E@std@@@std@@@std@@@0@0PAEAAU?$_Wrap_alloc@V?$allocator@E@std@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z$0+25p ...
UNDEF:0000B3C8                 extrn ___CxxFrameHandler3:near
UNDEF:0000B3C8                                         ; CODE XREF: __ehhandler$??0ByteArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@@Z+16j
UNDEF:0000B3C8                                         ; __ehhandler$??0StringArray@@QAE@V?$vector@EV?$allocator@E@std@@@std@@I@Z+16j ...
UNDEF:0000B3CC ; const type_info::`vftable'
UNDEF:0000B3CC                 extrn ??_7type_info@@6B@:near
UNDEF:0000B3CC                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:0000B3CC                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:0000B3D0                 extrn ___security_cookie:near
UNDEF:0000B3D0                                         ; DATA XREF: ByteArray::ByteArray(std::vector<uchar,std::allocator<uchar>>)+14r
UNDEF:0000B3D0                                         ; StringArray::StringArray(std::vector<uchar,std::allocator<uchar>>,uint)+14r ...
UNDEF:0000B3D4                 extrn __fltused:near
UNDEF:0000B3D4
UNDEF:0000B3D4
UNDEF:0000B3D4                 end