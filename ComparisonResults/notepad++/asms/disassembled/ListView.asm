.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : AF8F69C758145E22CB4033A8D2925CCB
.rdata:00000000 ; Input CRC32 : 8E07CC5C
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\ListView.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 _rdata          segment dword public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 ; const WCHAR _SG123189
.rdata:00000000 $SG123189       dw 0                    ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+7Do
.rdata:00000002                 align 4
.rdata:00000004 ; const WCHAR _SG123190
.rdata:00000004 $SG123190:                              ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+82o
.rdata:00000004                 unicode 0, <SysListView32>,0
.rdata:00000020 ; char _SG123194[]
.rdata:00000020 $SG123194       db 'ListView::init : CreateWindowEx() function return null',0
.rdata:00000020                                         ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+9Eo
.rdata:00000057                 align 4
.rdata:00000058 $SG123205       db 'ColumnVal',0        ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+142o
.rdata:00000062                 align 4
.rdata:00000064 $SG123206       db 'AsciiInsertion',0   ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+147o
.rdata:00000073                 align 4
.rdata:00000074 $SG123207:                              ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+14Co
.rdata:00000074                 unicode 0, <Value>,0
.rdata:00000080 $SG123210       db 'ColumnHex',0        ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+164o
.rdata:0000008A                 align 4
.rdata:0000008C $SG123211       db 'AsciiInsertion',0   ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+169o
.rdata:0000009B                 align 4
.rdata:0000009C $SG123212:                              ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+16Eo
.rdata:0000009C                 unicode 0, <Hex>,0
.rdata:000000A4 $SG123215       db 'ColumnChar',0       ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+183o
.rdata:000000AF                 align 10h
.rdata:000000B0 $SG123216       db 'AsciiInsertion',0   ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+188o
.rdata:000000BF                 align 10h
.rdata:000000C0 $SG123217:                              ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+18Do
.rdata:000000C0                 unicode 0, <Character>,0
.rdata:000000D4 ; wchar_t _SG123253
.rdata:000000D4 $SG123253:                              ; DATA XREF: ListView::getAscii(uchar):$LN35o
.rdata:000000D4                 unicode 0, <NULL>,0
.rdata:000000DE                 align 10h
.rdata:000000E0 ; wchar_t _SG123255
.rdata:000000E0 $SG123255:                              ; DATA XREF: ListView::getAscii(uchar):$LN34o
.rdata:000000E0                 unicode 0, <SOH>,0
.rdata:000000E8 ; wchar_t _SG123257
.rdata:000000E8 $SG123257:                              ; DATA XREF: ListView::getAscii(uchar):$LN33o
.rdata:000000E8                 unicode 0, <STX>,0
.rdata:000000F0 ; wchar_t _SG123259
.rdata:000000F0 $SG123259:                              ; DATA XREF: ListView::getAscii(uchar):$LN32o
.rdata:000000F0                 unicode 0, <ETX>,0
.rdata:000000F8 ; wchar_t _SG123261
.rdata:000000F8 $SG123261:                              ; DATA XREF: ListView::getAscii(uchar):$LN31o
.rdata:000000F8                 unicode 0, <EOT>,0
.rdata:00000100 ; wchar_t _SG123263
.rdata:00000100 $SG123263:                              ; DATA XREF: ListView::getAscii(uchar):$LN30o
.rdata:00000100                 unicode 0, <ENQ>,0
.rdata:00000108 ; wchar_t _SG123265
.rdata:00000108 $SG123265:                              ; DATA XREF: ListView::getAscii(uchar):$LN29o
.rdata:00000108                 unicode 0, <ACK>,0
.rdata:00000110 ; wchar_t _SG123267
.rdata:00000110 $SG123267:                              ; DATA XREF: ListView::getAscii(uchar):$LN28o
.rdata:00000110                 unicode 0, <BEL>,0
.rdata:00000118 ; wchar_t _SG123269
.rdata:00000118 $SG123269:                              ; DATA XREF: ListView::getAscii(uchar):$LN27o
.rdata:00000118                 unicode 0, <BS>,0
.rdata:0000011E                 align 10h
.rdata:00000120 ; wchar_t _SG123271
.rdata:00000120 $SG123271:                              ; DATA XREF: ListView::getAscii(uchar):$LN26o
.rdata:00000120                 unicode 0, <TAB>,0
.rdata:00000128 ; wchar_t _SG123273
.rdata:00000128 $SG123273:                              ; DATA XREF: ListView::getAscii(uchar):$LN25o
.rdata:00000128                 unicode 0, <LF>,0
.rdata:0000012E                 align 10h
.rdata:00000130 ; wchar_t _SG123275
.rdata:00000130 $SG123275:                              ; DATA XREF: ListView::getAscii(uchar):$LN24o
.rdata:00000130                 unicode 0, <VT>,0
.rdata:00000136                 align 4
.rdata:00000138 ; wchar_t _SG123277
.rdata:00000138 $SG123277:                              ; DATA XREF: ListView::getAscii(uchar):$LN23o
.rdata:00000138                 unicode 0, <FF>,0
.rdata:0000013E                 align 10h
.rdata:00000140 ; wchar_t _SG123279
.rdata:00000140 $SG123279:                              ; DATA XREF: ListView::getAscii(uchar):$LN22o
.rdata:00000140                 unicode 0, <CR>,0
.rdata:00000146                 align 4
.rdata:00000148 ; wchar_t _SG123281
.rdata:00000148 $SG123281:                              ; DATA XREF: ListView::getAscii(uchar):$LN21o
.rdata:00000148                 unicode 0, <SO>,0
.rdata:0000014E                 align 10h
.rdata:00000150 ; wchar_t _SG123283
.rdata:00000150 $SG123283:                              ; DATA XREF: ListView::getAscii(uchar):$LN20o
.rdata:00000150                 unicode 0, <SI>,0
.rdata:00000156                 align 4
.rdata:00000158 ; wchar_t _SG123285
.rdata:00000158 $SG123285:                              ; DATA XREF: ListView::getAscii(uchar):$LN19_1o
.rdata:00000158                 unicode 0, <DLE>,0
.rdata:00000160 ; wchar_t _SG123287
.rdata:00000160 $SG123287:                              ; DATA XREF: ListView::getAscii(uchar):$LN18o
.rdata:00000160                 unicode 0, <DC1>,0
.rdata:00000168 ; wchar_t _SG123289
.rdata:00000168 $SG123289:                              ; DATA XREF: ListView::getAscii(uchar):$LN17_1o
.rdata:00000168                 unicode 0, <DC2>,0
.rdata:00000170 ; wchar_t _SG123291
.rdata:00000170 $SG123291:                              ; DATA XREF: ListView::getAscii(uchar):$LN16o
.rdata:00000170                 unicode 0, <DC3>,0
.rdata:00000178 ; wchar_t _SG123293
.rdata:00000178 $SG123293:                              ; DATA XREF: ListView::getAscii(uchar):$LN15o
.rdata:00000178                 unicode 0, <DC4>,0
.rdata:00000180 ; wchar_t _SG123295
.rdata:00000180 $SG123295:                              ; DATA XREF: ListView::getAscii(uchar):$LN14o
.rdata:00000180                 unicode 0, <NAK>,0
.rdata:00000188 ; wchar_t _SG123297
.rdata:00000188 $SG123297:                              ; DATA XREF: ListView::getAscii(uchar):$LN13o
.rdata:00000188                 unicode 0, <SYN>,0
.rdata:00000190 ; wchar_t _SG123299
.rdata:00000190 $SG123299:                              ; DATA XREF: ListView::getAscii(uchar):$LN12o
.rdata:00000190                 unicode 0, <ETB>,0
.rdata:00000198 ; wchar_t _SG123301
.rdata:00000198 $SG123301:                              ; DATA XREF: ListView::getAscii(uchar):$LN11o
.rdata:00000198                 unicode 0, <CAN>,0
.rdata:000001A0 ; wchar_t _SG123303
.rdata:000001A0 $SG123303:                              ; DATA XREF: ListView::getAscii(uchar):$LN10o
.rdata:000001A0                 unicode 0, <EM>,0
.rdata:000001A6                 align 4
.rdata:000001A8 ; wchar_t _SG123305
.rdata:000001A8 $SG123305:                              ; DATA XREF: ListView::getAscii(uchar):$LN9o
.rdata:000001A8                 unicode 0, <SUB>,0
.rdata:000001B0 ; wchar_t _SG123307
.rdata:000001B0 $SG123307:                              ; DATA XREF: ListView::getAscii(uchar):$LN8o
.rdata:000001B0                 unicode 0, <ESC>,0
.rdata:000001B8 ; wchar_t _SG123309
.rdata:000001B8 $SG123309:                              ; DATA XREF: ListView::getAscii(uchar):$LN7o
.rdata:000001B8                 unicode 0, <FS>,0
.rdata:000001BE                 align 10h
.rdata:000001C0 ; wchar_t _SG123311
.rdata:000001C0 $SG123311:                              ; DATA XREF: ListView::getAscii(uchar):$LN6_2o
.rdata:000001C0                 unicode 0, <GS>,0
.rdata:000001C6                 align 4
.rdata:000001C8 ; wchar_t _SG123313
.rdata:000001C8 $SG123313:                              ; DATA XREF: ListView::getAscii(uchar):$LN5o
.rdata:000001C8                 unicode 0, <RS>,0
.rdata:000001CE                 align 10h
.rdata:000001D0 ; wchar_t _SG123315
.rdata:000001D0 $SG123315:                              ; DATA XREF: ListView::getAscii(uchar):$LN4o
.rdata:000001D0                 unicode 0, <US>,0
.rdata:000001D6                 align 4
.rdata:000001D8 ; wchar_t _SG123317
.rdata:000001D8 $SG123317:                              ; DATA XREF: ListView::getAscii(uchar):$LN3o
.rdata:000001D8                 unicode 0, <Space>,0
.rdata:000001E4 ; wchar_t _SG123319
.rdata:000001E4 $SG123319:                              ; DATA XREF: ListView::getAscii(uchar):$LN2o
.rdata:000001E4                 unicode 0, <DEL>,0
.rdata:000001EC ; wchar_t _SG123335
.rdata:000001EC $SG123335:                              ; DATA XREF: ListView::setValues(int)+64o
.rdata:000001EC                 unicode 0, <%d>,0
.rdata:000001F2                 align 4
.rdata:000001F4 ; wchar_t _SG123336
.rdata:000001F4 $SG123336:                              ; DATA XREF: ListView::setValues(int)+79o
.rdata:000001F4                 unicode 0, <%02X>,0
.rdata:000001FE                 align 10h
.rdata:000001FE _rdata          ends
.rdata:000001FE
.text$mn:00000200 ; ===========================================================================
.text$mn:00000200
.text$mn:00000200 ; Segment type: Pure code
.text$mn:00000200 ; Segment permissions: Read/Execute
.text$mn:00000200 _text$mn        segment para public 'CODE' use32
.text$mn:00000200                 assume cs:_text$mn
.text$mn:00000200                 ;org 200h
.text$mn:00000200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000200
.text$mn:00000200 ; =============== S U B R O U T I N E =======================================
.text$mn:00000200
.text$mn:00000200 ; Attributes: bp-based frame
.text$mn:00000200
.text$mn:00000200 ; void __thiscall ListView::init(ListView *this, HINSTANCE hInstance, HWND)
.text$mn:00000200                 public ?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:00000200 ?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:00000200
.text$mn:00000200 var_A8          = byte ptr -0A8h
.text$mn:00000200 var_9C          = dword ptr -9Ch
.text$mn:00000200 var_94          = dword ptr -94h
.text$mn:00000200 var_90          = dword ptr -90h
.text$mn:00000200 picce           = INITCOMMONCONTROLSEX ptr -7Ch
.text$mn:00000200 var_74          = dword ptr -74h
.text$mn:00000200 lParam          = dword ptr -70h
.text$mn:00000200 var_6C          = dword ptr -6Ch
.text$mn:00000200 dwNewLong       = dword ptr -68h
.text$mn:00000200 var_64          = byte ptr -64h
.text$mn:00000200 var_48          = byte ptr -48h
.text$mn:00000200 var_2C          = byte ptr -2Ch
.text$mn:00000200 var_10          = dword ptr -10h
.text$mn:00000200 var_C           = dword ptr -0Ch
.text$mn:00000200 var_4           = dword ptr -4
.text$mn:00000200 hInstance       = dword ptr  8
.text$mn:00000200 arg_4           = dword ptr  0Ch
.text$mn:00000200
.text$mn:00000200                 push    ebp
.text$mn:00000201                 mov     ebp, esp
.text$mn:00000203                 push    0FFFFFFFFh
.text$mn:00000205                 push    offset __ehhandler$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000020A                 mov     eax, large fs:0
.text$mn:00000210                 push    eax
.text$mn:00000211                 sub     esp, 9Ch
.text$mn:00000217                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000021C                 xor     eax, ebp
.text$mn:0000021E                 mov     [ebp+var_10], eax
.text$mn:00000221                 push    eax
.text$mn:00000222                 lea     eax, [ebp+var_C]
.text$mn:00000225                 mov     large fs:0, eax
.text$mn:0000022B                 mov     [ebp+dwNewLong], ecx
.text$mn:0000022E                 mov     eax, [ebp+arg_4]
.text$mn:00000231                 push    eax             ; HWND
.text$mn:00000232                 mov     ecx, [ebp+hInstance]
.text$mn:00000235                 push    ecx             ; HINSTANCE
.text$mn:00000236                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:00000239                 call    ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z ; Window::init(HINSTANCE__ *,HWND__ *)
.text$mn:0000023E                 mov     [ebp+picce.dwSize], 8
.text$mn:00000245                 mov     [ebp+picce.dwICC], 1
.text$mn:0000024C                 lea     edx, [ebp+picce]
.text$mn:0000024F                 push    edx             ; picce
.text$mn:00000250                 call    dword ptr ds:__imp__InitCommonControlsEx@4 ; InitCommonControlsEx(x)
.text$mn:00000256                 mov     [ebp+var_74], 814Dh
.text$mn:0000025D                 push    0               ; lpParam
.text$mn:0000025F                 mov     eax, [ebp+hInstance]
.text$mn:00000262                 push    eax             ; hInstance
.text$mn:00000263                 push    0               ; hMenu
.text$mn:00000265                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000268                 mov     edx, [ecx+8]
.text$mn:0000026B                 push    edx             ; hWndParent
.text$mn:0000026C                 push    0               ; nHeight
.text$mn:0000026E                 push    0               ; nWidth
.text$mn:00000270                 push    0               ; Y
.text$mn:00000272                 push    0               ; X
.text$mn:00000274                 mov     eax, [ebp+var_74]
.text$mn:00000277                 or      eax, 40000000h
.text$mn:0000027C                 push    eax             ; dwStyle
.text$mn:0000027D                 push    offset $SG123189 ; lpWindowName
.text$mn:00000282                 push    offset $SG123190 ; "SysListView32"
.text$mn:00000287                 push    0               ; dwExStyle
.text$mn:00000289                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:0000028F                 mov     ecx, [ebp+dwNewLong]
.text$mn:00000292                 mov     [ecx+0Ch], eax
.text$mn:00000295                 mov     edx, [ebp+dwNewLong]
.text$mn:00000298                 cmp     dword ptr [edx+0Ch], 0
.text$mn:0000029C                 jnz     short loc_2BF
.text$mn:0000029E                 push    offset $SG123194 ; "ListView::init : CreateWindowEx() funct"...
.text$mn:000002A3                 lea     ecx, [ebp+var_A8] ; this
.text$mn:000002A9                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000002AE                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000002B3                 lea     eax, [ebp+var_A8]
.text$mn:000002B9                 push    eax
.text$mn:000002BA                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000002BF ; ---------------------------------------------------------------------------
.text$mn:000002BF
.text$mn:000002BF loc_2BF:                                ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+9Cj
.text$mn:000002BF                 mov     ecx, [ebp+dwNewLong]
.text$mn:000002C2                 push    ecx             ; dwNewLong
.text$mn:000002C3                 push    0FFFFFFEBh      ; nIndex
.text$mn:000002C5                 mov     edx, [ebp+dwNewLong]
.text$mn:000002C8                 mov     eax, [edx+0Ch]
.text$mn:000002CB                 push    eax             ; hWnd
.text$mn:000002CC                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000002D2                 push    offset ?staticProc@ListView@@KGJPAUHWND__@@IIJ@Z ; dwNewLong
.text$mn:000002D7                 push    0FFFFFFFCh      ; nIndex
.text$mn:000002D9                 mov     ecx, [ebp+dwNewLong]
.text$mn:000002DC                 mov     edx, [ecx+0Ch]
.text$mn:000002DF                 push    edx             ; hWnd
.text$mn:000002E0                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000002E6                 mov     ecx, [ebp+dwNewLong]
.text$mn:000002E9                 mov     [ecx+14h], eax
.text$mn:000002EC                 push    0               ; lParam
.text$mn:000002EE                 push    0               ; wParam
.text$mn:000002F0                 push    1037h           ; Msg
.text$mn:000002F5                 mov     edx, [ebp+dwNewLong]
.text$mn:000002F8                 mov     eax, [edx+0Ch]
.text$mn:000002FB                 push    eax             ; hWnd
.text$mn:000002FC                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000302                 mov     [ebp+lParam], eax
.text$mn:00000305                 mov     ecx, [ebp+lParam]
.text$mn:00000308                 or      ecx, 8020h
.text$mn:0000030E                 mov     [ebp+lParam], ecx
.text$mn:00000311                 mov     edx, [ebp+lParam]
.text$mn:00000314                 push    edx             ; lParam
.text$mn:00000315                 push    0               ; wParam
.text$mn:00000317                 push    1036h           ; Msg
.text$mn:0000031C                 mov     eax, [ebp+dwNewLong]
.text$mn:0000031F                 mov     ecx, [eax+0Ch]
.text$mn:00000322                 push    ecx             ; hWnd
.text$mn:00000323                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000329                 mov     [ebp+var_9C], 6
.text$mn:00000333                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00000338                 mov     ecx, eax        ; this
.text$mn:0000033A                 call    ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ ; NppParameters::getNativeLangSpeaker(void)
.text$mn:0000033F                 mov     [ebp+var_6C], eax
.text$mn:00000342                 push    offset $SG123205 ; "ColumnVal"
.text$mn:00000347                 push    offset $SG123206 ; "AsciiInsertion"
.text$mn:0000034C                 push    offset $SG123207 ; "Value"
.text$mn:00000351                 lea     edx, [ebp+var_48]
.text$mn:00000354                 push    edx
.text$mn:00000355                 mov     ecx, [ebp+var_6C]
.text$mn:00000358                 call    ?getAttrNameStr@NativeLangSpeaker@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WPBD1@Z ; NativeLangSpeaker::getAttrNameStr(wchar_t const *,char const *,char const *)
.text$mn:0000035D                 mov     [ebp+var_4], 0
.text$mn:00000364                 push    offset $SG123210 ; "ColumnHex"
.text$mn:00000369                 push    offset $SG123211 ; "AsciiInsertion"
.text$mn:0000036E                 push    offset $SG123212 ; "Hex"
.text$mn:00000373                 lea     eax, [ebp+var_2C]
.text$mn:00000376                 push    eax
.text$mn:00000377                 mov     ecx, [ebp+var_6C]
.text$mn:0000037A                 call    ?getAttrNameStr@NativeLangSpeaker@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WPBD1@Z ; NativeLangSpeaker::getAttrNameStr(wchar_t const *,char const *,char const *)
.text$mn:0000037F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00000383                 push    offset $SG123215 ; "ColumnChar"
.text$mn:00000388                 push    offset $SG123216 ; "AsciiInsertion"
.text$mn:0000038D                 push    offset $SG123217 ; "Character"
.text$mn:00000392                 lea     ecx, [ebp+var_64]
.text$mn:00000395                 push    ecx
.text$mn:00000396                 mov     ecx, [ebp+var_6C]
.text$mn:00000399                 call    ?getAttrNameStr@NativeLangSpeaker@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WPBD1@Z ; NativeLangSpeaker::getAttrNameStr(wchar_t const *,char const *,char const *)
.text$mn:0000039E                 mov     byte ptr [ebp+var_4], 2
.text$mn:000003A2                 mov     [ebp+var_94], 2Dh ; '-'
.text$mn:000003AC                 lea     ecx, [ebp+var_48]
.text$mn:000003AF                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000003B4                 mov     [ebp+var_90], eax
.text$mn:000003BA                 lea     edx, [ebp+var_9C]
.text$mn:000003C0                 push    edx             ; lParam
.text$mn:000003C1                 push    0               ; wParam
.text$mn:000003C3                 push    1061h           ; Msg
.text$mn:000003C8                 mov     eax, [ebp+dwNewLong]
.text$mn:000003CB                 mov     ecx, [eax+0Ch]
.text$mn:000003CE                 push    ecx             ; hWnd
.text$mn:000003CF                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000003D5                 mov     [ebp+var_94], 2Dh ; '-'
.text$mn:000003DF                 lea     ecx, [ebp+var_2C]
.text$mn:000003E2                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000003E7                 mov     [ebp+var_90], eax
.text$mn:000003ED                 lea     edx, [ebp+var_9C]
.text$mn:000003F3                 push    edx             ; lParam
.text$mn:000003F4                 push    1               ; wParam
.text$mn:000003F6                 push    1061h           ; Msg
.text$mn:000003FB                 mov     eax, [ebp+dwNewLong]
.text$mn:000003FE                 mov     ecx, [eax+0Ch]
.text$mn:00000401                 push    ecx             ; hWnd
.text$mn:00000402                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000408                 mov     [ebp+var_94], 46h ; 'F'
.text$mn:00000412                 lea     ecx, [ebp+var_64]
.text$mn:00000415                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:0000041A                 mov     [ebp+var_90], eax
.text$mn:00000420                 lea     edx, [ebp+var_9C]
.text$mn:00000426                 push    edx             ; lParam
.text$mn:00000427                 push    2               ; wParam
.text$mn:00000429                 push    1061h           ; Msg
.text$mn:0000042E                 mov     eax, [ebp+dwNewLong]
.text$mn:00000431                 mov     ecx, [eax+0Ch]
.text$mn:00000434                 push    ecx             ; hWnd
.text$mn:00000435                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000043B                 mov     byte ptr [ebp+var_4], 1
.text$mn:0000043F                 lea     ecx, [ebp+var_64]
.text$mn:00000442                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000447                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000044B                 lea     ecx, [ebp+var_2C]
.text$mn:0000044E                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000453                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000045A                 lea     ecx, [ebp+var_48]
.text$mn:0000045D                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:00000462                 mov     ecx, [ebp+var_C]
.text$mn:00000465                 mov     large fs:0, ecx
.text$mn:0000046C                 pop     ecx
.text$mn:0000046D                 mov     ecx, [ebp+var_10]
.text$mn:00000470                 xor     ecx, ebp
.text$mn:00000472                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000477                 mov     esp, ebp
.text$mn:00000479                 pop     ebp
.text$mn:0000047A                 retn    8
.text$mn:0000047A ?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:0000047A
.text$mn:0000047A ; ---------------------------------------------------------------------------
.text$mn:0000047D                 align 10h
.text$mn:00000480
.text$mn:00000480 ; =============== S U B R O U T I N E =======================================
.text$mn:00000480
.text$mn:00000480 ; Attributes: bp-based frame
.text$mn:00000480
.text$mn:00000480 ; void __thiscall ListView::destroy(ListView *__hidden this)
.text$mn:00000480                 public ?destroy@ListView@@UAEXXZ
.text$mn:00000480 ?destroy@ListView@@UAEXXZ proc near
.text$mn:00000480
.text$mn:00000480 var_4           = dword ptr -4
.text$mn:00000480
.text$mn:00000480                 push    ebp
.text$mn:00000481                 mov     ebp, esp
.text$mn:00000483                 push    ecx
.text$mn:00000484                 mov     [ebp+var_4], ecx
.text$mn:00000487                 mov     eax, [ebp+var_4]
.text$mn:0000048A                 mov     ecx, [eax+0Ch]
.text$mn:0000048D                 push    ecx             ; hWnd
.text$mn:0000048E                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:00000494                 mov     edx, [ebp+var_4]
.text$mn:00000497                 mov     dword ptr [edx+0Ch], 0
.text$mn:0000049E                 mov     esp, ebp
.text$mn:000004A0                 pop     ebp
.text$mn:000004A1                 retn
.text$mn:000004A1 ?destroy@ListView@@UAEXXZ endp
.text$mn:000004A1
.text$mn:000004A1 ; ---------------------------------------------------------------------------
.text$mn:000004A2                 align 10h
.text$mn:000004B0
.text$mn:000004B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000004B0
.text$mn:000004B0 ; Attributes: bp-based frame
.text$mn:000004B0
.text$mn:000004B0 ; void __thiscall ListView::setValues(ListView *this, int)
.text$mn:000004B0                 public ?setValues@ListView@@QAEXH@Z
.text$mn:000004B0 ?setValues@ListView@@QAEXH@Z proc near  ; CODE XREF: ListView::resetValues(int)+3Ep
.text$mn:000004B0
.text$mn:000004B0 var_F0          = dword ptr -0F0h
.text$mn:000004B0 var_E8          = dword ptr -0E8h
.text$mn:000004B0 var_DC          = dword ptr -0DCh
.text$mn:000004B0 var_BC          = dword ptr -0BCh
.text$mn:000004B0 var_B4          = dword ptr -0B4h
.text$mn:000004B0 var_A8          = dword ptr -0A8h
.text$mn:000004B0 lParam          = dword ptr -88h
.text$mn:000004B0 var_84          = dword ptr -84h
.text$mn:000004B0 var_80          = dword ptr -80h
.text$mn:000004B0 var_74          = dword ptr -74h
.text$mn:000004B0 var_54          = dword ptr -54h
.text$mn:000004B0 wParam          = dword ptr -50h
.text$mn:000004B0 var_4C          = byte ptr -4Ch
.text$mn:000004B0 Dest            = word ptr -30h
.text$mn:000004B0 var_20          = word ptr -20h
.text$mn:000004B0 var_10          = dword ptr -10h
.text$mn:000004B0 var_C           = dword ptr -0Ch
.text$mn:000004B0 var_4           = dword ptr -4
.text$mn:000004B0 arg_0           = dword ptr  8
.text$mn:000004B0
.text$mn:000004B0                 push    ebp
.text$mn:000004B1                 mov     ebp, esp
.text$mn:000004B3                 push    0FFFFFFFFh
.text$mn:000004B5                 push    offset __ehhandler$?setValues@ListView@@QAEXH@Z
.text$mn:000004BA                 mov     eax, large fs:0
.text$mn:000004C0                 push    eax
.text$mn:000004C1                 sub     esp, 0E4h
.text$mn:000004C7                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000004CC                 xor     eax, ebp
.text$mn:000004CE                 mov     [ebp+var_10], eax
.text$mn:000004D1                 push    eax
.text$mn:000004D2                 lea     eax, [ebp+var_C]
.text$mn:000004D5                 mov     large fs:0, eax
.text$mn:000004DB                 mov     [ebp+var_54], ecx
.text$mn:000004DE                 mov     eax, [ebp+var_54]
.text$mn:000004E1                 mov     ecx, [ebp+arg_0]
.text$mn:000004E4                 mov     [eax+10h], ecx
.text$mn:000004E7                 mov     [ebp+wParam], 0
.text$mn:000004EE                 jmp     short loc_4F9
.text$mn:000004F0 ; ---------------------------------------------------------------------------
.text$mn:000004F0
.text$mn:000004F0 loc_4F0:                                ; CODE XREF: ListView::setValues(int)+147j
.text$mn:000004F0                 mov     edx, [ebp+wParam]
.text$mn:000004F3                 add     edx, 1
.text$mn:000004F6                 mov     [ebp+wParam], edx
.text$mn:000004F9
.text$mn:000004F9 loc_4F9:                                ; CODE XREF: ListView::setValues(int)+3Ej
.text$mn:000004F9                 cmp     [ebp+wParam], 100h
.text$mn:00000500                 jge     loc_5FC
.text$mn:00000506                 mov     [ebp+lParam], 1
.text$mn:00000510                 mov     eax, [ebp+wParam]
.text$mn:00000513                 push    eax
.text$mn:00000514                 push    offset $SG123335 ; "%d"
.text$mn:00000519                 lea     ecx, [ebp+Dest]
.text$mn:0000051C                 push    ecx             ; Dest
.text$mn:0000051D                 call    ?swprintf@@YAHPA_WPB_WZZ ; swprintf(wchar_t *,wchar_t const *,...)
.text$mn:00000522                 add     esp, 0Ch
.text$mn:00000525                 mov     edx, [ebp+wParam]
.text$mn:00000528                 push    edx
.text$mn:00000529                 push    offset $SG123336 ; "%02X"
.text$mn:0000052E                 lea     eax, [ebp+var_20]
.text$mn:00000531                 push    eax             ; Dest
.text$mn:00000532                 call    ?swprintf@@YAHPA_WPB_WZZ ; swprintf(wchar_t *,wchar_t const *,...)
.text$mn:00000537                 add     esp, 0Ch
.text$mn:0000053A                 lea     ecx, [ebp+Dest]
.text$mn:0000053D                 mov     [ebp+var_74], ecx
.text$mn:00000540                 mov     edx, [ebp+wParam]
.text$mn:00000543                 mov     [ebp+var_84], edx
.text$mn:00000549                 mov     [ebp+var_80], 0
.text$mn:00000550                 lea     eax, [ebp+lParam]
.text$mn:00000556                 push    eax             ; lParam
.text$mn:00000557                 push    0               ; wParam
.text$mn:00000559                 push    104Dh           ; Msg
.text$mn:0000055E                 mov     ecx, [ebp+var_54]
.text$mn:00000561                 mov     edx, [ecx+0Ch]
.text$mn:00000564                 push    edx             ; hWnd
.text$mn:00000565                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000056B                 mov     [ebp+var_B4], 1
.text$mn:00000575                 lea     eax, [ebp+var_20]
.text$mn:00000578                 mov     [ebp+var_A8], eax
.text$mn:0000057E                 lea     ecx, [ebp+var_BC]
.text$mn:00000584                 push    ecx             ; lParam
.text$mn:00000585                 mov     edx, [ebp+wParam]
.text$mn:00000588                 push    edx             ; wParam
.text$mn:00000589                 push    1074h           ; Msg
.text$mn:0000058E                 mov     eax, [ebp+var_54]
.text$mn:00000591                 mov     ecx, [eax+0Ch]
.text$mn:00000594                 push    ecx             ; hWnd
.text$mn:00000595                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:0000059B                 movzx   edx, byte ptr [ebp+wParam]
.text$mn:0000059F                 push    edx
.text$mn:000005A0                 lea     eax, [ebp+var_4C]
.text$mn:000005A3                 push    eax
.text$mn:000005A4                 mov     ecx, [ebp+var_54]
.text$mn:000005A7                 call    ?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z ; ListView::getAscii(uchar)
.text$mn:000005AC                 mov     [ebp+var_4], 0
.text$mn:000005B3                 mov     [ebp+var_E8], 2
.text$mn:000005BD                 lea     ecx, [ebp+var_4C]
.text$mn:000005C0                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:000005C5                 mov     [ebp+var_DC], eax
.text$mn:000005CB                 lea     ecx, [ebp+var_F0]
.text$mn:000005D1                 push    ecx             ; lParam
.text$mn:000005D2                 mov     edx, [ebp+wParam]
.text$mn:000005D5                 push    edx             ; wParam
.text$mn:000005D6                 push    1074h           ; Msg
.text$mn:000005DB                 mov     eax, [ebp+var_54]
.text$mn:000005DE                 mov     ecx, [eax+0Ch]
.text$mn:000005E1                 push    ecx             ; hWnd
.text$mn:000005E2                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000005E8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000005EF                 lea     ecx, [ebp+var_4C]
.text$mn:000005F2                 call    ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$mn:000005F7                 jmp     loc_4F0
.text$mn:000005FC ; ---------------------------------------------------------------------------
.text$mn:000005FC
.text$mn:000005FC loc_5FC:                                ; CODE XREF: ListView::setValues(int)+50j
.text$mn:000005FC                 mov     ecx, [ebp+var_C]
.text$mn:000005FF                 mov     large fs:0, ecx
.text$mn:00000606                 pop     ecx
.text$mn:00000607                 mov     ecx, [ebp+var_10]
.text$mn:0000060A                 xor     ecx, ebp
.text$mn:0000060C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000611                 mov     esp, ebp
.text$mn:00000613                 pop     ebp
.text$mn:00000614                 retn    4
.text$mn:00000614 ?setValues@ListView@@QAEXH@Z endp
.text$mn:00000614
.text$mn:00000614 ; ---------------------------------------------------------------------------
.text$mn:00000617                 align 10h
.text$mn:00000620
.text$mn:00000620 ; =============== S U B R O U T I N E =======================================
.text$mn:00000620
.text$mn:00000620 ; Attributes: bp-based frame
.text$mn:00000620
.text$mn:00000620 ; void __thiscall ListView::resetValues(ListView *this, int)
.text$mn:00000620                 public ?resetValues@ListView@@QAEXH@Z
.text$mn:00000620 ?resetValues@ListView@@QAEXH@Z proc near
.text$mn:00000620
.text$mn:00000620 var_4           = dword ptr -4
.text$mn:00000620 arg_0           = dword ptr  8
.text$mn:00000620
.text$mn:00000620                 push    ebp
.text$mn:00000621                 mov     ebp, esp
.text$mn:00000623                 push    ecx
.text$mn:00000624                 mov     [ebp+var_4], ecx
.text$mn:00000627                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:0000062B                 jnz     short loc_634
.text$mn:0000062D                 mov     [ebp+arg_0], 0
.text$mn:00000634
.text$mn:00000634 loc_634:                                ; CODE XREF: ListView::resetValues(int)+Bj
.text$mn:00000634                 mov     eax, [ebp+var_4]
.text$mn:00000637                 mov     ecx, [eax+10h]
.text$mn:0000063A                 cmp     ecx, [ebp+arg_0]
.text$mn:0000063D                 jnz     short loc_641
.text$mn:0000063F                 jmp     short loc_663
.text$mn:00000641 ; ---------------------------------------------------------------------------
.text$mn:00000641
.text$mn:00000641 loc_641:                                ; CODE XREF: ListView::resetValues(int)+1Dj
.text$mn:00000641                 push    0               ; lParam
.text$mn:00000643                 push    0               ; wParam
.text$mn:00000645                 push    1009h           ; Msg
.text$mn:0000064A                 mov     edx, [ebp+var_4]
.text$mn:0000064D                 mov     eax, [edx+0Ch]
.text$mn:00000650                 push    eax             ; hWnd
.text$mn:00000651                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000657                 mov     ecx, [ebp+arg_0]
.text$mn:0000065A                 push    ecx             ; int
.text$mn:0000065B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000065E                 call    ?setValues@ListView@@QAEXH@Z ; ListView::setValues(int)
.text$mn:00000663
.text$mn:00000663 loc_663:                                ; CODE XREF: ListView::resetValues(int)+1Fj
.text$mn:00000663                 mov     esp, ebp
.text$mn:00000665                 pop     ebp
.text$mn:00000666                 retn    4
.text$mn:00000666 ?resetValues@ListView@@QAEXH@Z endp
.text$mn:00000666
.text$mn:00000666 ; ---------------------------------------------------------------------------
.text$mn:00000669                 align 10h
.text$mn:00000670
.text$mn:00000670 ; =============== S U B R O U T I N E =======================================
.text$mn:00000670
.text$mn:00000670 ; Attributes: bp-based frame
.text$mn:00000670
.text$mn:00000670 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall ListView::getAscii(unsigned char)
.text$mn:00000670                 public ?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z
.text$mn:00000670 ?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z proc near
.text$mn:00000670                                         ; CODE XREF: ListView::setValues(int)+F7p
.text$mn:00000670
.text$mn:00000670 var_38          = dword ptr -38h
.text$mn:00000670 var_34          = dword ptr -34h
.text$mn:00000670 var_30          = dword ptr -30h
.text$mn:00000670 MultiByteStr    = byte ptr -2Ch
.text$mn:00000670 var_28          = dword ptr -28h
.text$mn:00000670 WideCharStr     = word ptr -24h
.text$mn:00000670 var_10          = dword ptr -10h
.text$mn:00000670 var_C           = dword ptr -0Ch
.text$mn:00000670 var_4           = dword ptr -4
.text$mn:00000670 arg_0           = dword ptr  8
.text$mn:00000670 arg_4           = byte ptr  0Ch
.text$mn:00000670
.text$mn:00000670                 push    ebp
.text$mn:00000671                 mov     ebp, esp
.text$mn:00000673                 push    0FFFFFFFFh
.text$mn:00000675                 push    offset __ehhandler$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z
.text$mn:0000067A                 mov     eax, large fs:0
.text$mn:00000680                 push    eax
.text$mn:00000681                 sub     esp, 2Ch
.text$mn:00000684                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000689                 xor     eax, ebp
.text$mn:0000068B                 mov     [ebp+var_10], eax
.text$mn:0000068E                 push    eax
.text$mn:0000068F                 lea     eax, [ebp+var_C]
.text$mn:00000692                 mov     large fs:0, eax
.text$mn:00000698                 mov     [ebp+var_38], ecx
.text$mn:0000069B                 mov     [ebp+var_28], 0
.text$mn:000006A2                 movzx   eax, [ebp+arg_4]
.text$mn:000006A6                 mov     [ebp+var_30], eax
.text$mn:000006A9                 cmp     [ebp+var_30], 7Fh ; '' ; switch 128 cases
.text$mn:000006AD                 ja      $LN1            ; jumptable 000006BD default case
.text$mn:000006B3                 mov     ecx, [ebp+var_30]
.text$mn:000006B6                 movzx   edx, ds:$LN44[ecx]
.text$mn:000006BD                 jmp     ds:$LN46[edx*4] ; switch jump
.text$mn:000006C4 ; ---------------------------------------------------------------------------
.text$mn:000006C4
.text$mn:000006C4 $LN35:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000006C4                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000006C4                 push    offset $SG123253 ; jumptable 000006BD case 0
.text$mn:000006C9                 mov     ecx, [ebp+arg_0]
.text$mn:000006CC                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000006D1                 mov     [ebp+var_4], 0
.text$mn:000006D8                 mov     eax, [ebp+var_28]
.text$mn:000006DB                 or      eax, 1
.text$mn:000006DE                 mov     [ebp+var_28], eax
.text$mn:000006E1                 mov     eax, [ebp+arg_0]
.text$mn:000006E4                 jmp     loc_C10
.text$mn:000006E9 ; ---------------------------------------------------------------------------
.text$mn:000006E9
.text$mn:000006E9 $LN34:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000006E9                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000006E9                 push    offset $SG123255 ; jumptable 000006BD case 1
.text$mn:000006EE                 mov     ecx, [ebp+arg_0]
.text$mn:000006F1                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000006F6                 mov     [ebp+var_4], 0
.text$mn:000006FD                 mov     ecx, [ebp+var_28]
.text$mn:00000700                 or      ecx, 1
.text$mn:00000703                 mov     [ebp+var_28], ecx
.text$mn:00000706                 mov     eax, [ebp+arg_0]
.text$mn:00000709                 jmp     loc_C10
.text$mn:0000070E ; ---------------------------------------------------------------------------
.text$mn:0000070E
.text$mn:0000070E $LN33:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:0000070E                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:0000070E                 push    offset $SG123257 ; jumptable 000006BD case 2
.text$mn:00000713                 mov     ecx, [ebp+arg_0]
.text$mn:00000716                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000071B                 mov     [ebp+var_4], 0
.text$mn:00000722                 mov     edx, [ebp+var_28]
.text$mn:00000725                 or      edx, 1
.text$mn:00000728                 mov     [ebp+var_28], edx
.text$mn:0000072B                 mov     eax, [ebp+arg_0]
.text$mn:0000072E                 jmp     loc_C10
.text$mn:00000733 ; ---------------------------------------------------------------------------
.text$mn:00000733
.text$mn:00000733 $LN32:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000733                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000733                 push    offset $SG123259 ; jumptable 000006BD case 3
.text$mn:00000738                 mov     ecx, [ebp+arg_0]
.text$mn:0000073B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000740                 mov     [ebp+var_4], 0
.text$mn:00000747                 mov     eax, [ebp+var_28]
.text$mn:0000074A                 or      eax, 1
.text$mn:0000074D                 mov     [ebp+var_28], eax
.text$mn:00000750                 mov     eax, [ebp+arg_0]
.text$mn:00000753                 jmp     loc_C10
.text$mn:00000758 ; ---------------------------------------------------------------------------
.text$mn:00000758
.text$mn:00000758 $LN31:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000758                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000758                 push    offset $SG123261 ; jumptable 000006BD case 4
.text$mn:0000075D                 mov     ecx, [ebp+arg_0]
.text$mn:00000760                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000765                 mov     [ebp+var_4], 0
.text$mn:0000076C                 mov     ecx, [ebp+var_28]
.text$mn:0000076F                 or      ecx, 1
.text$mn:00000772                 mov     [ebp+var_28], ecx
.text$mn:00000775                 mov     eax, [ebp+arg_0]
.text$mn:00000778                 jmp     loc_C10
.text$mn:0000077D ; ---------------------------------------------------------------------------
.text$mn:0000077D
.text$mn:0000077D $LN30:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:0000077D                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:0000077D                 push    offset $SG123263 ; jumptable 000006BD case 5
.text$mn:00000782                 mov     ecx, [ebp+arg_0]
.text$mn:00000785                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000078A                 mov     [ebp+var_4], 0
.text$mn:00000791                 mov     edx, [ebp+var_28]
.text$mn:00000794                 or      edx, 1
.text$mn:00000797                 mov     [ebp+var_28], edx
.text$mn:0000079A                 mov     eax, [ebp+arg_0]
.text$mn:0000079D                 jmp     loc_C10
.text$mn:000007A2 ; ---------------------------------------------------------------------------
.text$mn:000007A2
.text$mn:000007A2 $LN29:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000007A2                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000007A2                 push    offset $SG123265 ; jumptable 000006BD case 6
.text$mn:000007A7                 mov     ecx, [ebp+arg_0]
.text$mn:000007AA                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000007AF                 mov     [ebp+var_4], 0
.text$mn:000007B6                 mov     eax, [ebp+var_28]
.text$mn:000007B9                 or      eax, 1
.text$mn:000007BC                 mov     [ebp+var_28], eax
.text$mn:000007BF                 mov     eax, [ebp+arg_0]
.text$mn:000007C2                 jmp     loc_C10
.text$mn:000007C7 ; ---------------------------------------------------------------------------
.text$mn:000007C7
.text$mn:000007C7 $LN28:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000007C7                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000007C7                 push    offset $SG123267 ; jumptable 000006BD case 7
.text$mn:000007CC                 mov     ecx, [ebp+arg_0]
.text$mn:000007CF                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000007D4                 mov     [ebp+var_4], 0
.text$mn:000007DB                 mov     ecx, [ebp+var_28]
.text$mn:000007DE                 or      ecx, 1
.text$mn:000007E1                 mov     [ebp+var_28], ecx
.text$mn:000007E4                 mov     eax, [ebp+arg_0]
.text$mn:000007E7                 jmp     loc_C10
.text$mn:000007EC ; ---------------------------------------------------------------------------
.text$mn:000007EC
.text$mn:000007EC $LN27:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000007EC                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000007EC                 push    offset $SG123269 ; jumptable 000006BD case 8
.text$mn:000007F1                 mov     ecx, [ebp+arg_0]
.text$mn:000007F4                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000007F9                 mov     [ebp+var_4], 0
.text$mn:00000800                 mov     edx, [ebp+var_28]
.text$mn:00000803                 or      edx, 1
.text$mn:00000806                 mov     [ebp+var_28], edx
.text$mn:00000809                 mov     eax, [ebp+arg_0]
.text$mn:0000080C                 jmp     loc_C10
.text$mn:00000811 ; ---------------------------------------------------------------------------
.text$mn:00000811
.text$mn:00000811 $LN26:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000811                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000811                 push    offset $SG123271 ; jumptable 000006BD case 9
.text$mn:00000816                 mov     ecx, [ebp+arg_0]
.text$mn:00000819                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000081E                 mov     [ebp+var_4], 0
.text$mn:00000825                 mov     eax, [ebp+var_28]
.text$mn:00000828                 or      eax, 1
.text$mn:0000082B                 mov     [ebp+var_28], eax
.text$mn:0000082E                 mov     eax, [ebp+arg_0]
.text$mn:00000831                 jmp     loc_C10
.text$mn:00000836 ; ---------------------------------------------------------------------------
.text$mn:00000836
.text$mn:00000836 $LN25:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000836                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000836                 push    offset $SG123273 ; jumptable 000006BD case 10
.text$mn:0000083B                 mov     ecx, [ebp+arg_0]
.text$mn:0000083E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000843                 mov     [ebp+var_4], 0
.text$mn:0000084A                 mov     ecx, [ebp+var_28]
.text$mn:0000084D                 or      ecx, 1
.text$mn:00000850                 mov     [ebp+var_28], ecx
.text$mn:00000853                 mov     eax, [ebp+arg_0]
.text$mn:00000856                 jmp     loc_C10
.text$mn:0000085B ; ---------------------------------------------------------------------------
.text$mn:0000085B
.text$mn:0000085B $LN24:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:0000085B                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:0000085B                 push    offset $SG123275 ; jumptable 000006BD case 11
.text$mn:00000860                 mov     ecx, [ebp+arg_0]
.text$mn:00000863                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000868                 mov     [ebp+var_4], 0
.text$mn:0000086F                 mov     edx, [ebp+var_28]
.text$mn:00000872                 or      edx, 1
.text$mn:00000875                 mov     [ebp+var_28], edx
.text$mn:00000878                 mov     eax, [ebp+arg_0]
.text$mn:0000087B                 jmp     loc_C10
.text$mn:00000880 ; ---------------------------------------------------------------------------
.text$mn:00000880
.text$mn:00000880 $LN23:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000880                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000880                 push    offset $SG123277 ; jumptable 000006BD case 12
.text$mn:00000885                 mov     ecx, [ebp+arg_0]
.text$mn:00000888                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000088D                 mov     [ebp+var_4], 0
.text$mn:00000894                 mov     eax, [ebp+var_28]
.text$mn:00000897                 or      eax, 1
.text$mn:0000089A                 mov     [ebp+var_28], eax
.text$mn:0000089D                 mov     eax, [ebp+arg_0]
.text$mn:000008A0                 jmp     loc_C10
.text$mn:000008A5 ; ---------------------------------------------------------------------------
.text$mn:000008A5
.text$mn:000008A5 $LN22:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000008A5                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000008A5                 push    offset $SG123279 ; jumptable 000006BD case 13
.text$mn:000008AA                 mov     ecx, [ebp+arg_0]
.text$mn:000008AD                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000008B2                 mov     [ebp+var_4], 0
.text$mn:000008B9                 mov     ecx, [ebp+var_28]
.text$mn:000008BC                 or      ecx, 1
.text$mn:000008BF                 mov     [ebp+var_28], ecx
.text$mn:000008C2                 mov     eax, [ebp+arg_0]
.text$mn:000008C5                 jmp     loc_C10
.text$mn:000008CA ; ---------------------------------------------------------------------------
.text$mn:000008CA
.text$mn:000008CA $LN21:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000008CA                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000008CA                 push    offset $SG123281 ; jumptable 000006BD case 14
.text$mn:000008CF                 mov     ecx, [ebp+arg_0]
.text$mn:000008D2                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000008D7                 mov     [ebp+var_4], 0
.text$mn:000008DE                 mov     edx, [ebp+var_28]
.text$mn:000008E1                 or      edx, 1
.text$mn:000008E4                 mov     [ebp+var_28], edx
.text$mn:000008E7                 mov     eax, [ebp+arg_0]
.text$mn:000008EA                 jmp     loc_C10
.text$mn:000008EF ; ---------------------------------------------------------------------------
.text$mn:000008EF
.text$mn:000008EF $LN20:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000008EF                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000008EF                 push    offset $SG123283 ; jumptable 000006BD case 15
.text$mn:000008F4                 mov     ecx, [ebp+arg_0]
.text$mn:000008F7                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000008FC                 mov     [ebp+var_4], 0
.text$mn:00000903                 mov     eax, [ebp+var_28]
.text$mn:00000906                 or      eax, 1
.text$mn:00000909                 mov     [ebp+var_28], eax
.text$mn:0000090C                 mov     eax, [ebp+arg_0]
.text$mn:0000090F                 jmp     loc_C10
.text$mn:00000914 ; ---------------------------------------------------------------------------
.text$mn:00000914
.text$mn:00000914 $LN19_1:                                ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000914                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000914                 push    offset $SG123285 ; jumptable 000006BD case 16
.text$mn:00000919                 mov     ecx, [ebp+arg_0]
.text$mn:0000091C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000921                 mov     [ebp+var_4], 0
.text$mn:00000928                 mov     ecx, [ebp+var_28]
.text$mn:0000092B                 or      ecx, 1
.text$mn:0000092E                 mov     [ebp+var_28], ecx
.text$mn:00000931                 mov     eax, [ebp+arg_0]
.text$mn:00000934                 jmp     loc_C10
.text$mn:00000939 ; ---------------------------------------------------------------------------
.text$mn:00000939
.text$mn:00000939 $LN18:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000939                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000939                 push    offset $SG123287 ; jumptable 000006BD case 17
.text$mn:0000093E                 mov     ecx, [ebp+arg_0]
.text$mn:00000941                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000946                 mov     [ebp+var_4], 0
.text$mn:0000094D                 mov     edx, [ebp+var_28]
.text$mn:00000950                 or      edx, 1
.text$mn:00000953                 mov     [ebp+var_28], edx
.text$mn:00000956                 mov     eax, [ebp+arg_0]
.text$mn:00000959                 jmp     loc_C10
.text$mn:0000095E ; ---------------------------------------------------------------------------
.text$mn:0000095E
.text$mn:0000095E $LN17_1:                                ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:0000095E                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:0000095E                 push    offset $SG123289 ; jumptable 000006BD case 18
.text$mn:00000963                 mov     ecx, [ebp+arg_0]
.text$mn:00000966                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:0000096B                 mov     [ebp+var_4], 0
.text$mn:00000972                 mov     eax, [ebp+var_28]
.text$mn:00000975                 or      eax, 1
.text$mn:00000978                 mov     [ebp+var_28], eax
.text$mn:0000097B                 mov     eax, [ebp+arg_0]
.text$mn:0000097E                 jmp     loc_C10
.text$mn:00000983 ; ---------------------------------------------------------------------------
.text$mn:00000983
.text$mn:00000983 $LN16:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000983                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000983                 push    offset $SG123291 ; jumptable 000006BD case 19
.text$mn:00000988                 mov     ecx, [ebp+arg_0]
.text$mn:0000098B                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000990                 mov     [ebp+var_4], 0
.text$mn:00000997                 mov     ecx, [ebp+var_28]
.text$mn:0000099A                 or      ecx, 1
.text$mn:0000099D                 mov     [ebp+var_28], ecx
.text$mn:000009A0                 mov     eax, [ebp+arg_0]
.text$mn:000009A3                 jmp     loc_C10
.text$mn:000009A8 ; ---------------------------------------------------------------------------
.text$mn:000009A8
.text$mn:000009A8 $LN15:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000009A8                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000009A8                 push    offset $SG123293 ; jumptable 000006BD case 20
.text$mn:000009AD                 mov     ecx, [ebp+arg_0]
.text$mn:000009B0                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000009B5                 mov     [ebp+var_4], 0
.text$mn:000009BC                 mov     edx, [ebp+var_28]
.text$mn:000009BF                 or      edx, 1
.text$mn:000009C2                 mov     [ebp+var_28], edx
.text$mn:000009C5                 mov     eax, [ebp+arg_0]
.text$mn:000009C8                 jmp     loc_C10
.text$mn:000009CD ; ---------------------------------------------------------------------------
.text$mn:000009CD
.text$mn:000009CD $LN14:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000009CD                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000009CD                 push    offset $SG123295 ; jumptable 000006BD case 21
.text$mn:000009D2                 mov     ecx, [ebp+arg_0]
.text$mn:000009D5                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000009DA                 mov     [ebp+var_4], 0
.text$mn:000009E1                 mov     eax, [ebp+var_28]
.text$mn:000009E4                 or      eax, 1
.text$mn:000009E7                 mov     [ebp+var_28], eax
.text$mn:000009EA                 mov     eax, [ebp+arg_0]
.text$mn:000009ED                 jmp     loc_C10
.text$mn:000009F2 ; ---------------------------------------------------------------------------
.text$mn:000009F2
.text$mn:000009F2 $LN13:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:000009F2                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:000009F2                 push    offset $SG123297 ; jumptable 000006BD case 22
.text$mn:000009F7                 mov     ecx, [ebp+arg_0]
.text$mn:000009FA                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:000009FF                 mov     [ebp+var_4], 0
.text$mn:00000A06                 mov     ecx, [ebp+var_28]
.text$mn:00000A09                 or      ecx, 1
.text$mn:00000A0C                 mov     [ebp+var_28], ecx
.text$mn:00000A0F                 mov     eax, [ebp+arg_0]
.text$mn:00000A12                 jmp     loc_C10
.text$mn:00000A17 ; ---------------------------------------------------------------------------
.text$mn:00000A17
.text$mn:00000A17 $LN12:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000A17                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000A17                 push    offset $SG123299 ; jumptable 000006BD case 23
.text$mn:00000A1C                 mov     ecx, [ebp+arg_0]
.text$mn:00000A1F                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000A24                 mov     [ebp+var_4], 0
.text$mn:00000A2B                 mov     edx, [ebp+var_28]
.text$mn:00000A2E                 or      edx, 1
.text$mn:00000A31                 mov     [ebp+var_28], edx
.text$mn:00000A34                 mov     eax, [ebp+arg_0]
.text$mn:00000A37                 jmp     loc_C10
.text$mn:00000A3C ; ---------------------------------------------------------------------------
.text$mn:00000A3C
.text$mn:00000A3C $LN11:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000A3C                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000A3C                 push    offset $SG123301 ; jumptable 000006BD case 24
.text$mn:00000A41                 mov     ecx, [ebp+arg_0]
.text$mn:00000A44                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000A49                 mov     [ebp+var_4], 0
.text$mn:00000A50                 mov     eax, [ebp+var_28]
.text$mn:00000A53                 or      eax, 1
.text$mn:00000A56                 mov     [ebp+var_28], eax
.text$mn:00000A59                 mov     eax, [ebp+arg_0]
.text$mn:00000A5C                 jmp     loc_C10
.text$mn:00000A61 ; ---------------------------------------------------------------------------
.text$mn:00000A61
.text$mn:00000A61 $LN10:                                  ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000A61                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000A61                 push    offset $SG123303 ; jumptable 000006BD case 25
.text$mn:00000A66                 mov     ecx, [ebp+arg_0]
.text$mn:00000A69                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000A6E                 mov     [ebp+var_4], 0
.text$mn:00000A75                 mov     ecx, [ebp+var_28]
.text$mn:00000A78                 or      ecx, 1
.text$mn:00000A7B                 mov     [ebp+var_28], ecx
.text$mn:00000A7E                 mov     eax, [ebp+arg_0]
.text$mn:00000A81                 jmp     loc_C10
.text$mn:00000A86 ; ---------------------------------------------------------------------------
.text$mn:00000A86
.text$mn:00000A86 $LN9:                                   ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000A86                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000A86                 push    offset $SG123305 ; jumptable 000006BD case 26
.text$mn:00000A8B                 mov     ecx, [ebp+arg_0]
.text$mn:00000A8E                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000A93                 mov     [ebp+var_4], 0
.text$mn:00000A9A                 mov     edx, [ebp+var_28]
.text$mn:00000A9D                 or      edx, 1
.text$mn:00000AA0                 mov     [ebp+var_28], edx
.text$mn:00000AA3                 mov     eax, [ebp+arg_0]
.text$mn:00000AA6                 jmp     loc_C10
.text$mn:00000AAB ; ---------------------------------------------------------------------------
.text$mn:00000AAB
.text$mn:00000AAB $LN8:                                   ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000AAB                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000AAB                 push    offset $SG123307 ; jumptable 000006BD case 27
.text$mn:00000AB0                 mov     ecx, [ebp+arg_0]
.text$mn:00000AB3                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000AB8                 mov     [ebp+var_4], 0
.text$mn:00000ABF                 mov     eax, [ebp+var_28]
.text$mn:00000AC2                 or      eax, 1
.text$mn:00000AC5                 mov     [ebp+var_28], eax
.text$mn:00000AC8                 mov     eax, [ebp+arg_0]
.text$mn:00000ACB                 jmp     loc_C10
.text$mn:00000AD0 ; ---------------------------------------------------------------------------
.text$mn:00000AD0
.text$mn:00000AD0 $LN7:                                   ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000AD0                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000AD0                 push    offset $SG123309 ; jumptable 000006BD case 28
.text$mn:00000AD5                 mov     ecx, [ebp+arg_0]
.text$mn:00000AD8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000ADD                 mov     [ebp+var_4], 0
.text$mn:00000AE4                 mov     ecx, [ebp+var_28]
.text$mn:00000AE7                 or      ecx, 1
.text$mn:00000AEA                 mov     [ebp+var_28], ecx
.text$mn:00000AED                 mov     eax, [ebp+arg_0]
.text$mn:00000AF0                 jmp     loc_C10
.text$mn:00000AF5 ; ---------------------------------------------------------------------------
.text$mn:00000AF5
.text$mn:00000AF5 $LN6_2:                                 ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000AF5                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000AF5                 push    offset $SG123311 ; jumptable 000006BD case 29
.text$mn:00000AFA                 mov     ecx, [ebp+arg_0]
.text$mn:00000AFD                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000B02                 mov     [ebp+var_4], 0
.text$mn:00000B09                 mov     edx, [ebp+var_28]
.text$mn:00000B0C                 or      edx, 1
.text$mn:00000B0F                 mov     [ebp+var_28], edx
.text$mn:00000B12                 mov     eax, [ebp+arg_0]
.text$mn:00000B15                 jmp     loc_C10
.text$mn:00000B1A ; ---------------------------------------------------------------------------
.text$mn:00000B1A
.text$mn:00000B1A $LN5:                                   ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000B1A                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000B1A                 push    offset $SG123313 ; jumptable 000006BD case 30
.text$mn:00000B1F                 mov     ecx, [ebp+arg_0]
.text$mn:00000B22                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000B27                 mov     [ebp+var_4], 0
.text$mn:00000B2E                 mov     eax, [ebp+var_28]
.text$mn:00000B31                 or      eax, 1
.text$mn:00000B34                 mov     [ebp+var_28], eax
.text$mn:00000B37                 mov     eax, [ebp+arg_0]
.text$mn:00000B3A                 jmp     loc_C10
.text$mn:00000B3F ; ---------------------------------------------------------------------------
.text$mn:00000B3F
.text$mn:00000B3F $LN4:                                   ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000B3F                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000B3F                 push    offset $SG123315 ; jumptable 000006BD case 31
.text$mn:00000B44                 mov     ecx, [ebp+arg_0]
.text$mn:00000B47                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000B4C                 mov     [ebp+var_4], 0
.text$mn:00000B53                 mov     ecx, [ebp+var_28]
.text$mn:00000B56                 or      ecx, 1
.text$mn:00000B59                 mov     [ebp+var_28], ecx
.text$mn:00000B5C                 mov     eax, [ebp+arg_0]
.text$mn:00000B5F                 jmp     loc_C10
.text$mn:00000B64 ; ---------------------------------------------------------------------------
.text$mn:00000B64
.text$mn:00000B64 $LN3:                                   ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000B64                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000B64                 push    offset $SG123317 ; jumptable 000006BD case 32
.text$mn:00000B69                 mov     ecx, [ebp+arg_0]
.text$mn:00000B6C                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000B71                 mov     [ebp+var_4], 0
.text$mn:00000B78                 mov     edx, [ebp+var_28]
.text$mn:00000B7B                 or      edx, 1
.text$mn:00000B7E                 mov     [ebp+var_28], edx
.text$mn:00000B81                 mov     eax, [ebp+arg_0]
.text$mn:00000B84                 jmp     loc_C10
.text$mn:00000B89 ; ---------------------------------------------------------------------------
.text$mn:00000B89
.text$mn:00000B89 $LN2:                                   ; CODE XREF: ListView::getAscii(uchar)+4Dj
.text$mn:00000B89                                         ; DATA XREF: .text$mn:$LN46o
.text$mn:00000B89                 push    offset $SG123319 ; jumptable 000006BD case 127
.text$mn:00000B8E                 mov     ecx, [ebp+arg_0]
.text$mn:00000B91                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000B96                 mov     [ebp+var_4], 0
.text$mn:00000B9D                 mov     eax, [ebp+var_28]
.text$mn:00000BA0                 or      eax, 1
.text$mn:00000BA3                 mov     [ebp+var_28], eax
.text$mn:00000BA6                 mov     eax, [ebp+arg_0]
.text$mn:00000BA9                 jmp     short loc_C10
.text$mn:00000BAB ; ---------------------------------------------------------------------------
.text$mn:00000BAB
.text$mn:00000BAB $LN1:                                   ; CODE XREF: ListView::getAscii(uchar)+3Dj
.text$mn:00000BAB                                         ; ListView::getAscii(uchar)+4Dj
.text$mn:00000BAB                                         ; DATA XREF: ...
.text$mn:00000BAB                 mov     ecx, 1          ; jumptable 000006BD default case
.text$mn:00000BB0                 imul    edx, ecx, 0
.text$mn:00000BB3                 mov     al, [ebp+arg_4]
.text$mn:00000BB6                 mov     [ebp+edx+MultiByteStr], al
.text$mn:00000BBA                 mov     [ebp+var_34], 1
.text$mn:00000BC1                 cmp     [ebp+var_34], 2
.text$mn:00000BC5                 jnb     short loc_BC9
.text$mn:00000BC7                 jmp     short loc_BCE
.text$mn:00000BC9 ; ---------------------------------------------------------------------------
.text$mn:00000BC9
.text$mn:00000BC9 loc_BC9:                                ; CODE XREF: ListView::getAscii(uchar)+555j
.text$mn:00000BC9                 call    ___report_rangecheckfailure
.text$mn:00000BCE
.text$mn:00000BCE loc_BCE:                                ; CODE XREF: ListView::getAscii(uchar)+557j
.text$mn:00000BCE                 mov     ecx, [ebp+var_34]
.text$mn:00000BD1                 mov     [ebp+ecx+MultiByteStr], 0
.text$mn:00000BD6                 push    14h             ; cchWideChar
.text$mn:00000BD8                 lea     edx, [ebp+WideCharStr]
.text$mn:00000BDB                 push    edx             ; lpWideCharStr
.text$mn:00000BDC                 push    0FFFFFFFFh      ; cbMultiByte
.text$mn:00000BDE                 lea     eax, [ebp+MultiByteStr]
.text$mn:00000BE1                 push    eax             ; lpMultiByteStr
.text$mn:00000BE2                 push    0               ; dwFlags
.text$mn:00000BE4                 mov     ecx, [ebp+var_38]
.text$mn:00000BE7                 mov     edx, [ecx+10h]
.text$mn:00000BEA                 push    edx             ; CodePage
.text$mn:00000BEB                 call    dword ptr ds:__imp__MultiByteToWideChar@24 ; MultiByteToWideChar(x,x,x,x,x,x)
.text$mn:00000BF1                 lea     eax, [ebp+WideCharStr]
.text$mn:00000BF4                 push    eax             ; Str
.text$mn:00000BF5                 mov     ecx, [ebp+arg_0]
.text$mn:00000BF8                 call    ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)
.text$mn:00000BFD                 mov     [ebp+var_4], 0
.text$mn:00000C04                 mov     ecx, [ebp+var_28]
.text$mn:00000C07                 or      ecx, 1
.text$mn:00000C0A                 mov     [ebp+var_28], ecx
.text$mn:00000C0D                 mov     eax, [ebp+arg_0]
.text$mn:00000C10
.text$mn:00000C10 loc_C10:                                ; CODE XREF: ListView::getAscii(uchar)+74j
.text$mn:00000C10                                         ; ListView::getAscii(uchar)+99j ...
.text$mn:00000C10                 mov     ecx, [ebp+var_C]
.text$mn:00000C13                 mov     large fs:0, ecx
.text$mn:00000C1A                 pop     ecx
.text$mn:00000C1B                 mov     ecx, [ebp+var_10]
.text$mn:00000C1E                 xor     ecx, ebp
.text$mn:00000C20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000C25                 mov     esp, ebp
.text$mn:00000C27                 pop     ebp
.text$mn:00000C28                 retn    8
.text$mn:00000C28 ?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z endp
.text$mn:00000C28
.text$mn:00000C28 ; ---------------------------------------------------------------------------
.text$mn:00000C2B                 align 4
.text$mn:00000C2C $LN46           dd offset $LN35, offset $LN34, offset $LN33, offset $LN32
.text$mn:00000C2C                                         ; DATA XREF: ListView::getAscii(uchar)+4Dr
.text$mn:00000C2C                 dd offset $LN31, offset $LN30, offset $LN29, offset $LN28 ; jump table for switch statement
.text$mn:00000C2C                 dd offset $LN27, offset $LN26, offset $LN25, offset $LN24
.text$mn:00000C2C                 dd offset $LN23, offset $LN22, offset $LN21, offset $LN20
.text$mn:00000C2C                 dd offset $LN19_1, offset $LN18, offset $LN17_1, offset $LN16
.text$mn:00000C2C                 dd offset $LN15, offset $LN14, offset $LN13, offset $LN12
.text$mn:00000C2C                 dd offset $LN11, offset $LN10, offset $LN9, offset $LN8
.text$mn:00000C2C                 dd offset $LN7, offset $LN6_2, offset $LN5, offset $LN4
.text$mn:00000C2C                 dd offset $LN3, offset $LN2, offset $LN1
.text$mn:00000CB8 $LN44           db      0,     1,     2,     3
.text$mn:00000CB8                                         ; DATA XREF: ListView::getAscii(uchar)+46r
.text$mn:00000CB8                 db      4,     5,     6,     7 ; indirect table for switch statement
.text$mn:00000CB8                 db      8,     9,   0Ah,   0Bh
.text$mn:00000CB8                 db    0Ch,   0Dh,   0Eh,   0Fh
.text$mn:00000CB8                 db    10h,   11h,   12h,   13h
.text$mn:00000CB8                 db    14h,   15h,   16h,   17h
.text$mn:00000CB8                 db    18h,   19h,   1Ah,   1Bh
.text$mn:00000CB8                 db    1Ch,   1Dh,   1Eh,   1Fh
.text$mn:00000CB8                 db    20h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   22h
.text$mn:00000CB8                 db    22h,   22h,   22h,   21h
.text$mn:00000D38                 align 10h
.text$mn:00000D40
.text$mn:00000D40 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D40
.text$mn:00000D40 ; Attributes: bp-based frame
.text$mn:00000D40
.text$mn:00000D40 ; __int32 __thiscall ListView::runProc(ListView *this, HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00000D40                 public ?runProc@ListView@@IAEJPAUHWND__@@IIJ@Z
.text$mn:00000D40 ?runProc@ListView@@IAEJPAUHWND__@@IIJ@Z proc near
.text$mn:00000D40                                         ; CODE XREF: ListView::staticProc(HWND__ *,uint,uint,long)+21p
.text$mn:00000D40
.text$mn:00000D40 var_4           = dword ptr -4
.text$mn:00000D40 hWnd            = dword ptr  8
.text$mn:00000D40 Msg             = dword ptr  0Ch
.text$mn:00000D40 wParam          = dword ptr  10h
.text$mn:00000D40 lParam          = dword ptr  14h
.text$mn:00000D40
.text$mn:00000D40                 push    ebp
.text$mn:00000D41                 mov     ebp, esp
.text$mn:00000D43                 push    ecx
.text$mn:00000D44                 mov     [ebp+var_4], ecx
.text$mn:00000D47                 mov     eax, [ebp+lParam]
.text$mn:00000D4A                 push    eax             ; lParam
.text$mn:00000D4B                 mov     ecx, [ebp+wParam]
.text$mn:00000D4E                 push    ecx             ; wParam
.text$mn:00000D4F                 mov     edx, [ebp+Msg]
.text$mn:00000D52                 push    edx             ; Msg
.text$mn:00000D53                 mov     eax, [ebp+hWnd]
.text$mn:00000D56                 push    eax             ; hWnd
.text$mn:00000D57                 mov     ecx, [ebp+var_4]
.text$mn:00000D5A                 mov     edx, [ecx+14h]
.text$mn:00000D5D                 push    edx             ; lpPrevWndFunc
.text$mn:00000D5E                 call    dword ptr ds:__imp__CallWindowProcW@20 ; CallWindowProcW(x,x,x,x,x)
.text$mn:00000D64                 mov     esp, ebp
.text$mn:00000D66                 pop     ebp
.text$mn:00000D67                 retn    10h
.text$mn:00000D67 ?runProc@ListView@@IAEJPAUHWND__@@IIJ@Z endp
.text$mn:00000D67
.text$mn:00000D67 ; ---------------------------------------------------------------------------
.text$mn:00000D6A                 align 4
.text$mn:00000D6A _text$mn        ends
.text$mn:00000D6A
.text$x:00000D6C ; ===========================================================================
.text$x:00000D6C
.text$x:00000D6C ; Segment type: Pure code
.text$x:00000D6C ; Segment permissions: Read/Execute
.text$x:00000D6C _text$x         segment para public 'CODE' use32
.text$x:00000D6C                 assume cs:_text$x
.text$x:00000D6C                 ;org 0D6Ch
.text$x:00000D6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000D6C
.text$x:00000D6C ; =============== S U B R O U T I N E =======================================
.text$x:00000D6C
.text$x:00000D6C
.text$x:00000D6C __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$0 proc near
.text$x:00000D6C                                         ; DATA XREF: .xdata$x:00003CCCo
.text$x:00000D6C                 lea     ecx, [ebp-48h]
.text$x:00000D6F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000D6F __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$0 endp
.text$x:00000D6F
.text$x:00000D74
.text$x:00000D74 ; =============== S U B R O U T I N E =======================================
.text$x:00000D74
.text$x:00000D74
.text$x:00000D74 __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$1 proc near
.text$x:00000D74                                         ; DATA XREF: .xdata$x:00003CD4o
.text$x:00000D74                 lea     ecx, [ebp-2Ch]
.text$x:00000D77                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000D77 __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$1 endp
.text$x:00000D77
.text$x:00000D7C
.text$x:00000D7C ; =============== S U B R O U T I N E =======================================
.text$x:00000D7C
.text$x:00000D7C
.text$x:00000D7C __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$2 proc near
.text$x:00000D7C                                         ; DATA XREF: .xdata$x:00003CDCo
.text$x:00000D7C                 lea     ecx, [ebp-64h]
.text$x:00000D7F                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000D7F __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$2 endp
.text$x:00000D7F
.text$x:00000D84
.text$x:00000D84 ; =============== S U B R O U T I N E =======================================
.text$x:00000D84
.text$x:00000D84
.text$x:00000D84 __ehhandler$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$x:00000D84                                         ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+5o
.text$x:00000D84
.text$x:00000D84 arg_4           = dword ptr  8
.text$x:00000D84
.text$x:00000D84                 mov     edx, [esp+arg_4]
.text$x:00000D88                 lea     eax, [edx+0Ch]
.text$x:00000D8B                 mov     ecx, [edx-0A0h]
.text$x:00000D91                 xor     ecx, eax
.text$x:00000D93                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000D98                 mov     ecx, [edx-4]
.text$x:00000D9B                 xor     ecx, eax
.text$x:00000D9D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DA2                 mov     eax, offset __ehfuncinfo$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$x:00000DA7                 jmp     ___CxxFrameHandler3
.text$x:00000DA7 __ehhandler$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$x:00000DA7
.text$x:00000DAC
.text$x:00000DAC ; =============== S U B R O U T I N E =======================================
.text$x:00000DAC
.text$x:00000DAC
.text$x:00000DAC __unwindfunclet$?setValues@ListView@@QAEXH@Z$0 proc near
.text$x:00000DAC                                         ; DATA XREF: .xdata$x:00003CC4o
.text$x:00000DAC                 lea     ecx, [ebp-4Ch]
.text$x:00000DAF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000DAF __unwindfunclet$?setValues@ListView@@QAEXH@Z$0 endp
.text$x:00000DAF
.text$x:00000DB4
.text$x:00000DB4 ; =============== S U B R O U T I N E =======================================
.text$x:00000DB4
.text$x:00000DB4
.text$x:00000DB4 __ehhandler$?setValues@ListView@@QAEXH@Z proc near
.text$x:00000DB4                                         ; DATA XREF: ListView::setValues(int)+5o
.text$x:00000DB4
.text$x:00000DB4 arg_4           = dword ptr  8
.text$x:00000DB4
.text$x:00000DB4                 mov     edx, [esp+arg_4]
.text$x:00000DB8                 lea     eax, [edx+0Ch]
.text$x:00000DBB                 mov     ecx, [edx-0E8h]
.text$x:00000DC1                 xor     ecx, eax
.text$x:00000DC3                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DC8                 mov     ecx, [edx-4]
.text$x:00000DCB                 xor     ecx, eax
.text$x:00000DCD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000DD2                 mov     eax, offset __ehfuncinfo$?setValues@ListView@@QAEXH@Z
.text$x:00000DD7                 jmp     ___CxxFrameHandler3
.text$x:00000DD7 __ehhandler$?setValues@ListView@@QAEXH@Z endp
.text$x:00000DD7
.text$x:00000DDC
.text$x:00000DDC ; =============== S U B R O U T I N E =======================================
.text$x:00000DDC
.text$x:00000DDC
.text$x:00000DDC __unwindfunclet$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z$0 proc near
.text$x:00000DDC                                         ; DATA XREF: .xdata$x:00003CBCo
.text$x:00000DDC                 mov     eax, [ebp-28h]
.text$x:00000DDF                 and     eax, 1
.text$x:00000DE2                 jz      locret_DF4
.text$x:00000DE8                 and     dword ptr [ebp-28h], 0FFFFFFFEh
.text$x:00000DEC                 mov     ecx, [ebp+8]
.text$x:00000DEF                 jmp     ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)
.text$x:00000DF4 ; ---------------------------------------------------------------------------
.text$x:00000DF4
.text$x:00000DF4 locret_DF4:                             ; CODE XREF: __unwindfunclet$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z$0+6j
.text$x:00000DF4                 retn
.text$x:00000DF4 __unwindfunclet$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z$0 endp
.text$x:00000DF4
.text$x:00000DF5
.text$x:00000DF5 ; =============== S U B R O U T I N E =======================================
.text$x:00000DF5
.text$x:00000DF5
.text$x:00000DF5 __ehhandler$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z proc near
.text$x:00000DF5                                         ; DATA XREF: ListView::getAscii(uchar)+5o
.text$x:00000DF5
.text$x:00000DF5 arg_4           = dword ptr  8
.text$x:00000DF5
.text$x:00000DF5                 mov     edx, [esp+arg_4]
.text$x:00000DF9                 lea     eax, [edx+0Ch]
.text$x:00000DFC                 mov     ecx, [edx-30h]
.text$x:00000DFF                 xor     ecx, eax
.text$x:00000E01                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E06                 mov     ecx, [edx-4]
.text$x:00000E09                 xor     ecx, eax
.text$x:00000E0B                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000E10                 mov     eax, offset __ehfuncinfo$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z
.text$x:00000E15                 jmp     ___CxxFrameHandler3
.text$x:00000E15 __ehhandler$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z endp
.text$x:00000E15
.text$x:00000E15 ; ---------------------------------------------------------------------------
.text$x:00000E1A                 align 4
.text$x:00000E1A _text$x         ends
.text$x:00000E1A
.text$mn:00000E1C ; ===========================================================================
.text$mn:00000E1C
.text$mn:00000E1C ; Segment type: Pure code
.text$mn:00000E1C ; Segment permissions: Read/Execute
.text$mn:00000E1C _text$mn        segment para public 'CODE' use32
.text$mn:00000E1C                 assume cs:_text$mn
.text$mn:00000E1C                 ;org 0E1Ch
.text$mn:00000E1C ; COMDAT (pick any)
.text$mn:00000E1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E1C
.text$mn:00000E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00000E1C
.text$mn:00000E1C ; Attributes: bp-based frame
.text$mn:00000E1C
.text$mn:00000E1C ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00000E1C                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00000E1C ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00000E1C                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00000E1C
.text$mn:00000E1C var_4           = dword ptr -4
.text$mn:00000E1C arg_0           = dword ptr  8
.text$mn:00000E1C
.text$mn:00000E1C                 push    ebp
.text$mn:00000E1D                 mov     ebp, esp
.text$mn:00000E1F                 push    ecx
.text$mn:00000E20                 mov     [ebp+var_4], 0
.text$mn:00000E27                 cmp     [ebp+arg_0], 0
.text$mn:00000E2B                 jnz     short loc_E2F
.text$mn:00000E2D                 jmp     short loc_E4F
.text$mn:00000E2F ; ---------------------------------------------------------------------------
.text$mn:00000E2F
.text$mn:00000E2F loc_E2F:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00000E2F                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00000E33                 ja      short loc_E4A
.text$mn:00000E35                 mov     eax, [ebp+arg_0]
.text$mn:00000E38                 push    eax             ; unsigned int
.text$mn:00000E39                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000E3E                 add     esp, 4
.text$mn:00000E41                 mov     [ebp+var_4], eax
.text$mn:00000E44                 cmp     [ebp+var_4], 0
.text$mn:00000E48                 jnz     short loc_E4F
.text$mn:00000E4A
.text$mn:00000E4A loc_E4A:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00000E4A                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000E4F
.text$mn:00000E4F loc_E4F:                                ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00000E4F                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00000E4F                 mov     eax, [ebp+var_4]
.text$mn:00000E52                 mov     esp, ebp
.text$mn:00000E54                 pop     ebp
.text$mn:00000E55                 retn
.text$mn:00000E55 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00000E55
.text$mn:00000E55 ; ---------------------------------------------------------------------------
.text$mn:00000E56                 align 4
.text$mn:00000E56 _text$mn        ends
.text$mn:00000E56
.text$mn:00000E58 ; ===========================================================================
.text$mn:00000E58
.text$mn:00000E58 ; Segment type: Pure code
.text$mn:00000E58 ; Segment permissions: Read/Execute
.text$mn:00000E58 _text$mn        segment para public 'CODE' use32
.text$mn:00000E58                 assume cs:_text$mn
.text$mn:00000E58                 ;org 0E58h
.text$mn:00000E58 ; COMDAT (pick any)
.text$mn:00000E58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E58
.text$mn:00000E58 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E58
.text$mn:00000E58 ; Attributes: bp-based frame
.text$mn:00000E58
.text$mn:00000E58 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00000E58                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00000E58 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00000E58                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00000E58
.text$mn:00000E58 var_4           = dword ptr -4
.text$mn:00000E58 arg_0           = dword ptr  8
.text$mn:00000E58
.text$mn:00000E58                 push    ebp
.text$mn:00000E59                 mov     ebp, esp
.text$mn:00000E5B                 push    ecx
.text$mn:00000E5C                 mov     [ebp+var_4], 0
.text$mn:00000E63                 cmp     [ebp+arg_0], 0
.text$mn:00000E67                 jnz     short loc_E6B
.text$mn:00000E69                 jmp     short loc_E91
.text$mn:00000E6B ; ---------------------------------------------------------------------------
.text$mn:00000E6B
.text$mn:00000E6B loc_E6B:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00000E6B                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00000E72                 ja      short loc_E8C
.text$mn:00000E74                 mov     eax, [ebp+arg_0]
.text$mn:00000E77                 shl     eax, 3
.text$mn:00000E7A                 push    eax             ; unsigned int
.text$mn:00000E7B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000E80                 add     esp, 4
.text$mn:00000E83                 mov     [ebp+var_4], eax
.text$mn:00000E86                 cmp     [ebp+var_4], 0
.text$mn:00000E8A                 jnz     short loc_E91
.text$mn:00000E8C
.text$mn:00000E8C loc_E8C:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00000E8C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000E91
.text$mn:00000E91 loc_E91:                                ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00000E91                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00000E91                 mov     eax, [ebp+var_4]
.text$mn:00000E94                 mov     esp, ebp
.text$mn:00000E96                 pop     ebp
.text$mn:00000E97                 retn
.text$mn:00000E97 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00000E97
.text$mn:00000E97 _text$mn        ends
.text$mn:00000E97
.text$mn:00000E98 ; ===========================================================================
.text$mn:00000E98
.text$mn:00000E98 ; Segment type: Pure code
.text$mn:00000E98 ; Segment permissions: Read/Execute
.text$mn:00000E98 _text$mn        segment para public 'CODE' use32
.text$mn:00000E98                 assume cs:_text$mn
.text$mn:00000E98                 ;org 0E98h
.text$mn:00000E98 ; COMDAT (pick any)
.text$mn:00000E98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000E98
.text$mn:00000E98 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E98
.text$mn:00000E98 ; Attributes: bp-based frame
.text$mn:00000E98
.text$mn:00000E98 ; wchar_t * __cdecl std::_Allocate<wchar_t>(unsigned int, wchar_t *)
.text$mn:00000E98                 public ??$_Allocate@_W@std@@YAPA_WIPA_W@Z
.text$mn:00000E98 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z proc near
.text$mn:00000E98                                         ; CODE XREF: std::allocator<wchar_t>::allocate(uint)+Dp
.text$mn:00000E98
.text$mn:00000E98 var_4           = dword ptr -4
.text$mn:00000E98 arg_0           = dword ptr  8
.text$mn:00000E98
.text$mn:00000E98                 push    ebp
.text$mn:00000E99                 mov     ebp, esp
.text$mn:00000E9B                 push    ecx
.text$mn:00000E9C                 mov     [ebp+var_4], 0
.text$mn:00000EA3                 cmp     [ebp+arg_0], 0
.text$mn:00000EA7                 jnz     short loc_EAB
.text$mn:00000EA9                 jmp     short loc_ED0
.text$mn:00000EAB ; ---------------------------------------------------------------------------
.text$mn:00000EAB
.text$mn:00000EAB loc_EAB:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+Fj
.text$mn:00000EAB                 cmp     [ebp+arg_0], 7FFFFFFFh
.text$mn:00000EB2                 ja      short loc_ECB
.text$mn:00000EB4                 mov     eax, [ebp+arg_0]
.text$mn:00000EB7                 shl     eax, 1
.text$mn:00000EB9                 push    eax             ; unsigned int
.text$mn:00000EBA                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00000EBF                 add     esp, 4
.text$mn:00000EC2                 mov     [ebp+var_4], eax
.text$mn:00000EC5                 cmp     [ebp+var_4], 0
.text$mn:00000EC9                 jnz     short loc_ED0
.text$mn:00000ECB
.text$mn:00000ECB loc_ECB:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+1Aj
.text$mn:00000ECB                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00000ED0
.text$mn:00000ED0 loc_ED0:                                ; CODE XREF: std::_Allocate<wchar_t>(uint,wchar_t *)+11j
.text$mn:00000ED0                                         ; std::_Allocate<wchar_t>(uint,wchar_t *)+31j
.text$mn:00000ED0                 mov     eax, [ebp+var_4]
.text$mn:00000ED3                 mov     esp, ebp
.text$mn:00000ED5                 pop     ebp
.text$mn:00000ED6                 retn
.text$mn:00000ED6 ??$_Allocate@_W@std@@YAPA_WIPA_W@Z endp
.text$mn:00000ED6
.text$mn:00000ED6 ; ---------------------------------------------------------------------------
.text$mn:00000ED7                 align 4
.text$mn:00000ED7 _text$mn        ends
.text$mn:00000ED7
.text$mn:00000ED8 ; ===========================================================================
.text$mn:00000ED8
.text$mn:00000ED8 ; Segment type: Pure code
.text$mn:00000ED8 ; Segment permissions: Read/Execute
.text$mn:00000ED8 _text$mn        segment para public 'CODE' use32
.text$mn:00000ED8                 assume cs:_text$mn
.text$mn:00000ED8                 ;org 0ED8h
.text$mn:00000ED8 ; COMDAT (pick any)
.text$mn:00000ED8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000ED8
.text$mn:00000ED8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000ED8
.text$mn:00000ED8 ; Attributes: bp-based frame
.text$mn:00000ED8
.text$mn:00000ED8 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00000ED8                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00000ED8 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00000ED8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00000ED8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00000ED8
.text$mn:00000ED8 arg_0           = dword ptr  8
.text$mn:00000ED8 arg_4           = dword ptr  0Ch
.text$mn:00000ED8 arg_8           = dword ptr  10h
.text$mn:00000ED8
.text$mn:00000ED8                 push    ebp
.text$mn:00000ED9                 mov     ebp, esp
.text$mn:00000EDB                 cmp     [ebp+arg_0], 0
.text$mn:00000EDF                 jnz     short loc_EF6
.text$mn:00000EE1                 mov     eax, [ebp+arg_8]
.text$mn:00000EE4                 push    eax             ; unsigned int
.text$mn:00000EE5                 mov     ecx, [ebp+arg_4]
.text$mn:00000EE8                 push    ecx             ; wchar_t *
.text$mn:00000EE9                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000EEE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000EF3                 add     esp, 0Ch
.text$mn:00000EF6
.text$mn:00000EF6 loc_EF6:                                ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00000EF6                 pop     ebp
.text$mn:00000EF7                 retn
.text$mn:00000EF7 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00000EF7
.text$mn:00000EF7 _text$mn        ends
.text$mn:00000EF7
.text$mn:00000EF8 ; ===========================================================================
.text$mn:00000EF8
.text$mn:00000EF8 ; Segment type: Pure code
.text$mn:00000EF8 ; Segment permissions: Read/Execute
.text$mn:00000EF8 _text$mn        segment para public 'CODE' use32
.text$mn:00000EF8                 assume cs:_text$mn
.text$mn:00000EF8                 ;org 0EF8h
.text$mn:00000EF8 ; COMDAT (pick any)
.text$mn:00000EF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000EF8
.text$mn:00000EF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00000EF8
.text$mn:00000EF8 ; Attributes: bp-based frame
.text$mn:00000EF8
.text$mn:00000EF8 ; int __cdecl std::_Debug_pointer<wchar_t>(int, wchar_t *, unsigned int)
.text$mn:00000EF8                 public ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z
.text$mn:00000EF8 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z proc near
.text$mn:00000EF8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+15p
.text$mn:00000EF8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+1Bp
.text$mn:00000EF8
.text$mn:00000EF8 arg_0           = dword ptr  8
.text$mn:00000EF8 arg_4           = dword ptr  0Ch
.text$mn:00000EF8 arg_8           = dword ptr  10h
.text$mn:00000EF8
.text$mn:00000EF8                 push    ebp
.text$mn:00000EF9                 mov     ebp, esp
.text$mn:00000EFB                 cmp     [ebp+arg_0], 0
.text$mn:00000EFF                 jnz     short loc_F16
.text$mn:00000F01                 mov     eax, [ebp+arg_8]
.text$mn:00000F04                 push    eax             ; unsigned int
.text$mn:00000F05                 mov     ecx, [ebp+arg_4]
.text$mn:00000F08                 push    ecx             ; wchar_t *
.text$mn:00000F09                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00000F0E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00000F13                 add     esp, 0Ch
.text$mn:00000F16
.text$mn:00000F16 loc_F16:                                ; CODE XREF: std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+7j
.text$mn:00000F16                 pop     ebp
.text$mn:00000F17                 retn
.text$mn:00000F17 ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z endp
.text$mn:00000F17
.text$mn:00000F17 _text$mn        ends
.text$mn:00000F17
.text$mn:00000F18 ; ===========================================================================
.text$mn:00000F18
.text$mn:00000F18 ; Segment type: Pure code
.text$mn:00000F18 ; Segment permissions: Read/Execute
.text$mn:00000F18 _text$mn        segment para public 'CODE' use32
.text$mn:00000F18                 assume cs:_text$mn
.text$mn:00000F18                 ;org 0F18h
.text$mn:00000F18 ; COMDAT (pick any)
.text$mn:00000F18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F18
.text$mn:00000F18 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F18
.text$mn:00000F18 ; Attributes: bp-based frame
.text$mn:00000F18
.text$mn:00000F18 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00000F18                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00000F18 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00000F18                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00000F18                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00000F18
.text$mn:00000F18 arg_0           = dword ptr  8
.text$mn:00000F18
.text$mn:00000F18                 push    ebp
.text$mn:00000F19                 mov     ebp, esp
.text$mn:00000F1B                 mov     eax, [ebp+arg_0]
.text$mn:00000F1E                 pop     ebp
.text$mn:00000F1F                 retn
.text$mn:00000F1F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00000F1F
.text$mn:00000F1F _text$mn        ends
.text$mn:00000F1F
.text$mn:00000F20 ; ===========================================================================
.text$mn:00000F20
.text$mn:00000F20 ; Segment type: Pure code
.text$mn:00000F20 ; Segment permissions: Read/Execute
.text$mn:00000F20 _text$mn        segment para public 'CODE' use32
.text$mn:00000F20                 assume cs:_text$mn
.text$mn:00000F20                 ;org 0F20h
.text$mn:00000F20 ; COMDAT (pick any)
.text$mn:00000F20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F20
.text$mn:00000F20 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F20
.text$mn:00000F20 ; Attributes: bp-based frame
.text$mn:00000F20
.text$mn:00000F20 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00000F20                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00000F20 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00000F20                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00000F20                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p ...
.text$mn:00000F20
.text$mn:00000F20 arg_0           = dword ptr  8
.text$mn:00000F20
.text$mn:00000F20                 push    ebp
.text$mn:00000F21                 mov     ebp, esp
.text$mn:00000F23                 mov     eax, [ebp+arg_0]
.text$mn:00000F26                 pop     ebp
.text$mn:00000F27                 retn
.text$mn:00000F27 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00000F27
.text$mn:00000F27 _text$mn        ends
.text$mn:00000F27
.text$mn:00000F28 ; ===========================================================================
.text$mn:00000F28
.text$mn:00000F28 ; Segment type: Pure code
.text$mn:00000F28 ; Segment permissions: Read/Execute
.text$mn:00000F28 _text$mn        segment para public 'CODE' use32
.text$mn:00000F28                 assume cs:_text$mn
.text$mn:00000F28                 ;org 0F28h
.text$mn:00000F28 ; COMDAT (pick any)
.text$mn:00000F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F28
.text$mn:00000F28 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F28
.text$mn:00000F28 ; Attributes: bp-based frame
.text$mn:00000F28
.text$mn:00000F28 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00000F28                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00000F28 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000F28                                         ; CODE XREF: $LN19+4Bp
.text$mn:00000F28
.text$mn:00000F28 var_4           = dword ptr -4
.text$mn:00000F28 arg_0           = dword ptr  8
.text$mn:00000F28 arg_4           = dword ptr  0Ch
.text$mn:00000F28
.text$mn:00000F28                 push    ebp
.text$mn:00000F29                 mov     ebp, esp
.text$mn:00000F2B                 push    ecx
.text$mn:00000F2C                 mov     [ebp+var_4], ecx
.text$mn:00000F2F                 mov     eax, [ebp+arg_4]
.text$mn:00000F32                 push    eax
.text$mn:00000F33                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000F38                 add     esp, 4
.text$mn:00000F3B                 push    eax             ; int
.text$mn:00000F3C                 mov     ecx, [ebp+arg_0]
.text$mn:00000F3F                 push    ecx             ; void *
.text$mn:00000F40                 mov     edx, [ebp+var_4]
.text$mn:00000F43                 push    edx             ; int
.text$mn:00000F44                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00000F49                 add     esp, 0Ch
.text$mn:00000F4C                 mov     esp, ebp
.text$mn:00000F4E                 pop     ebp
.text$mn:00000F4F                 retn    8
.text$mn:00000F4F ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000F4F
.text$mn:00000F4F ; ---------------------------------------------------------------------------
.text$mn:00000F52                 align 4
.text$mn:00000F52 _text$mn        ends
.text$mn:00000F52
.text$mn:00000F54 ; ===========================================================================
.text$mn:00000F54
.text$mn:00000F54 ; Segment type: Pure code
.text$mn:00000F54 ; Segment permissions: Read/Execute
.text$mn:00000F54 _text$mn        segment para public 'CODE' use32
.text$mn:00000F54                 assume cs:_text$mn
.text$mn:00000F54                 ;org 0F54h
.text$mn:00000F54 ; COMDAT (pick any)
.text$mn:00000F54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000F54
.text$mn:00000F54 ; =============== S U B R O U T I N E =======================================
.text$mn:00000F54
.text$mn:00000F54 ; Attributes: bp-based frame
.text$mn:00000F54
.text$mn:00000F54 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00000F54                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000F54 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00000F54                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00000F54
.text$mn:00000F54 var_1C          = dword ptr -1Ch
.text$mn:00000F54 var_18          = dword ptr -18h
.text$mn:00000F54 var_14          = dword ptr -14h
.text$mn:00000F54 var_10          = dword ptr -10h
.text$mn:00000F54 var_C           = dword ptr -0Ch
.text$mn:00000F54 var_4           = dword ptr -4
.text$mn:00000F54 arg_0           = dword ptr  8
.text$mn:00000F54 arg_4           = dword ptr  0Ch
.text$mn:00000F54
.text$mn:00000F54                 push    ebp
.text$mn:00000F55                 mov     ebp, esp
.text$mn:00000F57                 push    0FFFFFFFFh
.text$mn:00000F59                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00000F5E                 mov     eax, large fs:0
.text$mn:00000F64                 push    eax
.text$mn:00000F65                 sub     esp, 10h
.text$mn:00000F68                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000F6D                 xor     eax, ebp
.text$mn:00000F6F                 push    eax
.text$mn:00000F70                 lea     eax, [ebp+var_C]
.text$mn:00000F73                 mov     large fs:0, eax
.text$mn:00000F79                 mov     [ebp+var_18], ecx
.text$mn:00000F7C                 mov     eax, [ebp+arg_0]
.text$mn:00000F7F                 push    eax             ; void *
.text$mn:00000F80                 push    4               ; unsigned int
.text$mn:00000F82                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00000F87                 add     esp, 8
.text$mn:00000F8A                 mov     [ebp+var_10], eax
.text$mn:00000F8D                 mov     [ebp+var_4], 0
.text$mn:00000F94                 cmp     [ebp+var_10], 0
.text$mn:00000F98                 jz      short loc_FB5
.text$mn:00000F9A                 mov     ecx, [ebp+arg_4]
.text$mn:00000F9D                 push    ecx
.text$mn:00000F9E                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00000FA3                 add     esp, 4
.text$mn:00000FA6                 mov     edx, [ebp+var_10]
.text$mn:00000FA9                 mov     eax, [eax]
.text$mn:00000FAB                 mov     [edx], eax
.text$mn:00000FAD                 mov     ecx, [ebp+var_10]
.text$mn:00000FB0                 mov     [ebp+var_14], ecx
.text$mn:00000FB3                 jmp     short loc_FBC
.text$mn:00000FB5 ; ---------------------------------------------------------------------------
.text$mn:00000FB5
.text$mn:00000FB5 loc_FB5:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00000FB5                 mov     [ebp+var_14], 0
.text$mn:00000FBC
.text$mn:00000FBC loc_FBC:                                ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00000FBC                 mov     edx, [ebp+var_14]
.text$mn:00000FBF                 mov     [ebp+var_1C], edx
.text$mn:00000FC2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FC9                 mov     ecx, [ebp+var_C]
.text$mn:00000FCC                 mov     large fs:0, ecx
.text$mn:00000FD3                 pop     ecx
.text$mn:00000FD4                 mov     esp, ebp
.text$mn:00000FD6                 pop     ebp
.text$mn:00000FD7                 retn    8
.text$mn:00000FD7 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00000FD7
.text$mn:00000FD7 ; ---------------------------------------------------------------------------
.text$mn:00000FDA                 align 4
.text$mn:00000FDA _text$mn        ends
.text$mn:00000FDA
.text$x:00000FDC ; ===========================================================================
.text$x:00000FDC
.text$x:00000FDC ; Segment type: Pure code
.text$x:00000FDC ; Segment permissions: Read/Execute
.text$x:00000FDC _text$x         segment para public 'CODE' use32
.text$x:00000FDC                 assume cs:_text$x
.text$x:00000FDC                 ;org 0FDCh
.text$x:00000FDC ; COMDAT (pick associative to section at F54)
.text$x:00000FDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00000FDC
.text$x:00000FDC ; =============== S U B R O U T I N E =======================================
.text$x:00000FDC
.text$x:00000FDC
.text$x:00000FDC __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:00000FDC                                         ; DATA XREF: .xdata$x:00003D7Co
.text$x:00000FDC                 mov     eax, [ebp+8]
.text$x:00000FDF                 push    eax
.text$x:00000FE0                 mov     eax, [ebp-10h]
.text$x:00000FE3                 push    eax             ; void *
.text$x:00000FE4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00000FE9                 add     esp, 8
.text$x:00000FEC                 retn
.text$x:00000FEC __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:00000FEC
.text$x:00000FED
.text$x:00000FED ; =============== S U B R O U T I N E =======================================
.text$x:00000FED
.text$x:00000FED
.text$x:00000FED __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:00000FED                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:00000FED
.text$x:00000FED arg_4           = dword ptr  8
.text$x:00000FED
.text$x:00000FED                 mov     edx, [esp+arg_4]
.text$x:00000FF1                 lea     eax, [edx+0Ch]
.text$x:00000FF4                 mov     ecx, [edx-14h]
.text$x:00000FF7                 xor     ecx, eax
.text$x:00000FF9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00000FFE                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00001003                 jmp     ___CxxFrameHandler3
.text$x:00001003 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00001003
.text$x:00001003 _text$x         ends
.text$x:00001003
.text$mn:00001008 ; ===========================================================================
.text$mn:00001008
.text$mn:00001008 ; Segment type: Pure code
.text$mn:00001008 ; Segment permissions: Read/Execute
.text$mn:00001008 _text$mn        segment para public 'CODE' use32
.text$mn:00001008                 assume cs:_text$mn
.text$mn:00001008                 ;org 1008h
.text$mn:00001008 ; COMDAT (pick any)
.text$mn:00001008                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001008
.text$mn:00001008 ; =============== S U B R O U T I N E =======================================
.text$mn:00001008
.text$mn:00001008 ; Attributes: bp-based frame
.text$mn:00001008
.text$mn:00001008 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001008                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001008 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001008                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001008
.text$mn:00001008 arg_0           = dword ptr  8
.text$mn:00001008 arg_4           = dword ptr  0Ch
.text$mn:00001008 arg_8           = dword ptr  10h
.text$mn:00001008
.text$mn:00001008                 push    ebp
.text$mn:00001009                 mov     ebp, esp
.text$mn:0000100B                 mov     eax, [ebp+arg_8]
.text$mn:0000100E                 push    eax
.text$mn:0000100F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001014                 add     esp, 4
.text$mn:00001017                 push    eax             ; int
.text$mn:00001018                 mov     ecx, [ebp+arg_4]
.text$mn:0000101B                 push    ecx             ; void *
.text$mn:0000101C                 mov     ecx, [ebp+arg_0]
.text$mn:0000101F                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001024                 pop     ebp
.text$mn:00001025                 retn
.text$mn:00001025 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001025
.text$mn:00001025 ; ---------------------------------------------------------------------------
.text$mn:00001026                 align 4
.text$mn:00001026 _text$mn        ends
.text$mn:00001026
.text$mn:00001028 ; ===========================================================================
.text$mn:00001028
.text$mn:00001028 ; Segment type: Pure code
.text$mn:00001028 ; Segment permissions: Read/Execute
.text$mn:00001028 _text$mn        segment para public 'CODE' use32
.text$mn:00001028                 assume cs:_text$mn
.text$mn:00001028                 ;org 1028h
.text$mn:00001028 ; COMDAT (pick any)
.text$mn:00001028                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001028
.text$mn:00001028 ; =============== S U B R O U T I N E =======================================
.text$mn:00001028
.text$mn:00001028 ; Attributes: bp-based frame
.text$mn:00001028
.text$mn:00001028 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00001028                 public ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001028 ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00001028                                         ; CODE XREF: $LN19_0+4Bp
.text$mn:00001028
.text$mn:00001028 var_4           = dword ptr -4
.text$mn:00001028 arg_0           = dword ptr  8
.text$mn:00001028 arg_4           = dword ptr  0Ch
.text$mn:00001028
.text$mn:00001028                 push    ebp
.text$mn:00001029                 mov     ebp, esp
.text$mn:0000102B                 push    ecx
.text$mn:0000102C                 mov     [ebp+var_4], ecx
.text$mn:0000102F                 mov     eax, [ebp+arg_4]
.text$mn:00001032                 push    eax
.text$mn:00001033                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001038                 add     esp, 4
.text$mn:0000103B                 push    eax             ; int
.text$mn:0000103C                 mov     ecx, [ebp+arg_0]
.text$mn:0000103F                 push    ecx             ; void *
.text$mn:00001040                 mov     edx, [ebp+var_4]
.text$mn:00001043                 push    edx             ; int
.text$mn:00001044                 call    ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)
.text$mn:00001049                 add     esp, 0Ch
.text$mn:0000104C                 mov     esp, ebp
.text$mn:0000104E                 pop     ebp
.text$mn:0000104F                 retn    8
.text$mn:0000104F ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:0000104F
.text$mn:0000104F ; ---------------------------------------------------------------------------
.text$mn:00001052                 align 4
.text$mn:00001052 _text$mn        ends
.text$mn:00001052
.text$mn:00001054 ; ===========================================================================
.text$mn:00001054
.text$mn:00001054 ; Segment type: Pure code
.text$mn:00001054 ; Segment permissions: Read/Execute
.text$mn:00001054 _text$mn        segment para public 'CODE' use32
.text$mn:00001054                 assume cs:_text$mn
.text$mn:00001054                 ;org 1054h
.text$mn:00001054 ; COMDAT (pick any)
.text$mn:00001054                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001054
.text$mn:00001054 ; =============== S U B R O U T I N E =======================================
.text$mn:00001054
.text$mn:00001054 ; Attributes: bp-based frame
.text$mn:00001054
.text$mn:00001054 ; int __stdcall std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(void *, int)
.text$mn:00001054                 public ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:00001054 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$mn:00001054                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(std::allocator<wchar_t> &,wchar_t * *,wchar_t * &)+17p
.text$mn:00001054
.text$mn:00001054 var_1C          = dword ptr -1Ch
.text$mn:00001054 var_18          = dword ptr -18h
.text$mn:00001054 var_14          = dword ptr -14h
.text$mn:00001054 var_10          = dword ptr -10h
.text$mn:00001054 var_C           = dword ptr -0Ch
.text$mn:00001054 var_4           = dword ptr -4
.text$mn:00001054 arg_0           = dword ptr  8
.text$mn:00001054 arg_4           = dword ptr  0Ch
.text$mn:00001054
.text$mn:00001054                 push    ebp
.text$mn:00001055                 mov     ebp, esp
.text$mn:00001057                 push    0FFFFFFFFh
.text$mn:00001059                 push    offset __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$mn:0000105E                 mov     eax, large fs:0
.text$mn:00001064                 push    eax
.text$mn:00001065                 sub     esp, 10h
.text$mn:00001068                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000106D                 xor     eax, ebp
.text$mn:0000106F                 push    eax
.text$mn:00001070                 lea     eax, [ebp+var_C]
.text$mn:00001073                 mov     large fs:0, eax
.text$mn:00001079                 mov     [ebp+var_18], ecx
.text$mn:0000107C                 mov     eax, [ebp+arg_0]
.text$mn:0000107F                 push    eax             ; void *
.text$mn:00001080                 push    4               ; unsigned int
.text$mn:00001082                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00001087                 add     esp, 8
.text$mn:0000108A                 mov     [ebp+var_10], eax
.text$mn:0000108D                 mov     [ebp+var_4], 0
.text$mn:00001094                 cmp     [ebp+var_10], 0
.text$mn:00001098                 jz      short loc_10B5
.text$mn:0000109A                 mov     ecx, [ebp+arg_4]
.text$mn:0000109D                 push    ecx
.text$mn:0000109E                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:000010A3                 add     esp, 4
.text$mn:000010A6                 mov     edx, [ebp+var_10]
.text$mn:000010A9                 mov     eax, [eax]
.text$mn:000010AB                 mov     [edx], eax
.text$mn:000010AD                 mov     ecx, [ebp+var_10]
.text$mn:000010B0                 mov     [ebp+var_14], ecx
.text$mn:000010B3                 jmp     short loc_10BC
.text$mn:000010B5 ; ---------------------------------------------------------------------------
.text$mn:000010B5
.text$mn:000010B5 loc_10B5:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+44j
.text$mn:000010B5                 mov     [ebp+var_14], 0
.text$mn:000010BC
.text$mn:000010BC loc_10BC:                               ; CODE XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5Fj
.text$mn:000010BC                 mov     edx, [ebp+var_14]
.text$mn:000010BF                 mov     [ebp+var_1C], edx
.text$mn:000010C2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010C9                 mov     ecx, [ebp+var_C]
.text$mn:000010CC                 mov     large fs:0, ecx
.text$mn:000010D3                 pop     ecx
.text$mn:000010D4                 mov     esp, ebp
.text$mn:000010D6                 pop     ebp
.text$mn:000010D7                 retn    8
.text$mn:000010D7 ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$mn:000010D7
.text$mn:000010D7 ; ---------------------------------------------------------------------------
.text$mn:000010DA                 align 4
.text$mn:000010DA _text$mn        ends
.text$mn:000010DA
.text$x:000010DC ; ===========================================================================
.text$x:000010DC
.text$x:000010DC ; Segment type: Pure code
.text$x:000010DC ; Segment permissions: Read/Execute
.text$x:000010DC _text$x         segment para public 'CODE' use32
.text$x:000010DC                 assume cs:_text$x
.text$x:000010DC                 ;org 10DCh
.text$x:000010DC ; COMDAT (pick associative to section at 1054)
.text$x:000010DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000010DC
.text$x:000010DC ; =============== S U B R O U T I N E =======================================
.text$x:000010DC
.text$x:000010DC
.text$x:000010DC __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 proc near
.text$x:000010DC                                         ; DATA XREF: .xdata$x:00003DA8o
.text$x:000010DC                 mov     eax, [ebp+8]
.text$x:000010DF                 push    eax
.text$x:000010E0                 mov     eax, [ebp-10h]
.text$x:000010E3                 push    eax             ; void *
.text$x:000010E4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000010E9                 add     esp, 8
.text$x:000010EC                 retn
.text$x:000010EC __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0 endp
.text$x:000010EC
.text$x:000010ED
.text$x:000010ED ; =============== S U B R O U T I N E =======================================
.text$x:000010ED
.text$x:000010ED
.text$x:000010ED __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z proc near
.text$x:000010ED                                         ; DATA XREF: std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+5o
.text$x:000010ED
.text$x:000010ED arg_4           = dword ptr  8
.text$x:000010ED
.text$x:000010ED                 mov     edx, [esp+arg_4]
.text$x:000010F1                 lea     eax, [edx+0Ch]
.text$x:000010F4                 mov     ecx, [edx-14h]
.text$x:000010F7                 xor     ecx, eax
.text$x:000010F9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000010FE                 mov     eax, offset __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.text$x:00001103                 jmp     ___CxxFrameHandler3
.text$x:00001103 __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z endp
.text$x:00001103
.text$x:00001103 _text$x         ends
.text$x:00001103
.text$mn:00001108 ; ===========================================================================
.text$mn:00001108
.text$mn:00001108 ; Segment type: Pure code
.text$mn:00001108 ; Segment permissions: Read/Execute
.text$mn:00001108 _text$mn        segment para public 'CODE' use32
.text$mn:00001108                 assume cs:_text$mn
.text$mn:00001108                 ;org 1108h
.text$mn:00001108 ; COMDAT (pick any)
.text$mn:00001108                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001108
.text$mn:00001108 ; =============== S U B R O U T I N E =======================================
.text$mn:00001108
.text$mn:00001108 ; Attributes: bp-based frame
.text$mn:00001108
.text$mn:00001108 ; int __cdecl std::allocator_traits<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(int, void *, int)
.text$mn:00001108                 public ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z
.text$mn:00001108 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z proc near
.text$mn:00001108                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+1Cp
.text$mn:00001108
.text$mn:00001108 arg_0           = dword ptr  8
.text$mn:00001108 arg_4           = dword ptr  0Ch
.text$mn:00001108 arg_8           = dword ptr  10h
.text$mn:00001108
.text$mn:00001108                 push    ebp
.text$mn:00001109                 mov     ebp, esp
.text$mn:0000110B                 mov     eax, [ebp+arg_8]
.text$mn:0000110E                 push    eax
.text$mn:0000110F                 call    ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z ; std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001114                 add     esp, 4
.text$mn:00001117                 push    eax             ; int
.text$mn:00001118                 mov     ecx, [ebp+arg_4]
.text$mn:0000111B                 push    ecx             ; void *
.text$mn:0000111C                 mov     ecx, [ebp+arg_0]
.text$mn:0000111F                 call    ??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00001124                 pop     ebp
.text$mn:00001125                 retn
.text$mn:00001125 ??$construct@PA_WAAPA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_WAAPA_W@Z endp
.text$mn:00001125
.text$mn:00001125 ; ---------------------------------------------------------------------------
.text$mn:00001126                 align 4
.text$mn:00001126 _text$mn        ends
.text$mn:00001126
.text$mn:00001128 ; ===========================================================================
.text$mn:00001128
.text$mn:00001128 ; Segment type: Pure code
.text$mn:00001128 ; Segment permissions: Read/Execute
.text$mn:00001128 _text$mn        segment para public 'CODE' use32
.text$mn:00001128                 assume cs:_text$mn
.text$mn:00001128                 ;org 1128h
.text$mn:00001128 ; COMDAT (pick any)
.text$mn:00001128                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001128
.text$mn:00001128 ; =============== S U B R O U T I N E =======================================
.text$mn:00001128
.text$mn:00001128 ; Attributes: bp-based frame
.text$mn:00001128
.text$mn:00001128 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001128                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001128 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001128                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001128                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+32p
.text$mn:00001128
.text$mn:00001128 var_1C          = dword ptr -1Ch
.text$mn:00001128 var_18          = dword ptr -18h
.text$mn:00001128 var_14          = dword ptr -14h
.text$mn:00001128 var_10          = dword ptr -10h
.text$mn:00001128 var_C           = dword ptr -0Ch
.text$mn:00001128 var_4           = dword ptr -4
.text$mn:00001128 arg_0           = dword ptr  8
.text$mn:00001128 arg_4           = dword ptr  0Ch
.text$mn:00001128
.text$mn:00001128                 push    ebp
.text$mn:00001129                 mov     ebp, esp
.text$mn:0000112B                 push    0FFFFFFFFh
.text$mn:0000112D                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001132                 mov     eax, large fs:0
.text$mn:00001138                 push    eax
.text$mn:00001139                 sub     esp, 10h
.text$mn:0000113C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001141                 xor     eax, ebp
.text$mn:00001143                 push    eax
.text$mn:00001144                 lea     eax, [ebp+var_C]
.text$mn:00001147                 mov     large fs:0, eax
.text$mn:0000114D                 mov     [ebp+var_18], ecx
.text$mn:00001150                 mov     eax, [ebp+arg_0]
.text$mn:00001153                 push    eax             ; void *
.text$mn:00001154                 push    8               ; unsigned int
.text$mn:00001156                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:0000115B                 add     esp, 8
.text$mn:0000115E                 mov     [ebp+var_10], eax
.text$mn:00001161                 mov     [ebp+var_4], 0
.text$mn:00001168                 cmp     [ebp+var_10], 0
.text$mn:0000116C                 jz      short loc_118F
.text$mn:0000116E                 mov     ecx, [ebp+arg_4]
.text$mn:00001171                 push    ecx
.text$mn:00001172                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00001177                 add     esp, 4
.text$mn:0000117A                 mov     edx, [eax]
.text$mn:0000117C                 mov     eax, [eax+4]
.text$mn:0000117F                 mov     ecx, [ebp+var_10]
.text$mn:00001182                 mov     [ecx], edx
.text$mn:00001184                 mov     [ecx+4], eax
.text$mn:00001187                 mov     edx, [ebp+var_10]
.text$mn:0000118A                 mov     [ebp+var_14], edx
.text$mn:0000118D                 jmp     short loc_1196
.text$mn:0000118F ; ---------------------------------------------------------------------------
.text$mn:0000118F
.text$mn:0000118F loc_118F:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:0000118F                 mov     [ebp+var_14], 0
.text$mn:00001196
.text$mn:00001196 loc_1196:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:00001196                 mov     eax, [ebp+var_14]
.text$mn:00001199                 mov     [ebp+var_1C], eax
.text$mn:0000119C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000011A3                 mov     ecx, [ebp+var_C]
.text$mn:000011A6                 mov     large fs:0, ecx
.text$mn:000011AD                 pop     ecx
.text$mn:000011AE                 mov     esp, ebp
.text$mn:000011B0                 pop     ebp
.text$mn:000011B1                 retn    8
.text$mn:000011B1 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000011B1
.text$mn:000011B1 _text$mn        ends
.text$mn:000011B1
.text$x:000011B4 ; ===========================================================================
.text$x:000011B4
.text$x:000011B4 ; Segment type: Pure code
.text$x:000011B4 ; Segment permissions: Read/Execute
.text$x:000011B4 _text$x         segment para public 'CODE' use32
.text$x:000011B4                 assume cs:_text$x
.text$x:000011B4                 ;org 11B4h
.text$x:000011B4 ; COMDAT (pick associative to section at 1128)
.text$x:000011B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000011B4
.text$x:000011B4 ; =============== S U B R O U T I N E =======================================
.text$x:000011B4
.text$x:000011B4
.text$x:000011B4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000011B4                                         ; DATA XREF: .xdata$x:00003D50o
.text$x:000011B4                 mov     eax, [ebp+8]
.text$x:000011B7                 push    eax
.text$x:000011B8                 mov     eax, [ebp-10h]
.text$x:000011BB                 push    eax             ; void *
.text$x:000011BC                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000011C1                 add     esp, 8
.text$x:000011C4                 retn
.text$x:000011C4 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000011C4
.text$x:000011C5
.text$x:000011C5 ; =============== S U B R O U T I N E =======================================
.text$x:000011C5
.text$x:000011C5
.text$x:000011C5 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000011C5                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000011C5
.text$x:000011C5 arg_4           = dword ptr  8
.text$x:000011C5
.text$x:000011C5                 mov     edx, [esp+arg_4]
.text$x:000011C9                 lea     eax, [edx+0Ch]
.text$x:000011CC                 mov     ecx, [edx-14h]
.text$x:000011CF                 xor     ecx, eax
.text$x:000011D1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000011D6                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000011DB                 jmp     ___CxxFrameHandler3
.text$x:000011DB __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000011DB
.text$x:000011DB _text$x         ends
.text$x:000011DB
.text$mn:000011E0 ; ===========================================================================
.text$mn:000011E0
.text$mn:000011E0 ; Segment type: Pure code
.text$mn:000011E0 ; Segment permissions: Read/Execute
.text$mn:000011E0 _text$mn        segment para public 'CODE' use32
.text$mn:000011E0                 assume cs:_text$mn
.text$mn:000011E0                 ;org 11E0h
.text$mn:000011E0 ; COMDAT (pick any)
.text$mn:000011E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000011E0
.text$mn:000011E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000011E0
.text$mn:000011E0 ; Attributes: bp-based frame
.text$mn:000011E0
.text$mn:000011E0 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000011E0                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:000011E0 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:000011E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:000011E0
.text$mn:000011E0 var_4           = dword ptr -4
.text$mn:000011E0 arg_0           = dword ptr  8
.text$mn:000011E0
.text$mn:000011E0                 push    ebp
.text$mn:000011E1                 mov     ebp, esp
.text$mn:000011E3                 push    ecx
.text$mn:000011E4                 mov     [ebp+var_4], ecx
.text$mn:000011E7                 mov     eax, [ebp+arg_0]
.text$mn:000011EA                 push    eax
.text$mn:000011EB                 mov     ecx, [ebp+var_4]
.text$mn:000011EE                 push    ecx
.text$mn:000011EF                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:000011F4                 add     esp, 8
.text$mn:000011F7                 mov     esp, ebp
.text$mn:000011F9                 pop     ebp
.text$mn:000011FA                 retn    4
.text$mn:000011FA ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:000011FA
.text$mn:000011FA ; ---------------------------------------------------------------------------
.text$mn:000011FD                 align 10h
.text$mn:000011FD _text$mn        ends
.text$mn:000011FD
.text$mn:00001200 ; ===========================================================================
.text$mn:00001200
.text$mn:00001200 ; Segment type: Pure code
.text$mn:00001200 ; Segment permissions: Read/Execute
.text$mn:00001200 _text$mn        segment para public 'CODE' use32
.text$mn:00001200                 assume cs:_text$mn
.text$mn:00001200                 ;org 1200h
.text$mn:00001200 ; COMDAT (pick any)
.text$mn:00001200                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001200
.text$mn:00001200 ; =============== S U B R O U T I N E =======================================
.text$mn:00001200
.text$mn:00001200 ; Attributes: bp-based frame
.text$mn:00001200
.text$mn:00001200 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001200                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00001200 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00001200                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00001200
.text$mn:00001200 var_4           = dword ptr -4
.text$mn:00001200
.text$mn:00001200                 push    ebp
.text$mn:00001201                 mov     ebp, esp
.text$mn:00001203                 push    ecx
.text$mn:00001204                 mov     [ebp+var_4], ecx
.text$mn:00001207                 mov     esp, ebp
.text$mn:00001209                 pop     ebp
.text$mn:0000120A                 retn    4
.text$mn:0000120A ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:0000120A
.text$mn:0000120A ; ---------------------------------------------------------------------------
.text$mn:0000120D                 align 10h
.text$mn:0000120D _text$mn        ends
.text$mn:0000120D
.text$mn:00001210 ; ===========================================================================
.text$mn:00001210
.text$mn:00001210 ; Segment type: Pure code
.text$mn:00001210 ; Segment permissions: Read/Execute
.text$mn:00001210 _text$mn        segment para public 'CODE' use32
.text$mn:00001210                 assume cs:_text$mn
.text$mn:00001210                 ;org 1210h
.text$mn:00001210 ; COMDAT (pick any)
.text$mn:00001210                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001210
.text$mn:00001210 ; =============== S U B R O U T I N E =======================================
.text$mn:00001210
.text$mn:00001210 ; Attributes: bp-based frame
.text$mn:00001210
.text$mn:00001210 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00001210                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00001210 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00001210                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00001210
.text$mn:00001210 arg_0           = dword ptr  8
.text$mn:00001210 arg_4           = dword ptr  0Ch
.text$mn:00001210
.text$mn:00001210                 push    ebp
.text$mn:00001211                 mov     ebp, esp
.text$mn:00001213                 mov     eax, [ebp+arg_4]
.text$mn:00001216                 push    eax
.text$mn:00001217                 mov     ecx, [ebp+arg_0]
.text$mn:0000121A                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000121F                 pop     ebp
.text$mn:00001220                 retn
.text$mn:00001220 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00001220
.text$mn:00001220 ; ---------------------------------------------------------------------------
.text$mn:00001221                 align 4
.text$mn:00001221 _text$mn        ends
.text$mn:00001221
.text$mn:00001224 ; ===========================================================================
.text$mn:00001224
.text$mn:00001224 ; Segment type: Pure code
.text$mn:00001224 ; Segment permissions: Read/Execute
.text$mn:00001224 _text$mn        segment para public 'CODE' use32
.text$mn:00001224                 assume cs:_text$mn
.text$mn:00001224                 ;org 1224h
.text$mn:00001224 ; COMDAT (pick any)
.text$mn:00001224                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001224
.text$mn:00001224 ; =============== S U B R O U T I N E =======================================
.text$mn:00001224
.text$mn:00001224 ; Attributes: bp-based frame
.text$mn:00001224
.text$mn:00001224 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001224                 public ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z
.text$mn:00001224 ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z proc near
.text$mn:00001224                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+3Ap
.text$mn:00001224
.text$mn:00001224 var_4           = dword ptr -4
.text$mn:00001224 arg_0           = dword ptr  8
.text$mn:00001224
.text$mn:00001224                 push    ebp
.text$mn:00001225                 mov     ebp, esp
.text$mn:00001227                 push    ecx
.text$mn:00001228                 mov     [ebp+var_4], ecx
.text$mn:0000122B                 mov     eax, [ebp+arg_0]
.text$mn:0000122E                 push    eax
.text$mn:0000122F                 mov     ecx, [ebp+var_4]
.text$mn:00001232                 push    ecx
.text$mn:00001233                 call    ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z ; std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)
.text$mn:00001238                 add     esp, 8
.text$mn:0000123B                 mov     esp, ebp
.text$mn:0000123D                 pop     ebp
.text$mn:0000123E                 retn    4
.text$mn:0000123E ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z endp
.text$mn:0000123E
.text$mn:0000123E ; ---------------------------------------------------------------------------
.text$mn:00001241                 align 4
.text$mn:00001241 _text$mn        ends
.text$mn:00001241
.text$mn:00001244 ; ===========================================================================
.text$mn:00001244
.text$mn:00001244 ; Segment type: Pure code
.text$mn:00001244 ; Segment permissions: Read/Execute
.text$mn:00001244 _text$mn        segment para public 'CODE' use32
.text$mn:00001244                 assume cs:_text$mn
.text$mn:00001244                 ;org 1244h
.text$mn:00001244 ; COMDAT (pick any)
.text$mn:00001244                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001244
.text$mn:00001244 ; =============== S U B R O U T I N E =======================================
.text$mn:00001244
.text$mn:00001244 ; Attributes: bp-based frame
.text$mn:00001244
.text$mn:00001244 ; public: void __thiscall std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001244                 public ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z
.text$mn:00001244 ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z proc near
.text$mn:00001244                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::destroy<wchar_t *>(std::allocator<wchar_t> &,wchar_t * *)+Ap
.text$mn:00001244
.text$mn:00001244 var_4           = dword ptr -4
.text$mn:00001244
.text$mn:00001244                 push    ebp
.text$mn:00001245                 mov     ebp, esp
.text$mn:00001247                 push    ecx
.text$mn:00001248                 mov     [ebp+var_4], ecx
.text$mn:0000124B                 mov     esp, ebp
.text$mn:0000124D                 pop     ebp
.text$mn:0000124E                 retn    4
.text$mn:0000124E ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z endp
.text$mn:0000124E
.text$mn:0000124E ; ---------------------------------------------------------------------------
.text$mn:00001251                 align 4
.text$mn:00001251 _text$mn        ends
.text$mn:00001251
.text$mn:00001254 ; ===========================================================================
.text$mn:00001254
.text$mn:00001254 ; Segment type: Pure code
.text$mn:00001254 ; Segment permissions: Read/Execute
.text$mn:00001254 _text$mn        segment para public 'CODE' use32
.text$mn:00001254                 assume cs:_text$mn
.text$mn:00001254                 ;org 1254h
.text$mn:00001254 ; COMDAT (pick any)
.text$mn:00001254                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001254
.text$mn:00001254 ; =============== S U B R O U T I N E =======================================
.text$mn:00001254
.text$mn:00001254 ; Attributes: bp-based frame
.text$mn:00001254
.text$mn:00001254 ; public: static void __cdecl std::allocator_traits<class std::allocator<wchar_t>>::destroy<wchar_t *>(class std::allocator<wchar_t> &, wchar_t * *)
.text$mn:00001254                 public ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z
.text$mn:00001254 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z proc near
.text$mn:00001254                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)+Fp
.text$mn:00001254
.text$mn:00001254 arg_0           = dword ptr  8
.text$mn:00001254 arg_4           = dword ptr  0Ch
.text$mn:00001254
.text$mn:00001254                 push    ebp
.text$mn:00001255                 mov     ebp, esp
.text$mn:00001257                 mov     eax, [ebp+arg_4]
.text$mn:0000125A                 push    eax
.text$mn:0000125B                 mov     ecx, [ebp+arg_0]
.text$mn:0000125E                 call    ??$destroy@PA_W@?$allocator@_W@std@@QAEXPAPA_W@Z ; std::allocator<wchar_t>::destroy<wchar_t *>(wchar_t * *)
.text$mn:00001263                 pop     ebp
.text$mn:00001264                 retn
.text$mn:00001264 ??$destroy@PA_W@?$allocator_traits@V?$allocator@_W@std@@@std@@SAXAAV?$allocator@_W@1@PAPA_W@Z endp
.text$mn:00001264
.text$mn:00001264 ; ---------------------------------------------------------------------------
.text$mn:00001265                 align 4
.text$mn:00001265 _text$mn        ends
.text$mn:00001265
.text$mn:00001268 ; ===========================================================================
.text$mn:00001268
.text$mn:00001268 ; Segment type: Pure code
.text$mn:00001268 ; Segment permissions: Read/Execute
.text$mn:00001268 _text$mn        segment para public 'CODE' use32
.text$mn:00001268                 assume cs:_text$mn
.text$mn:00001268                 ;org 1268h
.text$mn:00001268 ; COMDAT (pick any)
.text$mn:00001268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001268
.text$mn:00001268 ; =============== S U B R O U T I N E =======================================
.text$mn:00001268
.text$mn:00001268 ; Attributes: bp-based frame
.text$mn:00001268
.text$mn:00001268 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001268                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001268 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001268                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00001268                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+22p
.text$mn:00001268
.text$mn:00001268 var_4           = dword ptr -4
.text$mn:00001268
.text$mn:00001268                 push    ebp
.text$mn:00001269                 mov     ebp, esp
.text$mn:0000126B                 push    ecx
.text$mn:0000126C                 mov     [ebp+var_4], ecx
.text$mn:0000126F                 mov     esp, ebp
.text$mn:00001271                 pop     ebp
.text$mn:00001272                 retn    4
.text$mn:00001272 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00001272
.text$mn:00001272 ; ---------------------------------------------------------------------------
.text$mn:00001275                 align 4
.text$mn:00001275 _text$mn        ends
.text$mn:00001275
.text$mn:00001278 ; ===========================================================================
.text$mn:00001278
.text$mn:00001278 ; Segment type: Pure code
.text$mn:00001278 ; Segment permissions: Read/Execute
.text$mn:00001278 _text$mn        segment para public 'CODE' use32
.text$mn:00001278                 assume cs:_text$mn
.text$mn:00001278                 ;org 1278h
.text$mn:00001278 ; COMDAT (pick any)
.text$mn:00001278                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001278
.text$mn:00001278 ; =============== S U B R O U T I N E =======================================
.text$mn:00001278
.text$mn:00001278 ; Attributes: bp-based frame
.text$mn:00001278
.text$mn:00001278 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00001278                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00001278 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00001278                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00001278                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00001278
.text$mn:00001278 arg_0           = dword ptr  8
.text$mn:00001278
.text$mn:00001278                 push    ebp
.text$mn:00001279                 mov     ebp, esp
.text$mn:0000127B                 mov     eax, [ebp+arg_0]
.text$mn:0000127E                 pop     ebp
.text$mn:0000127F                 retn
.text$mn:0000127F ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:0000127F
.text$mn:0000127F _text$mn        ends
.text$mn:0000127F
.text$mn:00001280 ; ===========================================================================
.text$mn:00001280
.text$mn:00001280 ; Segment type: Pure code
.text$mn:00001280 ; Segment permissions: Read/Execute
.text$mn:00001280 _text$mn        segment para public 'CODE' use32
.text$mn:00001280                 assume cs:_text$mn
.text$mn:00001280                 ;org 1280h
.text$mn:00001280 ; COMDAT (pick any)
.text$mn:00001280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001280
.text$mn:00001280 ; =============== S U B R O U T I N E =======================================
.text$mn:00001280
.text$mn:00001280 ; Attributes: bp-based frame
.text$mn:00001280
.text$mn:00001280 ; wchar_t * & __cdecl std::forward<wchar_t * &>(wchar_t * &)
.text$mn:00001280                 public ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z
.text$mn:00001280 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z proc near
.text$mn:00001280                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+Bp
.text$mn:00001280                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+4Ap ...
.text$mn:00001280
.text$mn:00001280 arg_0           = dword ptr  8
.text$mn:00001280
.text$mn:00001280                 push    ebp
.text$mn:00001281                 mov     ebp, esp
.text$mn:00001283                 mov     eax, [ebp+arg_0]
.text$mn:00001286                 pop     ebp
.text$mn:00001287                 retn
.text$mn:00001287 ??$forward@AAPA_W@std@@YAAAPA_WAAPA_W@Z endp
.text$mn:00001287
.text$mn:00001287 _text$mn        ends
.text$mn:00001287
.text$mn:00001288 ; ===========================================================================
.text$mn:00001288
.text$mn:00001288 ; Segment type: Pure code
.text$mn:00001288 ; Segment permissions: Read/Execute
.text$mn:00001288 _text$mn        segment para public 'CODE' use32
.text$mn:00001288                 assume cs:_text$mn
.text$mn:00001288                 ;org 1288h
.text$mn:00001288 ; COMDAT (pick any)
.text$mn:00001288                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001288
.text$mn:00001288 ; =============== S U B R O U T I N E =======================================
.text$mn:00001288
.text$mn:00001288 ; Attributes: bp-based frame
.text$mn:00001288
.text$mn:00001288 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00001288                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00001288 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00001288                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:00001288
.text$mn:00001288 arg_0           = dword ptr  8
.text$mn:00001288
.text$mn:00001288                 push    ebp
.text$mn:00001289                 mov     ebp, esp
.text$mn:0000128B                 mov     eax, [ebp+arg_0]
.text$mn:0000128E                 pop     ebp
.text$mn:0000128F                 retn
.text$mn:0000128F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000128F
.text$mn:0000128F _text$mn        ends
.text$mn:0000128F
.text$mn:00001290 ; ===========================================================================
.text$mn:00001290
.text$mn:00001290 ; Segment type: Pure code
.text$mn:00001290 ; Segment permissions: Read/Execute
.text$mn:00001290 _text$mn        segment para public 'CODE' use32
.text$mn:00001290                 assume cs:_text$mn
.text$mn:00001290                 ;org 1290h
.text$mn:00001290 ; COMDAT (pick any)
.text$mn:00001290                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001290
.text$mn:00001290 ; =============== S U B R O U T I N E =======================================
.text$mn:00001290
.text$mn:00001290 ; Attributes: bp-based frame
.text$mn:00001290
.text$mn:00001290 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00001290                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001290 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00001290                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00001290
.text$mn:00001290 var_10          = dword ptr -10h
.text$mn:00001290 var_C           = dword ptr -0Ch
.text$mn:00001290 var_4           = dword ptr -4
.text$mn:00001290
.text$mn:00001290                 push    ebp
.text$mn:00001291                 mov     ebp, esp
.text$mn:00001293                 push    0FFFFFFFFh
.text$mn:00001295                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000129A                 mov     eax, large fs:0
.text$mn:000012A0                 push    eax
.text$mn:000012A1                 push    ecx
.text$mn:000012A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012A7                 xor     eax, ebp
.text$mn:000012A9                 push    eax
.text$mn:000012AA                 lea     eax, [ebp+var_C]
.text$mn:000012AD                 mov     large fs:0, eax
.text$mn:000012B3                 mov     [ebp+var_10], ecx
.text$mn:000012B6                 mov     ecx, [ebp+var_10]
.text$mn:000012B9                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000012BE                 mov     [ebp+var_4], 0
.text$mn:000012C5                 mov     ecx, [ebp+var_10]
.text$mn:000012C8                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000012CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000012D4                 mov     eax, [ebp+var_10]
.text$mn:000012D7                 mov     ecx, [ebp+var_C]
.text$mn:000012DA                 mov     large fs:0, ecx
.text$mn:000012E1                 pop     ecx
.text$mn:000012E2                 mov     esp, ebp
.text$mn:000012E4                 pop     ebp
.text$mn:000012E5                 retn    4
.text$mn:000012E5 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000012E5
.text$mn:000012E5 _text$mn        ends
.text$mn:000012E5
.text$x:000012E8 ; ===========================================================================
.text$x:000012E8
.text$x:000012E8 ; Segment type: Pure code
.text$x:000012E8 ; Segment permissions: Read/Execute
.text$x:000012E8 _text$x         segment para public 'CODE' use32
.text$x:000012E8                 assume cs:_text$x
.text$x:000012E8                 ;org 12E8h
.text$x:000012E8 ; COMDAT (pick associative to section at 1290)
.text$x:000012E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000012E8
.text$x:000012E8 ; =============== S U B R O U T I N E =======================================
.text$x:000012E8
.text$x:000012E8
.text$x:000012E8 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000012E8                                         ; DATA XREF: .xdata$x:000037DCo
.text$x:000012E8                 mov     ecx, [ebp-10h]
.text$x:000012EB                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000012EB __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000012EB
.text$x:000012F0
.text$x:000012F0 ; =============== S U B R O U T I N E =======================================
.text$x:000012F0
.text$x:000012F0
.text$x:000012F0 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000012F0                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000012F0
.text$x:000012F0 arg_4           = dword ptr  8
.text$x:000012F0
.text$x:000012F0                 mov     edx, [esp+arg_4]
.text$x:000012F4                 lea     eax, [edx+0Ch]
.text$x:000012F7                 mov     ecx, [edx-8]
.text$x:000012FA                 xor     ecx, eax
.text$x:000012FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001301                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00001306                 jmp     ___CxxFrameHandler3
.text$x:00001306 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00001306
.text$x:00001306 ; ---------------------------------------------------------------------------
.text$x:0000130B                 align 4
.text$x:0000130B _text$x         ends
.text$x:0000130B
.text$mn:0000130C ; ===========================================================================
.text$mn:0000130C
.text$mn:0000130C ; Segment type: Pure code
.text$mn:0000130C ; Segment permissions: Read/Execute
.text$mn:0000130C _text$mn        segment para public 'CODE' use32
.text$mn:0000130C                 assume cs:_text$mn
.text$mn:0000130C                 ;org 130Ch
.text$mn:0000130C ; COMDAT (pick any)
.text$mn:0000130C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000130C
.text$mn:0000130C ; =============== S U B R O U T I N E =======================================
.text$mn:0000130C
.text$mn:0000130C ; Attributes: bp-based frame
.text$mn:0000130C
.text$mn:0000130C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(class std::allocator<wchar_t> const &)
.text$mn:0000130C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:0000130C ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$mn:0000130C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+34p
.text$mn:0000130C
.text$mn:0000130C var_10          = dword ptr -10h
.text$mn:0000130C var_C           = dword ptr -0Ch
.text$mn:0000130C var_4           = dword ptr -4
.text$mn:0000130C
.text$mn:0000130C                 push    ebp
.text$mn:0000130D                 mov     ebp, esp
.text$mn:0000130F                 push    0FFFFFFFFh
.text$mn:00001311                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$mn:00001316                 mov     eax, large fs:0
.text$mn:0000131C                 push    eax
.text$mn:0000131D                 push    ecx
.text$mn:0000131E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001323                 xor     eax, ebp
.text$mn:00001325                 push    eax
.text$mn:00001326                 lea     eax, [ebp+var_C]
.text$mn:00001329                 mov     large fs:0, eax
.text$mn:0000132F                 mov     [ebp+var_10], ecx
.text$mn:00001332                 mov     ecx, [ebp+var_10]
.text$mn:00001335                 call    ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:0000133A                 mov     [ebp+var_4], 0
.text$mn:00001341                 mov     ecx, [ebp+var_10]
.text$mn:00001344                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00001349                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001350                 mov     eax, [ebp+var_10]
.text$mn:00001353                 mov     ecx, [ebp+var_C]
.text$mn:00001356                 mov     large fs:0, ecx
.text$mn:0000135D                 pop     ecx
.text$mn:0000135E                 mov     esp, ebp
.text$mn:00001360                 pop     ebp
.text$mn:00001361                 retn    4
.text$mn:00001361 ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$mn:00001361
.text$mn:00001361 _text$mn        ends
.text$mn:00001361
.text$x:00001364 ; ===========================================================================
.text$x:00001364
.text$x:00001364 ; Segment type: Pure code
.text$x:00001364 ; Segment permissions: Read/Execute
.text$x:00001364 _text$x         segment para public 'CODE' use32
.text$x:00001364                 assume cs:_text$x
.text$x:00001364                 ;org 1364h
.text$x:00001364 ; COMDAT (pick associative to section at 130C)
.text$x:00001364                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001364
.text$x:00001364 ; =============== S U B R O U T I N E =======================================
.text$x:00001364
.text$x:00001364
.text$x:00001364 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 proc near
.text$x:00001364                                         ; DATA XREF: .xdata$x:00003B80o
.text$x:00001364                 mov     ecx, [ebp-10h]
.text$x:00001367                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00001367 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0 endp
.text$x:00001367
.text$x:0000136C
.text$x:0000136C ; =============== S U B R O U T I N E =======================================
.text$x:0000136C
.text$x:0000136C
.text$x:0000136C __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z proc near
.text$x:0000136C                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+5o
.text$x:0000136C
.text$x:0000136C arg_4           = dword ptr  8
.text$x:0000136C
.text$x:0000136C                 mov     edx, [esp+arg_4]
.text$x:00001370                 lea     eax, [edx+0Ch]
.text$x:00001373                 mov     ecx, [edx-8]
.text$x:00001376                 xor     ecx, eax
.text$x:00001378                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000137D                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.text$x:00001382                 jmp     ___CxxFrameHandler3
.text$x:00001382 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z endp
.text$x:00001382
.text$x:00001382 ; ---------------------------------------------------------------------------
.text$x:00001387                 align 4
.text$x:00001387 _text$x         ends
.text$x:00001387
.text$mn:00001388 ; ===========================================================================
.text$mn:00001388
.text$mn:00001388 ; Segment type: Pure code
.text$mn:00001388 ; Segment permissions: Read/Execute
.text$mn:00001388 _text$mn        segment para public 'CODE' use32
.text$mn:00001388                 assume cs:_text$mn
.text$mn:00001388                 ;org 1388h
.text$mn:00001388 ; COMDAT (pick any)
.text$mn:00001388                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001388
.text$mn:00001388 ; =============== S U B R O U T I N E =======================================
.text$mn:00001388
.text$mn:00001388 ; Attributes: bp-based frame
.text$mn:00001388
.text$mn:00001388 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001388                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001388 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001388                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00001388
.text$mn:00001388 var_10          = dword ptr -10h
.text$mn:00001388 var_C           = dword ptr -0Ch
.text$mn:00001388 var_4           = dword ptr -4
.text$mn:00001388
.text$mn:00001388                 push    ebp
.text$mn:00001389                 mov     ebp, esp
.text$mn:0000138B                 push    0FFFFFFFFh
.text$mn:0000138D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001392                 mov     eax, large fs:0
.text$mn:00001398                 push    eax
.text$mn:00001399                 push    ecx
.text$mn:0000139A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000139F                 xor     eax, ebp
.text$mn:000013A1                 push    eax
.text$mn:000013A2                 lea     eax, [ebp+var_C]
.text$mn:000013A5                 mov     large fs:0, eax
.text$mn:000013AB                 mov     [ebp+var_10], ecx
.text$mn:000013AE                 mov     ecx, [ebp+var_10] ; this
.text$mn:000013B1                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:000013B6                 mov     [ebp+var_4], 0
.text$mn:000013BD                 mov     eax, [ebp+var_10]
.text$mn:000013C0                 mov     dword ptr [eax+14h], 0
.text$mn:000013C7                 mov     ecx, [ebp+var_10]
.text$mn:000013CA                 mov     dword ptr [ecx+18h], 0
.text$mn:000013D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000013D8                 mov     eax, [ebp+var_10]
.text$mn:000013DB                 mov     ecx, [ebp+var_C]
.text$mn:000013DE                 mov     large fs:0, ecx
.text$mn:000013E5                 pop     ecx
.text$mn:000013E6                 mov     esp, ebp
.text$mn:000013E8                 pop     ebp
.text$mn:000013E9                 retn
.text$mn:000013E9 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000013E9
.text$mn:000013E9 ; ---------------------------------------------------------------------------
.text$mn:000013EA                 align 4
.text$mn:000013EA _text$mn        ends
.text$mn:000013EA
.text$x:000013EC ; ===========================================================================
.text$x:000013EC
.text$x:000013EC ; Segment type: Pure code
.text$x:000013EC ; Segment permissions: Read/Execute
.text$x:000013EC _text$x         segment para public 'CODE' use32
.text$x:000013EC                 assume cs:_text$x
.text$x:000013EC                 ;org 13ECh
.text$x:000013EC ; COMDAT (pick associative to section at 1388)
.text$x:000013EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000013EC
.text$x:000013EC ; =============== S U B R O U T I N E =======================================
.text$x:000013EC
.text$x:000013EC
.text$x:000013EC __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000013EC                                         ; DATA XREF: .xdata$x:00003784o
.text$x:000013EC                 mov     ecx, [ebp-10h]  ; this
.text$x:000013EF                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000013EF __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000013EF
.text$x:000013F4
.text$x:000013F4 ; =============== S U B R O U T I N E =======================================
.text$x:000013F4
.text$x:000013F4
.text$x:000013F4 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000013F4                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000013F4
.text$x:000013F4 arg_4           = dword ptr  8
.text$x:000013F4
.text$x:000013F4                 mov     edx, [esp+arg_4]
.text$x:000013F8                 lea     eax, [edx+0Ch]
.text$x:000013FB                 mov     ecx, [edx-8]
.text$x:000013FE                 xor     ecx, eax
.text$x:00001400                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001405                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000140A                 jmp     ___CxxFrameHandler3
.text$x:0000140A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000140A
.text$x:0000140A ; ---------------------------------------------------------------------------
.text$x:0000140F                 align 10h
.text$x:0000140F _text$x         ends
.text$x:0000140F
.text$mn:00001410 ; ===========================================================================
.text$mn:00001410
.text$mn:00001410 ; Segment type: Pure code
.text$mn:00001410 ; Segment permissions: Read/Execute
.text$mn:00001410 _text$mn        segment para public 'CODE' use32
.text$mn:00001410                 assume cs:_text$mn
.text$mn:00001410                 ;org 1410h
.text$mn:00001410 ; COMDAT (pick any)
.text$mn:00001410                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001410
.text$mn:00001410 ; =============== S U B R O U T I N E =======================================
.text$mn:00001410
.text$mn:00001410 ; Attributes: bp-based frame
.text$mn:00001410
.text$mn:00001410 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00001410                 public ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001410 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00001410                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+29p
.text$mn:00001410
.text$mn:00001410 var_10          = dword ptr -10h
.text$mn:00001410 var_C           = dword ptr -0Ch
.text$mn:00001410 var_4           = dword ptr -4
.text$mn:00001410
.text$mn:00001410                 push    ebp
.text$mn:00001411                 mov     ebp, esp
.text$mn:00001413                 push    0FFFFFFFFh
.text$mn:00001415                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:0000141A                 mov     eax, large fs:0
.text$mn:00001420                 push    eax
.text$mn:00001421                 push    ecx
.text$mn:00001422                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001427                 xor     eax, ebp
.text$mn:00001429                 push    eax
.text$mn:0000142A                 lea     eax, [ebp+var_C]
.text$mn:0000142D                 mov     large fs:0, eax
.text$mn:00001433                 mov     [ebp+var_10], ecx
.text$mn:00001436                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001439                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000143E                 mov     [ebp+var_4], 0
.text$mn:00001445                 mov     eax, [ebp+var_10]
.text$mn:00001448                 mov     dword ptr [eax+14h], 0
.text$mn:0000144F                 mov     ecx, [ebp+var_10]
.text$mn:00001452                 mov     dword ptr [ecx+18h], 0
.text$mn:00001459                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001460                 mov     eax, [ebp+var_10]
.text$mn:00001463                 mov     ecx, [ebp+var_C]
.text$mn:00001466                 mov     large fs:0, ecx
.text$mn:0000146D                 pop     ecx
.text$mn:0000146E                 mov     esp, ebp
.text$mn:00001470                 pop     ebp
.text$mn:00001471                 retn
.text$mn:00001471 ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00001471
.text$mn:00001471 ; ---------------------------------------------------------------------------
.text$mn:00001472                 align 4
.text$mn:00001472 _text$mn        ends
.text$mn:00001472
.text$x:00001474 ; ===========================================================================
.text$x:00001474
.text$x:00001474 ; Segment type: Pure code
.text$x:00001474 ; Segment permissions: Read/Execute
.text$x:00001474 _text$x         segment para public 'CODE' use32
.text$x:00001474                 assume cs:_text$x
.text$x:00001474                 ;org 1474h
.text$x:00001474 ; COMDAT (pick associative to section at 1410)
.text$x:00001474                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001474
.text$x:00001474 ; =============== S U B R O U T I N E =======================================
.text$x:00001474
.text$x:00001474
.text$x:00001474 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00001474                                         ; DATA XREF: .xdata$x:00003B28o
.text$x:00001474                 mov     ecx, [ebp-10h]  ; this
.text$x:00001477                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001477 __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00001477
.text$x:0000147C
.text$x:0000147C ; =============== S U B R O U T I N E =======================================
.text$x:0000147C
.text$x:0000147C
.text$x:0000147C __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:0000147C                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:0000147C
.text$x:0000147C arg_4           = dword ptr  8
.text$x:0000147C
.text$x:0000147C                 mov     edx, [esp+arg_4]
.text$x:00001480                 lea     eax, [edx+0Ch]
.text$x:00001483                 mov     ecx, [edx-8]
.text$x:00001486                 xor     ecx, eax
.text$x:00001488                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000148D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00001492                 jmp     ___CxxFrameHandler3
.text$x:00001492 __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00001492
.text$x:00001492 ; ---------------------------------------------------------------------------
.text$x:00001497                 align 4
.text$x:00001497 _text$x         ends
.text$x:00001497
.text$mn:00001498 ; ===========================================================================
.text$mn:00001498
.text$mn:00001498 ; Segment type: Pure code
.text$mn:00001498 ; Segment permissions: Read/Execute
.text$mn:00001498 _text$mn        segment para public 'CODE' use32
.text$mn:00001498                 assume cs:_text$mn
.text$mn:00001498                 ;org 1498h
.text$mn:00001498 ; COMDAT (pick any)
.text$mn:00001498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001498
.text$mn:00001498 ; =============== S U B R O U T I N E =======================================
.text$mn:00001498
.text$mn:00001498 ; Attributes: bp-based frame
.text$mn:00001498
.text$mn:00001498 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00001498                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00001498 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00001498                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00001498
.text$mn:00001498 var_4           = dword ptr -4
.text$mn:00001498
.text$mn:00001498                 push    ebp
.text$mn:00001499                 mov     ebp, esp
.text$mn:0000149B                 push    ecx
.text$mn:0000149C                 mov     [ebp+var_4], ecx
.text$mn:0000149F                 mov     ecx, [ebp+var_4]
.text$mn:000014A2                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000014A7                 mov     eax, [ebp+var_4]
.text$mn:000014AA                 mov     esp, ebp
.text$mn:000014AC                 pop     ebp
.text$mn:000014AD                 retn
.text$mn:000014AD ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000014AD
.text$mn:000014AD ; ---------------------------------------------------------------------------
.text$mn:000014AE                 align 10h
.text$mn:000014AE _text$mn        ends
.text$mn:000014AE
.text$mn:000014B0 ; ===========================================================================
.text$mn:000014B0
.text$mn:000014B0 ; Segment type: Pure code
.text$mn:000014B0 ; Segment permissions: Read/Execute
.text$mn:000014B0 _text$mn        segment para public 'CODE' use32
.text$mn:000014B0                 assume cs:_text$mn
.text$mn:000014B0                 ;org 14B0h
.text$mn:000014B0 ; COMDAT (pick any)
.text$mn:000014B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014B0
.text$mn:000014B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000014B0
.text$mn:000014B0 ; Attributes: bp-based frame
.text$mn:000014B0
.text$mn:000014B0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::_Wrap_alloc<class std::allocator<wchar_t>>(void)
.text$mn:000014B0                 public ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ
.text$mn:000014B0 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ proc near
.text$mn:000014B0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)+Ap
.text$mn:000014B0
.text$mn:000014B0 var_4           = dword ptr -4
.text$mn:000014B0
.text$mn:000014B0                 push    ebp
.text$mn:000014B1                 mov     ebp, esp
.text$mn:000014B3                 push    ecx
.text$mn:000014B4                 mov     [ebp+var_4], ecx
.text$mn:000014B7                 mov     ecx, [ebp+var_4]
.text$mn:000014BA                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000014BF                 mov     eax, [ebp+var_4]
.text$mn:000014C2                 mov     esp, ebp
.text$mn:000014C4                 pop     ebp
.text$mn:000014C5                 retn
.text$mn:000014C5 ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ endp
.text$mn:000014C5
.text$mn:000014C5 ; ---------------------------------------------------------------------------
.text$mn:000014C6                 align 4
.text$mn:000014C6 _text$mn        ends
.text$mn:000014C6
.text$mn:000014C8 ; ===========================================================================
.text$mn:000014C8
.text$mn:000014C8 ; Segment type: Pure code
.text$mn:000014C8 ; Segment permissions: Read/Execute
.text$mn:000014C8 _text$mn        segment para public 'CODE' use32
.text$mn:000014C8                 assume cs:_text$mn
.text$mn:000014C8                 ;org 14C8h
.text$mn:000014C8 ; COMDAT (pick any)
.text$mn:000014C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014C8
.text$mn:000014C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014C8
.text$mn:000014C8 ; Attributes: bp-based frame
.text$mn:000014C8
.text$mn:000014C8 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000014C8                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000014C8 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000014C8                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000014C8
.text$mn:000014C8 var_4           = dword ptr -4
.text$mn:000014C8
.text$mn:000014C8                 push    ebp
.text$mn:000014C9                 mov     ebp, esp
.text$mn:000014CB                 push    ecx
.text$mn:000014CC                 mov     [ebp+var_4], ecx
.text$mn:000014CF                 mov     eax, [ebp+var_4]
.text$mn:000014D2                 mov     esp, ebp
.text$mn:000014D4                 pop     ebp
.text$mn:000014D5                 retn
.text$mn:000014D5 ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000014D5
.text$mn:000014D5 ; ---------------------------------------------------------------------------
.text$mn:000014D6                 align 4
.text$mn:000014D6 _text$mn        ends
.text$mn:000014D6
.text$mn:000014D8 ; ===========================================================================
.text$mn:000014D8
.text$mn:000014D8 ; Segment type: Pure code
.text$mn:000014D8 ; Segment permissions: Read/Execute
.text$mn:000014D8 _text$mn        segment para public 'CODE' use32
.text$mn:000014D8                 assume cs:_text$mn
.text$mn:000014D8                 ;org 14D8h
.text$mn:000014D8 ; COMDAT (pick any)
.text$mn:000014D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014D8
.text$mn:000014D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014D8
.text$mn:000014D8 ; Attributes: bp-based frame
.text$mn:000014D8
.text$mn:000014D8 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000014D8                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000014D8 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000014D8                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000014D8                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+Cp ...
.text$mn:000014D8
.text$mn:000014D8 var_4           = dword ptr -4
.text$mn:000014D8
.text$mn:000014D8                 push    ebp
.text$mn:000014D9                 mov     ebp, esp
.text$mn:000014DB                 push    ecx
.text$mn:000014DC                 mov     [ebp+var_4], ecx
.text$mn:000014DF                 mov     eax, [ebp+var_4]
.text$mn:000014E2                 mov     esp, ebp
.text$mn:000014E4                 pop     ebp
.text$mn:000014E5                 retn
.text$mn:000014E5 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000014E5
.text$mn:000014E5 ; ---------------------------------------------------------------------------
.text$mn:000014E6                 align 4
.text$mn:000014E6 _text$mn        ends
.text$mn:000014E6
.text$mn:000014E8 ; ===========================================================================
.text$mn:000014E8
.text$mn:000014E8 ; Segment type: Pure code
.text$mn:000014E8 ; Segment permissions: Read/Execute
.text$mn:000014E8 _text$mn        segment para public 'CODE' use32
.text$mn:000014E8                 assume cs:_text$mn
.text$mn:000014E8                 ;org 14E8h
.text$mn:000014E8 ; COMDAT (pick any)
.text$mn:000014E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014E8
.text$mn:000014E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014E8
.text$mn:000014E8 ; Attributes: bp-based frame
.text$mn:000014E8
.text$mn:000014E8 ; public: __thiscall std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000014E8                 public ??0?$allocator@_W@std@@QAE@XZ
.text$mn:000014E8 ??0?$allocator@_W@std@@QAE@XZ proc near ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)+Ap
.text$mn:000014E8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+2Bp
.text$mn:000014E8
.text$mn:000014E8 var_4           = dword ptr -4
.text$mn:000014E8
.text$mn:000014E8                 push    ebp
.text$mn:000014E9                 mov     ebp, esp
.text$mn:000014EB                 push    ecx
.text$mn:000014EC                 mov     [ebp+var_4], ecx
.text$mn:000014EF                 mov     eax, [ebp+var_4]
.text$mn:000014F2                 mov     esp, ebp
.text$mn:000014F4                 pop     ebp
.text$mn:000014F5                 retn
.text$mn:000014F5 ??0?$allocator@_W@std@@QAE@XZ endp
.text$mn:000014F5
.text$mn:000014F5 ; ---------------------------------------------------------------------------
.text$mn:000014F6                 align 4
.text$mn:000014F6 _text$mn        ends
.text$mn:000014F6
.text$mn:000014F8 ; ===========================================================================
.text$mn:000014F8
.text$mn:000014F8 ; Segment type: Pure code
.text$mn:000014F8 ; Segment permissions: Read/Execute
.text$mn:000014F8 _text$mn        segment para public 'CODE' use32
.text$mn:000014F8                 assume cs:_text$mn
.text$mn:000014F8                 ;org 14F8h
.text$mn:000014F8 ; COMDAT (pick any)
.text$mn:000014F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000014F8
.text$mn:000014F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000014F8
.text$mn:000014F8 ; Attributes: bp-based frame
.text$mn:000014F8
.text$mn:000014F8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000014F8                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000014F8 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000014F8                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000014F8                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000014F8
.text$mn:000014F8 var_14          = dword ptr -14h
.text$mn:000014F8 var_D           = byte ptr -0Dh
.text$mn:000014F8 var_C           = dword ptr -0Ch
.text$mn:000014F8 var_4           = dword ptr -4
.text$mn:000014F8 Str             = dword ptr  8
.text$mn:000014F8
.text$mn:000014F8                 push    ebp
.text$mn:000014F9                 mov     ebp, esp
.text$mn:000014FB                 push    0FFFFFFFFh
.text$mn:000014FD                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00001502                 mov     eax, large fs:0
.text$mn:00001508                 push    eax
.text$mn:00001509                 sub     esp, 8
.text$mn:0000150C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001511                 xor     eax, ebp
.text$mn:00001513                 push    eax
.text$mn:00001514                 lea     eax, [ebp+var_C]
.text$mn:00001517                 mov     large fs:0, eax
.text$mn:0000151D                 mov     [ebp+var_14], ecx
.text$mn:00001520                 lea     ecx, [ebp+var_D]
.text$mn:00001523                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001528                 push    eax
.text$mn:00001529                 mov     ecx, [ebp+var_14]
.text$mn:0000152C                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00001531                 mov     [ebp+var_4], 0
.text$mn:00001538                 push    0               ; Size
.text$mn:0000153A                 push    0               ; char
.text$mn:0000153C                 mov     ecx, [ebp+var_14]
.text$mn:0000153F                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001544                 mov     eax, [ebp+Str]
.text$mn:00001547                 push    eax             ; Str
.text$mn:00001548                 mov     ecx, [ebp+var_14]
.text$mn:0000154B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00001550                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001557                 mov     eax, [ebp+var_14]
.text$mn:0000155A                 mov     ecx, [ebp+var_C]
.text$mn:0000155D                 mov     large fs:0, ecx
.text$mn:00001564                 pop     ecx
.text$mn:00001565                 mov     esp, ebp
.text$mn:00001567                 pop     ebp
.text$mn:00001568                 retn    4
.text$mn:00001568 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00001568
.text$mn:00001568 ; ---------------------------------------------------------------------------
.text$mn:0000156B                 align 4
.text$mn:0000156B _text$mn        ends
.text$mn:0000156B
.text$x:0000156C ; ===========================================================================
.text$x:0000156C
.text$x:0000156C ; Segment type: Pure code
.text$x:0000156C ; Segment permissions: Read/Execute
.text$x:0000156C _text$x         segment para public 'CODE' use32
.text$x:0000156C                 assume cs:_text$x
.text$x:0000156C                 ;org 156Ch
.text$x:0000156C ; COMDAT (pick associative to section at 14F8)
.text$x:0000156C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000156C
.text$x:0000156C ; =============== S U B R O U T I N E =======================================
.text$x:0000156C
.text$x:0000156C
.text$x:0000156C __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:0000156C                                         ; DATA XREF: .xdata$x:00003834o
.text$x:0000156C                 mov     ecx, [ebp-14h]
.text$x:0000156F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000156F __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:0000156F
.text$x:00001574
.text$x:00001574 ; =============== S U B R O U T I N E =======================================
.text$x:00001574
.text$x:00001574
.text$x:00001574 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00001574                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00001574
.text$x:00001574 arg_4           = dword ptr  8
.text$x:00001574
.text$x:00001574                 mov     edx, [esp+arg_4]
.text$x:00001578                 lea     eax, [edx+0Ch]
.text$x:0000157B                 mov     ecx, [edx-0Ch]
.text$x:0000157E                 xor     ecx, eax
.text$x:00001580                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001585                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:0000158A                 jmp     ___CxxFrameHandler3
.text$x:0000158A __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:0000158A
.text$x:0000158A ; ---------------------------------------------------------------------------
.text$x:0000158F                 align 10h
.text$x:0000158F _text$x         ends
.text$x:0000158F
.text$mn:00001590 ; ===========================================================================
.text$mn:00001590
.text$mn:00001590 ; Segment type: Pure code
.text$mn:00001590 ; Segment permissions: Read/Execute
.text$mn:00001590 _text$mn        segment para public 'CODE' use32
.text$mn:00001590                 assume cs:_text$mn
.text$mn:00001590                 ;org 1590h
.text$mn:00001590 ; COMDAT (pick any)
.text$mn:00001590                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001590
.text$mn:00001590 ; =============== S U B R O U T I N E =======================================
.text$mn:00001590
.text$mn:00001590 ; Attributes: bp-based frame
.text$mn:00001590
.text$mn:00001590 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t *Str)
.text$mn:00001590                 public ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:00001590 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$mn:00001590                                         ; CODE XREF: ListView::getAscii(uchar)+5Cp
.text$mn:00001590                                         ; ListView::getAscii(uchar)+81p ...
.text$mn:00001590
.text$mn:00001590 var_14          = dword ptr -14h
.text$mn:00001590 var_D           = byte ptr -0Dh
.text$mn:00001590 var_C           = dword ptr -0Ch
.text$mn:00001590 var_4           = dword ptr -4
.text$mn:00001590 Str             = dword ptr  8
.text$mn:00001590
.text$mn:00001590                 push    ebp
.text$mn:00001591                 mov     ebp, esp
.text$mn:00001593                 push    0FFFFFFFFh
.text$mn:00001595                 push    offset __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$mn:0000159A                 mov     eax, large fs:0
.text$mn:000015A0                 push    eax
.text$mn:000015A1                 sub     esp, 8
.text$mn:000015A4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000015A9                 xor     eax, ebp
.text$mn:000015AB                 push    eax
.text$mn:000015AC                 lea     eax, [ebp+var_C]
.text$mn:000015AF                 mov     large fs:0, eax
.text$mn:000015B5                 mov     [ebp+var_14], ecx
.text$mn:000015B8                 lea     ecx, [ebp+var_D]
.text$mn:000015BB                 call    ??0?$allocator@_W@std@@QAE@XZ ; std::allocator<wchar_t>::allocator<wchar_t>(void)
.text$mn:000015C0                 push    eax
.text$mn:000015C1                 mov     ecx, [ebp+var_14]
.text$mn:000015C4                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)
.text$mn:000015C9                 mov     [ebp+var_4], 0
.text$mn:000015D0                 push    0
.text$mn:000015D2                 push    0
.text$mn:000015D4                 mov     ecx, [ebp+var_14]
.text$mn:000015D7                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000015DC                 mov     eax, [ebp+Str]
.text$mn:000015DF                 push    eax             ; Str
.text$mn:000015E0                 mov     ecx, [ebp+var_14]
.text$mn:000015E3                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)
.text$mn:000015E8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000015EF                 mov     eax, [ebp+var_14]
.text$mn:000015F2                 mov     ecx, [ebp+var_C]
.text$mn:000015F5                 mov     large fs:0, ecx
.text$mn:000015FC                 pop     ecx
.text$mn:000015FD                 mov     esp, ebp
.text$mn:000015FF                 pop     ebp
.text$mn:00001600                 retn    4
.text$mn:00001600 ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$mn:00001600
.text$mn:00001600 ; ---------------------------------------------------------------------------
.text$mn:00001603                 align 4
.text$mn:00001603 _text$mn        ends
.text$mn:00001603
.text$x:00001604 ; ===========================================================================
.text$x:00001604
.text$x:00001604 ; Segment type: Pure code
.text$x:00001604 ; Segment permissions: Read/Execute
.text$x:00001604 _text$x         segment para public 'CODE' use32
.text$x:00001604                 assume cs:_text$x
.text$x:00001604                 ;org 1604h
.text$x:00001604 ; COMDAT (pick associative to section at 1590)
.text$x:00001604                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001604
.text$x:00001604 ; =============== S U B R O U T I N E =======================================
.text$x:00001604
.text$x:00001604
.text$x:00001604 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 proc near
.text$x:00001604                                         ; DATA XREF: .xdata$x:00003BD8o
.text$x:00001604                 mov     ecx, [ebp-14h]
.text$x:00001607                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00001607 __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0 endp
.text$x:00001607
.text$x:0000160C
.text$x:0000160C ; =============== S U B R O U T I N E =======================================
.text$x:0000160C
.text$x:0000160C
.text$x:0000160C __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z proc near
.text$x:0000160C                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+5o
.text$x:0000160C
.text$x:0000160C arg_4           = dword ptr  8
.text$x:0000160C
.text$x:0000160C                 mov     edx, [esp+arg_4]
.text$x:00001610                 lea     eax, [edx+0Ch]
.text$x:00001613                 mov     ecx, [edx-0Ch]
.text$x:00001616                 xor     ecx, eax
.text$x:00001618                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000161D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.text$x:00001622                 jmp     ___CxxFrameHandler3
.text$x:00001622 __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z endp
.text$x:00001622
.text$x:00001622 ; ---------------------------------------------------------------------------
.text$x:00001627                 align 4
.text$x:00001627 _text$x         ends
.text$x:00001627
.text$mn:00001628 ; ===========================================================================
.text$mn:00001628
.text$mn:00001628 ; Segment type: Pure code
.text$mn:00001628 ; Segment permissions: Read/Execute
.text$mn:00001628 _text$mn        segment para public 'CODE' use32
.text$mn:00001628                 assume cs:_text$mn
.text$mn:00001628                 ;org 1628h
.text$mn:00001628 ; COMDAT (pick any)
.text$mn:00001628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001628
.text$mn:00001628 ; =============== S U B R O U T I N E =======================================
.text$mn:00001628
.text$mn:00001628 ; Attributes: bp-based frame
.text$mn:00001628
.text$mn:00001628 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001628                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001628 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001628                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001628                                         ; std::_String_val<std::_Simple_types<wchar_t>>::_String_val<std::_Simple_types<wchar_t>>(void)+29p
.text$mn:00001628
.text$mn:00001628 var_4           = dword ptr -4
.text$mn:00001628
.text$mn:00001628                 push    ebp
.text$mn:00001629                 mov     ebp, esp
.text$mn:0000162B                 push    ecx
.text$mn:0000162C                 mov     [ebp+var_4], ecx
.text$mn:0000162F                 mov     eax, [ebp+var_4]
.text$mn:00001632                 mov     dword ptr [eax], 0
.text$mn:00001638                 mov     eax, [ebp+var_4]
.text$mn:0000163B                 mov     esp, ebp
.text$mn:0000163D                 pop     ebp
.text$mn:0000163E                 retn
.text$mn:0000163E ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000163E
.text$mn:0000163E ; ---------------------------------------------------------------------------
.text$mn:0000163F                 align 10h
.text$mn:0000163F _text$mn        ends
.text$mn:0000163F
.text$mn:00001640 ; ===========================================================================
.text$mn:00001640
.text$mn:00001640 ; Segment type: Pure code
.text$mn:00001640 ; Segment permissions: Read/Execute
.text$mn:00001640 _text$mn        segment para public 'CODE' use32
.text$mn:00001640                 assume cs:_text$mn
.text$mn:00001640                 ;org 1640h
.text$mn:00001640 ; COMDAT (pick any)
.text$mn:00001640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001640
.text$mn:00001640 ; =============== S U B R O U T I N E =======================================
.text$mn:00001640
.text$mn:00001640 ; Attributes: bp-based frame
.text$mn:00001640
.text$mn:00001640 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00001640                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00001640 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00001640                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00001640                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+23p
.text$mn:00001640
.text$mn:00001640 var_4           = dword ptr -4
.text$mn:00001640
.text$mn:00001640                 push    ebp
.text$mn:00001641                 mov     ebp, esp
.text$mn:00001643                 push    ecx
.text$mn:00001644                 mov     [ebp+var_4], ecx
.text$mn:00001647                 mov     eax, [ebp+var_4]
.text$mn:0000164A                 mov     dword ptr [eax], 0
.text$mn:00001650                 mov     ecx, [ebp+var_4]
.text$mn:00001653                 mov     dword ptr [ecx+4], 0
.text$mn:0000165A                 mov     eax, [ebp+var_4]
.text$mn:0000165D                 mov     esp, ebp
.text$mn:0000165F                 pop     ebp
.text$mn:00001660                 retn
.text$mn:00001660 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00001660
.text$mn:00001660 ; ---------------------------------------------------------------------------
.text$mn:00001661                 align 4
.text$mn:00001661 _text$mn        ends
.text$mn:00001661
.text$mn:00001664 ; ===========================================================================
.text$mn:00001664
.text$mn:00001664 ; Segment type: Pure code
.text$mn:00001664 ; Segment permissions: Read/Execute
.text$mn:00001664 _text$mn        segment para public 'CODE' use32
.text$mn:00001664                 assume cs:_text$mn
.text$mn:00001664                 ;org 1664h
.text$mn:00001664 ; COMDAT (pick any)
.text$mn:00001664                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001664
.text$mn:00001664 ; =============== S U B R O U T I N E =======================================
.text$mn:00001664
.text$mn:00001664 ; Attributes: bp-based frame
.text$mn:00001664
.text$mn:00001664 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001664                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00001664 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00001664                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00001664                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00001664
.text$mn:00001664 var_10          = dword ptr -10h
.text$mn:00001664 var_C           = dword ptr -0Ch
.text$mn:00001664 var_4           = dword ptr -4
.text$mn:00001664
.text$mn:00001664                 push    ebp
.text$mn:00001665                 mov     ebp, esp
.text$mn:00001667                 push    0FFFFFFFFh
.text$mn:00001669                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:0000166E                 mov     eax, large fs:0
.text$mn:00001674                 push    eax
.text$mn:00001675                 push    ecx
.text$mn:00001676                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000167B                 xor     eax, ebp
.text$mn:0000167D                 push    eax
.text$mn:0000167E                 lea     eax, [ebp+var_C]
.text$mn:00001681                 mov     large fs:0, eax
.text$mn:00001687                 mov     [ebp+var_10], ecx
.text$mn:0000168A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000168D                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00001692                 mov     [ebp+var_4], 0
.text$mn:00001699                 mov     eax, [ebp+var_10]
.text$mn:0000169C                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000016A2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016A9                 mov     eax, [ebp+var_10]
.text$mn:000016AC                 mov     ecx, [ebp+var_C]
.text$mn:000016AF                 mov     large fs:0, ecx
.text$mn:000016B6                 pop     ecx
.text$mn:000016B7                 mov     esp, ebp
.text$mn:000016B9                 pop     ebp
.text$mn:000016BA                 retn
.text$mn:000016BA ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000016BA
.text$mn:000016BA ; ---------------------------------------------------------------------------
.text$mn:000016BB                 align 4
.text$mn:000016BB _text$mn        ends
.text$mn:000016BB
.text$x:000016BC ; ===========================================================================
.text$x:000016BC
.text$x:000016BC ; Segment type: Pure code
.text$x:000016BC ; Segment permissions: Read/Execute
.text$x:000016BC _text$x         segment para public 'CODE' use32
.text$x:000016BC                 assume cs:_text$x
.text$x:000016BC                 ;org 16BCh
.text$x:000016BC ; COMDAT (pick associative to section at 1664)
.text$x:000016BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000016BC
.text$x:000016BC ; =============== S U B R O U T I N E =======================================
.text$x:000016BC
.text$x:000016BC
.text$x:000016BC __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000016BC                                         ; DATA XREF: .xdata$x:0000399Co
.text$x:000016BC                 mov     ecx, [ebp-10h]  ; this
.text$x:000016BF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000016BF __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000016BF
.text$x:000016C4
.text$x:000016C4 ; =============== S U B R O U T I N E =======================================
.text$x:000016C4
.text$x:000016C4
.text$x:000016C4 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:000016C4                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:000016C4
.text$x:000016C4 arg_4           = dword ptr  8
.text$x:000016C4
.text$x:000016C4                 mov     edx, [esp+arg_4]
.text$x:000016C8                 lea     eax, [edx+0Ch]
.text$x:000016CB                 mov     ecx, [edx-8]
.text$x:000016CE                 xor     ecx, eax
.text$x:000016D0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000016D5                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:000016DA                 jmp     ___CxxFrameHandler3
.text$x:000016DA __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:000016DA
.text$x:000016DA ; ---------------------------------------------------------------------------
.text$x:000016DF                 align 10h
.text$x:000016DF _text$x         ends
.text$x:000016DF
.text$mn:000016E0 ; ===========================================================================
.text$mn:000016E0
.text$mn:000016E0 ; Segment type: Pure code
.text$mn:000016E0 ; Segment permissions: Read/Execute
.text$mn:000016E0 _text$mn        segment para public 'CODE' use32
.text$mn:000016E0                 assume cs:_text$mn
.text$mn:000016E0                 ;org 16E0h
.text$mn:000016E0 ; COMDAT (pick any)
.text$mn:000016E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000016E0
.text$mn:000016E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000016E0
.text$mn:000016E0 ; Attributes: bp-based frame
.text$mn:000016E0
.text$mn:000016E0 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:000016E0                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000016E0 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:000016E0                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:000016E0
.text$mn:000016E0 var_10          = dword ptr -10h
.text$mn:000016E0 var_C           = dword ptr -0Ch
.text$mn:000016E0 var_4           = dword ptr -4
.text$mn:000016E0
.text$mn:000016E0                 push    ebp
.text$mn:000016E1                 mov     ebp, esp
.text$mn:000016E3                 push    0FFFFFFFFh
.text$mn:000016E5                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:000016EA                 mov     eax, large fs:0
.text$mn:000016F0                 push    eax
.text$mn:000016F1                 push    ecx
.text$mn:000016F2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016F7                 xor     eax, ebp
.text$mn:000016F9                 push    eax
.text$mn:000016FA                 lea     eax, [ebp+var_C]
.text$mn:000016FD                 mov     large fs:0, eax
.text$mn:00001703                 mov     [ebp+var_10], ecx
.text$mn:00001706                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001709                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000170E                 mov     [ebp+var_4], 0
.text$mn:00001715                 mov     eax, [ebp+var_10]
.text$mn:00001718                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000171E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001725                 mov     eax, [ebp+var_10]
.text$mn:00001728                 mov     ecx, [ebp+var_C]
.text$mn:0000172B                 mov     large fs:0, ecx
.text$mn:00001732                 pop     ecx
.text$mn:00001733                 mov     esp, ebp
.text$mn:00001735                 pop     ebp
.text$mn:00001736                 retn
.text$mn:00001736 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001736
.text$mn:00001736 ; ---------------------------------------------------------------------------
.text$mn:00001737                 align 4
.text$mn:00001737 _text$mn        ends
.text$mn:00001737
.text$x:00001738 ; ===========================================================================
.text$x:00001738
.text$x:00001738 ; Segment type: Pure code
.text$x:00001738 ; Segment permissions: Read/Execute
.text$x:00001738 _text$x         segment para public 'CODE' use32
.text$x:00001738                 assume cs:_text$x
.text$x:00001738                 ;org 1738h
.text$x:00001738 ; COMDAT (pick associative to section at 16E0)
.text$x:00001738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001738
.text$x:00001738 ; =============== S U B R O U T I N E =======================================
.text$x:00001738
.text$x:00001738
.text$x:00001738 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001738                                         ; DATA XREF: .xdata$x:00003A20o
.text$x:00001738                 mov     ecx, [ebp-10h]  ; this
.text$x:0000173B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000173B __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000173B
.text$x:00001740
.text$x:00001740 ; =============== S U B R O U T I N E =======================================
.text$x:00001740
.text$x:00001740
.text$x:00001740 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00001740                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00001740
.text$x:00001740 arg_4           = dword ptr  8
.text$x:00001740
.text$x:00001740                 mov     edx, [esp+arg_4]
.text$x:00001744                 lea     eax, [edx+0Ch]
.text$x:00001747                 mov     ecx, [edx-8]
.text$x:0000174A                 xor     ecx, eax
.text$x:0000174C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001751                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00001756                 jmp     ___CxxFrameHandler3
.text$x:00001756 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00001756
.text$x:00001756 ; ---------------------------------------------------------------------------
.text$x:0000175B                 align 4
.text$x:0000175B _text$x         ends
.text$x:0000175B
.text$mn:0000175C ; ===========================================================================
.text$mn:0000175C
.text$mn:0000175C ; Segment type: Pure code
.text$mn:0000175C ; Segment permissions: Read/Execute
.text$mn:0000175C _text$mn        segment para public 'CODE' use32
.text$mn:0000175C                 assume cs:_text$mn
.text$mn:0000175C                 ;org 175Ch
.text$mn:0000175C ; COMDAT (pick any)
.text$mn:0000175C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000175C
.text$mn:0000175C ; =============== S U B R O U T I N E =======================================
.text$mn:0000175C
.text$mn:0000175C ; Attributes: bp-based frame
.text$mn:0000175C
.text$mn:0000175C ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000175C                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:0000175C ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:0000175C                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000175C
.text$mn:0000175C var_10          = dword ptr -10h
.text$mn:0000175C var_C           = dword ptr -0Ch
.text$mn:0000175C var_4           = dword ptr -4
.text$mn:0000175C
.text$mn:0000175C                 push    ebp
.text$mn:0000175D                 mov     ebp, esp
.text$mn:0000175F                 push    0FFFFFFFFh
.text$mn:00001761                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00001766                 mov     eax, large fs:0
.text$mn:0000176C                 push    eax
.text$mn:0000176D                 push    ecx
.text$mn:0000176E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001773                 xor     eax, ebp
.text$mn:00001775                 push    eax
.text$mn:00001776                 lea     eax, [ebp+var_C]
.text$mn:00001779                 mov     large fs:0, eax
.text$mn:0000177F                 mov     [ebp+var_10], ecx
.text$mn:00001782                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001785                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000178A                 mov     [ebp+var_4], 0
.text$mn:00001791                 mov     eax, [ebp+var_10]
.text$mn:00001794                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:0000179A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017A1                 mov     eax, [ebp+var_10]
.text$mn:000017A4                 mov     ecx, [ebp+var_C]
.text$mn:000017A7                 mov     large fs:0, ecx
.text$mn:000017AE                 pop     ecx
.text$mn:000017AF                 mov     esp, ebp
.text$mn:000017B1                 pop     ebp
.text$mn:000017B2                 retn
.text$mn:000017B2 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:000017B2
.text$mn:000017B2 ; ---------------------------------------------------------------------------
.text$mn:000017B3                 align 4
.text$mn:000017B3 _text$mn        ends
.text$mn:000017B3
.text$x:000017B4 ; ===========================================================================
.text$x:000017B4
.text$x:000017B4 ; Segment type: Pure code
.text$x:000017B4 ; Segment permissions: Read/Execute
.text$x:000017B4 _text$x         segment para public 'CODE' use32
.text$x:000017B4                 assume cs:_text$x
.text$x:000017B4                 ;org 17B4h
.text$x:000017B4 ; COMDAT (pick associative to section at 175C)
.text$x:000017B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000017B4
.text$x:000017B4 ; =============== S U B R O U T I N E =======================================
.text$x:000017B4
.text$x:000017B4
.text$x:000017B4 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:000017B4                                         ; DATA XREF: .xdata$x:00003AA4o
.text$x:000017B4                 mov     ecx, [ebp-10h]  ; this
.text$x:000017B7                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:000017B7 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:000017B7
.text$x:000017BC
.text$x:000017BC ; =============== S U B R O U T I N E =======================================
.text$x:000017BC
.text$x:000017BC
.text$x:000017BC __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:000017BC                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:000017BC
.text$x:000017BC arg_4           = dword ptr  8
.text$x:000017BC
.text$x:000017BC                 mov     edx, [esp+arg_4]
.text$x:000017C0                 lea     eax, [edx+0Ch]
.text$x:000017C3                 mov     ecx, [edx-8]
.text$x:000017C6                 xor     ecx, eax
.text$x:000017C8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000017CD                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:000017D2                 jmp     ___CxxFrameHandler3
.text$x:000017D2 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:000017D2
.text$x:000017D2 ; ---------------------------------------------------------------------------
.text$x:000017D7                 align 4
.text$x:000017D7 _text$x         ends
.text$x:000017D7
.text$mn:000017D8 ; ===========================================================================
.text$mn:000017D8
.text$mn:000017D8 ; Segment type: Pure code
.text$mn:000017D8 ; Segment permissions: Read/Execute
.text$mn:000017D8 _text$mn        segment para public 'CODE' use32
.text$mn:000017D8                 assume cs:_text$mn
.text$mn:000017D8                 ;org 17D8h
.text$mn:000017D8 ; COMDAT (pick any)
.text$mn:000017D8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017D8
.text$mn:000017D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000017D8
.text$mn:000017D8 ; Attributes: bp-based frame
.text$mn:000017D8
.text$mn:000017D8 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:000017D8                 public ??0error_category@std@@QAE@XZ
.text$mn:000017D8 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:000017D8
.text$mn:000017D8 var_4           = dword ptr -4
.text$mn:000017D8
.text$mn:000017D8                 push    ebp
.text$mn:000017D9                 mov     ebp, esp
.text$mn:000017DB                 push    ecx
.text$mn:000017DC                 mov     [ebp+var_4], ecx
.text$mn:000017DF                 mov     eax, [ebp+var_4]
.text$mn:000017E2                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:000017E8                 mov     eax, [ebp+var_4]
.text$mn:000017EB                 mov     esp, ebp
.text$mn:000017ED                 pop     ebp
.text$mn:000017EE                 retn
.text$mn:000017EE ??0error_category@std@@QAE@XZ endp
.text$mn:000017EE
.text$mn:000017EE ; ---------------------------------------------------------------------------
.text$mn:000017EF                 align 10h
.text$mn:000017EF _text$mn        ends
.text$mn:000017EF
.text$mn:000017F0 ; ===========================================================================
.text$mn:000017F0
.text$mn:000017F0 ; Segment type: Pure code
.text$mn:000017F0 ; Segment permissions: Read/Execute
.text$mn:000017F0 _text$mn        segment para public 'CODE' use32
.text$mn:000017F0                 assume cs:_text$mn
.text$mn:000017F0                 ;org 17F0h
.text$mn:000017F0 ; COMDAT (pick any)
.text$mn:000017F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000017F0
.text$mn:000017F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017F0
.text$mn:000017F0 ; Attributes: bp-based frame
.text$mn:000017F0
.text$mn:000017F0 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:000017F0                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:000017F0 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:000017F0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:000017F0                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:000017F0
.text$mn:000017F0 var_4           = dword ptr -4
.text$mn:000017F0 arg_0           = dword ptr  8
.text$mn:000017F0 arg_4           = dword ptr  0Ch
.text$mn:000017F0
.text$mn:000017F0                 push    ebp
.text$mn:000017F1                 mov     ebp, esp
.text$mn:000017F3                 push    ecx
.text$mn:000017F4                 mov     [ebp+var_4], ecx
.text$mn:000017F7                 mov     eax, [ebp+var_4]
.text$mn:000017FA                 mov     ecx, [ebp+arg_0]
.text$mn:000017FD                 mov     [eax], ecx
.text$mn:000017FF                 mov     edx, [ebp+var_4]
.text$mn:00001802                 mov     eax, [ebp+arg_4]
.text$mn:00001805                 mov     [edx+4], eax
.text$mn:00001808                 mov     eax, [ebp+var_4]
.text$mn:0000180B                 mov     esp, ebp
.text$mn:0000180D                 pop     ebp
.text$mn:0000180E                 retn    8
.text$mn:0000180E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:0000180E
.text$mn:0000180E ; ---------------------------------------------------------------------------
.text$mn:00001811                 align 4
.text$mn:00001811 _text$mn        ends
.text$mn:00001811
.text$mn:00001814 ; ===========================================================================
.text$mn:00001814
.text$mn:00001814 ; Segment type: Pure code
.text$mn:00001814 ; Segment permissions: Read/Execute
.text$mn:00001814 _text$mn        segment para public 'CODE' use32
.text$mn:00001814                 assume cs:_text$mn
.text$mn:00001814                 ;org 1814h
.text$mn:00001814 ; COMDAT (pick any)
.text$mn:00001814                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001814
.text$mn:00001814 ; =============== S U B R O U T I N E =======================================
.text$mn:00001814
.text$mn:00001814 ; Attributes: bp-based frame
.text$mn:00001814
.text$mn:00001814 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001814                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001814 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001814                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001814
.text$mn:00001814 var_4           = dword ptr -4
.text$mn:00001814 arg_0           = dword ptr  8
.text$mn:00001814
.text$mn:00001814                 push    ebp
.text$mn:00001815                 mov     ebp, esp
.text$mn:00001817                 push    ecx
.text$mn:00001818                 mov     [ebp+var_4], ecx
.text$mn:0000181B                 mov     eax, [ebp+var_4]
.text$mn:0000181E                 mov     ecx, [ebp+arg_0]
.text$mn:00001821                 mov     [eax], ecx
.text$mn:00001823                 mov     eax, [ebp+var_4]
.text$mn:00001826                 mov     esp, ebp
.text$mn:00001828                 pop     ebp
.text$mn:00001829                 retn    4
.text$mn:00001829 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001829
.text$mn:00001829 _text$mn        ends
.text$mn:00001829
.text$mn:0000182C ; ===========================================================================
.text$mn:0000182C
.text$mn:0000182C ; Segment type: Pure code
.text$mn:0000182C ; Segment permissions: Read/Execute
.text$mn:0000182C _text$mn        segment para public 'CODE' use32
.text$mn:0000182C                 assume cs:_text$mn
.text$mn:0000182C                 ;org 182Ch
.text$mn:0000182C ; COMDAT (pick any)
.text$mn:0000182C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000182C
.text$mn:0000182C ; =============== S U B R O U T I N E =======================================
.text$mn:0000182C
.text$mn:0000182C ; Attributes: bp-based frame
.text$mn:0000182C
.text$mn:0000182C ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:0000182C                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:0000182C ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:0000182C                                         ; DATA XREF: .xdata$x:00003E34o
.text$mn:0000182C
.text$mn:0000182C var_10          = dword ptr -10h
.text$mn:0000182C var_C           = dword ptr -0Ch
.text$mn:0000182C var_4           = dword ptr -4
.text$mn:0000182C arg_0           = dword ptr  8
.text$mn:0000182C
.text$mn:0000182C                 push    ebp
.text$mn:0000182D                 mov     ebp, esp
.text$mn:0000182F                 push    0FFFFFFFFh
.text$mn:00001831                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00001836                 mov     eax, large fs:0
.text$mn:0000183C                 push    eax
.text$mn:0000183D                 push    ecx
.text$mn:0000183E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001843                 xor     eax, ebp
.text$mn:00001845                 push    eax
.text$mn:00001846                 lea     eax, [ebp+var_C]
.text$mn:00001849                 mov     large fs:0, eax
.text$mn:0000184F                 mov     [ebp+var_10], ecx
.text$mn:00001852                 mov     eax, [ebp+arg_0]
.text$mn:00001855                 push    eax             ; struct std::exception *
.text$mn:00001856                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001859                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:0000185E                 mov     [ebp+var_4], 0
.text$mn:00001865                 mov     ecx, [ebp+var_10]
.text$mn:00001868                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:0000186E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001875                 mov     eax, [ebp+var_10]
.text$mn:00001878                 mov     ecx, [ebp+var_C]
.text$mn:0000187B                 mov     large fs:0, ecx
.text$mn:00001882                 pop     ecx
.text$mn:00001883                 mov     esp, ebp
.text$mn:00001885                 pop     ebp
.text$mn:00001886                 retn    4
.text$mn:00001886 ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00001886
.text$mn:00001886 ; ---------------------------------------------------------------------------
.text$mn:00001889                 align 4
.text$mn:00001889 _text$mn        ends
.text$mn:00001889
.text$x:0000188C ; ===========================================================================
.text$x:0000188C
.text$x:0000188C ; Segment type: Pure code
.text$x:0000188C ; Segment permissions: Read/Execute
.text$x:0000188C _text$x         segment para public 'CODE' use32
.text$x:0000188C                 assume cs:_text$x
.text$x:0000188C                 ;org 188Ch
.text$x:0000188C ; COMDAT (pick associative to section at 182C)
.text$x:0000188C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000188C
.text$x:0000188C ; =============== S U B R O U T I N E =======================================
.text$x:0000188C
.text$x:0000188C
.text$x:0000188C __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000188C                                         ; DATA XREF: .xdata$x:00003970o
.text$x:0000188C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000188F                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:0000188F __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:0000188F
.text$x:00001894
.text$x:00001894 ; =============== S U B R O U T I N E =======================================
.text$x:00001894
.text$x:00001894
.text$x:00001894 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00001894                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00001894
.text$x:00001894 arg_4           = dword ptr  8
.text$x:00001894
.text$x:00001894                 mov     edx, [esp+arg_4]
.text$x:00001898                 lea     eax, [edx+0Ch]
.text$x:0000189B                 mov     ecx, [edx-8]
.text$x:0000189E                 xor     ecx, eax
.text$x:000018A0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000018A5                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:000018AA                 jmp     ___CxxFrameHandler3
.text$x:000018AA __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:000018AA
.text$x:000018AA ; ---------------------------------------------------------------------------
.text$x:000018AF                 align 10h
.text$x:000018AF _text$x         ends
.text$x:000018AF
.text$mn:000018B0 ; ===========================================================================
.text$mn:000018B0
.text$mn:000018B0 ; Segment type: Pure code
.text$mn:000018B0 ; Segment permissions: Read/Execute
.text$mn:000018B0 _text$mn        segment para public 'CODE' use32
.text$mn:000018B0                 assume cs:_text$mn
.text$mn:000018B0                 ;org 18B0h
.text$mn:000018B0 ; COMDAT (pick any)
.text$mn:000018B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000018B0
.text$mn:000018B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000018B0
.text$mn:000018B0 ; Attributes: bp-based frame
.text$mn:000018B0
.text$mn:000018B0 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:000018B0                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:000018B0 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:000018B0                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+A9p
.text$mn:000018B0
.text$mn:000018B0 var_10          = dword ptr -10h
.text$mn:000018B0 var_C           = dword ptr -0Ch
.text$mn:000018B0 var_4           = dword ptr -4
.text$mn:000018B0 arg_0           = dword ptr  8
.text$mn:000018B0
.text$mn:000018B0                 push    ebp
.text$mn:000018B1                 mov     ebp, esp
.text$mn:000018B3                 push    0FFFFFFFFh
.text$mn:000018B5                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:000018BA                 mov     eax, large fs:0
.text$mn:000018C0                 push    eax
.text$mn:000018C1                 push    ecx
.text$mn:000018C2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018C7                 xor     eax, ebp
.text$mn:000018C9                 push    eax
.text$mn:000018CA                 lea     eax, [ebp+var_C]
.text$mn:000018CD                 mov     large fs:0, eax
.text$mn:000018D3                 mov     [ebp+var_10], ecx
.text$mn:000018D6                 lea     eax, [ebp+arg_0]
.text$mn:000018D9                 push    eax             ; char **
.text$mn:000018DA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000018DD                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:000018E2                 mov     [ebp+var_4], 0
.text$mn:000018E9                 mov     ecx, [ebp+var_10]
.text$mn:000018EC                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:000018F2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018F9                 mov     eax, [ebp+var_10]
.text$mn:000018FC                 mov     ecx, [ebp+var_C]
.text$mn:000018FF                 mov     large fs:0, ecx
.text$mn:00001906                 pop     ecx
.text$mn:00001907                 mov     esp, ebp
.text$mn:00001909                 pop     ebp
.text$mn:0000190A                 retn    4
.text$mn:0000190A ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:0000190A
.text$mn:0000190A ; ---------------------------------------------------------------------------
.text$mn:0000190D                 align 10h
.text$mn:0000190D _text$mn        ends
.text$mn:0000190D
.text$x:00001910 ; ===========================================================================
.text$x:00001910
.text$x:00001910 ; Segment type: Pure code
.text$x:00001910 ; Segment permissions: Read/Execute
.text$x:00001910 _text$x         segment para public 'CODE' use32
.text$x:00001910                 assume cs:_text$x
.text$x:00001910                 ;org 1910h
.text$x:00001910 ; COMDAT (pick associative to section at 18B0)
.text$x:00001910                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001910
.text$x:00001910 ; =============== S U B R O U T I N E =======================================
.text$x:00001910
.text$x:00001910
.text$x:00001910 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00001910                                         ; DATA XREF: .xdata$x:00003918o
.text$x:00001910                 mov     ecx, [ebp-10h]  ; this
.text$x:00001913                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00001913 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00001913
.text$x:00001918
.text$x:00001918 ; =============== S U B R O U T I N E =======================================
.text$x:00001918
.text$x:00001918
.text$x:00001918 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00001918                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00001918
.text$x:00001918 arg_4           = dword ptr  8
.text$x:00001918
.text$x:00001918                 mov     edx, [esp+arg_4]
.text$x:0000191C                 lea     eax, [edx+0Ch]
.text$x:0000191F                 mov     ecx, [edx-8]
.text$x:00001922                 xor     ecx, eax
.text$x:00001924                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001929                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:0000192E                 jmp     ___CxxFrameHandler3
.text$x:0000192E __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:0000192E
.text$x:0000192E ; ---------------------------------------------------------------------------
.text$x:00001933                 align 4
.text$x:00001933 _text$x         ends
.text$x:00001933
.text$mn:00001934 ; ===========================================================================
.text$mn:00001934
.text$mn:00001934 ; Segment type: Pure code
.text$mn:00001934 ; Segment permissions: Read/Execute
.text$mn:00001934 _text$mn        segment para public 'CODE' use32
.text$mn:00001934                 assume cs:_text$mn
.text$mn:00001934                 ;org 1934h
.text$mn:00001934 ; COMDAT (pick any)
.text$mn:00001934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001934
.text$mn:00001934 ; =============== S U B R O U T I N E =======================================
.text$mn:00001934
.text$mn:00001934 ; Attributes: bp-based frame
.text$mn:00001934
.text$mn:00001934 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001934                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001934 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001934                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001934                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001934
.text$mn:00001934 var_10          = dword ptr -10h
.text$mn:00001934 var_C           = dword ptr -0Ch
.text$mn:00001934 var_4           = dword ptr -4
.text$mn:00001934
.text$mn:00001934                 push    ebp
.text$mn:00001935                 mov     ebp, esp
.text$mn:00001937                 push    0FFFFFFFFh
.text$mn:00001939                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000193E                 mov     eax, large fs:0
.text$mn:00001944                 push    eax
.text$mn:00001945                 push    ecx
.text$mn:00001946                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000194B                 xor     eax, ebp
.text$mn:0000194D                 push    eax
.text$mn:0000194E                 lea     eax, [ebp+var_C]
.text$mn:00001951                 mov     large fs:0, eax
.text$mn:00001957                 mov     [ebp+var_10], ecx
.text$mn:0000195A                 mov     [ebp+var_4], 0
.text$mn:00001961                 mov     ecx, [ebp+var_10]
.text$mn:00001964                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001969                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001970                 mov     ecx, [ebp+var_10]
.text$mn:00001973                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001978                 mov     ecx, [ebp+var_C]
.text$mn:0000197B                 mov     large fs:0, ecx
.text$mn:00001982                 pop     ecx
.text$mn:00001983                 mov     esp, ebp
.text$mn:00001985                 pop     ebp
.text$mn:00001986                 retn
.text$mn:00001986 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001986
.text$mn:00001986 ; ---------------------------------------------------------------------------
.text$mn:00001987                 align 4
.text$mn:00001987 _text$mn        ends
.text$mn:00001987
.text$x:00001988 ; ===========================================================================
.text$x:00001988
.text$x:00001988 ; Segment type: Pure code
.text$x:00001988 ; Segment permissions: Read/Execute
.text$x:00001988 _text$x         segment para public 'CODE' use32
.text$x:00001988                 assume cs:_text$x
.text$x:00001988                 ;org 1988h
.text$x:00001988 ; COMDAT (pick associative to section at 1934)
.text$x:00001988                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001988
.text$x:00001988 ; =============== S U B R O U T I N E =======================================
.text$x:00001988
.text$x:00001988
.text$x:00001988 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001988                                         ; DATA XREF: .xdata$x:00003808o
.text$x:00001988                 mov     ecx, [ebp-10h]
.text$x:0000198B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000198B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000198B
.text$x:00001990
.text$x:00001990 ; =============== S U B R O U T I N E =======================================
.text$x:00001990
.text$x:00001990
.text$x:00001990 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001990                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001990
.text$x:00001990 arg_4           = dword ptr  8
.text$x:00001990
.text$x:00001990                 mov     edx, [esp+arg_4]
.text$x:00001994                 lea     eax, [edx+0Ch]
.text$x:00001997                 mov     ecx, [edx-8]
.text$x:0000199A                 xor     ecx, eax
.text$x:0000199C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019A1                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:000019A6                 jmp     ___CxxFrameHandler3
.text$x:000019A6 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:000019A6
.text$x:000019A6 ; ---------------------------------------------------------------------------
.text$x:000019AB                 align 4
.text$x:000019AB _text$x         ends
.text$x:000019AB
.text$mn:000019AC ; ===========================================================================
.text$mn:000019AC
.text$mn:000019AC ; Segment type: Pure code
.text$mn:000019AC ; Segment permissions: Read/Execute
.text$mn:000019AC _text$mn        segment para public 'CODE' use32
.text$mn:000019AC                 assume cs:_text$mn
.text$mn:000019AC                 ;org 19ACh
.text$mn:000019AC ; COMDAT (pick any)
.text$mn:000019AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000019AC
.text$mn:000019AC ; =============== S U B R O U T I N E =======================================
.text$mn:000019AC
.text$mn:000019AC ; Attributes: bp-based frame
.text$mn:000019AC
.text$mn:000019AC ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::~_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>(void)
.text$mn:000019AC                 public ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000019AC ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000019AC                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0+3j
.text$mn:000019AC                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+43p ...
.text$mn:000019AC
.text$mn:000019AC var_10          = dword ptr -10h
.text$mn:000019AC var_C           = dword ptr -0Ch
.text$mn:000019AC var_4           = dword ptr -4
.text$mn:000019AC
.text$mn:000019AC                 push    ebp
.text$mn:000019AD                 mov     ebp, esp
.text$mn:000019AF                 push    0FFFFFFFFh
.text$mn:000019B1                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$mn:000019B6                 mov     eax, large fs:0
.text$mn:000019BC                 push    eax
.text$mn:000019BD                 push    ecx
.text$mn:000019BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019C3                 xor     eax, ebp
.text$mn:000019C5                 push    eax
.text$mn:000019C6                 lea     eax, [ebp+var_C]
.text$mn:000019C9                 mov     large fs:0, eax
.text$mn:000019CF                 mov     [ebp+var_10], ecx
.text$mn:000019D2                 mov     [ebp+var_4], 0
.text$mn:000019D9                 mov     ecx, [ebp+var_10]
.text$mn:000019DC                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:000019E1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019E8                 mov     ecx, [ebp+var_10]
.text$mn:000019EB                 call    ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$mn:000019F0                 mov     ecx, [ebp+var_C]
.text$mn:000019F3                 mov     large fs:0, ecx
.text$mn:000019FA                 pop     ecx
.text$mn:000019FB                 mov     esp, ebp
.text$mn:000019FD                 pop     ebp
.text$mn:000019FE                 retn
.text$mn:000019FE ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$mn:000019FE
.text$mn:000019FE ; ---------------------------------------------------------------------------
.text$mn:000019FF                 align 10h
.text$mn:000019FF _text$mn        ends
.text$mn:000019FF
.text$x:00001A00 ; ===========================================================================
.text$x:00001A00
.text$x:00001A00 ; Segment type: Pure code
.text$x:00001A00 ; Segment permissions: Read/Execute
.text$x:00001A00 _text$x         segment para public 'CODE' use32
.text$x:00001A00                 assume cs:_text$x
.text$x:00001A00                 ;org 1A00h
.text$x:00001A00 ; COMDAT (pick associative to section at 19AC)
.text$x:00001A00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A00
.text$x:00001A00 ; =============== S U B R O U T I N E =======================================
.text$x:00001A00
.text$x:00001A00
.text$x:00001A00 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001A00                                         ; DATA XREF: .xdata$x:00003BACo
.text$x:00001A00                 mov     ecx, [ebp-10h]
.text$x:00001A03                 jmp     ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)
.text$x:00001A03 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001A03
.text$x:00001A08
.text$x:00001A08 ; =============== S U B R O U T I N E =======================================
.text$x:00001A08
.text$x:00001A08
.text$x:00001A08 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001A08                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+5o
.text$x:00001A08
.text$x:00001A08 arg_4           = dword ptr  8
.text$x:00001A08
.text$x:00001A08                 mov     edx, [esp+arg_4]
.text$x:00001A0C                 lea     eax, [edx+0Ch]
.text$x:00001A0F                 mov     ecx, [edx-8]
.text$x:00001A12                 xor     ecx, eax
.text$x:00001A14                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A19                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.text$x:00001A1E                 jmp     ___CxxFrameHandler3
.text$x:00001A1E __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ endp
.text$x:00001A1E
.text$x:00001A1E ; ---------------------------------------------------------------------------
.text$x:00001A23                 align 4
.text$x:00001A23 _text$x         ends
.text$x:00001A23
.text$mn:00001A24 ; ===========================================================================
.text$mn:00001A24
.text$mn:00001A24 ; Segment type: Pure code
.text$mn:00001A24 ; Segment permissions: Read/Execute
.text$mn:00001A24 _text$mn        segment para public 'CODE' use32
.text$mn:00001A24                 assume cs:_text$mn
.text$mn:00001A24                 ;org 1A24h
.text$mn:00001A24 ; COMDAT (pick any)
.text$mn:00001A24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A24
.text$mn:00001A24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A24
.text$mn:00001A24 ; Attributes: bp-based frame
.text$mn:00001A24
.text$mn:00001A24 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001A24                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001A24 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001A24                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001A24                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001A24
.text$mn:00001A24 var_10          = dword ptr -10h
.text$mn:00001A24 var_C           = dword ptr -0Ch
.text$mn:00001A24 var_4           = dword ptr -4
.text$mn:00001A24
.text$mn:00001A24                 push    ebp
.text$mn:00001A25                 mov     ebp, esp
.text$mn:00001A27                 push    0FFFFFFFFh
.text$mn:00001A29                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001A2E                 mov     eax, large fs:0
.text$mn:00001A34                 push    eax
.text$mn:00001A35                 push    ecx
.text$mn:00001A36                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A3B                 xor     eax, ebp
.text$mn:00001A3D                 push    eax
.text$mn:00001A3E                 lea     eax, [ebp+var_C]
.text$mn:00001A41                 mov     large fs:0, eax
.text$mn:00001A47                 mov     [ebp+var_10], ecx
.text$mn:00001A4A                 mov     [ebp+var_4], 0
.text$mn:00001A51                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A58                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001A5B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001A60                 mov     ecx, [ebp+var_C]
.text$mn:00001A63                 mov     large fs:0, ecx
.text$mn:00001A6A                 pop     ecx
.text$mn:00001A6B                 mov     esp, ebp
.text$mn:00001A6D                 pop     ebp
.text$mn:00001A6E                 retn
.text$mn:00001A6E ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001A6E
.text$mn:00001A6E ; ---------------------------------------------------------------------------
.text$mn:00001A6F                 align 10h
.text$mn:00001A6F _text$mn        ends
.text$mn:00001A6F
.text$x:00001A70 ; ===========================================================================
.text$x:00001A70
.text$x:00001A70 ; Segment type: Pure code
.text$x:00001A70 ; Segment permissions: Read/Execute
.text$x:00001A70 _text$x         segment para public 'CODE' use32
.text$x:00001A70                 assume cs:_text$x
.text$x:00001A70                 ;org 1A70h
.text$x:00001A70 ; COMDAT (pick associative to section at 1A24)
.text$x:00001A70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001A70
.text$x:00001A70 ; =============== S U B R O U T I N E =======================================
.text$x:00001A70
.text$x:00001A70
.text$x:00001A70 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001A70                                         ; DATA XREF: .xdata$x:000037B0o
.text$x:00001A70                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A73                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001A73 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001A73
.text$x:00001A78
.text$x:00001A78 ; =============== S U B R O U T I N E =======================================
.text$x:00001A78
.text$x:00001A78
.text$x:00001A78 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001A78                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001A78
.text$x:00001A78 arg_4           = dword ptr  8
.text$x:00001A78
.text$x:00001A78                 mov     edx, [esp+arg_4]
.text$x:00001A7C                 lea     eax, [edx+0Ch]
.text$x:00001A7F                 mov     ecx, [edx-8]
.text$x:00001A82                 xor     ecx, eax
.text$x:00001A84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A89                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001A8E                 jmp     ___CxxFrameHandler3
.text$x:00001A8E __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001A8E
.text$x:00001A8E ; ---------------------------------------------------------------------------
.text$x:00001A93                 align 4
.text$x:00001A93 _text$x         ends
.text$x:00001A93
.text$mn:00001A94 ; ===========================================================================
.text$mn:00001A94
.text$mn:00001A94 ; Segment type: Pure code
.text$mn:00001A94 ; Segment permissions: Read/Execute
.text$mn:00001A94 _text$mn        segment para public 'CODE' use32
.text$mn:00001A94                 assume cs:_text$mn
.text$mn:00001A94                 ;org 1A94h
.text$mn:00001A94 ; COMDAT (pick any)
.text$mn:00001A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001A94
.text$mn:00001A94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A94
.text$mn:00001A94 ; Attributes: bp-based frame
.text$mn:00001A94
.text$mn:00001A94 ; public: __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::~_String_val<struct std::_Simple_types<wchar_t>>(void)
.text$mn:00001A94                 public ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001A94 ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$mn:00001A94                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0+3j
.text$mn:00001A94                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+3Fp ...
.text$mn:00001A94
.text$mn:00001A94 var_10          = dword ptr -10h
.text$mn:00001A94 var_C           = dword ptr -0Ch
.text$mn:00001A94 var_4           = dword ptr -4
.text$mn:00001A94
.text$mn:00001A94                 push    ebp
.text$mn:00001A95                 mov     ebp, esp
.text$mn:00001A97                 push    0FFFFFFFFh
.text$mn:00001A99                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$mn:00001A9E                 mov     eax, large fs:0
.text$mn:00001AA4                 push    eax
.text$mn:00001AA5                 push    ecx
.text$mn:00001AA6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001AAB                 xor     eax, ebp
.text$mn:00001AAD                 push    eax
.text$mn:00001AAE                 lea     eax, [ebp+var_C]
.text$mn:00001AB1                 mov     large fs:0, eax
.text$mn:00001AB7                 mov     [ebp+var_10], ecx
.text$mn:00001ABA                 mov     [ebp+var_4], 0
.text$mn:00001AC1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AC8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001ACB                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001AD0                 mov     ecx, [ebp+var_C]
.text$mn:00001AD3                 mov     large fs:0, ecx
.text$mn:00001ADA                 pop     ecx
.text$mn:00001ADB                 mov     esp, ebp
.text$mn:00001ADD                 pop     ebp
.text$mn:00001ADE                 retn
.text$mn:00001ADE ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$mn:00001ADE
.text$mn:00001ADE ; ---------------------------------------------------------------------------
.text$mn:00001ADF                 align 10h
.text$mn:00001ADF _text$mn        ends
.text$mn:00001ADF
.text$x:00001AE0 ; ===========================================================================
.text$x:00001AE0
.text$x:00001AE0 ; Segment type: Pure code
.text$x:00001AE0 ; Segment permissions: Read/Execute
.text$x:00001AE0 _text$x         segment para public 'CODE' use32
.text$x:00001AE0                 assume cs:_text$x
.text$x:00001AE0                 ;org 1AE0h
.text$x:00001AE0 ; COMDAT (pick associative to section at 1A94)
.text$x:00001AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001AE0
.text$x:00001AE0 ; =============== S U B R O U T I N E =======================================
.text$x:00001AE0
.text$x:00001AE0
.text$x:00001AE0 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 proc near
.text$x:00001AE0                                         ; DATA XREF: .xdata$x:00003B54o
.text$x:00001AE0                 mov     ecx, [ebp-10h]  ; this
.text$x:00001AE3                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001AE3 __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0 endp
.text$x:00001AE3
.text$x:00001AE8
.text$x:00001AE8 ; =============== S U B R O U T I N E =======================================
.text$x:00001AE8
.text$x:00001AE8
.text$x:00001AE8 __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ proc near
.text$x:00001AE8                                         ; DATA XREF: std::_String_val<std::_Simple_types<wchar_t>>::~_String_val<std::_Simple_types<wchar_t>>(void)+5o
.text$x:00001AE8
.text$x:00001AE8 arg_4           = dword ptr  8
.text$x:00001AE8
.text$x:00001AE8                 mov     edx, [esp+arg_4]
.text$x:00001AEC                 lea     eax, [edx+0Ch]
.text$x:00001AEF                 mov     ecx, [edx-8]
.text$x:00001AF2                 xor     ecx, eax
.text$x:00001AF4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AF9                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.text$x:00001AFE                 jmp     ___CxxFrameHandler3
.text$x:00001AFE __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ endp
.text$x:00001AFE
.text$x:00001AFE ; ---------------------------------------------------------------------------
.text$x:00001B03                 align 4
.text$x:00001B03 _text$x         ends
.text$x:00001B03
.text$mn:00001B04 ; ===========================================================================
.text$mn:00001B04
.text$mn:00001B04 ; Segment type: Pure code
.text$mn:00001B04 ; Segment permissions: Read/Execute
.text$mn:00001B04 _text$mn        segment para public 'CODE' use32
.text$mn:00001B04                 assume cs:_text$mn
.text$mn:00001B04                 ;org 1B04h
.text$mn:00001B04 ; COMDAT (pick any)
.text$mn:00001B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B04
.text$mn:00001B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B04
.text$mn:00001B04 ; Attributes: bp-based frame
.text$mn:00001B04
.text$mn:00001B04 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001B04                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001B04 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001B04                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001B04                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001B04
.text$mn:00001B04 var_10          = dword ptr -10h
.text$mn:00001B04 var_C           = dword ptr -0Ch
.text$mn:00001B04 var_4           = dword ptr -4
.text$mn:00001B04
.text$mn:00001B04                 push    ebp
.text$mn:00001B05                 mov     ebp, esp
.text$mn:00001B07                 push    0FFFFFFFFh
.text$mn:00001B09                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001B0E                 mov     eax, large fs:0
.text$mn:00001B14                 push    eax
.text$mn:00001B15                 push    ecx
.text$mn:00001B16                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B1B                 xor     eax, ebp
.text$mn:00001B1D                 push    eax
.text$mn:00001B1E                 lea     eax, [ebp+var_C]
.text$mn:00001B21                 mov     large fs:0, eax
.text$mn:00001B27                 mov     [ebp+var_10], ecx
.text$mn:00001B2A                 mov     [ebp+var_4], 0
.text$mn:00001B31                 push    0               ; Size
.text$mn:00001B33                 push    1               ; char
.text$mn:00001B35                 mov     ecx, [ebp+var_10]
.text$mn:00001B38                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001B3D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B44                 mov     ecx, [ebp+var_10]
.text$mn:00001B47                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001B4C                 mov     ecx, [ebp+var_C]
.text$mn:00001B4F                 mov     large fs:0, ecx
.text$mn:00001B56                 pop     ecx
.text$mn:00001B57                 mov     esp, ebp
.text$mn:00001B59                 pop     ebp
.text$mn:00001B5A                 retn
.text$mn:00001B5A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001B5A
.text$mn:00001B5A ; ---------------------------------------------------------------------------
.text$mn:00001B5B                 align 4
.text$mn:00001B5B _text$mn        ends
.text$mn:00001B5B
.text$x:00001B5C ; ===========================================================================
.text$x:00001B5C
.text$x:00001B5C ; Segment type: Pure code
.text$x:00001B5C ; Segment permissions: Read/Execute
.text$x:00001B5C _text$x         segment para public 'CODE' use32
.text$x:00001B5C                 assume cs:_text$x
.text$x:00001B5C                 ;org 1B5Ch
.text$x:00001B5C ; COMDAT (pick associative to section at 1B04)
.text$x:00001B5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001B5C
.text$x:00001B5C ; =============== S U B R O U T I N E =======================================
.text$x:00001B5C
.text$x:00001B5C
.text$x:00001B5C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001B5C                                         ; DATA XREF: .xdata$x:00003860o
.text$x:00001B5C                 mov     ecx, [ebp-10h]
.text$x:00001B5F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001B5F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001B5F
.text$x:00001B64
.text$x:00001B64 ; =============== S U B R O U T I N E =======================================
.text$x:00001B64
.text$x:00001B64
.text$x:00001B64 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001B64                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001B64
.text$x:00001B64 arg_4           = dword ptr  8
.text$x:00001B64
.text$x:00001B64                 mov     edx, [esp+arg_4]
.text$x:00001B68                 lea     eax, [edx+0Ch]
.text$x:00001B6B                 mov     ecx, [edx-8]
.text$x:00001B6E                 xor     ecx, eax
.text$x:00001B70                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B75                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001B7A                 jmp     ___CxxFrameHandler3
.text$x:00001B7A __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001B7A
.text$x:00001B7A ; ---------------------------------------------------------------------------
.text$x:00001B7F                 align 10h
.text$x:00001B7F _text$x         ends
.text$x:00001B7F
.text$mn:00001B80 ; ===========================================================================
.text$mn:00001B80
.text$mn:00001B80 ; Segment type: Pure code
.text$mn:00001B80 ; Segment permissions: Read/Execute
.text$mn:00001B80 _text$mn        segment para public 'CODE' use32
.text$mn:00001B80                 assume cs:_text$mn
.text$mn:00001B80                 ;org 1B80h
.text$mn:00001B80 ; COMDAT (pick any)
.text$mn:00001B80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001B80
.text$mn:00001B80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B80
.text$mn:00001B80 ; Attributes: bp-based frame
.text$mn:00001B80
.text$mn:00001B80 ; public: __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::~basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>(void)
.text$mn:00001B80                 public ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001B80 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$mn:00001B80                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+242p
.text$mn:00001B80                                         ; ListView::init(HINSTANCE__ *,HWND__ *)+24Ep ...
.text$mn:00001B80
.text$mn:00001B80 var_10          = dword ptr -10h
.text$mn:00001B80 var_C           = dword ptr -0Ch
.text$mn:00001B80 var_4           = dword ptr -4
.text$mn:00001B80
.text$mn:00001B80                 push    ebp
.text$mn:00001B81                 mov     ebp, esp
.text$mn:00001B83                 push    0FFFFFFFFh
.text$mn:00001B85                 push    offset __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$mn:00001B8A                 mov     eax, large fs:0
.text$mn:00001B90                 push    eax
.text$mn:00001B91                 push    ecx
.text$mn:00001B92                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B97                 xor     eax, ebp
.text$mn:00001B99                 push    eax
.text$mn:00001B9A                 lea     eax, [ebp+var_C]
.text$mn:00001B9D                 mov     large fs:0, eax
.text$mn:00001BA3                 mov     [ebp+var_10], ecx
.text$mn:00001BA6                 mov     [ebp+var_4], 0
.text$mn:00001BAD                 push    0
.text$mn:00001BAF                 push    1
.text$mn:00001BB1                 mov     ecx, [ebp+var_10]
.text$mn:00001BB4                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00001BB9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BC0                 mov     ecx, [ebp+var_10]
.text$mn:00001BC3                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$mn:00001BC8                 mov     ecx, [ebp+var_C]
.text$mn:00001BCB                 mov     large fs:0, ecx
.text$mn:00001BD2                 pop     ecx
.text$mn:00001BD3                 mov     esp, ebp
.text$mn:00001BD5                 pop     ebp
.text$mn:00001BD6                 retn
.text$mn:00001BD6 ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$mn:00001BD6
.text$mn:00001BD6 ; ---------------------------------------------------------------------------
.text$mn:00001BD7                 align 4
.text$mn:00001BD7 _text$mn        ends
.text$mn:00001BD7
.text$x:00001BD8 ; ===========================================================================
.text$x:00001BD8
.text$x:00001BD8 ; Segment type: Pure code
.text$x:00001BD8 ; Segment permissions: Read/Execute
.text$x:00001BD8 _text$x         segment para public 'CODE' use32
.text$x:00001BD8                 assume cs:_text$x
.text$x:00001BD8                 ;org 1BD8h
.text$x:00001BD8 ; COMDAT (pick associative to section at 1B80)
.text$x:00001BD8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001BD8
.text$x:00001BD8 ; =============== S U B R O U T I N E =======================================
.text$x:00001BD8
.text$x:00001BD8
.text$x:00001BD8 __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 proc near
.text$x:00001BD8                                         ; DATA XREF: .xdata$x:00003C04o
.text$x:00001BD8                 mov     ecx, [ebp-10h]
.text$x:00001BDB                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)
.text$x:00001BDB __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0 endp
.text$x:00001BDB
.text$x:00001BE0
.text$x:00001BE0 ; =============== S U B R O U T I N E =======================================
.text$x:00001BE0
.text$x:00001BE0
.text$x:00001BE0 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ proc near
.text$x:00001BE0                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+5o
.text$x:00001BE0
.text$x:00001BE0 arg_4           = dword ptr  8
.text$x:00001BE0
.text$x:00001BE0                 mov     edx, [esp+arg_4]
.text$x:00001BE4                 lea     eax, [edx+0Ch]
.text$x:00001BE7                 mov     ecx, [edx-8]
.text$x:00001BEA                 xor     ecx, eax
.text$x:00001BEC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BF1                 mov     eax, offset __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.text$x:00001BF6                 jmp     ___CxxFrameHandler3
.text$x:00001BF6 __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ endp
.text$x:00001BF6
.text$x:00001BF6 ; ---------------------------------------------------------------------------
.text$x:00001BFB                 align 4
.text$x:00001BFB _text$x         ends
.text$x:00001BFB
.text$mn:00001BFC ; ===========================================================================
.text$mn:00001BFC
.text$mn:00001BFC ; Segment type: Pure code
.text$mn:00001BFC ; Segment permissions: Read/Execute
.text$mn:00001BFC _text$mn        segment para public 'CODE' use32
.text$mn:00001BFC                 assume cs:_text$mn
.text$mn:00001BFC                 ;org 1BFCh
.text$mn:00001BFC ; COMDAT (pick any)
.text$mn:00001BFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001BFC
.text$mn:00001BFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001BFC
.text$mn:00001BFC ; Attributes: bp-based frame
.text$mn:00001BFC
.text$mn:00001BFC ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001BFC                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001BFC ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001BFC                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001BFC                                         ; __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0+3j ...
.text$mn:00001BFC
.text$mn:00001BFC var_4           = dword ptr -4
.text$mn:00001BFC
.text$mn:00001BFC                 push    ebp
.text$mn:00001BFD                 mov     ebp, esp
.text$mn:00001BFF                 push    ecx
.text$mn:00001C00                 mov     [ebp+var_4], ecx
.text$mn:00001C03                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001C06                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001C0B                 mov     esp, ebp
.text$mn:00001C0D                 pop     ebp
.text$mn:00001C0E                 retn
.text$mn:00001C0E ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001C0E
.text$mn:00001C0E ; ---------------------------------------------------------------------------
.text$mn:00001C0F                 align 10h
.text$mn:00001C0F _text$mn        ends
.text$mn:00001C0F
.text$mn:00001C10 ; ===========================================================================
.text$mn:00001C10
.text$mn:00001C10 ; Segment type: Pure code
.text$mn:00001C10 ; Segment permissions: Read/Execute
.text$mn:00001C10 _text$mn        segment para public 'CODE' use32
.text$mn:00001C10                 assume cs:_text$mn
.text$mn:00001C10                 ;org 1C10h
.text$mn:00001C10 ; COMDAT (pick any)
.text$mn:00001C10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C10
.text$mn:00001C10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C10
.text$mn:00001C10 ; Attributes: bp-based frame
.text$mn:00001C10
.text$mn:00001C10 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001C10                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001C10 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001C10                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001C10                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001C10
.text$mn:00001C10 var_10          = dword ptr -10h
.text$mn:00001C10 var_C           = dword ptr -0Ch
.text$mn:00001C10 var_4           = dword ptr -4
.text$mn:00001C10
.text$mn:00001C10                 push    ebp
.text$mn:00001C11                 mov     ebp, esp
.text$mn:00001C13                 push    0FFFFFFFFh
.text$mn:00001C15                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001C1A                 mov     eax, large fs:0
.text$mn:00001C20                 push    eax
.text$mn:00001C21                 push    ecx
.text$mn:00001C22                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C27                 xor     eax, ebp
.text$mn:00001C29                 push    eax
.text$mn:00001C2A                 lea     eax, [ebp+var_C]
.text$mn:00001C2D                 mov     large fs:0, eax
.text$mn:00001C33                 mov     [ebp+var_10], ecx
.text$mn:00001C36                 mov     [ebp+var_4], 0
.text$mn:00001C3D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001C44                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001C47                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001C4C                 mov     ecx, [ebp+var_C]
.text$mn:00001C4F                 mov     large fs:0, ecx
.text$mn:00001C56                 pop     ecx
.text$mn:00001C57                 mov     esp, ebp
.text$mn:00001C59                 pop     ebp
.text$mn:00001C5A                 retn
.text$mn:00001C5A ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00001C5A
.text$mn:00001C5A ; ---------------------------------------------------------------------------
.text$mn:00001C5B                 align 4
.text$mn:00001C5B _text$mn        ends
.text$mn:00001C5B
.text$x:00001C5C ; ===========================================================================
.text$x:00001C5C
.text$x:00001C5C ; Segment type: Pure code
.text$x:00001C5C ; Segment permissions: Read/Execute
.text$x:00001C5C _text$x         segment para public 'CODE' use32
.text$x:00001C5C                 assume cs:_text$x
.text$x:00001C5C                 ;org 1C5Ch
.text$x:00001C5C ; COMDAT (pick associative to section at 1C10)
.text$x:00001C5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001C5C
.text$x:00001C5C ; =============== S U B R O U T I N E =======================================
.text$x:00001C5C
.text$x:00001C5C
.text$x:00001C5C __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001C5C                                         ; DATA XREF: .xdata$x:000039F4o
.text$x:00001C5C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001C5F                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001C5F __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00001C5F
.text$x:00001C64
.text$x:00001C64 ; =============== S U B R O U T I N E =======================================
.text$x:00001C64
.text$x:00001C64
.text$x:00001C64 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001C64                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001C64
.text$x:00001C64 arg_4           = dword ptr  8
.text$x:00001C64
.text$x:00001C64                 mov     edx, [esp+arg_4]
.text$x:00001C68                 lea     eax, [edx+0Ch]
.text$x:00001C6B                 mov     ecx, [edx-8]
.text$x:00001C6E                 xor     ecx, eax
.text$x:00001C70                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C75                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00001C7A                 jmp     ___CxxFrameHandler3
.text$x:00001C7A __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00001C7A
.text$x:00001C7A ; ---------------------------------------------------------------------------
.text$x:00001C7F                 align 10h
.text$x:00001C7F _text$x         ends
.text$x:00001C7F
.text$mn:00001C80 ; ===========================================================================
.text$mn:00001C80
.text$mn:00001C80 ; Segment type: Pure code
.text$mn:00001C80 ; Segment permissions: Read/Execute
.text$mn:00001C80 _text$mn        segment para public 'CODE' use32
.text$mn:00001C80                 assume cs:_text$mn
.text$mn:00001C80                 ;org 1C80h
.text$mn:00001C80 ; COMDAT (pick any)
.text$mn:00001C80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001C80
.text$mn:00001C80 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C80
.text$mn:00001C80 ; Attributes: bp-based frame
.text$mn:00001C80
.text$mn:00001C80 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001C80                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001C80 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001C80                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001C80                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001C80
.text$mn:00001C80 var_10          = dword ptr -10h
.text$mn:00001C80 var_C           = dword ptr -0Ch
.text$mn:00001C80 var_4           = dword ptr -4
.text$mn:00001C80
.text$mn:00001C80                 push    ebp
.text$mn:00001C81                 mov     ebp, esp
.text$mn:00001C83                 push    0FFFFFFFFh
.text$mn:00001C85                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001C8A                 mov     eax, large fs:0
.text$mn:00001C90                 push    eax
.text$mn:00001C91                 push    ecx
.text$mn:00001C92                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C97                 xor     eax, ebp
.text$mn:00001C99                 push    eax
.text$mn:00001C9A                 lea     eax, [ebp+var_C]
.text$mn:00001C9D                 mov     large fs:0, eax
.text$mn:00001CA3                 mov     [ebp+var_10], ecx
.text$mn:00001CA6                 mov     [ebp+var_4], 0
.text$mn:00001CAD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001CB4                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001CB7                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001CBC                 mov     ecx, [ebp+var_C]
.text$mn:00001CBF                 mov     large fs:0, ecx
.text$mn:00001CC6                 pop     ecx
.text$mn:00001CC7                 mov     esp, ebp
.text$mn:00001CC9                 pop     ebp
.text$mn:00001CCA                 retn
.text$mn:00001CCA ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001CCA
.text$mn:00001CCA ; ---------------------------------------------------------------------------
.text$mn:00001CCB                 align 4
.text$mn:00001CCB _text$mn        ends
.text$mn:00001CCB
.text$x:00001CCC ; ===========================================================================
.text$x:00001CCC
.text$x:00001CCC ; Segment type: Pure code
.text$x:00001CCC ; Segment permissions: Read/Execute
.text$x:00001CCC _text$x         segment para public 'CODE' use32
.text$x:00001CCC                 assume cs:_text$x
.text$x:00001CCC                 ;org 1CCCh
.text$x:00001CCC ; COMDAT (pick associative to section at 1C80)
.text$x:00001CCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001CCC
.text$x:00001CCC ; =============== S U B R O U T I N E =======================================
.text$x:00001CCC
.text$x:00001CCC
.text$x:00001CCC __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001CCC                                         ; DATA XREF: .xdata$x:00003A78o
.text$x:00001CCC                 mov     ecx, [ebp-10h]  ; this
.text$x:00001CCF                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001CCF __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001CCF
.text$x:00001CD4
.text$x:00001CD4 ; =============== S U B R O U T I N E =======================================
.text$x:00001CD4
.text$x:00001CD4
.text$x:00001CD4 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001CD4                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001CD4
.text$x:00001CD4 arg_4           = dword ptr  8
.text$x:00001CD4
.text$x:00001CD4                 mov     edx, [esp+arg_4]
.text$x:00001CD8                 lea     eax, [edx+0Ch]
.text$x:00001CDB                 mov     ecx, [edx-8]
.text$x:00001CDE                 xor     ecx, eax
.text$x:00001CE0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CE5                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001CEA                 jmp     ___CxxFrameHandler3
.text$x:00001CEA __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001CEA
.text$x:00001CEA ; ---------------------------------------------------------------------------
.text$x:00001CEF                 align 10h
.text$x:00001CEF _text$x         ends
.text$x:00001CEF
.text$mn:00001CF0 ; ===========================================================================
.text$mn:00001CF0
.text$mn:00001CF0 ; Segment type: Pure code
.text$mn:00001CF0 ; Segment permissions: Read/Execute
.text$mn:00001CF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001CF0                 assume cs:_text$mn
.text$mn:00001CF0                 ;org 1CF0h
.text$mn:00001CF0 ; COMDAT (pick any)
.text$mn:00001CF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001CF0
.text$mn:00001CF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CF0
.text$mn:00001CF0 ; Attributes: bp-based frame
.text$mn:00001CF0
.text$mn:00001CF0 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001CF0                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001CF0 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001CF0                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001CF0                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001CF0
.text$mn:00001CF0 var_10          = dword ptr -10h
.text$mn:00001CF0 var_C           = dword ptr -0Ch
.text$mn:00001CF0 var_4           = dword ptr -4
.text$mn:00001CF0
.text$mn:00001CF0                 push    ebp
.text$mn:00001CF1                 mov     ebp, esp
.text$mn:00001CF3                 push    0FFFFFFFFh
.text$mn:00001CF5                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001CFA                 mov     eax, large fs:0
.text$mn:00001D00                 push    eax
.text$mn:00001D01                 push    ecx
.text$mn:00001D02                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D07                 xor     eax, ebp
.text$mn:00001D09                 push    eax
.text$mn:00001D0A                 lea     eax, [ebp+var_C]
.text$mn:00001D0D                 mov     large fs:0, eax
.text$mn:00001D13                 mov     [ebp+var_10], ecx
.text$mn:00001D16                 mov     [ebp+var_4], 0
.text$mn:00001D1D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D24                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001D27                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001D2C                 mov     ecx, [ebp+var_C]
.text$mn:00001D2F                 mov     large fs:0, ecx
.text$mn:00001D36                 pop     ecx
.text$mn:00001D37                 mov     esp, ebp
.text$mn:00001D39                 pop     ebp
.text$mn:00001D3A                 retn
.text$mn:00001D3A ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001D3A
.text$mn:00001D3A ; ---------------------------------------------------------------------------
.text$mn:00001D3B                 align 4
.text$mn:00001D3B _text$mn        ends
.text$mn:00001D3B
.text$x:00001D3C ; ===========================================================================
.text$x:00001D3C
.text$x:00001D3C ; Segment type: Pure code
.text$x:00001D3C ; Segment permissions: Read/Execute
.text$x:00001D3C _text$x         segment para public 'CODE' use32
.text$x:00001D3C                 assume cs:_text$x
.text$x:00001D3C                 ;org 1D3Ch
.text$x:00001D3C ; COMDAT (pick associative to section at 1CF0)
.text$x:00001D3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001D3C
.text$x:00001D3C ; =============== S U B R O U T I N E =======================================
.text$x:00001D3C
.text$x:00001D3C
.text$x:00001D3C __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001D3C                                         ; DATA XREF: .xdata$x:00003AFCo
.text$x:00001D3C                 mov     ecx, [ebp-10h]  ; this
.text$x:00001D3F                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001D3F __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001D3F
.text$x:00001D44
.text$x:00001D44 ; =============== S U B R O U T I N E =======================================
.text$x:00001D44
.text$x:00001D44
.text$x:00001D44 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001D44                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001D44
.text$x:00001D44 arg_4           = dword ptr  8
.text$x:00001D44
.text$x:00001D44                 mov     edx, [esp+arg_4]
.text$x:00001D48                 lea     eax, [edx+0Ch]
.text$x:00001D4B                 mov     ecx, [edx-8]
.text$x:00001D4E                 xor     ecx, eax
.text$x:00001D50                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D55                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001D5A                 jmp     ___CxxFrameHandler3
.text$x:00001D5A __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001D5A
.text$x:00001D5A ; ---------------------------------------------------------------------------
.text$x:00001D5F                 align 10h
.text$x:00001D5F _text$x         ends
.text$x:00001D5F
.text$mn:00001D60 ; ===========================================================================
.text$mn:00001D60
.text$mn:00001D60 ; Segment type: Pure code
.text$mn:00001D60 ; Segment permissions: Read/Execute
.text$mn:00001D60 _text$mn        segment para public 'CODE' use32
.text$mn:00001D60                 assume cs:_text$mn
.text$mn:00001D60                 ;org 1D60h
.text$mn:00001D60 ; COMDAT (pick any)
.text$mn:00001D60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D60
.text$mn:00001D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D60
.text$mn:00001D60 ; Attributes: bp-based frame
.text$mn:00001D60
.text$mn:00001D60 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001D60                 public ??1error_category@std@@UAE@XZ
.text$mn:00001D60 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001D60                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001D60
.text$mn:00001D60 var_4           = dword ptr -4
.text$mn:00001D60
.text$mn:00001D60                 push    ebp
.text$mn:00001D61                 mov     ebp, esp
.text$mn:00001D63                 push    ecx
.text$mn:00001D64                 mov     [ebp+var_4], ecx
.text$mn:00001D67                 mov     eax, [ebp+var_4]
.text$mn:00001D6A                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001D70                 mov     esp, ebp
.text$mn:00001D72                 pop     ebp
.text$mn:00001D73                 retn
.text$mn:00001D73 ??1error_category@std@@UAE@XZ endp
.text$mn:00001D73
.text$mn:00001D73 _text$mn        ends
.text$mn:00001D73
.text$mn:00001D74 ; ===========================================================================
.text$mn:00001D74
.text$mn:00001D74 ; Segment type: Pure code
.text$mn:00001D74 ; Segment permissions: Read/Execute
.text$mn:00001D74 _text$mn        segment para public 'CODE' use32
.text$mn:00001D74                 assume cs:_text$mn
.text$mn:00001D74                 ;org 1D74h
.text$mn:00001D74 ; COMDAT (pick any)
.text$mn:00001D74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001D74
.text$mn:00001D74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D74
.text$mn:00001D74 ; Attributes: bp-based frame
.text$mn:00001D74
.text$mn:00001D74 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:00001D74                 public ??1runtime_error@std@@UAE@XZ
.text$mn:00001D74 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:00001D74                                         ; DATA XREF: .xdata$x:00003DE4o
.text$mn:00001D74
.text$mn:00001D74 var_10          = dword ptr -10h
.text$mn:00001D74 var_C           = dword ptr -0Ch
.text$mn:00001D74 var_4           = dword ptr -4
.text$mn:00001D74
.text$mn:00001D74                 push    ebp
.text$mn:00001D75                 mov     ebp, esp
.text$mn:00001D77                 push    0FFFFFFFFh
.text$mn:00001D79                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:00001D7E                 mov     eax, large fs:0
.text$mn:00001D84                 push    eax
.text$mn:00001D85                 push    ecx
.text$mn:00001D86                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001D8B                 xor     eax, ebp
.text$mn:00001D8D                 push    eax
.text$mn:00001D8E                 lea     eax, [ebp+var_C]
.text$mn:00001D91                 mov     large fs:0, eax
.text$mn:00001D97                 mov     [ebp+var_10], ecx
.text$mn:00001D9A                 mov     [ebp+var_4], 0
.text$mn:00001DA1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001DA8                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001DAB                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:00001DB0                 mov     ecx, [ebp+var_C]
.text$mn:00001DB3                 mov     large fs:0, ecx
.text$mn:00001DBA                 pop     ecx
.text$mn:00001DBB                 mov     esp, ebp
.text$mn:00001DBD                 pop     ebp
.text$mn:00001DBE                 retn
.text$mn:00001DBE ??1runtime_error@std@@UAE@XZ endp
.text$mn:00001DBE
.text$mn:00001DBE ; ---------------------------------------------------------------------------
.text$mn:00001DBF                 align 10h
.text$mn:00001DBF _text$mn        ends
.text$mn:00001DBF
.text$x:00001DC0 ; ===========================================================================
.text$x:00001DC0
.text$x:00001DC0 ; Segment type: Pure code
.text$x:00001DC0 ; Segment permissions: Read/Execute
.text$x:00001DC0 _text$x         segment para public 'CODE' use32
.text$x:00001DC0                 assume cs:_text$x
.text$x:00001DC0                 ;org 1DC0h
.text$x:00001DC0 ; COMDAT (pick associative to section at 1D74)
.text$x:00001DC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001DC0
.text$x:00001DC0 ; =============== S U B R O U T I N E =======================================
.text$x:00001DC0
.text$x:00001DC0
.text$x:00001DC0 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:00001DC0                                         ; DATA XREF: .xdata$x:00003944o
.text$x:00001DC0                 mov     ecx, [ebp-10h]  ; this
.text$x:00001DC3                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00001DC3 __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:00001DC3
.text$x:00001DC8
.text$x:00001DC8 ; =============== S U B R O U T I N E =======================================
.text$x:00001DC8
.text$x:00001DC8
.text$x:00001DC8 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:00001DC8                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:00001DC8
.text$x:00001DC8 arg_4           = dword ptr  8
.text$x:00001DC8
.text$x:00001DC8                 mov     edx, [esp+arg_4]
.text$x:00001DCC                 lea     eax, [edx+0Ch]
.text$x:00001DCF                 mov     ecx, [edx-8]
.text$x:00001DD2                 xor     ecx, eax
.text$x:00001DD4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001DD9                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:00001DDE                 jmp     ___CxxFrameHandler3
.text$x:00001DDE __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:00001DDE
.text$x:00001DDE ; ---------------------------------------------------------------------------
.text$x:00001DE3                 align 4
.text$x:00001DE3 _text$x         ends
.text$x:00001DE3
.text$mn:00001DE4 ; ===========================================================================
.text$mn:00001DE4
.text$mn:00001DE4 ; Segment type: Pure code
.text$mn:00001DE4 ; Segment permissions: Read/Execute
.text$mn:00001DE4 _text$mn        segment para public 'CODE' use32
.text$mn:00001DE4                 assume cs:_text$mn
.text$mn:00001DE4                 ;org 1DE4h
.text$mn:00001DE4 ; COMDAT (pick any)
.text$mn:00001DE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DE4
.text$mn:00001DE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DE4
.text$mn:00001DE4 ; Attributes: bp-based frame
.text$mn:00001DE4
.text$mn:00001DE4 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001DE4                 public ??2@YAPAXIPAX@Z
.text$mn:00001DE4 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001DE4                                         ; std::allocator<wchar_t>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)+2Ep ...
.text$mn:00001DE4
.text$mn:00001DE4 arg_4           = dword ptr  0Ch
.text$mn:00001DE4
.text$mn:00001DE4                 push    ebp
.text$mn:00001DE5                 mov     ebp, esp
.text$mn:00001DE7                 mov     eax, [ebp+arg_4]
.text$mn:00001DEA                 pop     ebp
.text$mn:00001DEB                 retn
.text$mn:00001DEB ??2@YAPAXIPAX@Z endp
.text$mn:00001DEB
.text$mn:00001DEB _text$mn        ends
.text$mn:00001DEB
.text$mn:00001DEC ; ===========================================================================
.text$mn:00001DEC
.text$mn:00001DEC ; Segment type: Pure code
.text$mn:00001DEC ; Segment permissions: Read/Execute
.text$mn:00001DEC _text$mn        segment para public 'CODE' use32
.text$mn:00001DEC                 assume cs:_text$mn
.text$mn:00001DEC                 ;org 1DECh
.text$mn:00001DEC ; COMDAT (pick any)
.text$mn:00001DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DEC
.text$mn:00001DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00001DEC
.text$mn:00001DEC ; Attributes: bp-based frame
.text$mn:00001DEC
.text$mn:00001DEC ; void __cdecl operator delete(void *)
.text$mn:00001DEC                 public ??3@YAXPAX0@Z
.text$mn:00001DEC ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001DEC                                         ; __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0+8p ...
.text$mn:00001DEC                 push    ebp
.text$mn:00001DED                 mov     ebp, esp
.text$mn:00001DEF                 pop     ebp
.text$mn:00001DF0                 retn
.text$mn:00001DF0 ??3@YAXPAX0@Z   endp
.text$mn:00001DF0
.text$mn:00001DF0 ; ---------------------------------------------------------------------------
.text$mn:00001DF1                 align 4
.text$mn:00001DF1 _text$mn        ends
.text$mn:00001DF1
.text$mn:00001DF4 ; ===========================================================================
.text$mn:00001DF4
.text$mn:00001DF4 ; Segment type: Pure code
.text$mn:00001DF4 ; Segment permissions: Read/Execute
.text$mn:00001DF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF4                 assume cs:_text$mn
.text$mn:00001DF4                 ;org 1DF4h
.text$mn:00001DF4 ; COMDAT (pick any)
.text$mn:00001DF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001DF4
.text$mn:00001DF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF4
.text$mn:00001DF4 ; Attributes: bp-based frame
.text$mn:00001DF4
.text$mn:00001DF4 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001DF4                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001DF4 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001DF4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001DF4                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001DF4
.text$mn:00001DF4 var_8           = dword ptr -8
.text$mn:00001DF4 var_4           = dword ptr -4
.text$mn:00001DF4 arg_0           = dword ptr  8
.text$mn:00001DF4
.text$mn:00001DF4                 push    ebp
.text$mn:00001DF5                 mov     ebp, esp
.text$mn:00001DF7                 sub     esp, 8
.text$mn:00001DFA                 mov     [ebp+var_8], ecx
.text$mn:00001DFD                 mov     eax, [ebp+var_8]
.text$mn:00001E00                 cmp     eax, [ebp+arg_0]
.text$mn:00001E03                 jnz     short loc_1E0E
.text$mn:00001E05                 mov     [ebp+var_4], 1
.text$mn:00001E0C                 jmp     short loc_1E15
.text$mn:00001E0E ; ---------------------------------------------------------------------------
.text$mn:00001E0E
.text$mn:00001E0E loc_1E0E:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001E0E                 mov     [ebp+var_4], 0
.text$mn:00001E15
.text$mn:00001E15 loc_1E15:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001E15                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001E18                 mov     esp, ebp
.text$mn:00001E1A                 pop     ebp
.text$mn:00001E1B                 retn    4
.text$mn:00001E1B ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001E1B
.text$mn:00001E1B ; ---------------------------------------------------------------------------
.text$mn:00001E1E                 align 10h
.text$mn:00001E1E _text$mn        ends
.text$mn:00001E1E
.text$mn:00001E20 ; ===========================================================================
.text$mn:00001E20
.text$mn:00001E20 ; Segment type: Pure code
.text$mn:00001E20 ; Segment permissions: Read/Execute
.text$mn:00001E20 _text$mn        segment para public 'CODE' use32
.text$mn:00001E20                 assume cs:_text$mn
.text$mn:00001E20                 ;org 1E20h
.text$mn:00001E20 ; COMDAT (pick any)
.text$mn:00001E20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E20
.text$mn:00001E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E20
.text$mn:00001E20 ; Attributes: bp-based frame
.text$mn:00001E20
.text$mn:00001E20 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001E20                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001E20 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001E20                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001E20
.text$mn:00001E20 var_8           = dword ptr -8
.text$mn:00001E20 var_4           = dword ptr -4
.text$mn:00001E20 arg_0           = dword ptr  8
.text$mn:00001E20
.text$mn:00001E20                 push    ebp
.text$mn:00001E21                 mov     ebp, esp
.text$mn:00001E23                 sub     esp, 8
.text$mn:00001E26                 push    esi
.text$mn:00001E27                 mov     [ebp+var_4], ecx
.text$mn:00001E2A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001E2D                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001E32                 push    eax
.text$mn:00001E33                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E36                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001E3B                 mov     ecx, eax
.text$mn:00001E3D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001E42                 movzx   eax, al
.text$mn:00001E45                 test    eax, eax
.text$mn:00001E47                 jz      short loc_1E68
.text$mn:00001E49                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E4C                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001E51                 mov     esi, eax
.text$mn:00001E53                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001E56                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001E5B                 cmp     esi, eax
.text$mn:00001E5D                 jnz     short loc_1E68
.text$mn:00001E5F                 mov     [ebp+var_8], 1
.text$mn:00001E66                 jmp     short loc_1E6F
.text$mn:00001E68 ; ---------------------------------------------------------------------------
.text$mn:00001E68
.text$mn:00001E68 loc_1E68:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001E68                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001E68                 mov     [ebp+var_8], 0
.text$mn:00001E6F
.text$mn:00001E6F loc_1E6F:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001E6F                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001E72                 pop     esi
.text$mn:00001E73                 mov     esp, ebp
.text$mn:00001E75                 pop     ebp
.text$mn:00001E76                 retn    4
.text$mn:00001E76 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001E76
.text$mn:00001E76 ; ---------------------------------------------------------------------------
.text$mn:00001E79                 align 4
.text$mn:00001E79 _text$mn        ends
.text$mn:00001E79
.text$mn:00001E7C ; ===========================================================================
.text$mn:00001E7C
.text$mn:00001E7C ; Segment type: Pure code
.text$mn:00001E7C ; Segment permissions: Read/Execute
.text$mn:00001E7C _text$mn        segment para public 'CODE' use32
.text$mn:00001E7C                 assume cs:_text$mn
.text$mn:00001E7C                 ;org 1E7Ch
.text$mn:00001E7C ; COMDAT (pick any)
.text$mn:00001E7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E7C
.text$mn:00001E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E7C
.text$mn:00001E7C ; Attributes: bp-based frame
.text$mn:00001E7C
.text$mn:00001E7C ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001E7C                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001E7C ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001E7C
.text$mn:00001E7C var_4           = dword ptr -4
.text$mn:00001E7C arg_0           = dword ptr  8
.text$mn:00001E7C
.text$mn:00001E7C                 push    ebp
.text$mn:00001E7D                 mov     ebp, esp
.text$mn:00001E7F                 push    ecx
.text$mn:00001E80                 mov     [ebp+var_4], ecx
.text$mn:00001E83                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E86                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001E8B                 mov     eax, [ebp+arg_0]
.text$mn:00001E8E                 and     eax, 1
.text$mn:00001E91                 jz      short loc_1E9F
.text$mn:00001E93                 mov     ecx, [ebp+var_4]
.text$mn:00001E96                 push    ecx             ; void *
.text$mn:00001E97                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E9C                 add     esp, 4
.text$mn:00001E9F
.text$mn:00001E9F loc_1E9F:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001E9F                 mov     eax, [ebp+var_4]
.text$mn:00001EA2                 mov     esp, ebp
.text$mn:00001EA4                 pop     ebp
.text$mn:00001EA5                 retn    4
.text$mn:00001EA5 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001EA5
.text$mn:00001EA5 _text$mn        ends
.text$mn:00001EA5
.text$mn:00001EA8 ; ===========================================================================
.text$mn:00001EA8
.text$mn:00001EA8 ; Segment type: Pure code
.text$mn:00001EA8 ; Segment permissions: Read/Execute
.text$mn:00001EA8 _text$mn        segment para public 'CODE' use32
.text$mn:00001EA8                 assume cs:_text$mn
.text$mn:00001EA8                 ;org 1EA8h
.text$mn:00001EA8 ; COMDAT (pick any)
.text$mn:00001EA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001EA8
.text$mn:00001EA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00001EA8
.text$mn:00001EA8 ; Attributes: bp-based frame
.text$mn:00001EA8
.text$mn:00001EA8 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001EA8                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001EA8 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001EA8
.text$mn:00001EA8 var_4           = dword ptr -4
.text$mn:00001EA8 arg_0           = dword ptr  8
.text$mn:00001EA8
.text$mn:00001EA8                 push    ebp
.text$mn:00001EA9                 mov     ebp, esp
.text$mn:00001EAB                 push    ecx
.text$mn:00001EAC                 mov     [ebp+var_4], ecx
.text$mn:00001EAF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001EB2                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001EB7                 mov     eax, [ebp+arg_0]
.text$mn:00001EBA                 and     eax, 1
.text$mn:00001EBD                 jz      short loc_1ECB
.text$mn:00001EBF                 mov     ecx, [ebp+var_4]
.text$mn:00001EC2                 push    ecx             ; void *
.text$mn:00001EC3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001EC8                 add     esp, 4
.text$mn:00001ECB
.text$mn:00001ECB loc_1ECB:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001ECB                 mov     eax, [ebp+var_4]
.text$mn:00001ECE                 mov     esp, ebp
.text$mn:00001ED0                 pop     ebp
.text$mn:00001ED1                 retn    4
.text$mn:00001ED1 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001ED1
.text$mn:00001ED1 _text$mn        ends
.text$mn:00001ED1
.text$mn:00001ED4 ; ===========================================================================
.text$mn:00001ED4
.text$mn:00001ED4 ; Segment type: Pure code
.text$mn:00001ED4 ; Segment permissions: Read/Execute
.text$mn:00001ED4 _text$mn        segment para public 'CODE' use32
.text$mn:00001ED4                 assume cs:_text$mn
.text$mn:00001ED4                 ;org 1ED4h
.text$mn:00001ED4 ; COMDAT (pick any)
.text$mn:00001ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001ED4
.text$mn:00001ED4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001ED4
.text$mn:00001ED4 ; Attributes: bp-based frame
.text$mn:00001ED4
.text$mn:00001ED4 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001ED4                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001ED4 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001ED4
.text$mn:00001ED4 var_4           = dword ptr -4
.text$mn:00001ED4 arg_0           = dword ptr  8
.text$mn:00001ED4
.text$mn:00001ED4                 push    ebp
.text$mn:00001ED5                 mov     ebp, esp
.text$mn:00001ED7                 push    ecx
.text$mn:00001ED8                 mov     [ebp+var_4], ecx
.text$mn:00001EDB                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001EDE                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001EE3                 mov     eax, [ebp+arg_0]
.text$mn:00001EE6                 and     eax, 1
.text$mn:00001EE9                 jz      short loc_1EF7
.text$mn:00001EEB                 mov     ecx, [ebp+var_4]
.text$mn:00001EEE                 push    ecx             ; void *
.text$mn:00001EEF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001EF4                 add     esp, 4
.text$mn:00001EF7
.text$mn:00001EF7 loc_1EF7:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001EF7                 mov     eax, [ebp+var_4]
.text$mn:00001EFA                 mov     esp, ebp
.text$mn:00001EFC                 pop     ebp
.text$mn:00001EFD                 retn    4
.text$mn:00001EFD ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001EFD
.text$mn:00001EFD _text$mn        ends
.text$mn:00001EFD
.text$mn:00001F00 ; ===========================================================================
.text$mn:00001F00
.text$mn:00001F00 ; Segment type: Pure code
.text$mn:00001F00 ; Segment permissions: Read/Execute
.text$mn:00001F00 _text$mn        segment para public 'CODE' use32
.text$mn:00001F00                 assume cs:_text$mn
.text$mn:00001F00                 ;org 1F00h
.text$mn:00001F00 ; COMDAT (pick any)
.text$mn:00001F00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F00
.text$mn:00001F00 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F00
.text$mn:00001F00 ; Attributes: bp-based frame
.text$mn:00001F00
.text$mn:00001F00 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001F00                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001F00 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001F00
.text$mn:00001F00 var_4           = dword ptr -4
.text$mn:00001F00 arg_0           = dword ptr  8
.text$mn:00001F00
.text$mn:00001F00                 push    ebp
.text$mn:00001F01                 mov     ebp, esp
.text$mn:00001F03                 push    ecx
.text$mn:00001F04                 mov     [ebp+var_4], ecx
.text$mn:00001F07                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001F0A                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001F0F                 mov     eax, [ebp+arg_0]
.text$mn:00001F12                 and     eax, 1
.text$mn:00001F15                 jz      short loc_1F23
.text$mn:00001F17                 mov     ecx, [ebp+var_4]
.text$mn:00001F1A                 push    ecx             ; void *
.text$mn:00001F1B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001F20                 add     esp, 4
.text$mn:00001F23
.text$mn:00001F23 loc_1F23:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001F23                 mov     eax, [ebp+var_4]
.text$mn:00001F26                 mov     esp, ebp
.text$mn:00001F28                 pop     ebp
.text$mn:00001F29                 retn    4
.text$mn:00001F29 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001F29
.text$mn:00001F29 _text$mn        ends
.text$mn:00001F29
.text$mn:00001F2C ; ===========================================================================
.text$mn:00001F2C
.text$mn:00001F2C ; Segment type: Pure code
.text$mn:00001F2C ; Segment permissions: Read/Execute
.text$mn:00001F2C _text$mn        segment para public 'CODE' use32
.text$mn:00001F2C                 assume cs:_text$mn
.text$mn:00001F2C                 ;org 1F2Ch
.text$mn:00001F2C ; COMDAT (pick any)
.text$mn:00001F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F2C
.text$mn:00001F2C ; =============== S U B R O U T I N E =======================================
.text$mn:00001F2C
.text$mn:00001F2C ; Attributes: bp-based frame
.text$mn:00001F2C
.text$mn:00001F2C ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:00001F2C                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:00001F2C ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:00001F2C
.text$mn:00001F2C var_4           = dword ptr -4
.text$mn:00001F2C arg_0           = dword ptr  8
.text$mn:00001F2C
.text$mn:00001F2C                 push    ebp
.text$mn:00001F2D                 mov     ebp, esp
.text$mn:00001F2F                 push    ecx
.text$mn:00001F30                 mov     [ebp+var_4], ecx
.text$mn:00001F33                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001F36                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:00001F3B                 mov     eax, [ebp+arg_0]
.text$mn:00001F3E                 and     eax, 1
.text$mn:00001F41                 jz      short loc_1F4F
.text$mn:00001F43                 mov     ecx, [ebp+var_4]
.text$mn:00001F46                 push    ecx             ; void *
.text$mn:00001F47                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001F4C                 add     esp, 4
.text$mn:00001F4F
.text$mn:00001F4F loc_1F4F:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:00001F4F                 mov     eax, [ebp+var_4]
.text$mn:00001F52                 mov     esp, ebp
.text$mn:00001F54                 pop     ebp
.text$mn:00001F55                 retn    4
.text$mn:00001F55 ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:00001F55
.text$mn:00001F55 _text$mn        ends
.text$mn:00001F55
.text$di:00001F58 ; ===========================================================================
.text$di:00001F58
.text$di:00001F58 ; Segment type: Pure code
.text$di:00001F58 ; Segment permissions: Read/Execute
.text$di:00001F58 _text$di        segment para public 'CODE' use32
.text$di:00001F58                 assume cs:_text$di
.text$di:00001F58                 ;org 1F58h
.text$di:00001F58 ; COMDAT (pick any)
.text$di:00001F58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001F58
.text$di:00001F58 ; =============== S U B R O U T I N E =======================================
.text$di:00001F58
.text$di:00001F58 ; Attributes: bp-based frame
.text$di:00001F58
.text$di:00001F58 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001F58 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001F58                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001F58                 push    ebp
.text$di:00001F59                 mov     ebp, esp
.text$di:00001F5B                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001F60                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001F65                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001F6A                 call    _atexit
.text$di:00001F6F                 add     esp, 4
.text$di:00001F72                 pop     ebp
.text$di:00001F73                 retn
.text$di:00001F73 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001F73
.text$di:00001F73 _text$di        ends
.text$di:00001F73
.text$di:00001F74 ; ===========================================================================
.text$di:00001F74
.text$di:00001F74 ; Segment type: Pure code
.text$di:00001F74 ; Segment permissions: Read/Execute
.text$di:00001F74 _text$di        segment para public 'CODE' use32
.text$di:00001F74                 assume cs:_text$di
.text$di:00001F74                 ;org 1F74h
.text$di:00001F74 ; COMDAT (pick any)
.text$di:00001F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001F74
.text$di:00001F74 ; =============== S U B R O U T I N E =======================================
.text$di:00001F74
.text$di:00001F74 ; Attributes: bp-based frame
.text$di:00001F74
.text$di:00001F74 ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001F74 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001F74                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001F74                 push    ebp
.text$di:00001F75                 mov     ebp, esp
.text$di:00001F77                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001F7C                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001F81                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001F86                 call    _atexit
.text$di:00001F8B                 add     esp, 4
.text$di:00001F8E                 pop     ebp
.text$di:00001F8F                 retn
.text$di:00001F8F ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001F8F
.text$di:00001F8F _text$di        ends
.text$di:00001F8F
.text$di:00001F90 ; ===========================================================================
.text$di:00001F90
.text$di:00001F90 ; Segment type: Pure code
.text$di:00001F90 ; Segment permissions: Read/Execute
.text$di:00001F90 _text$di        segment para public 'CODE' use32
.text$di:00001F90                 assume cs:_text$di
.text$di:00001F90                 ;org 1F90h
.text$di:00001F90 ; COMDAT (pick any)
.text$di:00001F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001F90
.text$di:00001F90 ; =============== S U B R O U T I N E =======================================
.text$di:00001F90
.text$di:00001F90 ; Attributes: bp-based frame
.text$di:00001F90
.text$di:00001F90 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001F90 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001F90                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001F90                 push    ebp
.text$di:00001F91                 mov     ebp, esp
.text$di:00001F93                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001F98                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001F9D                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001FA2                 call    _atexit
.text$di:00001FA7                 add     esp, 4
.text$di:00001FAA                 pop     ebp
.text$di:00001FAB                 retn
.text$di:00001FAB ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001FAB
.text$di:00001FAB _text$di        ends
.text$di:00001FAB
.text$di:00001FAC ; ===========================================================================
.text$di:00001FAC
.text$di:00001FAC ; Segment type: Pure code
.text$di:00001FAC ; Segment permissions: Read/Execute
.text$di:00001FAC _text$di        segment para public 'CODE' use32
.text$di:00001FAC                 assume cs:_text$di
.text$di:00001FAC                 ;org 1FACh
.text$di:00001FAC ; COMDAT (pick any)
.text$di:00001FAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001FAC
.text$di:00001FAC ; =============== S U B R O U T I N E =======================================
.text$di:00001FAC
.text$di:00001FAC ; Attributes: bp-based frame
.text$di:00001FAC
.text$di:00001FAC ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001FAC ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001FAC                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001FAC                 push    ebp
.text$di:00001FAD                 mov     ebp, esp
.text$di:00001FAF                 push    0               ; unsigned int
.text$di:00001FB1                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001FB6                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001FBB                 pop     ebp
.text$di:00001FBC                 retn
.text$di:00001FBC ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001FBC
.text$di:00001FBC ; ---------------------------------------------------------------------------
.text$di:00001FBD                 align 10h
.text$di:00001FBD _text$di        ends
.text$di:00001FBD
.text$di:00001FC0 ; ===========================================================================
.text$di:00001FC0
.text$di:00001FC0 ; Segment type: Pure code
.text$di:00001FC0 ; Segment permissions: Read/Execute
.text$di:00001FC0 _text$di        segment para public 'CODE' use32
.text$di:00001FC0                 assume cs:_text$di
.text$di:00001FC0                 ;org 1FC0h
.text$di:00001FC0 ; COMDAT (pick any)
.text$di:00001FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001FC0
.text$di:00001FC0 ; =============== S U B R O U T I N E =======================================
.text$di:00001FC0
.text$di:00001FC0 ; Attributes: bp-based frame
.text$di:00001FC0
.text$di:00001FC0 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001FC0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001FC0                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001FC0                 push    ebp
.text$di:00001FC1                 mov     ebp, esp
.text$di:00001FC3                 push    0               ; unsigned int
.text$di:00001FC5                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001FCA                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001FCF                 pop     ebp
.text$di:00001FD0                 retn
.text$di:00001FD0 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001FD0
.text$di:00001FD0 ; ---------------------------------------------------------------------------
.text$di:00001FD1                 align 4
.text$di:00001FD1 _text$di        ends
.text$di:00001FD1
.text$di:00001FD4 ; ===========================================================================
.text$di:00001FD4
.text$di:00001FD4 ; Segment type: Pure code
.text$di:00001FD4 ; Segment permissions: Read/Execute
.text$di:00001FD4 _text$di        segment para public 'CODE' use32
.text$di:00001FD4                 assume cs:_text$di
.text$di:00001FD4                 ;org 1FD4h
.text$di:00001FD4 ; COMDAT (pick any)
.text$di:00001FD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001FD4
.text$di:00001FD4 ; =============== S U B R O U T I N E =======================================
.text$di:00001FD4
.text$di:00001FD4 ; Attributes: bp-based frame
.text$di:00001FD4
.text$di:00001FD4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001FD4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001FD4                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001FD4                 push    ebp
.text$di:00001FD5                 mov     ebp, esp
.text$di:00001FD7                 push    0               ; unsigned int
.text$di:00001FD9                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001FDE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001FE3                 pop     ebp
.text$di:00001FE4                 retn
.text$di:00001FE4 ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001FE4
.text$di:00001FE4 ; ---------------------------------------------------------------------------
.text$di:00001FE5                 align 4
.text$di:00001FE5 _text$di        ends
.text$di:00001FE5
.text$di:00001FE8 ; ===========================================================================
.text$di:00001FE8
.text$di:00001FE8 ; Segment type: Pure code
.text$di:00001FE8 ; Segment permissions: Read/Execute
.text$di:00001FE8 _text$di        segment para public 'CODE' use32
.text$di:00001FE8                 assume cs:_text$di
.text$di:00001FE8                 ;org 1FE8h
.text$di:00001FE8 ; COMDAT (pick any)
.text$di:00001FE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001FE8
.text$di:00001FE8 ; =============== S U B R O U T I N E =======================================
.text$di:00001FE8
.text$di:00001FE8 ; Attributes: bp-based frame
.text$di:00001FE8
.text$di:00001FE8 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001FE8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001FE8                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001FE8                 push    ebp
.text$di:00001FE9                 mov     ebp, esp
.text$di:00001FEB                 push    0               ; unsigned int
.text$di:00001FED                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001FF2                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001FF7                 pop     ebp
.text$di:00001FF8                 retn
.text$di:00001FF8 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001FF8
.text$di:00001FF8 ; ---------------------------------------------------------------------------
.text$di:00001FF9                 align 4
.text$di:00001FF9 _text$di        ends
.text$di:00001FF9
.text$di:00001FFC ; ===========================================================================
.text$di:00001FFC
.text$di:00001FFC ; Segment type: Pure code
.text$di:00001FFC ; Segment permissions: Read/Execute
.text$di:00001FFC _text$di        segment para public 'CODE' use32
.text$di:00001FFC                 assume cs:_text$di
.text$di:00001FFC                 ;org 1FFCh
.text$di:00001FFC ; COMDAT (pick any)
.text$di:00001FFC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00001FFC
.text$di:00001FFC ; =============== S U B R O U T I N E =======================================
.text$di:00001FFC
.text$di:00001FFC ; Attributes: bp-based frame
.text$di:00001FFC
.text$di:00001FFC ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001FFC ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001FFC
.text$di:00001FFC var_1           = byte ptr -1
.text$di:00001FFC
.text$di:00001FFC                 push    ebp
.text$di:00001FFD                 mov     ebp, esp
.text$di:00001FFF                 push    ecx
.text$di:00002000                 xor     eax, eax
.text$di:00002002                 mov     [ebp+var_1], al
.text$di:00002005                 mov     esp, ebp
.text$di:00002007                 pop     ebp
.text$di:00002008                 retn
.text$di:00002008 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00002008
.text$di:00002008 ; ---------------------------------------------------------------------------
.text$di:00002009                 align 4
.text$di:00002009 _text$di        ends
.text$di:00002009
.text$di:0000200C ; ===========================================================================
.text$di:0000200C
.text$di:0000200C ; Segment type: Pure code
.text$di:0000200C ; Segment permissions: Read/Execute
.text$di:0000200C _text$di        segment para public 'CODE' use32
.text$di:0000200C                 assume cs:_text$di
.text$di:0000200C                 ;org 200Ch
.text$di:0000200C ; COMDAT (pick any)
.text$di:0000200C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:0000200C
.text$di:0000200C ; =============== S U B R O U T I N E =======================================
.text$di:0000200C
.text$di:0000200C ; Attributes: bp-based frame
.text$di:0000200C
.text$di:0000200C ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:0000200C ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:0000200C                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:0000200C
.text$di:0000200C var_1           = byte ptr -1
.text$di:0000200C
.text$di:0000200C                 push    ebp
.text$di:0000200D                 mov     ebp, esp
.text$di:0000200F                 push    ecx
.text$di:00002010                 xor     eax, eax
.text$di:00002012                 mov     [ebp+var_1], al
.text$di:00002015                 mov     esp, ebp
.text$di:00002017                 pop     ebp
.text$di:00002018                 retn
.text$di:00002018 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00002018
.text$di:00002018 ; ---------------------------------------------------------------------------
.text$di:00002019                 align 4
.text$di:00002019 _text$di        ends
.text$di:00002019
.text$yd:0000201C ; ===========================================================================
.text$yd:0000201C
.text$yd:0000201C ; Segment type: Pure code
.text$yd:0000201C ; Segment permissions: Read/Execute
.text$yd:0000201C _text$yd        segment para public 'CODE' use32
.text$yd:0000201C                 assume cs:_text$yd
.text$yd:0000201C                 ;org 201Ch
.text$yd:0000201C ; COMDAT (pick any)
.text$yd:0000201C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000201C
.text$yd:0000201C ; =============== S U B R O U T I N E =======================================
.text$yd:0000201C
.text$yd:0000201C ; Attributes: bp-based frame
.text$yd:0000201C
.text$yd:0000201C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:0000201C ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:0000201C                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:0000201C                 push    ebp
.text$yd:0000201D                 mov     ebp, esp
.text$yd:0000201F                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00002024                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00002029                 pop     ebp
.text$yd:0000202A                 retn
.text$yd:0000202A ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:0000202A
.text$yd:0000202A ; ---------------------------------------------------------------------------
.text$yd:0000202B                 align 4
.text$yd:0000202B _text$yd        ends
.text$yd:0000202B
.text$yd:0000202C ; ===========================================================================
.text$yd:0000202C
.text$yd:0000202C ; Segment type: Pure code
.text$yd:0000202C ; Segment permissions: Read/Execute
.text$yd:0000202C _text$yd        segment para public 'CODE' use32
.text$yd:0000202C                 assume cs:_text$yd
.text$yd:0000202C                 ;org 202Ch
.text$yd:0000202C ; COMDAT (pick any)
.text$yd:0000202C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000202C
.text$yd:0000202C ; =============== S U B R O U T I N E =======================================
.text$yd:0000202C
.text$yd:0000202C ; Attributes: bp-based frame
.text$yd:0000202C
.text$yd:0000202C ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:0000202C ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:0000202C                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:0000202C                 push    ebp
.text$yd:0000202D                 mov     ebp, esp
.text$yd:0000202F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00002034                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00002039                 pop     ebp
.text$yd:0000203A                 retn
.text$yd:0000203A ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:0000203A
.text$yd:0000203A ; ---------------------------------------------------------------------------
.text$yd:0000203B                 align 4
.text$yd:0000203B _text$yd        ends
.text$yd:0000203B
.text$yd:0000203C ; ===========================================================================
.text$yd:0000203C
.text$yd:0000203C ; Segment type: Pure code
.text$yd:0000203C ; Segment permissions: Read/Execute
.text$yd:0000203C _text$yd        segment para public 'CODE' use32
.text$yd:0000203C                 assume cs:_text$yd
.text$yd:0000203C                 ;org 203Ch
.text$yd:0000203C ; COMDAT (pick any)
.text$yd:0000203C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:0000203C
.text$yd:0000203C ; =============== S U B R O U T I N E =======================================
.text$yd:0000203C
.text$yd:0000203C ; Attributes: bp-based frame
.text$yd:0000203C
.text$yd:0000203C ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:0000203C ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:0000203C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:0000203C                 push    ebp
.text$yd:0000203D                 mov     ebp, esp
.text$yd:0000203F                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00002044                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00002049                 pop     ebp
.text$yd:0000204A                 retn
.text$yd:0000204A ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:0000204A
.text$yd:0000204A ; ---------------------------------------------------------------------------
.text$yd:0000204B                 align 4
.text$yd:0000204B _text$yd        ends
.text$yd:0000204B
.text$mn:0000204C ; ===========================================================================
.text$mn:0000204C
.text$mn:0000204C ; Segment type: Pure code
.text$mn:0000204C ; Segment permissions: Read/Execute
.text$mn:0000204C _text$mn        segment para public 'CODE' use32
.text$mn:0000204C                 assume cs:_text$mn
.text$mn:0000204C                 ;org 204Ch
.text$mn:0000204C ; COMDAT (pick any)
.text$mn:0000204C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000204C
.text$mn:0000204C ; =============== S U B R O U T I N E =======================================
.text$mn:0000204C
.text$mn:0000204C ; Attributes: bp-based frame
.text$mn:0000204C
.text$mn:0000204C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:0000204C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:0000204C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:0000204C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:0000204C
.text$mn:0000204C var_10          = byte ptr -10h
.text$mn:0000204C var_8           = dword ptr -8
.text$mn:0000204C var_1           = byte ptr -1
.text$mn:0000204C
.text$mn:0000204C                 push    ebp
.text$mn:0000204D                 mov     ebp, esp
.text$mn:0000204F                 sub     esp, 10h
.text$mn:00002052                 mov     [ebp+var_8], ecx
.text$mn:00002055                 lea     ecx, [ebp+var_1]
.text$mn:00002058                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:0000205D                 push    1
.text$mn:0000205F                 lea     ecx, [ebp+var_1]
.text$mn:00002062                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00002067                 mov     ecx, [ebp+var_8]
.text$mn:0000206A                 mov     [ecx], eax
.text$mn:0000206C                 lea     ecx, [ebp+var_10] ; this
.text$mn:0000206F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00002074                 push    eax             ; int
.text$mn:00002075                 mov     edx, [ebp+var_8]
.text$mn:00002078                 mov     eax, [edx]
.text$mn:0000207A                 push    eax             ; void *
.text$mn:0000207B                 lea     ecx, [ebp+var_1]
.text$mn:0000207E                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00002083                 mov     ecx, [ebp+var_8]
.text$mn:00002086                 mov     edx, [ecx]
.text$mn:00002088                 mov     eax, [ebp+var_8]
.text$mn:0000208B                 mov     [edx], eax
.text$mn:0000208D                 mov     esp, ebp
.text$mn:0000208F                 pop     ebp
.text$mn:00002090                 retn
.text$mn:00002090 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00002090
.text$mn:00002090 ; ---------------------------------------------------------------------------
.text$mn:00002091                 align 4
.text$mn:00002091 _text$mn        ends
.text$mn:00002091
.text$mn:00002094 ; ===========================================================================
.text$mn:00002094
.text$mn:00002094 ; Segment type: Pure code
.text$mn:00002094 ; Segment permissions: Read/Execute
.text$mn:00002094 _text$mn        segment para public 'CODE' use32
.text$mn:00002094                 assume cs:_text$mn
.text$mn:00002094                 ;org 2094h
.text$mn:00002094 ; COMDAT (pick any)
.text$mn:00002094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002094
.text$mn:00002094 ; =============== S U B R O U T I N E =======================================
.text$mn:00002094
.text$mn:00002094 ; Attributes: bp-based frame
.text$mn:00002094
.text$mn:00002094 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Alloc_proxy(void)
.text$mn:00002094                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00002094 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00002094                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(std::allocator<wchar_t> const &)+38p
.text$mn:00002094
.text$mn:00002094 var_10          = byte ptr -10h
.text$mn:00002094 var_8           = dword ptr -8
.text$mn:00002094 var_1           = byte ptr -1
.text$mn:00002094
.text$mn:00002094                 push    ebp
.text$mn:00002095                 mov     ebp, esp
.text$mn:00002097                 sub     esp, 10h
.text$mn:0000209A                 mov     [ebp+var_8], ecx
.text$mn:0000209D                 lea     ecx, [ebp+var_1]
.text$mn:000020A0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000020A5                 push    1
.text$mn:000020A7                 lea     ecx, [ebp+var_1]
.text$mn:000020AA                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000020AF                 mov     ecx, [ebp+var_8]
.text$mn:000020B2                 mov     [ecx], eax
.text$mn:000020B4                 lea     ecx, [ebp+var_10] ; this
.text$mn:000020B7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:000020BC                 push    eax             ; int
.text$mn:000020BD                 mov     edx, [ebp+var_8]
.text$mn:000020C0                 mov     eax, [edx]
.text$mn:000020C2                 push    eax             ; void *
.text$mn:000020C3                 lea     ecx, [ebp+var_1]
.text$mn:000020C6                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:000020CB                 mov     ecx, [ebp+var_8]
.text$mn:000020CE                 mov     edx, [ecx]
.text$mn:000020D0                 mov     eax, [ebp+var_8]
.text$mn:000020D3                 mov     [edx], eax
.text$mn:000020D5                 mov     esp, ebp
.text$mn:000020D7                 pop     ebp
.text$mn:000020D8                 retn
.text$mn:000020D8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:000020D8
.text$mn:000020D8 ; ---------------------------------------------------------------------------
.text$mn:000020D9                 align 4
.text$mn:000020D9 _text$mn        ends
.text$mn:000020D9
.text$mn:000020DC ; ===========================================================================
.text$mn:000020DC
.text$mn:000020DC ; Segment type: Pure code
.text$mn:000020DC ; Segment permissions: Read/Execute
.text$mn:000020DC _text$mn        segment para public 'CODE' use32
.text$mn:000020DC                 assume cs:_text$mn
.text$mn:000020DC                 ;org 20DCh
.text$mn:000020DC ; COMDAT (pick any)
.text$mn:000020DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020DC
.text$mn:000020DC ; =============== S U B R O U T I N E =======================================
.text$mn:000020DC
.text$mn:000020DC ; Attributes: bp-based frame
.text$mn:000020DC
.text$mn:000020DC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:000020DC                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000020DC ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:000020DC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:000020DC
.text$mn:000020DC var_20          = dword ptr -20h
.text$mn:000020DC var_1C          = dword ptr -1Ch
.text$mn:000020DC var_18          = dword ptr -18h
.text$mn:000020DC var_11          = byte ptr -11h
.text$mn:000020DC var_10          = dword ptr -10h
.text$mn:000020DC var_C           = byte ptr -0Ch
.text$mn:000020DC var_4           = dword ptr -4
.text$mn:000020DC arg_0           = dword ptr  8
.text$mn:000020DC
.text$mn:000020DC ; FUNCTION CHUNK AT .text$mn:000021FE SIZE 00000009 BYTES
.text$mn:000020DC
.text$mn:000020DC                 push    ebp
.text$mn:000020DD                 mov     ebp, esp
.text$mn:000020DF                 push    0FFFFFFFFh
.text$mn:000020E1                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000020E6                 mov     eax, large fs:0
.text$mn:000020EC                 push    eax
.text$mn:000020ED                 push    ecx
.text$mn:000020EE                 sub     esp, 10h
.text$mn:000020F1                 push    ebx
.text$mn:000020F2                 push    esi
.text$mn:000020F3                 push    edi
.text$mn:000020F4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000020F9                 xor     eax, ebp
.text$mn:000020FB                 push    eax
.text$mn:000020FC                 lea     eax, [ebp+var_C]
.text$mn:000020FF                 mov     large fs:0, eax
.text$mn:00002105                 mov     [ebp+var_10], esp
.text$mn:00002108                 mov     [ebp+var_18], ecx
.text$mn:0000210B                 mov     eax, [ebp+arg_0]
.text$mn:0000210E                 or      eax, 0Fh
.text$mn:00002111                 mov     [ebp+var_1C], eax
.text$mn:00002114                 mov     ecx, [ebp+var_18]
.text$mn:00002117                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000211C                 cmp     eax, [ebp+var_1C]
.text$mn:0000211F                 jnb     short loc_2129
.text$mn:00002121                 mov     ecx, [ebp+arg_0]
.text$mn:00002124                 mov     [ebp+var_1C], ecx
.text$mn:00002127                 jmp     short loc_217B
.text$mn:00002129 ; ---------------------------------------------------------------------------
.text$mn:00002129
.text$mn:00002129 loc_2129:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00002129                 mov     edx, [ebp+var_18]
.text$mn:0000212C                 mov     ecx, [edx+18h]
.text$mn:0000212F                 shr     ecx, 1
.text$mn:00002131                 mov     eax, [ebp+var_1C]
.text$mn:00002134                 xor     edx, edx
.text$mn:00002136                 mov     esi, 3
.text$mn:0000213B                 div     esi
.text$mn:0000213D                 cmp     ecx, eax
.text$mn:0000213F                 ja      short loc_2143
.text$mn:00002141                 jmp     short loc_217B
.text$mn:00002143 ; ---------------------------------------------------------------------------
.text$mn:00002143
.text$mn:00002143 loc_2143:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00002143                 mov     ecx, [ebp+var_18]
.text$mn:00002146                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000214B                 mov     edx, [ebp+var_18]
.text$mn:0000214E                 mov     ecx, [edx+18h]
.text$mn:00002151                 shr     ecx, 1
.text$mn:00002153                 sub     eax, ecx
.text$mn:00002155                 mov     edx, [ebp+var_18]
.text$mn:00002158                 cmp     [edx+18h], eax
.text$mn:0000215B                 ja      short loc_2170
.text$mn:0000215D                 mov     eax, [ebp+var_18]
.text$mn:00002160                 mov     ecx, [eax+18h]
.text$mn:00002163                 shr     ecx, 1
.text$mn:00002165                 mov     edx, [ebp+var_18]
.text$mn:00002168                 add     ecx, [edx+18h]
.text$mn:0000216B                 mov     [ebp+var_1C], ecx
.text$mn:0000216E                 jmp     short loc_217B
.text$mn:00002170 ; ---------------------------------------------------------------------------
.text$mn:00002170
.text$mn:00002170 loc_2170:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00002170                 mov     ecx, [ebp+var_18]
.text$mn:00002173                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002178                 mov     [ebp+var_1C], eax
.text$mn:0000217B
.text$mn:0000217B loc_217B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000217B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000217B                 mov     [ebp+var_4], 0
.text$mn:00002182                 mov     eax, [ebp+var_1C]
.text$mn:00002185                 add     eax, 1
.text$mn:00002188                 push    eax
.text$mn:00002189                 lea     ecx, [ebp+var_11]
.text$mn:0000218C                 push    ecx
.text$mn:0000218D                 mov     ecx, [ebp+var_18]
.text$mn:00002190                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002195                 mov     ecx, eax
.text$mn:00002197                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:0000219C                 mov     [ebp+var_20], eax
.text$mn:0000219F                 jmp     short loc_21FE
.text$mn:0000219F ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:0000219F
.text$mn:000021A1
.text$mn:000021A1 ; =============== S U B R O U T I N E =======================================
.text$mn:000021A1
.text$mn:000021A1
.text$mn:000021A1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000021A1                                         ; DATA XREF: .xdata$x:00003894o
.text$mn:000021A1
.text$mn:000021A1 ; FUNCTION CHUNK AT .text$mn:000021E8 SIZE 00000009 BYTES
.text$mn:000021A1 ; FUNCTION CHUNK AT .text$mn:000021F8 SIZE 00000006 BYTES
.text$mn:000021A1
.text$mn:000021A1                 mov     [ebp-10h], esp
.text$mn:000021A4                 mov     edx, [ebp+8]
.text$mn:000021A7                 mov     [ebp-1Ch], edx
.text$mn:000021AA                 mov     byte ptr [ebp-4], 2
.text$mn:000021AE                 mov     eax, [ebp-1Ch]
.text$mn:000021B1                 add     eax, 1
.text$mn:000021B4                 push    eax
.text$mn:000021B5                 lea     ecx, [ebp-12h]
.text$mn:000021B8                 push    ecx
.text$mn:000021B9                 mov     ecx, [ebp-18h]
.text$mn:000021BC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000021C1                 mov     ecx, eax
.text$mn:000021C3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000021C8                 mov     [ebp-20h], eax
.text$mn:000021CB                 jmp     short loc_21E8
.text$mn:000021CB __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000021CB
.text$mn:000021CD
.text$mn:000021CD ; =============== S U B R O U T I N E =======================================
.text$mn:000021CD
.text$mn:000021CD ; Attributes: noreturn
.text$mn:000021CD
.text$mn:000021CD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000021CD                                         ; DATA XREF: .xdata$x:000038A4o
.text$mn:000021CD                 push    0               ; Size
.text$mn:000021CF                 push    1               ; char
.text$mn:000021D1                 mov     ecx, [ebp-18h]
.text$mn:000021D4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000021D9                 push    0
.text$mn:000021DB                 push    0
.text$mn:000021DD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000021DD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000021DD
.text$mn:000021E2 ; ---------------------------------------------------------------------------
.text$mn:000021E2                 mov     eax, offset $LN17
.text$mn:000021E7                 retn
.text$mn:000021E8 ; ---------------------------------------------------------------------------
.text$mn:000021E8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000021E8
.text$mn:000021E8 loc_21E8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000021E8                 mov     dword ptr [ebp-4], 1
.text$mn:000021EF                 jmp     short loc_21F8
.text$mn:000021EF ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000021F1
.text$mn:000021F1 ; =============== S U B R O U T I N E =======================================
.text$mn:000021F1
.text$mn:000021F1
.text$mn:000021F1 $LN17           proc near               ; DATA XREF: .text$mn:000021E2o
.text$mn:000021F1                 mov     dword ptr [ebp-4], 1
.text$mn:000021F1 $LN17           endp ; sp-analysis failed
.text$mn:000021F1
.text$mn:000021F8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000021F8
.text$mn:000021F8 loc_21F8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000021F8                 mov     eax, offset $LN19
.text$mn:000021FD                 retn
.text$mn:000021FD ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:000021FE ; ---------------------------------------------------------------------------
.text$mn:000021FE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:000021FE
.text$mn:000021FE loc_21FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:000021FE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002205                 jmp     short loc_220E
.text$mn:00002205 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00002207
.text$mn:00002207 ; =============== S U B R O U T I N E =======================================
.text$mn:00002207
.text$mn:00002207
.text$mn:00002207 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_21F8o
.text$mn:00002207                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000220E
.text$mn:0000220E loc_220E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000220E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00002212                 jbe     short loc_222D
.text$mn:00002214                 mov     edx, [ebp+0Ch]
.text$mn:00002217                 push    edx             ; Size
.text$mn:00002218                 mov     ecx, [ebp-18h]
.text$mn:0000221B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002220                 push    eax             ; Src
.text$mn:00002221                 mov     eax, [ebp-20h]
.text$mn:00002224                 push    eax             ; Dst
.text$mn:00002225                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000222A                 add     esp, 0Ch
.text$mn:0000222D
.text$mn:0000222D loc_222D:                               ; CODE XREF: $LN19+Bj
.text$mn:0000222D                 push    0               ; Size
.text$mn:0000222F                 push    1               ; char
.text$mn:00002231                 mov     ecx, [ebp-18h]
.text$mn:00002234                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002239                 lea     ecx, [ebp-20h]
.text$mn:0000223C                 push    ecx             ; int
.text$mn:0000223D                 mov     edx, [ebp-18h]
.text$mn:00002240                 add     edx, 4
.text$mn:00002243                 push    edx             ; void *
.text$mn:00002244                 lea     eax, [ebp-13h]
.text$mn:00002247                 push    eax
.text$mn:00002248                 mov     ecx, [ebp-18h]
.text$mn:0000224B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002250                 mov     ecx, eax
.text$mn:00002252                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002257                 mov     ecx, [ebp-18h]
.text$mn:0000225A                 mov     edx, [ebp-1Ch]
.text$mn:0000225D                 mov     [ecx+18h], edx
.text$mn:00002260                 mov     eax, [ebp+0Ch]
.text$mn:00002263                 push    eax
.text$mn:00002264                 mov     ecx, [ebp-18h]
.text$mn:00002267                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000226C                 mov     ecx, [ebp-0Ch]
.text$mn:0000226F                 mov     large fs:0, ecx
.text$mn:00002276                 pop     ecx
.text$mn:00002277                 pop     edi
.text$mn:00002278                 pop     esi
.text$mn:00002279                 pop     ebx
.text$mn:0000227A                 mov     esp, ebp
.text$mn:0000227C                 pop     ebp
.text$mn:0000227D                 retn    8
.text$mn:0000227D $LN19           endp ; sp-analysis failed
.text$mn:0000227D
.text$mn:0000227D _text$mn        ends
.text$mn:0000227D
.text$x:00002280 ; ===========================================================================
.text$x:00002280
.text$x:00002280 ; Segment type: Pure code
.text$x:00002280 ; Segment permissions: Read/Execute
.text$x:00002280 _text$x         segment para public 'CODE' use32
.text$x:00002280                 assume cs:_text$x
.text$x:00002280                 ;org 2280h
.text$x:00002280 ; COMDAT (pick associative to section at 20DC)
.text$x:00002280                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002280
.text$x:00002280 ; =============== S U B R O U T I N E =======================================
.text$x:00002280
.text$x:00002280
.text$x:00002280 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00002280                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00002280
.text$x:00002280 arg_4           = dword ptr  8
.text$x:00002280
.text$x:00002280                 mov     edx, [esp+arg_4]
.text$x:00002284                 lea     eax, [edx+0Ch]
.text$x:00002287                 mov     ecx, [edx-24h]
.text$x:0000228A                 xor     ecx, eax
.text$x:0000228C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002291                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00002296                 jmp     ___CxxFrameHandler3
.text$x:00002296 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00002296
.text$x:00002296 ; ---------------------------------------------------------------------------
.text$x:0000229B                 align 4
.text$x:0000229B _text$x         ends
.text$x:0000229B
.text$mn:0000229C ; ===========================================================================
.text$mn:0000229C
.text$mn:0000229C ; Segment type: Pure code
.text$mn:0000229C ; Segment permissions: Read/Execute
.text$mn:0000229C _text$mn        segment para public 'CODE' use32
.text$mn:0000229C                 assume cs:_text$mn
.text$mn:0000229C                 ;org 229Ch
.text$mn:0000229C ; COMDAT (pick any)
.text$mn:0000229C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000229C
.text$mn:0000229C ; =============== S U B R O U T I N E =======================================
.text$mn:0000229C
.text$mn:0000229C ; Attributes: bp-based frame
.text$mn:0000229C
.text$mn:0000229C ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Copy(unsigned int, unsigned int)
.text$mn:0000229C                 public ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:0000229C ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$mn:0000229C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+37p
.text$mn:0000229C
.text$mn:0000229C var_20          = dword ptr -20h
.text$mn:0000229C var_1C          = dword ptr -1Ch
.text$mn:0000229C var_18          = dword ptr -18h
.text$mn:0000229C var_11          = byte ptr -11h
.text$mn:0000229C var_10          = dword ptr -10h
.text$mn:0000229C var_C           = byte ptr -0Ch
.text$mn:0000229C var_4           = dword ptr -4
.text$mn:0000229C arg_0           = dword ptr  8
.text$mn:0000229C
.text$mn:0000229C ; FUNCTION CHUNK AT .text$mn:000023BE SIZE 00000009 BYTES
.text$mn:0000229C
.text$mn:0000229C                 push    ebp
.text$mn:0000229D                 mov     ebp, esp
.text$mn:0000229F                 push    0FFFFFFFFh
.text$mn:000022A1                 push    offset __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000022A6                 mov     eax, large fs:0
.text$mn:000022AC                 push    eax
.text$mn:000022AD                 push    ecx
.text$mn:000022AE                 sub     esp, 10h
.text$mn:000022B1                 push    ebx
.text$mn:000022B2                 push    esi
.text$mn:000022B3                 push    edi
.text$mn:000022B4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022B9                 xor     eax, ebp
.text$mn:000022BB                 push    eax
.text$mn:000022BC                 lea     eax, [ebp+var_C]
.text$mn:000022BF                 mov     large fs:0, eax
.text$mn:000022C5                 mov     [ebp+var_10], esp
.text$mn:000022C8                 mov     [ebp+var_18], ecx
.text$mn:000022CB                 mov     eax, [ebp+arg_0]
.text$mn:000022CE                 or      eax, 7
.text$mn:000022D1                 mov     [ebp+var_1C], eax
.text$mn:000022D4                 mov     ecx, [ebp+var_18]
.text$mn:000022D7                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:000022DC                 cmp     eax, [ebp+var_1C]
.text$mn:000022DF                 jnb     short loc_22E9
.text$mn:000022E1                 mov     ecx, [ebp+arg_0]
.text$mn:000022E4                 mov     [ebp+var_1C], ecx
.text$mn:000022E7                 jmp     short loc_233B
.text$mn:000022E9 ; ---------------------------------------------------------------------------
.text$mn:000022E9
.text$mn:000022E9 loc_22E9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+43j
.text$mn:000022E9                 mov     edx, [ebp+var_18]
.text$mn:000022EC                 mov     ecx, [edx+18h]
.text$mn:000022EF                 shr     ecx, 1
.text$mn:000022F1                 mov     eax, [ebp+var_1C]
.text$mn:000022F4                 xor     edx, edx
.text$mn:000022F6                 mov     esi, 3
.text$mn:000022FB                 div     esi
.text$mn:000022FD                 cmp     ecx, eax
.text$mn:000022FF                 ja      short loc_2303
.text$mn:00002301                 jmp     short loc_233B
.text$mn:00002303 ; ---------------------------------------------------------------------------
.text$mn:00002303
.text$mn:00002303 loc_2303:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+63j
.text$mn:00002303                 mov     ecx, [ebp+var_18]
.text$mn:00002306                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000230B                 mov     edx, [ebp+var_18]
.text$mn:0000230E                 mov     ecx, [edx+18h]
.text$mn:00002311                 shr     ecx, 1
.text$mn:00002313                 sub     eax, ecx
.text$mn:00002315                 mov     edx, [ebp+var_18]
.text$mn:00002318                 cmp     [edx+18h], eax
.text$mn:0000231B                 ja      short loc_2330
.text$mn:0000231D                 mov     eax, [ebp+var_18]
.text$mn:00002320                 mov     ecx, [eax+18h]
.text$mn:00002323                 shr     ecx, 1
.text$mn:00002325                 mov     edx, [ebp+var_18]
.text$mn:00002328                 add     ecx, [edx+18h]
.text$mn:0000232B                 mov     [ebp+var_1C], ecx
.text$mn:0000232E                 jmp     short loc_233B
.text$mn:00002330 ; ---------------------------------------------------------------------------
.text$mn:00002330
.text$mn:00002330 loc_2330:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+7Fj
.text$mn:00002330                 mov     ecx, [ebp+var_18]
.text$mn:00002333                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:00002338                 mov     [ebp+var_1C], eax
.text$mn:0000233B
.text$mn:0000233B loc_233B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+4Bj
.text$mn:0000233B                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+65j ...
.text$mn:0000233B                 mov     [ebp+var_4], 0
.text$mn:00002342                 mov     eax, [ebp+var_1C]
.text$mn:00002345                 add     eax, 1
.text$mn:00002348                 push    eax
.text$mn:00002349                 lea     ecx, [ebp+var_11]
.text$mn:0000234C                 push    ecx
.text$mn:0000234D                 mov     ecx, [ebp+var_18]
.text$mn:00002350                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002355                 mov     ecx, eax
.text$mn:00002357                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:0000235C                 mov     [ebp+var_20], eax
.text$mn:0000235F                 jmp     short loc_23BE
.text$mn:0000235F ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$mn:0000235F
.text$mn:00002361
.text$mn:00002361 ; =============== S U B R O U T I N E =======================================
.text$mn:00002361
.text$mn:00002361
.text$mn:00002361 __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 proc near
.text$mn:00002361                                         ; DATA XREF: .xdata$x:00003C38o
.text$mn:00002361
.text$mn:00002361 ; FUNCTION CHUNK AT .text$mn:000023A8 SIZE 00000009 BYTES
.text$mn:00002361 ; FUNCTION CHUNK AT .text$mn:000023B8 SIZE 00000006 BYTES
.text$mn:00002361
.text$mn:00002361                 mov     [ebp-10h], esp
.text$mn:00002364                 mov     edx, [ebp+8]
.text$mn:00002367                 mov     [ebp-1Ch], edx
.text$mn:0000236A                 mov     byte ptr [ebp-4], 2
.text$mn:0000236E                 mov     eax, [ebp-1Ch]
.text$mn:00002371                 add     eax, 1
.text$mn:00002374                 push    eax
.text$mn:00002375                 lea     ecx, [ebp-12h]
.text$mn:00002378                 push    ecx
.text$mn:00002379                 mov     ecx, [ebp-18h]
.text$mn:0000237C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002381                 mov     ecx, eax
.text$mn:00002383                 call    ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)
.text$mn:00002388                 mov     [ebp-20h], eax
.text$mn:0000238B                 jmp     short loc_23A8
.text$mn:0000238B __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0 endp
.text$mn:0000238B
.text$mn:0000238D
.text$mn:0000238D ; =============== S U B R O U T I N E =======================================
.text$mn:0000238D
.text$mn:0000238D ; Attributes: noreturn
.text$mn:0000238D
.text$mn:0000238D __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 proc near
.text$mn:0000238D                                         ; DATA XREF: .xdata$x:00003C48o
.text$mn:0000238D                 push    0
.text$mn:0000238F                 push    1
.text$mn:00002391                 mov     ecx, [ebp-18h]
.text$mn:00002394                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:00002399                 push    0
.text$mn:0000239B                 push    0
.text$mn:0000239D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:0000239D __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1 endp
.text$mn:0000239D
.text$mn:000023A2 ; ---------------------------------------------------------------------------
.text$mn:000023A2                 mov     eax, offset $LN17_0
.text$mn:000023A7                 retn
.text$mn:000023A8 ; ---------------------------------------------------------------------------
.text$mn:000023A8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000023A8
.text$mn:000023A8 loc_23A8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+2Aj
.text$mn:000023A8                 mov     dword ptr [ebp-4], 1
.text$mn:000023AF                 jmp     short loc_23B8
.text$mn:000023AF ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000023B1
.text$mn:000023B1 ; =============== S U B R O U T I N E =======================================
.text$mn:000023B1
.text$mn:000023B1
.text$mn:000023B1 $LN17_0         proc near               ; DATA XREF: .text$mn:000023A2o
.text$mn:000023B1                 mov     dword ptr [ebp-4], 1
.text$mn:000023B1 $LN17_0         endp ; sp-analysis failed
.text$mn:000023B1
.text$mn:000023B8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000023B8
.text$mn:000023B8 loc_23B8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+4Ej
.text$mn:000023B8                 mov     eax, offset $LN19_0
.text$mn:000023BD                 retn
.text$mn:000023BD ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.text$mn:000023BE ; ---------------------------------------------------------------------------
.text$mn:000023BE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000023BE
.text$mn:000023BE loc_23BE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+C3j
.text$mn:000023BE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000023C5                 jmp     short loc_23CE
.text$mn:000023C5 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$mn:000023C7
.text$mn:000023C7 ; =============== S U B R O U T I N E =======================================
.text$mn:000023C7
.text$mn:000023C7
.text$mn:000023C7 $LN19_0         proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0:loc_23B8o
.text$mn:000023C7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:000023CE
.text$mn:000023CE loc_23CE:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+129j
.text$mn:000023CE                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:000023D2                 jbe     short loc_23ED
.text$mn:000023D4                 mov     edx, [ebp+0Ch]
.text$mn:000023D7                 push    edx             ; int
.text$mn:000023D8                 mov     ecx, [ebp-18h]
.text$mn:000023DB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000023E0                 push    eax             ; Src
.text$mn:000023E1                 mov     eax, [ebp-20h]
.text$mn:000023E4                 push    eax             ; Dst
.text$mn:000023E5                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000023EA                 add     esp, 0Ch
.text$mn:000023ED
.text$mn:000023ED loc_23ED:                               ; CODE XREF: $LN19_0+Bj
.text$mn:000023ED                 push    0
.text$mn:000023EF                 push    1
.text$mn:000023F1                 mov     ecx, [ebp-18h]
.text$mn:000023F4                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000023F9                 lea     ecx, [ebp-20h]
.text$mn:000023FC                 push    ecx             ; int
.text$mn:000023FD                 mov     edx, [ebp-18h]
.text$mn:00002400                 add     edx, 4
.text$mn:00002403                 push    edx             ; void *
.text$mn:00002404                 lea     eax, [ebp-13h]
.text$mn:00002407                 push    eax
.text$mn:00002408                 mov     ecx, [ebp-18h]
.text$mn:0000240B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002410                 mov     ecx, eax
.text$mn:00002412                 call    ??$construct@PA_WAAPA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_WAAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::construct<wchar_t *,wchar_t * &>(wchar_t * *,wchar_t * &)
.text$mn:00002417                 mov     ecx, [ebp-18h]
.text$mn:0000241A                 mov     edx, [ebp-1Ch]
.text$mn:0000241D                 mov     [ecx+18h], edx
.text$mn:00002420                 mov     eax, [ebp+0Ch]
.text$mn:00002423                 push    eax
.text$mn:00002424                 mov     ecx, [ebp-18h]
.text$mn:00002427                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:0000242C                 mov     ecx, [ebp-0Ch]
.text$mn:0000242F                 mov     large fs:0, ecx
.text$mn:00002436                 pop     ecx
.text$mn:00002437                 pop     edi
.text$mn:00002438                 pop     esi
.text$mn:00002439                 pop     ebx
.text$mn:0000243A                 mov     esp, ebp
.text$mn:0000243C                 pop     ebp
.text$mn:0000243D                 retn    8
.text$mn:0000243D $LN19_0         endp ; sp-analysis failed
.text$mn:0000243D
.text$mn:0000243D _text$mn        ends
.text$mn:0000243D
.text$x:00002440 ; ===========================================================================
.text$x:00002440
.text$x:00002440 ; Segment type: Pure code
.text$x:00002440 ; Segment permissions: Read/Execute
.text$x:00002440 _text$x         segment para public 'CODE' use32
.text$x:00002440                 assume cs:_text$x
.text$x:00002440                 ;org 2440h
.text$x:00002440 ; COMDAT (pick associative to section at 229C)
.text$x:00002440                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002440
.text$x:00002440 ; =============== S U B R O U T I N E =======================================
.text$x:00002440
.text$x:00002440
.text$x:00002440 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z proc near
.text$x:00002440                                         ; DATA XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+5o
.text$x:00002440
.text$x:00002440 arg_4           = dword ptr  8
.text$x:00002440
.text$x:00002440                 mov     edx, [esp+arg_4]
.text$x:00002444                 lea     eax, [edx+0Ch]
.text$x:00002447                 mov     ecx, [edx-24h]
.text$x:0000244A                 xor     ecx, eax
.text$x:0000244C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002451                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.text$x:00002456                 jmp     ___CxxFrameHandler3
.text$x:00002456 __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z endp
.text$x:00002456
.text$x:00002456 ; ---------------------------------------------------------------------------
.text$x:0000245B                 align 4
.text$x:0000245B _text$x         ends
.text$x:0000245B
.text$mn:0000245C ; ===========================================================================
.text$mn:0000245C
.text$mn:0000245C ; Segment type: Pure code
.text$mn:0000245C ; Segment permissions: Read/Execute
.text$mn:0000245C _text$mn        segment para public 'CODE' use32
.text$mn:0000245C                 assume cs:_text$mn
.text$mn:0000245C                 ;org 245Ch
.text$mn:0000245C ; COMDAT (pick any)
.text$mn:0000245C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000245C
.text$mn:0000245C ; =============== S U B R O U T I N E =======================================
.text$mn:0000245C
.text$mn:0000245C ; Attributes: bp-based frame
.text$mn:0000245C
.text$mn:0000245C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:0000245C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:0000245C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:0000245C                                         ; CODE XREF: $LN19+60p
.text$mn:0000245C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:0000245C
.text$mn:0000245C var_8           = dword ptr -8
.text$mn:0000245C var_1           = byte ptr -1
.text$mn:0000245C arg_0           = dword ptr  8
.text$mn:0000245C
.text$mn:0000245C                 push    ebp
.text$mn:0000245D                 mov     ebp, esp
.text$mn:0000245F                 sub     esp, 8
.text$mn:00002462                 mov     [ebp+var_8], ecx
.text$mn:00002465                 mov     [ebp+var_1], 0
.text$mn:00002469                 mov     eax, [ebp+var_8]
.text$mn:0000246C                 mov     ecx, [ebp+arg_0]
.text$mn:0000246F                 mov     [eax+14h], ecx
.text$mn:00002472                 lea     edx, [ebp+var_1]
.text$mn:00002475                 push    edx
.text$mn:00002476                 mov     ecx, [ebp+var_8]
.text$mn:00002479                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000247E                 add     eax, [ebp+arg_0]
.text$mn:00002481                 push    eax
.text$mn:00002482                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00002487                 add     esp, 8
.text$mn:0000248A                 mov     esp, ebp
.text$mn:0000248C                 pop     ebp
.text$mn:0000248D                 retn    4
.text$mn:0000248D ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:0000248D
.text$mn:0000248D _text$mn        ends
.text$mn:0000248D
.text$mn:00002490 ; ===========================================================================
.text$mn:00002490
.text$mn:00002490 ; Segment type: Pure code
.text$mn:00002490 ; Segment permissions: Read/Execute
.text$mn:00002490 _text$mn        segment para public 'CODE' use32
.text$mn:00002490                 assume cs:_text$mn
.text$mn:00002490                 ;org 2490h
.text$mn:00002490 ; COMDAT (pick any)
.text$mn:00002490                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002490
.text$mn:00002490 ; =============== S U B R O U T I N E =======================================
.text$mn:00002490
.text$mn:00002490 ; Attributes: bp-based frame
.text$mn:00002490
.text$mn:00002490 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Eos(unsigned int)
.text$mn:00002490                 public ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z
.text$mn:00002490 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z proc near
.text$mn:00002490                                         ; CODE XREF: $LN19_0+60p
.text$mn:00002490                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+83p ...
.text$mn:00002490
.text$mn:00002490 var_8           = dword ptr -8
.text$mn:00002490 var_2           = word ptr -2
.text$mn:00002490 arg_0           = dword ptr  8
.text$mn:00002490
.text$mn:00002490                 push    ebp
.text$mn:00002491                 mov     ebp, esp
.text$mn:00002493                 sub     esp, 8
.text$mn:00002496                 mov     [ebp+var_8], ecx
.text$mn:00002499                 xor     eax, eax
.text$mn:0000249B                 mov     [ebp+var_2], ax
.text$mn:0000249F                 mov     ecx, [ebp+var_8]
.text$mn:000024A2                 mov     edx, [ebp+arg_0]
.text$mn:000024A5                 mov     [ecx+14h], edx
.text$mn:000024A8                 lea     eax, [ebp+var_2]
.text$mn:000024AB                 push    eax
.text$mn:000024AC                 mov     ecx, [ebp+var_8]
.text$mn:000024AF                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000024B4                 mov     ecx, [ebp+arg_0]
.text$mn:000024B7                 lea     edx, [eax+ecx*2]
.text$mn:000024BA                 push    edx
.text$mn:000024BB                 call    ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z ; std::char_traits<wchar_t>::assign(wchar_t &,wchar_t const &)
.text$mn:000024C0                 add     esp, 8
.text$mn:000024C3                 mov     esp, ebp
.text$mn:000024C5                 pop     ebp
.text$mn:000024C6                 retn    4
.text$mn:000024C6 ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z endp
.text$mn:000024C6
.text$mn:000024C6 ; ---------------------------------------------------------------------------
.text$mn:000024C9                 align 4
.text$mn:000024C9 _text$mn        ends
.text$mn:000024C9
.text$mn:000024CC ; ===========================================================================
.text$mn:000024CC
.text$mn:000024CC ; Segment type: Pure code
.text$mn:000024CC ; Segment permissions: Read/Execute
.text$mn:000024CC _text$mn        segment para public 'CODE' use32
.text$mn:000024CC                 assume cs:_text$mn
.text$mn:000024CC                 ;org 24CCh
.text$mn:000024CC ; COMDAT (pick any)
.text$mn:000024CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024CC
.text$mn:000024CC ; =============== S U B R O U T I N E =======================================
.text$mn:000024CC
.text$mn:000024CC ; Attributes: bp-based frame
.text$mn:000024CC
.text$mn:000024CC ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000024CC                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000024CC ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000024CC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000024CC
.text$mn:000024CC var_8           = dword ptr -8
.text$mn:000024CC var_1           = byte ptr -1
.text$mn:000024CC
.text$mn:000024CC                 push    ebp
.text$mn:000024CD                 mov     ebp, esp
.text$mn:000024CF                 sub     esp, 8
.text$mn:000024D2                 mov     [ebp+var_8], ecx
.text$mn:000024D5                 lea     ecx, [ebp+var_1]
.text$mn:000024D8                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:000024DD                 mov     ecx, [ebp+var_8] ; this
.text$mn:000024E0                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000024E5                 mov     eax, [ebp+var_8]
.text$mn:000024E8                 mov     ecx, [eax]
.text$mn:000024EA                 push    ecx
.text$mn:000024EB                 lea     ecx, [ebp+var_1]
.text$mn:000024EE                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:000024F3                 push    1               ; int
.text$mn:000024F5                 mov     edx, [ebp+var_8]
.text$mn:000024F8                 mov     eax, [edx]
.text$mn:000024FA                 push    eax             ; void *
.text$mn:000024FB                 lea     ecx, [ebp+var_1]
.text$mn:000024FE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00002503                 mov     ecx, [ebp+var_8]
.text$mn:00002506                 mov     dword ptr [ecx], 0
.text$mn:0000250C                 mov     esp, ebp
.text$mn:0000250E                 pop     ebp
.text$mn:0000250F                 retn
.text$mn:0000250F ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:0000250F
.text$mn:0000250F _text$mn        ends
.text$mn:0000250F
.text$mn:00002510 ; ===========================================================================
.text$mn:00002510
.text$mn:00002510 ; Segment type: Pure code
.text$mn:00002510 ; Segment permissions: Read/Execute
.text$mn:00002510 _text$mn        segment para public 'CODE' use32
.text$mn:00002510                 assume cs:_text$mn
.text$mn:00002510                 ;org 2510h
.text$mn:00002510 ; COMDAT (pick any)
.text$mn:00002510                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002510
.text$mn:00002510 ; =============== S U B R O U T I N E =======================================
.text$mn:00002510
.text$mn:00002510 ; Attributes: bp-based frame
.text$mn:00002510
.text$mn:00002510 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Free_proxy(void)
.text$mn:00002510                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ
.text$mn:00002510 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00002510                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::~_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>(void)+30p
.text$mn:00002510
.text$mn:00002510 var_8           = dword ptr -8
.text$mn:00002510 var_1           = byte ptr -1
.text$mn:00002510
.text$mn:00002510                 push    ebp
.text$mn:00002511                 mov     ebp, esp
.text$mn:00002513                 sub     esp, 8
.text$mn:00002516                 mov     [ebp+var_8], ecx
.text$mn:00002519                 lea     ecx, [ebp+var_1]
.text$mn:0000251C                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002521                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002524                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002529                 mov     eax, [ebp+var_8]
.text$mn:0000252C                 mov     ecx, [eax]
.text$mn:0000252E                 push    ecx
.text$mn:0000252F                 lea     ecx, [ebp+var_1]
.text$mn:00002532                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002537                 push    1               ; int
.text$mn:00002539                 mov     edx, [ebp+var_8]
.text$mn:0000253C                 mov     eax, [edx]
.text$mn:0000253E                 push    eax             ; void *
.text$mn:0000253F                 lea     ecx, [ebp+var_1]
.text$mn:00002542                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00002547                 mov     ecx, [ebp+var_8]
.text$mn:0000254A                 mov     dword ptr [ecx], 0
.text$mn:00002550                 mov     esp, ebp
.text$mn:00002552                 pop     ebp
.text$mn:00002553                 retn
.text$mn:00002553 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAEXXZ endp
.text$mn:00002553
.text$mn:00002553 _text$mn        ends
.text$mn:00002553
.text$mn:00002554 ; ===========================================================================
.text$mn:00002554
.text$mn:00002554 ; Segment type: Pure code
.text$mn:00002554 ; Segment permissions: Read/Execute
.text$mn:00002554 _text$mn        segment para public 'CODE' use32
.text$mn:00002554                 assume cs:_text$mn
.text$mn:00002554                 ;org 2554h
.text$mn:00002554 ; COMDAT (pick any)
.text$mn:00002554                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002554
.text$mn:00002554 ; =============== S U B R O U T I N E =======================================
.text$mn:00002554
.text$mn:00002554 ; Attributes: bp-based frame
.text$mn:00002554
.text$mn:00002554 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00002554                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00002554 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00002554                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00002554                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00002554
.text$mn:00002554 var_4           = dword ptr -4
.text$mn:00002554 arg_0           = dword ptr  8
.text$mn:00002554
.text$mn:00002554                 push    ebp
.text$mn:00002555                 mov     ebp, esp
.text$mn:00002557                 push    ecx
.text$mn:00002558                 mov     [ebp+var_4], ecx
.text$mn:0000255B                 mov     ecx, [ebp+arg_0]
.text$mn:0000255E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00002563                 mov     eax, [ebp+arg_0]
.text$mn:00002566                 mov     esp, ebp
.text$mn:00002568                 pop     ebp
.text$mn:00002569                 retn    4
.text$mn:00002569 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00002569
.text$mn:00002569 _text$mn        ends
.text$mn:00002569
.text$mn:0000256C ; ===========================================================================
.text$mn:0000256C
.text$mn:0000256C ; Segment type: Pure code
.text$mn:0000256C ; Segment permissions: Read/Execute
.text$mn:0000256C _text$mn        segment para public 'CODE' use32
.text$mn:0000256C                 assume cs:_text$mn
.text$mn:0000256C                 ;org 256Ch
.text$mn:0000256C ; COMDAT (pick any)
.text$mn:0000256C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000256C
.text$mn:0000256C ; =============== S U B R O U T I N E =======================================
.text$mn:0000256C
.text$mn:0000256C ; Attributes: bp-based frame
.text$mn:0000256C
.text$mn:0000256C ; public: struct std::_Wrap_alloc<class std::allocator<wchar_t>> __thiscall std::_String_alloc<0, struct std::_String_base_types<wchar_t, class std::allocator<wchar_t>>>::_Getal(void)const
.text$mn:0000256C                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ
.text$mn:0000256C ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ proc near
.text$mn:0000256C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+B4p
.text$mn:0000256C                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:0000256C
.text$mn:0000256C var_4           = dword ptr -4
.text$mn:0000256C arg_0           = dword ptr  8
.text$mn:0000256C
.text$mn:0000256C                 push    ebp
.text$mn:0000256D                 mov     ebp, esp
.text$mn:0000256F                 push    ecx
.text$mn:00002570                 mov     [ebp+var_4], ecx
.text$mn:00002573                 mov     ecx, [ebp+arg_0]
.text$mn:00002576                 call    ??0?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::_Wrap_alloc<std::allocator<wchar_t>>(void)
.text$mn:0000257B                 mov     eax, [ebp+arg_0]
.text$mn:0000257E                 mov     esp, ebp
.text$mn:00002580                 pop     ebp
.text$mn:00002581                 retn    4
.text$mn:00002581 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ endp
.text$mn:00002581
.text$mn:00002581 _text$mn        ends
.text$mn:00002581
.text$mn:00002584 ; ===========================================================================
.text$mn:00002584
.text$mn:00002584 ; Segment type: Pure code
.text$mn:00002584 ; Segment permissions: Read/Execute
.text$mn:00002584 _text$mn        segment para public 'CODE' use32
.text$mn:00002584                 assume cs:_text$mn
.text$mn:00002584                 ;org 2584h
.text$mn:00002584 ; COMDAT (pick any)
.text$mn:00002584                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002584
.text$mn:00002584 ; =============== S U B R O U T I N E =======================================
.text$mn:00002584
.text$mn:00002584 ; Attributes: bp-based frame
.text$mn:00002584
.text$mn:00002584 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00002584                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00002584 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00002584                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00002584                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00002584
.text$mn:00002584 var_C           = dword ptr -0Ch
.text$mn:00002584 Size            = dword ptr -8
.text$mn:00002584 var_4           = dword ptr -4
.text$mn:00002584 arg_0           = dword ptr  8
.text$mn:00002584 arg_4           = byte ptr  0Ch
.text$mn:00002584
.text$mn:00002584                 push    ebp
.text$mn:00002585                 mov     ebp, esp
.text$mn:00002587                 sub     esp, 0Ch
.text$mn:0000258A                 mov     [ebp+var_4], ecx
.text$mn:0000258D                 mov     ecx, [ebp+var_4]
.text$mn:00002590                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002595                 cmp     eax, [ebp+arg_0]
.text$mn:00002598                 jnb     short loc_25A2
.text$mn:0000259A                 mov     ecx, [ebp+var_4]
.text$mn:0000259D                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:000025A2
.text$mn:000025A2 loc_25A2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:000025A2                 mov     eax, [ebp+var_4]
.text$mn:000025A5                 mov     ecx, [eax+18h]
.text$mn:000025A8                 cmp     ecx, [ebp+arg_0]
.text$mn:000025AB                 jnb     short loc_25C2
.text$mn:000025AD                 mov     edx, [ebp+var_4]
.text$mn:000025B0                 mov     eax, [edx+14h]
.text$mn:000025B3                 push    eax
.text$mn:000025B4                 mov     ecx, [ebp+arg_0]
.text$mn:000025B7                 push    ecx
.text$mn:000025B8                 mov     ecx, [ebp+var_4]
.text$mn:000025BB                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000025C0                 jmp     short loc_260C
.text$mn:000025C2 ; ---------------------------------------------------------------------------
.text$mn:000025C2
.text$mn:000025C2 loc_25C2:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000025C2                 movzx   edx, [ebp+arg_4]
.text$mn:000025C6                 test    edx, edx
.text$mn:000025C8                 jz      short loc_25FC
.text$mn:000025CA                 cmp     [ebp+arg_0], 10h
.text$mn:000025CE                 jnb     short loc_25FC
.text$mn:000025D0                 mov     eax, [ebp+var_4]
.text$mn:000025D3                 mov     ecx, [ebp+arg_0]
.text$mn:000025D6                 cmp     ecx, [eax+14h]
.text$mn:000025D9                 jnb     short loc_25E3
.text$mn:000025DB                 mov     edx, [ebp+arg_0]
.text$mn:000025DE                 mov     [ebp+Size], edx
.text$mn:000025E1                 jmp     short loc_25EC
.text$mn:000025E3 ; ---------------------------------------------------------------------------
.text$mn:000025E3
.text$mn:000025E3 loc_25E3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000025E3                 mov     eax, [ebp+var_4]
.text$mn:000025E6                 mov     ecx, [eax+14h]
.text$mn:000025E9                 mov     [ebp+Size], ecx
.text$mn:000025EC
.text$mn:000025EC loc_25EC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000025EC                 mov     edx, [ebp+Size]
.text$mn:000025EF                 push    edx             ; Size
.text$mn:000025F0                 push    1               ; char
.text$mn:000025F2                 mov     ecx, [ebp+var_4]
.text$mn:000025F5                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000025FA                 jmp     short loc_260C
.text$mn:000025FC ; ---------------------------------------------------------------------------
.text$mn:000025FC
.text$mn:000025FC loc_25FC:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000025FC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000025FC                 cmp     [ebp+arg_0], 0
.text$mn:00002600                 jnz     short loc_260C
.text$mn:00002602                 push    0
.text$mn:00002604                 mov     ecx, [ebp+var_4]
.text$mn:00002607                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000260C
.text$mn:0000260C loc_260C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:0000260C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:0000260C                 cmp     [ebp+arg_0], 0
.text$mn:00002610                 jbe     short loc_261B
.text$mn:00002612                 mov     [ebp+var_C], 1
.text$mn:00002619                 jmp     short loc_2622
.text$mn:0000261B ; ---------------------------------------------------------------------------
.text$mn:0000261B
.text$mn:0000261B loc_261B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000261B                 mov     [ebp+var_C], 0
.text$mn:00002622
.text$mn:00002622 loc_2622:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00002622                 mov     al, byte ptr [ebp+var_C]
.text$mn:00002625                 mov     esp, ebp
.text$mn:00002627                 pop     ebp
.text$mn:00002628                 retn    8
.text$mn:00002628 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:00002628
.text$mn:00002628 ; ---------------------------------------------------------------------------
.text$mn:0000262B                 align 4
.text$mn:0000262B _text$mn        ends
.text$mn:0000262B
.text$mn:0000262C ; ===========================================================================
.text$mn:0000262C
.text$mn:0000262C ; Segment type: Pure code
.text$mn:0000262C ; Segment permissions: Read/Execute
.text$mn:0000262C _text$mn        segment para public 'CODE' use32
.text$mn:0000262C                 assume cs:_text$mn
.text$mn:0000262C                 ;org 262Ch
.text$mn:0000262C ; COMDAT (pick any)
.text$mn:0000262C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000262C
.text$mn:0000262C ; =============== S U B R O U T I N E =======================================
.text$mn:0000262C
.text$mn:0000262C ; Attributes: bp-based frame
.text$mn:0000262C
.text$mn:0000262C ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Grow(unsigned int, bool)
.text$mn:0000262C                 public ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z
.text$mn:0000262C ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z proc near
.text$mn:0000262C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+6Ap
.text$mn:0000262C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+61p
.text$mn:0000262C
.text$mn:0000262C var_C           = dword ptr -0Ch
.text$mn:0000262C var_8           = dword ptr -8
.text$mn:0000262C var_4           = dword ptr -4
.text$mn:0000262C arg_0           = dword ptr  8
.text$mn:0000262C arg_4           = byte ptr  0Ch
.text$mn:0000262C
.text$mn:0000262C                 push    ebp
.text$mn:0000262D                 mov     ebp, esp
.text$mn:0000262F                 sub     esp, 0Ch
.text$mn:00002632                 mov     [ebp+var_4], ecx
.text$mn:00002635                 mov     ecx, [ebp+var_4]
.text$mn:00002638                 call    ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)
.text$mn:0000263D                 cmp     eax, [ebp+arg_0]
.text$mn:00002640                 jnb     short loc_264A
.text$mn:00002642                 mov     ecx, [ebp+var_4]
.text$mn:00002645                 call    ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)
.text$mn:0000264A
.text$mn:0000264A loc_264A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+14j
.text$mn:0000264A                 mov     eax, [ebp+var_4]
.text$mn:0000264D                 mov     ecx, [eax+18h]
.text$mn:00002650                 cmp     ecx, [ebp+arg_0]
.text$mn:00002653                 jnb     short loc_266A
.text$mn:00002655                 mov     edx, [ebp+var_4]
.text$mn:00002658                 mov     eax, [edx+14h]
.text$mn:0000265B                 push    eax
.text$mn:0000265C                 mov     ecx, [ebp+arg_0]
.text$mn:0000265F                 push    ecx
.text$mn:00002660                 mov     ecx, [ebp+var_4]
.text$mn:00002663                 call    ?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)
.text$mn:00002668                 jmp     short loc_26B4
.text$mn:0000266A ; ---------------------------------------------------------------------------
.text$mn:0000266A
.text$mn:0000266A loc_266A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+27j
.text$mn:0000266A                 movzx   edx, [ebp+arg_4]
.text$mn:0000266E                 test    edx, edx
.text$mn:00002670                 jz      short loc_26A4
.text$mn:00002672                 cmp     [ebp+arg_0], 8
.text$mn:00002676                 jnb     short loc_26A4
.text$mn:00002678                 mov     eax, [ebp+var_4]
.text$mn:0000267B                 mov     ecx, [ebp+arg_0]
.text$mn:0000267E                 cmp     ecx, [eax+14h]
.text$mn:00002681                 jnb     short loc_268B
.text$mn:00002683                 mov     edx, [ebp+arg_0]
.text$mn:00002686                 mov     [ebp+var_8], edx
.text$mn:00002689                 jmp     short loc_2694
.text$mn:0000268B ; ---------------------------------------------------------------------------
.text$mn:0000268B
.text$mn:0000268B loc_268B:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+55j
.text$mn:0000268B                 mov     eax, [ebp+var_4]
.text$mn:0000268E                 mov     ecx, [eax+14h]
.text$mn:00002691                 mov     [ebp+var_8], ecx
.text$mn:00002694
.text$mn:00002694 loc_2694:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+5Dj
.text$mn:00002694                 mov     edx, [ebp+var_8]
.text$mn:00002697                 push    edx
.text$mn:00002698                 push    1
.text$mn:0000269A                 mov     ecx, [ebp+var_4]
.text$mn:0000269D                 call    ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)
.text$mn:000026A2                 jmp     short loc_26B4
.text$mn:000026A4 ; ---------------------------------------------------------------------------
.text$mn:000026A4
.text$mn:000026A4 loc_26A4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+44j
.text$mn:000026A4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+4Aj
.text$mn:000026A4                 cmp     [ebp+arg_0], 0
.text$mn:000026A8                 jnz     short loc_26B4
.text$mn:000026AA                 push    0
.text$mn:000026AC                 mov     ecx, [ebp+var_4]
.text$mn:000026AF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000026B4
.text$mn:000026B4 loc_26B4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+3Cj
.text$mn:000026B4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+76j ...
.text$mn:000026B4                 cmp     [ebp+arg_0], 0
.text$mn:000026B8                 jbe     short loc_26C3
.text$mn:000026BA                 mov     [ebp+var_C], 1
.text$mn:000026C1                 jmp     short loc_26CA
.text$mn:000026C3 ; ---------------------------------------------------------------------------
.text$mn:000026C3
.text$mn:000026C3 loc_26C3:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+8Cj
.text$mn:000026C3                 mov     [ebp+var_C], 0
.text$mn:000026CA
.text$mn:000026CA loc_26CA:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+95j
.text$mn:000026CA                 mov     al, byte ptr [ebp+var_C]
.text$mn:000026CD                 mov     esp, ebp
.text$mn:000026CF                 pop     ebp
.text$mn:000026D0                 retn    8
.text$mn:000026D0 ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z endp
.text$mn:000026D0
.text$mn:000026D0 ; ---------------------------------------------------------------------------
.text$mn:000026D3                 align 4
.text$mn:000026D3 _text$mn        ends
.text$mn:000026D3
.text$mn:000026D4 ; ===========================================================================
.text$mn:000026D4
.text$mn:000026D4 ; Segment type: Pure code
.text$mn:000026D4 ; Segment permissions: Read/Execute
.text$mn:000026D4 _text$mn        segment para public 'CODE' use32
.text$mn:000026D4                 assume cs:_text$mn
.text$mn:000026D4                 ;org 26D4h
.text$mn:000026D4 ; COMDAT (pick any)
.text$mn:000026D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026D4
.text$mn:000026D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000026D4
.text$mn:000026D4 ; Attributes: bp-based frame
.text$mn:000026D4
.text$mn:000026D4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000026D4                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000026D4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000026D4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000026D4
.text$mn:000026D4 var_4           = dword ptr -4
.text$mn:000026D4 arg_0           = dword ptr  8
.text$mn:000026D4
.text$mn:000026D4                 push    ebp
.text$mn:000026D5                 mov     ebp, esp
.text$mn:000026D7                 push    ecx
.text$mn:000026D8                 mov     [ebp+var_4], ecx
.text$mn:000026DB                 cmp     [ebp+arg_0], 0
.text$mn:000026DF                 jz      short loc_2701
.text$mn:000026E1                 mov     ecx, [ebp+var_4]
.text$mn:000026E4                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000026E9                 cmp     [ebp+arg_0], eax
.text$mn:000026EC                 jb      short loc_2701
.text$mn:000026EE                 mov     ecx, [ebp+var_4]
.text$mn:000026F1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000026F6                 mov     ecx, [ebp+var_4]
.text$mn:000026F9                 add     eax, [ecx+14h]
.text$mn:000026FC                 cmp     eax, [ebp+arg_0]
.text$mn:000026FF                 ja      short loc_2707
.text$mn:00002701
.text$mn:00002701 loc_2701:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00002701                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00002701                 xor     al, al
.text$mn:00002703                 jmp     short loc_2709
.text$mn:00002705 ; ---------------------------------------------------------------------------
.text$mn:00002705                 jmp     short loc_2709
.text$mn:00002707 ; ---------------------------------------------------------------------------
.text$mn:00002707
.text$mn:00002707 loc_2707:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00002707                 mov     al, 1
.text$mn:00002709
.text$mn:00002709 loc_2709:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00002709                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00002709                 mov     esp, ebp
.text$mn:0000270B                 pop     ebp
.text$mn:0000270C                 retn    4
.text$mn:0000270C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:0000270C
.text$mn:0000270C ; ---------------------------------------------------------------------------
.text$mn:0000270F                 align 10h
.text$mn:0000270F _text$mn        ends
.text$mn:0000270F
.text$mn:00002710 ; ===========================================================================
.text$mn:00002710
.text$mn:00002710 ; Segment type: Pure code
.text$mn:00002710 ; Segment permissions: Read/Execute
.text$mn:00002710 _text$mn        segment para public 'CODE' use32
.text$mn:00002710                 assume cs:_text$mn
.text$mn:00002710                 ;org 2710h
.text$mn:00002710 ; COMDAT (pick any)
.text$mn:00002710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002710
.text$mn:00002710 ; =============== S U B R O U T I N E =======================================
.text$mn:00002710
.text$mn:00002710 ; Attributes: bp-based frame
.text$mn:00002710
.text$mn:00002710 ; public: bool __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00002710                 public ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z
.text$mn:00002710 ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z proc near
.text$mn:00002710                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+2Ap
.text$mn:00002710
.text$mn:00002710 var_4           = dword ptr -4
.text$mn:00002710 arg_0           = dword ptr  8
.text$mn:00002710
.text$mn:00002710                 push    ebp
.text$mn:00002711                 mov     ebp, esp
.text$mn:00002713                 push    ecx
.text$mn:00002714                 mov     [ebp+var_4], ecx
.text$mn:00002717                 cmp     [ebp+arg_0], 0
.text$mn:0000271B                 jz      short loc_2740
.text$mn:0000271D                 mov     ecx, [ebp+var_4]
.text$mn:00002720                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002725                 cmp     [ebp+arg_0], eax
.text$mn:00002728                 jb      short loc_2740
.text$mn:0000272A                 mov     ecx, [ebp+var_4]
.text$mn:0000272D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002732                 mov     ecx, [ebp+var_4]
.text$mn:00002735                 mov     edx, [ecx+14h]
.text$mn:00002738                 lea     eax, [eax+edx*2]
.text$mn:0000273B                 cmp     eax, [ebp+arg_0]
.text$mn:0000273E                 ja      short loc_2746
.text$mn:00002740
.text$mn:00002740 loc_2740:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+Bj
.text$mn:00002740                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+18j
.text$mn:00002740                 xor     al, al
.text$mn:00002742                 jmp     short loc_2748
.text$mn:00002744 ; ---------------------------------------------------------------------------
.text$mn:00002744                 jmp     short loc_2748
.text$mn:00002746 ; ---------------------------------------------------------------------------
.text$mn:00002746
.text$mn:00002746 loc_2746:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+2Ej
.text$mn:00002746                 mov     al, 1
.text$mn:00002748
.text$mn:00002748 loc_2748:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+32j
.text$mn:00002748                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)+34j
.text$mn:00002748                 mov     esp, ebp
.text$mn:0000274A                 pop     ebp
.text$mn:0000274B                 retn    4
.text$mn:0000274B ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z endp
.text$mn:0000274B
.text$mn:0000274B ; ---------------------------------------------------------------------------
.text$mn:0000274E                 align 10h
.text$mn:0000274E _text$mn        ends
.text$mn:0000274E
.text$mn:00002750 ; ===========================================================================
.text$mn:00002750
.text$mn:00002750 ; Segment type: Pure code
.text$mn:00002750 ; Segment permissions: Read/Execute
.text$mn:00002750 _text$mn        segment para public 'CODE' use32
.text$mn:00002750                 assume cs:_text$mn
.text$mn:00002750                 ;org 2750h
.text$mn:00002750 ; COMDAT (pick any)
.text$mn:00002750                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002750
.text$mn:00002750 ; =============== S U B R O U T I N E =======================================
.text$mn:00002750
.text$mn:00002750 ; Attributes: bp-based frame
.text$mn:00002750
.text$mn:00002750 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002750                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00002750 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00002750                                         ; CODE XREF: $LN19+14p
.text$mn:00002750                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00002750
.text$mn:00002750 var_8           = dword ptr -8
.text$mn:00002750 var_4           = dword ptr -4
.text$mn:00002750
.text$mn:00002750                 push    ebp
.text$mn:00002751                 mov     ebp, esp
.text$mn:00002753                 sub     esp, 8
.text$mn:00002756                 mov     [ebp+var_4], ecx
.text$mn:00002759                 mov     eax, [ebp+var_4]
.text$mn:0000275C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002760                 jb      short loc_2776
.text$mn:00002762                 mov     ecx, [ebp+var_4]
.text$mn:00002765                 mov     edx, [ecx+4]
.text$mn:00002768                 push    edx
.text$mn:00002769                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000276E                 add     esp, 4
.text$mn:00002771                 mov     [ebp+var_8], eax
.text$mn:00002774                 jmp     short loc_277F
.text$mn:00002776 ; ---------------------------------------------------------------------------
.text$mn:00002776
.text$mn:00002776 loc_2776:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002776                 mov     eax, [ebp+var_4]
.text$mn:00002779                 add     eax, 4
.text$mn:0000277C                 mov     [ebp+var_8], eax
.text$mn:0000277F
.text$mn:0000277F loc_277F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000277F                 mov     eax, [ebp+var_8]
.text$mn:00002782                 mov     esp, ebp
.text$mn:00002784                 pop     ebp
.text$mn:00002785                 retn
.text$mn:00002785 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00002785
.text$mn:00002785 ; ---------------------------------------------------------------------------
.text$mn:00002786                 align 4
.text$mn:00002786 _text$mn        ends
.text$mn:00002786
.text$mn:00002788 ; ===========================================================================
.text$mn:00002788
.text$mn:00002788 ; Segment type: Pure code
.text$mn:00002788 ; Segment permissions: Read/Execute
.text$mn:00002788 _text$mn        segment para public 'CODE' use32
.text$mn:00002788                 assume cs:_text$mn
.text$mn:00002788                 ;org 2788h
.text$mn:00002788 ; COMDAT (pick any)
.text$mn:00002788                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002788
.text$mn:00002788 ; =============== S U B R O U T I N E =======================================
.text$mn:00002788
.text$mn:00002788 ; Attributes: bp-based frame
.text$mn:00002788
.text$mn:00002788 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00002788                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00002788 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00002788                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00002788
.text$mn:00002788 var_8           = dword ptr -8
.text$mn:00002788 var_4           = dword ptr -4
.text$mn:00002788
.text$mn:00002788                 push    ebp
.text$mn:00002789                 mov     ebp, esp
.text$mn:0000278B                 sub     esp, 8
.text$mn:0000278E                 mov     [ebp+var_4], ecx
.text$mn:00002791                 mov     eax, [ebp+var_4]
.text$mn:00002794                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002798                 jb      short loc_27AE
.text$mn:0000279A                 mov     ecx, [ebp+var_4]
.text$mn:0000279D                 mov     edx, [ecx+4]
.text$mn:000027A0                 push    edx
.text$mn:000027A1                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000027A6                 add     esp, 4
.text$mn:000027A9                 mov     [ebp+var_8], eax
.text$mn:000027AC                 jmp     short loc_27B7
.text$mn:000027AE ; ---------------------------------------------------------------------------
.text$mn:000027AE
.text$mn:000027AE loc_27AE:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000027AE                 mov     eax, [ebp+var_4]
.text$mn:000027B1                 add     eax, 4
.text$mn:000027B4                 mov     [ebp+var_8], eax
.text$mn:000027B7
.text$mn:000027B7 loc_27B7:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000027B7                 mov     eax, [ebp+var_8]
.text$mn:000027BA                 mov     esp, ebp
.text$mn:000027BC                 pop     ebp
.text$mn:000027BD                 retn
.text$mn:000027BD ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000027BD
.text$mn:000027BD ; ---------------------------------------------------------------------------
.text$mn:000027BE                 align 10h
.text$mn:000027BE _text$mn        ends
.text$mn:000027BE
.text$mn:000027C0 ; ===========================================================================
.text$mn:000027C0
.text$mn:000027C0 ; Segment type: Pure code
.text$mn:000027C0 ; Segment permissions: Read/Execute
.text$mn:000027C0 _text$mn        segment para public 'CODE' use32
.text$mn:000027C0                 assume cs:_text$mn
.text$mn:000027C0                 ;org 27C0h
.text$mn:000027C0 ; COMDAT (pick any)
.text$mn:000027C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027C0
.text$mn:000027C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C0
.text$mn:000027C0 ; Attributes: bp-based frame
.text$mn:000027C0
.text$mn:000027C0 ; public: wchar_t * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:000027C0                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ
.text$mn:000027C0 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ proc near
.text$mn:000027C0                                         ; CODE XREF: $LN19_0+14p
.text$mn:000027C0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+1Fp ...
.text$mn:000027C0
.text$mn:000027C0 var_8           = dword ptr -8
.text$mn:000027C0 var_4           = dword ptr -4
.text$mn:000027C0
.text$mn:000027C0                 push    ebp
.text$mn:000027C1                 mov     ebp, esp
.text$mn:000027C3                 sub     esp, 8
.text$mn:000027C6                 mov     [ebp+var_4], ecx
.text$mn:000027C9                 mov     eax, [ebp+var_4]
.text$mn:000027CC                 cmp     dword ptr [eax+18h], 8
.text$mn:000027D0                 jb      short loc_27E6
.text$mn:000027D2                 mov     ecx, [ebp+var_4]
.text$mn:000027D5                 mov     edx, [ecx+4]
.text$mn:000027D8                 push    edx
.text$mn:000027D9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000027DE                 add     esp, 4
.text$mn:000027E1                 mov     [ebp+var_8], eax
.text$mn:000027E4                 jmp     short loc_27EF
.text$mn:000027E6 ; ---------------------------------------------------------------------------
.text$mn:000027E6
.text$mn:000027E6 loc_27E6:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000027E6                 mov     eax, [ebp+var_4]
.text$mn:000027E9                 add     eax, 4
.text$mn:000027EC                 mov     [ebp+var_8], eax
.text$mn:000027EF
.text$mn:000027EF loc_27EF:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000027EF                 mov     eax, [ebp+var_8]
.text$mn:000027F2                 mov     esp, ebp
.text$mn:000027F4                 pop     ebp
.text$mn:000027F5                 retn
.text$mn:000027F5 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ endp
.text$mn:000027F5
.text$mn:000027F5 ; ---------------------------------------------------------------------------
.text$mn:000027F6                 align 4
.text$mn:000027F6 _text$mn        ends
.text$mn:000027F6
.text$mn:000027F8 ; ===========================================================================
.text$mn:000027F8
.text$mn:000027F8 ; Segment type: Pure code
.text$mn:000027F8 ; Segment permissions: Read/Execute
.text$mn:000027F8 _text$mn        segment para public 'CODE' use32
.text$mn:000027F8                 assume cs:_text$mn
.text$mn:000027F8                 ;org 27F8h
.text$mn:000027F8 ; COMDAT (pick any)
.text$mn:000027F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000027F8
.text$mn:000027F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000027F8
.text$mn:000027F8 ; Attributes: bp-based frame
.text$mn:000027F8
.text$mn:000027F8 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:000027F8                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:000027F8 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:000027F8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+7Dp
.text$mn:000027F8                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:000027F8
.text$mn:000027F8 var_8           = dword ptr -8
.text$mn:000027F8 var_4           = dword ptr -4
.text$mn:000027F8
.text$mn:000027F8                 push    ebp
.text$mn:000027F9                 mov     ebp, esp
.text$mn:000027FB                 sub     esp, 8
.text$mn:000027FE                 mov     [ebp+var_4], ecx
.text$mn:00002801                 mov     eax, [ebp+var_4]
.text$mn:00002804                 cmp     dword ptr [eax+18h], 8
.text$mn:00002808                 jb      short loc_281E
.text$mn:0000280A                 mov     ecx, [ebp+var_4]
.text$mn:0000280D                 mov     edx, [ecx+4]
.text$mn:00002810                 push    edx
.text$mn:00002811                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:00002816                 add     esp, 4
.text$mn:00002819                 mov     [ebp+var_8], eax
.text$mn:0000281C                 jmp     short loc_2827
.text$mn:0000281E ; ---------------------------------------------------------------------------
.text$mn:0000281E
.text$mn:0000281E loc_281E:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:0000281E                 mov     eax, [ebp+var_4]
.text$mn:00002821                 add     eax, 4
.text$mn:00002824                 mov     [ebp+var_8], eax
.text$mn:00002827
.text$mn:00002827 loc_2827:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:00002827                 mov     eax, [ebp+var_8]
.text$mn:0000282A                 mov     esp, ebp
.text$mn:0000282C                 pop     ebp
.text$mn:0000282D                 retn
.text$mn:0000282D ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:0000282D
.text$mn:0000282D ; ---------------------------------------------------------------------------
.text$mn:0000282E                 align 10h
.text$mn:0000282E _text$mn        ends
.text$mn:0000282E
.text$mn:00002830 ; ===========================================================================
.text$mn:00002830
.text$mn:00002830 ; Segment type: Pure code
.text$mn:00002830 ; Segment permissions: Read/Execute
.text$mn:00002830 _text$mn        segment para public 'CODE' use32
.text$mn:00002830                 assume cs:_text$mn
.text$mn:00002830                 ;org 2830h
.text$mn:00002830 ; COMDAT (pick any)
.text$mn:00002830                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002830
.text$mn:00002830 ; =============== S U B R O U T I N E =======================================
.text$mn:00002830
.text$mn:00002830 ; Attributes: bp-based frame
.text$mn:00002830
.text$mn:00002830 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:00002830                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:00002830 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:00002830                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:00002830                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:00002830
.text$mn:00002830 var_18          = byte ptr -18h
.text$mn:00002830 var_14          = dword ptr -14h
.text$mn:00002830 var_10          = dword ptr -10h
.text$mn:00002830 var_C           = dword ptr -0Ch
.text$mn:00002830 var_4           = dword ptr -4
.text$mn:00002830
.text$mn:00002830                 push    ebp
.text$mn:00002831                 mov     ebp, esp
.text$mn:00002833                 push    0FFFFFFFFh
.text$mn:00002835                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:0000283A                 mov     eax, large fs:0
.text$mn:00002840                 push    eax
.text$mn:00002841                 sub     esp, 0Ch
.text$mn:00002844                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002849                 xor     eax, ebp
.text$mn:0000284B                 push    eax
.text$mn:0000284C                 lea     eax, [ebp+var_C]
.text$mn:0000284F                 mov     large fs:0, eax
.text$mn:00002855                 mov     [ebp+var_14], ecx
.text$mn:00002858                 mov     eax, [ebp+var_14]
.text$mn:0000285B                 cmp     dword ptr [eax], 0
.text$mn:0000285E                 jz      short loc_28BB
.text$mn:00002860                 push    3               ; int
.text$mn:00002862                 lea     ecx, [ebp+var_18] ; this
.text$mn:00002865                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000286A                 mov     [ebp+var_4], 0
.text$mn:00002871                 mov     ecx, [ebp+var_14]
.text$mn:00002874                 mov     edx, [ecx]
.text$mn:00002876                 add     edx, 4
.text$mn:00002879                 mov     [ebp+var_10], edx
.text$mn:0000287C                 jmp     short loc_288B
.text$mn:0000287E ; ---------------------------------------------------------------------------
.text$mn:0000287E
.text$mn:0000287E loc_287E:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000287E                 mov     eax, [ebp+var_10]
.text$mn:00002881                 mov     ecx, [eax]
.text$mn:00002883                 mov     edx, [ebp+var_10]
.text$mn:00002886                 mov     eax, [ecx+4]
.text$mn:00002889                 mov     [edx], eax
.text$mn:0000288B
.text$mn:0000288B loc_288B:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:0000288B                 mov     ecx, [ebp+var_10]
.text$mn:0000288E                 cmp     dword ptr [ecx], 0
.text$mn:00002891                 jz      short loc_28A0
.text$mn:00002893                 mov     edx, [ebp+var_10]
.text$mn:00002896                 mov     eax, [edx]
.text$mn:00002898                 mov     dword ptr [eax], 0
.text$mn:0000289E                 jmp     short loc_287E
.text$mn:000028A0 ; ---------------------------------------------------------------------------
.text$mn:000028A0
.text$mn:000028A0 loc_28A0:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:000028A0                 mov     ecx, [ebp+var_14]
.text$mn:000028A3                 mov     edx, [ecx]
.text$mn:000028A5                 mov     dword ptr [edx+4], 0
.text$mn:000028AC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028B3                 lea     ecx, [ebp+var_18] ; this
.text$mn:000028B6                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000028BB
.text$mn:000028BB loc_28BB:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:000028BB                 mov     ecx, [ebp+var_C]
.text$mn:000028BE                 mov     large fs:0, ecx
.text$mn:000028C5                 pop     ecx
.text$mn:000028C6                 mov     esp, ebp
.text$mn:000028C8                 pop     ebp
.text$mn:000028C9                 retn
.text$mn:000028C9 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:000028C9
.text$mn:000028C9 ; ---------------------------------------------------------------------------
.text$mn:000028CA                 align 4
.text$mn:000028CA _text$mn        ends
.text$mn:000028CA
.text$x:000028CC ; ===========================================================================
.text$x:000028CC
.text$x:000028CC ; Segment type: Pure code
.text$x:000028CC ; Segment permissions: Read/Execute
.text$x:000028CC _text$x         segment para public 'CODE' use32
.text$x:000028CC                 assume cs:_text$x
.text$x:000028CC                 ;org 28CCh
.text$x:000028CC ; COMDAT (pick associative to section at 2830)
.text$x:000028CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028CC
.text$x:000028CC ; =============== S U B R O U T I N E =======================================
.text$x:000028CC
.text$x:000028CC
.text$x:000028CC __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:000028CC                                         ; DATA XREF: .xdata$x:00003758o
.text$x:000028CC                 lea     ecx, [ebp-18h]  ; this
.text$x:000028CF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000028CF __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:000028CF
.text$x:000028D4
.text$x:000028D4 ; =============== S U B R O U T I N E =======================================
.text$x:000028D4
.text$x:000028D4
.text$x:000028D4 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:000028D4                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:000028D4
.text$x:000028D4 arg_4           = dword ptr  8
.text$x:000028D4
.text$x:000028D4                 mov     edx, [esp+arg_4]
.text$x:000028D8                 lea     eax, [edx+0Ch]
.text$x:000028DB                 mov     ecx, [edx-10h]
.text$x:000028DE                 xor     ecx, eax
.text$x:000028E0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000028E5                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:000028EA                 jmp     ___CxxFrameHandler3
.text$x:000028EA __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:000028EA
.text$x:000028EA ; ---------------------------------------------------------------------------
.text$x:000028EF                 align 10h
.text$x:000028EF _text$x         ends
.text$x:000028EF
.text$mn:000028F0 ; ===========================================================================
.text$mn:000028F0
.text$mn:000028F0 ; Segment type: Pure code
.text$mn:000028F0 ; Segment permissions: Read/Execute
.text$mn:000028F0 _text$mn        segment para public 'CODE' use32
.text$mn:000028F0                 assume cs:_text$mn
.text$mn:000028F0                 ;org 28F0h
.text$mn:000028F0 ; COMDAT (pick any)
.text$mn:000028F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000028F0
.text$mn:000028F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000028F0
.text$mn:000028F0 ; Attributes: bp-based frame
.text$mn:000028F0
.text$mn:000028F0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:000028F0                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:000028F0 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:000028F0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:000028F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:000028F0
.text$mn:000028F0 var_C           = dword ptr -0Ch
.text$mn:000028F0 var_8           = dword ptr -8
.text$mn:000028F0 var_2           = byte ptr -2
.text$mn:000028F0 var_1           = byte ptr -1
.text$mn:000028F0 arg_0           = byte ptr  8
.text$mn:000028F0 Size            = dword ptr  0Ch
.text$mn:000028F0
.text$mn:000028F0                 push    ebp
.text$mn:000028F1                 mov     ebp, esp
.text$mn:000028F3                 sub     esp, 0Ch
.text$mn:000028F6                 mov     [ebp+var_8], ecx
.text$mn:000028F9                 movzx   eax, [ebp+arg_0]
.text$mn:000028FD                 test    eax, eax
.text$mn:000028FF                 jnz     short loc_2903
.text$mn:00002901                 jmp     short loc_2976
.text$mn:00002903 ; ---------------------------------------------------------------------------
.text$mn:00002903
.text$mn:00002903 loc_2903:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00002903                 mov     ecx, [ebp+var_8]
.text$mn:00002906                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000290A                 jb      short loc_2976
.text$mn:0000290C                 mov     edx, [ebp+var_8]
.text$mn:0000290F                 mov     eax, [edx+4]
.text$mn:00002912                 mov     [ebp+var_C], eax
.text$mn:00002915                 mov     ecx, [ebp+var_8]
.text$mn:00002918                 add     ecx, 4
.text$mn:0000291B                 push    ecx
.text$mn:0000291C                 lea     edx, [ebp+var_1]
.text$mn:0000291F                 push    edx
.text$mn:00002920                 mov     ecx, [ebp+var_8]
.text$mn:00002923                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002928                 mov     ecx, eax
.text$mn:0000292A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000292F                 cmp     [ebp+Size], 0
.text$mn:00002933                 jbe     short loc_2955
.text$mn:00002935                 mov     eax, [ebp+Size]
.text$mn:00002938                 push    eax             ; Size
.text$mn:00002939                 mov     ecx, [ebp+var_C]
.text$mn:0000293C                 push    ecx
.text$mn:0000293D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002942                 add     esp, 4
.text$mn:00002945                 push    eax             ; Src
.text$mn:00002946                 mov     edx, [ebp+var_8]
.text$mn:00002949                 add     edx, 4
.text$mn:0000294C                 push    edx             ; Dst
.text$mn:0000294D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002952                 add     esp, 0Ch
.text$mn:00002955
.text$mn:00002955 loc_2955:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00002955                 mov     eax, [ebp+var_8]
.text$mn:00002958                 mov     ecx, [eax+18h]
.text$mn:0000295B                 add     ecx, 1
.text$mn:0000295E                 push    ecx             ; int
.text$mn:0000295F                 mov     edx, [ebp+var_C]
.text$mn:00002962                 push    edx             ; void *
.text$mn:00002963                 lea     eax, [ebp+var_2]
.text$mn:00002966                 push    eax
.text$mn:00002967                 mov     ecx, [ebp+var_8]
.text$mn:0000296A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000296F                 mov     ecx, eax
.text$mn:00002971                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00002976
.text$mn:00002976 loc_2976:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00002976                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00002976                 mov     ecx, [ebp+var_8]
.text$mn:00002979                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00002980                 mov     edx, [ebp+Size]
.text$mn:00002983                 push    edx
.text$mn:00002984                 mov     ecx, [ebp+var_8]
.text$mn:00002987                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000298C                 mov     esp, ebp
.text$mn:0000298E                 pop     ebp
.text$mn:0000298F                 retn    8
.text$mn:0000298F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000298F
.text$mn:0000298F ; ---------------------------------------------------------------------------
.text$mn:00002992                 align 4
.text$mn:00002992 _text$mn        ends
.text$mn:00002992
.text$mn:00002994 ; ===========================================================================
.text$mn:00002994
.text$mn:00002994 ; Segment type: Pure code
.text$mn:00002994 ; Segment permissions: Read/Execute
.text$mn:00002994 _text$mn        segment para public 'CODE' use32
.text$mn:00002994                 assume cs:_text$mn
.text$mn:00002994                 ;org 2994h
.text$mn:00002994 ; COMDAT (pick any)
.text$mn:00002994                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002994
.text$mn:00002994 ; =============== S U B R O U T I N E =======================================
.text$mn:00002994
.text$mn:00002994 ; Attributes: bp-based frame
.text$mn:00002994
.text$mn:00002994 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy(bool, unsigned int)
.text$mn:00002994                 public ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z
.text$mn:00002994 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z proc near
.text$mn:00002994                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+47p
.text$mn:00002994                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(void)+34p ...
.text$mn:00002994
.text$mn:00002994 var_C           = dword ptr -0Ch
.text$mn:00002994 var_8           = dword ptr -8
.text$mn:00002994 var_2           = byte ptr -2
.text$mn:00002994 var_1           = byte ptr -1
.text$mn:00002994 arg_0           = byte ptr  8
.text$mn:00002994 arg_4           = dword ptr  0Ch
.text$mn:00002994
.text$mn:00002994                 push    ebp
.text$mn:00002995                 mov     ebp, esp
.text$mn:00002997                 sub     esp, 0Ch
.text$mn:0000299A                 mov     [ebp+var_8], ecx
.text$mn:0000299D                 movzx   eax, [ebp+arg_0]
.text$mn:000029A1                 test    eax, eax
.text$mn:000029A3                 jnz     short loc_29A7
.text$mn:000029A5                 jmp     short loc_2A1A
.text$mn:000029A7 ; ---------------------------------------------------------------------------
.text$mn:000029A7
.text$mn:000029A7 loc_29A7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+Fj
.text$mn:000029A7                 mov     ecx, [ebp+var_8]
.text$mn:000029AA                 cmp     dword ptr [ecx+18h], 8
.text$mn:000029AE                 jb      short loc_2A1A
.text$mn:000029B0                 mov     edx, [ebp+var_8]
.text$mn:000029B3                 mov     eax, [edx+4]
.text$mn:000029B6                 mov     [ebp+var_C], eax
.text$mn:000029B9                 mov     ecx, [ebp+var_8]
.text$mn:000029BC                 add     ecx, 4
.text$mn:000029BF                 push    ecx
.text$mn:000029C0                 lea     edx, [ebp+var_1]
.text$mn:000029C3                 push    edx
.text$mn:000029C4                 mov     ecx, [ebp+var_8]
.text$mn:000029C7                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:000029CC                 mov     ecx, eax
.text$mn:000029CE                 call    ??$destroy@PA_W@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPAPA_W@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::destroy<wchar_t *>(wchar_t * *)
.text$mn:000029D3                 cmp     [ebp+arg_4], 0
.text$mn:000029D7                 jbe     short loc_29F9
.text$mn:000029D9                 mov     eax, [ebp+arg_4]
.text$mn:000029DC                 push    eax             ; int
.text$mn:000029DD                 mov     ecx, [ebp+var_C]
.text$mn:000029E0                 push    ecx
.text$mn:000029E1                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000029E6                 add     esp, 4
.text$mn:000029E9                 push    eax             ; Src
.text$mn:000029EA                 mov     edx, [ebp+var_8]
.text$mn:000029ED                 add     edx, 4
.text$mn:000029F0                 push    edx             ; Dst
.text$mn:000029F1                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:000029F6                 add     esp, 0Ch
.text$mn:000029F9
.text$mn:000029F9 loc_29F9:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+43j
.text$mn:000029F9                 mov     eax, [ebp+var_8]
.text$mn:000029FC                 mov     ecx, [eax+18h]
.text$mn:000029FF                 add     ecx, 1
.text$mn:00002A02                 push    ecx             ; int
.text$mn:00002A03                 mov     edx, [ebp+var_C]
.text$mn:00002A06                 push    edx             ; void *
.text$mn:00002A07                 lea     eax, [ebp+var_2]
.text$mn:00002A0A                 push    eax
.text$mn:00002A0B                 mov     ecx, [ebp+var_8]
.text$mn:00002A0E                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00002A13                 mov     ecx, eax
.text$mn:00002A15                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z ; std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)
.text$mn:00002A1A
.text$mn:00002A1A loc_2A1A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+11j
.text$mn:00002A1A                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+1Aj
.text$mn:00002A1A                 mov     ecx, [ebp+var_8]
.text$mn:00002A1D                 mov     dword ptr [ecx+18h], 7
.text$mn:00002A24                 mov     edx, [ebp+arg_4]
.text$mn:00002A27                 push    edx
.text$mn:00002A28                 mov     ecx, [ebp+var_8]
.text$mn:00002A2B                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002A30                 mov     esp, ebp
.text$mn:00002A32                 pop     ebp
.text$mn:00002A33                 retn    8
.text$mn:00002A33 ?_Tidy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEX_NI@Z endp
.text$mn:00002A33
.text$mn:00002A33 ; ---------------------------------------------------------------------------
.text$mn:00002A36                 align 4
.text$mn:00002A36 _text$mn        ends
.text$mn:00002A36
.text$mn:00002A38 ; ===========================================================================
.text$mn:00002A38
.text$mn:00002A38 ; Segment type: Pure code
.text$mn:00002A38 ; Segment permissions: Read/Execute
.text$mn:00002A38 _text$mn        segment para public 'CODE' use32
.text$mn:00002A38                 assume cs:_text$mn
.text$mn:00002A38                 ;org 2A38h
.text$mn:00002A38 ; COMDAT (pick any)
.text$mn:00002A38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A38
.text$mn:00002A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A38
.text$mn:00002A38 ; Attributes: bp-based frame
.text$mn:00002A38
.text$mn:00002A38 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00002A38                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002A38 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002A38                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00002A38
.text$mn:00002A38 var_4           = dword ptr -4
.text$mn:00002A38
.text$mn:00002A38                 push    ebp
.text$mn:00002A39                 mov     ebp, esp
.text$mn:00002A3B                 push    ecx
.text$mn:00002A3C                 mov     [ebp+var_4], ecx
.text$mn:00002A3F                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00002A44                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00002A49                 mov     esp, ebp
.text$mn:00002A4B                 pop     ebp
.text$mn:00002A4C                 retn
.text$mn:00002A4C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002A4C
.text$mn:00002A4C ; ---------------------------------------------------------------------------
.text$mn:00002A4D                 align 10h
.text$mn:00002A4D _text$mn        ends
.text$mn:00002A4D
.text$mn:00002A50 ; ===========================================================================
.text$mn:00002A50
.text$mn:00002A50 ; Segment type: Pure code
.text$mn:00002A50 ; Segment permissions: Read/Execute
.text$mn:00002A50 _text$mn        segment para public 'CODE' use32
.text$mn:00002A50                 assume cs:_text$mn
.text$mn:00002A50                 ;org 2A50h
.text$mn:00002A50 ; COMDAT (pick any)
.text$mn:00002A50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A50
.text$mn:00002A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A50
.text$mn:00002A50 ; Attributes: bp-based frame
.text$mn:00002A50
.text$mn:00002A50 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xlen(void)const
.text$mn:00002A50                 public ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00002A50 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00002A50                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)+19p
.text$mn:00002A50
.text$mn:00002A50 var_4           = dword ptr -4
.text$mn:00002A50
.text$mn:00002A50                 push    ebp
.text$mn:00002A51                 mov     ebp, esp
.text$mn:00002A53                 push    ecx
.text$mn:00002A54                 mov     [ebp+var_4], ecx
.text$mn:00002A57                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00002A5C                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00002A61                 mov     esp, ebp
.text$mn:00002A63                 pop     ebp
.text$mn:00002A64                 retn
.text$mn:00002A64 ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00002A64
.text$mn:00002A64 ; ---------------------------------------------------------------------------
.text$mn:00002A65                 align 4
.text$mn:00002A65 _text$mn        ends
.text$mn:00002A65
.text$mn:00002A68 ; ===========================================================================
.text$mn:00002A68
.text$mn:00002A68 ; Segment type: Pure code
.text$mn:00002A68 ; Segment permissions: Read/Execute
.text$mn:00002A68 _text$mn        segment para public 'CODE' use32
.text$mn:00002A68                 assume cs:_text$mn
.text$mn:00002A68                 ;org 2A68h
.text$mn:00002A68 ; COMDAT (pick any)
.text$mn:00002A68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A68
.text$mn:00002A68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A68
.text$mn:00002A68 ; Attributes: bp-based frame
.text$mn:00002A68
.text$mn:00002A68 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00002A68                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002A68 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002A68                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00002A68                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00002A68
.text$mn:00002A68 var_4           = dword ptr -4
.text$mn:00002A68
.text$mn:00002A68                 push    ebp
.text$mn:00002A69                 mov     ebp, esp
.text$mn:00002A6B                 push    ecx
.text$mn:00002A6C                 mov     [ebp+var_4], ecx
.text$mn:00002A6F                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00002A74                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002A79                 mov     esp, ebp
.text$mn:00002A7B                 pop     ebp
.text$mn:00002A7C                 retn
.text$mn:00002A7C ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002A7C
.text$mn:00002A7C ; ---------------------------------------------------------------------------
.text$mn:00002A7D                 align 10h
.text$mn:00002A7D _text$mn        ends
.text$mn:00002A7D
.text$mn:00002A80 ; ===========================================================================
.text$mn:00002A80
.text$mn:00002A80 ; Segment type: Pure code
.text$mn:00002A80 ; Segment permissions: Read/Execute
.text$mn:00002A80 _text$mn        segment para public 'CODE' use32
.text$mn:00002A80                 assume cs:_text$mn
.text$mn:00002A80                 ;org 2A80h
.text$mn:00002A80 ; COMDAT (pick any)
.text$mn:00002A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A80
.text$mn:00002A80 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A80
.text$mn:00002A80 ; Attributes: bp-based frame
.text$mn:00002A80
.text$mn:00002A80 ; public: void __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Xran(void)const
.text$mn:00002A80                 public ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ
.text$mn:00002A80 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ proc near
.text$mn:00002A80                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+19p
.text$mn:00002A80                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+15p ...
.text$mn:00002A80
.text$mn:00002A80 var_4           = dword ptr -4
.text$mn:00002A80
.text$mn:00002A80                 push    ebp
.text$mn:00002A81                 mov     ebp, esp
.text$mn:00002A83                 push    ecx
.text$mn:00002A84                 mov     [ebp+var_4], ecx
.text$mn:00002A87                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00002A8C                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002A91                 mov     esp, ebp
.text$mn:00002A93                 pop     ebp
.text$mn:00002A94                 retn
.text$mn:00002A94 ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ endp
.text$mn:00002A94
.text$mn:00002A94 ; ---------------------------------------------------------------------------
.text$mn:00002A95                 align 4
.text$mn:00002A95 _text$mn        ends
.text$mn:00002A95
.text$mn:00002A98 ; ===========================================================================
.text$mn:00002A98
.text$mn:00002A98 ; Segment type: Pure code
.text$mn:00002A98 ; Segment permissions: Read/Execute
.text$mn:00002A98 _text$mn        segment para public 'CODE' use32
.text$mn:00002A98                 assume cs:_text$mn
.text$mn:00002A98                 ;org 2A98h
.text$mn:00002A98 ; COMDAT (pick any)
.text$mn:00002A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A98
.text$mn:00002A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A98
.text$mn:00002A98 ; Attributes: bp-based frame
.text$mn:00002A98
.text$mn:00002A98 ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:00002A98                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:00002A98 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:00002A98                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:00002A98                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:00002A98
.text$mn:00002A98 var_4           = dword ptr -4
.text$mn:00002A98 arg_0           = dword ptr  8
.text$mn:00002A98
.text$mn:00002A98                 push    ebp
.text$mn:00002A99                 mov     ebp, esp
.text$mn:00002A9B                 push    ecx
.text$mn:00002A9C                 mov     [ebp+var_4], ecx
.text$mn:00002A9F                 mov     eax, [ebp+arg_0]
.text$mn:00002AA2                 push    eax
.text$mn:00002AA3                 mov     ecx, [ebp+var_4]
.text$mn:00002AA6                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:00002AAB                 mov     esp, ebp
.text$mn:00002AAD                 pop     ebp
.text$mn:00002AAE                 retn    4
.text$mn:00002AAE ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00002AAE
.text$mn:00002AAE ; ---------------------------------------------------------------------------
.text$mn:00002AB1                 align 4
.text$mn:00002AB1 _text$mn        ends
.text$mn:00002AB1
.text$mn:00002AB4 ; ===========================================================================
.text$mn:00002AB4
.text$mn:00002AB4 ; Segment type: Pure code
.text$mn:00002AB4 ; Segment permissions: Read/Execute
.text$mn:00002AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB4                 assume cs:_text$mn
.text$mn:00002AB4                 ;org 2AB4h
.text$mn:00002AB4 ; COMDAT (pick any)
.text$mn:00002AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AB4
.text$mn:00002AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB4
.text$mn:00002AB4 ; Attributes: bp-based frame
.text$mn:00002AB4
.text$mn:00002AB4 ; public: wchar_t * __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::allocate(unsigned int)
.text$mn:00002AB4                 public ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z
.text$mn:00002AB4 ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z proc near
.text$mn:00002AB4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+BBp
.text$mn:00002AB4                                         ; __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0+22p
.text$mn:00002AB4
.text$mn:00002AB4 var_4           = dword ptr -4
.text$mn:00002AB4 arg_0           = dword ptr  8
.text$mn:00002AB4
.text$mn:00002AB4                 push    ebp
.text$mn:00002AB5                 mov     ebp, esp
.text$mn:00002AB7                 push    ecx
.text$mn:00002AB8                 mov     [ebp+var_4], ecx
.text$mn:00002ABB                 mov     eax, [ebp+arg_0]
.text$mn:00002ABE                 push    eax
.text$mn:00002ABF                 mov     ecx, [ebp+var_4]
.text$mn:00002AC2                 call    ?allocate@?$allocator@_W@std@@QAEPA_WI@Z ; std::allocator<wchar_t>::allocate(uint)
.text$mn:00002AC7                 mov     esp, ebp
.text$mn:00002AC9                 pop     ebp
.text$mn:00002ACA                 retn    4
.text$mn:00002ACA ?allocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEPA_WI@Z endp
.text$mn:00002ACA
.text$mn:00002ACA ; ---------------------------------------------------------------------------
.text$mn:00002ACD                 align 10h
.text$mn:00002ACD _text$mn        ends
.text$mn:00002ACD
.text$mn:00002AD0 ; ===========================================================================
.text$mn:00002AD0
.text$mn:00002AD0 ; Segment type: Pure code
.text$mn:00002AD0 ; Segment permissions: Read/Execute
.text$mn:00002AD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AD0                 assume cs:_text$mn
.text$mn:00002AD0                 ;org 2AD0h
.text$mn:00002AD0 ; COMDAT (pick any)
.text$mn:00002AD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AD0
.text$mn:00002AD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AD0
.text$mn:00002AD0 ; Attributes: bp-based frame
.text$mn:00002AD0
.text$mn:00002AD0 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00002AD0                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00002AD0 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00002AD0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00002AD0
.text$mn:00002AD0 var_4           = dword ptr -4
.text$mn:00002AD0 arg_0           = dword ptr  8
.text$mn:00002AD0
.text$mn:00002AD0                 push    ebp
.text$mn:00002AD1                 mov     ebp, esp
.text$mn:00002AD3                 push    ecx
.text$mn:00002AD4                 mov     [ebp+var_4], ecx
.text$mn:00002AD7                 push    0
.text$mn:00002AD9                 mov     eax, [ebp+arg_0]
.text$mn:00002ADC                 push    eax
.text$mn:00002ADD                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:00002AE2                 add     esp, 8
.text$mn:00002AE5                 mov     esp, ebp
.text$mn:00002AE7                 pop     ebp
.text$mn:00002AE8                 retn    4
.text$mn:00002AE8 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:00002AE8
.text$mn:00002AE8 ; ---------------------------------------------------------------------------
.text$mn:00002AEB                 align 4
.text$mn:00002AEB _text$mn        ends
.text$mn:00002AEB
.text$mn:00002AEC ; ===========================================================================
.text$mn:00002AEC
.text$mn:00002AEC ; Segment type: Pure code
.text$mn:00002AEC ; Segment permissions: Read/Execute
.text$mn:00002AEC _text$mn        segment para public 'CODE' use32
.text$mn:00002AEC                 assume cs:_text$mn
.text$mn:00002AEC                 ;org 2AECh
.text$mn:00002AEC ; COMDAT (pick any)
.text$mn:00002AEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AEC
.text$mn:00002AEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002AEC
.text$mn:00002AEC ; Attributes: bp-based frame
.text$mn:00002AEC
.text$mn:00002AEC ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00002AEC                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00002AEC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00002AEC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00002AEC                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Alloc_proxy(void)+16p
.text$mn:00002AEC
.text$mn:00002AEC var_4           = dword ptr -4
.text$mn:00002AEC arg_0           = dword ptr  8
.text$mn:00002AEC
.text$mn:00002AEC                 push    ebp
.text$mn:00002AED                 mov     ebp, esp
.text$mn:00002AEF                 push    ecx
.text$mn:00002AF0                 mov     [ebp+var_4], ecx
.text$mn:00002AF3                 push    0
.text$mn:00002AF5                 mov     eax, [ebp+arg_0]
.text$mn:00002AF8                 push    eax
.text$mn:00002AF9                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:00002AFE                 add     esp, 8
.text$mn:00002B01                 mov     esp, ebp
.text$mn:00002B03                 pop     ebp
.text$mn:00002B04                 retn    4
.text$mn:00002B04 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00002B04
.text$mn:00002B04 ; ---------------------------------------------------------------------------
.text$mn:00002B07                 align 4
.text$mn:00002B07 _text$mn        ends
.text$mn:00002B07
.text$mn:00002B08 ; ===========================================================================
.text$mn:00002B08
.text$mn:00002B08 ; Segment type: Pure code
.text$mn:00002B08 ; Segment permissions: Read/Execute
.text$mn:00002B08 _text$mn        segment para public 'CODE' use32
.text$mn:00002B08                 assume cs:_text$mn
.text$mn:00002B08                 ;org 2B08h
.text$mn:00002B08 ; COMDAT (pick any)
.text$mn:00002B08                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B08
.text$mn:00002B08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B08
.text$mn:00002B08 ; Attributes: bp-based frame
.text$mn:00002B08
.text$mn:00002B08 ; public: wchar_t * __thiscall std::allocator<wchar_t>::allocate(unsigned int)
.text$mn:00002B08                 public ?allocate@?$allocator@_W@std@@QAEPA_WI@Z
.text$mn:00002B08 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z proc near
.text$mn:00002B08                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::allocate(uint)+Ep
.text$mn:00002B08
.text$mn:00002B08 var_4           = dword ptr -4
.text$mn:00002B08 arg_0           = dword ptr  8
.text$mn:00002B08
.text$mn:00002B08                 push    ebp
.text$mn:00002B09                 mov     ebp, esp
.text$mn:00002B0B                 push    ecx
.text$mn:00002B0C                 mov     [ebp+var_4], ecx
.text$mn:00002B0F                 push    0
.text$mn:00002B11                 mov     eax, [ebp+arg_0]
.text$mn:00002B14                 push    eax
.text$mn:00002B15                 call    ??$_Allocate@_W@std@@YAPA_WIPA_W@Z ; std::_Allocate<wchar_t>(uint,wchar_t *)
.text$mn:00002B1A                 add     esp, 8
.text$mn:00002B1D                 mov     esp, ebp
.text$mn:00002B1F                 pop     ebp
.text$mn:00002B20                 retn    4
.text$mn:00002B20 ?allocate@?$allocator@_W@std@@QAEPA_WI@Z endp
.text$mn:00002B20
.text$mn:00002B20 ; ---------------------------------------------------------------------------
.text$mn:00002B23                 align 4
.text$mn:00002B23 _text$mn        ends
.text$mn:00002B23
.text$mn:00002B24 ; ===========================================================================
.text$mn:00002B24
.text$mn:00002B24 ; Segment type: Pure code
.text$mn:00002B24 ; Segment permissions: Read/Execute
.text$mn:00002B24 _text$mn        segment para public 'CODE' use32
.text$mn:00002B24                 assume cs:_text$mn
.text$mn:00002B24                 ;org 2B24h
.text$mn:00002B24 ; COMDAT (pick any)
.text$mn:00002B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B24
.text$mn:00002B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B24
.text$mn:00002B24 ; Attributes: bp-based frame
.text$mn:00002B24
.text$mn:00002B24 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00002B24                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002B24 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002B24                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00002B24
.text$mn:00002B24 Size            = dword ptr -8
.text$mn:00002B24 var_4           = dword ptr -4
.text$mn:00002B24 arg_0           = dword ptr  8
.text$mn:00002B24 arg_4           = dword ptr  0Ch
.text$mn:00002B24 arg_8           = dword ptr  10h
.text$mn:00002B24
.text$mn:00002B24                 push    ebp
.text$mn:00002B25                 mov     ebp, esp
.text$mn:00002B27                 sub     esp, 8
.text$mn:00002B2A                 mov     [ebp+var_4], ecx
.text$mn:00002B2D                 mov     ecx, [ebp+arg_0]
.text$mn:00002B30                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002B35                 cmp     eax, [ebp+arg_4]
.text$mn:00002B38                 jnb     short loc_2B42
.text$mn:00002B3A                 mov     ecx, [ebp+var_4]
.text$mn:00002B3D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002B42
.text$mn:00002B42 loc_2B42:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00002B42                 mov     ecx, [ebp+arg_0]
.text$mn:00002B45                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00002B4A                 sub     eax, [ebp+arg_4]
.text$mn:00002B4D                 mov     [ebp+Size], eax
.text$mn:00002B50                 mov     eax, [ebp+arg_8]
.text$mn:00002B53                 cmp     eax, [ebp+Size]
.text$mn:00002B56                 jnb     short loc_2B5E
.text$mn:00002B58                 mov     ecx, [ebp+arg_8]
.text$mn:00002B5B                 mov     [ebp+Size], ecx
.text$mn:00002B5E
.text$mn:00002B5E loc_2B5E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:00002B5E                 mov     edx, [ebp+var_4]
.text$mn:00002B61                 cmp     edx, [ebp+arg_0]
.text$mn:00002B64                 jnz     short loc_2B85
.text$mn:00002B66                 mov     eax, [ebp+arg_4]
.text$mn:00002B69                 add     eax, [ebp+Size]
.text$mn:00002B6C                 push    eax
.text$mn:00002B6D                 mov     ecx, [ebp+var_4]
.text$mn:00002B70                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00002B75                 mov     ecx, [ebp+arg_4]
.text$mn:00002B78                 push    ecx
.text$mn:00002B79                 push    0
.text$mn:00002B7B                 mov     ecx, [ebp+var_4]
.text$mn:00002B7E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00002B83                 jmp     short loc_2BC7
.text$mn:00002B85 ; ---------------------------------------------------------------------------
.text$mn:00002B85
.text$mn:00002B85 loc_2B85:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00002B85                 push    0
.text$mn:00002B87                 mov     edx, [ebp+Size]
.text$mn:00002B8A                 push    edx
.text$mn:00002B8B                 mov     ecx, [ebp+var_4]
.text$mn:00002B8E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002B93                 movzx   eax, al
.text$mn:00002B96                 test    eax, eax
.text$mn:00002B98                 jz      short loc_2BC7
.text$mn:00002B9A                 mov     ecx, [ebp+Size]
.text$mn:00002B9D                 push    ecx             ; Size
.text$mn:00002B9E                 mov     ecx, [ebp+arg_0]
.text$mn:00002BA1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002BA6                 add     eax, [ebp+arg_4]
.text$mn:00002BA9                 push    eax             ; Src
.text$mn:00002BAA                 mov     ecx, [ebp+var_4]
.text$mn:00002BAD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002BB2                 push    eax             ; Dst
.text$mn:00002BB3                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002BB8                 add     esp, 0Ch
.text$mn:00002BBB                 mov     edx, [ebp+Size]
.text$mn:00002BBE                 push    edx
.text$mn:00002BBF                 mov     ecx, [ebp+var_4]
.text$mn:00002BC2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002BC7
.text$mn:00002BC7 loc_2BC7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00002BC7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00002BC7                 mov     eax, [ebp+var_4]
.text$mn:00002BCA                 mov     esp, ebp
.text$mn:00002BCC                 pop     ebp
.text$mn:00002BCD                 retn    0Ch
.text$mn:00002BCD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00002BCD
.text$mn:00002BCD _text$mn        ends
.text$mn:00002BCD
.text$mn:00002BD0 ; ===========================================================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Segment type: Pure code
.text$mn:00002BD0 ; Segment permissions: Read/Execute
.text$mn:00002BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002BD0                 assume cs:_text$mn
.text$mn:00002BD0                 ;org 2BD0h
.text$mn:00002BD0 ; COMDAT (pick any)
.text$mn:00002BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BD0
.text$mn:00002BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BD0
.text$mn:00002BD0 ; Attributes: bp-based frame
.text$mn:00002BD0
.text$mn:00002BD0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:00002BD0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:00002BD0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:00002BD0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:00002BD0
.text$mn:00002BD0 var_4           = dword ptr -4
.text$mn:00002BD0 Str             = dword ptr  8
.text$mn:00002BD0
.text$mn:00002BD0                 push    ebp
.text$mn:00002BD1                 mov     ebp, esp
.text$mn:00002BD3                 push    ecx
.text$mn:00002BD4                 mov     [ebp+var_4], ecx
.text$mn:00002BD7                 push    490h            ; unsigned int
.text$mn:00002BDC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002BE1                 mov     eax, [ebp+Str]
.text$mn:00002BE4                 push    eax             ; int
.text$mn:00002BE5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002BEA                 add     esp, 0Ch
.text$mn:00002BED                 mov     ecx, [ebp+Str]
.text$mn:00002BF0                 push    ecx             ; Str
.text$mn:00002BF1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002BF6                 add     esp, 4
.text$mn:00002BF9                 push    eax             ; Size
.text$mn:00002BFA                 mov     edx, [ebp+Str]
.text$mn:00002BFD                 push    edx             ; Src
.text$mn:00002BFE                 mov     ecx, [ebp+var_4]
.text$mn:00002C01                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00002C06                 mov     esp, ebp
.text$mn:00002C08                 pop     ebp
.text$mn:00002C09                 retn    4
.text$mn:00002C09 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00002C09
.text$mn:00002C09 _text$mn        ends
.text$mn:00002C09
.text$mn:00002C0C ; ===========================================================================
.text$mn:00002C0C
.text$mn:00002C0C ; Segment type: Pure code
.text$mn:00002C0C ; Segment permissions: Read/Execute
.text$mn:00002C0C _text$mn        segment para public 'CODE' use32
.text$mn:00002C0C                 assume cs:_text$mn
.text$mn:00002C0C                 ;org 2C0Ch
.text$mn:00002C0C ; COMDAT (pick any)
.text$mn:00002C0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002C0C
.text$mn:00002C0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002C0C
.text$mn:00002C0C ; Attributes: bp-based frame
.text$mn:00002C0C
.text$mn:00002C0C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:00002C0C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:00002C0C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:00002C0C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:00002C0C
.text$mn:00002C0C var_4           = dword ptr -4
.text$mn:00002C0C Src             = dword ptr  8
.text$mn:00002C0C Size            = dword ptr  0Ch
.text$mn:00002C0C
.text$mn:00002C0C                 push    ebp
.text$mn:00002C0D                 mov     ebp, esp
.text$mn:00002C0F                 push    ecx
.text$mn:00002C10                 mov     [ebp+var_4], ecx
.text$mn:00002C13                 cmp     [ebp+Size], 0
.text$mn:00002C17                 jz      short loc_2C2F
.text$mn:00002C19                 push    47Fh            ; unsigned int
.text$mn:00002C1E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002C23                 mov     eax, [ebp+Src]
.text$mn:00002C26                 push    eax             ; int
.text$mn:00002C27                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002C2C                 add     esp, 0Ch
.text$mn:00002C2F
.text$mn:00002C2F loc_2C2F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:00002C2F                 mov     ecx, [ebp+Src]
.text$mn:00002C32                 push    ecx
.text$mn:00002C33                 mov     ecx, [ebp+var_4]
.text$mn:00002C36                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:00002C3B                 movzx   edx, al
.text$mn:00002C3E                 test    edx, edx
.text$mn:00002C40                 jz      short loc_2C62
.text$mn:00002C42                 mov     eax, [ebp+Size]
.text$mn:00002C45                 push    eax
.text$mn:00002C46                 mov     ecx, [ebp+var_4]
.text$mn:00002C49                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002C4E                 mov     ecx, [ebp+Src]
.text$mn:00002C51                 sub     ecx, eax
.text$mn:00002C53                 push    ecx
.text$mn:00002C54                 mov     edx, [ebp+var_4]
.text$mn:00002C57                 push    edx
.text$mn:00002C58                 mov     ecx, [ebp+var_4]
.text$mn:00002C5B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00002C60                 jmp     short loc_2C9F
.text$mn:00002C62 ; ---------------------------------------------------------------------------
.text$mn:00002C62
.text$mn:00002C62 loc_2C62:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00002C62                 push    0
.text$mn:00002C64                 mov     eax, [ebp+Size]
.text$mn:00002C67                 push    eax
.text$mn:00002C68                 mov     ecx, [ebp+var_4]
.text$mn:00002C6B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00002C70                 movzx   ecx, al
.text$mn:00002C73                 test    ecx, ecx
.text$mn:00002C75                 jz      short loc_2C9C
.text$mn:00002C77                 mov     edx, [ebp+Size]
.text$mn:00002C7A                 push    edx             ; Size
.text$mn:00002C7B                 mov     eax, [ebp+Src]
.text$mn:00002C7E                 push    eax             ; Src
.text$mn:00002C7F                 mov     ecx, [ebp+var_4]
.text$mn:00002C82                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002C87                 push    eax             ; Dst
.text$mn:00002C88                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002C8D                 add     esp, 0Ch
.text$mn:00002C90                 mov     ecx, [ebp+Size]
.text$mn:00002C93                 push    ecx
.text$mn:00002C94                 mov     ecx, [ebp+var_4]
.text$mn:00002C97                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002C9C
.text$mn:00002C9C loc_2C9C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00002C9C                 mov     eax, [ebp+var_4]
.text$mn:00002C9F
.text$mn:00002C9F loc_2C9F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:00002C9F                 mov     esp, ebp
.text$mn:00002CA1                 pop     ebp
.text$mn:00002CA2                 retn    8
.text$mn:00002CA2 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:00002CA2
.text$mn:00002CA2 ; ---------------------------------------------------------------------------
.text$mn:00002CA5                 align 4
.text$mn:00002CA5 _text$mn        ends
.text$mn:00002CA5
.text$mn:00002CA8 ; ===========================================================================
.text$mn:00002CA8
.text$mn:00002CA8 ; Segment type: Pure code
.text$mn:00002CA8 ; Segment permissions: Read/Execute
.text$mn:00002CA8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CA8                 assume cs:_text$mn
.text$mn:00002CA8                 ;org 2CA8h
.text$mn:00002CA8 ; COMDAT (pick any)
.text$mn:00002CA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002CA8
.text$mn:00002CA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CA8
.text$mn:00002CA8 ; Attributes: bp-based frame
.text$mn:00002CA8
.text$mn:00002CA8 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::assign(class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> const &, unsigned int, unsigned int)
.text$mn:00002CA8                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00002CA8 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00002CA8                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+51p
.text$mn:00002CA8
.text$mn:00002CA8 var_8           = dword ptr -8
.text$mn:00002CA8 var_4           = dword ptr -4
.text$mn:00002CA8 arg_0           = dword ptr  8
.text$mn:00002CA8 arg_4           = dword ptr  0Ch
.text$mn:00002CA8 arg_8           = dword ptr  10h
.text$mn:00002CA8
.text$mn:00002CA8                 push    ebp
.text$mn:00002CA9                 mov     ebp, esp
.text$mn:00002CAB                 sub     esp, 8
.text$mn:00002CAE                 mov     [ebp+var_4], ecx
.text$mn:00002CB1                 mov     ecx, [ebp+arg_0]
.text$mn:00002CB4                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00002CB9                 cmp     eax, [ebp+arg_4]
.text$mn:00002CBC                 jnb     short loc_2CC6
.text$mn:00002CBE                 mov     ecx, [ebp+var_4]
.text$mn:00002CC1                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:00002CC6
.text$mn:00002CC6 loc_2CC6:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+14j
.text$mn:00002CC6                 mov     ecx, [ebp+arg_0]
.text$mn:00002CC9                 call    ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::size(void)
.text$mn:00002CCE                 sub     eax, [ebp+arg_4]
.text$mn:00002CD1                 mov     [ebp+var_8], eax
.text$mn:00002CD4                 mov     eax, [ebp+arg_8]
.text$mn:00002CD7                 cmp     eax, [ebp+var_8]
.text$mn:00002CDA                 jnb     short loc_2CE2
.text$mn:00002CDC                 mov     ecx, [ebp+arg_8]
.text$mn:00002CDF                 mov     [ebp+var_8], ecx
.text$mn:00002CE2
.text$mn:00002CE2 loc_2CE2:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+32j
.text$mn:00002CE2                 mov     edx, [ebp+var_4]
.text$mn:00002CE5                 cmp     edx, [ebp+arg_0]
.text$mn:00002CE8                 jnz     short loc_2D09
.text$mn:00002CEA                 mov     eax, [ebp+arg_4]
.text$mn:00002CED                 add     eax, [ebp+var_8]
.text$mn:00002CF0                 push    eax
.text$mn:00002CF1                 mov     ecx, [ebp+var_4]
.text$mn:00002CF4                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)
.text$mn:00002CF9                 mov     ecx, [ebp+arg_4]
.text$mn:00002CFC                 push    ecx
.text$mn:00002CFD                 push    0
.text$mn:00002CFF                 mov     ecx, [ebp+var_4]
.text$mn:00002D02                 call    ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)
.text$mn:00002D07                 jmp     short loc_2D4E
.text$mn:00002D09 ; ---------------------------------------------------------------------------
.text$mn:00002D09
.text$mn:00002D09 loc_2D09:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+40j
.text$mn:00002D09                 push    0
.text$mn:00002D0B                 mov     edx, [ebp+var_8]
.text$mn:00002D0E                 push    edx
.text$mn:00002D0F                 mov     ecx, [ebp+var_4]
.text$mn:00002D12                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00002D17                 movzx   eax, al
.text$mn:00002D1A                 test    eax, eax
.text$mn:00002D1C                 jz      short loc_2D4E
.text$mn:00002D1E                 mov     ecx, [ebp+var_8]
.text$mn:00002D21                 push    ecx             ; int
.text$mn:00002D22                 mov     ecx, [ebp+arg_0]
.text$mn:00002D25                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002D2A                 mov     edx, [ebp+arg_4]
.text$mn:00002D2D                 lea     eax, [eax+edx*2]
.text$mn:00002D30                 push    eax             ; Src
.text$mn:00002D31                 mov     ecx, [ebp+var_4]
.text$mn:00002D34                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002D39                 push    eax             ; Dst
.text$mn:00002D3A                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002D3F                 add     esp, 0Ch
.text$mn:00002D42                 mov     ecx, [ebp+var_8]
.text$mn:00002D45                 push    ecx
.text$mn:00002D46                 mov     ecx, [ebp+var_4]
.text$mn:00002D49                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002D4E
.text$mn:00002D4E loc_2D4E:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Fj
.text$mn:00002D4E                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+74j
.text$mn:00002D4E                 mov     eax, [ebp+var_4]
.text$mn:00002D51                 mov     esp, ebp
.text$mn:00002D53                 pop     ebp
.text$mn:00002D54                 retn    0Ch
.text$mn:00002D54 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00002D54
.text$mn:00002D54 ; ---------------------------------------------------------------------------
.text$mn:00002D57                 align 4
.text$mn:00002D57 _text$mn        ends
.text$mn:00002D57
.text$mn:00002D58 ; ===========================================================================
.text$mn:00002D58
.text$mn:00002D58 ; Segment type: Pure code
.text$mn:00002D58 ; Segment permissions: Read/Execute
.text$mn:00002D58 _text$mn        segment para public 'CODE' use32
.text$mn:00002D58                 assume cs:_text$mn
.text$mn:00002D58                 ;org 2D58h
.text$mn:00002D58 ; COMDAT (pick any)
.text$mn:00002D58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D58
.text$mn:00002D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D58
.text$mn:00002D58 ; Attributes: bp-based frame
.text$mn:00002D58
.text$mn:00002D58 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t *Str)
.text$mn:00002D58                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z
.text$mn:00002D58 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z proc near
.text$mn:00002D58                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>(wchar_t const *)+53p
.text$mn:00002D58
.text$mn:00002D58 var_4           = dword ptr -4
.text$mn:00002D58 Str             = dword ptr  8
.text$mn:00002D58
.text$mn:00002D58                 push    ebp
.text$mn:00002D59                 mov     ebp, esp
.text$mn:00002D5B                 push    ecx
.text$mn:00002D5C                 mov     [ebp+var_4], ecx
.text$mn:00002D5F                 push    490h            ; unsigned int
.text$mn:00002D64                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002D69                 mov     eax, [ebp+Str]
.text$mn:00002D6C                 push    eax             ; int
.text$mn:00002D6D                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00002D72                 add     esp, 0Ch
.text$mn:00002D75                 mov     ecx, [ebp+Str]
.text$mn:00002D78                 push    ecx             ; Str
.text$mn:00002D79                 call    ?length@?$char_traits@_W@std@@SAIPB_W@Z ; std::char_traits<wchar_t>::length(wchar_t const *)
.text$mn:00002D7E                 add     esp, 4
.text$mn:00002D81                 push    eax             ; int
.text$mn:00002D82                 mov     edx, [ebp+Str]
.text$mn:00002D85                 push    edx             ; Src
.text$mn:00002D86                 mov     ecx, [ebp+var_4]
.text$mn:00002D89                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)
.text$mn:00002D8E                 mov     esp, ebp
.text$mn:00002D90                 pop     ebp
.text$mn:00002D91                 retn    4
.text$mn:00002D91 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_W@Z endp
.text$mn:00002D91
.text$mn:00002D91 _text$mn        ends
.text$mn:00002D91
.text$mn:00002D94 ; ===========================================================================
.text$mn:00002D94
.text$mn:00002D94 ; Segment type: Pure code
.text$mn:00002D94 ; Segment permissions: Read/Execute
.text$mn:00002D94 _text$mn        segment para public 'CODE' use32
.text$mn:00002D94                 assume cs:_text$mn
.text$mn:00002D94                 ;org 2D94h
.text$mn:00002D94 ; COMDAT (pick any)
.text$mn:00002D94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D94
.text$mn:00002D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D94
.text$mn:00002D94 ; Attributes: bp-based frame
.text$mn:00002D94
.text$mn:00002D94 ; int __stdcall std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(void *Src, int)
.text$mn:00002D94                 public ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z
.text$mn:00002D94 ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z proc near
.text$mn:00002D94                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+31p
.text$mn:00002D94
.text$mn:00002D94 var_4           = dword ptr -4
.text$mn:00002D94 Src             = dword ptr  8
.text$mn:00002D94 arg_4           = dword ptr  0Ch
.text$mn:00002D94
.text$mn:00002D94                 push    ebp
.text$mn:00002D95                 mov     ebp, esp
.text$mn:00002D97                 push    ecx
.text$mn:00002D98                 mov     [ebp+var_4], ecx
.text$mn:00002D9B                 cmp     [ebp+arg_4], 0
.text$mn:00002D9F                 jz      short loc_2DB7
.text$mn:00002DA1                 push    47Fh            ; unsigned int
.text$mn:00002DA6                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002DAB                 mov     eax, [ebp+Src]
.text$mn:00002DAE                 push    eax             ; int
.text$mn:00002DAF                 call    ??$_Debug_pointer@_W@std@@YAXPB_W0I@Z ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)
.text$mn:00002DB4                 add     esp, 0Ch
.text$mn:00002DB7
.text$mn:00002DB7 loc_2DB7:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+Bj
.text$mn:00002DB7                 mov     ecx, [ebp+Src]
.text$mn:00002DBA                 push    ecx
.text$mn:00002DBB                 mov     ecx, [ebp+var_4]
.text$mn:00002DBE                 call    ?_Inside@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NPB_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Inside(wchar_t const *)
.text$mn:00002DC3                 movzx   edx, al
.text$mn:00002DC6                 test    edx, edx
.text$mn:00002DC8                 jz      short loc_2DEC
.text$mn:00002DCA                 mov     eax, [ebp+arg_4]
.text$mn:00002DCD                 push    eax
.text$mn:00002DCE                 mov     ecx, [ebp+var_4]
.text$mn:00002DD1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002DD6                 mov     ecx, [ebp+Src]
.text$mn:00002DD9                 sub     ecx, eax
.text$mn:00002DDB                 sar     ecx, 1
.text$mn:00002DDD                 push    ecx
.text$mn:00002DDE                 mov     edx, [ebp+var_4]
.text$mn:00002DE1                 push    edx
.text$mn:00002DE2                 mov     ecx, [ebp+var_4]
.text$mn:00002DE5                 call    ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)
.text$mn:00002DEA                 jmp     short loc_2E29
.text$mn:00002DEC ; ---------------------------------------------------------------------------
.text$mn:00002DEC
.text$mn:00002DEC loc_2DEC:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+34j
.text$mn:00002DEC                 push    0
.text$mn:00002DEE                 mov     eax, [ebp+arg_4]
.text$mn:00002DF1                 push    eax
.text$mn:00002DF2                 mov     ecx, [ebp+var_4]
.text$mn:00002DF5                 call    ?_Grow@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE_NI_N@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Grow(uint,bool)
.text$mn:00002DFA                 movzx   ecx, al
.text$mn:00002DFD                 test    ecx, ecx
.text$mn:00002DFF                 jz      short loc_2E26
.text$mn:00002E01                 mov     edx, [ebp+arg_4]
.text$mn:00002E04                 push    edx             ; int
.text$mn:00002E05                 mov     eax, [ebp+Src]
.text$mn:00002E08                 push    eax             ; Src
.text$mn:00002E09                 mov     ecx, [ebp+var_4]
.text$mn:00002E0C                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002E11                 push    eax             ; Dst
.text$mn:00002E12                 call    ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)
.text$mn:00002E17                 add     esp, 0Ch
.text$mn:00002E1A                 mov     ecx, [ebp+arg_4]
.text$mn:00002E1D                 push    ecx
.text$mn:00002E1E                 mov     ecx, [ebp+var_4]
.text$mn:00002E21                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00002E26
.text$mn:00002E26 loc_2E26:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+6Bj
.text$mn:00002E26                 mov     eax, [ebp+var_4]
.text$mn:00002E29
.text$mn:00002E29 loc_2E29:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *,uint)+56j
.text$mn:00002E29                 mov     esp, ebp
.text$mn:00002E2B                 pop     ebp
.text$mn:00002E2C                 retn    8
.text$mn:00002E2C ?assign@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@PB_WI@Z endp
.text$mn:00002E2C
.text$mn:00002E2C ; ---------------------------------------------------------------------------
.text$mn:00002E2F                 align 10h
.text$mn:00002E2F _text$mn        ends
.text$mn:00002E2F
.text$mn:00002E30 ; ===========================================================================
.text$mn:00002E30
.text$mn:00002E30 ; Segment type: Pure code
.text$mn:00002E30 ; Segment permissions: Read/Execute
.text$mn:00002E30 _text$mn        segment para public 'CODE' use32
.text$mn:00002E30                 assume cs:_text$mn
.text$mn:00002E30                 ;org 2E30h
.text$mn:00002E30 ; COMDAT (pick any)
.text$mn:00002E30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E30
.text$mn:00002E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E30
.text$mn:00002E30 ; Attributes: bp-based frame
.text$mn:00002E30
.text$mn:00002E30 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00002E30                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00002E30 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00002E30                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00002E30
.text$mn:00002E30 arg_0           = dword ptr  8
.text$mn:00002E30 arg_4           = dword ptr  0Ch
.text$mn:00002E30
.text$mn:00002E30                 push    ebp
.text$mn:00002E31                 mov     ebp, esp
.text$mn:00002E33                 mov     eax, [ebp+arg_0]
.text$mn:00002E36                 mov     ecx, [ebp+arg_4]
.text$mn:00002E39                 mov     dl, [ecx]
.text$mn:00002E3B                 mov     [eax], dl
.text$mn:00002E3D                 pop     ebp
.text$mn:00002E3E                 retn
.text$mn:00002E3E ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00002E3E
.text$mn:00002E3E ; ---------------------------------------------------------------------------
.text$mn:00002E3F                 align 10h
.text$mn:00002E3F _text$mn        ends
.text$mn:00002E3F
.text$mn:00002E40 ; ===========================================================================
.text$mn:00002E40
.text$mn:00002E40 ; Segment type: Pure code
.text$mn:00002E40 ; Segment permissions: Read/Execute
.text$mn:00002E40 _text$mn        segment para public 'CODE' use32
.text$mn:00002E40                 assume cs:_text$mn
.text$mn:00002E40                 ;org 2E40h
.text$mn:00002E40 ; COMDAT (pick any)
.text$mn:00002E40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E40
.text$mn:00002E40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E40
.text$mn:00002E40 ; Attributes: bp-based frame
.text$mn:00002E40
.text$mn:00002E40 ; public: static void __cdecl std::char_traits<wchar_t>::assign(wchar_t &, wchar_t const &)
.text$mn:00002E40                 public ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z
.text$mn:00002E40 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z proc near
.text$mn:00002E40                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)+2Bp
.text$mn:00002E40
.text$mn:00002E40 arg_0           = dword ptr  8
.text$mn:00002E40 arg_4           = dword ptr  0Ch
.text$mn:00002E40
.text$mn:00002E40                 push    ebp
.text$mn:00002E41                 mov     ebp, esp
.text$mn:00002E43                 mov     eax, [ebp+arg_0]
.text$mn:00002E46                 mov     ecx, [ebp+arg_4]
.text$mn:00002E49                 mov     dx, [ecx]
.text$mn:00002E4C                 mov     [eax], dx
.text$mn:00002E4F                 pop     ebp
.text$mn:00002E50                 retn
.text$mn:00002E50 ?assign@?$char_traits@_W@std@@SAXAA_WAB_W@Z endp
.text$mn:00002E50
.text$mn:00002E50 ; ---------------------------------------------------------------------------
.text$mn:00002E51                 align 4
.text$mn:00002E51 _text$mn        ends
.text$mn:00002E51
.text$mn:00002E54 ; ===========================================================================
.text$mn:00002E54
.text$mn:00002E54 ; Segment type: Pure code
.text$mn:00002E54 ; Segment permissions: Read/Execute
.text$mn:00002E54 _text$mn        segment para public 'CODE' use32
.text$mn:00002E54                 assume cs:_text$mn
.text$mn:00002E54                 ;org 2E54h
.text$mn:00002E54 ; COMDAT (pick any)
.text$mn:00002E54                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E54
.text$mn:00002E54 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E54
.text$mn:00002E54 ; Attributes: bp-based frame
.text$mn:00002E54
.text$mn:00002E54 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00002E54                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00002E54 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00002E54                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+1AFp
.text$mn:00002E54                                         ; ListView::init(HINSTANCE__ *,HWND__ *)+1E2p ...
.text$mn:00002E54
.text$mn:00002E54 var_4           = dword ptr -4
.text$mn:00002E54
.text$mn:00002E54                 push    ebp
.text$mn:00002E55                 mov     ebp, esp
.text$mn:00002E57                 push    ecx
.text$mn:00002E58                 mov     [ebp+var_4], ecx
.text$mn:00002E5B                 mov     ecx, [ebp+var_4]
.text$mn:00002E5E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002E63                 mov     esp, ebp
.text$mn:00002E65                 pop     ebp
.text$mn:00002E66                 retn
.text$mn:00002E66 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00002E66
.text$mn:00002E66 ; ---------------------------------------------------------------------------
.text$mn:00002E67                 align 4
.text$mn:00002E67 _text$mn        ends
.text$mn:00002E67
.text$mn:00002E68 ; ===========================================================================
.text$mn:00002E68
.text$mn:00002E68 ; Segment type: Pure code
.text$mn:00002E68 ; Segment permissions: Read/Execute
.text$mn:00002E68 _text$mn        segment para public 'CODE' use32
.text$mn:00002E68                 assume cs:_text$mn
.text$mn:00002E68                 ;org 2E68h
.text$mn:00002E68 ; COMDAT (pick any)
.text$mn:00002E68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E68
.text$mn:00002E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E68
.text$mn:00002E68 ; Attributes: bp-based frame
.text$mn:00002E68
.text$mn:00002E68 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00002E68                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00002E68 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002E68                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00002E68
.text$mn:00002E68 var_4           = dword ptr -4
.text$mn:00002E68
.text$mn:00002E68                 push    ebp
.text$mn:00002E69                 mov     ebp, esp
.text$mn:00002E6B                 push    ecx
.text$mn:00002E6C                 mov     [ebp+var_4], ecx
.text$mn:00002E6F                 mov     eax, [ebp+var_4]
.text$mn:00002E72                 mov     eax, [eax+4]
.text$mn:00002E75                 mov     esp, ebp
.text$mn:00002E77                 pop     ebp
.text$mn:00002E78                 retn
.text$mn:00002E78 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002E78
.text$mn:00002E78 ; ---------------------------------------------------------------------------
.text$mn:00002E79                 align 4
.text$mn:00002E79 _text$mn        ends
.text$mn:00002E79
.text$mn:00002E7C ; ===========================================================================
.text$mn:00002E7C
.text$mn:00002E7C ; Segment type: Pure code
.text$mn:00002E7C ; Segment permissions: Read/Execute
.text$mn:00002E7C _text$mn        segment para public 'CODE' use32
.text$mn:00002E7C                 assume cs:_text$mn
.text$mn:00002E7C                 ;org 2E7Ch
.text$mn:00002E7C ; COMDAT (pick any)
.text$mn:00002E7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E7C
.text$mn:00002E7C ; =============== S U B R O U T I N E =======================================
.text$mn:00002E7C
.text$mn:00002E7C ; Attributes: bp-based frame
.text$mn:00002E7C
.text$mn:00002E7C ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00002E7C                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00002E7C ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002E7C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00002E7C                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00002E7C
.text$mn:00002E7C var_4           = dword ptr -4
.text$mn:00002E7C
.text$mn:00002E7C                 push    ebp
.text$mn:00002E7D                 mov     ebp, esp
.text$mn:00002E7F                 push    ecx
.text$mn:00002E80                 mov     [ebp+var_4], ecx
.text$mn:00002E83                 mov     eax, [ebp+var_4]
.text$mn:00002E86                 mov     eax, [eax+4]
.text$mn:00002E89                 mov     esp, ebp
.text$mn:00002E8B                 pop     ebp
.text$mn:00002E8C                 retn
.text$mn:00002E8C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002E8C
.text$mn:00002E8C ; ---------------------------------------------------------------------------
.text$mn:00002E8D                 align 10h
.text$mn:00002E8D _text$mn        ends
.text$mn:00002E8D
.text$mn:00002E90 ; ===========================================================================
.text$mn:00002E90
.text$mn:00002E90 ; Segment type: Pure code
.text$mn:00002E90 ; Segment permissions: Read/Execute
.text$mn:00002E90 _text$mn        segment para public 'CODE' use32
.text$mn:00002E90                 assume cs:_text$mn
.text$mn:00002E90                 ;org 2E90h
.text$mn:00002E90 ; COMDAT (pick any)
.text$mn:00002E90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E90
.text$mn:00002E90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E90
.text$mn:00002E90 ; Attributes: bp-based frame
.text$mn:00002E90
.text$mn:00002E90 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002E90                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002E90 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002E90                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002E90
.text$mn:00002E90 var_4           = dword ptr -4
.text$mn:00002E90 Dst             = dword ptr  8
.text$mn:00002E90 Src             = dword ptr  0Ch
.text$mn:00002E90 Size            = dword ptr  10h
.text$mn:00002E90
.text$mn:00002E90                 push    ebp
.text$mn:00002E91                 mov     ebp, esp
.text$mn:00002E93                 push    ecx
.text$mn:00002E94                 cmp     [ebp+Size], 0
.text$mn:00002E98                 jnz     short loc_2EA2
.text$mn:00002E9A                 mov     eax, [ebp+Dst]
.text$mn:00002E9D                 mov     [ebp+var_4], eax
.text$mn:00002EA0                 jmp     short loc_2EB9
.text$mn:00002EA2 ; ---------------------------------------------------------------------------
.text$mn:00002EA2
.text$mn:00002EA2 loc_2EA2:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:00002EA2                 mov     ecx, [ebp+Size]
.text$mn:00002EA5                 push    ecx             ; Size
.text$mn:00002EA6                 mov     edx, [ebp+Src]
.text$mn:00002EA9                 push    edx             ; Src
.text$mn:00002EAA                 mov     eax, [ebp+Dst]
.text$mn:00002EAD                 push    eax             ; Dst
.text$mn:00002EAE                 call    _memcpy
.text$mn:00002EB3                 add     esp, 0Ch
.text$mn:00002EB6                 mov     [ebp+var_4], eax
.text$mn:00002EB9
.text$mn:00002EB9 loc_2EB9:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:00002EB9                 mov     eax, [ebp+var_4]
.text$mn:00002EBC                 mov     esp, ebp
.text$mn:00002EBE                 pop     ebp
.text$mn:00002EBF                 retn
.text$mn:00002EBF ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002EBF
.text$mn:00002EBF _text$mn        ends
.text$mn:00002EBF
.text$mn:00002EC0 ; ===========================================================================
.text$mn:00002EC0
.text$mn:00002EC0 ; Segment type: Pure code
.text$mn:00002EC0 ; Segment permissions: Read/Execute
.text$mn:00002EC0 _text$mn        segment para public 'CODE' use32
.text$mn:00002EC0                 assume cs:_text$mn
.text$mn:00002EC0                 ;org 2EC0h
.text$mn:00002EC0 ; COMDAT (pick any)
.text$mn:00002EC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EC0
.text$mn:00002EC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EC0
.text$mn:00002EC0 ; Attributes: bp-based frame
.text$mn:00002EC0
.text$mn:00002EC0 ; int __cdecl std::char_traits<wchar_t>::copy(void *Dst, void *Src, int)
.text$mn:00002EC0                 public ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:00002EC0 ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:00002EC0                                         ; CODE XREF: $LN19_0+1Ep
.text$mn:00002EC0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002EC0
.text$mn:00002EC0 var_4           = dword ptr -4
.text$mn:00002EC0 Dst             = dword ptr  8
.text$mn:00002EC0 Src             = dword ptr  0Ch
.text$mn:00002EC0 arg_8           = dword ptr  10h
.text$mn:00002EC0
.text$mn:00002EC0                 push    ebp
.text$mn:00002EC1                 mov     ebp, esp
.text$mn:00002EC3                 push    ecx
.text$mn:00002EC4                 cmp     [ebp+arg_8], 0
.text$mn:00002EC8                 jnz     short loc_2ED2
.text$mn:00002ECA                 mov     eax, [ebp+Dst]
.text$mn:00002ECD                 mov     [ebp+var_4], eax
.text$mn:00002ED0                 jmp     short loc_2EE9
.text$mn:00002ED2 ; ---------------------------------------------------------------------------
.text$mn:00002ED2
.text$mn:00002ED2 loc_2ED2:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+8j
.text$mn:00002ED2                 mov     ecx, [ebp+arg_8]
.text$mn:00002ED5                 push    ecx             ; int
.text$mn:00002ED6                 mov     edx, [ebp+Src]
.text$mn:00002ED9                 push    edx             ; Src
.text$mn:00002EDA                 mov     eax, [ebp+Dst]
.text$mn:00002EDD                 push    eax             ; Dst
.text$mn:00002EDE                 call    _wmemcpy
.text$mn:00002EE3                 add     esp, 0Ch
.text$mn:00002EE6                 mov     [ebp+var_4], eax
.text$mn:00002EE9
.text$mn:00002EE9 loc_2EE9:                               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00002EE9                 mov     eax, [ebp+var_4]
.text$mn:00002EEC                 mov     esp, ebp
.text$mn:00002EEE                 pop     ebp
.text$mn:00002EEF                 retn
.text$mn:00002EEF ?copy@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:00002EEF
.text$mn:00002EEF _text$mn        ends
.text$mn:00002EEF
.text$mn:00002EF0 ; ===========================================================================
.text$mn:00002EF0
.text$mn:00002EF0 ; Segment type: Pure code
.text$mn:00002EF0 ; Segment permissions: Read/Execute
.text$mn:00002EF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002EF0                 assume cs:_text$mn
.text$mn:00002EF0                 ;org 2EF0h
.text$mn:00002EF0 ; COMDAT (pick any)
.text$mn:00002EF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EF0
.text$mn:00002EF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002EF0
.text$mn:00002EF0 ; Attributes: bp-based frame
.text$mn:00002EF0
.text$mn:00002EF0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:00002EF0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:00002EF0 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:00002EF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:00002EF0
.text$mn:00002EF0 var_4           = dword ptr -4
.text$mn:00002EF0 arg_0           = dword ptr  8
.text$mn:00002EF0 arg_4           = dword ptr  0Ch
.text$mn:00002EF0
.text$mn:00002EF0                 push    ebp
.text$mn:00002EF1                 mov     ebp, esp
.text$mn:00002EF3                 push    ecx
.text$mn:00002EF4                 mov     [ebp+var_4], ecx
.text$mn:00002EF7                 mov     eax, [ebp+arg_4]
.text$mn:00002EFA                 push    eax             ; int
.text$mn:00002EFB                 mov     ecx, [ebp+arg_0]
.text$mn:00002EFE                 push    ecx             ; void *
.text$mn:00002EFF                 mov     ecx, [ebp+var_4]
.text$mn:00002F02                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:00002F07                 mov     esp, ebp
.text$mn:00002F09                 pop     ebp
.text$mn:00002F0A                 retn    8
.text$mn:00002F0A ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:00002F0A
.text$mn:00002F0A ; ---------------------------------------------------------------------------
.text$mn:00002F0D                 align 10h
.text$mn:00002F0D _text$mn        ends
.text$mn:00002F0D
.text$mn:00002F10 ; ===========================================================================
.text$mn:00002F10
.text$mn:00002F10 ; Segment type: Pure code
.text$mn:00002F10 ; Segment permissions: Read/Execute
.text$mn:00002F10 _text$mn        segment para public 'CODE' use32
.text$mn:00002F10                 assume cs:_text$mn
.text$mn:00002F10                 ;org 2F10h
.text$mn:00002F10 ; COMDAT (pick any)
.text$mn:00002F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F10
.text$mn:00002F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F10
.text$mn:00002F10 ; Attributes: bp-based frame
.text$mn:00002F10
.text$mn:00002F10 ; int __stdcall std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(void *, int)
.text$mn:00002F10                 public ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z
.text$mn:00002F10 ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z proc near
.text$mn:00002F10                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Tidy(bool,uint)+81p
.text$mn:00002F10
.text$mn:00002F10 var_4           = dword ptr -4
.text$mn:00002F10 arg_0           = dword ptr  8
.text$mn:00002F10 arg_4           = dword ptr  0Ch
.text$mn:00002F10
.text$mn:00002F10                 push    ebp
.text$mn:00002F11                 mov     ebp, esp
.text$mn:00002F13                 push    ecx
.text$mn:00002F14                 mov     [ebp+var_4], ecx
.text$mn:00002F17                 mov     eax, [ebp+arg_4]
.text$mn:00002F1A                 push    eax             ; int
.text$mn:00002F1B                 mov     ecx, [ebp+arg_0]
.text$mn:00002F1E                 push    ecx             ; void *
.text$mn:00002F1F                 mov     ecx, [ebp+var_4]
.text$mn:00002F22                 call    ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z ; std::allocator<wchar_t>::deallocate(wchar_t *,uint)
.text$mn:00002F27                 mov     esp, ebp
.text$mn:00002F29                 pop     ebp
.text$mn:00002F2A                 retn    8
.text$mn:00002F2A ?deallocate@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QAEXPA_WI@Z endp
.text$mn:00002F2A
.text$mn:00002F2A ; ---------------------------------------------------------------------------
.text$mn:00002F2D                 align 10h
.text$mn:00002F2D _text$mn        ends
.text$mn:00002F2D
.text$mn:00002F30 ; ===========================================================================
.text$mn:00002F30
.text$mn:00002F30 ; Segment type: Pure code
.text$mn:00002F30 ; Segment permissions: Read/Execute
.text$mn:00002F30 _text$mn        segment para public 'CODE' use32
.text$mn:00002F30                 assume cs:_text$mn
.text$mn:00002F30                 ;org 2F30h
.text$mn:00002F30 ; COMDAT (pick any)
.text$mn:00002F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F30
.text$mn:00002F30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F30
.text$mn:00002F30 ; Attributes: bp-based frame
.text$mn:00002F30
.text$mn:00002F30 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:00002F30                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:00002F30 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:00002F30                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:00002F30
.text$mn:00002F30 var_4           = dword ptr -4
.text$mn:00002F30 arg_0           = dword ptr  8
.text$mn:00002F30
.text$mn:00002F30                 push    ebp
.text$mn:00002F31                 mov     ebp, esp
.text$mn:00002F33                 push    ecx
.text$mn:00002F34                 mov     [ebp+var_4], ecx
.text$mn:00002F37                 mov     eax, [ebp+arg_0]
.text$mn:00002F3A                 push    eax             ; void *
.text$mn:00002F3B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002F40                 add     esp, 4
.text$mn:00002F43                 mov     esp, ebp
.text$mn:00002F45                 pop     ebp
.text$mn:00002F46                 retn    8
.text$mn:00002F46 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00002F46
.text$mn:00002F46 ; ---------------------------------------------------------------------------
.text$mn:00002F49                 align 4
.text$mn:00002F49 _text$mn        ends
.text$mn:00002F49
.text$mn:00002F4C ; ===========================================================================
.text$mn:00002F4C
.text$mn:00002F4C ; Segment type: Pure code
.text$mn:00002F4C ; Segment permissions: Read/Execute
.text$mn:00002F4C _text$mn        segment para public 'CODE' use32
.text$mn:00002F4C                 assume cs:_text$mn
.text$mn:00002F4C                 ;org 2F4Ch
.text$mn:00002F4C ; COMDAT (pick any)
.text$mn:00002F4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F4C
.text$mn:00002F4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F4C
.text$mn:00002F4C ; Attributes: bp-based frame
.text$mn:00002F4C
.text$mn:00002F4C ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00002F4C                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00002F4C ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00002F4C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00002F4C                                         ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Free_proxy(void)+32p
.text$mn:00002F4C
.text$mn:00002F4C var_4           = dword ptr -4
.text$mn:00002F4C arg_0           = dword ptr  8
.text$mn:00002F4C
.text$mn:00002F4C                 push    ebp
.text$mn:00002F4D                 mov     ebp, esp
.text$mn:00002F4F                 push    ecx
.text$mn:00002F50                 mov     [ebp+var_4], ecx
.text$mn:00002F53                 mov     eax, [ebp+arg_0]
.text$mn:00002F56                 push    eax             ; void *
.text$mn:00002F57                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002F5C                 add     esp, 4
.text$mn:00002F5F                 mov     esp, ebp
.text$mn:00002F61                 pop     ebp
.text$mn:00002F62                 retn    8
.text$mn:00002F62 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002F62
.text$mn:00002F62 ; ---------------------------------------------------------------------------
.text$mn:00002F65                 align 4
.text$mn:00002F65 _text$mn        ends
.text$mn:00002F65
.text$mn:00002F68 ; ===========================================================================
.text$mn:00002F68
.text$mn:00002F68 ; Segment type: Pure code
.text$mn:00002F68 ; Segment permissions: Read/Execute
.text$mn:00002F68 _text$mn        segment para public 'CODE' use32
.text$mn:00002F68                 assume cs:_text$mn
.text$mn:00002F68                 ;org 2F68h
.text$mn:00002F68 ; COMDAT (pick any)
.text$mn:00002F68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F68
.text$mn:00002F68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F68
.text$mn:00002F68 ; Attributes: bp-based frame
.text$mn:00002F68
.text$mn:00002F68 ; int __stdcall std::allocator<wchar_t>::deallocate(void *, int)
.text$mn:00002F68                 public ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z
.text$mn:00002F68 ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z proc near
.text$mn:00002F68                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::deallocate(wchar_t *,uint)+12p
.text$mn:00002F68
.text$mn:00002F68 var_4           = dword ptr -4
.text$mn:00002F68 arg_0           = dword ptr  8
.text$mn:00002F68
.text$mn:00002F68                 push    ebp
.text$mn:00002F69                 mov     ebp, esp
.text$mn:00002F6B                 push    ecx
.text$mn:00002F6C                 mov     [ebp+var_4], ecx
.text$mn:00002F6F                 mov     eax, [ebp+arg_0]
.text$mn:00002F72                 push    eax             ; void *
.text$mn:00002F73                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00002F78                 add     esp, 4
.text$mn:00002F7B                 mov     esp, ebp
.text$mn:00002F7D                 pop     ebp
.text$mn:00002F7E                 retn    8
.text$mn:00002F7E ?deallocate@?$allocator@_W@std@@QAEXPA_WI@Z endp
.text$mn:00002F7E
.text$mn:00002F7E ; ---------------------------------------------------------------------------
.text$mn:00002F81                 align 4
.text$mn:00002F81 _text$mn        ends
.text$mn:00002F81
.text$mn:00002F84 ; ===========================================================================
.text$mn:00002F84
.text$mn:00002F84 ; Segment type: Pure code
.text$mn:00002F84 ; Segment permissions: Read/Execute
.text$mn:00002F84 _text$mn        segment para public 'CODE' use32
.text$mn:00002F84                 assume cs:_text$mn
.text$mn:00002F84                 ;org 2F84h
.text$mn:00002F84 ; COMDAT (pick any)
.text$mn:00002F84                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F84
.text$mn:00002F84 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F84
.text$mn:00002F84 ; Attributes: bp-based frame
.text$mn:00002F84
.text$mn:00002F84 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002F84                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002F84 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002F84                                         ; DATA XREF: .rdata:00003F10o
.text$mn:00002F84
.text$mn:00002F84 var_4           = dword ptr -4
.text$mn:00002F84 arg_0           = dword ptr  8
.text$mn:00002F84 arg_4           = dword ptr  0Ch
.text$mn:00002F84
.text$mn:00002F84                 push    ebp
.text$mn:00002F85                 mov     ebp, esp
.text$mn:00002F87                 push    ecx
.text$mn:00002F88                 mov     [ebp+var_4], ecx
.text$mn:00002F8B                 mov     eax, [ebp+arg_4]
.text$mn:00002F8E                 push    eax             ; int
.text$mn:00002F8F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002F94                 add     esp, 4
.text$mn:00002F97                 test    eax, eax
.text$mn:00002F99                 jz      short loc_2FB4
.text$mn:00002F9B                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002FA0                 push    eax             ; struct std::error_category *
.text$mn:00002FA1                 mov     ecx, [ebp+arg_4]
.text$mn:00002FA4                 push    ecx             ; int
.text$mn:00002FA5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002FA8                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002FAD                 mov     eax, [ebp+arg_0]
.text$mn:00002FB0                 jmp     short loc_2FC9
.text$mn:00002FB2 ; ---------------------------------------------------------------------------
.text$mn:00002FB2                 jmp     short loc_2FC9
.text$mn:00002FB4 ; ---------------------------------------------------------------------------
.text$mn:00002FB4
.text$mn:00002FB4 loc_2FB4:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002FB4                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00002FB9                 push    eax             ; struct std::error_category *
.text$mn:00002FBA                 mov     edx, [ebp+arg_4]
.text$mn:00002FBD                 push    edx             ; int
.text$mn:00002FBE                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002FC1                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002FC6                 mov     eax, [ebp+arg_0]
.text$mn:00002FC9
.text$mn:00002FC9 loc_2FC9:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:00002FC9                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:00002FC9                 mov     esp, ebp
.text$mn:00002FCB                 pop     ebp
.text$mn:00002FCC                 retn    8
.text$mn:00002FCC ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002FCC
.text$mn:00002FCC ; ---------------------------------------------------------------------------
.text$mn:00002FCF                 align 10h
.text$mn:00002FCF _text$mn        ends
.text$mn:00002FCF
.text$mn:00002FD0 ; ===========================================================================
.text$mn:00002FD0
.text$mn:00002FD0 ; Segment type: Pure code
.text$mn:00002FD0 ; Segment permissions: Read/Execute
.text$mn:00002FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002FD0                 assume cs:_text$mn
.text$mn:00002FD0                 ;org 2FD0h
.text$mn:00002FD0 ; COMDAT (pick any)
.text$mn:00002FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FD0
.text$mn:00002FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FD0
.text$mn:00002FD0 ; Attributes: bp-based frame
.text$mn:00002FD0
.text$mn:00002FD0 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002FD0                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002FD0 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002FD0                                         ; DATA XREF: .rdata:00003E80o
.text$mn:00002FD0                                         ; .rdata:00003E9Co ...
.text$mn:00002FD0
.text$mn:00002FD0 var_4           = dword ptr -4
.text$mn:00002FD0 arg_0           = dword ptr  8
.text$mn:00002FD0 arg_4           = dword ptr  0Ch
.text$mn:00002FD0
.text$mn:00002FD0                 push    ebp
.text$mn:00002FD1                 mov     ebp, esp
.text$mn:00002FD3                 push    ecx
.text$mn:00002FD4                 mov     [ebp+var_4], ecx
.text$mn:00002FD7                 mov     eax, [ebp+var_4]
.text$mn:00002FDA                 push    eax             ; struct std::error_category *
.text$mn:00002FDB                 mov     ecx, [ebp+arg_4]
.text$mn:00002FDE                 push    ecx             ; int
.text$mn:00002FDF                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002FE2                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002FE7                 mov     eax, [ebp+arg_0]
.text$mn:00002FEA                 mov     esp, ebp
.text$mn:00002FEC                 pop     ebp
.text$mn:00002FED                 retn    8
.text$mn:00002FED ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002FED
.text$mn:00002FED _text$mn        ends
.text$mn:00002FED
.text$mn:00002FF0 ; ===========================================================================
.text$mn:00002FF0
.text$mn:00002FF0 ; Segment type: Pure code
.text$mn:00002FF0 ; Segment permissions: Read/Execute
.text$mn:00002FF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002FF0                 assume cs:_text$mn
.text$mn:00002FF0                 ;org 2FF0h
.text$mn:00002FF0 ; COMDAT (pick any)
.text$mn:00002FF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002FF0
.text$mn:00002FF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002FF0
.text$mn:00002FF0 ; Attributes: bp-based frame
.text$mn:00002FF0
.text$mn:00002FF0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002FF0                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002FF0 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002FF0                                         ; DATA XREF: .rdata:00003E84o
.text$mn:00002FF0                                         ; .rdata:00003EA0o ...
.text$mn:00002FF0
.text$mn:00002FF0 var_8           = dword ptr -8
.text$mn:00002FF0 var_4           = dword ptr -4
.text$mn:00002FF0 arg_0           = dword ptr  8
.text$mn:00002FF0 arg_4           = dword ptr  0Ch
.text$mn:00002FF0
.text$mn:00002FF0                 push    ebp
.text$mn:00002FF1                 mov     ebp, esp
.text$mn:00002FF3                 sub     esp, 8
.text$mn:00002FF6                 mov     [ebp+var_8], ecx
.text$mn:00002FF9                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002FFC                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00003001                 push    eax
.text$mn:00003002                 mov     ecx, [ebp+var_8]
.text$mn:00003005                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000300A                 movzx   eax, al
.text$mn:0000300D                 test    eax, eax
.text$mn:0000300F                 jz      short loc_3027
.text$mn:00003011                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003014                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00003019                 cmp     eax, [ebp+arg_4]
.text$mn:0000301C                 jnz     short loc_3027
.text$mn:0000301E                 mov     [ebp+var_4], 1
.text$mn:00003025                 jmp     short loc_302E
.text$mn:00003027 ; ---------------------------------------------------------------------------
.text$mn:00003027
.text$mn:00003027 loc_3027:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:00003027                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:00003027                 mov     [ebp+var_4], 0
.text$mn:0000302E
.text$mn:0000302E loc_302E:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:0000302E                 mov     al, byte ptr [ebp+var_4]
.text$mn:00003031                 mov     esp, ebp
.text$mn:00003033                 pop     ebp
.text$mn:00003034                 retn    8
.text$mn:00003034 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:00003034
.text$mn:00003034 ; ---------------------------------------------------------------------------
.text$mn:00003037                 align 4
.text$mn:00003037 _text$mn        ends
.text$mn:00003037
.text$mn:00003038 ; ===========================================================================
.text$mn:00003038
.text$mn:00003038 ; Segment type: Pure code
.text$mn:00003038 ; Segment permissions: Read/Execute
.text$mn:00003038 _text$mn        segment para public 'CODE' use32
.text$mn:00003038                 assume cs:_text$mn
.text$mn:00003038                 ;org 3038h
.text$mn:00003038 ; COMDAT (pick any)
.text$mn:00003038                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003038
.text$mn:00003038 ; =============== S U B R O U T I N E =======================================
.text$mn:00003038
.text$mn:00003038 ; Attributes: bp-based frame
.text$mn:00003038
.text$mn:00003038 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:00003038                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:00003038 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:00003038                                         ; DATA XREF: .rdata:00003E88o
.text$mn:00003038                                         ; .rdata:00003EA4o ...
.text$mn:00003038
.text$mn:00003038 var_C           = byte ptr -0Ch
.text$mn:00003038 var_4           = dword ptr -4
.text$mn:00003038 arg_0           = dword ptr  8
.text$mn:00003038 arg_4           = dword ptr  0Ch
.text$mn:00003038
.text$mn:00003038                 push    ebp
.text$mn:00003039                 mov     ebp, esp
.text$mn:0000303B                 sub     esp, 0Ch
.text$mn:0000303E                 mov     [ebp+var_4], ecx
.text$mn:00003041                 mov     eax, [ebp+arg_4]
.text$mn:00003044                 push    eax             ; std::error_condition *
.text$mn:00003045                 mov     ecx, [ebp+arg_0]
.text$mn:00003048                 push    ecx
.text$mn:00003049                 lea     edx, [ebp+var_C]
.text$mn:0000304C                 push    edx
.text$mn:0000304D                 mov     eax, [ebp+var_4]
.text$mn:00003050                 mov     edx, [eax]
.text$mn:00003052                 mov     ecx, [ebp+var_4]
.text$mn:00003055                 mov     eax, [edx+0Ch]
.text$mn:00003058                 call    eax
.text$mn:0000305A                 mov     ecx, eax
.text$mn:0000305C                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:00003061                 mov     esp, ebp
.text$mn:00003063                 pop     ebp
.text$mn:00003064                 retn    8
.text$mn:00003064 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:00003064
.text$mn:00003064 ; ---------------------------------------------------------------------------
.text$mn:00003067                 align 4
.text$mn:00003067 _text$mn        ends
.text$mn:00003067
.text$mn:00003068 ; ===========================================================================
.text$mn:00003068
.text$mn:00003068 ; Segment type: Pure code
.text$mn:00003068 ; Segment permissions: Read/Execute
.text$mn:00003068 _text$mn        segment para public 'CODE' use32
.text$mn:00003068                 assume cs:_text$mn
.text$mn:00003068                 ;org 3068h
.text$mn:00003068 ; COMDAT (pick any)
.text$mn:00003068                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003068
.text$mn:00003068 ; =============== S U B R O U T I N E =======================================
.text$mn:00003068
.text$mn:00003068 ; Attributes: bp-based frame
.text$mn:00003068
.text$mn:00003068 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:00003068                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:00003068 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00003068                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:00003068
.text$mn:00003068 var_4           = dword ptr -4
.text$mn:00003068 arg_0           = dword ptr  8
.text$mn:00003068
.text$mn:00003068                 push    ebp
.text$mn:00003069                 mov     ebp, esp
.text$mn:0000306B                 push    ecx
.text$mn:0000306C                 mov     [ebp+var_4], ecx
.text$mn:0000306F                 mov     eax, [ebp+var_4]
.text$mn:00003072                 mov     ecx, [eax+14h]
.text$mn:00003075                 cmp     ecx, [ebp+arg_0]
.text$mn:00003078                 jnb     short loc_3082
.text$mn:0000307A                 mov     ecx, [ebp+var_4]
.text$mn:0000307D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00003082
.text$mn:00003082 loc_3082:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00003082                 mov     edx, [ebp+arg_0]
.text$mn:00003085                 push    edx
.text$mn:00003086                 mov     ecx, [ebp+var_4]
.text$mn:00003089                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000308E                 mov     eax, [ebp+var_4]
.text$mn:00003091                 mov     esp, ebp
.text$mn:00003093                 pop     ebp
.text$mn:00003094                 retn    4
.text$mn:00003094 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00003094
.text$mn:00003094 ; ---------------------------------------------------------------------------
.text$mn:00003097                 align 4
.text$mn:00003097 _text$mn        ends
.text$mn:00003097
.text$mn:00003098 ; ===========================================================================
.text$mn:00003098
.text$mn:00003098 ; Segment type: Pure code
.text$mn:00003098 ; Segment permissions: Read/Execute
.text$mn:00003098 _text$mn        segment para public 'CODE' use32
.text$mn:00003098                 assume cs:_text$mn
.text$mn:00003098                 ;org 3098h
.text$mn:00003098 ; COMDAT (pick any)
.text$mn:00003098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003098
.text$mn:00003098 ; =============== S U B R O U T I N E =======================================
.text$mn:00003098
.text$mn:00003098 ; Attributes: bp-based frame
.text$mn:00003098
.text$mn:00003098 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00003098                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00003098 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00003098                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00003098
.text$mn:00003098 var_C           = dword ptr -0Ch
.text$mn:00003098 Dst             = dword ptr -8
.text$mn:00003098 var_4           = dword ptr -4
.text$mn:00003098 arg_0           = dword ptr  8
.text$mn:00003098 arg_4           = dword ptr  0Ch
.text$mn:00003098
.text$mn:00003098                 push    ebp
.text$mn:00003099                 mov     ebp, esp
.text$mn:0000309B                 sub     esp, 0Ch
.text$mn:0000309E                 mov     [ebp+var_4], ecx
.text$mn:000030A1                 mov     eax, [ebp+var_4]
.text$mn:000030A4                 mov     ecx, [eax+14h]
.text$mn:000030A7                 cmp     ecx, [ebp+arg_0]
.text$mn:000030AA                 jnb     short loc_30B4
.text$mn:000030AC                 mov     ecx, [ebp+var_4]
.text$mn:000030AF                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000030B4
.text$mn:000030B4 loc_30B4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:000030B4                 mov     edx, [ebp+var_4]
.text$mn:000030B7                 mov     eax, [edx+14h]
.text$mn:000030BA                 sub     eax, [ebp+arg_0]
.text$mn:000030BD                 cmp     eax, [ebp+arg_4]
.text$mn:000030C0                 ja      short loc_30D0
.text$mn:000030C2                 mov     ecx, [ebp+arg_0]
.text$mn:000030C5                 push    ecx
.text$mn:000030C6                 mov     ecx, [ebp+var_4]
.text$mn:000030C9                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000030CE                 jmp     short loc_3116
.text$mn:000030D0 ; ---------------------------------------------------------------------------
.text$mn:000030D0
.text$mn:000030D0 loc_30D0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:000030D0                 cmp     [ebp+arg_4], 0
.text$mn:000030D4                 jbe     short loc_3116
.text$mn:000030D6                 mov     ecx, [ebp+var_4]
.text$mn:000030D9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000030DE                 add     eax, [ebp+arg_0]
.text$mn:000030E1                 mov     [ebp+Dst], eax
.text$mn:000030E4                 mov     edx, [ebp+var_4]
.text$mn:000030E7                 mov     eax, [edx+14h]
.text$mn:000030EA                 sub     eax, [ebp+arg_4]
.text$mn:000030ED                 mov     [ebp+var_C], eax
.text$mn:000030F0                 mov     ecx, [ebp+var_C]
.text$mn:000030F3                 sub     ecx, [ebp+arg_0]
.text$mn:000030F6                 push    ecx             ; Size
.text$mn:000030F7                 mov     edx, [ebp+Dst]
.text$mn:000030FA                 add     edx, [ebp+arg_4]
.text$mn:000030FD                 push    edx             ; Src
.text$mn:000030FE                 mov     eax, [ebp+Dst]
.text$mn:00003101                 push    eax             ; Dst
.text$mn:00003102                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00003107                 add     esp, 0Ch
.text$mn:0000310A                 mov     ecx, [ebp+var_C]
.text$mn:0000310D                 push    ecx
.text$mn:0000310E                 mov     ecx, [ebp+var_4]
.text$mn:00003111                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003116
.text$mn:00003116 loc_3116:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00003116                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00003116                 mov     eax, [ebp+var_4]
.text$mn:00003119                 mov     esp, ebp
.text$mn:0000311B                 pop     ebp
.text$mn:0000311C                 retn    8
.text$mn:0000311C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:0000311C
.text$mn:0000311C ; ---------------------------------------------------------------------------
.text$mn:0000311F                 align 10h
.text$mn:0000311F _text$mn        ends
.text$mn:0000311F
.text$mn:00003120 ; ===========================================================================
.text$mn:00003120
.text$mn:00003120 ; Segment type: Pure code
.text$mn:00003120 ; Segment permissions: Read/Execute
.text$mn:00003120 _text$mn        segment para public 'CODE' use32
.text$mn:00003120                 assume cs:_text$mn
.text$mn:00003120                 ;org 3120h
.text$mn:00003120 ; COMDAT (pick any)
.text$mn:00003120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003120
.text$mn:00003120 ; =============== S U B R O U T I N E =======================================
.text$mn:00003120
.text$mn:00003120 ; Attributes: bp-based frame
.text$mn:00003120
.text$mn:00003120 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int)
.text$mn:00003120                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z
.text$mn:00003120 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z proc near
.text$mn:00003120                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+4Cp
.text$mn:00003120
.text$mn:00003120 var_4           = dword ptr -4
.text$mn:00003120 arg_0           = dword ptr  8
.text$mn:00003120
.text$mn:00003120                 push    ebp
.text$mn:00003121                 mov     ebp, esp
.text$mn:00003123                 push    ecx
.text$mn:00003124                 mov     [ebp+var_4], ecx
.text$mn:00003127                 mov     eax, [ebp+var_4]
.text$mn:0000312A                 mov     ecx, [eax+14h]
.text$mn:0000312D                 cmp     ecx, [ebp+arg_0]
.text$mn:00003130                 jnb     short loc_313A
.text$mn:00003132                 mov     ecx, [ebp+var_4]
.text$mn:00003135                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000313A
.text$mn:0000313A loc_313A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint)+10j
.text$mn:0000313A                 mov     edx, [ebp+arg_0]
.text$mn:0000313D                 push    edx
.text$mn:0000313E                 mov     ecx, [ebp+var_4]
.text$mn:00003141                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003146                 mov     eax, [ebp+var_4]
.text$mn:00003149                 mov     esp, ebp
.text$mn:0000314B                 pop     ebp
.text$mn:0000314C                 retn    4
.text$mn:0000314C ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@I@Z endp
.text$mn:0000314C
.text$mn:0000314C ; ---------------------------------------------------------------------------
.text$mn:0000314F                 align 10h
.text$mn:0000314F _text$mn        ends
.text$mn:0000314F
.text$mn:00003150 ; ===========================================================================
.text$mn:00003150
.text$mn:00003150 ; Segment type: Pure code
.text$mn:00003150 ; Segment permissions: Read/Execute
.text$mn:00003150 _text$mn        segment para public 'CODE' use32
.text$mn:00003150                 assume cs:_text$mn
.text$mn:00003150                 ;org 3150h
.text$mn:00003150 ; COMDAT (pick any)
.text$mn:00003150                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003150
.text$mn:00003150 ; =============== S U B R O U T I N E =======================================
.text$mn:00003150
.text$mn:00003150 ; Attributes: bp-based frame
.text$mn:00003150
.text$mn:00003150 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> & __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::erase(unsigned int, unsigned int)
.text$mn:00003150                 public ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z
.text$mn:00003150 ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00003150                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+5Ap
.text$mn:00003150
.text$mn:00003150 var_C           = dword ptr -0Ch
.text$mn:00003150 Dst             = dword ptr -8
.text$mn:00003150 var_4           = dword ptr -4
.text$mn:00003150 arg_0           = dword ptr  8
.text$mn:00003150 arg_4           = dword ptr  0Ch
.text$mn:00003150
.text$mn:00003150                 push    ebp
.text$mn:00003151                 mov     ebp, esp
.text$mn:00003153                 sub     esp, 0Ch
.text$mn:00003156                 mov     [ebp+var_4], ecx
.text$mn:00003159                 mov     eax, [ebp+var_4]
.text$mn:0000315C                 mov     ecx, [eax+14h]
.text$mn:0000315F                 cmp     ecx, [ebp+arg_0]
.text$mn:00003162                 jnb     short loc_316C
.text$mn:00003164                 mov     ecx, [ebp+var_4]
.text$mn:00003167                 call    ?_Xran@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)
.text$mn:0000316C
.text$mn:0000316C loc_316C:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+12j
.text$mn:0000316C                 mov     edx, [ebp+var_4]
.text$mn:0000316F                 mov     eax, [edx+14h]
.text$mn:00003172                 sub     eax, [ebp+arg_0]
.text$mn:00003175                 cmp     eax, [ebp+arg_4]
.text$mn:00003178                 ja      short loc_3188
.text$mn:0000317A                 mov     ecx, [ebp+arg_0]
.text$mn:0000317D                 push    ecx
.text$mn:0000317E                 mov     ecx, [ebp+var_4]
.text$mn:00003181                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:00003186                 jmp     short loc_31D4
.text$mn:00003188 ; ---------------------------------------------------------------------------
.text$mn:00003188
.text$mn:00003188 loc_3188:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+28j
.text$mn:00003188                 cmp     [ebp+arg_4], 0
.text$mn:0000318C                 jbe     short loc_31D4
.text$mn:0000318E                 mov     ecx, [ebp+var_4]
.text$mn:00003191                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QAEPA_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00003196                 mov     edx, [ebp+arg_0]
.text$mn:00003199                 lea     eax, [eax+edx*2]
.text$mn:0000319C                 mov     [ebp+Dst], eax
.text$mn:0000319F                 mov     ecx, [ebp+var_4]
.text$mn:000031A2                 mov     edx, [ecx+14h]
.text$mn:000031A5                 sub     edx, [ebp+arg_4]
.text$mn:000031A8                 mov     [ebp+var_C], edx
.text$mn:000031AB                 mov     eax, [ebp+var_C]
.text$mn:000031AE                 sub     eax, [ebp+arg_0]
.text$mn:000031B1                 push    eax             ; int
.text$mn:000031B2                 mov     ecx, [ebp+arg_4]
.text$mn:000031B5                 mov     edx, [ebp+Dst]
.text$mn:000031B8                 lea     eax, [edx+ecx*2]
.text$mn:000031BB                 push    eax             ; Src
.text$mn:000031BC                 mov     ecx, [ebp+Dst]
.text$mn:000031BF                 push    ecx             ; Dst
.text$mn:000031C0                 call    ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z ; std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)
.text$mn:000031C5                 add     esp, 0Ch
.text$mn:000031C8                 mov     edx, [ebp+var_C]
.text$mn:000031CB                 push    edx
.text$mn:000031CC                 mov     ecx, [ebp+var_4]
.text$mn:000031CF                 call    ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXI@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Eos(uint)
.text$mn:000031D4
.text$mn:000031D4 loc_31D4:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+36j
.text$mn:000031D4                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+3Cj
.text$mn:000031D4                 mov     eax, [ebp+var_4]
.text$mn:000031D7                 mov     esp, ebp
.text$mn:000031D9                 pop     ebp
.text$mn:000031DA                 retn    8
.text$mn:000031DA ?erase@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEAAV12@II@Z endp
.text$mn:000031DA
.text$mn:000031DA ; ---------------------------------------------------------------------------
.text$mn:000031DD                 align 10h
.text$mn:000031DD _text$mn        ends
.text$mn:000031DD
.text$mn:000031E0 ; ===========================================================================
.text$mn:000031E0
.text$mn:000031E0 ; Segment type: Pure code
.text$mn:000031E0 ; Segment permissions: Read/Execute
.text$mn:000031E0 _text$mn        segment para public 'CODE' use32
.text$mn:000031E0                 assume cs:_text$mn
.text$mn:000031E0                 ;org 31E0h
.text$mn:000031E0 ; COMDAT (pick any)
.text$mn:000031E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031E0
.text$mn:000031E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000031E0
.text$mn:000031E0 ; Attributes: bp-based frame
.text$mn:000031E0
.text$mn:000031E0 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000031E0                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000031E0 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000031E0                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000031E0                 push    ebp
.text$mn:000031E1                 mov     ebp, esp
.text$mn:000031E3                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000031E8                 pop     ebp
.text$mn:000031E9                 retn
.text$mn:000031E9 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000031E9
.text$mn:000031E9 ; ---------------------------------------------------------------------------
.text$mn:000031EA                 align 4
.text$mn:000031EA _text$mn        ends
.text$mn:000031EA
.text$mn:000031EC ; ===========================================================================
.text$mn:000031EC
.text$mn:000031EC ; Segment type: Pure code
.text$mn:000031EC ; Segment permissions: Read/Execute
.text$mn:000031EC _text$mn        segment para public 'CODE' use32
.text$mn:000031EC                 assume cs:_text$mn
.text$mn:000031EC                 ;org 31ECh
.text$mn:000031EC ; COMDAT (pick any)
.text$mn:000031EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031EC
.text$mn:000031EC ; =============== S U B R O U T I N E =======================================
.text$mn:000031EC
.text$mn:000031EC ; Attributes: bp-based frame
.text$mn:000031EC
.text$mn:000031EC ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:000031EC                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:000031EC ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:000031EC                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+133p
.text$mn:000031EC                 push    ebp
.text$mn:000031ED                 mov     ebp, esp
.text$mn:000031EF                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:000031F4                 pop     ebp
.text$mn:000031F5                 retn
.text$mn:000031F5 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:000031F5
.text$mn:000031F5 ; ---------------------------------------------------------------------------
.text$mn:000031F6                 align 4
.text$mn:000031F6 _text$mn        ends
.text$mn:000031F6
.text$mn:000031F8 ; ===========================================================================
.text$mn:000031F8
.text$mn:000031F8 ; Segment type: Pure code
.text$mn:000031F8 ; Segment permissions: Read/Execute
.text$mn:000031F8 _text$mn        segment para public 'CODE' use32
.text$mn:000031F8                 assume cs:_text$mn
.text$mn:000031F8                 ;org 31F8h
.text$mn:000031F8 ; COMDAT (pick any)
.text$mn:000031F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031F8
.text$mn:000031F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000031F8
.text$mn:000031F8 ; Attributes: bp-based frame
.text$mn:000031F8
.text$mn:000031F8 ; struct NativeLangSpeaker *__thiscall NppParameters::getNativeLangSpeaker(NppParameters *__hidden this)
.text$mn:000031F8                 public ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ
.text$mn:000031F8 ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ proc near
.text$mn:000031F8                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+13Ap
.text$mn:000031F8
.text$mn:000031F8 var_4           = dword ptr -4
.text$mn:000031F8
.text$mn:000031F8                 push    ebp
.text$mn:000031F9                 mov     ebp, esp
.text$mn:000031FB                 push    ecx
.text$mn:000031FC                 mov     [ebp+var_4], ecx
.text$mn:000031FF                 mov     eax, [ebp+var_4]
.text$mn:00003202                 mov     eax, [eax+1CC20h]
.text$mn:00003208                 mov     esp, ebp
.text$mn:0000320A                 pop     ebp
.text$mn:0000320B                 retn
.text$mn:0000320B ?getNativeLangSpeaker@NppParameters@@QAEPAVNativeLangSpeaker@@XZ endp
.text$mn:0000320B
.text$mn:0000320B _text$mn        ends
.text$mn:0000320B
.text$mn:0000320C ; ===========================================================================
.text$mn:0000320C
.text$mn:0000320C ; Segment type: Pure code
.text$mn:0000320C ; Segment permissions: Read/Execute
.text$mn:0000320C _text$mn        segment para public 'CODE' use32
.text$mn:0000320C                 assume cs:_text$mn
.text$mn:0000320C                 ;org 320Ch
.text$mn:0000320C ; COMDAT (pick any)
.text$mn:0000320C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000320C
.text$mn:0000320C ; =============== S U B R O U T I N E =======================================
.text$mn:0000320C
.text$mn:0000320C ; Attributes: bp-based frame
.text$mn:0000320C
.text$mn:0000320C ; void __thiscall Window::init(Window *this, HINSTANCE, HWND)
.text$mn:0000320C                 public ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.text$mn:0000320C ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z proc near
.text$mn:0000320C                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+39p
.text$mn:0000320C
.text$mn:0000320C var_4           = dword ptr -4
.text$mn:0000320C arg_0           = dword ptr  8
.text$mn:0000320C arg_4           = dword ptr  0Ch
.text$mn:0000320C
.text$mn:0000320C                 push    ebp
.text$mn:0000320D                 mov     ebp, esp
.text$mn:0000320F                 push    ecx
.text$mn:00003210                 mov     [ebp+var_4], ecx
.text$mn:00003213                 mov     eax, [ebp+var_4]
.text$mn:00003216                 mov     ecx, [ebp+arg_0]
.text$mn:00003219                 mov     [eax+4], ecx
.text$mn:0000321C                 mov     edx, [ebp+var_4]
.text$mn:0000321F                 mov     eax, [ebp+arg_4]
.text$mn:00003222                 mov     [edx+8], eax
.text$mn:00003225                 mov     esp, ebp
.text$mn:00003227                 pop     ebp
.text$mn:00003228                 retn    8
.text$mn:00003228 ?init@Window@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z endp
.text$mn:00003228
.text$mn:00003228 ; ---------------------------------------------------------------------------
.text$mn:0000322B                 align 4
.text$mn:0000322B _text$mn        ends
.text$mn:0000322B
.text$mn:0000322C ; ===========================================================================
.text$mn:0000322C
.text$mn:0000322C ; Segment type: Pure code
.text$mn:0000322C ; Segment permissions: Read/Execute
.text$mn:0000322C _text$mn        segment para public 'CODE' use32
.text$mn:0000322C                 assume cs:_text$mn
.text$mn:0000322C                 ;org 322Ch
.text$mn:0000322C ; COMDAT (pick any)
.text$mn:0000322C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000322C
.text$mn:0000322C ; =============== S U B R O U T I N E =======================================
.text$mn:0000322C
.text$mn:0000322C ; Attributes: bp-based frame
.text$mn:0000322C
.text$mn:0000322C ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:0000322C                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:0000322C ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:0000322C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:0000322C
.text$mn:0000322C var_4           = dword ptr -4
.text$mn:0000322C Str             = dword ptr  8
.text$mn:0000322C
.text$mn:0000322C                 push    ebp
.text$mn:0000322D                 mov     ebp, esp
.text$mn:0000322F                 push    ecx
.text$mn:00003230                 mov     eax, [ebp+Str]
.text$mn:00003233                 movsx   ecx, byte ptr [eax]
.text$mn:00003236                 test    ecx, ecx
.text$mn:00003238                 jnz     short loc_3243
.text$mn:0000323A                 mov     [ebp+var_4], 0
.text$mn:00003241                 jmp     short loc_3252
.text$mn:00003243 ; ---------------------------------------------------------------------------
.text$mn:00003243
.text$mn:00003243 loc_3243:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00003243                 mov     edx, [ebp+Str]
.text$mn:00003246                 push    edx             ; Str
.text$mn:00003247                 call    _strlen
.text$mn:0000324C                 add     esp, 4
.text$mn:0000324F                 mov     [ebp+var_4], eax
.text$mn:00003252
.text$mn:00003252 loc_3252:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00003252                 mov     eax, [ebp+var_4]
.text$mn:00003255                 mov     esp, ebp
.text$mn:00003257                 pop     ebp
.text$mn:00003258                 retn
.text$mn:00003258 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00003258
.text$mn:00003258 ; ---------------------------------------------------------------------------
.text$mn:00003259                 align 4
.text$mn:00003259 _text$mn        ends
.text$mn:00003259
.text$mn:0000325C ; ===========================================================================
.text$mn:0000325C
.text$mn:0000325C ; Segment type: Pure code
.text$mn:0000325C ; Segment permissions: Read/Execute
.text$mn:0000325C _text$mn        segment para public 'CODE' use32
.text$mn:0000325C                 assume cs:_text$mn
.text$mn:0000325C                 ;org 325Ch
.text$mn:0000325C ; COMDAT (pick any)
.text$mn:0000325C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000325C
.text$mn:0000325C ; =============== S U B R O U T I N E =======================================
.text$mn:0000325C
.text$mn:0000325C ; Attributes: bp-based frame
.text$mn:0000325C
.text$mn:0000325C ; int __cdecl std::char_traits<wchar_t>::length(wchar_t *Str)
.text$mn:0000325C                 public ?length@?$char_traits@_W@std@@SAIPB_W@Z
.text$mn:0000325C ?length@?$char_traits@_W@std@@SAIPB_W@Z proc near
.text$mn:0000325C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(wchar_t const *)+21p
.text$mn:0000325C
.text$mn:0000325C var_4           = dword ptr -4
.text$mn:0000325C Str             = dword ptr  8
.text$mn:0000325C
.text$mn:0000325C                 push    ebp
.text$mn:0000325D                 mov     ebp, esp
.text$mn:0000325F                 push    ecx
.text$mn:00003260                 mov     eax, [ebp+Str]
.text$mn:00003263                 movzx   ecx, word ptr [eax]
.text$mn:00003266                 test    ecx, ecx
.text$mn:00003268                 jnz     short loc_3273
.text$mn:0000326A                 mov     [ebp+var_4], 0
.text$mn:00003271                 jmp     short loc_3282
.text$mn:00003273 ; ---------------------------------------------------------------------------
.text$mn:00003273
.text$mn:00003273 loc_3273:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+Cj
.text$mn:00003273                 mov     edx, [ebp+Str]
.text$mn:00003276                 push    edx             ; Str
.text$mn:00003277                 call    _wcslen
.text$mn:0000327C                 add     esp, 4
.text$mn:0000327F                 mov     [ebp+var_4], eax
.text$mn:00003282
.text$mn:00003282 loc_3282:                               ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+15j
.text$mn:00003282                 mov     eax, [ebp+var_4]
.text$mn:00003285                 mov     esp, ebp
.text$mn:00003287                 pop     ebp
.text$mn:00003288                 retn
.text$mn:00003288 ?length@?$char_traits@_W@std@@SAIPB_W@Z endp
.text$mn:00003288
.text$mn:00003288 ; ---------------------------------------------------------------------------
.text$mn:00003289                 align 4
.text$mn:00003289 _text$mn        ends
.text$mn:00003289
.text$mn:0000328C ; ===========================================================================
.text$mn:0000328C
.text$mn:0000328C ; Segment type: Pure code
.text$mn:0000328C ; Segment permissions: Read/Execute
.text$mn:0000328C _text$mn        segment para public 'CODE' use32
.text$mn:0000328C                 assume cs:_text$mn
.text$mn:0000328C                 ;org 328Ch
.text$mn:0000328C ; COMDAT (pick any)
.text$mn:0000328C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000328C
.text$mn:0000328C ; =============== S U B R O U T I N E =======================================
.text$mn:0000328C
.text$mn:0000328C ; Attributes: bp-based frame
.text$mn:0000328C
.text$mn:0000328C ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:0000328C                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:0000328C ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:0000328C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:0000328C
.text$mn:0000328C var_4           = dword ptr -4
.text$mn:0000328C
.text$mn:0000328C                 push    ebp
.text$mn:0000328D                 mov     ebp, esp
.text$mn:0000328F                 push    ecx
.text$mn:00003290                 mov     [ebp+var_4], ecx
.text$mn:00003293                 mov     eax, [ebp+var_4]
.text$mn:00003296                 push    eax
.text$mn:00003297                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:0000329C                 add     esp, 4
.text$mn:0000329F                 mov     esp, ebp
.text$mn:000032A1                 pop     ebp
.text$mn:000032A2                 retn
.text$mn:000032A2 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:000032A2
.text$mn:000032A2 ; ---------------------------------------------------------------------------
.text$mn:000032A3                 align 4
.text$mn:000032A3 _text$mn        ends
.text$mn:000032A3
.text$mn:000032A4 ; ===========================================================================
.text$mn:000032A4
.text$mn:000032A4 ; Segment type: Pure code
.text$mn:000032A4 ; Segment permissions: Read/Execute
.text$mn:000032A4 _text$mn        segment para public 'CODE' use32
.text$mn:000032A4                 assume cs:_text$mn
.text$mn:000032A4                 ;org 32A4h
.text$mn:000032A4 ; COMDAT (pick any)
.text$mn:000032A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032A4
.text$mn:000032A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032A4
.text$mn:000032A4 ; Attributes: bp-based frame
.text$mn:000032A4
.text$mn:000032A4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<wchar_t>>::max_size(void)const
.text$mn:000032A4                 public ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ
.text$mn:000032A4 ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ proc near
.text$mn:000032A4                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+17p
.text$mn:000032A4
.text$mn:000032A4 var_4           = dword ptr -4
.text$mn:000032A4
.text$mn:000032A4                 push    ebp
.text$mn:000032A5                 mov     ebp, esp
.text$mn:000032A7                 push    ecx
.text$mn:000032A8                 mov     [ebp+var_4], ecx
.text$mn:000032AB                 mov     eax, [ebp+var_4]
.text$mn:000032AE                 push    eax
.text$mn:000032AF                 call    ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z ; std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)
.text$mn:000032B4                 add     esp, 4
.text$mn:000032B7                 mov     esp, ebp
.text$mn:000032B9                 pop     ebp
.text$mn:000032BA                 retn
.text$mn:000032BA ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ endp
.text$mn:000032BA
.text$mn:000032BA ; ---------------------------------------------------------------------------
.text$mn:000032BB                 align 4
.text$mn:000032BB _text$mn        ends
.text$mn:000032BB
.text$mn:000032BC ; ===========================================================================
.text$mn:000032BC
.text$mn:000032BC ; Segment type: Pure code
.text$mn:000032BC ; Segment permissions: Read/Execute
.text$mn:000032BC _text$mn        segment para public 'CODE' use32
.text$mn:000032BC                 assume cs:_text$mn
.text$mn:000032BC                 ;org 32BCh
.text$mn:000032BC ; COMDAT (pick any)
.text$mn:000032BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032BC
.text$mn:000032BC ; =============== S U B R O U T I N E =======================================
.text$mn:000032BC
.text$mn:000032BC ; Attributes: bp-based frame
.text$mn:000032BC
.text$mn:000032BC ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:000032BC                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:000032BC ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:000032BC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:000032BC
.text$mn:000032BC var_4           = dword ptr -4
.text$mn:000032BC
.text$mn:000032BC                 push    ebp
.text$mn:000032BD                 mov     ebp, esp
.text$mn:000032BF                 push    ecx
.text$mn:000032C0                 mov     [ebp+var_4], ecx
.text$mn:000032C3                 or      eax, 0FFFFFFFFh
.text$mn:000032C6                 mov     esp, ebp
.text$mn:000032C8                 pop     ebp
.text$mn:000032C9                 retn
.text$mn:000032C9 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:000032C9
.text$mn:000032C9 ; ---------------------------------------------------------------------------
.text$mn:000032CA                 align 4
.text$mn:000032CA _text$mn        ends
.text$mn:000032CA
.text$mn:000032CC ; ===========================================================================
.text$mn:000032CC
.text$mn:000032CC ; Segment type: Pure code
.text$mn:000032CC ; Segment permissions: Read/Execute
.text$mn:000032CC _text$mn        segment para public 'CODE' use32
.text$mn:000032CC                 assume cs:_text$mn
.text$mn:000032CC                 ;org 32CCh
.text$mn:000032CC ; COMDAT (pick any)
.text$mn:000032CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032CC
.text$mn:000032CC ; =============== S U B R O U T I N E =======================================
.text$mn:000032CC
.text$mn:000032CC ; Attributes: bp-based frame
.text$mn:000032CC
.text$mn:000032CC ; public: unsigned int __thiscall std::allocator<wchar_t>::max_size(void)const
.text$mn:000032CC                 public ?max_size@?$allocator@_W@std@@QBEIXZ
.text$mn:000032CC ?max_size@?$allocator@_W@std@@QBEIXZ proc near
.text$mn:000032CC                                         ; CODE XREF: std::allocator_traits<std::allocator<wchar_t>>::max_size(std::allocator<wchar_t> const &)+6p
.text$mn:000032CC
.text$mn:000032CC var_4           = dword ptr -4
.text$mn:000032CC
.text$mn:000032CC                 push    ebp
.text$mn:000032CD                 mov     ebp, esp
.text$mn:000032CF                 push    ecx
.text$mn:000032D0                 mov     [ebp+var_4], ecx
.text$mn:000032D3                 mov     eax, 7FFFFFFFh
.text$mn:000032D8                 mov     esp, ebp
.text$mn:000032DA                 pop     ebp
.text$mn:000032DB                 retn
.text$mn:000032DB ?max_size@?$allocator@_W@std@@QBEIXZ endp
.text$mn:000032DB
.text$mn:000032DB _text$mn        ends
.text$mn:000032DB
.text$mn:000032DC ; ===========================================================================
.text$mn:000032DC
.text$mn:000032DC ; Segment type: Pure code
.text$mn:000032DC ; Segment permissions: Read/Execute
.text$mn:000032DC _text$mn        segment para public 'CODE' use32
.text$mn:000032DC                 assume cs:_text$mn
.text$mn:000032DC                 ;org 32DCh
.text$mn:000032DC ; COMDAT (pick any)
.text$mn:000032DC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032DC
.text$mn:000032DC ; =============== S U B R O U T I N E =======================================
.text$mn:000032DC
.text$mn:000032DC ; Attributes: bp-based frame
.text$mn:000032DC
.text$mn:000032DC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:000032DC                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:000032DC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:000032DC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:000032DC
.text$mn:000032DC arg_0           = dword ptr  8
.text$mn:000032DC
.text$mn:000032DC                 push    ebp
.text$mn:000032DD                 mov     ebp, esp
.text$mn:000032DF                 mov     ecx, [ebp+arg_0]
.text$mn:000032E2                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:000032E7                 pop     ebp
.text$mn:000032E8                 retn
.text$mn:000032E8 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:000032E8
.text$mn:000032E8 ; ---------------------------------------------------------------------------
.text$mn:000032E9                 align 4
.text$mn:000032E9 _text$mn        ends
.text$mn:000032E9
.text$mn:000032EC ; ===========================================================================
.text$mn:000032EC
.text$mn:000032EC ; Segment type: Pure code
.text$mn:000032EC ; Segment permissions: Read/Execute
.text$mn:000032EC _text$mn        segment para public 'CODE' use32
.text$mn:000032EC                 assume cs:_text$mn
.text$mn:000032EC                 ;org 32ECh
.text$mn:000032EC ; COMDAT (pick any)
.text$mn:000032EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032EC
.text$mn:000032EC ; =============== S U B R O U T I N E =======================================
.text$mn:000032EC
.text$mn:000032EC ; Attributes: bp-based frame
.text$mn:000032EC
.text$mn:000032EC ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<wchar_t>>::max_size(class std::allocator<wchar_t> const &)
.text$mn:000032EC                 public ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z
.text$mn:000032EC ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z proc near
.text$mn:000032EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)+Bp
.text$mn:000032EC
.text$mn:000032EC arg_0           = dword ptr  8
.text$mn:000032EC
.text$mn:000032EC                 push    ebp
.text$mn:000032ED                 mov     ebp, esp
.text$mn:000032EF                 mov     ecx, [ebp+arg_0]
.text$mn:000032F2                 call    ?max_size@?$allocator@_W@std@@QBEIXZ ; std::allocator<wchar_t>::max_size(void)
.text$mn:000032F7                 pop     ebp
.text$mn:000032F8                 retn
.text$mn:000032F8 ?max_size@?$allocator_traits@V?$allocator@_W@std@@@std@@SAIABV?$allocator@_W@2@@Z endp
.text$mn:000032F8
.text$mn:000032F8 ; ---------------------------------------------------------------------------
.text$mn:000032F9                 align 4
.text$mn:000032F9 _text$mn        ends
.text$mn:000032F9
.text$mn:000032FC ; ===========================================================================
.text$mn:000032FC
.text$mn:000032FC ; Segment type: Pure code
.text$mn:000032FC ; Segment permissions: Read/Execute
.text$mn:000032FC _text$mn        segment para public 'CODE' use32
.text$mn:000032FC                 assume cs:_text$mn
.text$mn:000032FC                 ;org 32FCh
.text$mn:000032FC ; COMDAT (pick any)
.text$mn:000032FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032FC
.text$mn:000032FC ; =============== S U B R O U T I N E =======================================
.text$mn:000032FC
.text$mn:000032FC ; Attributes: bp-based frame
.text$mn:000032FC
.text$mn:000032FC ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:000032FC                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:000032FC ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:000032FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:000032FC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:000032FC
.text$mn:000032FC var_10          = dword ptr -10h
.text$mn:000032FC var_C           = dword ptr -0Ch
.text$mn:000032FC var_8           = dword ptr -8
.text$mn:000032FC var_1           = byte ptr -1
.text$mn:000032FC
.text$mn:000032FC                 push    ebp
.text$mn:000032FD                 mov     ebp, esp
.text$mn:000032FF                 sub     esp, 10h
.text$mn:00003302                 mov     [ebp+var_10], ecx
.text$mn:00003305                 lea     eax, [ebp+var_1]
.text$mn:00003308                 push    eax
.text$mn:00003309                 mov     ecx, [ebp+var_10]
.text$mn:0000330C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003311                 mov     ecx, eax
.text$mn:00003313                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00003318                 mov     [ebp+var_8], eax
.text$mn:0000331B                 cmp     [ebp+var_8], 1
.text$mn:0000331F                 ja      short loc_332A
.text$mn:00003321                 mov     [ebp+var_C], 1
.text$mn:00003328                 jmp     short loc_3333
.text$mn:0000332A ; ---------------------------------------------------------------------------
.text$mn:0000332A
.text$mn:0000332A loc_332A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:0000332A                 mov     ecx, [ebp+var_8]
.text$mn:0000332D                 sub     ecx, 1
.text$mn:00003330                 mov     [ebp+var_C], ecx
.text$mn:00003333
.text$mn:00003333 loc_3333:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00003333                 mov     eax, [ebp+var_C]
.text$mn:00003336                 mov     esp, ebp
.text$mn:00003338                 pop     ebp
.text$mn:00003339                 retn
.text$mn:00003339 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003339
.text$mn:00003339 ; ---------------------------------------------------------------------------
.text$mn:0000333A                 align 4
.text$mn:0000333A _text$mn        ends
.text$mn:0000333A
.text$mn:0000333C ; ===========================================================================
.text$mn:0000333C
.text$mn:0000333C ; Segment type: Pure code
.text$mn:0000333C ; Segment permissions: Read/Execute
.text$mn:0000333C _text$mn        segment para public 'CODE' use32
.text$mn:0000333C                 assume cs:_text$mn
.text$mn:0000333C                 ;org 333Ch
.text$mn:0000333C ; COMDAT (pick any)
.text$mn:0000333C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000333C
.text$mn:0000333C ; =============== S U B R O U T I N E =======================================
.text$mn:0000333C
.text$mn:0000333C ; Attributes: bp-based frame
.text$mn:0000333C
.text$mn:0000333C ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::max_size(void)const
.text$mn:0000333C                 public ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:0000333C ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:0000333C                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+3Bp
.text$mn:0000333C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Copy(uint,uint)+6Ap ...
.text$mn:0000333C
.text$mn:0000333C var_10          = dword ptr -10h
.text$mn:0000333C var_C           = dword ptr -0Ch
.text$mn:0000333C var_8           = dword ptr -8
.text$mn:0000333C var_1           = byte ptr -1
.text$mn:0000333C
.text$mn:0000333C                 push    ebp
.text$mn:0000333D                 mov     ebp, esp
.text$mn:0000333F                 sub     esp, 10h
.text$mn:00003342                 mov     [ebp+var_10], ecx
.text$mn:00003345                 lea     eax, [ebp+var_1]
.text$mn:00003348                 push    eax
.text$mn:00003349                 mov     ecx, [ebp+var_10]
.text$mn:0000334C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@_W@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<wchar_t,std::allocator<wchar_t>>>::_Getal(void)
.text$mn:00003351                 mov     ecx, eax
.text$mn:00003353                 call    ?max_size@?$_Wrap_alloc@V?$allocator@_W@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<wchar_t>>::max_size(void)
.text$mn:00003358                 mov     [ebp+var_8], eax
.text$mn:0000335B                 cmp     [ebp+var_8], 1
.text$mn:0000335F                 ja      short loc_336A
.text$mn:00003361                 mov     [ebp+var_C], 1
.text$mn:00003368                 jmp     short loc_3373
.text$mn:0000336A ; ---------------------------------------------------------------------------
.text$mn:0000336A
.text$mn:0000336A loc_336A:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+23j
.text$mn:0000336A                 mov     ecx, [ebp+var_8]
.text$mn:0000336D                 sub     ecx, 1
.text$mn:00003370                 mov     [ebp+var_C], ecx
.text$mn:00003373
.text$mn:00003373 loc_3373:                               ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::max_size(void)+2Cj
.text$mn:00003373                 mov     eax, [ebp+var_C]
.text$mn:00003376                 mov     esp, ebp
.text$mn:00003378                 pop     ebp
.text$mn:00003379                 retn
.text$mn:00003379 ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00003379
.text$mn:00003379 ; ---------------------------------------------------------------------------
.text$mn:0000337A                 align 4
.text$mn:0000337A _text$mn        ends
.text$mn:0000337A
.text$mn:0000337C ; ===========================================================================
.text$mn:0000337C
.text$mn:0000337C ; Segment type: Pure code
.text$mn:0000337C ; Segment permissions: Read/Execute
.text$mn:0000337C _text$mn        segment para public 'CODE' use32
.text$mn:0000337C                 assume cs:_text$mn
.text$mn:0000337C                 ;org 337Ch
.text$mn:0000337C ; COMDAT (pick any)
.text$mn:0000337C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000337C
.text$mn:0000337C ; =============== S U B R O U T I N E =======================================
.text$mn:0000337C
.text$mn:0000337C ; Attributes: bp-based frame
.text$mn:0000337C
.text$mn:0000337C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:0000337C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000337C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:0000337C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:0000337C                                         ; DATA XREF: .rdata:00003E98o
.text$mn:0000337C
.text$mn:0000337C var_1C          = dword ptr -1Ch
.text$mn:0000337C var_18          = dword ptr -18h
.text$mn:0000337C Str             = dword ptr -14h
.text$mn:0000337C var_10          = dword ptr -10h
.text$mn:0000337C var_C           = dword ptr -0Ch
.text$mn:0000337C var_4           = dword ptr -4
.text$mn:0000337C arg_0           = dword ptr  8
.text$mn:0000337C arg_4           = dword ptr  0Ch
.text$mn:0000337C
.text$mn:0000337C                 push    ebp
.text$mn:0000337D                 mov     ebp, esp
.text$mn:0000337F                 push    0FFFFFFFFh
.text$mn:00003381                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003386                 mov     eax, large fs:0
.text$mn:0000338C                 push    eax
.text$mn:0000338D                 sub     esp, 10h
.text$mn:00003390                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003395                 xor     eax, ebp
.text$mn:00003397                 push    eax
.text$mn:00003398                 lea     eax, [ebp+var_C]
.text$mn:0000339B                 mov     large fs:0, eax
.text$mn:000033A1                 mov     [ebp+var_1C], ecx
.text$mn:000033A4                 mov     [ebp+var_18], 0
.text$mn:000033AB                 mov     eax, [ebp+arg_4]
.text$mn:000033AE                 push    eax             ; int
.text$mn:000033AF                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:000033B4                 add     esp, 4
.text$mn:000033B7                 mov     [ebp+var_10], eax
.text$mn:000033BA                 cmp     [ebp+var_10], 0
.text$mn:000033BE                 jz      short loc_33C8
.text$mn:000033C0                 mov     ecx, [ebp+var_10]
.text$mn:000033C3                 mov     [ebp+Str], ecx
.text$mn:000033C6                 jmp     short loc_33CF
.text$mn:000033C8 ; ---------------------------------------------------------------------------
.text$mn:000033C8
.text$mn:000033C8 loc_33C8:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:000033C8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:000033CF
.text$mn:000033CF loc_33CF:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:000033CF                 mov     edx, [ebp+Str]
.text$mn:000033D2                 push    edx             ; Str
.text$mn:000033D3                 mov     ecx, [ebp+arg_0]
.text$mn:000033D6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:000033DB                 mov     [ebp+var_4], 0
.text$mn:000033E2                 mov     eax, [ebp+var_18]
.text$mn:000033E5                 or      eax, 1
.text$mn:000033E8                 mov     [ebp+var_18], eax
.text$mn:000033EB                 mov     eax, [ebp+arg_0]
.text$mn:000033EE                 mov     ecx, [ebp+var_C]
.text$mn:000033F1                 mov     large fs:0, ecx
.text$mn:000033F8                 pop     ecx
.text$mn:000033F9                 mov     esp, ebp
.text$mn:000033FB                 pop     ebp
.text$mn:000033FC                 retn    8
.text$mn:000033FC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000033FC
.text$mn:000033FC ; ---------------------------------------------------------------------------
.text$mn:000033FF                 align 10h
.text$mn:000033FF _text$mn        ends
.text$mn:000033FF
.text$x:00003400 ; ===========================================================================
.text$x:00003400
.text$x:00003400 ; Segment type: Pure code
.text$x:00003400 ; Segment permissions: Read/Execute
.text$x:00003400 _text$x         segment para public 'CODE' use32
.text$x:00003400                 assume cs:_text$x
.text$x:00003400                 ;org 3400h
.text$x:00003400 ; COMDAT (pick associative to section at 337C)
.text$x:00003400                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003400
.text$x:00003400 ; =============== S U B R O U T I N E =======================================
.text$x:00003400
.text$x:00003400
.text$x:00003400 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00003400                                         ; DATA XREF: .xdata$x:000039C8o
.text$x:00003400                 mov     eax, [ebp-18h]
.text$x:00003403                 and     eax, 1
.text$x:00003406                 jz      $LN6
.text$x:0000340C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00003410                 mov     ecx, [ebp+8]
.text$x:00003413                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003418 ; ---------------------------------------------------------------------------
.text$x:00003418
.text$x:00003418 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003418                 retn
.text$x:00003418 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003418
.text$x:00003419
.text$x:00003419 ; =============== S U B R O U T I N E =======================================
.text$x:00003419
.text$x:00003419
.text$x:00003419 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003419                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00003419
.text$x:00003419 arg_4           = dword ptr  8
.text$x:00003419
.text$x:00003419                 mov     edx, [esp+arg_4]
.text$x:0000341D                 lea     eax, [edx+0Ch]
.text$x:00003420                 mov     ecx, [edx-14h]
.text$x:00003423                 xor     ecx, eax
.text$x:00003425                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000342A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:0000342F                 jmp     ___CxxFrameHandler3
.text$x:0000342F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:0000342F
.text$x:0000342F _text$x         ends
.text$x:0000342F
.text$mn:00003434 ; ===========================================================================
.text$mn:00003434
.text$mn:00003434 ; Segment type: Pure code
.text$mn:00003434 ; Segment permissions: Read/Execute
.text$mn:00003434 _text$mn        segment para public 'CODE' use32
.text$mn:00003434                 assume cs:_text$mn
.text$mn:00003434                 ;org 3434h
.text$mn:00003434 ; COMDAT (pick any)
.text$mn:00003434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003434
.text$mn:00003434 ; =============== S U B R O U T I N E =======================================
.text$mn:00003434
.text$mn:00003434 ; Attributes: bp-based frame
.text$mn:00003434
.text$mn:00003434 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00003434                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003434 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00003434                                         ; DATA XREF: .rdata:00003ECCo
.text$mn:00003434
.text$mn:00003434 var_14          = dword ptr -14h
.text$mn:00003434 var_10          = dword ptr -10h
.text$mn:00003434 var_C           = dword ptr -0Ch
.text$mn:00003434 var_4           = dword ptr -4
.text$mn:00003434 arg_0           = dword ptr  8
.text$mn:00003434 arg_4           = dword ptr  0Ch
.text$mn:00003434
.text$mn:00003434                 push    ebp
.text$mn:00003435                 mov     ebp, esp
.text$mn:00003437                 push    0FFFFFFFFh
.text$mn:00003439                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:0000343E                 mov     eax, large fs:0
.text$mn:00003444                 push    eax
.text$mn:00003445                 sub     esp, 8
.text$mn:00003448                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000344D                 xor     eax, ebp
.text$mn:0000344F                 push    eax
.text$mn:00003450                 lea     eax, [ebp+var_C]
.text$mn:00003453                 mov     large fs:0, eax
.text$mn:00003459                 mov     [ebp+var_14], ecx
.text$mn:0000345C                 mov     [ebp+var_10], 0
.text$mn:00003463                 cmp     [ebp+arg_4], 1
.text$mn:00003467                 jnz     short loc_348D
.text$mn:00003469                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:0000346E                 mov     ecx, [ebp+arg_0]
.text$mn:00003471                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003476                 mov     [ebp+var_4], 0
.text$mn:0000347D                 mov     eax, [ebp+var_10]
.text$mn:00003480                 or      eax, 1
.text$mn:00003483                 mov     [ebp+var_10], eax
.text$mn:00003486                 mov     eax, [ebp+arg_0]
.text$mn:00003489                 jmp     short loc_34B0
.text$mn:0000348B ; ---------------------------------------------------------------------------
.text$mn:0000348B                 jmp     short loc_34B0
.text$mn:0000348D ; ---------------------------------------------------------------------------
.text$mn:0000348D
.text$mn:0000348D loc_348D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:0000348D                 mov     ecx, [ebp+arg_4]
.text$mn:00003490                 push    ecx
.text$mn:00003491                 mov     edx, [ebp+arg_0]
.text$mn:00003494                 push    edx
.text$mn:00003495                 mov     ecx, [ebp+var_14]
.text$mn:00003498                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:0000349D                 mov     [ebp+var_4], 0
.text$mn:000034A4                 mov     eax, [ebp+var_10]
.text$mn:000034A7                 or      eax, 1
.text$mn:000034AA                 mov     [ebp+var_10], eax
.text$mn:000034AD                 mov     eax, [ebp+arg_0]
.text$mn:000034B0
.text$mn:000034B0 loc_34B0:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:000034B0                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:000034B0                 mov     ecx, [ebp+var_C]
.text$mn:000034B3                 mov     large fs:0, ecx
.text$mn:000034BA                 pop     ecx
.text$mn:000034BB                 mov     esp, ebp
.text$mn:000034BD                 pop     ebp
.text$mn:000034BE                 retn    8
.text$mn:000034BE ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:000034BE
.text$mn:000034BE ; ---------------------------------------------------------------------------
.text$mn:000034C1                 align 4
.text$mn:000034C1 _text$mn        ends
.text$mn:000034C1
.text$x:000034C4 ; ===========================================================================
.text$x:000034C4
.text$x:000034C4 ; Segment type: Pure code
.text$x:000034C4 ; Segment permissions: Read/Execute
.text$x:000034C4 _text$x         segment para public 'CODE' use32
.text$x:000034C4                 assume cs:_text$x
.text$x:000034C4                 ;org 34C4h
.text$x:000034C4 ; COMDAT (pick associative to section at 3434)
.text$x:000034C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000034C4
.text$x:000034C4 ; =============== S U B R O U T I N E =======================================
.text$x:000034C4
.text$x:000034C4
.text$x:000034C4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:000034C4                                         ; DATA XREF: .xdata$x:00003A4Co
.text$x:000034C4                 mov     eax, [ebp-10h]
.text$x:000034C7                 and     eax, 1
.text$x:000034CA                 jz      $LN6_0
.text$x:000034D0                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:000034D4                 mov     ecx, [ebp+8]
.text$x:000034D7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:000034DC ; ---------------------------------------------------------------------------
.text$x:000034DC
.text$x:000034DC $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:000034DC                 retn
.text$x:000034DC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:000034DC
.text$x:000034DD
.text$x:000034DD ; =============== S U B R O U T I N E =======================================
.text$x:000034DD
.text$x:000034DD
.text$x:000034DD __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:000034DD                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:000034DD
.text$x:000034DD arg_4           = dword ptr  8
.text$x:000034DD
.text$x:000034DD                 mov     edx, [esp+arg_4]
.text$x:000034E1                 lea     eax, [edx+0Ch]
.text$x:000034E4                 mov     ecx, [edx-0Ch]
.text$x:000034E7                 xor     ecx, eax
.text$x:000034E9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000034EE                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000034F3                 jmp     ___CxxFrameHandler3
.text$x:000034F3 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000034F3
.text$x:000034F3 _text$x         ends
.text$x:000034F3
.text$mn:000034F8 ; ===========================================================================
.text$mn:000034F8
.text$mn:000034F8 ; Segment type: Pure code
.text$mn:000034F8 ; Segment permissions: Read/Execute
.text$mn:000034F8 _text$mn        segment para public 'CODE' use32
.text$mn:000034F8                 assume cs:_text$mn
.text$mn:000034F8                 ;org 34F8h
.text$mn:000034F8 ; COMDAT (pick any)
.text$mn:000034F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034F8
.text$mn:000034F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000034F8
.text$mn:000034F8 ; Attributes: bp-based frame
.text$mn:000034F8
.text$mn:000034F8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:000034F8                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:000034F8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:000034F8                                         ; DATA XREF: .rdata:00003F0Co
.text$mn:000034F8
.text$mn:000034F8 var_1C          = dword ptr -1Ch
.text$mn:000034F8 var_18          = dword ptr -18h
.text$mn:000034F8 Str             = dword ptr -14h
.text$mn:000034F8 var_10          = dword ptr -10h
.text$mn:000034F8 var_C           = dword ptr -0Ch
.text$mn:000034F8 var_4           = dword ptr -4
.text$mn:000034F8 arg_0           = dword ptr  8
.text$mn:000034F8 arg_4           = dword ptr  0Ch
.text$mn:000034F8
.text$mn:000034F8                 push    ebp
.text$mn:000034F9                 mov     ebp, esp
.text$mn:000034FB                 push    0FFFFFFFFh
.text$mn:000034FD                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00003502                 mov     eax, large fs:0
.text$mn:00003508                 push    eax
.text$mn:00003509                 sub     esp, 10h
.text$mn:0000350C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003511                 xor     eax, ebp
.text$mn:00003513                 push    eax
.text$mn:00003514                 lea     eax, [ebp+var_C]
.text$mn:00003517                 mov     large fs:0, eax
.text$mn:0000351D                 mov     [ebp+var_1C], ecx
.text$mn:00003520                 mov     [ebp+var_18], 0
.text$mn:00003527                 mov     eax, [ebp+arg_4]
.text$mn:0000352A                 push    eax             ; int
.text$mn:0000352B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00003530                 add     esp, 4
.text$mn:00003533                 mov     [ebp+var_10], eax
.text$mn:00003536                 cmp     [ebp+var_10], 0
.text$mn:0000353A                 jz      short loc_3544
.text$mn:0000353C                 mov     ecx, [ebp+var_10]
.text$mn:0000353F                 mov     [ebp+Str], ecx
.text$mn:00003542                 jmp     short loc_354B
.text$mn:00003544 ; ---------------------------------------------------------------------------
.text$mn:00003544
.text$mn:00003544 loc_3544:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00003544                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:0000354B
.text$mn:0000354B loc_354B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:0000354B                 mov     edx, [ebp+Str]
.text$mn:0000354E                 push    edx             ; Str
.text$mn:0000354F                 mov     ecx, [ebp+arg_0]
.text$mn:00003552                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00003557                 mov     [ebp+var_4], 0
.text$mn:0000355E                 mov     eax, [ebp+var_18]
.text$mn:00003561                 or      eax, 1
.text$mn:00003564                 mov     [ebp+var_18], eax
.text$mn:00003567                 mov     eax, [ebp+arg_0]
.text$mn:0000356A                 mov     ecx, [ebp+var_C]
.text$mn:0000356D                 mov     large fs:0, ecx
.text$mn:00003574                 pop     ecx
.text$mn:00003575                 mov     esp, ebp
.text$mn:00003577                 pop     ebp
.text$mn:00003578                 retn    8
.text$mn:00003578 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00003578
.text$mn:00003578 ; ---------------------------------------------------------------------------
.text$mn:0000357B                 align 4
.text$mn:0000357B _text$mn        ends
.text$mn:0000357B
.text$x:0000357C ; ===========================================================================
.text$x:0000357C
.text$x:0000357C ; Segment type: Pure code
.text$x:0000357C ; Segment permissions: Read/Execute
.text$x:0000357C _text$x         segment para public 'CODE' use32
.text$x:0000357C                 assume cs:_text$x
.text$x:0000357C                 ;org 357Ch
.text$x:0000357C ; COMDAT (pick associative to section at 34F8)
.text$x:0000357C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000357C
.text$x:0000357C ; =============== S U B R O U T I N E =======================================
.text$x:0000357C
.text$x:0000357C
.text$x:0000357C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:0000357C                                         ; DATA XREF: .xdata$x:00003AD0o
.text$x:0000357C                 mov     eax, [ebp-18h]
.text$x:0000357F                 and     eax, 1
.text$x:00003582                 jz      $LN6_1
.text$x:00003588                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:0000358C                 mov     ecx, [ebp+8]
.text$x:0000358F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00003594 ; ---------------------------------------------------------------------------
.text$x:00003594
.text$x:00003594 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00003594                 retn
.text$x:00003594 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00003594
.text$x:00003595
.text$x:00003595 ; =============== S U B R O U T I N E =======================================
.text$x:00003595
.text$x:00003595
.text$x:00003595 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00003595                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00003595
.text$x:00003595 arg_4           = dword ptr  8
.text$x:00003595
.text$x:00003595                 mov     edx, [esp+arg_4]
.text$x:00003599                 lea     eax, [edx+0Ch]
.text$x:0000359C                 mov     ecx, [edx-14h]
.text$x:0000359F                 xor     ecx, eax
.text$x:000035A1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000035A6                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:000035AB                 jmp     ___CxxFrameHandler3
.text$x:000035AB __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:000035AB
.text$x:000035AB _text$x         ends
.text$x:000035AB
.text$mn:000035B0 ; ===========================================================================
.text$mn:000035B0
.text$mn:000035B0 ; Segment type: Pure code
.text$mn:000035B0 ; Segment permissions: Read/Execute
.text$mn:000035B0 _text$mn        segment para public 'CODE' use32
.text$mn:000035B0                 assume cs:_text$mn
.text$mn:000035B0                 ;org 35B0h
.text$mn:000035B0 ; COMDAT (pick any)
.text$mn:000035B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035B0
.text$mn:000035B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035B0
.text$mn:000035B0 ; Attributes: bp-based frame
.text$mn:000035B0
.text$mn:000035B0 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:000035B0                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:000035B0 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:000035B0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:000035B0
.text$mn:000035B0 var_4           = dword ptr -4
.text$mn:000035B0 Dst             = dword ptr  8
.text$mn:000035B0 Src             = dword ptr  0Ch
.text$mn:000035B0 Size            = dword ptr  10h
.text$mn:000035B0
.text$mn:000035B0                 push    ebp
.text$mn:000035B1                 mov     ebp, esp
.text$mn:000035B3                 push    ecx
.text$mn:000035B4                 cmp     [ebp+Size], 0
.text$mn:000035B8                 jnz     short loc_35C2
.text$mn:000035BA                 mov     eax, [ebp+Dst]
.text$mn:000035BD                 mov     [ebp+var_4], eax
.text$mn:000035C0                 jmp     short loc_35D9
.text$mn:000035C2 ; ---------------------------------------------------------------------------
.text$mn:000035C2
.text$mn:000035C2 loc_35C2:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:000035C2                 mov     ecx, [ebp+Size]
.text$mn:000035C5                 push    ecx             ; Size
.text$mn:000035C6                 mov     edx, [ebp+Src]
.text$mn:000035C9                 push    edx             ; Src
.text$mn:000035CA                 mov     eax, [ebp+Dst]
.text$mn:000035CD                 push    eax             ; Dst
.text$mn:000035CE                 call    _memmove
.text$mn:000035D3                 add     esp, 0Ch
.text$mn:000035D6                 mov     [ebp+var_4], eax
.text$mn:000035D9
.text$mn:000035D9 loc_35D9:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:000035D9                 mov     eax, [ebp+var_4]
.text$mn:000035DC                 mov     esp, ebp
.text$mn:000035DE                 pop     ebp
.text$mn:000035DF                 retn
.text$mn:000035DF ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000035DF
.text$mn:000035DF _text$mn        ends
.text$mn:000035DF
.text$mn:000035E0 ; ===========================================================================
.text$mn:000035E0
.text$mn:000035E0 ; Segment type: Pure code
.text$mn:000035E0 ; Segment permissions: Read/Execute
.text$mn:000035E0 _text$mn        segment para public 'CODE' use32
.text$mn:000035E0                 assume cs:_text$mn
.text$mn:000035E0                 ;org 35E0h
.text$mn:000035E0 ; COMDAT (pick any)
.text$mn:000035E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000035E0
.text$mn:000035E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000035E0
.text$mn:000035E0 ; Attributes: bp-based frame
.text$mn:000035E0
.text$mn:000035E0 ; int __cdecl std::char_traits<wchar_t>::move(void *Dst, void *Src, int)
.text$mn:000035E0                 public ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z
.text$mn:000035E0 ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z proc near
.text$mn:000035E0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::erase(uint,uint)+70p
.text$mn:000035E0
.text$mn:000035E0 var_4           = dword ptr -4
.text$mn:000035E0 Dst             = dword ptr  8
.text$mn:000035E0 Src             = dword ptr  0Ch
.text$mn:000035E0 arg_8           = dword ptr  10h
.text$mn:000035E0
.text$mn:000035E0                 push    ebp
.text$mn:000035E1                 mov     ebp, esp
.text$mn:000035E3                 push    ecx
.text$mn:000035E4                 cmp     [ebp+arg_8], 0
.text$mn:000035E8                 jnz     short loc_35F2
.text$mn:000035EA                 mov     eax, [ebp+Dst]
.text$mn:000035ED                 mov     [ebp+var_4], eax
.text$mn:000035F0                 jmp     short loc_3609
.text$mn:000035F2 ; ---------------------------------------------------------------------------
.text$mn:000035F2
.text$mn:000035F2 loc_35F2:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+8j
.text$mn:000035F2                 mov     ecx, [ebp+arg_8]
.text$mn:000035F5                 push    ecx             ; int
.text$mn:000035F6                 mov     edx, [ebp+Src]
.text$mn:000035F9                 push    edx             ; Src
.text$mn:000035FA                 mov     eax, [ebp+Dst]
.text$mn:000035FD                 push    eax             ; Dst
.text$mn:000035FE                 call    _wmemmove
.text$mn:00003603                 add     esp, 0Ch
.text$mn:00003606                 mov     [ebp+var_4], eax
.text$mn:00003609
.text$mn:00003609 loc_3609:                               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+10j
.text$mn:00003609                 mov     eax, [ebp+var_4]
.text$mn:0000360C                 mov     esp, ebp
.text$mn:0000360E                 pop     ebp
.text$mn:0000360F                 retn
.text$mn:0000360F ?move@?$char_traits@_W@std@@SAPA_WPA_WPB_WI@Z endp
.text$mn:0000360F
.text$mn:0000360F _text$mn        ends
.text$mn:0000360F
.text$mn:00003610 ; ===========================================================================
.text$mn:00003610
.text$mn:00003610 ; Segment type: Pure code
.text$mn:00003610 ; Segment permissions: Read/Execute
.text$mn:00003610 _text$mn        segment para public 'CODE' use32
.text$mn:00003610                 assume cs:_text$mn
.text$mn:00003610                 ;org 3610h
.text$mn:00003610 ; COMDAT (pick any)
.text$mn:00003610                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003610
.text$mn:00003610 ; =============== S U B R O U T I N E =======================================
.text$mn:00003610
.text$mn:00003610 ; Attributes: bp-based frame
.text$mn:00003610
.text$mn:00003610 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00003610                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00003610 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00003610                                         ; DATA XREF: .rdata:00003E94o
.text$mn:00003610
.text$mn:00003610 var_4           = dword ptr -4
.text$mn:00003610
.text$mn:00003610                 push    ebp
.text$mn:00003611                 mov     ebp, esp
.text$mn:00003613                 push    ecx
.text$mn:00003614                 mov     [ebp+var_4], ecx
.text$mn:00003617                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:0000361C                 mov     esp, ebp
.text$mn:0000361E                 pop     ebp
.text$mn:0000361F                 retn
.text$mn:0000361F ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:0000361F
.text$mn:0000361F _text$mn        ends
.text$mn:0000361F
.text$mn:00003620 ; ===========================================================================
.text$mn:00003620
.text$mn:00003620 ; Segment type: Pure code
.text$mn:00003620 ; Segment permissions: Read/Execute
.text$mn:00003620 _text$mn        segment para public 'CODE' use32
.text$mn:00003620                 assume cs:_text$mn
.text$mn:00003620                 ;org 3620h
.text$mn:00003620 ; COMDAT (pick any)
.text$mn:00003620                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003620
.text$mn:00003620 ; =============== S U B R O U T I N E =======================================
.text$mn:00003620
.text$mn:00003620 ; Attributes: bp-based frame
.text$mn:00003620
.text$mn:00003620 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00003620                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00003620 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00003620                                         ; DATA XREF: .rdata:00003EC8o
.text$mn:00003620
.text$mn:00003620 var_4           = dword ptr -4
.text$mn:00003620
.text$mn:00003620                 push    ebp
.text$mn:00003621                 mov     ebp, esp
.text$mn:00003623                 push    ecx
.text$mn:00003624                 mov     [ebp+var_4], ecx
.text$mn:00003627                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:0000362C                 mov     esp, ebp
.text$mn:0000362E                 pop     ebp
.text$mn:0000362F                 retn
.text$mn:0000362F ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:0000362F
.text$mn:0000362F _text$mn        ends
.text$mn:0000362F
.text$mn:00003630 ; ===========================================================================
.text$mn:00003630
.text$mn:00003630 ; Segment type: Pure code
.text$mn:00003630 ; Segment permissions: Read/Execute
.text$mn:00003630 _text$mn        segment para public 'CODE' use32
.text$mn:00003630                 assume cs:_text$mn
.text$mn:00003630                 ;org 3630h
.text$mn:00003630 ; COMDAT (pick any)
.text$mn:00003630                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003630
.text$mn:00003630 ; =============== S U B R O U T I N E =======================================
.text$mn:00003630
.text$mn:00003630 ; Attributes: bp-based frame
.text$mn:00003630
.text$mn:00003630 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00003630                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00003630 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00003630                                         ; DATA XREF: .rdata:00003F08o
.text$mn:00003630
.text$mn:00003630 var_4           = dword ptr -4
.text$mn:00003630
.text$mn:00003630                 push    ebp
.text$mn:00003631                 mov     ebp, esp
.text$mn:00003633                 push    ecx
.text$mn:00003634                 mov     [ebp+var_4], ecx
.text$mn:00003637                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:0000363C                 mov     esp, ebp
.text$mn:0000363E                 pop     ebp
.text$mn:0000363F                 retn
.text$mn:0000363F ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:0000363F
.text$mn:0000363F _text$mn        ends
.text$mn:0000363F
.text$mn:00003640 ; ===========================================================================
.text$mn:00003640
.text$mn:00003640 ; Segment type: Pure code
.text$mn:00003640 ; Segment permissions: Read/Execute
.text$mn:00003640 _text$mn        segment para public 'CODE' use32
.text$mn:00003640                 assume cs:_text$mn
.text$mn:00003640                 ;org 3640h
.text$mn:00003640 ; COMDAT (pick any)
.text$mn:00003640                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003640
.text$mn:00003640 ; =============== S U B R O U T I N E =======================================
.text$mn:00003640
.text$mn:00003640 ; Attributes: bp-based frame
.text$mn:00003640
.text$mn:00003640 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00003640                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00003640 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00003640                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00003640                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00003640
.text$mn:00003640 var_4           = dword ptr -4
.text$mn:00003640
.text$mn:00003640                 push    ebp
.text$mn:00003641                 mov     ebp, esp
.text$mn:00003643                 push    ecx
.text$mn:00003644                 mov     [ebp+var_4], ecx
.text$mn:00003647                 mov     eax, [ebp+var_4]
.text$mn:0000364A                 mov     eax, [eax+14h]
.text$mn:0000364D                 mov     esp, ebp
.text$mn:0000364F                 pop     ebp
.text$mn:00003650                 retn
.text$mn:00003650 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00003650
.text$mn:00003650 ; ---------------------------------------------------------------------------
.text$mn:00003651                 align 4
.text$mn:00003651 _text$mn        ends
.text$mn:00003651
.text$mn:00003654 ; ===========================================================================
.text$mn:00003654
.text$mn:00003654 ; Segment type: Pure code
.text$mn:00003654 ; Segment permissions: Read/Execute
.text$mn:00003654 _text$mn        segment para public 'CODE' use32
.text$mn:00003654                 assume cs:_text$mn
.text$mn:00003654                 ;org 3654h
.text$mn:00003654 ; COMDAT (pick any)
.text$mn:00003654                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003654
.text$mn:00003654 ; =============== S U B R O U T I N E =======================================
.text$mn:00003654
.text$mn:00003654 ; Attributes: bp-based frame
.text$mn:00003654
.text$mn:00003654 ; public: unsigned int __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::size(void)const
.text$mn:00003654                 public ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ
.text$mn:00003654 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ proc near
.text$mn:00003654                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+Cp
.text$mn:00003654                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::assign(std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>> const &,uint,uint)+21p
.text$mn:00003654
.text$mn:00003654 var_4           = dword ptr -4
.text$mn:00003654
.text$mn:00003654                 push    ebp
.text$mn:00003655                 mov     ebp, esp
.text$mn:00003657                 push    ecx
.text$mn:00003658                 mov     [ebp+var_4], ecx
.text$mn:0000365B                 mov     eax, [ebp+var_4]
.text$mn:0000365E                 mov     eax, [eax+14h]
.text$mn:00003661                 mov     esp, ebp
.text$mn:00003663                 pop     ebp
.text$mn:00003664                 retn
.text$mn:00003664 ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ endp
.text$mn:00003664
.text$mn:00003664 ; ---------------------------------------------------------------------------
.text$mn:00003665                 align 4
.text$mn:00003665 _text$mn        ends
.text$mn:00003665
.text$mn:00003668 ; ===========================================================================
.text$mn:00003668
.text$mn:00003668 ; Segment type: Pure code
.text$mn:00003668 ; Segment permissions: Read/Execute
.text$mn:00003668 _text$mn        segment para public 'CODE' use32
.text$mn:00003668                 assume cs:_text$mn
.text$mn:00003668                 ;org 3668h
.text$mn:00003668 ; COMDAT (pick any)
.text$mn:00003668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003668
.text$mn:00003668 ; =============== S U B R O U T I N E =======================================
.text$mn:00003668
.text$mn:00003668 ; Attributes: bp-based frame
.text$mn:00003668
.text$mn:00003668 ; __int32 __stdcall ListView::staticProc(HWND hWnd, UINT Msg, WPARAM wParam, __int32)
.text$mn:00003668                 public ?staticProc@ListView@@KGJPAUHWND__@@IIJ@Z
.text$mn:00003668 ?staticProc@ListView@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:00003668                                         ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+D2o
.text$mn:00003668
.text$mn:00003668 hWnd            = dword ptr  8
.text$mn:00003668 Msg             = dword ptr  0Ch
.text$mn:00003668 wParam          = dword ptr  10h
.text$mn:00003668 arg_C           = dword ptr  14h
.text$mn:00003668
.text$mn:00003668                 push    ebp
.text$mn:00003669                 mov     ebp, esp
.text$mn:0000366B                 mov     eax, [ebp+arg_C]
.text$mn:0000366E                 push    eax             ; __int32
.text$mn:0000366F                 mov     ecx, [ebp+wParam]
.text$mn:00003672                 push    ecx             ; wParam
.text$mn:00003673                 mov     edx, [ebp+Msg]
.text$mn:00003676                 push    edx             ; Msg
.text$mn:00003677                 mov     eax, [ebp+hWnd]
.text$mn:0000367A                 push    eax             ; hWnd
.text$mn:0000367B                 push    0FFFFFFEBh      ; nIndex
.text$mn:0000367D                 mov     ecx, [ebp+hWnd]
.text$mn:00003680                 push    ecx             ; hWnd
.text$mn:00003681                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:00003687                 mov     ecx, eax        ; this
.text$mn:00003689                 call    ?runProc@ListView@@IAEJPAUHWND__@@IIJ@Z ; ListView::runProc(HWND__ *,uint,uint,long)
.text$mn:0000368E                 pop     ebp
.text$mn:0000368F                 retn    10h
.text$mn:0000368F ?staticProc@ListView@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:0000368F
.text$mn:0000368F ; ---------------------------------------------------------------------------
.text$mn:00003692                 align 4
.text$mn:00003692 _text$mn        ends
.text$mn:00003692
.text$mn:00003694 ; ===========================================================================
.text$mn:00003694
.text$mn:00003694 ; Segment type: Pure code
.text$mn:00003694 ; Segment permissions: Read/Execute
.text$mn:00003694 _text$mn        segment para public 'CODE' use32
.text$mn:00003694                 assume cs:_text$mn
.text$mn:00003694                 ;org 3694h
.text$mn:00003694 ; COMDAT (pick any)
.text$mn:00003694                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003694
.text$mn:00003694 ; =============== S U B R O U T I N E =======================================
.text$mn:00003694
.text$mn:00003694 ; Attributes: bp-based frame
.text$mn:00003694
.text$mn:00003694 ; int swprintf(wchar_t *Dest, const wchar_t *Format, ...)
.text$mn:00003694                 public ?swprintf@@YAHPA_WPB_WZZ
.text$mn:00003694 ?swprintf@@YAHPA_WPB_WZZ proc near      ; CODE XREF: ListView::setValues(int)+6Dp
.text$mn:00003694                                         ; ListView::setValues(int)+82p
.text$mn:00003694
.text$mn:00003694 var_8           = dword ptr -8
.text$mn:00003694 Args            = dword ptr -4
.text$mn:00003694 Dest            = dword ptr  8
.text$mn:00003694 Format          = dword ptr  0Ch
.text$mn:00003694 arg_8           = byte ptr  10h
.text$mn:00003694
.text$mn:00003694                 push    ebp
.text$mn:00003695                 mov     ebp, esp
.text$mn:00003697                 sub     esp, 8
.text$mn:0000369A                 lea     eax, [ebp+arg_8]
.text$mn:0000369D                 mov     [ebp+Args], eax
.text$mn:000036A0                 mov     ecx, [ebp+Args]
.text$mn:000036A3                 push    ecx             ; Args
.text$mn:000036A4                 mov     edx, [ebp+Format]
.text$mn:000036A7                 push    edx             ; Format
.text$mn:000036A8                 mov     eax, [ebp+Dest]
.text$mn:000036AB                 push    eax             ; Dest
.text$mn:000036AC                 call    __vswprintf
.text$mn:000036B1                 add     esp, 0Ch
.text$mn:000036B4                 mov     [ebp+var_8], eax
.text$mn:000036B7                 mov     [ebp+Args], 0
.text$mn:000036BE                 mov     eax, [ebp+var_8]
.text$mn:000036C1                 mov     esp, ebp
.text$mn:000036C3                 pop     ebp
.text$mn:000036C4                 retn
.text$mn:000036C4 ?swprintf@@YAHPA_WPB_WZZ endp
.text$mn:000036C4
.text$mn:000036C4 ; ---------------------------------------------------------------------------
.text$mn:000036C5                 align 4
.text$mn:000036C5 _text$mn        ends
.text$mn:000036C5
.text$mn:000036C8 ; ===========================================================================
.text$mn:000036C8
.text$mn:000036C8 ; Segment type: Pure code
.text$mn:000036C8 ; Segment permissions: Read/Execute
.text$mn:000036C8 _text$mn        segment para public 'CODE' use32
.text$mn:000036C8                 assume cs:_text$mn
.text$mn:000036C8                 ;org 36C8h
.text$mn:000036C8 ; COMDAT (pick any)
.text$mn:000036C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036C8
.text$mn:000036C8 ; =============== S U B R O U T I N E =======================================
.text$mn:000036C8
.text$mn:000036C8 ; Attributes: bp-based frame
.text$mn:000036C8
.text$mn:000036C8 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:000036C8                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:000036C8 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000036C8                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2FB4p
.text$mn:000036C8                 push    ebp
.text$mn:000036C9                 mov     ebp, esp
.text$mn:000036CB                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:000036D0                 pop     ebp
.text$mn:000036D1                 retn
.text$mn:000036D1 ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000036D1
.text$mn:000036D1 ; ---------------------------------------------------------------------------
.text$mn:000036D2                 align 4
.text$mn:000036D2 _text$mn        ends
.text$mn:000036D2
.text$mn:000036D4 ; ===========================================================================
.text$mn:000036D4
.text$mn:000036D4 ; Segment type: Pure code
.text$mn:000036D4 ; Segment permissions: Read/Execute
.text$mn:000036D4 _text$mn        segment para public 'CODE' use32
.text$mn:000036D4                 assume cs:_text$mn
.text$mn:000036D4                 ;org 36D4h
.text$mn:000036D4 ; COMDAT (pick any)
.text$mn:000036D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036D4
.text$mn:000036D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036D4
.text$mn:000036D4 ; Attributes: bp-based frame
.text$mn:000036D4
.text$mn:000036D4 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:000036D4                 public ?value@error_code@std@@QBEHXZ
.text$mn:000036D4 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:000036D4
.text$mn:000036D4 var_4           = dword ptr -4
.text$mn:000036D4
.text$mn:000036D4                 push    ebp
.text$mn:000036D5                 mov     ebp, esp
.text$mn:000036D7                 push    ecx
.text$mn:000036D8                 mov     [ebp+var_4], ecx
.text$mn:000036DB                 mov     eax, [ebp+var_4]
.text$mn:000036DE                 mov     eax, [eax]
.text$mn:000036E0                 mov     esp, ebp
.text$mn:000036E2                 pop     ebp
.text$mn:000036E3                 retn
.text$mn:000036E3 ?value@error_code@std@@QBEHXZ endp
.text$mn:000036E3
.text$mn:000036E3 _text$mn        ends
.text$mn:000036E3
.text$mn:000036E4 ; ===========================================================================
.text$mn:000036E4
.text$mn:000036E4 ; Segment type: Pure code
.text$mn:000036E4 ; Segment permissions: Read/Execute
.text$mn:000036E4 _text$mn        segment para public 'CODE' use32
.text$mn:000036E4                 assume cs:_text$mn
.text$mn:000036E4                 ;org 36E4h
.text$mn:000036E4 ; COMDAT (pick any)
.text$mn:000036E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036E4
.text$mn:000036E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036E4
.text$mn:000036E4 ; Attributes: bp-based frame
.text$mn:000036E4
.text$mn:000036E4 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:000036E4                 public ?value@error_condition@std@@QBEHXZ
.text$mn:000036E4 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:000036E4                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:000036E4                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:000036E4
.text$mn:000036E4 var_4           = dword ptr -4
.text$mn:000036E4
.text$mn:000036E4                 push    ebp
.text$mn:000036E5                 mov     ebp, esp
.text$mn:000036E7                 push    ecx
.text$mn:000036E8                 mov     [ebp+var_4], ecx
.text$mn:000036EB                 mov     eax, [ebp+var_4]
.text$mn:000036EE                 mov     eax, [eax]
.text$mn:000036F0                 mov     esp, ebp
.text$mn:000036F2                 pop     ebp
.text$mn:000036F3                 retn
.text$mn:000036F3 ?value@error_condition@std@@QBEHXZ endp
.text$mn:000036F3
.text$mn:000036F3 _text$mn        ends
.text$mn:000036F3
.text$mn:000036F4 ; ===========================================================================
.text$mn:000036F4
.text$mn:000036F4 ; Segment type: Pure code
.text$mn:000036F4 ; Segment permissions: Read/Execute
.text$mn:000036F4 _text$mn        segment para public 'CODE' use32
.text$mn:000036F4                 assume cs:_text$mn
.text$mn:000036F4                 ;org 36F4h
.text$mn:000036F4 ; COMDAT (pick any)
.text$mn:000036F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036F4
.text$mn:000036F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000036F4
.text$mn:000036F4 ; Attributes: bp-based frame
.text$mn:000036F4
.text$mn:000036F4                 public _hypot
.text$mn:000036F4 _hypot          proc near
.text$mn:000036F4
.text$mn:000036F4 var_10          = qword ptr -10h
.text$mn:000036F4 var_8           = qword ptr -8
.text$mn:000036F4 arg_0           = qword ptr  8
.text$mn:000036F4 arg_8           = qword ptr  10h
.text$mn:000036F4
.text$mn:000036F4                 push    ebp
.text$mn:000036F5                 mov     ebp, esp
.text$mn:000036F7                 sub     esp, 8
.text$mn:000036FA                 movsd   xmm0, [ebp+arg_8]
.text$mn:000036FF                 movsd   [esp+8+var_8], xmm0
.text$mn:00003704                 sub     esp, 8
.text$mn:00003707                 movsd   xmm0, [ebp+arg_0]
.text$mn:0000370C                 movsd   [esp+10h+var_10], xmm0
.text$mn:00003711                 call    __hypot
.text$mn:00003716                 add     esp, 10h
.text$mn:00003719                 pop     ebp
.text$mn:0000371A                 retn
.text$mn:0000371A _hypot          endp
.text$mn:0000371A
.text$mn:0000371A ; ---------------------------------------------------------------------------
.text$mn:0000371B                 align 4
.text$mn:0000371B _text$mn        ends
.text$mn:0000371B
.text$mn:0000371C ; ===========================================================================
.text$mn:0000371C
.text$mn:0000371C ; Segment type: Pure code
.text$mn:0000371C ; Segment permissions: Read/Execute
.text$mn:0000371C _text$mn        segment para public 'CODE' use32
.text$mn:0000371C                 assume cs:_text$mn
.text$mn:0000371C                 ;org 371Ch
.text$mn:0000371C ; COMDAT (pick any)
.text$mn:0000371C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000371C
.text$mn:0000371C ; =============== S U B R O U T I N E =======================================
.text$mn:0000371C
.text$mn:0000371C ; Attributes: bp-based frame
.text$mn:0000371C
.text$mn:0000371C ; int __cdecl wmemcpy(void *Dst, void *Src, int)
.text$mn:0000371C                 public _wmemcpy
.text$mn:0000371C _wmemcpy        proc near               ; CODE XREF: std::char_traits<wchar_t>::copy(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:0000371C
.text$mn:0000371C Dst             = dword ptr  8
.text$mn:0000371C Src             = dword ptr  0Ch
.text$mn:0000371C arg_8           = dword ptr  10h
.text$mn:0000371C
.text$mn:0000371C                 push    ebp
.text$mn:0000371D                 mov     ebp, esp
.text$mn:0000371F                 mov     eax, [ebp+arg_8]
.text$mn:00003722                 shl     eax, 1
.text$mn:00003724                 push    eax             ; Size
.text$mn:00003725                 mov     ecx, [ebp+Src]
.text$mn:00003728                 push    ecx             ; Src
.text$mn:00003729                 mov     edx, [ebp+Dst]
.text$mn:0000372C                 push    edx             ; Dst
.text$mn:0000372D                 call    _memcpy
.text$mn:00003732                 add     esp, 0Ch
.text$mn:00003735                 pop     ebp
.text$mn:00003736                 retn
.text$mn:00003736 _wmemcpy        endp
.text$mn:00003736
.text$mn:00003736 ; ---------------------------------------------------------------------------
.text$mn:00003737                 align 4
.text$mn:00003737 _text$mn        ends
.text$mn:00003737
.text$mn:00003738 ; ===========================================================================
.text$mn:00003738
.text$mn:00003738 ; Segment type: Pure code
.text$mn:00003738 ; Segment permissions: Read/Execute
.text$mn:00003738 _text$mn        segment para public 'CODE' use32
.text$mn:00003738                 assume cs:_text$mn
.text$mn:00003738                 ;org 3738h
.text$mn:00003738 ; COMDAT (pick any)
.text$mn:00003738                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003738
.text$mn:00003738 ; =============== S U B R O U T I N E =======================================
.text$mn:00003738
.text$mn:00003738 ; Attributes: bp-based frame
.text$mn:00003738
.text$mn:00003738 ; int __cdecl wmemmove(void *Dst, void *Src, int)
.text$mn:00003738                 public _wmemmove
.text$mn:00003738 _wmemmove       proc near               ; CODE XREF: std::char_traits<wchar_t>::move(wchar_t *,wchar_t const *,uint)+1Ep
.text$mn:00003738
.text$mn:00003738 Dst             = dword ptr  8
.text$mn:00003738 Src             = dword ptr  0Ch
.text$mn:00003738 arg_8           = dword ptr  10h
.text$mn:00003738
.text$mn:00003738                 push    ebp
.text$mn:00003739                 mov     ebp, esp
.text$mn:0000373B                 mov     eax, [ebp+arg_8]
.text$mn:0000373E                 shl     eax, 1
.text$mn:00003740                 push    eax             ; Size
.text$mn:00003741                 mov     ecx, [ebp+Src]
.text$mn:00003744                 push    ecx             ; Src
.text$mn:00003745                 mov     edx, [ebp+Dst]
.text$mn:00003748                 push    edx             ; Dst
.text$mn:00003749                 call    _memmove
.text$mn:0000374E                 add     esp, 0Ch
.text$mn:00003751                 pop     ebp
.text$mn:00003752                 retn
.text$mn:00003752 _wmemmove       endp
.text$mn:00003752
.text$mn:00003752 ; ---------------------------------------------------------------------------
.text$mn:00003753                 align 4
.text$mn:00003753 _text$mn        ends
.text$mn:00003753
.xdata$x:00003754 ; ===========================================================================
.xdata$x:00003754
.xdata$x:00003754 ; Segment type: Pure data
.xdata$x:00003754 ; Segment permissions: Read
.xdata$x:00003754 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003754                 assume cs:_xdata$x
.xdata$x:00003754                 ;org 3754h
.xdata$x:00003754 ; COMDAT (pick associative to section at 2830)
.xdata$x:00003754 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00003754                                         ; DATA XREF: .xdata$x:00003764o
.xdata$x:00003755                 db 0FFh
.xdata$x:00003756                 db 0FFh
.xdata$x:00003757                 db 0FFh
.xdata$x:00003758                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:0000375C __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:0000375C                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:0000375D                 db    5
.xdata$x:0000375E                 db  93h ; 
.xdata$x:0000375F                 db  19h
.xdata$x:00003760                 db    1
.xdata$x:00003761                 db    0
.xdata$x:00003762                 db    0
.xdata$x:00003763                 db    0
.xdata$x:00003764                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00003768                 align 20h
.xdata$x:00003768 _xdata$x        ends
.xdata$x:00003768
.xdata$x:00003780 ; ===========================================================================
.xdata$x:00003780
.xdata$x:00003780 ; Segment type: Pure data
.xdata$x:00003780 ; Segment permissions: Read
.xdata$x:00003780 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003780                 assume cs:_xdata$x
.xdata$x:00003780                 ;org 3780h
.xdata$x:00003780 ; COMDAT (pick associative to section at 1388)
.xdata$x:00003780 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003780                                         ; DATA XREF: .xdata$x:00003790o
.xdata$x:00003781                 db 0FFh
.xdata$x:00003782                 db 0FFh
.xdata$x:00003783                 db 0FFh
.xdata$x:00003784                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00003788 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003788                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00003789                 db    5
.xdata$x:0000378A                 db  93h ; 
.xdata$x:0000378B                 db  19h
.xdata$x:0000378C                 db    1
.xdata$x:0000378D                 db    0
.xdata$x:0000378E                 db    0
.xdata$x:0000378F                 db    0
.xdata$x:00003790                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00003794                 db    0
.xdata$x:00003795                 db    0
.xdata$x:00003796                 db    0
.xdata$x:00003797                 db    0
.xdata$x:00003798                 db    0
.xdata$x:00003799                 db    0
.xdata$x:0000379A                 db    0
.xdata$x:0000379B                 db    0
.xdata$x:0000379C                 db    0
.xdata$x:0000379D                 db    0
.xdata$x:0000379E                 db    0
.xdata$x:0000379F                 db    0
.xdata$x:000037A0                 db    0
.xdata$x:000037A1                 db    0
.xdata$x:000037A2                 db    0
.xdata$x:000037A3                 db    0
.xdata$x:000037A4                 db    0
.xdata$x:000037A5                 db    0
.xdata$x:000037A6                 db    0
.xdata$x:000037A7                 db    0
.xdata$x:000037A8                 db    0
.xdata$x:000037A9                 db    0
.xdata$x:000037AA                 db    0
.xdata$x:000037AB                 db    0
.xdata$x:000037AB _xdata$x        ends
.xdata$x:000037AB
.xdata$x:000037AC ; ===========================================================================
.xdata$x:000037AC
.xdata$x:000037AC ; Segment type: Pure data
.xdata$x:000037AC ; Segment permissions: Read
.xdata$x:000037AC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000037AC                 assume cs:_xdata$x
.xdata$x:000037AC                 ;org 37ACh
.xdata$x:000037AC ; COMDAT (pick associative to section at 1A24)
.xdata$x:000037AC __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000037AC                                         ; DATA XREF: .xdata$x:000037BCo
.xdata$x:000037AD                 db 0FFh
.xdata$x:000037AE                 db 0FFh
.xdata$x:000037AF                 db 0FFh
.xdata$x:000037B0                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000037B4 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000037B4                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000037B5                 db    5
.xdata$x:000037B6                 db  93h ; 
.xdata$x:000037B7                 db  19h
.xdata$x:000037B8                 db    1
.xdata$x:000037B9                 db    0
.xdata$x:000037BA                 db    0
.xdata$x:000037BB                 db    0
.xdata$x:000037BC                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000037C0                 db    0
.xdata$x:000037C1                 db    0
.xdata$x:000037C2                 db    0
.xdata$x:000037C3                 db    0
.xdata$x:000037C4                 db    0
.xdata$x:000037C5                 db    0
.xdata$x:000037C6                 db    0
.xdata$x:000037C7                 db    0
.xdata$x:000037C8                 db    0
.xdata$x:000037C9                 db    0
.xdata$x:000037CA                 db    0
.xdata$x:000037CB                 db    0
.xdata$x:000037CC                 db    0
.xdata$x:000037CD                 db    0
.xdata$x:000037CE                 db    0
.xdata$x:000037CF                 db    0
.xdata$x:000037D0                 db    0
.xdata$x:000037D1                 db    0
.xdata$x:000037D2                 db    0
.xdata$x:000037D3                 db    0
.xdata$x:000037D4                 db    0
.xdata$x:000037D5                 db    0
.xdata$x:000037D6                 db    0
.xdata$x:000037D7                 db    0
.xdata$x:000037D7 _xdata$x        ends
.xdata$x:000037D7
.xdata$x:000037D8 ; ===========================================================================
.xdata$x:000037D8
.xdata$x:000037D8 ; Segment type: Pure data
.xdata$x:000037D8 ; Segment permissions: Read
.xdata$x:000037D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000037D8                 assume cs:_xdata$x
.xdata$x:000037D8                 ;org 37D8h
.xdata$x:000037D8 ; COMDAT (pick associative to section at 1290)
.xdata$x:000037D8 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:000037D8                                         ; DATA XREF: .xdata$x:000037E8o
.xdata$x:000037D9                 db 0FFh
.xdata$x:000037DA                 db 0FFh
.xdata$x:000037DB                 db 0FFh
.xdata$x:000037DC                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:000037E0 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:000037E0                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:000037E1                 db    5
.xdata$x:000037E2                 db  93h ; 
.xdata$x:000037E3                 db  19h
.xdata$x:000037E4                 db    1
.xdata$x:000037E5                 db    0
.xdata$x:000037E6                 db    0
.xdata$x:000037E7                 db    0
.xdata$x:000037E8                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:000037EC                 db    0
.xdata$x:000037ED                 db    0
.xdata$x:000037EE                 db    0
.xdata$x:000037EF                 db    0
.xdata$x:000037F0                 db    0
.xdata$x:000037F1                 db    0
.xdata$x:000037F2                 db    0
.xdata$x:000037F3                 db    0
.xdata$x:000037F4                 db    0
.xdata$x:000037F5                 db    0
.xdata$x:000037F6                 db    0
.xdata$x:000037F7                 db    0
.xdata$x:000037F8                 db    0
.xdata$x:000037F9                 db    0
.xdata$x:000037FA                 db    0
.xdata$x:000037FB                 db    0
.xdata$x:000037FC                 db    0
.xdata$x:000037FD                 db    0
.xdata$x:000037FE                 db    0
.xdata$x:000037FF                 db    0
.xdata$x:00003800                 db    0
.xdata$x:00003801                 db    0
.xdata$x:00003802                 db    0
.xdata$x:00003803                 db    0
.xdata$x:00003803 _xdata$x        ends
.xdata$x:00003803
.xdata$x:00003804 ; ===========================================================================
.xdata$x:00003804
.xdata$x:00003804 ; Segment type: Pure data
.xdata$x:00003804 ; Segment permissions: Read
.xdata$x:00003804 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003804                 assume cs:_xdata$x
.xdata$x:00003804                 ;org 3804h
.xdata$x:00003804 ; COMDAT (pick associative to section at 1934)
.xdata$x:00003804 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003804                                         ; DATA XREF: .xdata$x:00003814o
.xdata$x:00003805                 db 0FFh
.xdata$x:00003806                 db 0FFh
.xdata$x:00003807                 db 0FFh
.xdata$x:00003808                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000380C __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000380C                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000380D                 db    5
.xdata$x:0000380E                 db  93h ; 
.xdata$x:0000380F                 db  19h
.xdata$x:00003810                 db    1
.xdata$x:00003811                 db    0
.xdata$x:00003812                 db    0
.xdata$x:00003813                 db    0
.xdata$x:00003814                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00003818                 db    0
.xdata$x:00003819                 db    0
.xdata$x:0000381A                 db    0
.xdata$x:0000381B                 db    0
.xdata$x:0000381C                 db    0
.xdata$x:0000381D                 db    0
.xdata$x:0000381E                 db    0
.xdata$x:0000381F                 db    0
.xdata$x:00003820                 db    0
.xdata$x:00003821                 db    0
.xdata$x:00003822                 db    0
.xdata$x:00003823                 db    0
.xdata$x:00003824                 db    0
.xdata$x:00003825                 db    0
.xdata$x:00003826                 db    0
.xdata$x:00003827                 db    0
.xdata$x:00003828                 db    0
.xdata$x:00003829                 db    0
.xdata$x:0000382A                 db    0
.xdata$x:0000382B                 db    0
.xdata$x:0000382C                 db    0
.xdata$x:0000382D                 db    0
.xdata$x:0000382E                 db    0
.xdata$x:0000382F                 db    0
.xdata$x:0000382F _xdata$x        ends
.xdata$x:0000382F
.xdata$x:00003830 ; ===========================================================================
.xdata$x:00003830
.xdata$x:00003830 ; Segment type: Pure data
.xdata$x:00003830 ; Segment permissions: Read
.xdata$x:00003830 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003830                 assume cs:_xdata$x
.xdata$x:00003830                 ;org 3830h
.xdata$x:00003830 ; COMDAT (pick associative to section at 14F8)
.xdata$x:00003830 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00003830                                         ; DATA XREF: .xdata$x:00003840o
.xdata$x:00003831                 db 0FFh
.xdata$x:00003832                 db 0FFh
.xdata$x:00003833                 db 0FFh
.xdata$x:00003834                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00003838 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00003838                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00003839                 db    5
.xdata$x:0000383A                 db  93h ; 
.xdata$x:0000383B                 db  19h
.xdata$x:0000383C                 db    1
.xdata$x:0000383D                 db    0
.xdata$x:0000383E                 db    0
.xdata$x:0000383F                 db    0
.xdata$x:00003840                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00003844                 db    0
.xdata$x:00003845                 db    0
.xdata$x:00003846                 db    0
.xdata$x:00003847                 db    0
.xdata$x:00003848                 db    0
.xdata$x:00003849                 db    0
.xdata$x:0000384A                 db    0
.xdata$x:0000384B                 db    0
.xdata$x:0000384C                 db    0
.xdata$x:0000384D                 db    0
.xdata$x:0000384E                 db    0
.xdata$x:0000384F                 db    0
.xdata$x:00003850                 db    0
.xdata$x:00003851                 db    0
.xdata$x:00003852                 db    0
.xdata$x:00003853                 db    0
.xdata$x:00003854                 db    0
.xdata$x:00003855                 db    0
.xdata$x:00003856                 db    0
.xdata$x:00003857                 db    0
.xdata$x:00003858                 db    0
.xdata$x:00003859                 db    0
.xdata$x:0000385A                 db    0
.xdata$x:0000385B                 db    0
.xdata$x:0000385B _xdata$x        ends
.xdata$x:0000385B
.xdata$x:0000385C ; ===========================================================================
.xdata$x:0000385C
.xdata$x:0000385C ; Segment type: Pure data
.xdata$x:0000385C ; Segment permissions: Read
.xdata$x:0000385C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000385C                 assume cs:_xdata$x
.xdata$x:0000385C                 ;org 385Ch
.xdata$x:0000385C ; COMDAT (pick associative to section at 1B04)
.xdata$x:0000385C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000385C                                         ; DATA XREF: .xdata$x:0000386Co
.xdata$x:0000385D                 db 0FFh
.xdata$x:0000385E                 db 0FFh
.xdata$x:0000385F                 db 0FFh
.xdata$x:00003860                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00003864 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00003864                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00003865                 db    5
.xdata$x:00003866                 db  93h ; 
.xdata$x:00003867                 db  19h
.xdata$x:00003868                 db    1
.xdata$x:00003869                 db    0
.xdata$x:0000386A                 db    0
.xdata$x:0000386B                 db    0
.xdata$x:0000386C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00003870                 db    0
.xdata$x:00003871                 db    0
.xdata$x:00003872                 db    0
.xdata$x:00003873                 db    0
.xdata$x:00003874                 db    0
.xdata$x:00003875                 db    0
.xdata$x:00003876                 db    0
.xdata$x:00003877                 db    0
.xdata$x:00003878                 db    0
.xdata$x:00003879                 db    0
.xdata$x:0000387A                 db    0
.xdata$x:0000387B                 db    0
.xdata$x:0000387C                 db    0
.xdata$x:0000387D                 db    0
.xdata$x:0000387E                 db    0
.xdata$x:0000387F                 db    0
.xdata$x:00003880                 db    0
.xdata$x:00003881                 db    0
.xdata$x:00003882                 db    0
.xdata$x:00003883                 db    0
.xdata$x:00003884                 db    0
.xdata$x:00003885                 db    0
.xdata$x:00003886                 db    0
.xdata$x:00003887                 db    0
.xdata$x:00003887 _xdata$x        ends
.xdata$x:00003887
.xdata$x:00003888 ; ===========================================================================
.xdata$x:00003888
.xdata$x:00003888 ; Segment type: Pure data
.xdata$x:00003888 ; Segment permissions: Read
.xdata$x:00003888 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003888                 assume cs:_xdata$x
.xdata$x:00003888                 ;org 3888h
.xdata$x:00003888 ; COMDAT (pick associative to section at 20DC)
.xdata$x:00003888 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00003888                                         ; DATA XREF: .xdata$x:00003910o
.xdata$x:00003889                 db    0
.xdata$x:0000388A                 db    0
.xdata$x:0000388B                 db    0
.xdata$x:0000388C                 db    0
.xdata$x:0000388D                 db    0
.xdata$x:0000388E                 db    0
.xdata$x:0000388F                 db    0
.xdata$x:00003890                 db    0
.xdata$x:00003891                 db    0
.xdata$x:00003892                 db    0
.xdata$x:00003893                 db    0
.xdata$x:00003894                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00003898 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00003898                                         ; DATA XREF: .xdata$x:000038FCo
.xdata$x:00003899                 db    0
.xdata$x:0000389A                 db    0
.xdata$x:0000389B                 db    0
.xdata$x:0000389C                 db    0
.xdata$x:0000389D                 db    0
.xdata$x:0000389E                 db    0
.xdata$x:0000389F                 db    0
.xdata$x:000038A0                 db    0
.xdata$x:000038A1                 db    0
.xdata$x:000038A2                 db    0
.xdata$x:000038A3                 db    0
.xdata$x:000038A4                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:000038A8 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000038A8                                         ; DATA XREF: .xdata$x:000038D0o
.xdata$x:000038A9                 db 0FFh
.xdata$x:000038AA                 db 0FFh
.xdata$x:000038AB                 db 0FFh
.xdata$x:000038AC                 db    0
.xdata$x:000038AD                 db    0
.xdata$x:000038AE                 db    0
.xdata$x:000038AF                 db    0
.xdata$x:000038B0                 db 0FFh
.xdata$x:000038B1                 db 0FFh
.xdata$x:000038B2                 db 0FFh
.xdata$x:000038B3                 db 0FFh
.xdata$x:000038B4                 db    0
.xdata$x:000038B5                 db    0
.xdata$x:000038B6                 db    0
.xdata$x:000038B7                 db    0
.xdata$x:000038B8                 db    1
.xdata$x:000038B9                 db    0
.xdata$x:000038BA                 db    0
.xdata$x:000038BB                 db    0
.xdata$x:000038BC                 db    0
.xdata$x:000038BD                 db    0
.xdata$x:000038BE                 db    0
.xdata$x:000038BF                 db    0
.xdata$x:000038C0                 db    1
.xdata$x:000038C1                 db    0
.xdata$x:000038C2                 db    0
.xdata$x:000038C3                 db    0
.xdata$x:000038C4                 db    0
.xdata$x:000038C5                 db    0
.xdata$x:000038C6                 db    0
.xdata$x:000038C7                 db    0
.xdata$x:000038C8 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000038C8                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000038C9                 db    5
.xdata$x:000038CA                 db  93h ; 
.xdata$x:000038CB                 db  19h
.xdata$x:000038CC                 db    4
.xdata$x:000038CD                 db    0
.xdata$x:000038CE                 db    0
.xdata$x:000038CF                 db    0
.xdata$x:000038D0                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000038D4                 db    2
.xdata$x:000038D5                 db    0
.xdata$x:000038D6                 db    0
.xdata$x:000038D7                 db    0
.xdata$x:000038D8                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:000038DC                 db    0
.xdata$x:000038DD                 db    0
.xdata$x:000038DE                 db    0
.xdata$x:000038DF                 db    0
.xdata$x:000038E0                 db    0
.xdata$x:000038E1                 db    0
.xdata$x:000038E2                 db    0
.xdata$x:000038E3                 db    0
.xdata$x:000038E4                 db    0
.xdata$x:000038E5                 db    0
.xdata$x:000038E6                 db    0
.xdata$x:000038E7                 db    0
.xdata$x:000038E8                 db    0
.xdata$x:000038E9                 db    0
.xdata$x:000038EA                 db    0
.xdata$x:000038EB                 db    0
.xdata$x:000038EC __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:000038EC                                         ; DATA XREF: .xdata$x:000038D8o
.xdata$x:000038ED                 db    0
.xdata$x:000038EE                 db    0
.xdata$x:000038EF                 db    0
.xdata$x:000038F0                 db    2
.xdata$x:000038F1                 db    0
.xdata$x:000038F2                 db    0
.xdata$x:000038F3                 db    0
.xdata$x:000038F4                 db    3
.xdata$x:000038F5                 db    0
.xdata$x:000038F6                 db    0
.xdata$x:000038F7                 db    0
.xdata$x:000038F8                 db    1
.xdata$x:000038F9                 db    0
.xdata$x:000038FA                 db    0
.xdata$x:000038FB                 db    0
.xdata$x:000038FC                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00003900                 db    0
.xdata$x:00003901                 db    0
.xdata$x:00003902                 db    0
.xdata$x:00003903                 db    0
.xdata$x:00003904                 db    0
.xdata$x:00003905                 db    0
.xdata$x:00003906                 db    0
.xdata$x:00003907                 db    0
.xdata$x:00003908                 db    3
.xdata$x:00003909                 db    0
.xdata$x:0000390A                 db    0
.xdata$x:0000390B                 db    0
.xdata$x:0000390C                 db    1
.xdata$x:0000390D                 db    0
.xdata$x:0000390E                 db    0
.xdata$x:0000390F                 db    0
.xdata$x:00003910                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00003910 _xdata$x        ends
.xdata$x:00003910
.xdata$x:00003914 ; ===========================================================================
.xdata$x:00003914
.xdata$x:00003914 ; Segment type: Pure data
.xdata$x:00003914 ; Segment permissions: Read
.xdata$x:00003914 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003914                 assume cs:_xdata$x
.xdata$x:00003914                 ;org 3914h
.xdata$x:00003914 ; COMDAT (pick associative to section at 18B0)
.xdata$x:00003914 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00003914                                         ; DATA XREF: .xdata$x:00003924o
.xdata$x:00003915                 db 0FFh
.xdata$x:00003916                 db 0FFh
.xdata$x:00003917                 db 0FFh
.xdata$x:00003918                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:0000391C __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000391C                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:0000391D                 db    5
.xdata$x:0000391E                 db  93h ; 
.xdata$x:0000391F                 db  19h
.xdata$x:00003920                 db    1
.xdata$x:00003921                 db    0
.xdata$x:00003922                 db    0
.xdata$x:00003923                 db    0
.xdata$x:00003924                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00003928                 align 20h
.xdata$x:00003928 _xdata$x        ends
.xdata$x:00003928
.xdata$x:00003940 ; ===========================================================================
.xdata$x:00003940
.xdata$x:00003940 ; Segment type: Pure data
.xdata$x:00003940 ; Segment permissions: Read
.xdata$x:00003940 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003940                 assume cs:_xdata$x
.xdata$x:00003940                 ;org 3940h
.xdata$x:00003940 ; COMDAT (pick associative to section at 1D74)
.xdata$x:00003940 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00003940                                         ; DATA XREF: .xdata$x:00003950o
.xdata$x:00003941                 db 0FFh
.xdata$x:00003942                 db 0FFh
.xdata$x:00003943                 db 0FFh
.xdata$x:00003944                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00003948 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00003948                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00003949                 db    5
.xdata$x:0000394A                 db  93h ; 
.xdata$x:0000394B                 db  19h
.xdata$x:0000394C                 db    1
.xdata$x:0000394D                 db    0
.xdata$x:0000394E                 db    0
.xdata$x:0000394F                 db    0
.xdata$x:00003950                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00003954                 db    0
.xdata$x:00003955                 db    0
.xdata$x:00003956                 db    0
.xdata$x:00003957                 db    0
.xdata$x:00003958                 db    0
.xdata$x:00003959                 db    0
.xdata$x:0000395A                 db    0
.xdata$x:0000395B                 db    0
.xdata$x:0000395C                 db    0
.xdata$x:0000395D                 db    0
.xdata$x:0000395E                 db    0
.xdata$x:0000395F                 db    0
.xdata$x:00003960                 db    0
.xdata$x:00003961                 db    0
.xdata$x:00003962                 db    0
.xdata$x:00003963                 db    0
.xdata$x:00003964                 db    0
.xdata$x:00003965                 db    0
.xdata$x:00003966                 db    0
.xdata$x:00003967                 db    0
.xdata$x:00003968                 db    0
.xdata$x:00003969                 db    0
.xdata$x:0000396A                 db    0
.xdata$x:0000396B                 db    0
.xdata$x:0000396B _xdata$x        ends
.xdata$x:0000396B
.xdata$x:0000396C ; ===========================================================================
.xdata$x:0000396C
.xdata$x:0000396C ; Segment type: Pure data
.xdata$x:0000396C ; Segment permissions: Read
.xdata$x:0000396C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000396C                 assume cs:_xdata$x
.xdata$x:0000396C                 ;org 396Ch
.xdata$x:0000396C ; COMDAT (pick associative to section at 182C)
.xdata$x:0000396C __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000396C                                         ; DATA XREF: .xdata$x:0000397Co
.xdata$x:0000396D                 db 0FFh
.xdata$x:0000396E                 db 0FFh
.xdata$x:0000396F                 db 0FFh
.xdata$x:00003970                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:00003974 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00003974                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:00003975                 db    5
.xdata$x:00003976                 db  93h ; 
.xdata$x:00003977                 db  19h
.xdata$x:00003978                 db    1
.xdata$x:00003979                 db    0
.xdata$x:0000397A                 db    0
.xdata$x:0000397B                 db    0
.xdata$x:0000397C                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:00003980                 db    0
.xdata$x:00003981                 db    0
.xdata$x:00003982                 db    0
.xdata$x:00003983                 db    0
.xdata$x:00003984                 db    0
.xdata$x:00003985                 db    0
.xdata$x:00003986                 db    0
.xdata$x:00003987                 db    0
.xdata$x:00003988                 db    0
.xdata$x:00003989                 db    0
.xdata$x:0000398A                 db    0
.xdata$x:0000398B                 db    0
.xdata$x:0000398C                 db    0
.xdata$x:0000398D                 db    0
.xdata$x:0000398E                 db    0
.xdata$x:0000398F                 db    0
.xdata$x:00003990                 db    0
.xdata$x:00003991                 db    0
.xdata$x:00003992                 db    0
.xdata$x:00003993                 db    0
.xdata$x:00003994                 db    0
.xdata$x:00003995                 db    0
.xdata$x:00003996                 db    0
.xdata$x:00003997                 db    0
.xdata$x:00003997 _xdata$x        ends
.xdata$x:00003997
.xdata$x:00003998 ; ===========================================================================
.xdata$x:00003998
.xdata$x:00003998 ; Segment type: Pure data
.xdata$x:00003998 ; Segment permissions: Read
.xdata$x:00003998 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003998                 assume cs:_xdata$x
.xdata$x:00003998                 ;org 3998h
.xdata$x:00003998 ; COMDAT (pick associative to section at 1664)
.xdata$x:00003998 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003998                                         ; DATA XREF: .xdata$x:000039A8o
.xdata$x:00003999                 db 0FFh
.xdata$x:0000399A                 db 0FFh
.xdata$x:0000399B                 db 0FFh
.xdata$x:0000399C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000039A0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000039A0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000039A1                 db    5
.xdata$x:000039A2                 db  93h ; 
.xdata$x:000039A3                 db  19h
.xdata$x:000039A4                 db    1
.xdata$x:000039A5                 db    0
.xdata$x:000039A6                 db    0
.xdata$x:000039A7                 db    0
.xdata$x:000039A8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000039AC                 db    0
.xdata$x:000039AD                 db    0
.xdata$x:000039AE                 db    0
.xdata$x:000039AF                 db    0
.xdata$x:000039B0                 db    0
.xdata$x:000039B1                 db    0
.xdata$x:000039B2                 db    0
.xdata$x:000039B3                 db    0
.xdata$x:000039B4                 db    0
.xdata$x:000039B5                 db    0
.xdata$x:000039B6                 db    0
.xdata$x:000039B7                 db    0
.xdata$x:000039B8                 db    0
.xdata$x:000039B9                 db    0
.xdata$x:000039BA                 db    0
.xdata$x:000039BB                 db    0
.xdata$x:000039BC                 db    0
.xdata$x:000039BD                 db    0
.xdata$x:000039BE                 db    0
.xdata$x:000039BF                 db    0
.xdata$x:000039C0                 db    0
.xdata$x:000039C1                 db    0
.xdata$x:000039C2                 db    0
.xdata$x:000039C3                 db    0
.xdata$x:000039C3 _xdata$x        ends
.xdata$x:000039C3
.xdata$x:000039C4 ; ===========================================================================
.xdata$x:000039C4
.xdata$x:000039C4 ; Segment type: Pure data
.xdata$x:000039C4 ; Segment permissions: Read
.xdata$x:000039C4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000039C4                 assume cs:_xdata$x
.xdata$x:000039C4                 ;org 39C4h
.xdata$x:000039C4 ; COMDAT (pick associative to section at 337C)
.xdata$x:000039C4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000039C4                                         ; DATA XREF: .xdata$x:000039D4o
.xdata$x:000039C5                 db 0FFh
.xdata$x:000039C6                 db 0FFh
.xdata$x:000039C7                 db 0FFh
.xdata$x:000039C8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000039CC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000039CC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000039CD                 db    5
.xdata$x:000039CE                 db  93h ; 
.xdata$x:000039CF                 db  19h
.xdata$x:000039D0                 db    1
.xdata$x:000039D1                 db    0
.xdata$x:000039D2                 db    0
.xdata$x:000039D3                 db    0
.xdata$x:000039D4                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000039D8                 db    0
.xdata$x:000039D9                 db    0
.xdata$x:000039DA                 db    0
.xdata$x:000039DB                 db    0
.xdata$x:000039DC                 db    0
.xdata$x:000039DD                 db    0
.xdata$x:000039DE                 db    0
.xdata$x:000039DF                 db    0
.xdata$x:000039E0                 db    0
.xdata$x:000039E1                 db    0
.xdata$x:000039E2                 db    0
.xdata$x:000039E3                 db    0
.xdata$x:000039E4                 db    0
.xdata$x:000039E5                 db    0
.xdata$x:000039E6                 db    0
.xdata$x:000039E7                 db    0
.xdata$x:000039E8                 db    0
.xdata$x:000039E9                 db    0
.xdata$x:000039EA                 db    0
.xdata$x:000039EB                 db    0
.xdata$x:000039EC                 db    0
.xdata$x:000039ED                 db    0
.xdata$x:000039EE                 db    0
.xdata$x:000039EF                 db    0
.xdata$x:000039EF _xdata$x        ends
.xdata$x:000039EF
.xdata$x:000039F0 ; ===========================================================================
.xdata$x:000039F0
.xdata$x:000039F0 ; Segment type: Pure data
.xdata$x:000039F0 ; Segment permissions: Read
.xdata$x:000039F0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000039F0                 assume cs:_xdata$x
.xdata$x:000039F0                 ;org 39F0h
.xdata$x:000039F0 ; COMDAT (pick associative to section at 1C10)
.xdata$x:000039F0 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000039F0                                         ; DATA XREF: .xdata$x:00003A00o
.xdata$x:000039F1                 db 0FFh
.xdata$x:000039F2                 db 0FFh
.xdata$x:000039F3                 db 0FFh
.xdata$x:000039F4                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:000039F8 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000039F8                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:000039F9                 db    5
.xdata$x:000039FA                 db  93h ; 
.xdata$x:000039FB                 db  19h
.xdata$x:000039FC                 db    1
.xdata$x:000039FD                 db    0
.xdata$x:000039FE                 db    0
.xdata$x:000039FF                 db    0
.xdata$x:00003A00                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00003A04                 db    0
.xdata$x:00003A05                 db    0
.xdata$x:00003A06                 db    0
.xdata$x:00003A07                 db    0
.xdata$x:00003A08                 db    0
.xdata$x:00003A09                 db    0
.xdata$x:00003A0A                 db    0
.xdata$x:00003A0B                 db    0
.xdata$x:00003A0C                 db    0
.xdata$x:00003A0D                 db    0
.xdata$x:00003A0E                 db    0
.xdata$x:00003A0F                 db    0
.xdata$x:00003A10                 db    0
.xdata$x:00003A11                 db    0
.xdata$x:00003A12                 db    0
.xdata$x:00003A13                 db    0
.xdata$x:00003A14                 db    0
.xdata$x:00003A15                 db    0
.xdata$x:00003A16                 db    0
.xdata$x:00003A17                 db    0
.xdata$x:00003A18                 db    0
.xdata$x:00003A19                 db    0
.xdata$x:00003A1A                 db    0
.xdata$x:00003A1B                 db    0
.xdata$x:00003A1B _xdata$x        ends
.xdata$x:00003A1B
.xdata$x:00003A1C ; ===========================================================================
.xdata$x:00003A1C
.xdata$x:00003A1C ; Segment type: Pure data
.xdata$x:00003A1C ; Segment permissions: Read
.xdata$x:00003A1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003A1C                 assume cs:_xdata$x
.xdata$x:00003A1C                 ;org 3A1Ch
.xdata$x:00003A1C ; COMDAT (pick associative to section at 16E0)
.xdata$x:00003A1C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003A1C                                         ; DATA XREF: .xdata$x:00003A2Co
.xdata$x:00003A1D                 db 0FFh
.xdata$x:00003A1E                 db 0FFh
.xdata$x:00003A1F                 db 0FFh
.xdata$x:00003A20                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00003A24 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003A24                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00003A25                 db    5
.xdata$x:00003A26                 db  93h ; 
.xdata$x:00003A27                 db  19h
.xdata$x:00003A28                 db    1
.xdata$x:00003A29                 db    0
.xdata$x:00003A2A                 db    0
.xdata$x:00003A2B                 db    0
.xdata$x:00003A2C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00003A30                 db    0
.xdata$x:00003A31                 db    0
.xdata$x:00003A32                 db    0
.xdata$x:00003A33                 db    0
.xdata$x:00003A34                 db    0
.xdata$x:00003A35                 db    0
.xdata$x:00003A36                 db    0
.xdata$x:00003A37                 db    0
.xdata$x:00003A38                 db    0
.xdata$x:00003A39                 db    0
.xdata$x:00003A3A                 db    0
.xdata$x:00003A3B                 db    0
.xdata$x:00003A3C                 db    0
.xdata$x:00003A3D                 db    0
.xdata$x:00003A3E                 db    0
.xdata$x:00003A3F                 db    0
.xdata$x:00003A40                 db    0
.xdata$x:00003A41                 db    0
.xdata$x:00003A42                 db    0
.xdata$x:00003A43                 db    0
.xdata$x:00003A44                 db    0
.xdata$x:00003A45                 db    0
.xdata$x:00003A46                 db    0
.xdata$x:00003A47                 db    0
.xdata$x:00003A47 _xdata$x        ends
.xdata$x:00003A47
.xdata$x:00003A48 ; ===========================================================================
.xdata$x:00003A48
.xdata$x:00003A48 ; Segment type: Pure data
.xdata$x:00003A48 ; Segment permissions: Read
.xdata$x:00003A48 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003A48                 assume cs:_xdata$x
.xdata$x:00003A48                 ;org 3A48h
.xdata$x:00003A48 ; COMDAT (pick associative to section at 3434)
.xdata$x:00003A48 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00003A48                                         ; DATA XREF: .xdata$x:00003A58o
.xdata$x:00003A49                 db 0FFh
.xdata$x:00003A4A                 db 0FFh
.xdata$x:00003A4B                 db 0FFh
.xdata$x:00003A4C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003A50 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003A50                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003A51                 db    5
.xdata$x:00003A52                 db  93h ; 
.xdata$x:00003A53                 db  19h
.xdata$x:00003A54                 db    1
.xdata$x:00003A55                 db    0
.xdata$x:00003A56                 db    0
.xdata$x:00003A57                 db    0
.xdata$x:00003A58                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003A5C                 db    0
.xdata$x:00003A5D                 db    0
.xdata$x:00003A5E                 db    0
.xdata$x:00003A5F                 db    0
.xdata$x:00003A60                 db    0
.xdata$x:00003A61                 db    0
.xdata$x:00003A62                 db    0
.xdata$x:00003A63                 db    0
.xdata$x:00003A64                 db    0
.xdata$x:00003A65                 db    0
.xdata$x:00003A66                 db    0
.xdata$x:00003A67                 db    0
.xdata$x:00003A68                 db    0
.xdata$x:00003A69                 db    0
.xdata$x:00003A6A                 db    0
.xdata$x:00003A6B                 db    0
.xdata$x:00003A6C                 db    0
.xdata$x:00003A6D                 db    0
.xdata$x:00003A6E                 db    0
.xdata$x:00003A6F                 db    0
.xdata$x:00003A70                 db    0
.xdata$x:00003A71                 db    0
.xdata$x:00003A72                 db    0
.xdata$x:00003A73                 db    0
.xdata$x:00003A73 _xdata$x        ends
.xdata$x:00003A73
.xdata$x:00003A74 ; ===========================================================================
.xdata$x:00003A74
.xdata$x:00003A74 ; Segment type: Pure data
.xdata$x:00003A74 ; Segment permissions: Read
.xdata$x:00003A74 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003A74                 assume cs:_xdata$x
.xdata$x:00003A74                 ;org 3A74h
.xdata$x:00003A74 ; COMDAT (pick associative to section at 1C80)
.xdata$x:00003A74 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003A74                                         ; DATA XREF: .xdata$x:00003A84o
.xdata$x:00003A75                 db 0FFh
.xdata$x:00003A76                 db 0FFh
.xdata$x:00003A77                 db 0FFh
.xdata$x:00003A78                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:00003A7C __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003A7C                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:00003A7D                 db    5
.xdata$x:00003A7E                 db  93h ; 
.xdata$x:00003A7F                 db  19h
.xdata$x:00003A80                 db    1
.xdata$x:00003A81                 db    0
.xdata$x:00003A82                 db    0
.xdata$x:00003A83                 db    0
.xdata$x:00003A84                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00003A88                 align 20h
.xdata$x:00003A88 _xdata$x        ends
.xdata$x:00003A88
.xdata$x:00003AA0 ; ===========================================================================
.xdata$x:00003AA0
.xdata$x:00003AA0 ; Segment type: Pure data
.xdata$x:00003AA0 ; Segment permissions: Read
.xdata$x:00003AA0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003AA0                 assume cs:_xdata$x
.xdata$x:00003AA0                 ;org 3AA0h
.xdata$x:00003AA0 ; COMDAT (pick associative to section at 175C)
.xdata$x:00003AA0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003AA0                                         ; DATA XREF: .xdata$x:00003AB0o
.xdata$x:00003AA1                 db 0FFh
.xdata$x:00003AA2                 db 0FFh
.xdata$x:00003AA3                 db 0FFh
.xdata$x:00003AA4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00003AA8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003AA8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00003AA9                 db    5
.xdata$x:00003AAA                 db  93h ; 
.xdata$x:00003AAB                 db  19h
.xdata$x:00003AAC                 db    1
.xdata$x:00003AAD                 db    0
.xdata$x:00003AAE                 db    0
.xdata$x:00003AAF                 db    0
.xdata$x:00003AB0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00003AB4                 db    0
.xdata$x:00003AB5                 db    0
.xdata$x:00003AB6                 db    0
.xdata$x:00003AB7                 db    0
.xdata$x:00003AB8                 db    0
.xdata$x:00003AB9                 db    0
.xdata$x:00003ABA                 db    0
.xdata$x:00003ABB                 db    0
.xdata$x:00003ABC                 db    0
.xdata$x:00003ABD                 db    0
.xdata$x:00003ABE                 db    0
.xdata$x:00003ABF                 db    0
.xdata$x:00003AC0                 db    0
.xdata$x:00003AC1                 db    0
.xdata$x:00003AC2                 db    0
.xdata$x:00003AC3                 db    0
.xdata$x:00003AC4                 db    0
.xdata$x:00003AC5                 db    0
.xdata$x:00003AC6                 db    0
.xdata$x:00003AC7                 db    0
.xdata$x:00003AC8                 db    0
.xdata$x:00003AC9                 db    0
.xdata$x:00003ACA                 db    0
.xdata$x:00003ACB                 db    0
.xdata$x:00003ACB _xdata$x        ends
.xdata$x:00003ACB
.xdata$x:00003ACC ; ===========================================================================
.xdata$x:00003ACC
.xdata$x:00003ACC ; Segment type: Pure data
.xdata$x:00003ACC ; Segment permissions: Read
.xdata$x:00003ACC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003ACC                 assume cs:_xdata$x
.xdata$x:00003ACC                 ;org 3ACCh
.xdata$x:00003ACC ; COMDAT (pick associative to section at 34F8)
.xdata$x:00003ACC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00003ACC                                         ; DATA XREF: .xdata$x:00003ADCo
.xdata$x:00003ACD                 db 0FFh
.xdata$x:00003ACE                 db 0FFh
.xdata$x:00003ACF                 db 0FFh
.xdata$x:00003AD0                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003AD4 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003AD4                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003AD5                 db    5
.xdata$x:00003AD6                 db  93h ; 
.xdata$x:00003AD7                 db  19h
.xdata$x:00003AD8                 db    1
.xdata$x:00003AD9                 db    0
.xdata$x:00003ADA                 db    0
.xdata$x:00003ADB                 db    0
.xdata$x:00003ADC                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003AE0                 db    0
.xdata$x:00003AE1                 db    0
.xdata$x:00003AE2                 db    0
.xdata$x:00003AE3                 db    0
.xdata$x:00003AE4                 db    0
.xdata$x:00003AE5                 db    0
.xdata$x:00003AE6                 db    0
.xdata$x:00003AE7                 db    0
.xdata$x:00003AE8                 db    0
.xdata$x:00003AE9                 db    0
.xdata$x:00003AEA                 db    0
.xdata$x:00003AEB                 db    0
.xdata$x:00003AEC                 db    0
.xdata$x:00003AED                 db    0
.xdata$x:00003AEE                 db    0
.xdata$x:00003AEF                 db    0
.xdata$x:00003AF0                 db    0
.xdata$x:00003AF1                 db    0
.xdata$x:00003AF2                 db    0
.xdata$x:00003AF3                 db    0
.xdata$x:00003AF4                 db    0
.xdata$x:00003AF5                 db    0
.xdata$x:00003AF6                 db    0
.xdata$x:00003AF7                 db    0
.xdata$x:00003AF7 _xdata$x        ends
.xdata$x:00003AF7
.xdata$x:00003AF8 ; ===========================================================================
.xdata$x:00003AF8
.xdata$x:00003AF8 ; Segment type: Pure data
.xdata$x:00003AF8 ; Segment permissions: Read
.xdata$x:00003AF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003AF8                 assume cs:_xdata$x
.xdata$x:00003AF8                 ;org 3AF8h
.xdata$x:00003AF8 ; COMDAT (pick associative to section at 1CF0)
.xdata$x:00003AF8 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003AF8                                         ; DATA XREF: .xdata$x:00003B08o
.xdata$x:00003AF9                 db 0FFh
.xdata$x:00003AFA                 db 0FFh
.xdata$x:00003AFB                 db 0FFh
.xdata$x:00003AFC                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00003B00 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003B00                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00003B01                 db    5
.xdata$x:00003B02                 db  93h ; 
.xdata$x:00003B03                 db  19h
.xdata$x:00003B04                 db    1
.xdata$x:00003B05                 db    0
.xdata$x:00003B06                 db    0
.xdata$x:00003B07                 db    0
.xdata$x:00003B08                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:00003B0C                 db    0
.xdata$x:00003B0D                 db    0
.xdata$x:00003B0E                 db    0
.xdata$x:00003B0F                 db    0
.xdata$x:00003B10                 db    0
.xdata$x:00003B11                 db    0
.xdata$x:00003B12                 db    0
.xdata$x:00003B13                 db    0
.xdata$x:00003B14                 db    0
.xdata$x:00003B15                 db    0
.xdata$x:00003B16                 db    0
.xdata$x:00003B17                 db    0
.xdata$x:00003B18                 db    0
.xdata$x:00003B19                 db    0
.xdata$x:00003B1A                 db    0
.xdata$x:00003B1B                 db    0
.xdata$x:00003B1C                 db    0
.xdata$x:00003B1D                 db    0
.xdata$x:00003B1E                 db    0
.xdata$x:00003B1F                 db    0
.xdata$x:00003B20                 db    0
.xdata$x:00003B21                 db    0
.xdata$x:00003B22                 db    0
.xdata$x:00003B23                 db    0
.xdata$x:00003B23 _xdata$x        ends
.xdata$x:00003B23
.xdata$x:00003B24 ; ===========================================================================
.xdata$x:00003B24
.xdata$x:00003B24 ; Segment type: Pure data
.xdata$x:00003B24 ; Segment permissions: Read
.xdata$x:00003B24 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003B24                 assume cs:_xdata$x
.xdata$x:00003B24                 ;org 3B24h
.xdata$x:00003B24 ; COMDAT (pick associative to section at 1410)
.xdata$x:00003B24 __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003B24                                         ; DATA XREF: .xdata$x:00003B34o
.xdata$x:00003B25                 db 0FFh
.xdata$x:00003B26                 db 0FFh
.xdata$x:00003B27                 db 0FFh
.xdata$x:00003B28                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00003B2C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003B2C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00003B2D                 db    5
.xdata$x:00003B2E                 db  93h ; 
.xdata$x:00003B2F                 db  19h
.xdata$x:00003B30                 db    1
.xdata$x:00003B31                 db    0
.xdata$x:00003B32                 db    0
.xdata$x:00003B33                 db    0
.xdata$x:00003B34                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00003B38                 db    0
.xdata$x:00003B39                 db    0
.xdata$x:00003B3A                 db    0
.xdata$x:00003B3B                 db    0
.xdata$x:00003B3C                 db    0
.xdata$x:00003B3D                 db    0
.xdata$x:00003B3E                 db    0
.xdata$x:00003B3F                 db    0
.xdata$x:00003B40                 db    0
.xdata$x:00003B41                 db    0
.xdata$x:00003B42                 db    0
.xdata$x:00003B43                 db    0
.xdata$x:00003B44                 db    0
.xdata$x:00003B45                 db    0
.xdata$x:00003B46                 db    0
.xdata$x:00003B47                 db    0
.xdata$x:00003B48                 db    0
.xdata$x:00003B49                 db    0
.xdata$x:00003B4A                 db    0
.xdata$x:00003B4B                 db    0
.xdata$x:00003B4C                 db    0
.xdata$x:00003B4D                 db    0
.xdata$x:00003B4E                 db    0
.xdata$x:00003B4F                 db    0
.xdata$x:00003B4F _xdata$x        ends
.xdata$x:00003B4F
.xdata$x:00003B50 ; ===========================================================================
.xdata$x:00003B50
.xdata$x:00003B50 ; Segment type: Pure data
.xdata$x:00003B50 ; Segment permissions: Read
.xdata$x:00003B50 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003B50                 assume cs:_xdata$x
.xdata$x:00003B50                 ;org 3B50h
.xdata$x:00003B50 ; COMDAT (pick associative to section at 1A94)
.xdata$x:00003B50 __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003B50                                         ; DATA XREF: .xdata$x:00003B60o
.xdata$x:00003B51                 db 0FFh
.xdata$x:00003B52                 db 0FFh
.xdata$x:00003B53                 db 0FFh
.xdata$x:00003B54                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ$0
.xdata$x:00003B58 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003B58                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ+11o
.xdata$x:00003B59                 db    5
.xdata$x:00003B5A                 db  93h ; 
.xdata$x:00003B5B                 db  19h
.xdata$x:00003B5C                 db    1
.xdata$x:00003B5D                 db    0
.xdata$x:00003B5E                 db    0
.xdata$x:00003B5F                 db    0
.xdata$x:00003B60                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QAE@XZ
.xdata$x:00003B64                 db    0
.xdata$x:00003B65                 db    0
.xdata$x:00003B66                 db    0
.xdata$x:00003B67                 db    0
.xdata$x:00003B68                 db    0
.xdata$x:00003B69                 db    0
.xdata$x:00003B6A                 db    0
.xdata$x:00003B6B                 db    0
.xdata$x:00003B6C                 db    0
.xdata$x:00003B6D                 db    0
.xdata$x:00003B6E                 db    0
.xdata$x:00003B6F                 db    0
.xdata$x:00003B70                 db    0
.xdata$x:00003B71                 db    0
.xdata$x:00003B72                 db    0
.xdata$x:00003B73                 db    0
.xdata$x:00003B74                 db    0
.xdata$x:00003B75                 db    0
.xdata$x:00003B76                 db    0
.xdata$x:00003B77                 db    0
.xdata$x:00003B78                 db    0
.xdata$x:00003B79                 db    0
.xdata$x:00003B7A                 db    0
.xdata$x:00003B7B                 db    0
.xdata$x:00003B7B _xdata$x        ends
.xdata$x:00003B7B
.xdata$x:00003B7C ; ===========================================================================
.xdata$x:00003B7C
.xdata$x:00003B7C ; Segment type: Pure data
.xdata$x:00003B7C ; Segment permissions: Read
.xdata$x:00003B7C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003B7C                 assume cs:_xdata$x
.xdata$x:00003B7C                 ;org 3B7Ch
.xdata$x:00003B7C ; COMDAT (pick associative to section at 130C)
.xdata$x:00003B7C __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db 0FFh
.xdata$x:00003B7C                                         ; DATA XREF: .xdata$x:00003B8Co
.xdata$x:00003B7D                 db 0FFh
.xdata$x:00003B7E                 db 0FFh
.xdata$x:00003B7F                 db 0FFh
.xdata$x:00003B80                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z$0
.xdata$x:00003B84 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z db  22h ; "
.xdata$x:00003B84                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z+11o
.xdata$x:00003B85                 db    5
.xdata$x:00003B86                 db  93h ; 
.xdata$x:00003B87                 db  19h
.xdata$x:00003B88                 db    1
.xdata$x:00003B89                 db    0
.xdata$x:00003B8A                 db    0
.xdata$x:00003B8B                 db    0
.xdata$x:00003B8C                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@ABV?$allocator@_W@1@@Z
.xdata$x:00003B90                 db    0
.xdata$x:00003B91                 db    0
.xdata$x:00003B92                 db    0
.xdata$x:00003B93                 db    0
.xdata$x:00003B94                 db    0
.xdata$x:00003B95                 db    0
.xdata$x:00003B96                 db    0
.xdata$x:00003B97                 db    0
.xdata$x:00003B98                 db    0
.xdata$x:00003B99                 db    0
.xdata$x:00003B9A                 db    0
.xdata$x:00003B9B                 db    0
.xdata$x:00003B9C                 db    0
.xdata$x:00003B9D                 db    0
.xdata$x:00003B9E                 db    0
.xdata$x:00003B9F                 db    0
.xdata$x:00003BA0                 db    0
.xdata$x:00003BA1                 db    0
.xdata$x:00003BA2                 db    0
.xdata$x:00003BA3                 db    0
.xdata$x:00003BA4                 db    0
.xdata$x:00003BA5                 db    0
.xdata$x:00003BA6                 db    0
.xdata$x:00003BA7                 db    0
.xdata$x:00003BA7 _xdata$x        ends
.xdata$x:00003BA7
.xdata$x:00003BA8 ; ===========================================================================
.xdata$x:00003BA8
.xdata$x:00003BA8 ; Segment type: Pure data
.xdata$x:00003BA8 ; Segment permissions: Read
.xdata$x:00003BA8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003BA8                 assume cs:_xdata$x
.xdata$x:00003BA8                 ;org 3BA8h
.xdata$x:00003BA8 ; COMDAT (pick associative to section at 19AC)
.xdata$x:00003BA8 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00003BA8                                         ; DATA XREF: .xdata$x:00003BB8o
.xdata$x:00003BA9                 db 0FFh
.xdata$x:00003BAA                 db 0FFh
.xdata$x:00003BAB                 db 0FFh
.xdata$x:00003BAC                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00003BB0 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00003BB0                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00003BB1                 db    5
.xdata$x:00003BB2                 db  93h ; 
.xdata$x:00003BB3                 db  19h
.xdata$x:00003BB4                 db    1
.xdata$x:00003BB5                 db    0
.xdata$x:00003BB6                 db    0
.xdata$x:00003BB7                 db    0
.xdata$x:00003BB8                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@_WV?$allocator@_W@std@@@std@@@std@@QAE@XZ
.xdata$x:00003BBC                 db    0
.xdata$x:00003BBD                 db    0
.xdata$x:00003BBE                 db    0
.xdata$x:00003BBF                 db    0
.xdata$x:00003BC0                 db    0
.xdata$x:00003BC1                 db    0
.xdata$x:00003BC2                 db    0
.xdata$x:00003BC3                 db    0
.xdata$x:00003BC4                 db    0
.xdata$x:00003BC5                 db    0
.xdata$x:00003BC6                 db    0
.xdata$x:00003BC7                 db    0
.xdata$x:00003BC8                 db    0
.xdata$x:00003BC9                 db    0
.xdata$x:00003BCA                 db    0
.xdata$x:00003BCB                 db    0
.xdata$x:00003BCC                 db    0
.xdata$x:00003BCD                 db    0
.xdata$x:00003BCE                 db    0
.xdata$x:00003BCF                 db    0
.xdata$x:00003BD0                 db    0
.xdata$x:00003BD1                 db    0
.xdata$x:00003BD2                 db    0
.xdata$x:00003BD3                 db    0
.xdata$x:00003BD3 _xdata$x        ends
.xdata$x:00003BD3
.xdata$x:00003BD4 ; ===========================================================================
.xdata$x:00003BD4
.xdata$x:00003BD4 ; Segment type: Pure data
.xdata$x:00003BD4 ; Segment permissions: Read
.xdata$x:00003BD4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003BD4                 assume cs:_xdata$x
.xdata$x:00003BD4                 ;org 3BD4h
.xdata$x:00003BD4 ; COMDAT (pick associative to section at 1590)
.xdata$x:00003BD4 __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db 0FFh
.xdata$x:00003BD4                                         ; DATA XREF: .xdata$x:00003BE4o
.xdata$x:00003BD5                 db 0FFh
.xdata$x:00003BD6                 db 0FFh
.xdata$x:00003BD7                 db 0FFh
.xdata$x:00003BD8                 dd offset __unwindfunclet$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z$0
.xdata$x:00003BDC __ehfuncinfo$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z db  22h ; "
.xdata$x:00003BDC                                         ; DATA XREF: __ehhandler$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z+11o
.xdata$x:00003BDD                 db    5
.xdata$x:00003BDE                 db  93h ; 
.xdata$x:00003BDF                 db  19h
.xdata$x:00003BE0                 db    1
.xdata$x:00003BE1                 db    0
.xdata$x:00003BE2                 db    0
.xdata$x:00003BE3                 db    0
.xdata$x:00003BE4                 dd offset __unwindtable$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@PB_W@Z
.xdata$x:00003BE8                 align 20h
.xdata$x:00003BE8 _xdata$x        ends
.xdata$x:00003BE8
.xdata$x:00003C00 ; ===========================================================================
.xdata$x:00003C00
.xdata$x:00003C00 ; Segment type: Pure data
.xdata$x:00003C00 ; Segment permissions: Read
.xdata$x:00003C00 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003C00                 assume cs:_xdata$x
.xdata$x:00003C00                 ;org 3C00h
.xdata$x:00003C00 ; COMDAT (pick associative to section at 1B80)
.xdata$x:00003C00 __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db 0FFh
.xdata$x:00003C00                                         ; DATA XREF: .xdata$x:00003C10o
.xdata$x:00003C01                 db 0FFh
.xdata$x:00003C02                 db 0FFh
.xdata$x:00003C03                 db 0FFh
.xdata$x:00003C04                 dd offset __unwindfunclet$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ$0
.xdata$x:00003C08 __ehfuncinfo$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00003C08                                         ; DATA XREF: __ehhandler$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ+11o
.xdata$x:00003C09                 db    5
.xdata$x:00003C0A                 db  93h ; 
.xdata$x:00003C0B                 db  19h
.xdata$x:00003C0C                 db    1
.xdata$x:00003C0D                 db    0
.xdata$x:00003C0E                 db    0
.xdata$x:00003C0F                 db    0
.xdata$x:00003C10                 dd offset __unwindtable$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAE@XZ
.xdata$x:00003C14                 db    0
.xdata$x:00003C15                 db    0
.xdata$x:00003C16                 db    0
.xdata$x:00003C17                 db    0
.xdata$x:00003C18                 db    0
.xdata$x:00003C19                 db    0
.xdata$x:00003C1A                 db    0
.xdata$x:00003C1B                 db    0
.xdata$x:00003C1C                 db    0
.xdata$x:00003C1D                 db    0
.xdata$x:00003C1E                 db    0
.xdata$x:00003C1F                 db    0
.xdata$x:00003C20                 db    0
.xdata$x:00003C21                 db    0
.xdata$x:00003C22                 db    0
.xdata$x:00003C23                 db    0
.xdata$x:00003C24                 db    0
.xdata$x:00003C25                 db    0
.xdata$x:00003C26                 db    0
.xdata$x:00003C27                 db    0
.xdata$x:00003C28                 db    0
.xdata$x:00003C29                 db    0
.xdata$x:00003C2A                 db    0
.xdata$x:00003C2B                 db    0
.xdata$x:00003C2B _xdata$x        ends
.xdata$x:00003C2B
.xdata$x:00003C2C ; ===========================================================================
.xdata$x:00003C2C
.xdata$x:00003C2C ; Segment type: Pure data
.xdata$x:00003C2C ; Segment permissions: Read
.xdata$x:00003C2C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003C2C                 assume cs:_xdata$x
.xdata$x:00003C2C                 ;org 3C2Ch
.xdata$x:00003C2C ; COMDAT (pick associative to section at 229C)
.xdata$x:00003C2C __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00003C2C                                         ; DATA XREF: .xdata$x:00003CB4o
.xdata$x:00003C2D                 db    0
.xdata$x:00003C2E                 db    0
.xdata$x:00003C2F                 db    0
.xdata$x:00003C30                 db    0
.xdata$x:00003C31                 db    0
.xdata$x:00003C32                 db    0
.xdata$x:00003C33                 db    0
.xdata$x:00003C34                 db    0
.xdata$x:00003C35                 db    0
.xdata$x:00003C36                 db    0
.xdata$x:00003C37                 db    0
.xdata$x:00003C38                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$0
.xdata$x:00003C3C __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00003C3C                                         ; DATA XREF: .xdata$x:00003CA0o
.xdata$x:00003C3D                 db    0
.xdata$x:00003C3E                 db    0
.xdata$x:00003C3F                 db    0
.xdata$x:00003C40                 db    0
.xdata$x:00003C41                 db    0
.xdata$x:00003C42                 db    0
.xdata$x:00003C43                 db    0
.xdata$x:00003C44                 db    0
.xdata$x:00003C45                 db    0
.xdata$x:00003C46                 db    0
.xdata$x:00003C47                 db    0
.xdata$x:00003C48                 dd offset __catch$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$1
.xdata$x:00003C4C __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00003C4C                                         ; DATA XREF: .xdata$x:00003C74o
.xdata$x:00003C4D                 db 0FFh
.xdata$x:00003C4E                 db 0FFh
.xdata$x:00003C4F                 db 0FFh
.xdata$x:00003C50                 db    0
.xdata$x:00003C51                 db    0
.xdata$x:00003C52                 db    0
.xdata$x:00003C53                 db    0
.xdata$x:00003C54                 db 0FFh
.xdata$x:00003C55                 db 0FFh
.xdata$x:00003C56                 db 0FFh
.xdata$x:00003C57                 db 0FFh
.xdata$x:00003C58                 db    0
.xdata$x:00003C59                 db    0
.xdata$x:00003C5A                 db    0
.xdata$x:00003C5B                 db    0
.xdata$x:00003C5C                 db    1
.xdata$x:00003C5D                 db    0
.xdata$x:00003C5E                 db    0
.xdata$x:00003C5F                 db    0
.xdata$x:00003C60                 db    0
.xdata$x:00003C61                 db    0
.xdata$x:00003C62                 db    0
.xdata$x:00003C63                 db    0
.xdata$x:00003C64                 db    1
.xdata$x:00003C65                 db    0
.xdata$x:00003C66                 db    0
.xdata$x:00003C67                 db    0
.xdata$x:00003C68                 db    0
.xdata$x:00003C69                 db    0
.xdata$x:00003C6A                 db    0
.xdata$x:00003C6B                 db    0
.xdata$x:00003C6C __ehfuncinfo$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00003C6C                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z+11o
.xdata$x:00003C6D                 db    5
.xdata$x:00003C6E                 db  93h ; 
.xdata$x:00003C6F                 db  19h
.xdata$x:00003C70                 db    4
.xdata$x:00003C71                 db    0
.xdata$x:00003C72                 db    0
.xdata$x:00003C73                 db    0
.xdata$x:00003C74                 dd offset __unwindtable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00003C78                 db    2
.xdata$x:00003C79                 db    0
.xdata$x:00003C7A                 db    0
.xdata$x:00003C7B                 db    0
.xdata$x:00003C7C                 dd offset __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z
.xdata$x:00003C80                 db    0
.xdata$x:00003C81                 db    0
.xdata$x:00003C82                 db    0
.xdata$x:00003C83                 db    0
.xdata$x:00003C84                 db    0
.xdata$x:00003C85                 db    0
.xdata$x:00003C86                 db    0
.xdata$x:00003C87                 db    0
.xdata$x:00003C88                 db    0
.xdata$x:00003C89                 db    0
.xdata$x:00003C8A                 db    0
.xdata$x:00003C8B                 db    0
.xdata$x:00003C8C                 db    0
.xdata$x:00003C8D                 db    0
.xdata$x:00003C8E                 db    0
.xdata$x:00003C8F                 db    0
.xdata$x:00003C90 __tryblocktable$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z db    2
.xdata$x:00003C90                                         ; DATA XREF: .xdata$x:00003C7Co
.xdata$x:00003C91                 db    0
.xdata$x:00003C92                 db    0
.xdata$x:00003C93                 db    0
.xdata$x:00003C94                 db    2
.xdata$x:00003C95                 db    0
.xdata$x:00003C96                 db    0
.xdata$x:00003C97                 db    0
.xdata$x:00003C98                 db    3
.xdata$x:00003C99                 db    0
.xdata$x:00003C9A                 db    0
.xdata$x:00003C9B                 db    0
.xdata$x:00003C9C                 db    1
.xdata$x:00003C9D                 db    0
.xdata$x:00003C9E                 db    0
.xdata$x:00003C9F                 db    0
.xdata$x:00003CA0                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$4
.xdata$x:00003CA4                 db    0
.xdata$x:00003CA5                 db    0
.xdata$x:00003CA6                 db    0
.xdata$x:00003CA7                 db    0
.xdata$x:00003CA8                 db    0
.xdata$x:00003CA9                 db    0
.xdata$x:00003CAA                 db    0
.xdata$x:00003CAB                 db    0
.xdata$x:00003CAC                 db    3
.xdata$x:00003CAD                 db    0
.xdata$x:00003CAE                 db    0
.xdata$x:00003CAF                 db    0
.xdata$x:00003CB0                 db    1
.xdata$x:00003CB1                 db    0
.xdata$x:00003CB2                 db    0
.xdata$x:00003CB3                 db    0
.xdata$x:00003CB4                 dd offset __catchsym$?_Copy@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QAEXII@Z$5
.xdata$x:00003CB4 _xdata$x        ends
.xdata$x:00003CB4
.xdata$x:00003CB8 ; ===========================================================================
.xdata$x:00003CB8
.xdata$x:00003CB8 ; Segment type: Pure data
.xdata$x:00003CB8 ; Segment permissions: Read
.xdata$x:00003CB8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003CB8                 assume cs:_xdata$x
.xdata$x:00003CB8                 ;org 3CB8h
.xdata$x:00003CB8 __unwindtable$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z db 0FFh
.xdata$x:00003CB8                                         ; DATA XREF: .xdata$x:00003CE8o
.xdata$x:00003CB9                 db 0FFh
.xdata$x:00003CBA                 db 0FFh
.xdata$x:00003CBB                 db 0FFh
.xdata$x:00003CBC                 dd offset __unwindfunclet$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z$0
.xdata$x:00003CC0 __unwindtable$?setValues@ListView@@QAEXH@Z db 0FFh
.xdata$x:00003CC0                                         ; DATA XREF: .xdata$x:00003D0Co
.xdata$x:00003CC1                 db 0FFh
.xdata$x:00003CC2                 db 0FFh
.xdata$x:00003CC3                 db 0FFh
.xdata$x:00003CC4                 dd offset __unwindfunclet$?setValues@ListView@@QAEXH@Z$0
.xdata$x:00003CC8 __unwindtable$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z db 0FFh
.xdata$x:00003CC8                                         ; DATA XREF: .xdata$x:00003D30o
.xdata$x:00003CC9                 db 0FFh
.xdata$x:00003CCA                 db 0FFh
.xdata$x:00003CCB                 db 0FFh
.xdata$x:00003CCC                 dd offset __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$0
.xdata$x:00003CD0                 db    0
.xdata$x:00003CD1                 db    0
.xdata$x:00003CD2                 db    0
.xdata$x:00003CD3                 db    0
.xdata$x:00003CD4                 dd offset __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$1
.xdata$x:00003CD8                 db    1
.xdata$x:00003CD9                 db    0
.xdata$x:00003CDA                 db    0
.xdata$x:00003CDB                 db    0
.xdata$x:00003CDC                 dd offset __unwindfunclet$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z$2
.xdata$x:00003CE0 __ehfuncinfo$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z db  22h ; "
.xdata$x:00003CE0                                         ; DATA XREF: __ehhandler$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z+1Bo
.xdata$x:00003CE1                 db    5
.xdata$x:00003CE2                 db  93h ; 
.xdata$x:00003CE3                 db  19h
.xdata$x:00003CE4                 db    1
.xdata$x:00003CE5                 db    0
.xdata$x:00003CE6                 db    0
.xdata$x:00003CE7                 db    0
.xdata$x:00003CE8                 dd offset __unwindtable$?getAscii@ListView@@QAE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@E@Z
.xdata$x:00003CEC                 db    0
.xdata$x:00003CED                 db    0
.xdata$x:00003CEE                 db    0
.xdata$x:00003CEF                 db    0
.xdata$x:00003CF0                 db    0
.xdata$x:00003CF1                 db    0
.xdata$x:00003CF2                 db    0
.xdata$x:00003CF3                 db    0
.xdata$x:00003CF4                 db    0
.xdata$x:00003CF5                 db    0
.xdata$x:00003CF6                 db    0
.xdata$x:00003CF7                 db    0
.xdata$x:00003CF8                 db    0
.xdata$x:00003CF9                 db    0
.xdata$x:00003CFA                 db    0
.xdata$x:00003CFB                 db    0
.xdata$x:00003CFC                 db    0
.xdata$x:00003CFD                 db    0
.xdata$x:00003CFE                 db    0
.xdata$x:00003CFF                 db    0
.xdata$x:00003D00                 db    0
.xdata$x:00003D01                 db    0
.xdata$x:00003D02                 db    0
.xdata$x:00003D03                 db    0
.xdata$x:00003D04 __ehfuncinfo$?setValues@ListView@@QAEXH@Z db  22h ; "
.xdata$x:00003D04                                         ; DATA XREF: __ehhandler$?setValues@ListView@@QAEXH@Z+1Eo
.xdata$x:00003D05                 db    5
.xdata$x:00003D06                 db  93h ; 
.xdata$x:00003D07                 db  19h
.xdata$x:00003D08                 db    1
.xdata$x:00003D09                 db    0
.xdata$x:00003D0A                 db    0
.xdata$x:00003D0B                 db    0
.xdata$x:00003D0C                 dd offset __unwindtable$?setValues@ListView@@QAEXH@Z
.xdata$x:00003D10                 db    0
.xdata$x:00003D11                 db    0
.xdata$x:00003D12                 db    0
.xdata$x:00003D13                 db    0
.xdata$x:00003D14                 db    0
.xdata$x:00003D15                 db    0
.xdata$x:00003D16                 db    0
.xdata$x:00003D17                 db    0
.xdata$x:00003D18                 db    0
.xdata$x:00003D19                 db    0
.xdata$x:00003D1A                 db    0
.xdata$x:00003D1B                 db    0
.xdata$x:00003D1C                 db    0
.xdata$x:00003D1D                 db    0
.xdata$x:00003D1E                 db    0
.xdata$x:00003D1F                 db    0
.xdata$x:00003D20                 db    0
.xdata$x:00003D21                 db    0
.xdata$x:00003D22                 db    0
.xdata$x:00003D23                 db    0
.xdata$x:00003D24                 db    0
.xdata$x:00003D25                 db    0
.xdata$x:00003D26                 db    0
.xdata$x:00003D27                 db    0
.xdata$x:00003D28 __ehfuncinfo$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z db  22h ; "
.xdata$x:00003D28                                         ; DATA XREF: __ehhandler$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z+1Eo
.xdata$x:00003D29                 db    5
.xdata$x:00003D2A                 db  93h ; 
.xdata$x:00003D2B                 db  19h
.xdata$x:00003D2C                 db    3
.xdata$x:00003D2D                 db    0
.xdata$x:00003D2E                 db    0
.xdata$x:00003D2F                 db    0
.xdata$x:00003D30                 dd offset __unwindtable$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z
.xdata$x:00003D34                 db    0
.xdata$x:00003D35                 db    0
.xdata$x:00003D36                 db    0
.xdata$x:00003D37                 db    0
.xdata$x:00003D38                 db    0
.xdata$x:00003D39                 db    0
.xdata$x:00003D3A                 db    0
.xdata$x:00003D3B                 db    0
.xdata$x:00003D3C                 db    0
.xdata$x:00003D3D                 db    0
.xdata$x:00003D3E                 db    0
.xdata$x:00003D3F                 db    0
.xdata$x:00003D40                 db    0
.xdata$x:00003D41                 db    0
.xdata$x:00003D42                 db    0
.xdata$x:00003D43                 db    0
.xdata$x:00003D44                 db    0
.xdata$x:00003D45                 db    0
.xdata$x:00003D46                 db    0
.xdata$x:00003D47                 db    0
.xdata$x:00003D48                 db    0
.xdata$x:00003D49                 db    0
.xdata$x:00003D4A                 db    0
.xdata$x:00003D4B                 db    0
.xdata$x:00003D4B _xdata$x        ends
.xdata$x:00003D4B
.xdata$x:00003D4C ; ===========================================================================
.xdata$x:00003D4C
.xdata$x:00003D4C ; Segment type: Pure data
.xdata$x:00003D4C ; Segment permissions: Read
.xdata$x:00003D4C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003D4C                 assume cs:_xdata$x
.xdata$x:00003D4C                 ;org 3D4Ch
.xdata$x:00003D4C ; COMDAT (pick associative to section at 1128)
.xdata$x:00003D4C __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:00003D4C                                         ; DATA XREF: .xdata$x:00003D5Co
.xdata$x:00003D4D                 db 0FFh
.xdata$x:00003D4E                 db 0FFh
.xdata$x:00003D4F                 db 0FFh
.xdata$x:00003D50                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:00003D54 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:00003D54                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:00003D55                 db    5
.xdata$x:00003D56                 db  93h ; 
.xdata$x:00003D57                 db  19h
.xdata$x:00003D58                 db    1
.xdata$x:00003D59                 db    0
.xdata$x:00003D5A                 db    0
.xdata$x:00003D5B                 db    0
.xdata$x:00003D5C                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:00003D60                 db    0
.xdata$x:00003D61                 db    0
.xdata$x:00003D62                 db    0
.xdata$x:00003D63                 db    0
.xdata$x:00003D64                 db    0
.xdata$x:00003D65                 db    0
.xdata$x:00003D66                 db    0
.xdata$x:00003D67                 db    0
.xdata$x:00003D68                 db    0
.xdata$x:00003D69                 db    0
.xdata$x:00003D6A                 db    0
.xdata$x:00003D6B                 db    0
.xdata$x:00003D6C                 db    0
.xdata$x:00003D6D                 db    0
.xdata$x:00003D6E                 db    0
.xdata$x:00003D6F                 db    0
.xdata$x:00003D70                 db    0
.xdata$x:00003D71                 db    0
.xdata$x:00003D72                 db    0
.xdata$x:00003D73                 db    0
.xdata$x:00003D74                 db    0
.xdata$x:00003D75                 db    0
.xdata$x:00003D76                 db    0
.xdata$x:00003D77                 db    0
.xdata$x:00003D77 _xdata$x        ends
.xdata$x:00003D77
.xdata$x:00003D78 ; ===========================================================================
.xdata$x:00003D78
.xdata$x:00003D78 ; Segment type: Pure data
.xdata$x:00003D78 ; Segment permissions: Read
.xdata$x:00003D78 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003D78                 assume cs:_xdata$x
.xdata$x:00003D78                 ;org 3D78h
.xdata$x:00003D78 ; COMDAT (pick associative to section at F54)
.xdata$x:00003D78 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00003D78                                         ; DATA XREF: .xdata$x:00003D88o
.xdata$x:00003D79                 db 0FFh
.xdata$x:00003D7A                 db 0FFh
.xdata$x:00003D7B                 db 0FFh
.xdata$x:00003D7C                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:00003D80 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:00003D80                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:00003D81                 db    5
.xdata$x:00003D82                 db  93h ; 
.xdata$x:00003D83                 db  19h
.xdata$x:00003D84                 db    1
.xdata$x:00003D85                 db    0
.xdata$x:00003D86                 db    0
.xdata$x:00003D87                 db    0
.xdata$x:00003D88                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00003D8C                 db    0
.xdata$x:00003D8D                 db    0
.xdata$x:00003D8E                 db    0
.xdata$x:00003D8F                 db    0
.xdata$x:00003D90                 db    0
.xdata$x:00003D91                 db    0
.xdata$x:00003D92                 db    0
.xdata$x:00003D93                 db    0
.xdata$x:00003D94                 db    0
.xdata$x:00003D95                 db    0
.xdata$x:00003D96                 db    0
.xdata$x:00003D97                 db    0
.xdata$x:00003D98                 db    0
.xdata$x:00003D99                 db    0
.xdata$x:00003D9A                 db    0
.xdata$x:00003D9B                 db    0
.xdata$x:00003D9C                 db    0
.xdata$x:00003D9D                 db    0
.xdata$x:00003D9E                 db    0
.xdata$x:00003D9F                 db    0
.xdata$x:00003DA0                 db    0
.xdata$x:00003DA1                 db    0
.xdata$x:00003DA2                 db    0
.xdata$x:00003DA3                 db    0
.xdata$x:00003DA3 _xdata$x        ends
.xdata$x:00003DA3
.xdata$x:00003DA4 ; ===========================================================================
.xdata$x:00003DA4
.xdata$x:00003DA4 ; Segment type: Pure data
.xdata$x:00003DA4 ; Segment permissions: Read
.xdata$x:00003DA4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003DA4                 assume cs:_xdata$x
.xdata$x:00003DA4                 ;org 3DA4h
.xdata$x:00003DA4 ; COMDAT (pick associative to section at 1054)
.xdata$x:00003DA4 __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db 0FFh
.xdata$x:00003DA4                                         ; DATA XREF: .xdata$x:00003DB4o
.xdata$x:00003DA5                 db 0FFh
.xdata$x:00003DA6                 db 0FFh
.xdata$x:00003DA7                 db 0FFh
.xdata$x:00003DA8                 dd offset __unwindfunclet$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z$0
.xdata$x:00003DAC __ehfuncinfo$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z db  22h ; "
.xdata$x:00003DAC                                         ; DATA XREF: __ehhandler$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z+11o
.xdata$x:00003DAD                 db    5
.xdata$x:00003DAE                 db  93h ; 
.xdata$x:00003DAF                 db  19h
.xdata$x:00003DB0                 db    1
.xdata$x:00003DB1                 db    0
.xdata$x:00003DB2                 db    0
.xdata$x:00003DB3                 db    0
.xdata$x:00003DB4                 dd offset __unwindtable$??$construct@PA_WAAPA_W@?$allocator@_W@std@@QAEXPAPA_WAAPA_W@Z
.xdata$x:00003DB8                 db    0
.xdata$x:00003DB9                 db    0
.xdata$x:00003DBA                 db    0
.xdata$x:00003DBB                 db    0
.xdata$x:00003DBC                 db    0
.xdata$x:00003DBD                 db    0
.xdata$x:00003DBE                 db    0
.xdata$x:00003DBF                 db    0
.xdata$x:00003DC0                 db    0
.xdata$x:00003DC1                 db    0
.xdata$x:00003DC2                 db    0
.xdata$x:00003DC3                 db    0
.xdata$x:00003DC4                 db    0
.xdata$x:00003DC5                 db    0
.xdata$x:00003DC6                 db    0
.xdata$x:00003DC7                 db    0
.xdata$x:00003DC8                 db    0
.xdata$x:00003DC9                 db    0
.xdata$x:00003DCA                 db    0
.xdata$x:00003DCB                 db    0
.xdata$x:00003DCC                 db    0
.xdata$x:00003DCD                 db    0
.xdata$x:00003DCE                 db    0
.xdata$x:00003DCF                 db    0
.xdata$x:00003DCF _xdata$x        ends
.xdata$x:00003DCF
.bss:00003DD0 ; ===========================================================================
.bss:00003DD0
.bss:00003DD0 ; Segment type: Uninitialized
.bss:00003DD0 ; Segment permissions: Read/Write
.bss:00003DD0 _bss            segment byte public 'BSS' use32
.bss:00003DD0                 assume cs:_bss
.bss:00003DD0                 ;org 3DD0h
.bss:00003DD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003DD0 _allocator_arg  db    ? ;
.bss:00003DD1 _piecewise_construct db    ? ;
.bss:00003DD2                 align 4
.bss:00003DD2 _bss            ends
.bss:00003DD2
.rdata:00003DD4 ; ===========================================================================
.rdata:00003DD4
.rdata:00003DD4 ; Segment type: Pure data
.rdata:00003DD4 ; Segment permissions: Read
.rdata:00003DD4 _rdata          segment dword public 'DATA' use32
.rdata:00003DD4                 assume cs:_rdata
.rdata:00003DD4                 ;org 3DD4h
.rdata:00003DD4 ; COMDAT (pick largest)
.rdata:00003DD4                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00003DD8                 public ??_7runtime_error@std@@6B@
.rdata:00003DD8 ; const std::runtime_error::`vftable'
.rdata:00003DD8 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00003DD8                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00003DD8                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00003DD8                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:00003DDC                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:00003DDC _rdata          ends
.rdata:00003DDC
.xdata$x:00003DE0 ; ===========================================================================
.xdata$x:00003DE0
.xdata$x:00003DE0 ; Segment type: Pure data
.xdata$x:00003DE0 ; Segment permissions: Read
.xdata$x:00003DE0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003DE0                 assume cs:_xdata$x
.xdata$x:00003DE0                 ;org 3DE0h
.xdata$x:00003DE0 ; COMDAT (pick any)
.xdata$x:00003DE0                 public __TI2?AVruntime_error@std@@
.xdata$x:00003DE0 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+AEo
.xdata$x:00003DE1                 db    0
.xdata$x:00003DE2                 db    0
.xdata$x:00003DE3                 db    0
.xdata$x:00003DE4                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00003DE8                 db    0
.xdata$x:00003DE9                 db    0
.xdata$x:00003DEA                 db    0
.xdata$x:00003DEB                 db    0
.xdata$x:00003DEC                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:00003DEC _xdata$x        ends
.xdata$x:00003DEC
.xdata$x:00003DF0 ; ===========================================================================
.xdata$x:00003DF0
.xdata$x:00003DF0 ; Segment type: Pure data
.xdata$x:00003DF0 ; Segment permissions: Read
.xdata$x:00003DF0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003DF0                 assume cs:_xdata$x
.xdata$x:00003DF0                 ;org 3DF0h
.xdata$x:00003DF0 ; COMDAT (pick any)
.xdata$x:00003DF0                 public __CTA2?AVruntime_error@std@@
.xdata$x:00003DF0 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:00003DECo
.xdata$x:00003DF1                 db    0
.xdata$x:00003DF2                 db    0
.xdata$x:00003DF3                 db    0
.xdata$x:00003DF4                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00003DF8                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00003DF8 _xdata$x        ends
.xdata$x:00003DF8
.data$r:00003DFC ; ===========================================================================
.data$r:00003DFC
.data$r:00003DFC ; Segment type: Pure data
.data$r:00003DFC ; Segment permissions: Read/Write
.data$r:00003DFC _data$r         segment dword public 'DATA' use32
.data$r:00003DFC                 assume cs:_data$r
.data$r:00003DFC                 ;org 3DFCh
.data$r:00003DFC ; COMDAT (pick any)
.data$r:00003DFC                 public ??_R0?AVruntime_error@std@@@8
.data$r:00003DFC ; class std::runtime_error `RTTI Type Descriptor'
.data$r:00003DFC ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003DFC                                         ; DATA XREF: .xdata$x:00003E20o
.data$r:00003DFC                                         ; .rdata$r:00004064o ...
.data$r:00003DFC                                         ; const type_info::`vftable'
.data$r:00003E00                 db    0
.data$r:00003E01                 db    0
.data$r:00003E02                 db    0
.data$r:00003E03                 db    0
.data$r:00003E04                 db  2Eh ; .
.data$r:00003E05                 db  3Fh ; ?
.data$r:00003E06                 db  41h ; A
.data$r:00003E07                 db  56h ; V
.data$r:00003E08                 db  72h ; r
.data$r:00003E09                 db  75h ; u
.data$r:00003E0A                 db  6Eh ; n
.data$r:00003E0B                 db  74h ; t
.data$r:00003E0C                 db  69h ; i
.data$r:00003E0D                 db  6Dh ; m
.data$r:00003E0E                 db  65h ; e
.data$r:00003E0F                 db  5Fh ; _
.data$r:00003E10                 db  65h ; e
.data$r:00003E11                 db  72h ; r
.data$r:00003E12                 db  72h ; r
.data$r:00003E13                 db  6Fh ; o
.data$r:00003E14                 db  72h ; r
.data$r:00003E15                 db  40h ; @
.data$r:00003E16                 db  73h ; s
.data$r:00003E17                 db  74h ; t
.data$r:00003E18                 db  64h ; d
.data$r:00003E19                 db  40h ; @
.data$r:00003E1A                 db  40h ; @
.data$r:00003E1B                 db    0
.data$r:00003E1B _data$r         ends
.data$r:00003E1B
.xdata$x:00003E1C ; ===========================================================================
.xdata$x:00003E1C
.xdata$x:00003E1C ; Segment type: Pure data
.xdata$x:00003E1C ; Segment permissions: Read
.xdata$x:00003E1C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003E1C                 assume cs:_xdata$x
.xdata$x:00003E1C                 ;org 3E1Ch
.xdata$x:00003E1C ; COMDAT (pick any)
.xdata$x:00003E1C                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00003E1C __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00003E1C                                         ; DATA XREF: .xdata$x:00003DF4o
.xdata$x:00003E1D                 db    0
.xdata$x:00003E1E                 db    0
.xdata$x:00003E1F                 db    0
.xdata$x:00003E20                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:00003E24                 align 8
.xdata$x:00003E28                 db 0FFh
.xdata$x:00003E29                 db 0FFh
.xdata$x:00003E2A                 db 0FFh
.xdata$x:00003E2B                 db 0FFh
.xdata$x:00003E2C                 db    0
.xdata$x:00003E2D                 db    0
.xdata$x:00003E2E                 db    0
.xdata$x:00003E2F                 db    0
.xdata$x:00003E30                 db  0Ch
.xdata$x:00003E31                 db    0
.xdata$x:00003E32                 db    0
.xdata$x:00003E33                 db    0
.xdata$x:00003E34                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:00003E34 _xdata$x        ends
.xdata$x:00003E34
.data$r:00003E38 ; ===========================================================================
.data$r:00003E38
.data$r:00003E38 ; Segment type: Pure data
.data$r:00003E38 ; Segment permissions: Read/Write
.data$r:00003E38 _data$r         segment dword public 'DATA' use32
.data$r:00003E38                 assume cs:_data$r
.data$r:00003E38                 ;org 3E38h
.data$r:00003E38 ; COMDAT (pick any)
.data$r:00003E38                 public ??_R0?AVexception@std@@@8
.data$r:00003E38 ; class std::exception `RTTI Type Descriptor'
.data$r:00003E38 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003E38                                         ; DATA XREF: .xdata$x:00003E58o
.data$r:00003E38                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003E38                                         ; const type_info::`vftable'
.data$r:00003E3C                 align 10h
.data$r:00003E40 a_?avexception@ db '.?AVexception@std@@',0
.data$r:00003E40 _data$r         ends
.data$r:00003E40
.xdata$x:00003E54 ; ===========================================================================
.xdata$x:00003E54
.xdata$x:00003E54 ; Segment type: Pure data
.xdata$x:00003E54 ; Segment permissions: Read
.xdata$x:00003E54 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003E54                 assume cs:_xdata$x
.xdata$x:00003E54                 ;org 3E54h
.xdata$x:00003E54 ; COMDAT (pick any)
.xdata$x:00003E54                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00003E54 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:00003E54                                         ; DATA XREF: .xdata$x:00003DF8o
.xdata$x:00003E55                 db    0
.xdata$x:00003E56                 db    0
.xdata$x:00003E57                 db    0
.xdata$x:00003E58                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:00003E5C                 align 10h
.xdata$x:00003E60                 db 0FFh
.xdata$x:00003E61                 db 0FFh
.xdata$x:00003E62                 db 0FFh
.xdata$x:00003E63                 db 0FFh
.xdata$x:00003E64                 db    0
.xdata$x:00003E65                 db    0
.xdata$x:00003E66                 db    0
.xdata$x:00003E67                 db    0
.xdata$x:00003E68                 db  0Ch
.xdata$x:00003E69                 db    0
.xdata$x:00003E6A                 db    0
.xdata$x:00003E6B                 db    0
.xdata$x:00003E6C                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:00003E6C _xdata$x        ends
.xdata$x:00003E6C
.rdata:00003E70 ; ===========================================================================
.rdata:00003E70
.rdata:00003E70 ; Segment type: Pure data
.rdata:00003E70 ; Segment permissions: Read
.rdata:00003E70 _rdata          segment dword public 'DATA' use32
.rdata:00003E70                 assume cs:_rdata
.rdata:00003E70                 ;org 3E70h
.rdata:00003E70 ; COMDAT (pick largest)
.rdata:00003E70                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00003E74                 public ??_7error_category@std@@6B@
.rdata:00003E74 ; const std::error_category::`vftable'
.rdata:00003E74 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00003E74                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00003E74                                         ; std::error_category::~error_category(void)+Ao
.rdata:00003E74                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00003E78                 dd offset __purecall
.rdata:00003E7C                 dd offset __purecall
.rdata:00003E80                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003E84                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003E88                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003E88 _rdata          ends
.rdata:00003E88
.rdata:00003E8C ; ===========================================================================
.rdata:00003E8C
.rdata:00003E8C ; Segment type: Pure data
.rdata:00003E8C ; Segment permissions: Read
.rdata:00003E8C _rdata          segment dword public 'DATA' use32
.rdata:00003E8C                 assume cs:_rdata
.rdata:00003E8C                 ;org 3E8Ch
.rdata:00003E8C ; COMDAT (pick largest)
.rdata:00003E8C                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00003E90                 public ??_7_Generic_error_category@std@@6B@
.rdata:00003E90 ; const std::_Generic_error_category::`vftable'
.rdata:00003E90 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00003E90                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00003E90                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00003E94                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00003E98                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00003E9C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003EA0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003EA4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003EA4 _rdata          ends
.rdata:00003EA4
.rdata:00003EA8 ; ===========================================================================
.rdata:00003EA8
.rdata:00003EA8 ; Segment type: Pure data
.rdata:00003EA8 ; Segment permissions: Read
.rdata:00003EA8 _rdata          segment dword public 'DATA' use32
.rdata:00003EA8                 assume cs:_rdata
.rdata:00003EA8                 ;org 3EA8h
.rdata:00003EA8 ; COMDAT (pick any)
.rdata:00003EA8                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00003EA8 ; `string'
.rdata:00003EA8 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00003EA8                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00003EA8 _rdata          ends
.rdata:00003EA8
.rdata:00003EB0 ; ===========================================================================
.rdata:00003EB0
.rdata:00003EB0 ; Segment type: Pure data
.rdata:00003EB0 ; Segment permissions: Read
.rdata:00003EB0 _rdata          segment dword public 'DATA' use32
.rdata:00003EB0                 assume cs:_rdata
.rdata:00003EB0                 ;org 3EB0h
.rdata:00003EB0 ; COMDAT (pick any)
.rdata:00003EB0                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00003EB0 ; `string'
.rdata:00003EB0 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00003EB0                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_33C8o
.rdata:00003EB0                                         ; std::_System_error_category::message(int):loc_3544o
.rdata:00003EBE                 align 10h
.rdata:00003EBE _rdata          ends
.rdata:00003EBE
.rdata:00003EC0 ; ===========================================================================
.rdata:00003EC0
.rdata:00003EC0 ; Segment type: Pure data
.rdata:00003EC0 ; Segment permissions: Read
.rdata:00003EC0 _rdata          segment dword public 'DATA' use32
.rdata:00003EC0                 assume cs:_rdata
.rdata:00003EC0                 ;org 3EC0h
.rdata:00003EC0 ; COMDAT (pick largest)
.rdata:00003EC0                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00003EC4                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00003EC4 ; const std::_Iostream_error_category::`vftable'
.rdata:00003EC4 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00003EC4                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00003EC4                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00003EC8                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00003ECC                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00003ED0                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003ED4                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003ED8                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003ED8 _rdata          ends
.rdata:00003ED8
.rdata:00003EDC ; ===========================================================================
.rdata:00003EDC
.rdata:00003EDC ; Segment type: Pure data
.rdata:00003EDC ; Segment permissions: Read
.rdata:00003EDC _rdata          segment dword public 'DATA' use32
.rdata:00003EDC                 assume cs:_rdata
.rdata:00003EDC                 ;org 3EDCh
.rdata:00003EDC ; COMDAT (pick any)
.rdata:00003EDC                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00003EDC ; `string'
.rdata:00003EDC ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00003EDC                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00003EE5                 align 4
.rdata:00003EE5 _rdata          ends
.rdata:00003EE5
.rdata:00003EE8 ; ===========================================================================
.rdata:00003EE8
.rdata:00003EE8 ; Segment type: Pure data
.rdata:00003EE8 ; Segment permissions: Read
.rdata:00003EE8 _rdata          segment dword public 'DATA' use32
.rdata:00003EE8                 assume cs:_rdata
.rdata:00003EE8                 ;org 3EE8h
.rdata:00003EE8 ; COMDAT (pick any)
.rdata:00003EE8                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00003EE8 ; char `string'[]
.rdata:00003EE8 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00003EE8                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00003EFE                 align 10h
.rdata:00003EFE _rdata          ends
.rdata:00003EFE
.rdata:00003F00 ; ===========================================================================
.rdata:00003F00
.rdata:00003F00 ; Segment type: Pure data
.rdata:00003F00 ; Segment permissions: Read
.rdata:00003F00 _rdata          segment dword public 'DATA' use32
.rdata:00003F00                 assume cs:_rdata
.rdata:00003F00                 ;org 3F00h
.rdata:00003F00 ; COMDAT (pick largest)
.rdata:00003F00                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00003F04                 public ??_7_System_error_category@std@@6B@
.rdata:00003F04 ; const std::_System_error_category::`vftable'
.rdata:00003F04 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00003F04                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00003F04                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00003F08                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00003F0C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00003F10                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00003F14                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003F18                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003F18 _rdata          ends
.rdata:00003F18
.rdata:00003F1C ; ===========================================================================
.rdata:00003F1C
.rdata:00003F1C ; Segment type: Pure data
.rdata:00003F1C ; Segment permissions: Read
.rdata:00003F1C _rdata          segment dword public 'DATA' use32
.rdata:00003F1C                 assume cs:_rdata
.rdata:00003F1C                 ;org 3F1Ch
.rdata:00003F1C ; COMDAT (pick any)
.rdata:00003F1C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00003F1C ; `string'
.rdata:00003F1C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00003F1C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00003F23                 align 4
.rdata:00003F23 _rdata          ends
.rdata:00003F23
.bss:00003F24 ; ===========================================================================
.bss:00003F24
.bss:00003F24 ; Segment type: Uninitialized
.bss:00003F24 ; Segment permissions: Read/Write
.bss:00003F24 _bss            segment dword public 'BSS' use32
.bss:00003F24                 assume cs:_bss
.bss:00003F24                 ;org 3F24h
.bss:00003F24 ; COMDAT (pick any)
.bss:00003F24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003F24                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00003F24 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00003F24 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00003F24                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00003F24                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00003F25                 db    ? ;
.bss:00003F26                 db    ? ;
.bss:00003F27                 db    ? ;
.bss:00003F27 _bss            ends
.bss:00003F27
.bss:00003F28 ; ===========================================================================
.bss:00003F28
.bss:00003F28 ; Segment type: Uninitialized
.bss:00003F28 ; Segment permissions: Read/Write
.bss:00003F28 _bss            segment dword public 'BSS' use32
.bss:00003F28                 assume cs:_bss
.bss:00003F28                 ;org 3F28h
.bss:00003F28 ; COMDAT (pick any)
.bss:00003F28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003F28                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00003F28 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00003F28 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00003F28                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003F28                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00003F29                 db    ? ;
.bss:00003F2A                 db    ? ;
.bss:00003F2B                 db    ? ;
.bss:00003F2B _bss            ends
.bss:00003F2B
.bss:00003F2C ; ===========================================================================
.bss:00003F2C
.bss:00003F2C ; Segment type: Uninitialized
.bss:00003F2C ; Segment permissions: Read/Write
.bss:00003F2C _bss            segment dword public 'BSS' use32
.bss:00003F2C                 assume cs:_bss
.bss:00003F2C                 ;org 3F2Ch
.bss:00003F2C ; COMDAT (pick any)
.bss:00003F2C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003F2C                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00003F2C ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00003F2C ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00003F2C                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00003F2C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00003F2D                 db    ? ;
.bss:00003F2E                 db    ? ;
.bss:00003F2F                 db    ? ;
.bss:00003F2F _bss            ends
.bss:00003F2F
.bss:00003F30 ; ===========================================================================
.bss:00003F30
.bss:00003F30 ; Segment type: Uninitialized
.bss:00003F30 ; Segment permissions: Read/Write
.bss:00003F30 _bss            segment dword public 'BSS' use32
.bss:00003F30                 assume cs:_bss
.bss:00003F30                 ;org 3F30h
.bss:00003F30 ; COMDAT (pick any)
.bss:00003F30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003F30                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00003F30 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00003F30 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00003F30                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00003F31                 db    ? ;
.bss:00003F32                 db    ? ;
.bss:00003F33                 db    ? ;
.bss:00003F33 _bss            ends
.bss:00003F33
.bss:00003F34 ; ===========================================================================
.bss:00003F34
.bss:00003F34 ; Segment type: Uninitialized
.bss:00003F34 ; Segment permissions: Read/Write
.bss:00003F34 _bss            segment dword public 'BSS' use32
.bss:00003F34                 assume cs:_bss
.bss:00003F34                 ;org 3F34h
.bss:00003F34 ; COMDAT (pick any)
.bss:00003F34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003F34                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00003F34 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00003F34 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00003F34                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00003F35                 db    ? ;
.bss:00003F36                 db    ? ;
.bss:00003F37                 db    ? ;
.bss:00003F37 _bss            ends
.bss:00003F37
.rdata:00003F38 ; ===========================================================================
.rdata:00003F38
.rdata:00003F38 ; Segment type: Pure data
.rdata:00003F38 ; Segment permissions: Read
.rdata:00003F38 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00003F38 _rdata          segment para public 'DATA' use32
.rdata:00003F38                 assume cs:_rdata
.rdata:00003F38                 ;org 3F38h
.rdata:00003F38 ; COMDAT (pick any)
.rdata:00003F38                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00003F38 ; wchar_t `string'
.rdata:00003F38 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00003F38                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00003F38                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o ...
.rdata:00003F38                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00003F38                 unicode 0, <clude\xstring>,0
.rdata:00003FC6                 align 4
.rdata:00003FC6 _rdata          ends
.rdata:00003FC6
.bss:00003FC8 ; ===========================================================================
.bss:00003FC8
.bss:00003FC8 ; Segment type: Uninitialized
.bss:00003FC8 ; Segment permissions: Read/Write
.bss:00003FC8 _bss            segment dword public 'BSS' use32
.bss:00003FC8                 assume cs:_bss
.bss:00003FC8                 ;org 3FC8h
.bss:00003FC8 ; COMDAT (pick any)
.bss:00003FC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003FC8                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00003FC8 ; std::locale::id std::numpunct<char>::id
.bss:00003FC8 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00003FC8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00003FC9                 db    ? ;
.bss:00003FCA                 db    ? ;
.bss:00003FCB                 db    ? ;
.bss:00003FCB _bss            ends
.bss:00003FCB
.bss:00003FCC ; ===========================================================================
.bss:00003FCC
.bss:00003FCC ; Segment type: Uninitialized
.bss:00003FCC ; Segment permissions: Read/Write
.bss:00003FCC _bss            segment dword public 'BSS' use32
.bss:00003FCC                 assume cs:_bss
.bss:00003FCC                 ;org 3FCCh
.bss:00003FCC ; COMDAT (pick any)
.bss:00003FCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00003FCC                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00003FCC ; std::locale::id std::numpunct<wchar_t>::id
.bss:00003FCC ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00003FCC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00003FCD                 db    ? ;
.bss:00003FCE                 db    ? ;
.bss:00003FCF                 db    ? ;
.bss:00003FCF _bss            ends
.bss:00003FCF
.rdata:00003FD0 ; ===========================================================================
.rdata:00003FD0
.rdata:00003FD0 ; Segment type: Pure data
.rdata:00003FD0 ; Segment permissions: Read
.rdata:00003FD0 _rdata          segment dword public 'DATA' use32
.rdata:00003FD0                 assume cs:_rdata
.rdata:00003FD0                 ;org 3FD0h
.rdata:00003FD0 ; COMDAT (pick any)
.rdata:00003FD0                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00003FD0 ; char `string'[]
.rdata:00003FD0 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00003FD0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00003FD0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+7o
.rdata:00003FD0 _rdata          ends
.rdata:00003FD0
.rdata:00003FE0 ; ===========================================================================
.rdata:00003FE0
.rdata:00003FE0 ; Segment type: Pure data
.rdata:00003FE0 ; Segment permissions: Read
.rdata:00003FE0 _rdata          segment dword public 'DATA' use32
.rdata:00003FE0                 assume cs:_rdata
.rdata:00003FE0                 ;org 3FE0h
.rdata:00003FE0 ; COMDAT (pick any)
.rdata:00003FE0                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00003FE0 ; char `string'[]
.rdata:00003FE0 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00003FE0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00003FE0                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+7o
.rdata:00003FE0 _rdata          ends
.rdata:00003FE0
.rdata:00003FF8 ; ===========================================================================
.rdata:00003FF8
.rdata:00003FF8 ; Segment type: Pure data
.rdata:00003FF8 ; Segment permissions: Read
.rdata:00003FF8 _rdata          segment dword public 'DATA' use32
.rdata:00003FF8                 assume cs:_rdata
.rdata:00003FF8                 ;org 3FF8h
.rdata:00003FF8 ; COMDAT (pick any)
.rdata:00003FF8                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00003FF8 ; wchar_t `string'
.rdata:00003FF8 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00003FF8                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00003FF8                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+11o
.rdata:00003FF8                 unicode 0, <invalid null pointer>,0
.rdata:00004022                 align 4
.rdata:00004022 _rdata          ends
.rdata:00004022
.rdata$r:00004024 ; ===========================================================================
.rdata$r:00004024
.rdata$r:00004024 ; Segment type: Pure data
.rdata$r:00004024 ; Segment permissions: Read
.rdata$r:00004024 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004024                 assume cs:_rdata$r
.rdata$r:00004024                 ;org 4024h
.rdata$r:00004024 ; COMDAT (pick any)
.rdata$r:00004024                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00004024 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004024 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00004024                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00004024                                         ; .rdata$r:00004080o
.rdata$r:00004024                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00004028                 align 10h
.rdata$r:00004030                 db 0FFh
.rdata$r:00004031                 db 0FFh
.rdata$r:00004032                 db 0FFh
.rdata$r:00004033                 db 0FFh
.rdata$r:00004034                 db    0
.rdata$r:00004035                 db    0
.rdata$r:00004036                 db    0
.rdata$r:00004037                 db    0
.rdata$r:00004038                 db  40h ; @
.rdata$r:00004039                 db    0
.rdata$r:0000403A                 db    0
.rdata$r:0000403B                 db    0
.rdata$r:0000403C                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000403C _rdata$r        ends
.rdata$r:0000403C
.rdata$r:00004040 ; ===========================================================================
.rdata$r:00004040
.rdata$r:00004040 ; Segment type: Pure data
.rdata$r:00004040 ; Segment permissions: Read
.rdata$r:00004040 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004040                 assume cs:_rdata$r
.rdata$r:00004040                 ;org 4040h
.rdata$r:00004040 ; COMDAT (pick any)
.rdata$r:00004040                 public ??_R3exception@std@@8
.rdata$r:00004040 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004040 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:0000403Co
.rdata$r:00004041                 db    0
.rdata$r:00004042                 db    0
.rdata$r:00004043                 db    0
.rdata$r:00004044                 db    0
.rdata$r:00004045                 db    0
.rdata$r:00004046                 db    0
.rdata$r:00004047                 db    0
.rdata$r:00004048                 db    1
.rdata$r:00004049                 db    0
.rdata$r:0000404A                 db    0
.rdata$r:0000404B                 db    0
.rdata$r:0000404C                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:0000404C _rdata$r        ends
.rdata$r:0000404C
.rdata$r:00004050 ; ===========================================================================
.rdata$r:00004050
.rdata$r:00004050 ; Segment type: Pure data
.rdata$r:00004050 ; Segment permissions: Read
.rdata$r:00004050 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004050                 assume cs:_rdata$r
.rdata$r:00004050                 ;org 4050h
.rdata$r:00004050 ; COMDAT (pick any)
.rdata$r:00004050                 public ??_R2exception@std@@8
.rdata$r:00004050 ; std::exception::`RTTI Base Class Array'
.rdata$r:00004050 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00004050                                         ; DATA XREF: .rdata$r:0000404Co
.rdata$r:00004050                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004054                 db    0
.rdata$r:00004055                 align 4
.rdata$r:00004055 _rdata$r        ends
.rdata$r:00004055
.rdata$r:00004058 ; ===========================================================================
.rdata$r:00004058
.rdata$r:00004058 ; Segment type: Pure data
.rdata$r:00004058 ; Segment permissions: Read
.rdata$r:00004058 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004058                 assume cs:_rdata$r
.rdata$r:00004058                 ;org 4058h
.rdata$r:00004058 ; COMDAT (pick any)
.rdata$r:00004058                 public ??_R4runtime_error@std@@6B@
.rdata$r:00004058 ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00004058 ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00003DD4o
.rdata$r:00004059                 db    0
.rdata$r:0000405A                 db    0
.rdata$r:0000405B                 db    0
.rdata$r:0000405C                 db    0
.rdata$r:0000405D                 db    0
.rdata$r:0000405E                 db    0
.rdata$r:0000405F                 db    0
.rdata$r:00004060                 db    0
.rdata$r:00004061                 db    0
.rdata$r:00004062                 db    0
.rdata$r:00004063                 db    0
.rdata$r:00004064                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00004068                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004068 _rdata$r        ends
.rdata$r:00004068
.rdata$r:0000406C ; ===========================================================================
.rdata$r:0000406C
.rdata$r:0000406C ; Segment type: Pure data
.rdata$r:0000406C ; Segment permissions: Read
.rdata$r:0000406C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000406C                 assume cs:_rdata$r
.rdata$r:0000406C                 ;org 406Ch
.rdata$r:0000406C ; COMDAT (pick any)
.rdata$r:0000406C                 public ??_R3runtime_error@std@@8
.rdata$r:0000406C ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000406C ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00004068o
.rdata$r:0000406C                                         ; .rdata$r:000040A0o
.rdata$r:0000406D                 db    0
.rdata$r:0000406E                 db    0
.rdata$r:0000406F                 db    0
.rdata$r:00004070                 db    0
.rdata$r:00004071                 db    0
.rdata$r:00004072                 db    0
.rdata$r:00004073                 db    0
.rdata$r:00004074                 db    2
.rdata$r:00004075                 db    0
.rdata$r:00004076                 db    0
.rdata$r:00004077                 db    0
.rdata$r:00004078                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00004078 _rdata$r        ends
.rdata$r:00004078
.rdata$r:0000407C ; ===========================================================================
.rdata$r:0000407C
.rdata$r:0000407C ; Segment type: Pure data
.rdata$r:0000407C ; Segment permissions: Read
.rdata$r:0000407C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000407C                 assume cs:_rdata$r
.rdata$r:0000407C                 ;org 407Ch
.rdata$r:0000407C ; COMDAT (pick any)
.rdata$r:0000407C                 public ??_R2runtime_error@std@@8
.rdata$r:0000407C ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:0000407C ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:0000407C                                         ; DATA XREF: .rdata$r:00004078o
.rdata$r:0000407C                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004080                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004084                 db    0
.rdata$r:00004085                 align 4
.rdata$r:00004085 _rdata$r        ends
.rdata$r:00004085
.rdata$r:00004088 ; ===========================================================================
.rdata$r:00004088
.rdata$r:00004088 ; Segment type: Pure data
.rdata$r:00004088 ; Segment permissions: Read
.rdata$r:00004088 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004088                 assume cs:_rdata$r
.rdata$r:00004088                 ;org 4088h
.rdata$r:00004088 ; COMDAT (pick any)
.rdata$r:00004088                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00004088 ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004088 ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00004088                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00004088                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:0000408C                 db    1
.rdata$r:0000408D                 db    0
.rdata$r:0000408E                 db    0
.rdata$r:0000408F                 db    0
.rdata$r:00004090                 db    0
.rdata$r:00004091                 db    0
.rdata$r:00004092                 db    0
.rdata$r:00004093                 db    0
.rdata$r:00004094                 db 0FFh
.rdata$r:00004095                 db 0FFh
.rdata$r:00004096                 db 0FFh
.rdata$r:00004097                 db 0FFh
.rdata$r:00004098                 db    0
.rdata$r:00004099                 db    0
.rdata$r:0000409A                 db    0
.rdata$r:0000409B                 db    0
.rdata$r:0000409C                 db  40h ; @
.rdata$r:0000409D                 db    0
.rdata$r:0000409E                 db    0
.rdata$r:0000409F                 db    0
.rdata$r:000040A0                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:000040A0 _rdata$r        ends
.rdata$r:000040A0
.rdata$r:000040A4 ; ===========================================================================
.rdata$r:000040A4
.rdata$r:000040A4 ; Segment type: Pure data
.rdata$r:000040A4 ; Segment permissions: Read
.rdata$r:000040A4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000040A4                 assume cs:_rdata$r
.rdata$r:000040A4                 ;org 40A4h
.rdata$r:000040A4 ; COMDAT (pick any)
.rdata$r:000040A4                 public ??_R4error_category@std@@6B@
.rdata$r:000040A4 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000040A4 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:00003E70o
.rdata$r:000040A5                 db    0
.rdata$r:000040A6                 db    0
.rdata$r:000040A7                 db    0
.rdata$r:000040A8                 db    0
.rdata$r:000040A9                 db    0
.rdata$r:000040AA                 db    0
.rdata$r:000040AB                 db    0
.rdata$r:000040AC                 db    0
.rdata$r:000040AD                 db    0
.rdata$r:000040AE                 db    0
.rdata$r:000040AF                 db    0
.rdata$r:000040B0                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000040B4                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000040B4 _rdata$r        ends
.rdata$r:000040B4
.data$r:000040B8 ; ===========================================================================
.data$r:000040B8
.data$r:000040B8 ; Segment type: Pure data
.data$r:000040B8 ; Segment permissions: Read/Write
.data$r:000040B8 _data$r         segment dword public 'DATA' use32
.data$r:000040B8                 assume cs:_data$r
.data$r:000040B8                 ;org 40B8h
.data$r:000040B8 ; COMDAT (pick any)
.data$r:000040B8                 public ??_R0?AVerror_category@std@@@8
.data$r:000040B8 ; class std::error_category `RTTI Type Descriptor'
.data$r:000040B8 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000040B8                                         ; DATA XREF: .rdata$r:000040B0o
.data$r:000040B8                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000040B8                                         ; const type_info::`vftable'
.data$r:000040BC                 align 10h
.data$r:000040C0 a_?averror_cate db '.?AVerror_category@std@@',0
.data$r:000040D9                 align 4
.data$r:000040D9 _data$r         ends
.data$r:000040D9
.rdata$r:000040DC ; ===========================================================================
.rdata$r:000040DC
.rdata$r:000040DC ; Segment type: Pure data
.rdata$r:000040DC ; Segment permissions: Read
.rdata$r:000040DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000040DC                 assume cs:_rdata$r
.rdata$r:000040DC                 ;org 40DCh
.rdata$r:000040DC ; COMDAT (pick any)
.rdata$r:000040DC                 public ??_R3error_category@std@@8
.rdata$r:000040DC ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000040DC ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000040B4o
.rdata$r:000040DC                                         ; .rdata$r:0000410Co
.rdata$r:000040DD                 db    0
.rdata$r:000040DE                 db    0
.rdata$r:000040DF                 db    0
.rdata$r:000040E0                 db    0
.rdata$r:000040E1                 db    0
.rdata$r:000040E2                 db    0
.rdata$r:000040E3                 db    0
.rdata$r:000040E4                 db    1
.rdata$r:000040E5                 db    0
.rdata$r:000040E6                 db    0
.rdata$r:000040E7                 db    0
.rdata$r:000040E8                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000040E8 _rdata$r        ends
.rdata$r:000040E8
.rdata$r:000040EC ; ===========================================================================
.rdata$r:000040EC
.rdata$r:000040EC ; Segment type: Pure data
.rdata$r:000040EC ; Segment permissions: Read
.rdata$r:000040EC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000040EC                 assume cs:_rdata$r
.rdata$r:000040EC                 ;org 40ECh
.rdata$r:000040EC ; COMDAT (pick any)
.rdata$r:000040EC                 public ??_R2error_category@std@@8
.rdata$r:000040EC ; std::error_category::`RTTI Base Class Array'
.rdata$r:000040EC ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000040EC                                         ; DATA XREF: .rdata$r:000040E8o
.rdata$r:000040EC                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000040F0                 db    0
.rdata$r:000040F1                 align 4
.rdata$r:000040F1 _rdata$r        ends
.rdata$r:000040F1
.rdata$r:000040F4 ; ===========================================================================
.rdata$r:000040F4
.rdata$r:000040F4 ; Segment type: Pure data
.rdata$r:000040F4 ; Segment permissions: Read
.rdata$r:000040F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000040F4                 assume cs:_rdata$r
.rdata$r:000040F4                 ;org 40F4h
.rdata$r:000040F4 ; COMDAT (pick any)
.rdata$r:000040F4                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000040F4 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000040F4 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:000040F4                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:000040F4                                         ; .rdata$r:00004164o ...
.rdata$r:000040F4                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:000040F8                 align 10h
.rdata$r:00004100                 db 0FFh
.rdata$r:00004101                 db 0FFh
.rdata$r:00004102                 db 0FFh
.rdata$r:00004103                 db 0FFh
.rdata$r:00004104                 db    0
.rdata$r:00004105                 db    0
.rdata$r:00004106                 db    0
.rdata$r:00004107                 db    0
.rdata$r:00004108                 db  40h ; @
.rdata$r:00004109                 db    0
.rdata$r:0000410A                 db    0
.rdata$r:0000410B                 db    0
.rdata$r:0000410C                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000410C _rdata$r        ends
.rdata$r:0000410C
.rdata$r:00004110 ; ===========================================================================
.rdata$r:00004110
.rdata$r:00004110 ; Segment type: Pure data
.rdata$r:00004110 ; Segment permissions: Read
.rdata$r:00004110 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004110                 assume cs:_rdata$r
.rdata$r:00004110                 ;org 4110h
.rdata$r:00004110 ; COMDAT (pick any)
.rdata$r:00004110                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00004110 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00004110 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00004110                                         ; DATA XREF: .rdata:00003E8Co
.rdata$r:00004111                 db    0
.rdata$r:00004112                 db    0
.rdata$r:00004113                 db    0
.rdata$r:00004114                 db    0
.rdata$r:00004115                 db    0
.rdata$r:00004116                 db    0
.rdata$r:00004117                 db    0
.rdata$r:00004118                 db    0
.rdata$r:00004119                 db    0
.rdata$r:0000411A                 db    0
.rdata$r:0000411B                 db    0
.rdata$r:0000411C                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004120                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004120 _rdata$r        ends
.rdata$r:00004120
.data$r:00004124 ; ===========================================================================
.data$r:00004124
.data$r:00004124 ; Segment type: Pure data
.data$r:00004124 ; Segment permissions: Read/Write
.data$r:00004124 _data$r         segment dword public 'DATA' use32
.data$r:00004124                 assume cs:_data$r
.data$r:00004124                 ;org 4124h
.data$r:00004124 ; COMDAT (pick any)
.data$r:00004124                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00004124 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00004124 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004124                                         ; DATA XREF: .rdata$r:0000411Co
.data$r:00004124                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004124                                         ; const type_info::`vftable'
.data$r:00004128                 db    0
.data$r:00004129                 db    0
.data$r:0000412A                 db    0
.data$r:0000412B                 db    0
.data$r:0000412C                 db  2Eh ; .
.data$r:0000412D                 db  3Fh ; ?
.data$r:0000412E                 db  41h ; A
.data$r:0000412F                 db  56h ; V
.data$r:00004130                 db  5Fh ; _
.data$r:00004131                 db  47h ; G
.data$r:00004132                 db  65h ; e
.data$r:00004133                 db  6Eh ; n
.data$r:00004134                 db  65h ; e
.data$r:00004135                 db  72h ; r
.data$r:00004136                 db  69h ; i
.data$r:00004137                 db  63h ; c
.data$r:00004138                 db  5Fh ; _
.data$r:00004139                 db  65h ; e
.data$r:0000413A                 db  72h ; r
.data$r:0000413B                 db  72h ; r
.data$r:0000413C                 db  6Fh ; o
.data$r:0000413D                 db  72h ; r
.data$r:0000413E                 db  5Fh ; _
.data$r:0000413F                 db  63h ; c
.data$r:00004140                 db  61h ; a
.data$r:00004141                 db  74h ; t
.data$r:00004142                 db  65h ; e
.data$r:00004143                 db  67h ; g
.data$r:00004144                 db  6Fh ; o
.data$r:00004145                 db  72h ; r
.data$r:00004146                 db  79h ; y
.data$r:00004147                 db  40h ; @
.data$r:00004148                 db  73h ; s
.data$r:00004149                 db  74h ; t
.data$r:0000414A                 db  64h ; d
.data$r:0000414B                 db  40h ; @
.data$r:0000414C                 db  40h ; @
.data$r:0000414D                 db    0
.data$r:0000414E                 align 10h
.data$r:0000414E _data$r         ends
.data$r:0000414E
.rdata$r:00004150 ; ===========================================================================
.rdata$r:00004150
.rdata$r:00004150 ; Segment type: Pure data
.rdata$r:00004150 ; Segment permissions: Read
.rdata$r:00004150 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004150                 assume cs:_rdata$r
.rdata$r:00004150                 ;org 4150h
.rdata$r:00004150 ; COMDAT (pick any)
.rdata$r:00004150                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00004150 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004150 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00004150                                         ; DATA XREF: .rdata$r:00004120o
.rdata$r:00004150                                         ; .rdata$r:00004184o
.rdata$r:00004151                 db    0
.rdata$r:00004152                 db    0
.rdata$r:00004153                 db    0
.rdata$r:00004154                 db    0
.rdata$r:00004155                 db    0
.rdata$r:00004156                 db    0
.rdata$r:00004157                 db    0
.rdata$r:00004158                 db    2
.rdata$r:00004159                 db    0
.rdata$r:0000415A                 db    0
.rdata$r:0000415B                 db    0
.rdata$r:0000415C                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000415C _rdata$r        ends
.rdata$r:0000415C
.rdata$r:00004160 ; ===========================================================================
.rdata$r:00004160
.rdata$r:00004160 ; Segment type: Pure data
.rdata$r:00004160 ; Segment permissions: Read
.rdata$r:00004160 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004160                 assume cs:_rdata$r
.rdata$r:00004160                 ;org 4160h
.rdata$r:00004160 ; COMDAT (pick any)
.rdata$r:00004160                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00004160 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00004160 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00004160                                         ; DATA XREF: .rdata$r:0000415Co
.rdata$r:00004160                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004164                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004168                 db    0
.rdata$r:00004169                 align 4
.rdata$r:00004169 _rdata$r        ends
.rdata$r:00004169
.rdata$r:0000416C ; ===========================================================================
.rdata$r:0000416C
.rdata$r:0000416C ; Segment type: Pure data
.rdata$r:0000416C ; Segment permissions: Read
.rdata$r:0000416C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000416C                 assume cs:_rdata$r
.rdata$r:0000416C                 ;org 416Ch
.rdata$r:0000416C ; COMDAT (pick any)
.rdata$r:0000416C                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000416C ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:0000416C ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:0000416C                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:0000416C                                         ; .rdata$r:000041DCo ...
.rdata$r:0000416C                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00004170                 db    1
.rdata$r:00004171                 db    0
.rdata$r:00004172                 db    0
.rdata$r:00004173                 db    0
.rdata$r:00004174                 db    0
.rdata$r:00004175                 db    0
.rdata$r:00004176                 db    0
.rdata$r:00004177                 db    0
.rdata$r:00004178                 db 0FFh
.rdata$r:00004179                 db 0FFh
.rdata$r:0000417A                 db 0FFh
.rdata$r:0000417B                 db 0FFh
.rdata$r:0000417C                 db    0
.rdata$r:0000417D                 db    0
.rdata$r:0000417E                 db    0
.rdata$r:0000417F                 db    0
.rdata$r:00004180                 db  40h ; @
.rdata$r:00004181                 db    0
.rdata$r:00004182                 db    0
.rdata$r:00004183                 db    0
.rdata$r:00004184                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004184 _rdata$r        ends
.rdata$r:00004184
.rdata$r:00004188 ; ===========================================================================
.rdata$r:00004188
.rdata$r:00004188 ; Segment type: Pure data
.rdata$r:00004188 ; Segment permissions: Read
.rdata$r:00004188 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004188                 assume cs:_rdata$r
.rdata$r:00004188                 ;org 4188h
.rdata$r:00004188 ; COMDAT (pick any)
.rdata$r:00004188                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00004188 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00004188 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00004188                                         ; DATA XREF: .rdata:00003EC0o
.rdata$r:00004189                 db    0
.rdata$r:0000418A                 db    0
.rdata$r:0000418B                 db    0
.rdata$r:0000418C                 db    0
.rdata$r:0000418D                 db    0
.rdata$r:0000418E                 db    0
.rdata$r:0000418F                 db    0
.rdata$r:00004190                 db    0
.rdata$r:00004191                 db    0
.rdata$r:00004192                 db    0
.rdata$r:00004193                 db    0
.rdata$r:00004194                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:00004198                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004198 _rdata$r        ends
.rdata$r:00004198
.data$r:0000419C ; ===========================================================================
.data$r:0000419C
.data$r:0000419C ; Segment type: Pure data
.data$r:0000419C ; Segment permissions: Read/Write
.data$r:0000419C _data$r         segment dword public 'DATA' use32
.data$r:0000419C                 assume cs:_data$r
.data$r:0000419C                 ;org 419Ch
.data$r:0000419C ; COMDAT (pick any)
.data$r:0000419C                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:0000419C ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:0000419C ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000419C                                         ; DATA XREF: .rdata$r:00004194o
.data$r:0000419C                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000419C                                         ; const type_info::`vftable'
.data$r:000041A0                 db    0
.data$r:000041A1                 db    0
.data$r:000041A2                 db    0
.data$r:000041A3                 db    0
.data$r:000041A4                 db  2Eh ; .
.data$r:000041A5                 db  3Fh ; ?
.data$r:000041A6                 db  41h ; A
.data$r:000041A7                 db  56h ; V
.data$r:000041A8                 db  5Fh ; _
.data$r:000041A9                 db  49h ; I
.data$r:000041AA                 db  6Fh ; o
.data$r:000041AB                 db  73h ; s
.data$r:000041AC                 db  74h ; t
.data$r:000041AD                 db  72h ; r
.data$r:000041AE                 db  65h ; e
.data$r:000041AF                 db  61h ; a
.data$r:000041B0                 db  6Dh ; m
.data$r:000041B1                 db  5Fh ; _
.data$r:000041B2                 db  65h ; e
.data$r:000041B3                 db  72h ; r
.data$r:000041B4                 db  72h ; r
.data$r:000041B5                 db  6Fh ; o
.data$r:000041B6                 db  72h ; r
.data$r:000041B7                 db  5Fh ; _
.data$r:000041B8                 db  63h ; c
.data$r:000041B9                 db  61h ; a
.data$r:000041BA                 db  74h ; t
.data$r:000041BB                 db  65h ; e
.data$r:000041BC                 db  67h ; g
.data$r:000041BD                 db  6Fh ; o
.data$r:000041BE                 db  72h ; r
.data$r:000041BF                 db  79h ; y
.data$r:000041C0                 db  40h ; @
.data$r:000041C1                 db  73h ; s
.data$r:000041C2                 db  74h ; t
.data$r:000041C3                 db  64h ; d
.data$r:000041C4                 db  40h ; @
.data$r:000041C5                 db  40h ; @
.data$r:000041C6                 db    0
.data$r:000041C7                 align 4
.data$r:000041C7 _data$r         ends
.data$r:000041C7
.rdata$r:000041C8 ; ===========================================================================
.rdata$r:000041C8
.rdata$r:000041C8 ; Segment type: Pure data
.rdata$r:000041C8 ; Segment permissions: Read
.rdata$r:000041C8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000041C8                 assume cs:_rdata$r
.rdata$r:000041C8                 ;org 41C8h
.rdata$r:000041C8 ; COMDAT (pick any)
.rdata$r:000041C8                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000041C8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000041C8 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000041C8                                         ; DATA XREF: .rdata$r:00004198o
.rdata$r:000041C8                                         ; .rdata$r:00004200o
.rdata$r:000041C9                 db    0
.rdata$r:000041CA                 db    0
.rdata$r:000041CB                 db    0
.rdata$r:000041CC                 db    0
.rdata$r:000041CD                 db    0
.rdata$r:000041CE                 db    0
.rdata$r:000041CF                 db    0
.rdata$r:000041D0                 db    3
.rdata$r:000041D1                 db    0
.rdata$r:000041D2                 db    0
.rdata$r:000041D3                 db    0
.rdata$r:000041D4                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000041D4 _rdata$r        ends
.rdata$r:000041D4
.rdata$r:000041D8 ; ===========================================================================
.rdata$r:000041D8
.rdata$r:000041D8 ; Segment type: Pure data
.rdata$r:000041D8 ; Segment permissions: Read
.rdata$r:000041D8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000041D8                 assume cs:_rdata$r
.rdata$r:000041D8                 ;org 41D8h
.rdata$r:000041D8 ; COMDAT (pick any)
.rdata$r:000041D8                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000041D8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000041D8 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000041D8                                         ; DATA XREF: .rdata$r:000041D4o
.rdata$r:000041D8                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000041DC                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000041E0                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000041E4                 db    0
.rdata$r:000041E5                 align 4
.rdata$r:000041E5 _rdata$r        ends
.rdata$r:000041E5
.rdata$r:000041E8 ; ===========================================================================
.rdata$r:000041E8
.rdata$r:000041E8 ; Segment type: Pure data
.rdata$r:000041E8 ; Segment permissions: Read
.rdata$r:000041E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000041E8                 assume cs:_rdata$r
.rdata$r:000041E8                 ;org 41E8h
.rdata$r:000041E8 ; COMDAT (pick any)
.rdata$r:000041E8                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000041E8 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000041E8 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000041E8                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000041E8                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000041EC                 db    2
.rdata$r:000041ED                 db    0
.rdata$r:000041EE                 db    0
.rdata$r:000041EF                 db    0
.rdata$r:000041F0                 db    0
.rdata$r:000041F1                 db    0
.rdata$r:000041F2                 db    0
.rdata$r:000041F3                 db    0
.rdata$r:000041F4                 db 0FFh
.rdata$r:000041F5                 db 0FFh
.rdata$r:000041F6                 db 0FFh
.rdata$r:000041F7                 db 0FFh
.rdata$r:000041F8                 db    0
.rdata$r:000041F9                 db    0
.rdata$r:000041FA                 db    0
.rdata$r:000041FB                 db    0
.rdata$r:000041FC                 db  40h ; @
.rdata$r:000041FD                 db    0
.rdata$r:000041FE                 db    0
.rdata$r:000041FF                 db    0
.rdata$r:00004200                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004200 _rdata$r        ends
.rdata$r:00004200
.rdata$r:00004204 ; ===========================================================================
.rdata$r:00004204
.rdata$r:00004204 ; Segment type: Pure data
.rdata$r:00004204 ; Segment permissions: Read
.rdata$r:00004204 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004204                 assume cs:_rdata$r
.rdata$r:00004204                 ;org 4204h
.rdata$r:00004204 ; COMDAT (pick any)
.rdata$r:00004204                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00004204 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00004204 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00003F00o
.rdata$r:00004205                 db    0
.rdata$r:00004206                 db    0
.rdata$r:00004207                 db    0
.rdata$r:00004208                 db    0
.rdata$r:00004209                 db    0
.rdata$r:0000420A                 db    0
.rdata$r:0000420B                 db    0
.rdata$r:0000420C                 db    0
.rdata$r:0000420D                 db    0
.rdata$r:0000420E                 db    0
.rdata$r:0000420F                 db    0
.rdata$r:00004210                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004214                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004214 _rdata$r        ends
.rdata$r:00004214
.data$r:00004218 ; ===========================================================================
.data$r:00004218
.data$r:00004218 ; Segment type: Pure data
.data$r:00004218 ; Segment permissions: Read/Write
.data$r:00004218 _data$r         segment dword public 'DATA' use32
.data$r:00004218                 assume cs:_data$r
.data$r:00004218                 ;org 4218h
.data$r:00004218 ; COMDAT (pick any)
.data$r:00004218                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00004218 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00004218 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00004218                                         ; DATA XREF: .rdata$r:00004210o
.data$r:00004218                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00004218                                         ; const type_info::`vftable'
.data$r:0000421C                 align 10h
.data$r:00004220 a_?av_system_er db '.?AV_System_error_category@std@@',0
.data$r:00004241                 align 4
.data$r:00004241 _data$r         ends
.data$r:00004241
.rdata$r:00004244 ; ===========================================================================
.rdata$r:00004244
.rdata$r:00004244 ; Segment type: Pure data
.rdata$r:00004244 ; Segment permissions: Read
.rdata$r:00004244 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004244                 assume cs:_rdata$r
.rdata$r:00004244                 ;org 4244h
.rdata$r:00004244 ; COMDAT (pick any)
.rdata$r:00004244                 public ??_R3_System_error_category@std@@8
.rdata$r:00004244 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00004244 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00004214o
.rdata$r:00004244                                         ; .rdata$r:0000427Co
.rdata$r:00004245                 db    0
.rdata$r:00004246                 db    0
.rdata$r:00004247                 db    0
.rdata$r:00004248                 db    0
.rdata$r:00004249                 db    0
.rdata$r:0000424A                 db    0
.rdata$r:0000424B                 db    0
.rdata$r:0000424C                 db    3
.rdata$r:0000424D                 db    0
.rdata$r:0000424E                 db    0
.rdata$r:0000424F                 db    0
.rdata$r:00004250                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004250 _rdata$r        ends
.rdata$r:00004250
.rdata$r:00004254 ; ===========================================================================
.rdata$r:00004254
.rdata$r:00004254 ; Segment type: Pure data
.rdata$r:00004254 ; Segment permissions: Read
.rdata$r:00004254 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004254                 assume cs:_rdata$r
.rdata$r:00004254                 ;org 4254h
.rdata$r:00004254 ; COMDAT (pick any)
.rdata$r:00004254                 public ??_R2_System_error_category@std@@8
.rdata$r:00004254 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00004254 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004254                                         ; DATA XREF: .rdata$r:00004250o
.rdata$r:00004254                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004258                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000425C                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00004260                 db    0
.rdata$r:00004261                 align 4
.rdata$r:00004261 _rdata$r        ends
.rdata$r:00004261
.rdata$r:00004264 ; ===========================================================================
.rdata$r:00004264
.rdata$r:00004264 ; Segment type: Pure data
.rdata$r:00004264 ; Segment permissions: Read
.rdata$r:00004264 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00004264                 assume cs:_rdata$r
.rdata$r:00004264                 ;org 4264h
.rdata$r:00004264 ; COMDAT (pick any)
.rdata$r:00004264                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00004264 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00004264 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00004264                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00004264                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00004268                 db    2
.rdata$r:00004269                 db    0
.rdata$r:0000426A                 db    0
.rdata$r:0000426B                 db    0
.rdata$r:0000426C                 db    0
.rdata$r:0000426D                 db    0
.rdata$r:0000426E                 db    0
.rdata$r:0000426F                 db    0
.rdata$r:00004270                 db 0FFh
.rdata$r:00004271                 db 0FFh
.rdata$r:00004272                 db 0FFh
.rdata$r:00004273                 db 0FFh
.rdata$r:00004274                 db    0
.rdata$r:00004275                 db    0
.rdata$r:00004276                 db    0
.rdata$r:00004277                 db    0
.rdata$r:00004278                 db  40h ; @
.rdata$r:00004279                 db    0
.rdata$r:0000427A                 db    0
.rdata$r:0000427B                 db    0
.rdata$r:0000427C                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000427C _rdata$r        ends
.rdata$r:0000427C
.CRT$XCU:00004280 ; ===========================================================================
.CRT$XCU:00004280
.CRT$XCU:00004280 ; Segment type: Pure data
.CRT$XCU:00004280 ; Segment permissions: Read
.CRT$XCU:00004280 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004280                 assume cs:_CRT$XCU
.CRT$XCU:00004280                 ;org 4280h
.CRT$XCU:00004280 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00004284 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00004284 _CRT$XCU        ends
.CRT$XCU:00004284
.CRT$XCU:00004288 ; ===========================================================================
.CRT$XCU:00004288
.CRT$XCU:00004288 ; Segment type: Pure data
.CRT$XCU:00004288 ; Segment permissions: Read
.CRT$XCU:00004288 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004288                 assume cs:_CRT$XCU
.CRT$XCU:00004288                 ;org 4288h
.CRT$XCU:00004288 ; COMDAT (pick associative to section at 3F24)
.CRT$XCU:00004288 ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:00004288 ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:00004288 _CRT$XCU        ends
.CRT$XCU:00004288
.CRT$XCU:0000428C ; ===========================================================================
.CRT$XCU:0000428C
.CRT$XCU:0000428C ; Segment type: Pure data
.CRT$XCU:0000428C ; Segment permissions: Read
.CRT$XCU:0000428C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000428C                 assume cs:_CRT$XCU
.CRT$XCU:0000428C                 ;org 428Ch
.CRT$XCU:0000428C ; COMDAT (pick associative to section at 3F28)
.CRT$XCU:0000428C ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:0000428C ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:0000428C _CRT$XCU        ends
.CRT$XCU:0000428C
.CRT$XCU:00004290 ; ===========================================================================
.CRT$XCU:00004290
.CRT$XCU:00004290 ; Segment type: Pure data
.CRT$XCU:00004290 ; Segment permissions: Read
.CRT$XCU:00004290 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004290                 assume cs:_CRT$XCU
.CRT$XCU:00004290                 ;org 4290h
.CRT$XCU:00004290 ; COMDAT (pick associative to section at 3F2C)
.CRT$XCU:00004290 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00004290 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00004290 _CRT$XCU        ends
.CRT$XCU:00004290
.CRT$XCU:00004294 ; ===========================================================================
.CRT$XCU:00004294
.CRT$XCU:00004294 ; Segment type: Pure data
.CRT$XCU:00004294 ; Segment permissions: Read
.CRT$XCU:00004294 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004294                 assume cs:_CRT$XCU
.CRT$XCU:00004294                 ;org 4294h
.CRT$XCU:00004294 ; COMDAT (pick associative to section at 3F30)
.CRT$XCU:00004294 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00004294 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00004294 _CRT$XCU        ends
.CRT$XCU:00004294
.CRT$XCU:00004298 ; ===========================================================================
.CRT$XCU:00004298
.CRT$XCU:00004298 ; Segment type: Pure data
.CRT$XCU:00004298 ; Segment permissions: Read
.CRT$XCU:00004298 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00004298                 assume cs:_CRT$XCU
.CRT$XCU:00004298                 ;org 4298h
.CRT$XCU:00004298 ; COMDAT (pick associative to section at 3F34)
.CRT$XCU:00004298 ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:00004298 ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:00004298 _CRT$XCU        ends
.CRT$XCU:00004298
.CRT$XCU:0000429C ; ===========================================================================
.CRT$XCU:0000429C
.CRT$XCU:0000429C ; Segment type: Pure data
.CRT$XCU:0000429C ; Segment permissions: Read
.CRT$XCU:0000429C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000429C                 assume cs:_CRT$XCU
.CRT$XCU:0000429C                 ;org 429Ch
.CRT$XCU:0000429C ; COMDAT (pick associative to section at 3FC8)
.CRT$XCU:0000429C ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:0000429C ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:0000429C _CRT$XCU        ends
.CRT$XCU:0000429C
.CRT$XCU:000042A0 ; ===========================================================================
.CRT$XCU:000042A0
.CRT$XCU:000042A0 ; Segment type: Pure data
.CRT$XCU:000042A0 ; Segment permissions: Read
.CRT$XCU:000042A0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000042A0                 assume cs:_CRT$XCU
.CRT$XCU:000042A0                 ;org 42A0h
.CRT$XCU:000042A0 ; COMDAT (pick associative to section at 3FCC)
.CRT$XCU:000042A0 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000042A0 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000042A0 _CRT$XCU        ends
.CRT$XCU:000042A0
UNDEF:000042B0 ; ===========================================================================
UNDEF:000042B0
UNDEF:000042B0 ; Segment type: Externs
UNDEF:000042B0 ; UNDEF
UNDEF:000042B0                 extrn __purecall:near   ; DATA XREF: .rdata:00003E78o
UNDEF:000042B0                                         ; .rdata:00003E7Co
UNDEF:000042B4 ; void *__cdecl operator new(unsigned int)
UNDEF:000042B4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000042B4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p ...
UNDEF:000042B8 ; void __cdecl operator delete(void *)
UNDEF:000042B8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000042B8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000042BC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000042BC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000042BC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000042C0                 extrn ___report_rangecheckfailure:near
UNDEF:000042C0                                         ; CODE XREF: ListView::getAscii(uchar):loc_BC9p
UNDEF:000042C4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000042C4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000042C4                                         ; _wmemcpy+11p
UNDEF:000042C8 ; size_t __cdecl strlen(const char *Str)
UNDEF:000042C8                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000042CC ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000042CC                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000042CC                                         ; _wmemmove+11p
UNDEF:000042D0 ; size_t __cdecl wcslen(const wchar_t *Str)
UNDEF:000042D0                 extrn _wcslen:near      ; CODE XREF: std::char_traits<wchar_t>::length(wchar_t const *)+1Bp
UNDEF:000042D4 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000042D4                 extrn __imp__SendMessageW@16:near
UNDEF:000042D4                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+FCp
UNDEF:000042D4                                         ; ListView::init(HINSTANCE__ *,HWND__ *)+123p ...
UNDEF:000042D8 ; LRESULT __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000042D8                 extrn __imp__CallWindowProcW@20:near
UNDEF:000042D8                                         ; CODE XREF: ListView::runProc(HWND__ *,uint,uint,long)+1Ep
UNDEF:000042D8                                         ; DATA XREF: ListView::runProc(HWND__ *,uint,uint,long)+1Er
UNDEF:000042DC ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:000042DC                 extrn __imp__CreateWindowExW@48:near
UNDEF:000042DC                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+89p
UNDEF:000042DC                                         ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+89r
UNDEF:000042E0 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:000042E0                 extrn __imp__DestroyWindow@4:near
UNDEF:000042E0                                         ; CODE XREF: ListView::destroy(void)+Ep
UNDEF:000042E0                                         ; DATA XREF: ListView::destroy(void)+Er
UNDEF:000042E4 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:000042E4                 extrn __imp__GetWindowLongW@8:near
UNDEF:000042E4                                         ; CODE XREF: ListView::staticProc(HWND__ *,uint,uint,long)+19p
UNDEF:000042E4                                         ; DATA XREF: ListView::staticProc(HWND__ *,uint,uint,long)+19r
UNDEF:000042E8 ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:000042E8                 extrn __imp__SetWindowLongW@12:near
UNDEF:000042E8                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+CCp
UNDEF:000042E8                                         ; ListView::init(HINSTANCE__ *,HWND__ *)+E0p
UNDEF:000042E8                                         ; DATA XREF: ...
UNDEF:000042EC ; int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCSTR lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar)
UNDEF:000042EC                 extrn __imp__MultiByteToWideChar@24:near
UNDEF:000042EC                                         ; CODE XREF: ListView::getAscii(uchar)+57Bp
UNDEF:000042EC                                         ; DATA XREF: ListView::getAscii(uchar)+57Br
UNDEF:000042F0 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:000042F0                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:000042F0                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:000042F4 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:000042F4                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:000042F4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:000042F4                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:000042F8                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:000042FC ; int __cdecl _vswprintf(wchar_t *Dest, const wchar_t *Format, va_list Args)
UNDEF:000042FC                 extrn __vswprintf:near  ; CODE XREF: swprintf(wchar_t *,wchar_t const *,...)+18p
UNDEF:00004300 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00004300                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00004300                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00004304 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00004304                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00004304                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00004304                                         ; DATA XREF: .xdata$x:00003E6Co
UNDEF:00004308 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00004308                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00004308                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00004308                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:0000430C ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:0000430C                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:0000430C                                         ; DATA XREF: .rdata:00003DDCo
UNDEF:00004310 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00004310                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00004310                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00004310                                         ; std::_Debug_pointer<wchar_t>(wchar_t const *,wchar_t const *,uint)+16p
UNDEF:00004314 ; void __cdecl std::_Xbad_alloc()
UNDEF:00004314                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00004314                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_E4Ap
UNDEF:00004314                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_E8Cp ...
UNDEF:00004318 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00004318                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00004318                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00004318                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xlen(void)+Cp
UNDEF:0000431C ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:0000431C                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:0000431C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000431C                                         ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::_Xran(void)+Cp
UNDEF:00004320 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00004320                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00004320                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00004324 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004324                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004324                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00004328 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00004328                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00004328                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00004328                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:0000432C ; const char *__cdecl std::_Winerror_map(int)
UNDEF:0000432C                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:0000432C                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00004330 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004330                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004330                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:00004334 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004334                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004334                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00004338 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00004338                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00004338                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:0000433C ; BOOL __stdcall InitCommonControlsEx(const INITCOMMONCONTROLSEX *picce)
UNDEF:0000433C                 extrn __imp__InitCommonControlsEx@4:near
UNDEF:0000433C                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+50p
UNDEF:0000433C                                         ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+50r
UNDEF:00004340 ; public: class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>> __thiscall NativeLangSpeaker::getAttrNameStr(wchar_t const *, char const *, char const *)const
UNDEF:00004340                 extrn ?getAttrNameStr@NativeLangSpeaker@@QBE?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@PB_WPBD1@Z:near
UNDEF:00004340                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+158p
UNDEF:00004340                                         ; ListView::init(HINSTANCE__ *,HWND__ *)+17Ap ...
UNDEF:00004344 ; __fastcall __security_check_cookie(x)
UNDEF:00004344                 extrn @__security_check_cookie@4:near
UNDEF:00004344                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+272p
UNDEF:00004344                                         ; ListView::setValues(int)+15Cp ...
UNDEF:00004348 ; __stdcall _CxxThrowException(x, x)
UNDEF:00004348                 extrn __CxxThrowException@8:near
UNDEF:00004348                                         ; CODE XREF: ListView::init(HINSTANCE__ *,HWND__ *)+BAp
UNDEF:00004348                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p ...
UNDEF:0000434C                 extrn ___CxxFrameHandler3:near
UNDEF:0000434C                                         ; CODE XREF: __ehhandler$?init@ListView@@UAEXPAUHINSTANCE__@@PAUHWND__@@@Z+23j
UNDEF:0000434C                                         ; __ehhandler$?setValues@ListView@@QAEXH@Z+23j ...
UNDEF:00004350 ; const type_info::`vftable'
UNDEF:00004350                 extrn ??_7type_info@@6B@:near
UNDEF:00004350                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:00004350                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:00004354 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00004354                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00004354                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00004358                 extrn ___security_cookie:near
UNDEF:00004358                                         ; DATA XREF: ListView::init(HINSTANCE__ *,HWND__ *)+17r
UNDEF:00004358                                         ; ListView::setValues(int)+17r ...
UNDEF:0000435C                 extrn __fltused:near
UNDEF:0000435C
UNDEF:0000435C
UNDEF:0000435C                 end