.data:00000000 ;
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.data:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.data:00000000 ; |                      License info: 48-3677-7074-51                      |
.data:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.data:00000000 ; +-------------------------------------------------------------------------+
.data:00000000 ;
.data:00000000 ; Input MD5   : BF091C9A547AD1E7673DAF6E4AF3164F
.data:00000000 ; Input CRC32 : 7AAF4572
.data:00000000
.data:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\DocTabView.obj
.data:00000000 ; Format      : COFF (X386MAGIC)
.data:00000000 ; includelib "uuid.lib"
.data:00000000 ; includelib "libcpmtd"
.data:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.data:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.data:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.data:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.data:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.data:00000000 ; includelib "LIBCMTD"
.data:00000000 ; includelib "OLDNAMES"
.data:00000000
.data:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.data:00000000
.data:00000000                 .686p
.data:00000000                 .mmx
.data:00000000                 .model flat
.data:00000000
.data:00000000 ; ===========================================================================
.data:00000000
.data:00000000 ; Segment type: Pure data
.data:00000000 ; Segment permissions: Read/Write
.data:00000000 ; Segment alignment 'qword' can not be represented in assembly
.data:00000000 _data           segment para public 'DATA' use32
.data:00000000                 assume cs:_data
.data:00000000 _acTop_xpm      dd offset $SG143478     ; "12 12 56 1"
.data:00000004                 dd offset $SG143479     ; " \tc #FFFFFF"
.data:00000008                 dd offset $SG143480     ; ".\tc #8AB2E9"
.data:0000000C                 dd offset $SG143481     ; "+\tc #CCDCF6"
.data:00000010                 dd offset $SG143482     ; "@\tc #80ABEA"
.data:00000014                 dd offset $SG143483     ; "#\tc #7DA9E8"
.data:00000018                 dd offset $SG143484     ; "$\tc #C7DAF3"
.data:0000001C                 dd offset $SG143485     ; "%\tc #79A7E6"
.data:00000020                 dd offset $SG143486     ; "&\tc #ADC8EF"
.data:00000024                 dd offset $SG143487     ; "*\tc #87B0E8"
.data:00000028                 dd offset $SG143488     ; "=\tc #BBD2F0"
.data:0000002C                 dd offset $SG143489     ; "-\tc #6EA0E2"
.data:00000030                 dd offset $SG143490     ; ";\tc #A8C7EE"
.data:00000034                 dd offset $SG143491     ; ">\tc #A3C2ED"
.data:00000038                 dd offset $SG143492     ; ",\tc #75A4E3"
.data:0000003C                 dd offset $SG143493     ; "'\tc #A7C4EB"
.data:00000040                 dd offset $SG143494     ; ")\tc #6297E1"
.data:00000044                 dd offset $SG143495     ; "!\tc #A1C1EC"
.data:00000048                 dd offset $SG143496     ; "~\tc #92B7E8"
.data:0000004C                 dd offset $SG143497     ; "{\tc #99BBE9"
.data:00000050                 dd offset $SG143498     ; "]\tc #6197DD"
.data:00000054                 dd offset $SG143499     ; "^\tc #96B9E6"
.data:00000058                 dd offset $SG143500     ; "/\tc #538EDB"
.data:0000005C                 dd offset $SG143501     ; "(\tc #99BBEA"
.data:00000060                 dd offset $SG143502     ; "_\tc #80AAE3"
.data:00000064                 dd offset $SG143503     ; ":\tc #81ABE3"
.data:00000068                 dd offset $SG143504     ; "<\tc #8AB1E4"
.data:0000006C                 dd offset $SG143505     ; "[\tc #4B88D6"
.data:00000070                 dd offset $SG143506     ; "}\tc #4882D1"
.data:00000074                 dd offset $SG143507     ; "|\tc #4384D6"
.data:00000078                 dd offset $SG143508     ; "1\tc #90B5E7"
.data:0000007C                 dd offset $SG143509     ; "2\tc #74A3E0"
.data:00000080                 dd offset $SG143510     ; "3\tc #77A4E0"
.data:00000084                 dd offset $SG143511     ; "4\tc #81ABE2"
.data:00000088                 dd offset $SG143512     ; "5\tc #437FD3"
.data:0000008C                 dd offset $SG143513     ; "6\tc #7FA2DF"
.data:00000090                 dd offset $SG143514     ; "7\tc #3577D2"
.data:00000094                 dd offset $SG143515     ; "8\tc #87AFE4"
.data:00000098                 dd offset $SG143516     ; "9\tc #72A1DF"
.data:0000009C                 dd offset $SG143517     ; "0\tc #7CA9E1"
.data:000000A0                 dd offset $SG143518     ; "a\tc #3F7AD0"
.data:000000A4                 dd offset $SG143519     ; "b\tc #85A4DE"
.data:000000A8                 dd offset $SG143520     ; "c\tc #FBFCFE"
.data:000000AC                 dd offset $SG143521     ; "d\tc #236ECD"
.data:000000B0                 dd offset $SG143522     ; "e\tc #7EA8E1"
.data:000000B4                 dd offset $SG143523     ; "f\tc #79A6E0"
.data:000000B8                 dd offset $SG143524     ; "g\tc #3D77D0"
.data:000000BC                 dd offset $SG143525     ; "h\tc #87A4DC"
.data:000000C0                 dd offset $SG143526     ; "i\tc #1A62C9"
.data:000000C4                 dd offset $SG143527     ; "j\tc #75A3DF"
.data:000000C8                 dd offset $SG143528     ; "k\tc #3C74CF"
.data:000000CC                 dd offset $SG143529     ; "l\tc #8DA6DE"
.data:000000D0                 dd offset $SG143530     ; "m\tc #1859C4"
.data:000000D4                 dd offset $SG143531     ; "n\tc #3B71CC"
.data:000000D8                 dd offset $SG143532     ; "o\tc #8EA5DD"
.data:000000DC                 dd offset $SG143533     ; "p\tc #164EC0"
.data:000000E0                 dd offset $SG143534     ; "q\tc #92A7DD"
.data:000000E4                 dd offset $SG143535     ; "    .+      "
.data:000000E8                 dd offset $SG143536     ; "    @#$     "
.data:000000EC                 dd offset $SG143537     ; "    %&*=    "
.data:000000F0                 dd offset $SG143538     ; "    -;>,'   "
.data:000000F4                 dd offset $SG143539     ; "    )!~{]^  "
.data:000000F8                 dd offset $SG143540     ; "    /(_:<[} "
.data:000000FC                 dd offset $SG143541     ; "    |123456 "
.data:00000100                 dd offset $SG143542     ; "    7890abc "
.data:00000104                 dd offset $SG143543     ; "    defgh   "
.data:00000108                 dd offset $SG143544     ; "    ijkl    "
.data:0000010C                 dd offset $SG143545     ; "    mno     "
.data:00000110                 dd offset $SG143546     ; "    pq      "
.data:00000114                 align 8
.data:00000118 _acBottom_xpm   dd offset $SG143548     ; "12 12 54 1"
.data:0000011C                 dd offset $SG143549     ; " \tc #FFFFFF"
.data:00000120                 dd offset $SG143550     ; ".\tc #C4D7F3"
.data:00000124                 dd offset $SG143551     ; "+\tc #72A1E3"
.data:00000128                 dd offset $SG143552     ; "@\tc #C1D6F2"
.data:0000012C                 dd offset $SG143553     ; "#\tc #6397E1"
.data:00000130                 dd offset $SG143554     ; "$\tc #5990DD"
.data:00000134                 dd offset $SG143555     ; "%\tc #BBD2F0"
.data:00000138                 dd offset $SG143556     ; "&\tc #7AA6E5"
.data:0000013C                 dd offset $SG143557     ; "*\tc #9ABDEA"
.data:00000140                 dd offset $SG143558     ; "=\tc #4A87D9"
.data:00000144                 dd offset $SG143559     ; "-\tc #B1CAEE"
.data:00000148                 dd offset $SG143560     ; ";\tc #75A4E3"
.data:0000014C                 dd offset $SG143561     ; ">\tc #99BBE9"
.data:00000150                 dd offset $SG143562     ; ",\tc #95B9E8"
.data:00000154                 dd offset $SG143563     ; "'\tc #3A7CD4"
.data:00000158                 dd offset $SG143564     ; ")\tc #A9C6EC"
.data:0000015C                 dd offset $SG143565     ; "!\tc #71A0E0"
.data:00000160                 dd offset $SG143566     ; "~\tc #86AFE5"
.data:00000164                 dd offset $SG143567     ; "{\tc #8DB2E6"
.data:00000168                 dd offset $SG143568     ; "]\tc #2A72CF"
.data:0000016C                 dd offset $SG143569     ; "^\tc #73A0E0"
.data:00000170                 dd offset $SG143570     ; "/\tc #6B9DE0"
.data:00000174                 dd offset $SG143571     ; "(\tc #95B8E8"
.data:00000178                 dd offset $SG143572     ; "_\tc #81ABE3"
.data:0000017C                 dd offset $SG143573     ; ":\tc #72A1DF"
.data:00000180                 dd offset $SG143574     ; "<\tc #83ADE3"
.data:00000184                 dd offset $SG143575     ; "[\tc #1B65C9"
.data:00000188                 dd offset $SG143576     ; "}\tc #5F95DC"
.data:0000018C                 dd offset $SG143577     ; "|\tc #8BB3E5"
.data:00000190                 dd offset $SG143578     ; "1\tc #77A4E0"
.data:00000194                 dd offset $SG143579     ; "2\tc #679ADC"
.data:00000198                 dd offset $SG143580     ; "3\tc #7AA6E1"
.data:0000019C                 dd offset $SG143581     ; "4\tc #195CC6"
.data:000001A0                 dd offset $SG143582     ; "5\tc #FCFDFE"
.data:000001A4                 dd offset $SG143583     ; "6\tc #8DB2E4"
.data:000001A8                 dd offset $SG143584     ; "7\tc #4885D6"
.data:000001AC                 dd offset $SG143585     ; "8\tc #7CA9E1"
.data:000001B0                 dd offset $SG143586     ; "9\tc #6698DB"
.data:000001B4                 dd offset $SG143587     ; "0\tc #71A1DE"
.data:000001B8                 dd offset $SG143588     ; "a\tc #1752C0"
.data:000001BC                 dd offset $SG143589     ; "b\tc #88ABE0"
.data:000001C0                 dd offset $SG143590     ; "c\tc #3D77D0"
.data:000001C4                 dd offset $SG143591     ; "d\tc #6E9FDD"
.data:000001C8                 dd offset $SG143592     ; "e\tc #699BDC"
.data:000001CC                 dd offset $SG143593     ; "f\tc #1547BD"
.data:000001D0                 dd offset $SG143594     ; "g\tc #8DA6DE"
.data:000001D4                 dd offset $SG143595     ; "h\tc #376BC9"
.data:000001D8                 dd offset $SG143596     ; "i\tc #6295DA"
.data:000001DC                 dd offset $SG143597     ; "j\tc #1440B9"
.data:000001E0                 dd offset $SG143598     ; "k\tc #8DA0DB"
.data:000001E4                 dd offset $SG143599     ; "l\tc #315FC4"
.data:000001E8                 dd offset $SG143600     ; "m\tc #1339B7"
.data:000001EC                 dd offset $SG143601     ; "n\tc #909FDA"
.data:000001F0                 dd offset $SG143602     ; "o\tc #1233B4"
.data:000001F4                 dd offset $SG143603     ; "         .+ "
.data:000001F8                 dd offset $SG143604     ; "        @#$ "
.data:000001FC                 dd offset $SG143605     ; "       %&*= L"
.data:00000200                 dd offset $SG143606     ; "      -;>,' "
.data:00000204                 dd offset $SG143607     ; "     )!>~{] "
.data:00000208                 dd offset $SG143608     ; "    ^/(_:<[ "
.data:0000020C                 dd offset $SG143609     ; "    (}|1234 "
.data:00000210                 dd offset $SG143610     ; "    567890a "
.data:00000214                 dd offset $SG143611     ; "      bcdef "
.data:00000218                 dd offset $SG143612     ; "       ghij "
.data:0000021C                 dd offset $SG143613     ; "        klm "
.data:00000220                 dd offset $SG143614     ; "         no "
.data:00000224                 align 8
.data:00000228 _bookmark_xpm   dd offset $SG143616     ; "13 14 54 1"
.data:0000022C                 dd offset $SG143617     ; " \tc None"
.data:00000230                 dd offset $SG143618     ; ".\tc #545254"
.data:00000234                 dd offset $SG143619     ; "+\tc #3C3E3C"
.data:00000238                 dd offset $SG143620     ; "@\tc #646464"
.data:0000023C                 dd offset $SG143621     ; "#\tc #A4A4A4"
.data:00000240                 dd offset $SG143622     ; "$\tc #B7B8B7"
.data:00000244                 dd offset $SG143623     ; "%\tc #747284"
.data:00000248                 dd offset $SG143624     ; "&\tc #B4B2C4"
.data:0000024C                 dd offset $SG143625     ; "*\tc #DCD7E4"
.data:00000250                 dd offset $SG143626     ; "=\tc #1C1A1C"
.data:00000254                 dd offset $SG143627     ; "-\tc #403E58"
.data:00000258                 dd offset $SG143628     ; ";\tc #5C5A8C"
.data:0000025C                 dd offset $SG143629     ; ">\tc #7C7EAC"
.data:00000260                 dd offset $SG143630     ; ",\tc #7C8EBC"
.data:00000264                 dd offset $SG143631     ; "'\tc #242644"
.data:00000268                 dd offset $SG143632     ; ")\tc #282668"
.data:0000026C                 dd offset $SG143633     ; "!\tc #24367C"
.data:00000270                 dd offset $SG143634     ; "~\tc #244A84"
.data:00000274                 dd offset $SG143635     ; "{\tc #2C5098"
.data:00000278                 dd offset $SG143636     ; "]\tc #14162C"
.data:0000027C                 dd offset $SG143637     ; "^\tc #142E7C"
.data:00000280                 dd offset $SG143638     ; "/\tc #143789"
.data:00000284                 dd offset $SG143639     ; "(\tc #204990"
.data:00000288                 dd offset $SG143640     ; "_\tc #174091"
.data:0000028C                 dd offset $SG143641     ; ":\tc #0C0630"
.data:00000290                 dd offset $SG143642     ; "<\tc #24327C"
.data:00000294                 dd offset $SG143643     ; "[\tc #2450A0"
.data:00000298                 dd offset $SG143644     ; "}\tc #345DB4"
.data:0000029C                 dd offset $SG143645     ; "|\tc #3C68B8"
.data:000002A0                 dd offset $SG143646     ; "1\tc #141244"
.data:000002A4                 dd offset $SG143647     ; "2\tc #24428C"
.data:000002A8                 dd offset $SG143648     ; "3\tc #3462B9"
.data:000002AC                 dd offset $SG143649     ; "4\tc #4470C4"
.data:000002B0                 dd offset $SG143650     ; "5\tc #4C7FD6"
.data:000002B4                 dd offset $SG143651     ; "6\tc #4472CC"
.data:000002B8                 dd offset $SG143652     ; "7\tc #24224C"
.data:000002BC                 dd offset $SG143653     ; "8\tc #5C8DEC"
.data:000002C0                 dd offset $SG143654     ; "9\tc #5C94F6"
.data:000002C4                 dd offset $SG143655     ; "0\tc #5482DF"
.data:000002C8                 dd offset $SG143656     ; "a\tc #619DF7"
.data:000002CC                 dd offset $SG143657     ; "b\tc #6CA6FC"
.data:000002D0                 dd offset $SG143658     ; "c\tc #64A2FC"
.data:000002D4                 dd offset $SG143659     ; "d\tc #1C2E5C"
.data:000002D8                 dd offset $SG143660     ; "e\tc #6CA2FC"
.data:000002DC                 dd offset $SG143661     ; "f\tc #74B2FC"
.data:000002E0                 dd offset $SG143662     ; "g\tc #7CB8FC"
.data:000002E4                 dd offset $SG143663     ; "h\tc #1C3264"
.data:000002E8                 dd offset $SG143664     ; "i\tc #346AD4"
.data:000002EC                 dd offset $SG143665     ; "j\tc #7CBEFC"
.data:000002F0                 dd offset $SG143666     ; "k\tc #3C72DC"
.data:000002F4                 dd offset $SG143667     ; "l\tc #243250"
.data:000002F8                 dd offset $SG143668     ; "m\tc #346AB4"
.data:000002FC                 dd offset $SG143669     ; "n\tc #3C82DC"
.data:00000300                 dd offset $SG143670     ; "o\tc #6C6A6C"
.data:00000304                 dd offset $SG143671     ; "     .+.     "
.data:00000308                 dd offset $SG143672     ; "   @##$##@   "
.data:0000030C                 dd offset $SG143673     ; "  @%&***&%@  "
.data:00000310                 dd offset $SG143674     ; " =-;>,,,>;-= "
.data:00000314                 dd offset $SG143675     ; " ')!~{{{~!)' "
.data:00000318                 dd offset $SG143676     ; "])^/({{{(_^)]"
.data:0000031C                 dd offset $SG143677     ; ":<_[}|||}[_<:"
.data:00000320                 dd offset $SG143678     ; "12[3455563[21"
.data:00000324                 dd offset $SG143679     ; "7_365899063_7"
.data:00000328                 dd offset $SG143680     ; " /|09abc904/ "
.data:0000032C                 dd offset $SG143681     ; " d}8efgfb83d "
.data:00000330                 dd offset $SG143682     ; "  hiafjgakh  "
.data:00000334                 dd offset $SG143683     ; "   l~mnm~l   "
.data:00000338                 dd offset $SG143684     ; "     o@o     "
.data:00000338 _data           ends
.data:00000338
.rdata:0000033C ; ===========================================================================
.rdata:0000033C
.rdata:0000033C ; Segment type: Pure data
.rdata:0000033C ; Segment permissions: Read
.rdata:0000033C _rdata          segment dword public 'DATA' use32
.rdata:0000033C                 assume cs:_rdata
.rdata:0000033C                 ;org 33Ch
.rdata:0000033C $SG143478       db '12 12 56 1',0       ; DATA XREF: .data:_acTop_xpmo
.rdata:00000347                 align 4
.rdata:00000348 $SG143479       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:00000004o
.rdata:00000354 $SG143480       db '.',9,'c #8AB2E9',0  ; DATA XREF: .data:00000008o
.rdata:00000360 $SG143481       db '+',9,'c #CCDCF6',0  ; DATA XREF: .data:0000000Co
.rdata:0000036C $SG143482       db '@',9,'c #80ABEA',0  ; DATA XREF: .data:00000010o
.rdata:00000378 $SG143483       db '#',9,'c #7DA9E8',0  ; DATA XREF: .data:00000014o
.rdata:00000384 $SG143484       db '$',9,'c #C7DAF3',0  ; DATA XREF: .data:00000018o
.rdata:00000390 $SG143485       db '%',9,'c #79A7E6',0  ; DATA XREF: .data:0000001Co
.rdata:0000039C $SG143486       db '&',9,'c #ADC8EF',0  ; DATA XREF: .data:00000020o
.rdata:000003A8 $SG143487       db '*',9,'c #87B0E8',0  ; DATA XREF: .data:00000024o
.rdata:000003B4 $SG143488       db '=',9,'c #BBD2F0',0  ; DATA XREF: .data:00000028o
.rdata:000003C0 $SG143489       db '-',9,'c #6EA0E2',0  ; DATA XREF: .data:0000002Co
.rdata:000003CC $SG143490       db ';',9,'c #A8C7EE',0  ; DATA XREF: .data:00000030o
.rdata:000003D8 $SG143491       db '>',9,'c #A3C2ED',0  ; DATA XREF: .data:00000034o
.rdata:000003E4 $SG143492       db ',',9,'c #75A4E3',0  ; DATA XREF: .data:00000038o
.rdata:000003F0 $SG143493       db 27h,9,'c #A7C4EB',0  ; DATA XREF: .data:0000003Co
.rdata:000003FC $SG143494       db ')',9,'c #6297E1',0  ; DATA XREF: .data:00000040o
.rdata:00000408 $SG143495       db '!',9,'c #A1C1EC',0  ; DATA XREF: .data:00000044o
.rdata:00000414 $SG143496       db '~',9,'c #92B7E8',0  ; DATA XREF: .data:00000048o
.rdata:00000420 $SG143497       db '{',9,'c #99BBE9',0  ; DATA XREF: .data:0000004Co
.rdata:0000042C $SG143498       db ']',9,'c #6197DD',0  ; DATA XREF: .data:00000050o
.rdata:00000438 $SG143499       db '^',9,'c #96B9E6',0  ; DATA XREF: .data:00000054o
.rdata:00000444 $SG143500       db '/',9,'c #538EDB',0  ; DATA XREF: .data:00000058o
.rdata:00000450 $SG143501       db '(',9,'c #99BBEA',0  ; DATA XREF: .data:0000005Co
.rdata:0000045C $SG143502       db '_',9,'c #80AAE3',0  ; DATA XREF: .data:00000060o
.rdata:00000468 $SG143503       db ':',9,'c #81ABE3',0  ; DATA XREF: .data:00000064o
.rdata:00000474 $SG143504       db '<',9,'c #8AB1E4',0  ; DATA XREF: .data:00000068o
.rdata:00000480 $SG143505       db '[',9,'c #4B88D6',0  ; DATA XREF: .data:0000006Co
.rdata:0000048C $SG143506       db '}',9,'c #4882D1',0  ; DATA XREF: .data:00000070o
.rdata:00000498 $SG143507       db '|',9,'c #4384D6',0  ; DATA XREF: .data:00000074o
.rdata:000004A4 $SG143508       db '1',9,'c #90B5E7',0  ; DATA XREF: .data:00000078o
.rdata:000004B0 $SG143509       db '2',9,'c #74A3E0',0  ; DATA XREF: .data:0000007Co
.rdata:000004BC $SG143510       db '3',9,'c #77A4E0',0  ; DATA XREF: .data:00000080o
.rdata:000004C8 $SG143511       db '4',9,'c #81ABE2',0  ; DATA XREF: .data:00000084o
.rdata:000004D4 $SG143512       db '5',9,'c #437FD3',0  ; DATA XREF: .data:00000088o
.rdata:000004E0 $SG143513       db '6',9,'c #7FA2DF',0  ; DATA XREF: .data:0000008Co
.rdata:000004EC $SG143514       db '7',9,'c #3577D2',0  ; DATA XREF: .data:00000090o
.rdata:000004F8 $SG143515       db '8',9,'c #87AFE4',0  ; DATA XREF: .data:00000094o
.rdata:00000504 $SG143516       db '9',9,'c #72A1DF',0  ; DATA XREF: .data:00000098o
.rdata:00000510 $SG143517       db '0',9,'c #7CA9E1',0  ; DATA XREF: .data:0000009Co
.rdata:0000051C $SG143518       db 'a',9,'c #3F7AD0',0  ; DATA XREF: .data:000000A0o
.rdata:00000528 $SG143519       db 'b',9,'c #85A4DE',0  ; DATA XREF: .data:000000A4o
.rdata:00000534 $SG143520       db 'c',9,'c #FBFCFE',0  ; DATA XREF: .data:000000A8o
.rdata:00000540 $SG143521       db 'd',9,'c #236ECD',0  ; DATA XREF: .data:000000ACo
.rdata:0000054C $SG143522       db 'e',9,'c #7EA8E1',0  ; DATA XREF: .data:000000B0o
.rdata:00000558 $SG143523       db 'f',9,'c #79A6E0',0  ; DATA XREF: .data:000000B4o
.rdata:00000564 $SG143524       db 'g',9,'c #3D77D0',0  ; DATA XREF: .data:000000B8o
.rdata:00000570 $SG143525       db 'h',9,'c #87A4DC',0  ; DATA XREF: .data:000000BCo
.rdata:0000057C $SG143526       db 'i',9,'c #1A62C9',0  ; DATA XREF: .data:000000C0o
.rdata:00000588 $SG143527       db 'j',9,'c #75A3DF',0  ; DATA XREF: .data:000000C4o
.rdata:00000594 $SG143528       db 'k',9,'c #3C74CF',0  ; DATA XREF: .data:000000C8o
.rdata:000005A0 $SG143529       db 'l',9,'c #8DA6DE',0  ; DATA XREF: .data:000000CCo
.rdata:000005AC $SG143530       db 'm',9,'c #1859C4',0  ; DATA XREF: .data:000000D0o
.rdata:000005B8 $SG143531       db 'n',9,'c #3B71CC',0  ; DATA XREF: .data:000000D4o
.rdata:000005C4 $SG143532       db 'o',9,'c #8EA5DD',0  ; DATA XREF: .data:000000D8o
.rdata:000005D0 $SG143533       db 'p',9,'c #164EC0',0  ; DATA XREF: .data:000000DCo
.rdata:000005DC $SG143534       db 'q',9,'c #92A7DD',0  ; DATA XREF: .data:000000E0o
.rdata:000005E8 $SG143535       db '    .+      ',0     ; DATA XREF: .data:000000E4o
.rdata:000005F5                 align 4
.rdata:000005F8 $SG143536       db '    @#$     ',0     ; DATA XREF: .data:000000E8o
.rdata:00000605                 align 4
.rdata:00000608 $SG143537       db '    %&*=    ',0     ; DATA XREF: .data:000000ECo
.rdata:00000615                 align 4
.rdata:00000618 $SG143538       db '    -;>,',27h,'   ',0 ; DATA XREF: .data:000000F0o
.rdata:00000625                 align 4
.rdata:00000628 $SG143539       db '    )!~{]^  ',0     ; DATA XREF: .data:000000F4o
.rdata:00000635                 align 4
.rdata:00000638 $SG143540       db '    /(_:<[} ',0     ; DATA XREF: .data:000000F8o
.rdata:00000645                 align 4
.rdata:00000648 $SG143541       db '    |123456 ',0     ; DATA XREF: .data:000000FCo
.rdata:00000655                 align 4
.rdata:00000658 $SG143542       db '    7890abc ',0     ; DATA XREF: .data:00000100o
.rdata:00000665                 align 4
.rdata:00000668 $SG143543       db '    defgh   ',0     ; DATA XREF: .data:00000104o
.rdata:00000675                 align 4
.rdata:00000678 $SG143544       db '    ijkl    ',0     ; DATA XREF: .data:00000108o
.rdata:00000685                 align 4
.rdata:00000688 $SG143545       db '    mno     ',0     ; DATA XREF: .data:0000010Co
.rdata:00000695                 align 4
.rdata:00000698 $SG143546       db '    pq      ',0     ; DATA XREF: .data:00000110o
.rdata:000006A5                 align 4
.rdata:000006A8 $SG143548       db '12 12 54 1',0       ; DATA XREF: .data:_acBottom_xpmo
.rdata:000006B3                 align 4
.rdata:000006B4 $SG143549       db ' ',9,'c #FFFFFF',0  ; DATA XREF: .data:0000011Co
.rdata:000006C0 $SG143550       db '.',9,'c #C4D7F3',0  ; DATA XREF: .data:00000120o
.rdata:000006CC $SG143551       db '+',9,'c #72A1E3',0  ; DATA XREF: .data:00000124o
.rdata:000006D8 $SG143552       db '@',9,'c #C1D6F2',0  ; DATA XREF: .data:00000128o
.rdata:000006E4 $SG143553       db '#',9,'c #6397E1',0  ; DATA XREF: .data:0000012Co
.rdata:000006F0 $SG143554       db '$',9,'c #5990DD',0  ; DATA XREF: .data:00000130o
.rdata:000006FC $SG143555       db '%',9,'c #BBD2F0',0  ; DATA XREF: .data:00000134o
.rdata:00000708 $SG143556       db '&',9,'c #7AA6E5',0  ; DATA XREF: .data:00000138o
.rdata:00000714 $SG143557       db '*',9,'c #9ABDEA',0  ; DATA XREF: .data:0000013Co
.rdata:00000720 $SG143558       db '=',9,'c #4A87D9',0  ; DATA XREF: .data:00000140o
.rdata:0000072C $SG143559       db '-',9,'c #B1CAEE',0  ; DATA XREF: .data:00000144o
.rdata:00000738 $SG143560       db ';',9,'c #75A4E3',0  ; DATA XREF: .data:00000148o
.rdata:00000744 $SG143561       db '>',9,'c #99BBE9',0  ; DATA XREF: .data:0000014Co
.rdata:00000750 $SG143562       db ',',9,'c #95B9E8',0  ; DATA XREF: .data:00000150o
.rdata:0000075C $SG143563       db 27h,9,'c #3A7CD4',0  ; DATA XREF: .data:00000154o
.rdata:00000768 $SG143564       db ')',9,'c #A9C6EC',0  ; DATA XREF: .data:00000158o
.rdata:00000774 $SG143565       db '!',9,'c #71A0E0',0  ; DATA XREF: .data:0000015Co
.rdata:00000780 $SG143566       db '~',9,'c #86AFE5',0  ; DATA XREF: .data:00000160o
.rdata:0000078C $SG143567       db '{',9,'c #8DB2E6',0  ; DATA XREF: .data:00000164o
.rdata:00000798 $SG143568       db ']',9,'c #2A72CF',0  ; DATA XREF: .data:00000168o
.rdata:000007A4 $SG143569       db '^',9,'c #73A0E0',0  ; DATA XREF: .data:0000016Co
.rdata:000007B0 $SG143570       db '/',9,'c #6B9DE0',0  ; DATA XREF: .data:00000170o
.rdata:000007BC $SG143571       db '(',9,'c #95B8E8',0  ; DATA XREF: .data:00000174o
.rdata:000007C8 $SG143572       db '_',9,'c #81ABE3',0  ; DATA XREF: .data:00000178o
.rdata:000007D4 $SG143573       db ':',9,'c #72A1DF',0  ; DATA XREF: .data:0000017Co
.rdata:000007E0 $SG143574       db '<',9,'c #83ADE3',0  ; DATA XREF: .data:00000180o
.rdata:000007EC $SG143575       db '[',9,'c #1B65C9',0  ; DATA XREF: .data:00000184o
.rdata:000007F8 $SG143576       db '}',9,'c #5F95DC',0  ; DATA XREF: .data:00000188o
.rdata:00000804 $SG143577       db '|',9,'c #8BB3E5',0  ; DATA XREF: .data:0000018Co
.rdata:00000810 $SG143578       db '1',9,'c #77A4E0',0  ; DATA XREF: .data:00000190o
.rdata:0000081C $SG143579       db '2',9,'c #679ADC',0  ; DATA XREF: .data:00000194o
.rdata:00000828 $SG143580       db '3',9,'c #7AA6E1',0  ; DATA XREF: .data:00000198o
.rdata:00000834 $SG143581       db '4',9,'c #195CC6',0  ; DATA XREF: .data:0000019Co
.rdata:00000840 $SG143582       db '5',9,'c #FCFDFE',0  ; DATA XREF: .data:000001A0o
.rdata:0000084C $SG143583       db '6',9,'c #8DB2E4',0  ; DATA XREF: .data:000001A4o
.rdata:00000858 $SG143584       db '7',9,'c #4885D6',0  ; DATA XREF: .data:000001A8o
.rdata:00000864 $SG143585       db '8',9,'c #7CA9E1',0  ; DATA XREF: .data:000001ACo
.rdata:00000870 $SG143586       db '9',9,'c #6698DB',0  ; DATA XREF: .data:000001B0o
.rdata:0000087C $SG143587       db '0',9,'c #71A1DE',0  ; DATA XREF: .data:000001B4o
.rdata:00000888 $SG143588       db 'a',9,'c #1752C0',0  ; DATA XREF: .data:000001B8o
.rdata:00000894 $SG143589       db 'b',9,'c #88ABE0',0  ; DATA XREF: .data:000001BCo
.rdata:000008A0 $SG143590       db 'c',9,'c #3D77D0',0  ; DATA XREF: .data:000001C0o
.rdata:000008AC $SG143591       db 'd',9,'c #6E9FDD',0  ; DATA XREF: .data:000001C4o
.rdata:000008B8 $SG143592       db 'e',9,'c #699BDC',0  ; DATA XREF: .data:000001C8o
.rdata:000008C4 $SG143593       db 'f',9,'c #1547BD',0  ; DATA XREF: .data:000001CCo
.rdata:000008D0 $SG143594       db 'g',9,'c #8DA6DE',0  ; DATA XREF: .data:000001D0o
.rdata:000008DC $SG143595       db 'h',9,'c #376BC9',0  ; DATA XREF: .data:000001D4o
.rdata:000008E8 $SG143596       db 'i',9,'c #6295DA',0  ; DATA XREF: .data:000001D8o
.rdata:000008F4 $SG143597       db 'j',9,'c #1440B9',0  ; DATA XREF: .data:000001DCo
.rdata:00000900 $SG143598       db 'k',9,'c #8DA0DB',0  ; DATA XREF: .data:000001E0o
.rdata:0000090C $SG143599       db 'l',9,'c #315FC4',0  ; DATA XREF: .data:000001E4o
.rdata:00000918 $SG143600       db 'm',9,'c #1339B7',0  ; DATA XREF: .data:000001E8o
.rdata:00000924 $SG143601       db 'n',9,'c #909FDA',0  ; DATA XREF: .data:000001ECo
.rdata:00000930 $SG143602       db 'o',9,'c #1233B4',0  ; DATA XREF: .data:000001F0o
.rdata:0000093C $SG143603       db '         .+ ',0     ; DATA XREF: .data:000001F4o
.rdata:00000949                 align 4
.rdata:0000094C $SG143604       db '        @#$ ',0     ; DATA XREF: .data:000001F8o
.rdata:00000959                 align 4
.rdata:0000095C $SG143605       db '       %&*= L',0    ; DATA XREF: .data:000001FCo
.rdata:0000096A                 align 4
.rdata:0000096C $SG143606       db '      -;>,',27h,' ',0 ; DATA XREF: .data:00000200o
.rdata:00000979                 align 4
.rdata:0000097C $SG143607       db '     )!>~{] ',0     ; DATA XREF: .data:00000204o
.rdata:00000989                 align 4
.rdata:0000098C $SG143608       db '    ^/(_:<[ ',0     ; DATA XREF: .data:00000208o
.rdata:00000999                 align 4
.rdata:0000099C $SG143609       db '    (}|1234 ',0     ; DATA XREF: .data:0000020Co
.rdata:000009A9                 align 4
.rdata:000009AC $SG143610       db '    567890a ',0     ; DATA XREF: .data:00000210o
.rdata:000009B9                 align 4
.rdata:000009BC $SG143611       db '      bcdef ',0     ; DATA XREF: .data:00000214o
.rdata:000009C9                 align 4
.rdata:000009CC $SG143612       db '       ghij ',0     ; DATA XREF: .data:00000218o
.rdata:000009D9                 align 4
.rdata:000009DC $SG143613       db '        klm ',0     ; DATA XREF: .data:0000021Co
.rdata:000009E9                 align 4
.rdata:000009EC $SG143614       db '         no ',0     ; DATA XREF: .data:00000220o
.rdata:000009F9                 align 4
.rdata:000009FC $SG143616       db '13 14 54 1',0       ; DATA XREF: .data:_bookmark_xpmo
.rdata:00000A07                 align 4
.rdata:00000A08 $SG143617       db ' ',9,'c None',0     ; DATA XREF: .data:0000022Co
.rdata:00000A11                 align 4
.rdata:00000A14 $SG143618       db '.',9,'c #545254',0  ; DATA XREF: .data:00000230o
.rdata:00000A20 $SG143619       db '+',9,'c #3C3E3C',0  ; DATA XREF: .data:00000234o
.rdata:00000A2C $SG143620       db '@',9,'c #646464',0  ; DATA XREF: .data:00000238o
.rdata:00000A38 $SG143621       db '#',9,'c #A4A4A4',0  ; DATA XREF: .data:0000023Co
.rdata:00000A44 $SG143622       db '$',9,'c #B7B8B7',0  ; DATA XREF: .data:00000240o
.rdata:00000A50 $SG143623       db '%',9,'c #747284',0  ; DATA XREF: .data:00000244o
.rdata:00000A5C $SG143624       db '&',9,'c #B4B2C4',0  ; DATA XREF: .data:00000248o
.rdata:00000A68 $SG143625       db '*',9,'c #DCD7E4',0  ; DATA XREF: .data:0000024Co
.rdata:00000A74 $SG143626       db '=',9,'c #1C1A1C',0  ; DATA XREF: .data:00000250o
.rdata:00000A80 $SG143627       db '-',9,'c #403E58',0  ; DATA XREF: .data:00000254o
.rdata:00000A8C $SG143628       db ';',9,'c #5C5A8C',0  ; DATA XREF: .data:00000258o
.rdata:00000A98 $SG143629       db '>',9,'c #7C7EAC',0  ; DATA XREF: .data:0000025Co
.rdata:00000AA4 $SG143630       db ',',9,'c #7C8EBC',0  ; DATA XREF: .data:00000260o
.rdata:00000AB0 $SG143631       db 27h,9,'c #242644',0  ; DATA XREF: .data:00000264o
.rdata:00000ABC $SG143632       db ')',9,'c #282668',0  ; DATA XREF: .data:00000268o
.rdata:00000AC8 $SG143633       db '!',9,'c #24367C',0  ; DATA XREF: .data:0000026Co
.rdata:00000AD4 $SG143634       db '~',9,'c #244A84',0  ; DATA XREF: .data:00000270o
.rdata:00000AE0 $SG143635       db '{',9,'c #2C5098',0  ; DATA XREF: .data:00000274o
.rdata:00000AEC $SG143636       db ']',9,'c #14162C',0  ; DATA XREF: .data:00000278o
.rdata:00000AF8 $SG143637       db '^',9,'c #142E7C',0  ; DATA XREF: .data:0000027Co
.rdata:00000B04 $SG143638       db '/',9,'c #143789',0  ; DATA XREF: .data:00000280o
.rdata:00000B10 $SG143639       db '(',9,'c #204990',0  ; DATA XREF: .data:00000284o
.rdata:00000B1C $SG143640       db '_',9,'c #174091',0  ; DATA XREF: .data:00000288o
.rdata:00000B28 $SG143641       db ':',9,'c #0C0630',0  ; DATA XREF: .data:0000028Co
.rdata:00000B34 $SG143642       db '<',9,'c #24327C',0  ; DATA XREF: .data:00000290o
.rdata:00000B40 $SG143643       db '[',9,'c #2450A0',0  ; DATA XREF: .data:00000294o
.rdata:00000B4C $SG143644       db '}',9,'c #345DB4',0  ; DATA XREF: .data:00000298o
.rdata:00000B58 $SG143645       db '|',9,'c #3C68B8',0  ; DATA XREF: .data:0000029Co
.rdata:00000B64 $SG143646       db '1',9,'c #141244',0  ; DATA XREF: .data:000002A0o
.rdata:00000B70 $SG143647       db '2',9,'c #24428C',0  ; DATA XREF: .data:000002A4o
.rdata:00000B7C $SG143648       db '3',9,'c #3462B9',0  ; DATA XREF: .data:000002A8o
.rdata:00000B88 $SG143649       db '4',9,'c #4470C4',0  ; DATA XREF: .data:000002ACo
.rdata:00000B94 $SG143650       db '5',9,'c #4C7FD6',0  ; DATA XREF: .data:000002B0o
.rdata:00000BA0 $SG143651       db '6',9,'c #4472CC',0  ; DATA XREF: .data:000002B4o
.rdata:00000BAC $SG143652       db '7',9,'c #24224C',0  ; DATA XREF: .data:000002B8o
.rdata:00000BB8 $SG143653       db '8',9,'c #5C8DEC',0  ; DATA XREF: .data:000002BCo
.rdata:00000BC4 $SG143654       db '9',9,'c #5C94F6',0  ; DATA XREF: .data:000002C0o
.rdata:00000BD0 $SG143655       db '0',9,'c #5482DF',0  ; DATA XREF: .data:000002C4o
.rdata:00000BDC $SG143656       db 'a',9,'c #619DF7',0  ; DATA XREF: .data:000002C8o
.rdata:00000BE8 $SG143657       db 'b',9,'c #6CA6FC',0  ; DATA XREF: .data:000002CCo
.rdata:00000BF4 $SG143658       db 'c',9,'c #64A2FC',0  ; DATA XREF: .data:000002D0o
.rdata:00000C00 $SG143659       db 'd',9,'c #1C2E5C',0  ; DATA XREF: .data:000002D4o
.rdata:00000C0C $SG143660       db 'e',9,'c #6CA2FC',0  ; DATA XREF: .data:000002D8o
.rdata:00000C18 $SG143661       db 'f',9,'c #74B2FC',0  ; DATA XREF: .data:000002DCo
.rdata:00000C24 $SG143662       db 'g',9,'c #7CB8FC',0  ; DATA XREF: .data:000002E0o
.rdata:00000C30 $SG143663       db 'h',9,'c #1C3264',0  ; DATA XREF: .data:000002E4o
.rdata:00000C3C $SG143664       db 'i',9,'c #346AD4',0  ; DATA XREF: .data:000002E8o
.rdata:00000C48 $SG143665       db 'j',9,'c #7CBEFC',0  ; DATA XREF: .data:000002ECo
.rdata:00000C54 $SG143666       db 'k',9,'c #3C72DC',0  ; DATA XREF: .data:000002F0o
.rdata:00000C60 $SG143667       db 'l',9,'c #243250',0  ; DATA XREF: .data:000002F4o
.rdata:00000C6C $SG143668       db 'm',9,'c #346AB4',0  ; DATA XREF: .data:000002F8o
.rdata:00000C78 $SG143669       db 'n',9,'c #3C82DC',0  ; DATA XREF: .data:000002FCo
.rdata:00000C84 $SG143670       db 'o',9,'c #6C6A6C',0  ; DATA XREF: .data:00000300o
.rdata:00000C90 $SG143671       db '     .+.     ',0    ; DATA XREF: .data:00000304o
.rdata:00000C9E                 align 10h
.rdata:00000CA0 $SG143672       db '   @##$##@   ',0    ; DATA XREF: .data:00000308o
.rdata:00000CAE                 align 10h
.rdata:00000CB0 $SG143673       db '  @%&***&%@  ',0    ; DATA XREF: .data:0000030Co
.rdata:00000CBE                 align 10h
.rdata:00000CC0 $SG143674       db ' =-;>,,,>;-= ',0    ; DATA XREF: .data:00000310o
.rdata:00000CCE                 align 10h
.rdata:00000CD0 $SG143675       db ' ',27h,')!~{{{~!)',27h,' ',0
.rdata:00000CD0                                         ; DATA XREF: .data:00000314o
.rdata:00000CDE                 align 10h
.rdata:00000CE0 $SG143676       db '])^/({{{(_^)]',0    ; DATA XREF: .data:00000318o
.rdata:00000CEE                 align 10h
.rdata:00000CF0 $SG143677       db ':<_[}|||}[_<:',0    ; DATA XREF: .data:0000031Co
.rdata:00000CFE                 align 10h
.rdata:00000D00 $SG143678       db '12[3455563[21',0    ; DATA XREF: .data:00000320o
.rdata:00000D0E                 align 10h
.rdata:00000D10 $SG143679       db '7_365899063_7',0    ; DATA XREF: .data:00000324o
.rdata:00000D1E                 align 10h
.rdata:00000D20 $SG143680       db ' /|09abc904/ ',0    ; DATA XREF: .data:00000328o
.rdata:00000D2E                 align 10h
.rdata:00000D30 $SG143681       db ' d}8efgfb83d ',0    ; DATA XREF: .data:0000032Co
.rdata:00000D3E                 align 10h
.rdata:00000D40 $SG143682       db '  hiafjgakh  ',0    ; DATA XREF: .data:00000330o
.rdata:00000D4E                 align 10h
.rdata:00000D50 $SG143683       db '   l~mnm~l   ',0    ; DATA XREF: .data:00000334o
.rdata:00000D5E                 align 10h
.rdata:00000D60 $SG143684       db '     o@o     ',0    ; DATA XREF: .data:00000338o
.rdata:00000D6E                 align 10h
.rdata:00000D6E _rdata          ends
.rdata:00000D6E
.bss:00000D70 ; ===========================================================================
.bss:00000D70
.bss:00000D70 ; Segment type: Uninitialized
.bss:00000D70 ; Segment permissions: Read/Write
.bss:00000D70 _bss            segment byte public 'BSS' use32
.bss:00000D70                 assume cs:_bss
.bss:00000D70                 ;org 0D70h
.bss:00000D70                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00000D70                 public ?_hideTabBarStatus@DocTabView@@0_NA
.bss:00000D70 ; private: static bool DocTabView::_hideTabBarStatus
.bss:00000D70 ?_hideTabBarStatus@DocTabView@@0_NA db ?
.bss:00000D70                                         ; DATA XREF: DocTabView::reSizeTo(tagRECT &)+25r
.bss:00000D71 __Tuple_alloc   db    ? ;
.bss:00000D72 ; std::_Ignore ignore
.bss:00000D72 _ignore         db    ? ;               ; DATA XREF: std::`dynamic initializer for 'ignore''(void)+3o
.bss:00000D73 _allocator_arg  db    ? ;
.bss:00000D74 _piecewise_construct db    ? ;
.bss:00000D75                 align 4
.bss:00000D75 _bss            ends
.bss:00000D75
.text$mn:00000D78 ; ===========================================================================
.text$mn:00000D78
.text$mn:00000D78 ; Segment type: Pure code
.text$mn:00000D78 ; Segment permissions: Read/Execute
.text$mn:00000D78 _text$mn        segment para public 'CODE' use32
.text$mn:00000D78                 assume cs:_text$mn
.text$mn:00000D78                 ;org 0D78h
.text$mn:00000D78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00000D78
.text$mn:00000D78 ; =============== S U B R O U T I N E =======================================
.text$mn:00000D78
.text$mn:00000D78 ; Attributes: bp-based frame
.text$mn:00000D78
.text$mn:00000D78 ; void __thiscall DocTabView::addBuffer(DocTabView *this, struct Buffer *)
.text$mn:00000D78                 public ?addBuffer@DocTabView@@QAEXPAVBuffer@@@Z
.text$mn:00000D78 ?addBuffer@DocTabView@@QAEXPAVBuffer@@@Z proc near
.text$mn:00000D78
.text$mn:00000D78 lParam          = dword ptr -2Ch
.text$mn:00000D78 var_20          = dword ptr -20h
.text$mn:00000D78 var_18          = dword ptr -18h
.text$mn:00000D78 var_14          = dword ptr -14h
.text$mn:00000D78 wParam          = dword ptr -10h
.text$mn:00000D78 var_C           = dword ptr -0Ch
.text$mn:00000D78 var_8           = dword ptr -8
.text$mn:00000D78 var_4           = dword ptr -4
.text$mn:00000D78 arg_0           = dword ptr  8
.text$mn:00000D78
.text$mn:00000D78                 push    ebp
.text$mn:00000D79                 mov     ebp, esp
.text$mn:00000D7B                 sub     esp, 2Ch
.text$mn:00000D7E                 mov     [ebp+var_4], ecx
.text$mn:00000D81                 cmp     [ebp+arg_0], 0
.text$mn:00000D85                 jnz     short loc_D8C
.text$mn:00000D87                 jmp     loc_E42
.text$mn:00000D8C ; ---------------------------------------------------------------------------
.text$mn:00000D8C
.text$mn:00000D8C loc_D8C:                                ; CODE XREF: DocTabView::addBuffer(Buffer *)+Dj
.text$mn:00000D8C                 mov     eax, [ebp+arg_0]
.text$mn:00000D8F                 push    eax             ; struct Buffer *
.text$mn:00000D90                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000D93                 call    ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z ; DocTabView::getIndexByBuffer(Buffer *)
.text$mn:00000D98                 cmp     eax, 0FFFFFFFFh
.text$mn:00000D9B                 jz      short loc_DA2
.text$mn:00000D9D                 jmp     loc_E42
.text$mn:00000DA2 ; ---------------------------------------------------------------------------
.text$mn:00000DA2
.text$mn:00000DA2 loc_DA2:                                ; CODE XREF: DocTabView::addBuffer(Buffer *)+23j
.text$mn:00000DA2                 mov     ecx, [ebp+arg_0]
.text$mn:00000DA5                 push    ecx             ; struct Buffer *
.text$mn:00000DA6                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00000DAB                 mov     ecx, eax        ; this
.text$mn:00000DAD                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:00000DB2                 mov     [ebp+var_C], eax
.text$mn:00000DB5                 mov     [ebp+lParam], 0Bh
.text$mn:00000DBC                 mov     [ebp+var_8], 0FFFFFFFFh
.text$mn:00000DC3                 mov     edx, [ebp+var_4]
.text$mn:00000DC6                 movzx   eax, byte ptr [edx+14h]
.text$mn:00000DCA                 test    eax, eax
.text$mn:00000DCC                 jz      short loc_DD5
.text$mn:00000DCE                 mov     [ebp+var_8], 0
.text$mn:00000DD5
.text$mn:00000DD5 loc_DD5:                                ; CODE XREF: DocTabView::addBuffer(Buffer *)+54j
.text$mn:00000DD5                 mov     ecx, [ebp+var_8]
.text$mn:00000DD8                 mov     [ebp+var_18], ecx
.text$mn:00000DDB                 mov     ecx, [ebp+var_C] ; this
.text$mn:00000DDE                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00000DE3                 mov     [ebp+var_20], eax
.text$mn:00000DE6                 mov     edx, [ebp+arg_0]
.text$mn:00000DE9                 mov     [ebp+var_14], edx
.text$mn:00000DEC                 mov     eax, [ebp+var_4]
.text$mn:00000DEF                 mov     ecx, [eax+10h]
.text$mn:00000DF2                 mov     [ebp+wParam], ecx
.text$mn:00000DF5                 mov     edx, [ebp+var_4]
.text$mn:00000DF8                 mov     eax, [edx+10h]
.text$mn:00000DFB                 add     eax, 1
.text$mn:00000DFE                 mov     ecx, [ebp+var_4]
.text$mn:00000E01                 mov     [ecx+10h], eax
.text$mn:00000E04                 lea     edx, [ebp+lParam]
.text$mn:00000E07                 push    edx             ; lParam
.text$mn:00000E08                 mov     eax, [ebp+wParam]
.text$mn:00000E0B                 push    eax             ; wParam
.text$mn:00000E0C                 push    133Eh           ; Msg
.text$mn:00000E11                 mov     ecx, [ebp+var_4]
.text$mn:00000E14                 mov     edx, [ecx+0Ch]
.text$mn:00000E17                 push    edx             ; hWnd
.text$mn:00000E18                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E1E                 push    3FFh            ; int
.text$mn:00000E23                 mov     eax, [ebp+var_C]
.text$mn:00000E26                 push    eax             ; struct Buffer *
.text$mn:00000E27                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E2A                 call    ?bufferUpdated@DocTabView@@QAEXPAVBuffer@@H@Z ; DocTabView::bufferUpdated(Buffer *,int)
.text$mn:00000E2F                 push    0               ; lParam
.text$mn:00000E31                 push    0               ; wParam
.text$mn:00000E33                 push    5               ; Msg
.text$mn:00000E35                 mov     ecx, [ebp+var_4]
.text$mn:00000E38                 mov     edx, [ecx+8]
.text$mn:00000E3B                 push    edx             ; hWnd
.text$mn:00000E3C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E42
.text$mn:00000E42 loc_E42:                                ; CODE XREF: DocTabView::addBuffer(Buffer *)+Fj
.text$mn:00000E42                                         ; DocTabView::addBuffer(Buffer *)+25j
.text$mn:00000E42                 mov     esp, ebp
.text$mn:00000E44                 pop     ebp
.text$mn:00000E45                 retn    4
.text$mn:00000E45 ?addBuffer@DocTabView@@QAEXPAVBuffer@@@Z endp
.text$mn:00000E45
.text$mn:00000E48
.text$mn:00000E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E48
.text$mn:00000E48 ; Attributes: bp-based frame
.text$mn:00000E48
.text$mn:00000E48 ; void __thiscall DocTabView::closeBuffer(DocTabView *this, struct Buffer *)
.text$mn:00000E48                 public ?closeBuffer@DocTabView@@QAEXPAVBuffer@@@Z
.text$mn:00000E48 ?closeBuffer@DocTabView@@QAEXPAVBuffer@@@Z proc near
.text$mn:00000E48
.text$mn:00000E48 var_8           = dword ptr -8
.text$mn:00000E48 var_4           = dword ptr -4
.text$mn:00000E48 arg_0           = dword ptr  8
.text$mn:00000E48
.text$mn:00000E48                 push    ebp
.text$mn:00000E49                 mov     ebp, esp
.text$mn:00000E4B                 sub     esp, 8
.text$mn:00000E4E                 mov     [ebp+var_4], ecx
.text$mn:00000E51                 mov     eax, [ebp+arg_0]
.text$mn:00000E54                 push    eax             ; struct Buffer *
.text$mn:00000E55                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E58                 call    ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z ; DocTabView::getIndexByBuffer(Buffer *)
.text$mn:00000E5D                 mov     [ebp+var_8], eax
.text$mn:00000E60                 mov     ecx, [ebp+var_8]
.text$mn:00000E63                 push    ecx             ; unsigned int
.text$mn:00000E64                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000E67                 call    ?deletItemAt@TabBar@@QAEXI@Z ; TabBar::deletItemAt(uint)
.text$mn:00000E6C                 push    0               ; lParam
.text$mn:00000E6E                 push    0               ; wParam
.text$mn:00000E70                 push    5               ; Msg
.text$mn:00000E72                 mov     edx, [ebp+var_4]
.text$mn:00000E75                 mov     eax, [edx+8]
.text$mn:00000E78                 push    eax             ; hWnd
.text$mn:00000E79                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E7F                 mov     esp, ebp
.text$mn:00000E81                 pop     ebp
.text$mn:00000E82                 retn    4
.text$mn:00000E82 ?closeBuffer@DocTabView@@QAEXPAVBuffer@@@Z endp
.text$mn:00000E82
.text$mn:00000E82 ; ---------------------------------------------------------------------------
.text$mn:00000E85                 align 4
.text$mn:00000E88
.text$mn:00000E88 ; =============== S U B R O U T I N E =======================================
.text$mn:00000E88
.text$mn:00000E88 ; Attributes: bp-based frame
.text$mn:00000E88
.text$mn:00000E88 ; void __thiscall DocTabView::bufferUpdated(DocTabView *this, struct Buffer *, int)
.text$mn:00000E88                 public ?bufferUpdated@DocTabView@@QAEXPAVBuffer@@H@Z
.text$mn:00000E88 ?bufferUpdated@DocTabView@@QAEXPAVBuffer@@H@Z proc near
.text$mn:00000E88                                         ; CODE XREF: DocTabView::addBuffer(Buffer *)+B2p
.text$mn:00000E88                                         ; DocTabView::setBuffer(int,Buffer *)+5Cp
.text$mn:00000E88
.text$mn:00000E88 lParam          = dword ptr -444h
.text$mn:00000E88 var_438         = dword ptr -438h
.text$mn:00000E88 var_430         = dword ptr -430h
.text$mn:00000E88 var_42C         = dword ptr -42Ch
.text$mn:00000E88 wParam          = dword ptr -428h
.text$mn:00000E88 var_424         = dword ptr -424h
.text$mn:00000E88 var_420         = dword ptr -420h
.text$mn:00000E88 var_41C         = dword ptr -41Ch
.text$mn:00000E88 var_418         = dword ptr -418h
.text$mn:00000E88 var_414         = byte ptr -414h
.text$mn:00000E88 var_4           = dword ptr -4
.text$mn:00000E88 arg_0           = dword ptr  8
.text$mn:00000E88 arg_4           = dword ptr  0Ch
.text$mn:00000E88
.text$mn:00000E88                 push    ebp
.text$mn:00000E89                 mov     ebp, esp
.text$mn:00000E8B                 sub     esp, 444h
.text$mn:00000E91                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000E96                 xor     eax, ebp
.text$mn:00000E98                 mov     [ebp+var_4], eax
.text$mn:00000E9B                 mov     [ebp+var_420], ecx
.text$mn:00000EA1                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000EA4                 call    ?getID@Buffer@@QBEPAV1@XZ ; Buffer::getID(void)
.text$mn:00000EA9                 push    eax             ; struct Buffer *
.text$mn:00000EAA                 mov     ecx, [ebp+var_420] ; this
.text$mn:00000EB0                 call    ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z ; DocTabView::getIndexByBuffer(Buffer *)
.text$mn:00000EB5                 mov     [ebp+wParam], eax
.text$mn:00000EBB                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:00000EC2                 jnz     short loc_EC9
.text$mn:00000EC4                 jmp     loc_10A4
.text$mn:00000EC9 ; ---------------------------------------------------------------------------
.text$mn:00000EC9
.text$mn:00000EC9 loc_EC9:                                ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+3Aj
.text$mn:00000EC9                 mov     [ebp+var_42C], 0FFFFFFFFh
.text$mn:00000ED3                 mov     [ebp+lParam], 0
.text$mn:00000EDD                 mov     eax, [ebp+arg_4]
.text$mn:00000EE0                 and     eax, 10h
.text$mn:00000EE3                 jnz     short loc_EED
.text$mn:00000EE5                 mov     ecx, [ebp+arg_4]
.text$mn:00000EE8                 and     ecx, 2
.text$mn:00000EEB                 jz      short loc_F46
.text$mn:00000EED
.text$mn:00000EED loc_EED:                                ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+5Bj
.text$mn:00000EED                 mov     edx, [ebp+lParam]
.text$mn:00000EF3                 or      edx, 2
.text$mn:00000EF6                 mov     [ebp+lParam], edx
.text$mn:00000EFC                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000EFF                 call    ?isDirty@Buffer@@QBE_NXZ ; Buffer::isDirty(void)
.text$mn:00000F04                 movzx   eax, al
.text$mn:00000F07                 test    eax, eax
.text$mn:00000F09                 jz      short loc_F17
.text$mn:00000F0B                 mov     [ebp+var_424], 1
.text$mn:00000F15                 jmp     short loc_F21
.text$mn:00000F17 ; ---------------------------------------------------------------------------
.text$mn:00000F17
.text$mn:00000F17 loc_F17:                                ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+81j
.text$mn:00000F17                 mov     [ebp+var_424], 0
.text$mn:00000F21
.text$mn:00000F21 loc_F21:                                ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+8Dj
.text$mn:00000F21                 mov     ecx, [ebp+var_424]
.text$mn:00000F27                 mov     [ebp+var_430], ecx
.text$mn:00000F2D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F30                 call    ?isReadOnly@Buffer@@QBE_NXZ ; Buffer::isReadOnly(void)
.text$mn:00000F35                 movzx   edx, al
.text$mn:00000F38                 test    edx, edx
.text$mn:00000F3A                 jz      short loc_F46
.text$mn:00000F3C                 mov     [ebp+var_430], 2
.text$mn:00000F46
.text$mn:00000F46 loc_F46:                                ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+63j
.text$mn:00000F46                                         ; DocTabView::bufferUpdated(Buffer *,int)+B2j
.text$mn:00000F46                 mov     eax, [ebp+arg_4]
.text$mn:00000F49                 and     eax, 80h
.text$mn:00000F4E                 jz      loc_1060
.text$mn:00000F54                 mov     ecx, [ebp+lParam]
.text$mn:00000F5A                 or      ecx, 1
.text$mn:00000F5D                 mov     [ebp+lParam], ecx
.text$mn:00000F63                 lea     edx, [ebp+var_414]
.text$mn:00000F69                 mov     [ebp+var_438], edx
.text$mn:00000F6F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00000F72                 call    ?getFileName@Buffer@@QBEPB_WXZ ; Buffer::getFileName(void)
.text$mn:00000F77                 mov     [ebp+var_41C], eax
.text$mn:00000F7D                 lea     eax, [ebp+var_414]
.text$mn:00000F83                 mov     [ebp+var_418], eax
.text$mn:00000F89
.text$mn:00000F89 loc_F89:                                ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int):loc_1050j
.text$mn:00000F89                 mov     ecx, [ebp+var_41C]
.text$mn:00000F8F                 movzx   edx, word ptr [ecx]
.text$mn:00000F92                 test    edx, edx
.text$mn:00000F94                 jz      loc_1055
.text$mn:00000F9A                 mov     eax, [ebp+var_41C]
.text$mn:00000FA0                 movzx   ecx, word ptr [eax]
.text$mn:00000FA3                 cmp     ecx, 26h ; '&'
.text$mn:00000FA6                 jnz     short loc_1020
.text$mn:00000FA8                 mov     edx, 26h ; '&'
.text$mn:00000FAD                 mov     eax, [ebp+var_418]
.text$mn:00000FB3                 mov     [eax], dx
.text$mn:00000FB6                 mov     ecx, [ebp+var_418]
.text$mn:00000FBC                 add     ecx, 2
.text$mn:00000FBF                 mov     [ebp+var_418], ecx
.text$mn:00000FC5                 mov     edx, 26h ; '&'
.text$mn:00000FCA                 mov     eax, [ebp+var_418]
.text$mn:00000FD0                 mov     [eax], dx
.text$mn:00000FD3                 mov     ecx, [ebp+var_418]
.text$mn:00000FD9                 add     ecx, 2
.text$mn:00000FDC                 mov     [ebp+var_418], ecx
.text$mn:00000FE2
.text$mn:00000FE2 loc_FE2:                                ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+194j
.text$mn:00000FE2                 mov     edx, [ebp+var_41C]
.text$mn:00000FE8                 add     edx, 2
.text$mn:00000FEB                 mov     [ebp+var_41C], edx
.text$mn:00000FF1                 mov     eax, [ebp+var_41C]
.text$mn:00000FF7                 movzx   ecx, word ptr [eax]
.text$mn:00000FFA                 cmp     ecx, 26h ; '&'
.text$mn:00000FFD                 jnz     short loc_101E
.text$mn:00000FFF                 mov     edx, 26h ; '&'
.text$mn:00001004                 mov     eax, [ebp+var_418]
.text$mn:0000100A                 mov     [eax], dx
.text$mn:0000100D                 mov     ecx, [ebp+var_418]
.text$mn:00001013                 add     ecx, 2
.text$mn:00001016                 mov     [ebp+var_418], ecx
.text$mn:0000101C                 jmp     short loc_FE2
.text$mn:0000101E ; ---------------------------------------------------------------------------
.text$mn:0000101E
.text$mn:0000101E loc_101E:                               ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+175j
.text$mn:0000101E                 jmp     short loc_1050
.text$mn:00001020 ; ---------------------------------------------------------------------------
.text$mn:00001020
.text$mn:00001020 loc_1020:                               ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+11Ej
.text$mn:00001020                 mov     edx, [ebp+var_418]
.text$mn:00001026                 mov     eax, [ebp+var_41C]
.text$mn:0000102C                 mov     cx, [eax]
.text$mn:0000102F                 mov     [edx], cx
.text$mn:00001032                 mov     edx, [ebp+var_418]
.text$mn:00001038                 add     edx, 2
.text$mn:0000103B                 mov     [ebp+var_418], edx
.text$mn:00001041                 mov     eax, [ebp+var_41C]
.text$mn:00001047                 add     eax, 2
.text$mn:0000104A                 mov     [ebp+var_41C], eax
.text$mn:00001050
.text$mn:00001050 loc_1050:                               ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int):loc_101Ej
.text$mn:00001050                 jmp     loc_F89
.text$mn:00001055 ; ---------------------------------------------------------------------------
.text$mn:00001055
.text$mn:00001055 loc_1055:                               ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+10Cj
.text$mn:00001055                 xor     ecx, ecx
.text$mn:00001057                 mov     edx, [ebp+var_418]
.text$mn:0000105D                 mov     [edx], cx
.text$mn:00001060
.text$mn:00001060 loc_1060:                               ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+C6j
.text$mn:00001060                 lea     eax, [ebp+lParam]
.text$mn:00001066                 push    eax             ; lParam
.text$mn:00001067                 mov     ecx, [ebp+wParam]
.text$mn:0000106D                 push    ecx             ; wParam
.text$mn:0000106E                 push    133Dh           ; Msg
.text$mn:00001073                 mov     edx, [ebp+var_420]
.text$mn:00001079                 mov     eax, [edx+0Ch]
.text$mn:0000107C                 push    eax             ; hWnd
.text$mn:0000107D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001083                 mov     ecx, [ebp+arg_4]
.text$mn:00001086                 and     ecx, 100h
.text$mn:0000108C                 jz      short loc_10A4
.text$mn:0000108E                 push    0               ; lParam
.text$mn:00001090                 push    0               ; wParam
.text$mn:00001092                 push    5               ; Msg
.text$mn:00001094                 mov     edx, [ebp+var_420]
.text$mn:0000109A                 mov     eax, [edx+8]
.text$mn:0000109D                 push    eax             ; hWnd
.text$mn:0000109E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000010A4
.text$mn:000010A4 loc_10A4:                               ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+3Cj
.text$mn:000010A4                                         ; DocTabView::bufferUpdated(Buffer *,int)+204j
.text$mn:000010A4                 mov     ecx, [ebp+var_4]
.text$mn:000010A7                 xor     ecx, ebp
.text$mn:000010A9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000010AE                 mov     esp, ebp
.text$mn:000010B0                 pop     ebp
.text$mn:000010B1                 retn    8
.text$mn:000010B1 ?bufferUpdated@DocTabView@@QAEXPAVBuffer@@H@Z endp
.text$mn:000010B1
.text$mn:000010B1 ; ---------------------------------------------------------------------------
.text$mn:000010B4                 align 8
.text$mn:000010B8
.text$mn:000010B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010B8
.text$mn:000010B8 ; Attributes: bp-based frame
.text$mn:000010B8
.text$mn:000010B8 ; bool __thiscall DocTabView::activateBuffer(DocTabView *this, struct Buffer *)
.text$mn:000010B8                 public ?activateBuffer@DocTabView@@QAE_NPAVBuffer@@@Z
.text$mn:000010B8 ?activateBuffer@DocTabView@@QAE_NPAVBuffer@@@Z proc near
.text$mn:000010B8
.text$mn:000010B8 var_8           = dword ptr -8
.text$mn:000010B8 var_4           = dword ptr -4
.text$mn:000010B8 arg_0           = dword ptr  8
.text$mn:000010B8
.text$mn:000010B8                 push    ebp
.text$mn:000010B9                 mov     ebp, esp
.text$mn:000010BB                 sub     esp, 8
.text$mn:000010BE                 mov     [ebp+var_8], ecx
.text$mn:000010C1                 mov     eax, [ebp+arg_0]
.text$mn:000010C4                 push    eax             ; struct Buffer *
.text$mn:000010C5                 mov     ecx, [ebp+var_8] ; this
.text$mn:000010C8                 call    ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z ; DocTabView::getIndexByBuffer(Buffer *)
.text$mn:000010CD                 mov     [ebp+var_4], eax
.text$mn:000010D0                 cmp     [ebp+var_4], 0FFFFFFFFh
.text$mn:000010D4                 jnz     short loc_10DA
.text$mn:000010D6                 xor     al, al
.text$mn:000010D8                 jmp     short loc_10E8
.text$mn:000010DA ; ---------------------------------------------------------------------------
.text$mn:000010DA
.text$mn:000010DA loc_10DA:                               ; CODE XREF: DocTabView::activateBuffer(Buffer *)+1Cj
.text$mn:000010DA                 mov     ecx, [ebp+var_4]
.text$mn:000010DD                 push    ecx             ; int
.text$mn:000010DE                 mov     ecx, [ebp+var_8] ; this
.text$mn:000010E1                 call    ?activateAt@TabBar@@QBEXH@Z ; TabBar::activateAt(int)
.text$mn:000010E6                 mov     al, 1
.text$mn:000010E8
.text$mn:000010E8 loc_10E8:                               ; CODE XREF: DocTabView::activateBuffer(Buffer *)+20j
.text$mn:000010E8                 mov     esp, ebp
.text$mn:000010EA                 pop     ebp
.text$mn:000010EB                 retn    4
.text$mn:000010EB ?activateBuffer@DocTabView@@QAE_NPAVBuffer@@@Z endp
.text$mn:000010EB
.text$mn:000010EB ; ---------------------------------------------------------------------------
.text$mn:000010EE                 db 0Ah dup(0CCh)
.text$mn:000010F8
.text$mn:000010F8 ; =============== S U B R O U T I N E =======================================
.text$mn:000010F8
.text$mn:000010F8 ; Attributes: bp-based frame
.text$mn:000010F8
.text$mn:000010F8 ; struct Buffer *__thiscall DocTabView::activeBuffer(DocTabView *__hidden this)
.text$mn:000010F8                 public ?activeBuffer@DocTabView@@QAEPAVBuffer@@XZ
.text$mn:000010F8 ?activeBuffer@DocTabView@@QAEPAVBuffer@@XZ proc near
.text$mn:000010F8
.text$mn:000010F8 var_8           = dword ptr -8
.text$mn:000010F8 var_4           = dword ptr -4
.text$mn:000010F8
.text$mn:000010F8                 push    ebp
.text$mn:000010F9                 mov     ebp, esp
.text$mn:000010FB                 sub     esp, 8
.text$mn:000010FE                 mov     [ebp+var_4], ecx
.text$mn:00001101                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001104                 call    ?getCurrentTabIndex@TabBar@@QBEHXZ ; TabBar::getCurrentTabIndex(void)
.text$mn:00001109                 mov     [ebp+var_8], eax
.text$mn:0000110C                 mov     eax, [ebp+var_8]
.text$mn:0000110F                 push    eax             ; int
.text$mn:00001110                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001113                 call    ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z ; DocTabView::getBufferByIndex(int)
.text$mn:00001118                 mov     esp, ebp
.text$mn:0000111A                 pop     ebp
.text$mn:0000111B                 retn
.text$mn:0000111B ?activeBuffer@DocTabView@@QAEPAVBuffer@@XZ endp
.text$mn:0000111B
.text$mn:0000111B ; ---------------------------------------------------------------------------
.text$mn:0000111C                 db 0Ch dup(0CCh)
.text$mn:00001128
.text$mn:00001128 ; =============== S U B R O U T I N E =======================================
.text$mn:00001128
.text$mn:00001128 ; Attributes: bp-based frame
.text$mn:00001128
.text$mn:00001128 ; struct Buffer *__thiscall DocTabView::findBufferByName(DocTabView *this, const wchar_t *)
.text$mn:00001128                 public ?findBufferByName@DocTabView@@QAEPAVBuffer@@PB_W@Z
.text$mn:00001128 ?findBufferByName@DocTabView@@QAEPAVBuffer@@PB_W@Z proc near
.text$mn:00001128
.text$mn:00001128 lParam          = dword ptr -2Ch
.text$mn:00001128 var_14          = dword ptr -14h
.text$mn:00001128 var_10          = dword ptr -10h
.text$mn:00001128 var_C           = dword ptr -0Ch
.text$mn:00001128 var_8           = dword ptr -8
.text$mn:00001128 wParam          = dword ptr -4
.text$mn:00001128 lpString1       = dword ptr  8
.text$mn:00001128
.text$mn:00001128                 push    ebp
.text$mn:00001129                 mov     ebp, esp
.text$mn:0000112B                 sub     esp, 2Ch
.text$mn:0000112E                 mov     [ebp+var_8], ecx
.text$mn:00001131                 mov     [ebp+var_14], 0FFFFFFFFh
.text$mn:00001138                 mov     [ebp+lParam], 8
.text$mn:0000113F                 mov     [ebp+wParam], 0
.text$mn:00001146                 jmp     short loc_1151
.text$mn:00001148 ; ---------------------------------------------------------------------------
.text$mn:00001148
.text$mn:00001148 loc_1148:                               ; CODE XREF: DocTabView::findBufferByName(wchar_t const *):loc_11ABj
.text$mn:00001148                 mov     eax, [ebp+wParam]
.text$mn:0000114B                 add     eax, 1
.text$mn:0000114E                 mov     [ebp+wParam], eax
.text$mn:00001151
.text$mn:00001151 loc_1151:                               ; CODE XREF: DocTabView::findBufferByName(wchar_t const *)+1Ej
.text$mn:00001151                 mov     ecx, [ebp+var_8]
.text$mn:00001154                 mov     edx, [ebp+wParam]
.text$mn:00001157                 cmp     edx, [ecx+10h]
.text$mn:0000115A                 jnb     short loc_11AD
.text$mn:0000115C                 lea     eax, [ebp+lParam]
.text$mn:0000115F                 push    eax             ; lParam
.text$mn:00001160                 mov     ecx, [ebp+wParam]
.text$mn:00001163                 push    ecx             ; wParam
.text$mn:00001164                 push    133Ch           ; Msg
.text$mn:00001169                 mov     edx, [ebp+var_8]
.text$mn:0000116C                 mov     eax, [edx+0Ch]
.text$mn:0000116F                 push    eax             ; hWnd
.text$mn:00001170                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001176                 mov     ecx, [ebp+var_14]
.text$mn:00001179                 mov     [ebp+var_C], ecx
.text$mn:0000117C                 mov     edx, [ebp+var_C]
.text$mn:0000117F                 push    edx             ; struct Buffer *
.text$mn:00001180                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:00001185                 mov     ecx, eax        ; this
.text$mn:00001187                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:0000118C                 mov     [ebp+var_10], eax
.text$mn:0000118F                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001192                 call    ?getFullPathName@Buffer@@QBEPB_WXZ ; Buffer::getFullPathName(void)
.text$mn:00001197                 push    eax             ; lpString2
.text$mn:00001198                 mov     eax, [ebp+lpString1]
.text$mn:0000119B                 push    eax             ; lpString1
.text$mn:0000119C                 call    dword ptr ds:__imp__lstrcmpW@8 ; lstrcmpW(x,x)
.text$mn:000011A2                 test    eax, eax
.text$mn:000011A4                 jnz     short loc_11AB
.text$mn:000011A6                 mov     eax, [ebp+var_C]
.text$mn:000011A9                 jmp     short loc_11AF
.text$mn:000011AB ; ---------------------------------------------------------------------------
.text$mn:000011AB
.text$mn:000011AB loc_11AB:                               ; CODE XREF: DocTabView::findBufferByName(wchar_t const *)+7Cj
.text$mn:000011AB                 jmp     short loc_1148
.text$mn:000011AD ; ---------------------------------------------------------------------------
.text$mn:000011AD
.text$mn:000011AD loc_11AD:                               ; CODE XREF: DocTabView::findBufferByName(wchar_t const *)+32j
.text$mn:000011AD                 xor     eax, eax
.text$mn:000011AF
.text$mn:000011AF loc_11AF:                               ; CODE XREF: DocTabView::findBufferByName(wchar_t const *)+81j
.text$mn:000011AF                 mov     esp, ebp
.text$mn:000011B1                 pop     ebp
.text$mn:000011B2                 retn    4
.text$mn:000011B2 ?findBufferByName@DocTabView@@QAEPAVBuffer@@PB_W@Z endp
.text$mn:000011B2
.text$mn:000011B2 ; ---------------------------------------------------------------------------
.text$mn:000011B5                 align 4
.text$mn:000011B8
.text$mn:000011B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000011B8
.text$mn:000011B8 ; Attributes: bp-based frame
.text$mn:000011B8
.text$mn:000011B8 ; int __thiscall DocTabView::getIndexByBuffer(DocTabView *this, struct Buffer *)
.text$mn:000011B8                 public ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z
.text$mn:000011B8 ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z proc near
.text$mn:000011B8                                         ; CODE XREF: DocTabView::addBuffer(Buffer *)+1Bp
.text$mn:000011B8                                         ; DocTabView::closeBuffer(Buffer *)+10p ...
.text$mn:000011B8
.text$mn:000011B8 lParam          = dword ptr -24h
.text$mn:000011B8 var_C           = dword ptr -0Ch
.text$mn:000011B8 var_8           = dword ptr -8
.text$mn:000011B8 wParam          = dword ptr -4
.text$mn:000011B8 arg_0           = dword ptr  8
.text$mn:000011B8
.text$mn:000011B8                 push    ebp
.text$mn:000011B9                 mov     ebp, esp
.text$mn:000011BB                 sub     esp, 24h
.text$mn:000011BE                 mov     [ebp+var_8], ecx
.text$mn:000011C1                 mov     [ebp+var_C], 0FFFFFFFFh
.text$mn:000011C8                 mov     [ebp+lParam], 8
.text$mn:000011CF                 mov     [ebp+wParam], 0
.text$mn:000011D6                 jmp     short loc_11E1
.text$mn:000011D8 ; ---------------------------------------------------------------------------
.text$mn:000011D8
.text$mn:000011D8 loc_11D8:                               ; CODE XREF: DocTabView::getIndexByBuffer(Buffer *):loc_1213j
.text$mn:000011D8                 mov     eax, [ebp+wParam]
.text$mn:000011DB                 add     eax, 1
.text$mn:000011DE                 mov     [ebp+wParam], eax
.text$mn:000011E1
.text$mn:000011E1 loc_11E1:                               ; CODE XREF: DocTabView::getIndexByBuffer(Buffer *)+1Ej
.text$mn:000011E1                 mov     ecx, [ebp+var_8]
.text$mn:000011E4                 mov     edx, [ebp+wParam]
.text$mn:000011E7                 cmp     edx, [ecx+10h]
.text$mn:000011EA                 jge     short loc_1215
.text$mn:000011EC                 lea     eax, [ebp+lParam]
.text$mn:000011EF                 push    eax             ; lParam
.text$mn:000011F0                 mov     ecx, [ebp+wParam]
.text$mn:000011F3                 push    ecx             ; wParam
.text$mn:000011F4                 push    133Ch           ; Msg
.text$mn:000011F9                 mov     edx, [ebp+var_8]
.text$mn:000011FC                 mov     eax, [edx+0Ch]
.text$mn:000011FF                 push    eax             ; hWnd
.text$mn:00001200                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001206                 mov     ecx, [ebp+var_C]
.text$mn:00001209                 cmp     ecx, [ebp+arg_0]
.text$mn:0000120C                 jnz     short loc_1213
.text$mn:0000120E                 mov     eax, [ebp+wParam]
.text$mn:00001211                 jmp     short loc_1218
.text$mn:00001213 ; ---------------------------------------------------------------------------
.text$mn:00001213
.text$mn:00001213 loc_1213:                               ; CODE XREF: DocTabView::getIndexByBuffer(Buffer *)+54j
.text$mn:00001213                 jmp     short loc_11D8
.text$mn:00001215 ; ---------------------------------------------------------------------------
.text$mn:00001215
.text$mn:00001215 loc_1215:                               ; CODE XREF: DocTabView::getIndexByBuffer(Buffer *)+32j
.text$mn:00001215                 or      eax, 0FFFFFFFFh
.text$mn:00001218
.text$mn:00001218 loc_1218:                               ; CODE XREF: DocTabView::getIndexByBuffer(Buffer *)+59j
.text$mn:00001218                 mov     esp, ebp
.text$mn:0000121A                 pop     ebp
.text$mn:0000121B                 retn    4
.text$mn:0000121B ?getIndexByBuffer@DocTabView@@QAEHPAVBuffer@@@Z endp
.text$mn:0000121B
.text$mn:0000121B ; ---------------------------------------------------------------------------
.text$mn:0000121E                 db 0Ah dup(0CCh)
.text$mn:00001228
.text$mn:00001228 ; =============== S U B R O U T I N E =======================================
.text$mn:00001228
.text$mn:00001228 ; Attributes: bp-based frame
.text$mn:00001228
.text$mn:00001228 ; struct Buffer *__thiscall DocTabView::getBufferByIndex(DocTabView *this, int)
.text$mn:00001228                 public ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z
.text$mn:00001228 ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z proc near
.text$mn:00001228                                         ; CODE XREF: DocTabView::activeBuffer(void)+1Bp
.text$mn:00001228
.text$mn:00001228 lParam          = dword ptr -20h
.text$mn:00001228 var_8           = dword ptr -8
.text$mn:00001228 var_4           = dword ptr -4
.text$mn:00001228 wParam          = dword ptr  8
.text$mn:00001228
.text$mn:00001228                 push    ebp
.text$mn:00001229                 mov     ebp, esp
.text$mn:0000122B                 sub     esp, 20h
.text$mn:0000122E                 mov     [ebp+var_4], ecx
.text$mn:00001231                 mov     [ebp+var_8], 0FFFFFFFFh
.text$mn:00001238                 mov     [ebp+lParam], 8
.text$mn:0000123F                 lea     eax, [ebp+lParam]
.text$mn:00001242                 push    eax             ; lParam
.text$mn:00001243                 mov     ecx, [ebp+wParam]
.text$mn:00001246                 push    ecx             ; wParam
.text$mn:00001247                 push    133Ch           ; Msg
.text$mn:0000124C                 mov     edx, [ebp+var_4]
.text$mn:0000124F                 mov     eax, [edx+0Ch]
.text$mn:00001252                 push    eax             ; hWnd
.text$mn:00001253                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001259                 mov     eax, [ebp+var_8]
.text$mn:0000125C                 mov     esp, ebp
.text$mn:0000125E                 pop     ebp
.text$mn:0000125F                 retn    4
.text$mn:0000125F ?getBufferByIndex@DocTabView@@QAEPAVBuffer@@H@Z endp
.text$mn:0000125F
.text$mn:0000125F ; ---------------------------------------------------------------------------
.text$mn:00001262                 align 8
.text$mn:00001268
.text$mn:00001268 ; =============== S U B R O U T I N E =======================================
.text$mn:00001268
.text$mn:00001268 ; Attributes: bp-based frame
.text$mn:00001268
.text$mn:00001268 ; void __thiscall DocTabView::setBuffer(DocTabView *this, WPARAM wParam, struct Buffer *)
.text$mn:00001268                 public ?setBuffer@DocTabView@@QAEXHPAVBuffer@@@Z
.text$mn:00001268 ?setBuffer@DocTabView@@QAEXHPAVBuffer@@@Z proc near
.text$mn:00001268
.text$mn:00001268 lParam          = dword ptr -20h
.text$mn:00001268 var_8           = dword ptr -8
.text$mn:00001268 var_4           = dword ptr -4
.text$mn:00001268 wParam          = dword ptr  8
.text$mn:00001268 arg_4           = dword ptr  0Ch
.text$mn:00001268
.text$mn:00001268                 push    ebp
.text$mn:00001269                 mov     ebp, esp
.text$mn:0000126B                 sub     esp, 20h
.text$mn:0000126E                 mov     [ebp+var_4], ecx
.text$mn:00001271                 cmp     [ebp+wParam], 0
.text$mn:00001275                 jl      short loc_1282
.text$mn:00001277                 mov     eax, [ebp+var_4]
.text$mn:0000127A                 mov     ecx, [ebp+wParam]
.text$mn:0000127D                 cmp     ecx, [eax+10h]
.text$mn:00001280                 jl      short loc_1284
.text$mn:00001282
.text$mn:00001282 loc_1282:                               ; CODE XREF: DocTabView::setBuffer(int,Buffer *)+Dj
.text$mn:00001282                 jmp     short loc_12DC
.text$mn:00001284 ; ---------------------------------------------------------------------------
.text$mn:00001284
.text$mn:00001284 loc_1284:                               ; CODE XREF: DocTabView::setBuffer(int,Buffer *)+18j
.text$mn:00001284                 mov     edx, [ebp+arg_4]
.text$mn:00001287                 mov     [ebp+var_8], edx
.text$mn:0000128A                 mov     [ebp+lParam], 8
.text$mn:00001291                 lea     eax, [ebp+lParam]
.text$mn:00001294                 push    eax             ; lParam
.text$mn:00001295                 mov     ecx, [ebp+wParam]
.text$mn:00001298                 push    ecx             ; wParam
.text$mn:00001299                 push    133Dh           ; Msg
.text$mn:0000129E                 mov     edx, [ebp+var_4]
.text$mn:000012A1                 mov     eax, [edx+0Ch]
.text$mn:000012A4                 push    eax             ; hWnd
.text$mn:000012A5                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000012AB                 push    3FFh            ; int
.text$mn:000012B0                 mov     ecx, [ebp+arg_4]
.text$mn:000012B3                 push    ecx             ; struct Buffer *
.text$mn:000012B4                 call    ?getInstance@FileManager@@SAPAV1@XZ ; FileManager::getInstance(void)
.text$mn:000012B9                 mov     ecx, eax        ; this
.text$mn:000012BB                 call    ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z ; FileManager::getBufferByID(Buffer *)
.text$mn:000012C0                 push    eax             ; struct Buffer *
.text$mn:000012C1                 mov     ecx, [ebp+var_4] ; this
.text$mn:000012C4                 call    ?bufferUpdated@DocTabView@@QAEXPAVBuffer@@H@Z ; DocTabView::bufferUpdated(Buffer *,int)
.text$mn:000012C9                 push    0               ; lParam
.text$mn:000012CB                 push    0               ; wParam
.text$mn:000012CD                 push    5               ; Msg
.text$mn:000012CF                 mov     edx, [ebp+var_4]
.text$mn:000012D2                 mov     eax, [edx+8]
.text$mn:000012D5                 push    eax             ; hWnd
.text$mn:000012D6                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000012DC
.text$mn:000012DC loc_12DC:                               ; CODE XREF: DocTabView::setBuffer(int,Buffer *):loc_1282j
.text$mn:000012DC                 mov     esp, ebp
.text$mn:000012DE                 pop     ebp
.text$mn:000012DF                 retn    8
.text$mn:000012DF ?setBuffer@DocTabView@@QAEXHPAVBuffer@@@Z endp
.text$mn:000012DF
.text$mn:000012DF ; ---------------------------------------------------------------------------
.text$mn:000012E2                 align 8
.text$mn:000012E8
.text$mn:000012E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000012E8
.text$mn:000012E8 ; Attributes: bp-based frame
.text$mn:000012E8
.text$mn:000012E8 ; void __thiscall DocTabView::reSizeTo(DocTabView *this, struct tagRECT *)
.text$mn:000012E8                 public ?reSizeTo@DocTabView@@UAEXAAUtagRECT@@@Z
.text$mn:000012E8 ?reSizeTo@DocTabView@@UAEXAAUtagRECT@@@Z proc near
.text$mn:000012E8
.text$mn:000012E8 var_1C          = dword ptr -1Ch
.text$mn:000012E8 var_18          = dword ptr -18h
.text$mn:000012E8 var_14          = tagRECT ptr -14h
.text$mn:000012E8 var_4           = dword ptr -4
.text$mn:000012E8 arg_0           = dword ptr  8
.text$mn:000012E8
.text$mn:000012E8                 push    ebp
.text$mn:000012E9                 mov     ebp, esp
.text$mn:000012EB                 sub     esp, 1Ch
.text$mn:000012EE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000012F3                 xor     eax, ebp
.text$mn:000012F5                 mov     [ebp+var_4], eax
.text$mn:000012F8                 mov     [ebp+var_18], ecx
.text$mn:000012FB                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:00001300                 mov     ecx, eax        ; this
.text$mn:00001302                 call    ?getSVP@NppParameters@@QBEABUScintillaViewParams@@XZ ; NppParameters::getSVP(void)
.text$mn:00001307                 mov     eax, [eax+28h]
.text$mn:0000130A                 mov     [ebp+var_1C], eax
.text$mn:0000130D                 movzx   ecx, ds:?_hideTabBarStatus@DocTabView@@0_NA ; bool DocTabView::_hideTabBarStatus
.text$mn:00001314                 test    ecx, ecx
.text$mn:00001316                 jz      short loc_1357
.text$mn:00001318                 mov     edx, [ebp+arg_0]
.text$mn:0000131B                 mov     eax, [edx]
.text$mn:0000131D                 mov     [ebp+var_14.left], eax
.text$mn:00001320                 mov     ecx, [edx+4]
.text$mn:00001323                 mov     [ebp+var_14.top], ecx
.text$mn:00001326                 mov     eax, [edx+8]
.text$mn:00001329                 mov     [ebp+var_14.right], eax
.text$mn:0000132C                 mov     ecx, [edx+0Ch]
.text$mn:0000132F                 mov     [ebp+var_14.bottom], ecx
.text$mn:00001332                 lea     edx, [ebp+var_14]
.text$mn:00001335                 push    edx             ; struct tagRECT *
.text$mn:00001336                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001339                 call    ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z ; TabBar::reSizeTo(tagRECT &)
.text$mn:0000133E                 mov     eax, [ebp+arg_0]
.text$mn:00001341                 push    eax
.text$mn:00001342                 mov     ecx, [ebp+var_18]
.text$mn:00001345                 mov     edx, [ecx+7Ch]
.text$mn:00001348                 mov     eax, [ebp+var_18]
.text$mn:0000134B                 mov     edx, [edx]
.text$mn:0000134D                 mov     ecx, [eax+7Ch]
.text$mn:00001350                 mov     eax, [edx+10h]
.text$mn:00001353                 call    eax
.text$mn:00001355                 jmp     short loc_13BC
.text$mn:00001357 ; ---------------------------------------------------------------------------
.text$mn:00001357
.text$mn:00001357 loc_1357:                               ; CODE XREF: DocTabView::reSizeTo(tagRECT &)+2Ej
.text$mn:00001357                 mov     ecx, [ebp+arg_0]
.text$mn:0000135A                 push    ecx             ; struct tagRECT *
.text$mn:0000135B                 mov     ecx, [ebp+var_18] ; this
.text$mn:0000135E                 call    ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z ; TabBar::reSizeTo(tagRECT &)
.text$mn:00001363                 mov     edx, [ebp+arg_0]
.text$mn:00001366                 mov     eax, [edx]
.text$mn:00001368                 add     eax, [ebp+var_1C]
.text$mn:0000136B                 mov     ecx, [ebp+arg_0]
.text$mn:0000136E                 mov     [ecx], eax
.text$mn:00001370                 mov     edx, [ebp+var_1C]
.text$mn:00001373                 shl     edx, 1
.text$mn:00001375                 mov     eax, [ebp+arg_0]
.text$mn:00001378                 mov     ecx, [eax+8]
.text$mn:0000137B                 sub     ecx, edx
.text$mn:0000137D                 mov     edx, [ebp+arg_0]
.text$mn:00001380                 mov     [edx+8], ecx
.text$mn:00001383                 mov     eax, [ebp+arg_0]
.text$mn:00001386                 mov     ecx, [eax+4]
.text$mn:00001389                 add     ecx, [ebp+var_1C]
.text$mn:0000138C                 mov     edx, [ebp+arg_0]
.text$mn:0000138F                 mov     [edx+4], ecx
.text$mn:00001392                 mov     eax, [ebp+var_1C]
.text$mn:00001395                 shl     eax, 1
.text$mn:00001397                 mov     ecx, [ebp+arg_0]
.text$mn:0000139A                 mov     edx, [ecx+0Ch]
.text$mn:0000139D                 sub     edx, eax
.text$mn:0000139F                 mov     eax, [ebp+arg_0]
.text$mn:000013A2                 mov     [eax+0Ch], edx
.text$mn:000013A5                 mov     ecx, [ebp+arg_0]
.text$mn:000013A8                 push    ecx
.text$mn:000013A9                 mov     edx, [ebp+var_18]
.text$mn:000013AC                 mov     eax, [edx+7Ch]
.text$mn:000013AF                 mov     ecx, [ebp+var_18]
.text$mn:000013B2                 mov     edx, [eax]
.text$mn:000013B4                 mov     ecx, [ecx+7Ch]
.text$mn:000013B7                 mov     eax, [edx+10h]
.text$mn:000013BA                 call    eax
.text$mn:000013BC
.text$mn:000013BC loc_13BC:                               ; CODE XREF: DocTabView::reSizeTo(tagRECT &)+6Dj
.text$mn:000013BC                 mov     ecx, [ebp+var_4]
.text$mn:000013BF                 xor     ecx, ebp
.text$mn:000013C1                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000013C6                 mov     esp, ebp
.text$mn:000013C8                 pop     ebp
.text$mn:000013C9                 retn    4
.text$mn:000013C9 ?reSizeTo@DocTabView@@UAEXAAUtagRECT@@@Z endp
.text$mn:000013C9
.text$mn:000013C9 _text$mn        ends
.text$mn:000013C9
.text$mn:000013CC ; ===========================================================================
.text$mn:000013CC
.text$mn:000013CC ; Segment type: Pure code
.text$mn:000013CC ; Segment permissions: Read/Execute
.text$mn:000013CC _text$mn        segment para public 'CODE' use32
.text$mn:000013CC                 assume cs:_text$mn
.text$mn:000013CC                 ;org 13CCh
.text$mn:000013CC ; COMDAT (pick any)
.text$mn:000013CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000013CC
.text$mn:000013CC ; =============== S U B R O U T I N E =======================================
.text$mn:000013CC
.text$mn:000013CC ; Attributes: bp-based frame
.text$mn:000013CC
.text$mn:000013CC ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:000013CC                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:000013CC ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:000013CC                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:000013CC
.text$mn:000013CC var_4           = dword ptr -4
.text$mn:000013CC arg_0           = dword ptr  8
.text$mn:000013CC
.text$mn:000013CC                 push    ebp
.text$mn:000013CD                 mov     ebp, esp
.text$mn:000013CF                 push    ecx
.text$mn:000013D0                 mov     [ebp+var_4], 0
.text$mn:000013D7                 cmp     [ebp+arg_0], 0
.text$mn:000013DB                 jnz     short loc_13DF
.text$mn:000013DD                 jmp     short loc_13FF
.text$mn:000013DF ; ---------------------------------------------------------------------------
.text$mn:000013DF
.text$mn:000013DF loc_13DF:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:000013DF                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:000013E3                 ja      short loc_13FA
.text$mn:000013E5                 mov     eax, [ebp+arg_0]
.text$mn:000013E8                 push    eax             ; unsigned int
.text$mn:000013E9                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:000013EE                 add     esp, 4
.text$mn:000013F1                 mov     [ebp+var_4], eax
.text$mn:000013F4                 cmp     [ebp+var_4], 0
.text$mn:000013F8                 jnz     short loc_13FF
.text$mn:000013FA
.text$mn:000013FA loc_13FA:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:000013FA                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:000013FF
.text$mn:000013FF loc_13FF:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:000013FF                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:000013FF                 mov     eax, [ebp+var_4]
.text$mn:00001402                 mov     esp, ebp
.text$mn:00001404                 pop     ebp
.text$mn:00001405                 retn
.text$mn:00001405 ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001405
.text$mn:00001405 ; ---------------------------------------------------------------------------
.text$mn:00001406                 align 4
.text$mn:00001406 _text$mn        ends
.text$mn:00001406
.text$mn:00001408 ; ===========================================================================
.text$mn:00001408
.text$mn:00001408 ; Segment type: Pure code
.text$mn:00001408 ; Segment permissions: Read/Execute
.text$mn:00001408 _text$mn        segment para public 'CODE' use32
.text$mn:00001408                 assume cs:_text$mn
.text$mn:00001408                 ;org 1408h
.text$mn:00001408 ; COMDAT (pick any)
.text$mn:00001408                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001408
.text$mn:00001408 ; =============== S U B R O U T I N E =======================================
.text$mn:00001408
.text$mn:00001408 ; Attributes: bp-based frame
.text$mn:00001408
.text$mn:00001408 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001408                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001408 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001408                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001408
.text$mn:00001408 var_4           = dword ptr -4
.text$mn:00001408 arg_0           = dword ptr  8
.text$mn:00001408
.text$mn:00001408                 push    ebp
.text$mn:00001409                 mov     ebp, esp
.text$mn:0000140B                 push    ecx
.text$mn:0000140C                 mov     [ebp+var_4], 0
.text$mn:00001413                 cmp     [ebp+arg_0], 0
.text$mn:00001417                 jnz     short loc_141B
.text$mn:00001419                 jmp     short loc_1441
.text$mn:0000141B ; ---------------------------------------------------------------------------
.text$mn:0000141B
.text$mn:0000141B loc_141B:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:0000141B                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00001422                 ja      short loc_143C
.text$mn:00001424                 mov     eax, [ebp+arg_0]
.text$mn:00001427                 shl     eax, 3
.text$mn:0000142A                 push    eax             ; unsigned int
.text$mn:0000142B                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001430                 add     esp, 4
.text$mn:00001433                 mov     [ebp+var_4], eax
.text$mn:00001436                 cmp     [ebp+var_4], 0
.text$mn:0000143A                 jnz     short loc_1441
.text$mn:0000143C
.text$mn:0000143C loc_143C:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:0000143C                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001441
.text$mn:00001441 loc_1441:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001441                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001441                 mov     eax, [ebp+var_4]
.text$mn:00001444                 mov     esp, ebp
.text$mn:00001446                 pop     ebp
.text$mn:00001447                 retn
.text$mn:00001447 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00001447
.text$mn:00001447 _text$mn        ends
.text$mn:00001447
.text$mn:00001448 ; ===========================================================================
.text$mn:00001448
.text$mn:00001448 ; Segment type: Pure code
.text$mn:00001448 ; Segment permissions: Read/Execute
.text$mn:00001448 _text$mn        segment para public 'CODE' use32
.text$mn:00001448                 assume cs:_text$mn
.text$mn:00001448                 ;org 1448h
.text$mn:00001448 ; COMDAT (pick any)
.text$mn:00001448                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001448
.text$mn:00001448 ; =============== S U B R O U T I N E =======================================
.text$mn:00001448
.text$mn:00001448 ; Attributes: bp-based frame
.text$mn:00001448
.text$mn:00001448 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00001448                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00001448 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00001448                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00001448                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00001448
.text$mn:00001448 arg_0           = dword ptr  8
.text$mn:00001448 arg_4           = dword ptr  0Ch
.text$mn:00001448 arg_8           = dword ptr  10h
.text$mn:00001448
.text$mn:00001448                 push    ebp
.text$mn:00001449                 mov     ebp, esp
.text$mn:0000144B                 cmp     [ebp+arg_0], 0
.text$mn:0000144F                 jnz     short loc_1466
.text$mn:00001451                 mov     eax, [ebp+arg_8]
.text$mn:00001454                 push    eax             ; unsigned int
.text$mn:00001455                 mov     ecx, [ebp+arg_4]
.text$mn:00001458                 push    ecx             ; wchar_t *
.text$mn:00001459                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:0000145E                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001463                 add     esp, 0Ch
.text$mn:00001466
.text$mn:00001466 loc_1466:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00001466                 pop     ebp
.text$mn:00001467                 retn
.text$mn:00001467 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00001467
.text$mn:00001467 _text$mn        ends
.text$mn:00001467
.text$mn:00001468 ; ===========================================================================
.text$mn:00001468
.text$mn:00001468 ; Segment type: Pure code
.text$mn:00001468 ; Segment permissions: Read/Execute
.text$mn:00001468 _text$mn        segment para public 'CODE' use32
.text$mn:00001468                 assume cs:_text$mn
.text$mn:00001468                 ;org 1468h
.text$mn:00001468 ; COMDAT (pick any)
.text$mn:00001468                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001468
.text$mn:00001468 ; =============== S U B R O U T I N E =======================================
.text$mn:00001468
.text$mn:00001468 ; Attributes: bp-based frame
.text$mn:00001468
.text$mn:00001468 ; char * __cdecl std::addressof<char>(char &)
.text$mn:00001468                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:00001468 ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:00001468                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:00001468                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:00001468
.text$mn:00001468 arg_0           = dword ptr  8
.text$mn:00001468
.text$mn:00001468                 push    ebp
.text$mn:00001469                 mov     ebp, esp
.text$mn:0000146B                 mov     eax, [ebp+arg_0]
.text$mn:0000146E                 pop     ebp
.text$mn:0000146F                 retn
.text$mn:0000146F ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:0000146F
.text$mn:0000146F _text$mn        ends
.text$mn:0000146F
.text$mn:00001470 ; ===========================================================================
.text$mn:00001470
.text$mn:00001470 ; Segment type: Pure code
.text$mn:00001470 ; Segment permissions: Read/Execute
.text$mn:00001470 _text$mn        segment para public 'CODE' use32
.text$mn:00001470                 assume cs:_text$mn
.text$mn:00001470                 ;org 1470h
.text$mn:00001470 ; COMDAT (pick any)
.text$mn:00001470                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001470
.text$mn:00001470 ; =============== S U B R O U T I N E =======================================
.text$mn:00001470
.text$mn:00001470 ; Attributes: bp-based frame
.text$mn:00001470
.text$mn:00001470 ; wchar_t * __cdecl std::addressof<wchar_t>(wchar_t &)
.text$mn:00001470                 public ??$addressof@_W@std@@YAPA_WAA_W@Z
.text$mn:00001470 ??$addressof@_W@std@@YAPA_WAA_W@Z proc near
.text$mn:00001470                                         ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+19p
.text$mn:00001470
.text$mn:00001470 arg_0           = dword ptr  8
.text$mn:00001470
.text$mn:00001470                 push    ebp
.text$mn:00001471                 mov     ebp, esp
.text$mn:00001473                 mov     eax, [ebp+arg_0]
.text$mn:00001476                 pop     ebp
.text$mn:00001477                 retn
.text$mn:00001477 ??$addressof@_W@std@@YAPA_WAA_W@Z endp
.text$mn:00001477
.text$mn:00001477 _text$mn        ends
.text$mn:00001477
.text$mn:00001478 ; ===========================================================================
.text$mn:00001478
.text$mn:00001478 ; Segment type: Pure code
.text$mn:00001478 ; Segment permissions: Read/Execute
.text$mn:00001478 _text$mn        segment para public 'CODE' use32
.text$mn:00001478                 assume cs:_text$mn
.text$mn:00001478                 ;org 1478h
.text$mn:00001478 ; COMDAT (pick any)
.text$mn:00001478                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001478
.text$mn:00001478 ; =============== S U B R O U T I N E =======================================
.text$mn:00001478
.text$mn:00001478 ; Attributes: bp-based frame
.text$mn:00001478
.text$mn:00001478 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00001478                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00001478 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00001478                                         ; CODE XREF: $LN19+4Bp
.text$mn:00001478
.text$mn:00001478 var_4           = dword ptr -4
.text$mn:00001478 arg_0           = dword ptr  8
.text$mn:00001478 arg_4           = dword ptr  0Ch
.text$mn:00001478
.text$mn:00001478                 push    ebp
.text$mn:00001479                 mov     ebp, esp
.text$mn:0000147B                 push    ecx
.text$mn:0000147C                 mov     [ebp+var_4], ecx
.text$mn:0000147F                 mov     eax, [ebp+arg_4]
.text$mn:00001482                 push    eax
.text$mn:00001483                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001488                 add     esp, 4
.text$mn:0000148B                 push    eax             ; int
.text$mn:0000148C                 mov     ecx, [ebp+arg_0]
.text$mn:0000148F                 push    ecx             ; void *
.text$mn:00001490                 mov     edx, [ebp+var_4]
.text$mn:00001493                 push    edx             ; int
.text$mn:00001494                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00001499                 add     esp, 0Ch
.text$mn:0000149C                 mov     esp, ebp
.text$mn:0000149E                 pop     ebp
.text$mn:0000149F                 retn    8
.text$mn:0000149F ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000149F
.text$mn:0000149F ; ---------------------------------------------------------------------------
.text$mn:000014A2                 align 4
.text$mn:000014A2 _text$mn        ends
.text$mn:000014A2
.text$mn:000014A4 ; ===========================================================================
.text$mn:000014A4
.text$mn:000014A4 ; Segment type: Pure code
.text$mn:000014A4 ; Segment permissions: Read/Execute
.text$mn:000014A4 _text$mn        segment para public 'CODE' use32
.text$mn:000014A4                 assume cs:_text$mn
.text$mn:000014A4                 ;org 14A4h
.text$mn:000014A4 ; COMDAT (pick any)
.text$mn:000014A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000014A4
.text$mn:000014A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014A4
.text$mn:000014A4 ; Attributes: bp-based frame
.text$mn:000014A4
.text$mn:000014A4 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:000014A4                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000014A4 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:000014A4                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:000014A4
.text$mn:000014A4 var_1C          = dword ptr -1Ch
.text$mn:000014A4 var_18          = dword ptr -18h
.text$mn:000014A4 var_14          = dword ptr -14h
.text$mn:000014A4 var_10          = dword ptr -10h
.text$mn:000014A4 var_C           = dword ptr -0Ch
.text$mn:000014A4 var_4           = dword ptr -4
.text$mn:000014A4 arg_0           = dword ptr  8
.text$mn:000014A4 arg_4           = dword ptr  0Ch
.text$mn:000014A4
.text$mn:000014A4                 push    ebp
.text$mn:000014A5                 mov     ebp, esp
.text$mn:000014A7                 push    0FFFFFFFFh
.text$mn:000014A9                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:000014AE                 mov     eax, large fs:0
.text$mn:000014B4                 push    eax
.text$mn:000014B5                 sub     esp, 10h
.text$mn:000014B8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014BD                 xor     eax, ebp
.text$mn:000014BF                 push    eax
.text$mn:000014C0                 lea     eax, [ebp+var_C]
.text$mn:000014C3                 mov     large fs:0, eax
.text$mn:000014C9                 mov     [ebp+var_18], ecx
.text$mn:000014CC                 mov     eax, [ebp+arg_0]
.text$mn:000014CF                 push    eax             ; void *
.text$mn:000014D0                 push    4               ; unsigned int
.text$mn:000014D2                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000014D7                 add     esp, 8
.text$mn:000014DA                 mov     [ebp+var_10], eax
.text$mn:000014DD                 mov     [ebp+var_4], 0
.text$mn:000014E4                 cmp     [ebp+var_10], 0
.text$mn:000014E8                 jz      short loc_1505
.text$mn:000014EA                 mov     ecx, [ebp+arg_4]
.text$mn:000014ED                 push    ecx
.text$mn:000014EE                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000014F3                 add     esp, 4
.text$mn:000014F6                 mov     edx, [ebp+var_10]
.text$mn:000014F9                 mov     eax, [eax]
.text$mn:000014FB                 mov     [edx], eax
.text$mn:000014FD                 mov     ecx, [ebp+var_10]
.text$mn:00001500                 mov     [ebp+var_14], ecx
.text$mn:00001503                 jmp     short loc_150C
.text$mn:00001505 ; ---------------------------------------------------------------------------
.text$mn:00001505
.text$mn:00001505 loc_1505:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00001505                 mov     [ebp+var_14], 0
.text$mn:0000150C
.text$mn:0000150C loc_150C:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:0000150C                 mov     edx, [ebp+var_14]
.text$mn:0000150F                 mov     [ebp+var_1C], edx
.text$mn:00001512                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001519                 mov     ecx, [ebp+var_C]
.text$mn:0000151C                 mov     large fs:0, ecx
.text$mn:00001523                 pop     ecx
.text$mn:00001524                 mov     esp, ebp
.text$mn:00001526                 pop     ebp
.text$mn:00001527                 retn    8
.text$mn:00001527 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:00001527
.text$mn:00001527 ; ---------------------------------------------------------------------------
.text$mn:0000152A                 align 4
.text$mn:0000152A _text$mn        ends
.text$mn:0000152A
.text$x:0000152C ; ===========================================================================
.text$x:0000152C
.text$x:0000152C ; Segment type: Pure code
.text$x:0000152C ; Segment permissions: Read/Execute
.text$x:0000152C _text$x         segment para public 'CODE' use32
.text$x:0000152C                 assume cs:_text$x
.text$x:0000152C                 ;org 152Ch
.text$x:0000152C ; COMDAT (pick associative to section at 14A4)
.text$x:0000152C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:0000152C
.text$x:0000152C ; =============== S U B R O U T I N E =======================================
.text$x:0000152C
.text$x:0000152C
.text$x:0000152C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:0000152C                                         ; DATA XREF: .xdata$x:000031D4o
.text$x:0000152C                 mov     eax, [ebp+8]
.text$x:0000152F                 push    eax
.text$x:00001530                 mov     eax, [ebp-10h]
.text$x:00001533                 push    eax             ; void *
.text$x:00001534                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001539                 add     esp, 8
.text$x:0000153C                 retn
.text$x:0000153C __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:0000153C
.text$x:0000153D
.text$x:0000153D ; =============== S U B R O U T I N E =======================================
.text$x:0000153D
.text$x:0000153D
.text$x:0000153D __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:0000153D                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:0000153D
.text$x:0000153D arg_4           = dword ptr  8
.text$x:0000153D
.text$x:0000153D                 mov     edx, [esp+arg_4]
.text$x:00001541                 lea     eax, [edx+0Ch]
.text$x:00001544                 mov     ecx, [edx-14h]
.text$x:00001547                 xor     ecx, eax
.text$x:00001549                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000154E                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:00001553                 jmp     ___CxxFrameHandler3
.text$x:00001553 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:00001553
.text$x:00001553 _text$x         ends
.text$x:00001553
.text$mn:00001558 ; ===========================================================================
.text$mn:00001558
.text$mn:00001558 ; Segment type: Pure code
.text$mn:00001558 ; Segment permissions: Read/Execute
.text$mn:00001558 _text$mn        segment para public 'CODE' use32
.text$mn:00001558                 assume cs:_text$mn
.text$mn:00001558                 ;org 1558h
.text$mn:00001558 ; COMDAT (pick any)
.text$mn:00001558                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001558
.text$mn:00001558 ; =============== S U B R O U T I N E =======================================
.text$mn:00001558
.text$mn:00001558 ; Attributes: bp-based frame
.text$mn:00001558
.text$mn:00001558 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:00001558                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:00001558 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:00001558                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:00001558
.text$mn:00001558 arg_0           = dword ptr  8
.text$mn:00001558 arg_4           = dword ptr  0Ch
.text$mn:00001558 arg_8           = dword ptr  10h
.text$mn:00001558
.text$mn:00001558                 push    ebp
.text$mn:00001559                 mov     ebp, esp
.text$mn:0000155B                 mov     eax, [ebp+arg_8]
.text$mn:0000155E                 push    eax
.text$mn:0000155F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00001564                 add     esp, 4
.text$mn:00001567                 push    eax             ; int
.text$mn:00001568                 mov     ecx, [ebp+arg_4]
.text$mn:0000156B                 push    ecx             ; void *
.text$mn:0000156C                 mov     ecx, [ebp+arg_0]
.text$mn:0000156F                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00001574                 pop     ebp
.text$mn:00001575                 retn
.text$mn:00001575 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00001575
.text$mn:00001575 ; ---------------------------------------------------------------------------
.text$mn:00001576                 align 4
.text$mn:00001576 _text$mn        ends
.text$mn:00001576
.text$mn:00001578 ; ===========================================================================
.text$mn:00001578
.text$mn:00001578 ; Segment type: Pure code
.text$mn:00001578 ; Segment permissions: Read/Execute
.text$mn:00001578 _text$mn        segment para public 'CODE' use32
.text$mn:00001578                 assume cs:_text$mn
.text$mn:00001578                 ;org 1578h
.text$mn:00001578 ; COMDAT (pick any)
.text$mn:00001578                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001578
.text$mn:00001578 ; =============== S U B R O U T I N E =======================================
.text$mn:00001578
.text$mn:00001578 ; Attributes: bp-based frame
.text$mn:00001578
.text$mn:00001578 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00001578                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001578 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00001578                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00001578
.text$mn:00001578 var_1C          = dword ptr -1Ch
.text$mn:00001578 var_18          = dword ptr -18h
.text$mn:00001578 var_14          = dword ptr -14h
.text$mn:00001578 var_10          = dword ptr -10h
.text$mn:00001578 var_C           = dword ptr -0Ch
.text$mn:00001578 var_4           = dword ptr -4
.text$mn:00001578 arg_0           = dword ptr  8
.text$mn:00001578 arg_4           = dword ptr  0Ch
.text$mn:00001578
.text$mn:00001578                 push    ebp
.text$mn:00001579                 mov     ebp, esp
.text$mn:0000157B                 push    0FFFFFFFFh
.text$mn:0000157D                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00001582                 mov     eax, large fs:0
.text$mn:00001588                 push    eax
.text$mn:00001589                 sub     esp, 10h
.text$mn:0000158C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001591                 xor     eax, ebp
.text$mn:00001593                 push    eax
.text$mn:00001594                 lea     eax, [ebp+var_C]
.text$mn:00001597                 mov     large fs:0, eax
.text$mn:0000159D                 mov     [ebp+var_18], ecx
.text$mn:000015A0                 mov     eax, [ebp+arg_0]
.text$mn:000015A3                 push    eax             ; void *
.text$mn:000015A4                 push    8               ; unsigned int
.text$mn:000015A6                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:000015AB                 add     esp, 8
.text$mn:000015AE                 mov     [ebp+var_10], eax
.text$mn:000015B1                 mov     [ebp+var_4], 0
.text$mn:000015B8                 cmp     [ebp+var_10], 0
.text$mn:000015BC                 jz      short loc_15DF
.text$mn:000015BE                 mov     ecx, [ebp+arg_4]
.text$mn:000015C1                 push    ecx
.text$mn:000015C2                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000015C7                 add     esp, 4
.text$mn:000015CA                 mov     edx, [eax]
.text$mn:000015CC                 mov     eax, [eax+4]
.text$mn:000015CF                 mov     ecx, [ebp+var_10]
.text$mn:000015D2                 mov     [ecx], edx
.text$mn:000015D4                 mov     [ecx+4], eax
.text$mn:000015D7                 mov     edx, [ebp+var_10]
.text$mn:000015DA                 mov     [ebp+var_14], edx
.text$mn:000015DD                 jmp     short loc_15E6
.text$mn:000015DF ; ---------------------------------------------------------------------------
.text$mn:000015DF
.text$mn:000015DF loc_15DF:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:000015DF                 mov     [ebp+var_14], 0
.text$mn:000015E6
.text$mn:000015E6 loc_15E6:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:000015E6                 mov     eax, [ebp+var_14]
.text$mn:000015E9                 mov     [ebp+var_1C], eax
.text$mn:000015EC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000015F3                 mov     ecx, [ebp+var_C]
.text$mn:000015F6                 mov     large fs:0, ecx
.text$mn:000015FD                 pop     ecx
.text$mn:000015FE                 mov     esp, ebp
.text$mn:00001600                 pop     ebp
.text$mn:00001601                 retn    8
.text$mn:00001601 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:00001601
.text$mn:00001601 _text$mn        ends
.text$mn:00001601
.text$x:00001604 ; ===========================================================================
.text$x:00001604
.text$x:00001604 ; Segment type: Pure code
.text$x:00001604 ; Segment permissions: Read/Execute
.text$x:00001604 _text$x         segment para public 'CODE' use32
.text$x:00001604                 assume cs:_text$x
.text$x:00001604                 ;org 1604h
.text$x:00001604 ; COMDAT (pick associative to section at 1578)
.text$x:00001604                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001604
.text$x:00001604 ; =============== S U B R O U T I N E =======================================
.text$x:00001604
.text$x:00001604
.text$x:00001604 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:00001604                                         ; DATA XREF: .xdata$x:000031A8o
.text$x:00001604                 mov     eax, [ebp+8]
.text$x:00001607                 push    eax
.text$x:00001608                 mov     eax, [ebp-10h]
.text$x:0000160B                 push    eax             ; void *
.text$x:0000160C                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:00001611                 add     esp, 8
.text$x:00001614                 retn
.text$x:00001614 __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:00001614
.text$x:00001615
.text$x:00001615 ; =============== S U B R O U T I N E =======================================
.text$x:00001615
.text$x:00001615
.text$x:00001615 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:00001615                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:00001615
.text$x:00001615 arg_4           = dword ptr  8
.text$x:00001615
.text$x:00001615                 mov     edx, [esp+arg_4]
.text$x:00001619                 lea     eax, [edx+0Ch]
.text$x:0000161C                 mov     ecx, [edx-14h]
.text$x:0000161F                 xor     ecx, eax
.text$x:00001621                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001626                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:0000162B                 jmp     ___CxxFrameHandler3
.text$x:0000162B __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:0000162B
.text$x:0000162B _text$x         ends
.text$x:0000162B
.text$mn:00001630 ; ===========================================================================
.text$mn:00001630
.text$mn:00001630 ; Segment type: Pure code
.text$mn:00001630 ; Segment permissions: Read/Execute
.text$mn:00001630 _text$mn        segment para public 'CODE' use32
.text$mn:00001630                 assume cs:_text$mn
.text$mn:00001630                 ;org 1630h
.text$mn:00001630 ; COMDAT (pick any)
.text$mn:00001630                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001630
.text$mn:00001630 ; =============== S U B R O U T I N E =======================================
.text$mn:00001630
.text$mn:00001630 ; Attributes: bp-based frame
.text$mn:00001630
.text$mn:00001630 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00001630                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00001630 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00001630                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00001630
.text$mn:00001630 var_4           = dword ptr -4
.text$mn:00001630 arg_0           = dword ptr  8
.text$mn:00001630
.text$mn:00001630                 push    ebp
.text$mn:00001631                 mov     ebp, esp
.text$mn:00001633                 push    ecx
.text$mn:00001634                 mov     [ebp+var_4], ecx
.text$mn:00001637                 mov     eax, [ebp+arg_0]
.text$mn:0000163A                 push    eax
.text$mn:0000163B                 mov     ecx, [ebp+var_4]
.text$mn:0000163E                 push    ecx
.text$mn:0000163F                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:00001644                 add     esp, 8
.text$mn:00001647                 mov     esp, ebp
.text$mn:00001649                 pop     ebp
.text$mn:0000164A                 retn    4
.text$mn:0000164A ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:0000164A
.text$mn:0000164A ; ---------------------------------------------------------------------------
.text$mn:0000164D                 align 10h
.text$mn:0000164D _text$mn        ends
.text$mn:0000164D
.text$mn:00001650 ; ===========================================================================
.text$mn:00001650
.text$mn:00001650 ; Segment type: Pure code
.text$mn:00001650 ; Segment permissions: Read/Execute
.text$mn:00001650 _text$mn        segment para public 'CODE' use32
.text$mn:00001650                 assume cs:_text$mn
.text$mn:00001650                 ;org 1650h
.text$mn:00001650 ; COMDAT (pick any)
.text$mn:00001650                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001650
.text$mn:00001650 ; =============== S U B R O U T I N E =======================================
.text$mn:00001650
.text$mn:00001650 ; Attributes: bp-based frame
.text$mn:00001650
.text$mn:00001650 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00001650                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00001650 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00001650                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00001650
.text$mn:00001650 var_4           = dword ptr -4
.text$mn:00001650
.text$mn:00001650                 push    ebp
.text$mn:00001651                 mov     ebp, esp
.text$mn:00001653                 push    ecx
.text$mn:00001654                 mov     [ebp+var_4], ecx
.text$mn:00001657                 mov     esp, ebp
.text$mn:00001659                 pop     ebp
.text$mn:0000165A                 retn    4
.text$mn:0000165A ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:0000165A
.text$mn:0000165A ; ---------------------------------------------------------------------------
.text$mn:0000165D                 align 10h
.text$mn:0000165D _text$mn        ends
.text$mn:0000165D
.text$mn:00001660 ; ===========================================================================
.text$mn:00001660
.text$mn:00001660 ; Segment type: Pure code
.text$mn:00001660 ; Segment permissions: Read/Execute
.text$mn:00001660 _text$mn        segment para public 'CODE' use32
.text$mn:00001660                 assume cs:_text$mn
.text$mn:00001660                 ;org 1660h
.text$mn:00001660 ; COMDAT (pick any)
.text$mn:00001660                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001660
.text$mn:00001660 ; =============== S U B R O U T I N E =======================================
.text$mn:00001660
.text$mn:00001660 ; Attributes: bp-based frame
.text$mn:00001660
.text$mn:00001660 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00001660                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00001660 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00001660                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00001660
.text$mn:00001660 arg_0           = dword ptr  8
.text$mn:00001660 arg_4           = dword ptr  0Ch
.text$mn:00001660
.text$mn:00001660                 push    ebp
.text$mn:00001661                 mov     ebp, esp
.text$mn:00001663                 mov     eax, [ebp+arg_4]
.text$mn:00001666                 push    eax
.text$mn:00001667                 mov     ecx, [ebp+arg_0]
.text$mn:0000166A                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:0000166F                 pop     ebp
.text$mn:00001670                 retn
.text$mn:00001670 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00001670
.text$mn:00001670 ; ---------------------------------------------------------------------------
.text$mn:00001671                 align 4
.text$mn:00001671 _text$mn        ends
.text$mn:00001671
.text$mn:00001674 ; ===========================================================================
.text$mn:00001674
.text$mn:00001674 ; Segment type: Pure code
.text$mn:00001674 ; Segment permissions: Read/Execute
.text$mn:00001674 _text$mn        segment para public 'CODE' use32
.text$mn:00001674                 assume cs:_text$mn
.text$mn:00001674                 ;org 1674h
.text$mn:00001674 ; COMDAT (pick any)
.text$mn:00001674                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001674
.text$mn:00001674 ; =============== S U B R O U T I N E =======================================
.text$mn:00001674
.text$mn:00001674 ; Attributes: bp-based frame
.text$mn:00001674
.text$mn:00001674 ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:00001674                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:00001674 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:00001674                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:00001674
.text$mn:00001674 var_4           = dword ptr -4
.text$mn:00001674
.text$mn:00001674                 push    ebp
.text$mn:00001675                 mov     ebp, esp
.text$mn:00001677                 push    ecx
.text$mn:00001678                 mov     [ebp+var_4], ecx
.text$mn:0000167B                 mov     esp, ebp
.text$mn:0000167D                 pop     ebp
.text$mn:0000167E                 retn    4
.text$mn:0000167E ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:0000167E
.text$mn:0000167E ; ---------------------------------------------------------------------------
.text$mn:00001681                 align 4
.text$mn:00001681 _text$mn        ends
.text$mn:00001681
.text$mn:00001684 ; ===========================================================================
.text$mn:00001684
.text$mn:00001684 ; Segment type: Pure code
.text$mn:00001684 ; Segment permissions: Read/Execute
.text$mn:00001684 _text$mn        segment para public 'CODE' use32
.text$mn:00001684                 assume cs:_text$mn
.text$mn:00001684                 ;org 1684h
.text$mn:00001684 ; COMDAT (pick any)
.text$mn:00001684                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001684
.text$mn:00001684 ; =============== S U B R O U T I N E =======================================
.text$mn:00001684
.text$mn:00001684 ; Attributes: bp-based frame
.text$mn:00001684
.text$mn:00001684 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00001684                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00001684 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00001684                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00001684                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00001684
.text$mn:00001684 arg_0           = dword ptr  8
.text$mn:00001684
.text$mn:00001684                 push    ebp
.text$mn:00001685                 mov     ebp, esp
.text$mn:00001687                 mov     eax, [ebp+arg_0]
.text$mn:0000168A                 pop     ebp
.text$mn:0000168B                 retn
.text$mn:0000168B ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:0000168B
.text$mn:0000168B _text$mn        ends
.text$mn:0000168B
.text$mn:0000168C ; ===========================================================================
.text$mn:0000168C
.text$mn:0000168C ; Segment type: Pure code
.text$mn:0000168C ; Segment permissions: Read/Execute
.text$mn:0000168C _text$mn        segment para public 'CODE' use32
.text$mn:0000168C                 assume cs:_text$mn
.text$mn:0000168C                 ;org 168Ch
.text$mn:0000168C ; COMDAT (pick any)
.text$mn:0000168C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000168C
.text$mn:0000168C ; =============== S U B R O U T I N E =======================================
.text$mn:0000168C
.text$mn:0000168C ; Attributes: bp-based frame
.text$mn:0000168C
.text$mn:0000168C ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:0000168C                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:0000168C ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:0000168C                                         ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap
.text$mn:0000168C
.text$mn:0000168C arg_0           = dword ptr  8
.text$mn:0000168C
.text$mn:0000168C                 push    ebp
.text$mn:0000168D                 mov     ebp, esp
.text$mn:0000168F                 mov     eax, [ebp+arg_0]
.text$mn:00001692                 pop     ebp
.text$mn:00001693                 retn
.text$mn:00001693 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:00001693
.text$mn:00001693 _text$mn        ends
.text$mn:00001693
.text$mn:00001694 ; ===========================================================================
.text$mn:00001694
.text$mn:00001694 ; Segment type: Pure code
.text$mn:00001694 ; Segment permissions: Read/Execute
.text$mn:00001694 _text$mn        segment para public 'CODE' use32
.text$mn:00001694                 assume cs:_text$mn
.text$mn:00001694                 ;org 1694h
.text$mn:00001694 ; COMDAT (pick any)
.text$mn:00001694                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001694
.text$mn:00001694 ; =============== S U B R O U T I N E =======================================
.text$mn:00001694
.text$mn:00001694 ; Attributes: bp-based frame
.text$mn:00001694
.text$mn:00001694 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:00001694                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00001694 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:00001694                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:00001694
.text$mn:00001694 var_10          = dword ptr -10h
.text$mn:00001694 var_C           = dword ptr -0Ch
.text$mn:00001694 var_4           = dword ptr -4
.text$mn:00001694
.text$mn:00001694                 push    ebp
.text$mn:00001695                 mov     ebp, esp
.text$mn:00001697                 push    0FFFFFFFFh
.text$mn:00001699                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000169E                 mov     eax, large fs:0
.text$mn:000016A4                 push    eax
.text$mn:000016A5                 push    ecx
.text$mn:000016A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016AB                 xor     eax, ebp
.text$mn:000016AD                 push    eax
.text$mn:000016AE                 lea     eax, [ebp+var_C]
.text$mn:000016B1                 mov     large fs:0, eax
.text$mn:000016B7                 mov     [ebp+var_10], ecx
.text$mn:000016BA                 mov     ecx, [ebp+var_10]
.text$mn:000016BD                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000016C2                 mov     [ebp+var_4], 0
.text$mn:000016C9                 mov     ecx, [ebp+var_10]
.text$mn:000016CC                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000016D1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000016D8                 mov     eax, [ebp+var_10]
.text$mn:000016DB                 mov     ecx, [ebp+var_C]
.text$mn:000016DE                 mov     large fs:0, ecx
.text$mn:000016E5                 pop     ecx
.text$mn:000016E6                 mov     esp, ebp
.text$mn:000016E8                 pop     ebp
.text$mn:000016E9                 retn    4
.text$mn:000016E9 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000016E9
.text$mn:000016E9 _text$mn        ends
.text$mn:000016E9
.text$x:000016EC ; ===========================================================================
.text$x:000016EC
.text$x:000016EC ; Segment type: Pure code
.text$x:000016EC ; Segment permissions: Read/Execute
.text$x:000016EC _text$x         segment para public 'CODE' use32
.text$x:000016EC                 assume cs:_text$x
.text$x:000016EC                 ;org 16ECh
.text$x:000016EC ; COMDAT (pick associative to section at 1694)
.text$x:000016EC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000016EC
.text$x:000016EC ; =============== S U B R O U T I N E =======================================
.text$x:000016EC
.text$x:000016EC
.text$x:000016EC __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000016EC                                         ; DATA XREF: .xdata$x:00002EE0o
.text$x:000016EC                 mov     ecx, [ebp-10h]
.text$x:000016EF                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000016EF __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000016EF
.text$x:000016F4
.text$x:000016F4 ; =============== S U B R O U T I N E =======================================
.text$x:000016F4
.text$x:000016F4
.text$x:000016F4 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000016F4                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000016F4
.text$x:000016F4 arg_4           = dword ptr  8
.text$x:000016F4
.text$x:000016F4                 mov     edx, [esp+arg_4]
.text$x:000016F8                 lea     eax, [edx+0Ch]
.text$x:000016FB                 mov     ecx, [edx-8]
.text$x:000016FE                 xor     ecx, eax
.text$x:00001700                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001705                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:0000170A                 jmp     ___CxxFrameHandler3
.text$x:0000170A __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:0000170A
.text$x:0000170A ; ---------------------------------------------------------------------------
.text$x:0000170F                 align 10h
.text$x:0000170F _text$x         ends
.text$x:0000170F
.text$mn:00001710 ; ===========================================================================
.text$mn:00001710
.text$mn:00001710 ; Segment type: Pure code
.text$mn:00001710 ; Segment permissions: Read/Execute
.text$mn:00001710 _text$mn        segment para public 'CODE' use32
.text$mn:00001710                 assume cs:_text$mn
.text$mn:00001710                 ;org 1710h
.text$mn:00001710 ; COMDAT (pick any)
.text$mn:00001710                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001710
.text$mn:00001710 ; =============== S U B R O U T I N E =======================================
.text$mn:00001710
.text$mn:00001710 ; Attributes: bp-based frame
.text$mn:00001710
.text$mn:00001710 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001710                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001710 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001710                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00001710
.text$mn:00001710 var_10          = dword ptr -10h
.text$mn:00001710 var_C           = dword ptr -0Ch
.text$mn:00001710 var_4           = dword ptr -4
.text$mn:00001710
.text$mn:00001710                 push    ebp
.text$mn:00001711                 mov     ebp, esp
.text$mn:00001713                 push    0FFFFFFFFh
.text$mn:00001715                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000171A                 mov     eax, large fs:0
.text$mn:00001720                 push    eax
.text$mn:00001721                 push    ecx
.text$mn:00001722                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001727                 xor     eax, ebp
.text$mn:00001729                 push    eax
.text$mn:0000172A                 lea     eax, [ebp+var_C]
.text$mn:0000172D                 mov     large fs:0, eax
.text$mn:00001733                 mov     [ebp+var_10], ecx
.text$mn:00001736                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001739                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:0000173E                 mov     [ebp+var_4], 0
.text$mn:00001745                 mov     eax, [ebp+var_10]
.text$mn:00001748                 mov     dword ptr [eax+14h], 0
.text$mn:0000174F                 mov     ecx, [ebp+var_10]
.text$mn:00001752                 mov     dword ptr [ecx+18h], 0
.text$mn:00001759                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001760                 mov     eax, [ebp+var_10]
.text$mn:00001763                 mov     ecx, [ebp+var_C]
.text$mn:00001766                 mov     large fs:0, ecx
.text$mn:0000176D                 pop     ecx
.text$mn:0000176E                 mov     esp, ebp
.text$mn:00001770                 pop     ebp
.text$mn:00001771                 retn
.text$mn:00001771 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001771
.text$mn:00001771 ; ---------------------------------------------------------------------------
.text$mn:00001772                 align 4
.text$mn:00001772 _text$mn        ends
.text$mn:00001772
.text$x:00001774 ; ===========================================================================
.text$x:00001774
.text$x:00001774 ; Segment type: Pure code
.text$x:00001774 ; Segment permissions: Read/Execute
.text$x:00001774 _text$x         segment para public 'CODE' use32
.text$x:00001774                 assume cs:_text$x
.text$x:00001774                 ;org 1774h
.text$x:00001774 ; COMDAT (pick associative to section at 1710)
.text$x:00001774                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001774
.text$x:00001774 ; =============== S U B R O U T I N E =======================================
.text$x:00001774
.text$x:00001774
.text$x:00001774 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001774                                         ; DATA XREF: .xdata$x:00002E88o
.text$x:00001774                 mov     ecx, [ebp-10h]  ; this
.text$x:00001777                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001777 __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001777
.text$x:0000177C
.text$x:0000177C ; =============== S U B R O U T I N E =======================================
.text$x:0000177C
.text$x:0000177C
.text$x:0000177C __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:0000177C                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:0000177C
.text$x:0000177C arg_4           = dword ptr  8
.text$x:0000177C
.text$x:0000177C                 mov     edx, [esp+arg_4]
.text$x:00001780                 lea     eax, [edx+0Ch]
.text$x:00001783                 mov     ecx, [edx-8]
.text$x:00001786                 xor     ecx, eax
.text$x:00001788                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000178D                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001792                 jmp     ___CxxFrameHandler3
.text$x:00001792 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001792
.text$x:00001792 ; ---------------------------------------------------------------------------
.text$x:00001797                 align 4
.text$x:00001797 _text$x         ends
.text$x:00001797
.text$mn:00001798 ; ===========================================================================
.text$mn:00001798
.text$mn:00001798 ; Segment type: Pure code
.text$mn:00001798 ; Segment permissions: Read/Execute
.text$mn:00001798 _text$mn        segment para public 'CODE' use32
.text$mn:00001798                 assume cs:_text$mn
.text$mn:00001798                 ;org 1798h
.text$mn:00001798 ; COMDAT (pick any)
.text$mn:00001798                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001798
.text$mn:00001798 ; =============== S U B R O U T I N E =======================================
.text$mn:00001798
.text$mn:00001798 ; Attributes: bp-based frame
.text$mn:00001798
.text$mn:00001798 ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00001798                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00001798 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00001798                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00001798
.text$mn:00001798 var_4           = dword ptr -4
.text$mn:00001798
.text$mn:00001798                 push    ebp
.text$mn:00001799                 mov     ebp, esp
.text$mn:0000179B                 push    ecx
.text$mn:0000179C                 mov     [ebp+var_4], ecx
.text$mn:0000179F                 mov     ecx, [ebp+var_4]
.text$mn:000017A2                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:000017A7                 mov     eax, [ebp+var_4]
.text$mn:000017AA                 mov     esp, ebp
.text$mn:000017AC                 pop     ebp
.text$mn:000017AD                 retn
.text$mn:000017AD ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:000017AD
.text$mn:000017AD ; ---------------------------------------------------------------------------
.text$mn:000017AE                 align 10h
.text$mn:000017AE _text$mn        ends
.text$mn:000017AE
.text$mn:000017B0 ; ===========================================================================
.text$mn:000017B0
.text$mn:000017B0 ; Segment type: Pure code
.text$mn:000017B0 ; Segment permissions: Read/Execute
.text$mn:000017B0 _text$mn        segment para public 'CODE' use32
.text$mn:000017B0                 assume cs:_text$mn
.text$mn:000017B0                 ;org 17B0h
.text$mn:000017B0 ; COMDAT (pick any)
.text$mn:000017B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017B0
.text$mn:000017B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017B0
.text$mn:000017B0 ; Attributes: bp-based frame
.text$mn:000017B0
.text$mn:000017B0 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:000017B0                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:000017B0 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:000017B0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:000017B0
.text$mn:000017B0 var_4           = dword ptr -4
.text$mn:000017B0
.text$mn:000017B0                 push    ebp
.text$mn:000017B1                 mov     ebp, esp
.text$mn:000017B3                 push    ecx
.text$mn:000017B4                 mov     [ebp+var_4], ecx
.text$mn:000017B7                 mov     eax, [ebp+var_4]
.text$mn:000017BA                 mov     esp, ebp
.text$mn:000017BC                 pop     ebp
.text$mn:000017BD                 retn
.text$mn:000017BD ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:000017BD
.text$mn:000017BD ; ---------------------------------------------------------------------------
.text$mn:000017BE                 align 10h
.text$mn:000017BE _text$mn        ends
.text$mn:000017BE
.text$mn:000017C0 ; ===========================================================================
.text$mn:000017C0
.text$mn:000017C0 ; Segment type: Pure code
.text$mn:000017C0 ; Segment permissions: Read/Execute
.text$mn:000017C0 _text$mn        segment para public 'CODE' use32
.text$mn:000017C0                 assume cs:_text$mn
.text$mn:000017C0                 ;org 17C0h
.text$mn:000017C0 ; COMDAT (pick any)
.text$mn:000017C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017C0
.text$mn:000017C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017C0
.text$mn:000017C0 ; Attributes: bp-based frame
.text$mn:000017C0
.text$mn:000017C0 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:000017C0                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:000017C0 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:000017C0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp
.text$mn:000017C0                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+Cp
.text$mn:000017C0
.text$mn:000017C0 var_4           = dword ptr -4
.text$mn:000017C0
.text$mn:000017C0                 push    ebp
.text$mn:000017C1                 mov     ebp, esp
.text$mn:000017C3                 push    ecx
.text$mn:000017C4                 mov     [ebp+var_4], ecx
.text$mn:000017C7                 mov     eax, [ebp+var_4]
.text$mn:000017CA                 mov     esp, ebp
.text$mn:000017CC                 pop     ebp
.text$mn:000017CD                 retn
.text$mn:000017CD ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:000017CD
.text$mn:000017CD ; ---------------------------------------------------------------------------
.text$mn:000017CE                 align 10h
.text$mn:000017CE _text$mn        ends
.text$mn:000017CE
.text$mn:000017D0 ; ===========================================================================
.text$mn:000017D0
.text$mn:000017D0 ; Segment type: Pure code
.text$mn:000017D0 ; Segment permissions: Read/Execute
.text$mn:000017D0 _text$mn        segment para public 'CODE' use32
.text$mn:000017D0                 assume cs:_text$mn
.text$mn:000017D0                 ;org 17D0h
.text$mn:000017D0 ; COMDAT (pick any)
.text$mn:000017D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000017D0
.text$mn:000017D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000017D0
.text$mn:000017D0 ; Attributes: bp-based frame
.text$mn:000017D0
.text$mn:000017D0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:000017D0                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000017D0 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:000017D0                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:000017D0                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:000017D0
.text$mn:000017D0 var_14          = dword ptr -14h
.text$mn:000017D0 var_D           = byte ptr -0Dh
.text$mn:000017D0 var_C           = dword ptr -0Ch
.text$mn:000017D0 var_4           = dword ptr -4
.text$mn:000017D0 Str             = dword ptr  8
.text$mn:000017D0
.text$mn:000017D0                 push    ebp
.text$mn:000017D1                 mov     ebp, esp
.text$mn:000017D3                 push    0FFFFFFFFh
.text$mn:000017D5                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:000017DA                 mov     eax, large fs:0
.text$mn:000017E0                 push    eax
.text$mn:000017E1                 sub     esp, 8
.text$mn:000017E4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000017E9                 xor     eax, ebp
.text$mn:000017EB                 push    eax
.text$mn:000017EC                 lea     eax, [ebp+var_C]
.text$mn:000017EF                 mov     large fs:0, eax
.text$mn:000017F5                 mov     [ebp+var_14], ecx
.text$mn:000017F8                 lea     ecx, [ebp+var_D]
.text$mn:000017FB                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00001800                 push    eax
.text$mn:00001801                 mov     ecx, [ebp+var_14]
.text$mn:00001804                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00001809                 mov     [ebp+var_4], 0
.text$mn:00001810                 push    0               ; Size
.text$mn:00001812                 push    0               ; char
.text$mn:00001814                 mov     ecx, [ebp+var_14]
.text$mn:00001817                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000181C                 mov     eax, [ebp+Str]
.text$mn:0000181F                 push    eax             ; Str
.text$mn:00001820                 mov     ecx, [ebp+var_14]
.text$mn:00001823                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00001828                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000182F                 mov     eax, [ebp+var_14]
.text$mn:00001832                 mov     ecx, [ebp+var_C]
.text$mn:00001835                 mov     large fs:0, ecx
.text$mn:0000183C                 pop     ecx
.text$mn:0000183D                 mov     esp, ebp
.text$mn:0000183F                 pop     ebp
.text$mn:00001840                 retn    4
.text$mn:00001840 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00001840
.text$mn:00001840 ; ---------------------------------------------------------------------------
.text$mn:00001843                 align 4
.text$mn:00001843 _text$mn        ends
.text$mn:00001843
.text$x:00001844 ; ===========================================================================
.text$x:00001844
.text$x:00001844 ; Segment type: Pure code
.text$x:00001844 ; Segment permissions: Read/Execute
.text$x:00001844 _text$x         segment para public 'CODE' use32
.text$x:00001844                 assume cs:_text$x
.text$x:00001844                 ;org 1844h
.text$x:00001844 ; COMDAT (pick associative to section at 17D0)
.text$x:00001844                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001844
.text$x:00001844 ; =============== S U B R O U T I N E =======================================
.text$x:00001844
.text$x:00001844
.text$x:00001844 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00001844                                         ; DATA XREF: .xdata$x:00002F38o
.text$x:00001844                 mov     ecx, [ebp-14h]
.text$x:00001847                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001847 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00001847
.text$x:0000184C
.text$x:0000184C ; =============== S U B R O U T I N E =======================================
.text$x:0000184C
.text$x:0000184C
.text$x:0000184C __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:0000184C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:0000184C
.text$x:0000184C arg_4           = dword ptr  8
.text$x:0000184C
.text$x:0000184C                 mov     edx, [esp+arg_4]
.text$x:00001850                 lea     eax, [edx+0Ch]
.text$x:00001853                 mov     ecx, [edx-0Ch]
.text$x:00001856                 xor     ecx, eax
.text$x:00001858                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000185D                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00001862                 jmp     ___CxxFrameHandler3
.text$x:00001862 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00001862
.text$x:00001862 ; ---------------------------------------------------------------------------
.text$x:00001867                 align 4
.text$x:00001867 _text$x         ends
.text$x:00001867
.text$mn:00001868 ; ===========================================================================
.text$mn:00001868
.text$mn:00001868 ; Segment type: Pure code
.text$mn:00001868 ; Segment permissions: Read/Execute
.text$mn:00001868 _text$mn        segment para public 'CODE' use32
.text$mn:00001868                 assume cs:_text$mn
.text$mn:00001868                 ;org 1868h
.text$mn:00001868 ; COMDAT (pick any)
.text$mn:00001868                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001868
.text$mn:00001868 ; =============== S U B R O U T I N E =======================================
.text$mn:00001868
.text$mn:00001868 ; Attributes: bp-based frame
.text$mn:00001868
.text$mn:00001868 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001868                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00001868 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00001868                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00001868
.text$mn:00001868 var_4           = dword ptr -4
.text$mn:00001868
.text$mn:00001868                 push    ebp
.text$mn:00001869                 mov     ebp, esp
.text$mn:0000186B                 push    ecx
.text$mn:0000186C                 mov     [ebp+var_4], ecx
.text$mn:0000186F                 mov     eax, [ebp+var_4]
.text$mn:00001872                 mov     dword ptr [eax], 0
.text$mn:00001878                 mov     eax, [ebp+var_4]
.text$mn:0000187B                 mov     esp, ebp
.text$mn:0000187D                 pop     ebp
.text$mn:0000187E                 retn
.text$mn:0000187E ??0_Container_base12@std@@QAE@XZ endp
.text$mn:0000187E
.text$mn:0000187E ; ---------------------------------------------------------------------------
.text$mn:0000187F                 align 10h
.text$mn:0000187F _text$mn        ends
.text$mn:0000187F
.text$mn:00001880 ; ===========================================================================
.text$mn:00001880
.text$mn:00001880 ; Segment type: Pure code
.text$mn:00001880 ; Segment permissions: Read/Execute
.text$mn:00001880 _text$mn        segment para public 'CODE' use32
.text$mn:00001880                 assume cs:_text$mn
.text$mn:00001880                 ;org 1880h
.text$mn:00001880 ; COMDAT (pick any)
.text$mn:00001880                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001880
.text$mn:00001880 ; =============== S U B R O U T I N E =======================================
.text$mn:00001880
.text$mn:00001880 ; Attributes: bp-based frame
.text$mn:00001880
.text$mn:00001880 ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00001880                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00001880 ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00001880                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00001880
.text$mn:00001880 var_4           = dword ptr -4
.text$mn:00001880
.text$mn:00001880                 push    ebp
.text$mn:00001881                 mov     ebp, esp
.text$mn:00001883                 push    ecx
.text$mn:00001884                 mov     [ebp+var_4], ecx
.text$mn:00001887                 mov     eax, [ebp+var_4]
.text$mn:0000188A                 mov     dword ptr [eax], 0
.text$mn:00001890                 mov     ecx, [ebp+var_4]
.text$mn:00001893                 mov     dword ptr [ecx+4], 0
.text$mn:0000189A                 mov     eax, [ebp+var_4]
.text$mn:0000189D                 mov     esp, ebp
.text$mn:0000189F                 pop     ebp
.text$mn:000018A0                 retn
.text$mn:000018A0 ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:000018A0
.text$mn:000018A0 ; ---------------------------------------------------------------------------
.text$mn:000018A1                 align 4
.text$mn:000018A1 _text$mn        ends
.text$mn:000018A1
.text$mn:000018A4 ; ===========================================================================
.text$mn:000018A4
.text$mn:000018A4 ; Segment type: Pure code
.text$mn:000018A4 ; Segment permissions: Read/Execute
.text$mn:000018A4 _text$mn        segment para public 'CODE' use32
.text$mn:000018A4                 assume cs:_text$mn
.text$mn:000018A4                 ;org 18A4h
.text$mn:000018A4 ; COMDAT (pick any)
.text$mn:000018A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000018A4
.text$mn:000018A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000018A4
.text$mn:000018A4 ; Attributes: bp-based frame
.text$mn:000018A4
.text$mn:000018A4 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000018A4                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:000018A4 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:000018A4                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:000018A4                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:000018A4
.text$mn:000018A4 var_10          = dword ptr -10h
.text$mn:000018A4 var_C           = dword ptr -0Ch
.text$mn:000018A4 var_4           = dword ptr -4
.text$mn:000018A4
.text$mn:000018A4                 push    ebp
.text$mn:000018A5                 mov     ebp, esp
.text$mn:000018A7                 push    0FFFFFFFFh
.text$mn:000018A9                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:000018AE                 mov     eax, large fs:0
.text$mn:000018B4                 push    eax
.text$mn:000018B5                 push    ecx
.text$mn:000018B6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000018BB                 xor     eax, ebp
.text$mn:000018BD                 push    eax
.text$mn:000018BE                 lea     eax, [ebp+var_C]
.text$mn:000018C1                 mov     large fs:0, eax
.text$mn:000018C7                 mov     [ebp+var_10], ecx
.text$mn:000018CA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000018CD                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:000018D2                 mov     [ebp+var_4], 0
.text$mn:000018D9                 mov     eax, [ebp+var_10]
.text$mn:000018DC                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:000018E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018E9                 mov     eax, [ebp+var_10]
.text$mn:000018EC                 mov     ecx, [ebp+var_C]
.text$mn:000018EF                 mov     large fs:0, ecx
.text$mn:000018F6                 pop     ecx
.text$mn:000018F7                 mov     esp, ebp
.text$mn:000018F9                 pop     ebp
.text$mn:000018FA                 retn
.text$mn:000018FA ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:000018FA
.text$mn:000018FA ; ---------------------------------------------------------------------------
.text$mn:000018FB                 align 4
.text$mn:000018FB _text$mn        ends
.text$mn:000018FB
.text$x:000018FC ; ===========================================================================
.text$x:000018FC
.text$x:000018FC ; Segment type: Pure code
.text$x:000018FC ; Segment permissions: Read/Execute
.text$x:000018FC _text$x         segment para public 'CODE' use32
.text$x:000018FC                 assume cs:_text$x
.text$x:000018FC                 ;org 18FCh
.text$x:000018FC ; COMDAT (pick associative to section at 18A4)
.text$x:000018FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000018FC
.text$x:000018FC ; =============== S U B R O U T I N E =======================================
.text$x:000018FC
.text$x:000018FC
.text$x:000018FC __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:000018FC                                         ; DATA XREF: .xdata$x:0000301Co
.text$x:000018FC                 mov     ecx, [ebp-10h]  ; this
.text$x:000018FF                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:000018FF __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:000018FF
.text$x:00001904
.text$x:00001904 ; =============== S U B R O U T I N E =======================================
.text$x:00001904
.text$x:00001904
.text$x:00001904 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00001904                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00001904
.text$x:00001904 arg_4           = dword ptr  8
.text$x:00001904
.text$x:00001904                 mov     edx, [esp+arg_4]
.text$x:00001908                 lea     eax, [edx+0Ch]
.text$x:0000190B                 mov     ecx, [edx-8]
.text$x:0000190E                 xor     ecx, eax
.text$x:00001910                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001915                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:0000191A                 jmp     ___CxxFrameHandler3
.text$x:0000191A __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:0000191A
.text$x:0000191A ; ---------------------------------------------------------------------------
.text$x:0000191F                 align 10h
.text$x:0000191F _text$x         ends
.text$x:0000191F
.text$mn:00001920 ; ===========================================================================
.text$mn:00001920
.text$mn:00001920 ; Segment type: Pure code
.text$mn:00001920 ; Segment permissions: Read/Execute
.text$mn:00001920 _text$mn        segment para public 'CODE' use32
.text$mn:00001920                 assume cs:_text$mn
.text$mn:00001920                 ;org 1920h
.text$mn:00001920 ; COMDAT (pick any)
.text$mn:00001920                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001920
.text$mn:00001920 ; =============== S U B R O U T I N E =======================================
.text$mn:00001920
.text$mn:00001920 ; Attributes: bp-based frame
.text$mn:00001920
.text$mn:00001920 ; _DWORD __thiscall std::_Ignore::_Ignore(std::_Ignore *__hidden this)
.text$mn:00001920                 public ??0_Ignore@std@@QAE@XZ
.text$mn:00001920 ??0_Ignore@std@@QAE@XZ proc near        ; CODE XREF: std::`dynamic initializer for 'ignore''(void)+8p
.text$mn:00001920
.text$mn:00001920 var_4           = dword ptr -4
.text$mn:00001920
.text$mn:00001920                 push    ebp
.text$mn:00001921                 mov     ebp, esp
.text$mn:00001923                 push    ecx
.text$mn:00001924                 mov     [ebp+var_4], ecx
.text$mn:00001927                 mov     eax, [ebp+var_4]
.text$mn:0000192A                 mov     esp, ebp
.text$mn:0000192C                 pop     ebp
.text$mn:0000192D                 retn
.text$mn:0000192D ??0_Ignore@std@@QAE@XZ endp
.text$mn:0000192D
.text$mn:0000192D ; ---------------------------------------------------------------------------
.text$mn:0000192E                 align 10h
.text$mn:0000192E _text$mn        ends
.text$mn:0000192E
.text$mn:00001930 ; ===========================================================================
.text$mn:00001930
.text$mn:00001930 ; Segment type: Pure code
.text$mn:00001930 ; Segment permissions: Read/Execute
.text$mn:00001930 _text$mn        segment para public 'CODE' use32
.text$mn:00001930                 assume cs:_text$mn
.text$mn:00001930                 ;org 1930h
.text$mn:00001930 ; COMDAT (pick any)
.text$mn:00001930                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001930
.text$mn:00001930 ; =============== S U B R O U T I N E =======================================
.text$mn:00001930
.text$mn:00001930 ; Attributes: bp-based frame
.text$mn:00001930
.text$mn:00001930 ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001930                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00001930 ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00001930                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001930
.text$mn:00001930 var_10          = dword ptr -10h
.text$mn:00001930 var_C           = dword ptr -0Ch
.text$mn:00001930 var_4           = dword ptr -4
.text$mn:00001930
.text$mn:00001930                 push    ebp
.text$mn:00001931                 mov     ebp, esp
.text$mn:00001933                 push    0FFFFFFFFh
.text$mn:00001935                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:0000193A                 mov     eax, large fs:0
.text$mn:00001940                 push    eax
.text$mn:00001941                 push    ecx
.text$mn:00001942                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001947                 xor     eax, ebp
.text$mn:00001949                 push    eax
.text$mn:0000194A                 lea     eax, [ebp+var_C]
.text$mn:0000194D                 mov     large fs:0, eax
.text$mn:00001953                 mov     [ebp+var_10], ecx
.text$mn:00001956                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001959                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:0000195E                 mov     [ebp+var_4], 0
.text$mn:00001965                 mov     eax, [ebp+var_10]
.text$mn:00001968                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:0000196E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001975                 mov     eax, [ebp+var_10]
.text$mn:00001978                 mov     ecx, [ebp+var_C]
.text$mn:0000197B                 mov     large fs:0, ecx
.text$mn:00001982                 pop     ecx
.text$mn:00001983                 mov     esp, ebp
.text$mn:00001985                 pop     ebp
.text$mn:00001986                 retn
.text$mn:00001986 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00001986
.text$mn:00001986 ; ---------------------------------------------------------------------------
.text$mn:00001987                 align 4
.text$mn:00001987 _text$mn        ends
.text$mn:00001987
.text$x:00001988 ; ===========================================================================
.text$x:00001988
.text$x:00001988 ; Segment type: Pure code
.text$x:00001988 ; Segment permissions: Read/Execute
.text$x:00001988 _text$x         segment para public 'CODE' use32
.text$x:00001988                 assume cs:_text$x
.text$x:00001988                 ;org 1988h
.text$x:00001988 ; COMDAT (pick associative to section at 1930)
.text$x:00001988                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001988
.text$x:00001988 ; =============== S U B R O U T I N E =======================================
.text$x:00001988
.text$x:00001988
.text$x:00001988 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00001988                                         ; DATA XREF: .xdata$x:000030A0o
.text$x:00001988                 mov     ecx, [ebp-10h]  ; this
.text$x:0000198B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000198B __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:0000198B
.text$x:00001990
.text$x:00001990 ; =============== S U B R O U T I N E =======================================
.text$x:00001990
.text$x:00001990
.text$x:00001990 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00001990                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00001990
.text$x:00001990 arg_4           = dword ptr  8
.text$x:00001990
.text$x:00001990                 mov     edx, [esp+arg_4]
.text$x:00001994                 lea     eax, [edx+0Ch]
.text$x:00001997                 mov     ecx, [edx-8]
.text$x:0000199A                 xor     ecx, eax
.text$x:0000199C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000019A1                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:000019A6                 jmp     ___CxxFrameHandler3
.text$x:000019A6 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:000019A6
.text$x:000019A6 ; ---------------------------------------------------------------------------
.text$x:000019AB                 align 4
.text$x:000019AB _text$x         ends
.text$x:000019AB
.text$mn:000019AC ; ===========================================================================
.text$mn:000019AC
.text$mn:000019AC ; Segment type: Pure code
.text$mn:000019AC ; Segment permissions: Read/Execute
.text$mn:000019AC _text$mn        segment para public 'CODE' use32
.text$mn:000019AC                 assume cs:_text$mn
.text$mn:000019AC                 ;org 19ACh
.text$mn:000019AC ; COMDAT (pick any)
.text$mn:000019AC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000019AC
.text$mn:000019AC ; =============== S U B R O U T I N E =======================================
.text$mn:000019AC
.text$mn:000019AC ; Attributes: bp-based frame
.text$mn:000019AC
.text$mn:000019AC ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:000019AC                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:000019AC ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:000019AC                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:000019AC
.text$mn:000019AC var_10          = dword ptr -10h
.text$mn:000019AC var_C           = dword ptr -0Ch
.text$mn:000019AC var_4           = dword ptr -4
.text$mn:000019AC
.text$mn:000019AC                 push    ebp
.text$mn:000019AD                 mov     ebp, esp
.text$mn:000019AF                 push    0FFFFFFFFh
.text$mn:000019B1                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:000019B6                 mov     eax, large fs:0
.text$mn:000019BC                 push    eax
.text$mn:000019BD                 push    ecx
.text$mn:000019BE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000019C3                 xor     eax, ebp
.text$mn:000019C5                 push    eax
.text$mn:000019C6                 lea     eax, [ebp+var_C]
.text$mn:000019C9                 mov     large fs:0, eax
.text$mn:000019CF                 mov     [ebp+var_10], ecx
.text$mn:000019D2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000019D5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:000019DA                 mov     [ebp+var_4], 0
.text$mn:000019E1                 mov     eax, [ebp+var_10]
.text$mn:000019E4                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:000019EA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000019F1                 mov     eax, [ebp+var_10]
.text$mn:000019F4                 mov     ecx, [ebp+var_C]
.text$mn:000019F7                 mov     large fs:0, ecx
.text$mn:000019FE                 pop     ecx
.text$mn:000019FF                 mov     esp, ebp
.text$mn:00001A01                 pop     ebp
.text$mn:00001A02                 retn
.text$mn:00001A02 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00001A02
.text$mn:00001A02 ; ---------------------------------------------------------------------------
.text$mn:00001A03                 align 4
.text$mn:00001A03 _text$mn        ends
.text$mn:00001A03
.text$x:00001A04 ; ===========================================================================
.text$x:00001A04
.text$x:00001A04 ; Segment type: Pure code
.text$x:00001A04 ; Segment permissions: Read/Execute
.text$x:00001A04 _text$x         segment para public 'CODE' use32
.text$x:00001A04                 assume cs:_text$x
.text$x:00001A04                 ;org 1A04h
.text$x:00001A04 ; COMDAT (pick associative to section at 19AC)
.text$x:00001A04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001A04
.text$x:00001A04 ; =============== S U B R O U T I N E =======================================
.text$x:00001A04
.text$x:00001A04
.text$x:00001A04 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00001A04                                         ; DATA XREF: .xdata$x:00003124o
.text$x:00001A04                 mov     ecx, [ebp-10h]  ; this
.text$x:00001A07                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001A07 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00001A07
.text$x:00001A0C
.text$x:00001A0C ; =============== S U B R O U T I N E =======================================
.text$x:00001A0C
.text$x:00001A0C
.text$x:00001A0C __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00001A0C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00001A0C
.text$x:00001A0C arg_4           = dword ptr  8
.text$x:00001A0C
.text$x:00001A0C                 mov     edx, [esp+arg_4]
.text$x:00001A10                 lea     eax, [edx+0Ch]
.text$x:00001A13                 mov     ecx, [edx-8]
.text$x:00001A16                 xor     ecx, eax
.text$x:00001A18                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001A1D                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00001A22                 jmp     ___CxxFrameHandler3
.text$x:00001A22 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00001A22
.text$x:00001A22 ; ---------------------------------------------------------------------------
.text$x:00001A27                 align 4
.text$x:00001A27 _text$x         ends
.text$x:00001A27
.text$mn:00001A28 ; ===========================================================================
.text$mn:00001A28
.text$mn:00001A28 ; Segment type: Pure code
.text$mn:00001A28 ; Segment permissions: Read/Execute
.text$mn:00001A28 _text$mn        segment para public 'CODE' use32
.text$mn:00001A28                 assume cs:_text$mn
.text$mn:00001A28                 ;org 1A28h
.text$mn:00001A28 ; COMDAT (pick any)
.text$mn:00001A28                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A28
.text$mn:00001A28 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A28
.text$mn:00001A28 ; Attributes: bp-based frame
.text$mn:00001A28
.text$mn:00001A28 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00001A28                 public ??0error_category@std@@QAE@XZ
.text$mn:00001A28 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00001A28
.text$mn:00001A28 var_4           = dword ptr -4
.text$mn:00001A28
.text$mn:00001A28                 push    ebp
.text$mn:00001A29                 mov     ebp, esp
.text$mn:00001A2B                 push    ecx
.text$mn:00001A2C                 mov     [ebp+var_4], ecx
.text$mn:00001A2F                 mov     eax, [ebp+var_4]
.text$mn:00001A32                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001A38                 mov     eax, [ebp+var_4]
.text$mn:00001A3B                 mov     esp, ebp
.text$mn:00001A3D                 pop     ebp
.text$mn:00001A3E                 retn
.text$mn:00001A3E ??0error_category@std@@QAE@XZ endp
.text$mn:00001A3E
.text$mn:00001A3E ; ---------------------------------------------------------------------------
.text$mn:00001A3F                 align 10h
.text$mn:00001A3F _text$mn        ends
.text$mn:00001A3F
.text$mn:00001A40 ; ===========================================================================
.text$mn:00001A40
.text$mn:00001A40 ; Segment type: Pure code
.text$mn:00001A40 ; Segment permissions: Read/Execute
.text$mn:00001A40 _text$mn        segment para public 'CODE' use32
.text$mn:00001A40                 assume cs:_text$mn
.text$mn:00001A40                 ;org 1A40h
.text$mn:00001A40 ; COMDAT (pick any)
.text$mn:00001A40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A40
.text$mn:00001A40 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A40
.text$mn:00001A40 ; Attributes: bp-based frame
.text$mn:00001A40
.text$mn:00001A40 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00001A40                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00001A40 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00001A40                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00001A40                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00001A40
.text$mn:00001A40 var_4           = dword ptr -4
.text$mn:00001A40 arg_0           = dword ptr  8
.text$mn:00001A40 arg_4           = dword ptr  0Ch
.text$mn:00001A40
.text$mn:00001A40                 push    ebp
.text$mn:00001A41                 mov     ebp, esp
.text$mn:00001A43                 push    ecx
.text$mn:00001A44                 mov     [ebp+var_4], ecx
.text$mn:00001A47                 mov     eax, [ebp+var_4]
.text$mn:00001A4A                 mov     ecx, [ebp+arg_0]
.text$mn:00001A4D                 mov     [eax], ecx
.text$mn:00001A4F                 mov     edx, [ebp+var_4]
.text$mn:00001A52                 mov     eax, [ebp+arg_4]
.text$mn:00001A55                 mov     [edx+4], eax
.text$mn:00001A58                 mov     eax, [ebp+var_4]
.text$mn:00001A5B                 mov     esp, ebp
.text$mn:00001A5D                 pop     ebp
.text$mn:00001A5E                 retn    8
.text$mn:00001A5E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00001A5E
.text$mn:00001A5E ; ---------------------------------------------------------------------------
.text$mn:00001A61                 align 4
.text$mn:00001A61 _text$mn        ends
.text$mn:00001A61
.text$mn:00001A64 ; ===========================================================================
.text$mn:00001A64
.text$mn:00001A64 ; Segment type: Pure code
.text$mn:00001A64 ; Segment permissions: Read/Execute
.text$mn:00001A64 _text$mn        segment para public 'CODE' use32
.text$mn:00001A64                 assume cs:_text$mn
.text$mn:00001A64                 ;org 1A64h
.text$mn:00001A64 ; COMDAT (pick any)
.text$mn:00001A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A64
.text$mn:00001A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001A64
.text$mn:00001A64 ; Attributes: bp-based frame
.text$mn:00001A64
.text$mn:00001A64 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00001A64                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00001A64 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00001A64                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00001A64
.text$mn:00001A64 var_4           = dword ptr -4
.text$mn:00001A64 arg_0           = dword ptr  8
.text$mn:00001A64
.text$mn:00001A64                 push    ebp
.text$mn:00001A65                 mov     ebp, esp
.text$mn:00001A67                 push    ecx
.text$mn:00001A68                 mov     [ebp+var_4], ecx
.text$mn:00001A6B                 mov     eax, [ebp+var_4]
.text$mn:00001A6E                 mov     ecx, [ebp+arg_0]
.text$mn:00001A71                 mov     [eax], ecx
.text$mn:00001A73                 mov     eax, [ebp+var_4]
.text$mn:00001A76                 mov     esp, ebp
.text$mn:00001A78                 pop     ebp
.text$mn:00001A79                 retn    4
.text$mn:00001A79 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00001A79
.text$mn:00001A79 _text$mn        ends
.text$mn:00001A79
.text$mn:00001A7C ; ===========================================================================
.text$mn:00001A7C
.text$mn:00001A7C ; Segment type: Pure code
.text$mn:00001A7C ; Segment permissions: Read/Execute
.text$mn:00001A7C _text$mn        segment para public 'CODE' use32
.text$mn:00001A7C                 assume cs:_text$mn
.text$mn:00001A7C                 ;org 1A7Ch
.text$mn:00001A7C ; COMDAT (pick any)
.text$mn:00001A7C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001A7C
.text$mn:00001A7C ; =============== S U B R O U T I N E =======================================
.text$mn:00001A7C
.text$mn:00001A7C ; Attributes: bp-based frame
.text$mn:00001A7C
.text$mn:00001A7C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00001A7C                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001A7C ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00001A7C                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00001A7C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00001A7C
.text$mn:00001A7C var_10          = dword ptr -10h
.text$mn:00001A7C var_C           = dword ptr -0Ch
.text$mn:00001A7C var_4           = dword ptr -4
.text$mn:00001A7C
.text$mn:00001A7C                 push    ebp
.text$mn:00001A7D                 mov     ebp, esp
.text$mn:00001A7F                 push    0FFFFFFFFh
.text$mn:00001A81                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00001A86                 mov     eax, large fs:0
.text$mn:00001A8C                 push    eax
.text$mn:00001A8D                 push    ecx
.text$mn:00001A8E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001A93                 xor     eax, ebp
.text$mn:00001A95                 push    eax
.text$mn:00001A96                 lea     eax, [ebp+var_C]
.text$mn:00001A99                 mov     large fs:0, eax
.text$mn:00001A9F                 mov     [ebp+var_10], ecx
.text$mn:00001AA2                 mov     [ebp+var_4], 0
.text$mn:00001AA9                 mov     ecx, [ebp+var_10]
.text$mn:00001AAC                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00001AB1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001AB8                 mov     ecx, [ebp+var_10]
.text$mn:00001ABB                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00001AC0                 mov     ecx, [ebp+var_C]
.text$mn:00001AC3                 mov     large fs:0, ecx
.text$mn:00001ACA                 pop     ecx
.text$mn:00001ACB                 mov     esp, ebp
.text$mn:00001ACD                 pop     ebp
.text$mn:00001ACE                 retn
.text$mn:00001ACE ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00001ACE
.text$mn:00001ACE ; ---------------------------------------------------------------------------
.text$mn:00001ACF                 align 10h
.text$mn:00001ACF _text$mn        ends
.text$mn:00001ACF
.text$x:00001AD0 ; ===========================================================================
.text$x:00001AD0
.text$x:00001AD0 ; Segment type: Pure code
.text$x:00001AD0 ; Segment permissions: Read/Execute
.text$x:00001AD0 _text$x         segment para public 'CODE' use32
.text$x:00001AD0                 assume cs:_text$x
.text$x:00001AD0                 ;org 1AD0h
.text$x:00001AD0 ; COMDAT (pick associative to section at 1A7C)
.text$x:00001AD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001AD0
.text$x:00001AD0 ; =============== S U B R O U T I N E =======================================
.text$x:00001AD0
.text$x:00001AD0
.text$x:00001AD0 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00001AD0                                         ; DATA XREF: .xdata$x:00002F0Co
.text$x:00001AD0                 mov     ecx, [ebp-10h]
.text$x:00001AD3                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:00001AD3 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00001AD3
.text$x:00001AD8
.text$x:00001AD8 ; =============== S U B R O U T I N E =======================================
.text$x:00001AD8
.text$x:00001AD8
.text$x:00001AD8 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00001AD8                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00001AD8
.text$x:00001AD8 arg_4           = dword ptr  8
.text$x:00001AD8
.text$x:00001AD8                 mov     edx, [esp+arg_4]
.text$x:00001ADC                 lea     eax, [edx+0Ch]
.text$x:00001ADF                 mov     ecx, [edx-8]
.text$x:00001AE2                 xor     ecx, eax
.text$x:00001AE4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001AE9                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00001AEE                 jmp     ___CxxFrameHandler3
.text$x:00001AEE __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00001AEE
.text$x:00001AEE ; ---------------------------------------------------------------------------
.text$x:00001AF3                 align 4
.text$x:00001AF3 _text$x         ends
.text$x:00001AF3
.text$mn:00001AF4 ; ===========================================================================
.text$mn:00001AF4
.text$mn:00001AF4 ; Segment type: Pure code
.text$mn:00001AF4 ; Segment permissions: Read/Execute
.text$mn:00001AF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001AF4                 assume cs:_text$mn
.text$mn:00001AF4                 ;org 1AF4h
.text$mn:00001AF4 ; COMDAT (pick any)
.text$mn:00001AF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001AF4
.text$mn:00001AF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001AF4
.text$mn:00001AF4 ; Attributes: bp-based frame
.text$mn:00001AF4
.text$mn:00001AF4 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00001AF4                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001AF4 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00001AF4                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:00001AF4                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:00001AF4
.text$mn:00001AF4 var_10          = dword ptr -10h
.text$mn:00001AF4 var_C           = dword ptr -0Ch
.text$mn:00001AF4 var_4           = dword ptr -4
.text$mn:00001AF4
.text$mn:00001AF4                 push    ebp
.text$mn:00001AF5                 mov     ebp, esp
.text$mn:00001AF7                 push    0FFFFFFFFh
.text$mn:00001AF9                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00001AFE                 mov     eax, large fs:0
.text$mn:00001B04                 push    eax
.text$mn:00001B05                 push    ecx
.text$mn:00001B06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B0B                 xor     eax, ebp
.text$mn:00001B0D                 push    eax
.text$mn:00001B0E                 lea     eax, [ebp+var_C]
.text$mn:00001B11                 mov     large fs:0, eax
.text$mn:00001B17                 mov     [ebp+var_10], ecx
.text$mn:00001B1A                 mov     [ebp+var_4], 0
.text$mn:00001B21                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B28                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001B2B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00001B30                 mov     ecx, [ebp+var_C]
.text$mn:00001B33                 mov     large fs:0, ecx
.text$mn:00001B3A                 pop     ecx
.text$mn:00001B3B                 mov     esp, ebp
.text$mn:00001B3D                 pop     ebp
.text$mn:00001B3E                 retn
.text$mn:00001B3E ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00001B3E
.text$mn:00001B3E ; ---------------------------------------------------------------------------
.text$mn:00001B3F                 align 10h
.text$mn:00001B3F _text$mn        ends
.text$mn:00001B3F
.text$x:00001B40 ; ===========================================================================
.text$x:00001B40
.text$x:00001B40 ; Segment type: Pure code
.text$x:00001B40 ; Segment permissions: Read/Execute
.text$x:00001B40 _text$x         segment para public 'CODE' use32
.text$x:00001B40                 assume cs:_text$x
.text$x:00001B40                 ;org 1B40h
.text$x:00001B40 ; COMDAT (pick associative to section at 1AF4)
.text$x:00001B40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001B40
.text$x:00001B40 ; =============== S U B R O U T I N E =======================================
.text$x:00001B40
.text$x:00001B40
.text$x:00001B40 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:00001B40                                         ; DATA XREF: .xdata$x:00002EB4o
.text$x:00001B40                 mov     ecx, [ebp-10h]  ; this
.text$x:00001B43                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00001B43 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:00001B43
.text$x:00001B48
.text$x:00001B48 ; =============== S U B R O U T I N E =======================================
.text$x:00001B48
.text$x:00001B48
.text$x:00001B48 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00001B48                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00001B48
.text$x:00001B48 arg_4           = dword ptr  8
.text$x:00001B48
.text$x:00001B48                 mov     edx, [esp+arg_4]
.text$x:00001B4C                 lea     eax, [edx+0Ch]
.text$x:00001B4F                 mov     ecx, [edx-8]
.text$x:00001B52                 xor     ecx, eax
.text$x:00001B54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001B59                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:00001B5E                 jmp     ___CxxFrameHandler3
.text$x:00001B5E __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:00001B5E
.text$x:00001B5E ; ---------------------------------------------------------------------------
.text$x:00001B63                 align 4
.text$x:00001B63 _text$x         ends
.text$x:00001B63
.text$mn:00001B64 ; ===========================================================================
.text$mn:00001B64
.text$mn:00001B64 ; Segment type: Pure code
.text$mn:00001B64 ; Segment permissions: Read/Execute
.text$mn:00001B64 _text$mn        segment para public 'CODE' use32
.text$mn:00001B64                 assume cs:_text$mn
.text$mn:00001B64                 ;org 1B64h
.text$mn:00001B64 ; COMDAT (pick any)
.text$mn:00001B64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001B64
.text$mn:00001B64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001B64
.text$mn:00001B64 ; Attributes: bp-based frame
.text$mn:00001B64
.text$mn:00001B64 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00001B64                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001B64 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00001B64                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00001B64                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00001B64
.text$mn:00001B64 var_10          = dword ptr -10h
.text$mn:00001B64 var_C           = dword ptr -0Ch
.text$mn:00001B64 var_4           = dword ptr -4
.text$mn:00001B64
.text$mn:00001B64                 push    ebp
.text$mn:00001B65                 mov     ebp, esp
.text$mn:00001B67                 push    0FFFFFFFFh
.text$mn:00001B69                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00001B6E                 mov     eax, large fs:0
.text$mn:00001B74                 push    eax
.text$mn:00001B75                 push    ecx
.text$mn:00001B76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001B7B                 xor     eax, ebp
.text$mn:00001B7D                 push    eax
.text$mn:00001B7E                 lea     eax, [ebp+var_C]
.text$mn:00001B81                 mov     large fs:0, eax
.text$mn:00001B87                 mov     [ebp+var_10], ecx
.text$mn:00001B8A                 mov     [ebp+var_4], 0
.text$mn:00001B91                 push    0               ; Size
.text$mn:00001B93                 push    1               ; char
.text$mn:00001B95                 mov     ecx, [ebp+var_10]
.text$mn:00001B98                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00001B9D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BA4                 mov     ecx, [ebp+var_10]
.text$mn:00001BA7                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:00001BAC                 mov     ecx, [ebp+var_C]
.text$mn:00001BAF                 mov     large fs:0, ecx
.text$mn:00001BB6                 pop     ecx
.text$mn:00001BB7                 mov     esp, ebp
.text$mn:00001BB9                 pop     ebp
.text$mn:00001BBA                 retn
.text$mn:00001BBA ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:00001BBA
.text$mn:00001BBA ; ---------------------------------------------------------------------------
.text$mn:00001BBB                 align 4
.text$mn:00001BBB _text$mn        ends
.text$mn:00001BBB
.text$x:00001BBC ; ===========================================================================
.text$x:00001BBC
.text$x:00001BBC ; Segment type: Pure code
.text$x:00001BBC ; Segment permissions: Read/Execute
.text$x:00001BBC _text$x         segment para public 'CODE' use32
.text$x:00001BBC                 assume cs:_text$x
.text$x:00001BBC                 ;org 1BBCh
.text$x:00001BBC ; COMDAT (pick associative to section at 1B64)
.text$x:00001BBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001BBC
.text$x:00001BBC ; =============== S U B R O U T I N E =======================================
.text$x:00001BBC
.text$x:00001BBC
.text$x:00001BBC __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:00001BBC                                         ; DATA XREF: .xdata$x:00002F64o
.text$x:00001BBC                 mov     ecx, [ebp-10h]
.text$x:00001BBF                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00001BBF __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:00001BBF
.text$x:00001BC4
.text$x:00001BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00001BC4
.text$x:00001BC4
.text$x:00001BC4 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:00001BC4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:00001BC4
.text$x:00001BC4 arg_4           = dword ptr  8
.text$x:00001BC4
.text$x:00001BC4                 mov     edx, [esp+arg_4]
.text$x:00001BC8                 lea     eax, [edx+0Ch]
.text$x:00001BCB                 mov     ecx, [edx-8]
.text$x:00001BCE                 xor     ecx, eax
.text$x:00001BD0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001BD5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:00001BDA                 jmp     ___CxxFrameHandler3
.text$x:00001BDA __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:00001BDA
.text$x:00001BDA ; ---------------------------------------------------------------------------
.text$x:00001BDF                 align 10h
.text$x:00001BDF _text$x         ends
.text$x:00001BDF
.text$mn:00001BE0 ; ===========================================================================
.text$mn:00001BE0
.text$mn:00001BE0 ; Segment type: Pure code
.text$mn:00001BE0 ; Segment permissions: Read/Execute
.text$mn:00001BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00001BE0                 assume cs:_text$mn
.text$mn:00001BE0                 ;org 1BE0h
.text$mn:00001BE0 ; COMDAT (pick any)
.text$mn:00001BE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BE0
.text$mn:00001BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BE0
.text$mn:00001BE0 ; Attributes: bp-based frame
.text$mn:00001BE0
.text$mn:00001BE0 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00001BE0                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:00001BE0 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:00001BE0                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:00001BE0                                         ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+37p ...
.text$mn:00001BE0
.text$mn:00001BE0 var_4           = dword ptr -4
.text$mn:00001BE0
.text$mn:00001BE0                 push    ebp
.text$mn:00001BE1                 mov     ebp, esp
.text$mn:00001BE3                 push    ecx
.text$mn:00001BE4                 mov     [ebp+var_4], ecx
.text$mn:00001BE7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001BEA                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00001BEF                 mov     esp, ebp
.text$mn:00001BF1                 pop     ebp
.text$mn:00001BF2                 retn
.text$mn:00001BF2 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:00001BF2
.text$mn:00001BF2 ; ---------------------------------------------------------------------------
.text$mn:00001BF3                 align 4
.text$mn:00001BF3 _text$mn        ends
.text$mn:00001BF3
.text$mn:00001BF4 ; ===========================================================================
.text$mn:00001BF4
.text$mn:00001BF4 ; Segment type: Pure code
.text$mn:00001BF4 ; Segment permissions: Read/Execute
.text$mn:00001BF4 _text$mn        segment para public 'CODE' use32
.text$mn:00001BF4                 assume cs:_text$mn
.text$mn:00001BF4                 ;org 1BF4h
.text$mn:00001BF4 ; COMDAT (pick any)
.text$mn:00001BF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001BF4
.text$mn:00001BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BF4
.text$mn:00001BF4 ; Attributes: bp-based frame
.text$mn:00001BF4
.text$mn:00001BF4 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00001BF4                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001BF4 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:00001BF4                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:00001BF4                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:00001BF4
.text$mn:00001BF4 var_10          = dword ptr -10h
.text$mn:00001BF4 var_C           = dword ptr -0Ch
.text$mn:00001BF4 var_4           = dword ptr -4
.text$mn:00001BF4
.text$mn:00001BF4                 push    ebp
.text$mn:00001BF5                 mov     ebp, esp
.text$mn:00001BF7                 push    0FFFFFFFFh
.text$mn:00001BF9                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:00001BFE                 mov     eax, large fs:0
.text$mn:00001C04                 push    eax
.text$mn:00001C05                 push    ecx
.text$mn:00001C06                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C0B                 xor     eax, ebp
.text$mn:00001C0D                 push    eax
.text$mn:00001C0E                 lea     eax, [ebp+var_C]
.text$mn:00001C11                 mov     large fs:0, eax
.text$mn:00001C17                 mov     [ebp+var_10], ecx
.text$mn:00001C1A                 mov     [ebp+var_4], 0
.text$mn:00001C21                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001C28                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001C2B                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001C30                 mov     ecx, [ebp+var_C]
.text$mn:00001C33                 mov     large fs:0, ecx
.text$mn:00001C3A                 pop     ecx
.text$mn:00001C3B                 mov     esp, ebp
.text$mn:00001C3D                 pop     ebp
.text$mn:00001C3E                 retn
.text$mn:00001C3E ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00001C3E
.text$mn:00001C3E ; ---------------------------------------------------------------------------
.text$mn:00001C3F                 align 10h
.text$mn:00001C3F _text$mn        ends
.text$mn:00001C3F
.text$x:00001C40 ; ===========================================================================
.text$x:00001C40
.text$x:00001C40 ; Segment type: Pure code
.text$x:00001C40 ; Segment permissions: Read/Execute
.text$x:00001C40 _text$x         segment para public 'CODE' use32
.text$x:00001C40                 assume cs:_text$x
.text$x:00001C40                 ;org 1C40h
.text$x:00001C40 ; COMDAT (pick associative to section at 1BF4)
.text$x:00001C40                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001C40
.text$x:00001C40 ; =============== S U B R O U T I N E =======================================
.text$x:00001C40
.text$x:00001C40
.text$x:00001C40 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00001C40                                         ; DATA XREF: .xdata$x:00003074o
.text$x:00001C40                 mov     ecx, [ebp-10h]  ; this
.text$x:00001C43                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00001C43 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00001C43
.text$x:00001C48
.text$x:00001C48 ; =============== S U B R O U T I N E =======================================
.text$x:00001C48
.text$x:00001C48
.text$x:00001C48 __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:00001C48                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:00001C48
.text$x:00001C48 arg_4           = dword ptr  8
.text$x:00001C48
.text$x:00001C48                 mov     edx, [esp+arg_4]
.text$x:00001C4C                 lea     eax, [edx+0Ch]
.text$x:00001C4F                 mov     ecx, [edx-8]
.text$x:00001C52                 xor     ecx, eax
.text$x:00001C54                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001C59                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00001C5E                 jmp     ___CxxFrameHandler3
.text$x:00001C5E __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00001C5E
.text$x:00001C5E ; ---------------------------------------------------------------------------
.text$x:00001C63                 align 4
.text$x:00001C63 _text$x         ends
.text$x:00001C63
.text$mn:00001C64 ; ===========================================================================
.text$mn:00001C64
.text$mn:00001C64 ; Segment type: Pure code
.text$mn:00001C64 ; Segment permissions: Read/Execute
.text$mn:00001C64 _text$mn        segment para public 'CODE' use32
.text$mn:00001C64                 assume cs:_text$mn
.text$mn:00001C64                 ;org 1C64h
.text$mn:00001C64 ; COMDAT (pick any)
.text$mn:00001C64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001C64
.text$mn:00001C64 ; =============== S U B R O U T I N E =======================================
.text$mn:00001C64
.text$mn:00001C64 ; Attributes: bp-based frame
.text$mn:00001C64
.text$mn:00001C64 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00001C64                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001C64 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00001C64                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001C64                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00001C64
.text$mn:00001C64 var_10          = dword ptr -10h
.text$mn:00001C64 var_C           = dword ptr -0Ch
.text$mn:00001C64 var_4           = dword ptr -4
.text$mn:00001C64
.text$mn:00001C64                 push    ebp
.text$mn:00001C65                 mov     ebp, esp
.text$mn:00001C67                 push    0FFFFFFFFh
.text$mn:00001C69                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00001C6E                 mov     eax, large fs:0
.text$mn:00001C74                 push    eax
.text$mn:00001C75                 push    ecx
.text$mn:00001C76                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001C7B                 xor     eax, ebp
.text$mn:00001C7D                 push    eax
.text$mn:00001C7E                 lea     eax, [ebp+var_C]
.text$mn:00001C81                 mov     large fs:0, eax
.text$mn:00001C87                 mov     [ebp+var_10], ecx
.text$mn:00001C8A                 mov     [ebp+var_4], 0
.text$mn:00001C91                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001C98                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001C9B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001CA0                 mov     ecx, [ebp+var_C]
.text$mn:00001CA3                 mov     large fs:0, ecx
.text$mn:00001CAA                 pop     ecx
.text$mn:00001CAB                 mov     esp, ebp
.text$mn:00001CAD                 pop     ebp
.text$mn:00001CAE                 retn
.text$mn:00001CAE ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00001CAE
.text$mn:00001CAE ; ---------------------------------------------------------------------------
.text$mn:00001CAF                 align 10h
.text$mn:00001CAF _text$mn        ends
.text$mn:00001CAF
.text$x:00001CB0 ; ===========================================================================
.text$x:00001CB0
.text$x:00001CB0 ; Segment type: Pure code
.text$x:00001CB0 ; Segment permissions: Read/Execute
.text$x:00001CB0 _text$x         segment para public 'CODE' use32
.text$x:00001CB0                 assume cs:_text$x
.text$x:00001CB0                 ;org 1CB0h
.text$x:00001CB0 ; COMDAT (pick associative to section at 1C64)
.text$x:00001CB0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001CB0
.text$x:00001CB0 ; =============== S U B R O U T I N E =======================================
.text$x:00001CB0
.text$x:00001CB0
.text$x:00001CB0 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00001CB0                                         ; DATA XREF: .xdata$x:000030F8o
.text$x:00001CB0                 mov     ecx, [ebp-10h]  ; this
.text$x:00001CB3                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001CB3 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00001CB3
.text$x:00001CB8
.text$x:00001CB8 ; =============== S U B R O U T I N E =======================================
.text$x:00001CB8
.text$x:00001CB8
.text$x:00001CB8 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:00001CB8                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:00001CB8
.text$x:00001CB8 arg_4           = dword ptr  8
.text$x:00001CB8
.text$x:00001CB8                 mov     edx, [esp+arg_4]
.text$x:00001CBC                 lea     eax, [edx+0Ch]
.text$x:00001CBF                 mov     ecx, [edx-8]
.text$x:00001CC2                 xor     ecx, eax
.text$x:00001CC4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001CC9                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00001CCE                 jmp     ___CxxFrameHandler3
.text$x:00001CCE __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00001CCE
.text$x:00001CCE ; ---------------------------------------------------------------------------
.text$x:00001CD3                 align 4
.text$x:00001CD3 _text$x         ends
.text$x:00001CD3
.text$mn:00001CD4 ; ===========================================================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Segment type: Pure code
.text$mn:00001CD4 ; Segment permissions: Read/Execute
.text$mn:00001CD4 _text$mn        segment para public 'CODE' use32
.text$mn:00001CD4                 assume cs:_text$mn
.text$mn:00001CD4                 ;org 1CD4h
.text$mn:00001CD4 ; COMDAT (pick any)
.text$mn:00001CD4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001CD4
.text$mn:00001CD4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001CD4
.text$mn:00001CD4 ; Attributes: bp-based frame
.text$mn:00001CD4
.text$mn:00001CD4 ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00001CD4                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:00001CD4 ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:00001CD4                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00001CD4                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00001CD4
.text$mn:00001CD4 var_10          = dword ptr -10h
.text$mn:00001CD4 var_C           = dword ptr -0Ch
.text$mn:00001CD4 var_4           = dword ptr -4
.text$mn:00001CD4
.text$mn:00001CD4                 push    ebp
.text$mn:00001CD5                 mov     ebp, esp
.text$mn:00001CD7                 push    0FFFFFFFFh
.text$mn:00001CD9                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00001CDE                 mov     eax, large fs:0
.text$mn:00001CE4                 push    eax
.text$mn:00001CE5                 push    ecx
.text$mn:00001CE6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00001CEB                 xor     eax, ebp
.text$mn:00001CED                 push    eax
.text$mn:00001CEE                 lea     eax, [ebp+var_C]
.text$mn:00001CF1                 mov     large fs:0, eax
.text$mn:00001CF7                 mov     [ebp+var_10], ecx
.text$mn:00001CFA                 mov     [ebp+var_4], 0
.text$mn:00001D01                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001D08                 mov     ecx, [ebp+var_10] ; this
.text$mn:00001D0B                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001D10                 mov     ecx, [ebp+var_C]
.text$mn:00001D13                 mov     large fs:0, ecx
.text$mn:00001D1A                 pop     ecx
.text$mn:00001D1B                 mov     esp, ebp
.text$mn:00001D1D                 pop     ebp
.text$mn:00001D1E                 retn
.text$mn:00001D1E ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00001D1E
.text$mn:00001D1E ; ---------------------------------------------------------------------------
.text$mn:00001D1F                 align 10h
.text$mn:00001D1F _text$mn        ends
.text$mn:00001D1F
.text$x:00001D20 ; ===========================================================================
.text$x:00001D20
.text$x:00001D20 ; Segment type: Pure code
.text$x:00001D20 ; Segment permissions: Read/Execute
.text$x:00001D20 _text$x         segment para public 'CODE' use32
.text$x:00001D20                 assume cs:_text$x
.text$x:00001D20                 ;org 1D20h
.text$x:00001D20 ; COMDAT (pick associative to section at 1CD4)
.text$x:00001D20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00001D20
.text$x:00001D20 ; =============== S U B R O U T I N E =======================================
.text$x:00001D20
.text$x:00001D20
.text$x:00001D20 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00001D20                                         ; DATA XREF: .xdata$x:0000317Co
.text$x:00001D20                 mov     ecx, [ebp-10h]  ; this
.text$x:00001D23                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00001D23 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:00001D23
.text$x:00001D28
.text$x:00001D28 ; =============== S U B R O U T I N E =======================================
.text$x:00001D28
.text$x:00001D28
.text$x:00001D28 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00001D28                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00001D28
.text$x:00001D28 arg_4           = dword ptr  8
.text$x:00001D28
.text$x:00001D28                 mov     edx, [esp+arg_4]
.text$x:00001D2C                 lea     eax, [edx+0Ch]
.text$x:00001D2F                 mov     ecx, [edx-8]
.text$x:00001D32                 xor     ecx, eax
.text$x:00001D34                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001D39                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00001D3E                 jmp     ___CxxFrameHandler3
.text$x:00001D3E __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00001D3E
.text$x:00001D3E ; ---------------------------------------------------------------------------
.text$x:00001D43                 align 4
.text$x:00001D43 _text$x         ends
.text$x:00001D43
.text$mn:00001D44 ; ===========================================================================
.text$mn:00001D44
.text$mn:00001D44 ; Segment type: Pure code
.text$mn:00001D44 ; Segment permissions: Read/Execute
.text$mn:00001D44 _text$mn        segment para public 'CODE' use32
.text$mn:00001D44                 assume cs:_text$mn
.text$mn:00001D44                 ;org 1D44h
.text$mn:00001D44 ; COMDAT (pick any)
.text$mn:00001D44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D44
.text$mn:00001D44 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D44
.text$mn:00001D44 ; Attributes: bp-based frame
.text$mn:00001D44
.text$mn:00001D44 ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:00001D44                 public ??1error_category@std@@UAE@XZ
.text$mn:00001D44 ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:00001D44                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:00001D44
.text$mn:00001D44 var_4           = dword ptr -4
.text$mn:00001D44
.text$mn:00001D44                 push    ebp
.text$mn:00001D45                 mov     ebp, esp
.text$mn:00001D47                 push    ecx
.text$mn:00001D48                 mov     [ebp+var_4], ecx
.text$mn:00001D4B                 mov     eax, [ebp+var_4]
.text$mn:00001D4E                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00001D54                 mov     esp, ebp
.text$mn:00001D56                 pop     ebp
.text$mn:00001D57                 retn
.text$mn:00001D57 ??1error_category@std@@UAE@XZ endp
.text$mn:00001D57
.text$mn:00001D57 _text$mn        ends
.text$mn:00001D57
.text$mn:00001D58 ; ===========================================================================
.text$mn:00001D58
.text$mn:00001D58 ; Segment type: Pure code
.text$mn:00001D58 ; Segment permissions: Read/Execute
.text$mn:00001D58 _text$mn        segment para public 'CODE' use32
.text$mn:00001D58                 assume cs:_text$mn
.text$mn:00001D58                 ;org 1D58h
.text$mn:00001D58 ; COMDAT (pick any)
.text$mn:00001D58                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D58
.text$mn:00001D58 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D58
.text$mn:00001D58 ; Attributes: bp-based frame
.text$mn:00001D58
.text$mn:00001D58 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00001D58                 public ??2@YAPAXIPAX@Z
.text$mn:00001D58 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00001D58                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00001D58
.text$mn:00001D58 arg_4           = dword ptr  0Ch
.text$mn:00001D58
.text$mn:00001D58                 push    ebp
.text$mn:00001D59                 mov     ebp, esp
.text$mn:00001D5B                 mov     eax, [ebp+arg_4]
.text$mn:00001D5E                 pop     ebp
.text$mn:00001D5F                 retn
.text$mn:00001D5F ??2@YAPAXIPAX@Z endp
.text$mn:00001D5F
.text$mn:00001D5F _text$mn        ends
.text$mn:00001D5F
.text$mn:00001D60 ; ===========================================================================
.text$mn:00001D60
.text$mn:00001D60 ; Segment type: Pure code
.text$mn:00001D60 ; Segment permissions: Read/Execute
.text$mn:00001D60 _text$mn        segment para public 'CODE' use32
.text$mn:00001D60                 assume cs:_text$mn
.text$mn:00001D60                 ;org 1D60h
.text$mn:00001D60 ; COMDAT (pick any)
.text$mn:00001D60                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D60
.text$mn:00001D60 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D60
.text$mn:00001D60 ; Attributes: bp-based frame
.text$mn:00001D60
.text$mn:00001D60 ; void __cdecl operator delete(void *)
.text$mn:00001D60                 public ??3@YAXPAX0@Z
.text$mn:00001D60 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00001D60                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00001D60                 push    ebp
.text$mn:00001D61                 mov     ebp, esp
.text$mn:00001D63                 pop     ebp
.text$mn:00001D64                 retn
.text$mn:00001D64 ??3@YAXPAX0@Z   endp
.text$mn:00001D64
.text$mn:00001D64 ; ---------------------------------------------------------------------------
.text$mn:00001D65                 align 4
.text$mn:00001D65 _text$mn        ends
.text$mn:00001D65
.text$mn:00001D68 ; ===========================================================================
.text$mn:00001D68
.text$mn:00001D68 ; Segment type: Pure code
.text$mn:00001D68 ; Segment permissions: Read/Execute
.text$mn:00001D68 _text$mn        segment para public 'CODE' use32
.text$mn:00001D68                 assume cs:_text$mn
.text$mn:00001D68                 ;org 1D68h
.text$mn:00001D68 ; COMDAT (pick any)
.text$mn:00001D68                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D68
.text$mn:00001D68 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D68
.text$mn:00001D68 ; Attributes: bp-based frame
.text$mn:00001D68
.text$mn:00001D68 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:00001D68                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:00001D68 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:00001D68                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:00001D68                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:00001D68
.text$mn:00001D68 var_8           = dword ptr -8
.text$mn:00001D68 var_4           = dword ptr -4
.text$mn:00001D68 arg_0           = dword ptr  8
.text$mn:00001D68
.text$mn:00001D68                 push    ebp
.text$mn:00001D69                 mov     ebp, esp
.text$mn:00001D6B                 sub     esp, 8
.text$mn:00001D6E                 mov     [ebp+var_8], ecx
.text$mn:00001D71                 mov     eax, [ebp+var_8]
.text$mn:00001D74                 cmp     eax, [ebp+arg_0]
.text$mn:00001D77                 jnz     short loc_1D82
.text$mn:00001D79                 mov     [ebp+var_4], 1
.text$mn:00001D80                 jmp     short loc_1D89
.text$mn:00001D82 ; ---------------------------------------------------------------------------
.text$mn:00001D82
.text$mn:00001D82 loc_1D82:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:00001D82                 mov     [ebp+var_4], 0
.text$mn:00001D89
.text$mn:00001D89 loc_1D89:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:00001D89                 mov     al, byte ptr [ebp+var_4]
.text$mn:00001D8C                 mov     esp, ebp
.text$mn:00001D8E                 pop     ebp
.text$mn:00001D8F                 retn    4
.text$mn:00001D8F ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:00001D8F
.text$mn:00001D8F ; ---------------------------------------------------------------------------
.text$mn:00001D92                 align 4
.text$mn:00001D92 _text$mn        ends
.text$mn:00001D92
.text$mn:00001D94 ; ===========================================================================
.text$mn:00001D94
.text$mn:00001D94 ; Segment type: Pure code
.text$mn:00001D94 ; Segment permissions: Read/Execute
.text$mn:00001D94 _text$mn        segment para public 'CODE' use32
.text$mn:00001D94                 assume cs:_text$mn
.text$mn:00001D94                 ;org 1D94h
.text$mn:00001D94 ; COMDAT (pick any)
.text$mn:00001D94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001D94
.text$mn:00001D94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D94
.text$mn:00001D94 ; Attributes: bp-based frame
.text$mn:00001D94
.text$mn:00001D94 ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:00001D94                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:00001D94 ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:00001D94                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:00001D94
.text$mn:00001D94 var_8           = dword ptr -8
.text$mn:00001D94 var_4           = dword ptr -4
.text$mn:00001D94 arg_0           = dword ptr  8
.text$mn:00001D94
.text$mn:00001D94                 push    ebp
.text$mn:00001D95                 mov     ebp, esp
.text$mn:00001D97                 sub     esp, 8
.text$mn:00001D9A                 push    esi
.text$mn:00001D9B                 mov     [ebp+var_4], ecx
.text$mn:00001D9E                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001DA1                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001DA6                 push    eax
.text$mn:00001DA7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001DAA                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00001DAF                 mov     ecx, eax
.text$mn:00001DB1                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00001DB6                 movzx   eax, al
.text$mn:00001DB9                 test    eax, eax
.text$mn:00001DBB                 jz      short loc_1DDC
.text$mn:00001DBD                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001DC0                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001DC5                 mov     esi, eax
.text$mn:00001DC7                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00001DCA                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00001DCF                 cmp     esi, eax
.text$mn:00001DD1                 jnz     short loc_1DDC
.text$mn:00001DD3                 mov     [ebp+var_8], 1
.text$mn:00001DDA                 jmp     short loc_1DE3
.text$mn:00001DDC ; ---------------------------------------------------------------------------
.text$mn:00001DDC
.text$mn:00001DDC loc_1DDC:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00001DDC                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00001DDC                 mov     [ebp+var_8], 0
.text$mn:00001DE3
.text$mn:00001DE3 loc_1DE3:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:00001DE3                 mov     al, byte ptr [ebp+var_8]
.text$mn:00001DE6                 pop     esi
.text$mn:00001DE7                 mov     esp, ebp
.text$mn:00001DE9                 pop     ebp
.text$mn:00001DEA                 retn    4
.text$mn:00001DEA ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00001DEA
.text$mn:00001DEA ; ---------------------------------------------------------------------------
.text$mn:00001DED                 align 10h
.text$mn:00001DED _text$mn        ends
.text$mn:00001DED
.text$mn:00001DF0 ; ===========================================================================
.text$mn:00001DF0
.text$mn:00001DF0 ; Segment type: Pure code
.text$mn:00001DF0 ; Segment permissions: Read/Execute
.text$mn:00001DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00001DF0                 assume cs:_text$mn
.text$mn:00001DF0                 ;org 1DF0h
.text$mn:00001DF0 ; COMDAT (pick any)
.text$mn:00001DF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001DF0
.text$mn:00001DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DF0
.text$mn:00001DF0 ; Attributes: bp-based frame
.text$mn:00001DF0
.text$mn:00001DF0 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001DF0                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00001DF0 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001DF0
.text$mn:00001DF0 var_4           = dword ptr -4
.text$mn:00001DF0 arg_0           = dword ptr  8
.text$mn:00001DF0
.text$mn:00001DF0                 push    ebp
.text$mn:00001DF1                 mov     ebp, esp
.text$mn:00001DF3                 push    ecx
.text$mn:00001DF4                 mov     [ebp+var_4], ecx
.text$mn:00001DF7                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001DFA                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00001DFF                 mov     eax, [ebp+arg_0]
.text$mn:00001E02                 and     eax, 1
.text$mn:00001E05                 jz      short loc_1E13
.text$mn:00001E07                 mov     ecx, [ebp+var_4]
.text$mn:00001E0A                 push    ecx             ; void *
.text$mn:00001E0B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E10                 add     esp, 4
.text$mn:00001E13
.text$mn:00001E13 loc_1E13:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001E13                 mov     eax, [ebp+var_4]
.text$mn:00001E16                 mov     esp, ebp
.text$mn:00001E18                 pop     ebp
.text$mn:00001E19                 retn    4
.text$mn:00001E19 ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:00001E19
.text$mn:00001E19 _text$mn        ends
.text$mn:00001E19
.text$mn:00001E1C ; ===========================================================================
.text$mn:00001E1C
.text$mn:00001E1C ; Segment type: Pure code
.text$mn:00001E1C ; Segment permissions: Read/Execute
.text$mn:00001E1C _text$mn        segment para public 'CODE' use32
.text$mn:00001E1C                 assume cs:_text$mn
.text$mn:00001E1C                 ;org 1E1Ch
.text$mn:00001E1C ; COMDAT (pick any)
.text$mn:00001E1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E1C
.text$mn:00001E1C ; =============== S U B R O U T I N E =======================================
.text$mn:00001E1C
.text$mn:00001E1C ; Attributes: bp-based frame
.text$mn:00001E1C
.text$mn:00001E1C ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001E1C                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00001E1C ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001E1C
.text$mn:00001E1C var_4           = dword ptr -4
.text$mn:00001E1C arg_0           = dword ptr  8
.text$mn:00001E1C
.text$mn:00001E1C                 push    ebp
.text$mn:00001E1D                 mov     ebp, esp
.text$mn:00001E1F                 push    ecx
.text$mn:00001E20                 mov     [ebp+var_4], ecx
.text$mn:00001E23                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E26                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:00001E2B                 mov     eax, [ebp+arg_0]
.text$mn:00001E2E                 and     eax, 1
.text$mn:00001E31                 jz      short loc_1E3F
.text$mn:00001E33                 mov     ecx, [ebp+var_4]
.text$mn:00001E36                 push    ecx             ; void *
.text$mn:00001E37                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E3C                 add     esp, 4
.text$mn:00001E3F
.text$mn:00001E3F loc_1E3F:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001E3F                 mov     eax, [ebp+var_4]
.text$mn:00001E42                 mov     esp, ebp
.text$mn:00001E44                 pop     ebp
.text$mn:00001E45                 retn    4
.text$mn:00001E45 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00001E45
.text$mn:00001E45 _text$mn        ends
.text$mn:00001E45
.text$mn:00001E48 ; ===========================================================================
.text$mn:00001E48
.text$mn:00001E48 ; Segment type: Pure code
.text$mn:00001E48 ; Segment permissions: Read/Execute
.text$mn:00001E48 _text$mn        segment para public 'CODE' use32
.text$mn:00001E48                 assume cs:_text$mn
.text$mn:00001E48                 ;org 1E48h
.text$mn:00001E48 ; COMDAT (pick any)
.text$mn:00001E48                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E48
.text$mn:00001E48 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E48
.text$mn:00001E48 ; Attributes: bp-based frame
.text$mn:00001E48
.text$mn:00001E48 ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001E48                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:00001E48 ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:00001E48
.text$mn:00001E48 var_4           = dword ptr -4
.text$mn:00001E48 arg_0           = dword ptr  8
.text$mn:00001E48
.text$mn:00001E48                 push    ebp
.text$mn:00001E49                 mov     ebp, esp
.text$mn:00001E4B                 push    ecx
.text$mn:00001E4C                 mov     [ebp+var_4], ecx
.text$mn:00001E4F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E52                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:00001E57                 mov     eax, [ebp+arg_0]
.text$mn:00001E5A                 and     eax, 1
.text$mn:00001E5D                 jz      short loc_1E6B
.text$mn:00001E5F                 mov     ecx, [ebp+var_4]
.text$mn:00001E62                 push    ecx             ; void *
.text$mn:00001E63                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E68                 add     esp, 4
.text$mn:00001E6B
.text$mn:00001E6B loc_1E6B:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001E6B                 mov     eax, [ebp+var_4]
.text$mn:00001E6E                 mov     esp, ebp
.text$mn:00001E70                 pop     ebp
.text$mn:00001E71                 retn    4
.text$mn:00001E71 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00001E71
.text$mn:00001E71 _text$mn        ends
.text$mn:00001E71
.text$mn:00001E74 ; ===========================================================================
.text$mn:00001E74
.text$mn:00001E74 ; Segment type: Pure code
.text$mn:00001E74 ; Segment permissions: Read/Execute
.text$mn:00001E74 _text$mn        segment para public 'CODE' use32
.text$mn:00001E74                 assume cs:_text$mn
.text$mn:00001E74                 ;org 1E74h
.text$mn:00001E74 ; COMDAT (pick any)
.text$mn:00001E74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001E74
.text$mn:00001E74 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E74
.text$mn:00001E74 ; Attributes: bp-based frame
.text$mn:00001E74
.text$mn:00001E74 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00001E74                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00001E74 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00001E74
.text$mn:00001E74 var_4           = dword ptr -4
.text$mn:00001E74 arg_0           = dword ptr  8
.text$mn:00001E74
.text$mn:00001E74                 push    ebp
.text$mn:00001E75                 mov     ebp, esp
.text$mn:00001E77                 push    ecx
.text$mn:00001E78                 mov     [ebp+var_4], ecx
.text$mn:00001E7B                 mov     ecx, [ebp+var_4] ; this
.text$mn:00001E7E                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:00001E83                 mov     eax, [ebp+arg_0]
.text$mn:00001E86                 and     eax, 1
.text$mn:00001E89                 jz      short loc_1E97
.text$mn:00001E8B                 mov     ecx, [ebp+var_4]
.text$mn:00001E8E                 push    ecx             ; void *
.text$mn:00001E8F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00001E94                 add     esp, 4
.text$mn:00001E97
.text$mn:00001E97 loc_1E97:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00001E97                 mov     eax, [ebp+var_4]
.text$mn:00001E9A                 mov     esp, ebp
.text$mn:00001E9C                 pop     ebp
.text$mn:00001E9D                 retn    4
.text$mn:00001E9D ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:00001E9D
.text$mn:00001E9D _text$mn        ends
.text$mn:00001E9D
.text$di:00001EA0 ; ===========================================================================
.text$di:00001EA0
.text$di:00001EA0 ; Segment type: Pure code
.text$di:00001EA0 ; Segment permissions: Read/Execute
.text$di:00001EA0 _text$di        segment para public 'CODE' use32
.text$di:00001EA0                 assume cs:_text$di
.text$di:00001EA0                 ;org 1EA0h
.text$di:00001EA0 ; COMDAT (pick any)
.text$di:00001EA0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001EA0
.text$di:00001EA0 ; =============== S U B R O U T I N E =======================================
.text$di:00001EA0
.text$di:00001EA0 ; Attributes: bp-based frame
.text$di:00001EA0
.text$di:00001EA0 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:00001EA0 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:00001EA0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:00001EA0                 push    ebp
.text$di:00001EA1                 mov     ebp, esp
.text$di:00001EA3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:00001EA8                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:00001EAD                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001EB2                 call    _atexit
.text$di:00001EB7                 add     esp, 4
.text$di:00001EBA                 pop     ebp
.text$di:00001EBB                 retn
.text$di:00001EBB ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00001EBB
.text$di:00001EBB _text$di        ends
.text$di:00001EBB
.text$di:00001EBC ; ===========================================================================
.text$di:00001EBC
.text$di:00001EBC ; Segment type: Pure code
.text$di:00001EBC ; Segment permissions: Read/Execute
.text$di:00001EBC _text$di        segment para public 'CODE' use32
.text$di:00001EBC                 assume cs:_text$di
.text$di:00001EBC                 ;org 1EBCh
.text$di:00001EBC ; COMDAT (pick any)
.text$di:00001EBC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001EBC
.text$di:00001EBC ; =============== S U B R O U T I N E =======================================
.text$di:00001EBC
.text$di:00001EBC ; Attributes: bp-based frame
.text$di:00001EBC
.text$di:00001EBC ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00001EBC ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00001EBC                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00001EBC                 push    ebp
.text$di:00001EBD                 mov     ebp, esp
.text$di:00001EBF                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00001EC4                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00001EC9                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001ECE                 call    _atexit
.text$di:00001ED3                 add     esp, 4
.text$di:00001ED6                 pop     ebp
.text$di:00001ED7                 retn
.text$di:00001ED7 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00001ED7
.text$di:00001ED7 _text$di        ends
.text$di:00001ED7
.text$di:00001ED8 ; ===========================================================================
.text$di:00001ED8
.text$di:00001ED8 ; Segment type: Pure code
.text$di:00001ED8 ; Segment permissions: Read/Execute
.text$di:00001ED8 _text$di        segment para public 'CODE' use32
.text$di:00001ED8                 assume cs:_text$di
.text$di:00001ED8                 ;org 1ED8h
.text$di:00001ED8 ; COMDAT (pick any)
.text$di:00001ED8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001ED8
.text$di:00001ED8 ; =============== S U B R O U T I N E =======================================
.text$di:00001ED8
.text$di:00001ED8 ; Attributes: bp-based frame
.text$di:00001ED8
.text$di:00001ED8 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00001ED8 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00001ED8                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00001ED8                 push    ebp
.text$di:00001ED9                 mov     ebp, esp
.text$di:00001EDB                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00001EE0                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00001EE5                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00001EEA                 call    _atexit
.text$di:00001EEF                 add     esp, 4
.text$di:00001EF2                 pop     ebp
.text$di:00001EF3                 retn
.text$di:00001EF3 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00001EF3
.text$di:00001EF3 _text$di        ends
.text$di:00001EF3
.text$di:00001EF4 ; ===========================================================================
.text$di:00001EF4
.text$di:00001EF4 ; Segment type: Pure code
.text$di:00001EF4 ; Segment permissions: Read/Execute
.text$di:00001EF4 _text$di        segment para public 'CODE' use32
.text$di:00001EF4                 assume cs:_text$di
.text$di:00001EF4                 ;org 1EF4h
.text$di:00001EF4 ; COMDAT (pick any)
.text$di:00001EF4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001EF4
.text$di:00001EF4 ; =============== S U B R O U T I N E =======================================
.text$di:00001EF4
.text$di:00001EF4 ; Attributes: bp-based frame
.text$di:00001EF4
.text$di:00001EF4 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00001EF4 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001EF4                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00001EF4                 push    ebp
.text$di:00001EF5                 mov     ebp, esp
.text$di:00001EF7                 push    0               ; unsigned int
.text$di:00001EF9                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001EFE                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001F03                 pop     ebp
.text$di:00001F04                 retn
.text$di:00001F04 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001F04
.text$di:00001F04 ; ---------------------------------------------------------------------------
.text$di:00001F05                 align 4
.text$di:00001F05 _text$di        ends
.text$di:00001F05
.text$di:00001F08 ; ===========================================================================
.text$di:00001F08
.text$di:00001F08 ; Segment type: Pure code
.text$di:00001F08 ; Segment permissions: Read/Execute
.text$di:00001F08 _text$di        segment para public 'CODE' use32
.text$di:00001F08                 assume cs:_text$di
.text$di:00001F08                 ;org 1F08h
.text$di:00001F08 ; COMDAT (pick any)
.text$di:00001F08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F08
.text$di:00001F08 ; =============== S U B R O U T I N E =======================================
.text$di:00001F08
.text$di:00001F08 ; Attributes: bp-based frame
.text$di:00001F08
.text$di:00001F08 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00001F08 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001F08                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00001F08                 push    ebp
.text$di:00001F09                 mov     ebp, esp
.text$di:00001F0B                 push    0               ; unsigned int
.text$di:00001F0D                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00001F12                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001F17                 pop     ebp
.text$di:00001F18                 retn
.text$di:00001F18 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001F18
.text$di:00001F18 ; ---------------------------------------------------------------------------
.text$di:00001F19                 align 4
.text$di:00001F19 _text$di        ends
.text$di:00001F19
.text$di:00001F1C ; ===========================================================================
.text$di:00001F1C
.text$di:00001F1C ; Segment type: Pure code
.text$di:00001F1C ; Segment permissions: Read/Execute
.text$di:00001F1C _text$di        segment para public 'CODE' use32
.text$di:00001F1C                 assume cs:_text$di
.text$di:00001F1C                 ;org 1F1Ch
.text$di:00001F1C ; COMDAT (pick any)
.text$di:00001F1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F1C
.text$di:00001F1C ; =============== S U B R O U T I N E =======================================
.text$di:00001F1C
.text$di:00001F1C ; Attributes: bp-based frame
.text$di:00001F1C
.text$di:00001F1C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00001F1C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001F1C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00001F1C                 push    ebp
.text$di:00001F1D                 mov     ebp, esp
.text$di:00001F1F                 push    0               ; unsigned int
.text$di:00001F21                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00001F26                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001F2B                 pop     ebp
.text$di:00001F2C                 retn
.text$di:00001F2C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001F2C
.text$di:00001F2C ; ---------------------------------------------------------------------------
.text$di:00001F2D                 align 10h
.text$di:00001F2D _text$di        ends
.text$di:00001F2D
.text$di:00001F30 ; ===========================================================================
.text$di:00001F30
.text$di:00001F30 ; Segment type: Pure code
.text$di:00001F30 ; Segment permissions: Read/Execute
.text$di:00001F30 _text$di        segment para public 'CODE' use32
.text$di:00001F30                 assume cs:_text$di
.text$di:00001F30                 ;org 1F30h
.text$di:00001F30 ; COMDAT (pick any)
.text$di:00001F30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F30
.text$di:00001F30 ; =============== S U B R O U T I N E =======================================
.text$di:00001F30
.text$di:00001F30 ; Attributes: bp-based frame
.text$di:00001F30
.text$di:00001F30 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00001F30 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00001F30                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00001F30                 push    ebp
.text$di:00001F31                 mov     ebp, esp
.text$di:00001F33                 push    0               ; unsigned int
.text$di:00001F35                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00001F3A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00001F3F                 pop     ebp
.text$di:00001F40                 retn
.text$di:00001F40 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00001F40
.text$di:00001F40 ; ---------------------------------------------------------------------------
.text$di:00001F41                 align 4
.text$di:00001F41 _text$di        ends
.text$di:00001F41
.text$di:00001F44 ; ===========================================================================
.text$di:00001F44
.text$di:00001F44 ; Segment type: Pure code
.text$di:00001F44 ; Segment permissions: Read/Execute
.text$di:00001F44 _text$di        segment para public 'CODE' use32
.text$di:00001F44                 assume cs:_text$di
.text$di:00001F44                 ;org 1F44h
.text$di:00001F44 ; COMDAT (pick any)
.text$di:00001F44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F44
.text$di:00001F44 ; =============== S U B R O U T I N E =======================================
.text$di:00001F44
.text$di:00001F44 ; Attributes: bp-based frame
.text$di:00001F44
.text$di:00001F44 ; void __cdecl std::`dynamic initializer for '_Tuple_alloc''(void)
.text$di:00001F44 ??__E_Tuple_alloc@std@@YAXXZ proc near  ; DATA XREF: .CRT$XCU:__Tuple_alloc$initializer$o
.text$di:00001F44
.text$di:00001F44 var_1           = byte ptr -1
.text$di:00001F44
.text$di:00001F44                 push    ebp
.text$di:00001F45                 mov     ebp, esp
.text$di:00001F47                 push    ecx
.text$di:00001F48                 xor     eax, eax
.text$di:00001F4A                 mov     [ebp+var_1], al
.text$di:00001F4D                 mov     esp, ebp
.text$di:00001F4F                 pop     ebp
.text$di:00001F50                 retn
.text$di:00001F50 ??__E_Tuple_alloc@std@@YAXXZ endp
.text$di:00001F50
.text$di:00001F50 ; ---------------------------------------------------------------------------
.text$di:00001F51                 align 4
.text$di:00001F51 _text$di        ends
.text$di:00001F51
.text$di:00001F54 ; ===========================================================================
.text$di:00001F54
.text$di:00001F54 ; Segment type: Pure code
.text$di:00001F54 ; Segment permissions: Read/Execute
.text$di:00001F54 _text$di        segment para public 'CODE' use32
.text$di:00001F54                 assume cs:_text$di
.text$di:00001F54                 ;org 1F54h
.text$di:00001F54 ; COMDAT (pick any)
.text$di:00001F54                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F54
.text$di:00001F54 ; =============== S U B R O U T I N E =======================================
.text$di:00001F54
.text$di:00001F54 ; Attributes: bp-based frame
.text$di:00001F54
.text$di:00001F54 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00001F54 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00001F54
.text$di:00001F54 var_1           = byte ptr -1
.text$di:00001F54
.text$di:00001F54                 push    ebp
.text$di:00001F55                 mov     ebp, esp
.text$di:00001F57                 push    ecx
.text$di:00001F58                 xor     eax, eax
.text$di:00001F5A                 mov     [ebp+var_1], al
.text$di:00001F5D                 mov     esp, ebp
.text$di:00001F5F                 pop     ebp
.text$di:00001F60                 retn
.text$di:00001F60 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00001F60
.text$di:00001F60 ; ---------------------------------------------------------------------------
.text$di:00001F61                 align 4
.text$di:00001F61 _text$di        ends
.text$di:00001F61
.text$di:00001F64 ; ===========================================================================
.text$di:00001F64
.text$di:00001F64 ; Segment type: Pure code
.text$di:00001F64 ; Segment permissions: Read/Execute
.text$di:00001F64 _text$di        segment para public 'CODE' use32
.text$di:00001F64                 assume cs:_text$di
.text$di:00001F64                 ;org 1F64h
.text$di:00001F64 ; COMDAT (pick any)
.text$di:00001F64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F64
.text$di:00001F64 ; =============== S U B R O U T I N E =======================================
.text$di:00001F64
.text$di:00001F64 ; Attributes: bp-based frame
.text$di:00001F64
.text$di:00001F64 ; void __cdecl std::`dynamic initializer for 'ignore''(void)
.text$di:00001F64 ??__Eignore@std@@YAXXZ proc near        ; DATA XREF: .CRT$XCU:_ignore$initializer$o
.text$di:00001F64                 push    ebp
.text$di:00001F65                 mov     ebp, esp
.text$di:00001F67                 mov     ecx, offset _ignore ; this
.text$di:00001F6C                 call    ??0_Ignore@std@@QAE@XZ ; std::_Ignore::_Ignore(void)
.text$di:00001F71                 pop     ebp
.text$di:00001F72                 retn
.text$di:00001F72 ??__Eignore@std@@YAXXZ endp
.text$di:00001F72
.text$di:00001F72 ; ---------------------------------------------------------------------------
.text$di:00001F73                 align 4
.text$di:00001F73 _text$di        ends
.text$di:00001F73
.text$di:00001F74 ; ===========================================================================
.text$di:00001F74
.text$di:00001F74 ; Segment type: Pure code
.text$di:00001F74 ; Segment permissions: Read/Execute
.text$di:00001F74 _text$di        segment para public 'CODE' use32
.text$di:00001F74                 assume cs:_text$di
.text$di:00001F74                 ;org 1F74h
.text$di:00001F74 ; COMDAT (pick any)
.text$di:00001F74                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$di:00001F74
.text$di:00001F74 ; =============== S U B R O U T I N E =======================================
.text$di:00001F74
.text$di:00001F74 ; Attributes: bp-based frame
.text$di:00001F74
.text$di:00001F74 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00001F74 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00001F74                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00001F74
.text$di:00001F74 var_1           = byte ptr -1
.text$di:00001F74
.text$di:00001F74                 push    ebp
.text$di:00001F75                 mov     ebp, esp
.text$di:00001F77                 push    ecx
.text$di:00001F78                 xor     eax, eax
.text$di:00001F7A                 mov     [ebp+var_1], al
.text$di:00001F7D                 mov     esp, ebp
.text$di:00001F7F                 pop     ebp
.text$di:00001F80                 retn
.text$di:00001F80 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00001F80
.text$di:00001F80 ; ---------------------------------------------------------------------------
.text$di:00001F81                 align 4
.text$di:00001F81 _text$di        ends
.text$di:00001F81
.text$yd:00001F84 ; ===========================================================================
.text$yd:00001F84
.text$yd:00001F84 ; Segment type: Pure code
.text$yd:00001F84 ; Segment permissions: Read/Execute
.text$yd:00001F84 _text$yd        segment para public 'CODE' use32
.text$yd:00001F84                 assume cs:_text$yd
.text$yd:00001F84                 ;org 1F84h
.text$yd:00001F84 ; COMDAT (pick any)
.text$yd:00001F84                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001F84
.text$yd:00001F84 ; =============== S U B R O U T I N E =======================================
.text$yd:00001F84
.text$yd:00001F84 ; Attributes: bp-based frame
.text$yd:00001F84
.text$yd:00001F84 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00001F84 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00001F84                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00001F84                 push    ebp
.text$yd:00001F85                 mov     ebp, esp
.text$yd:00001F87                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00001F8C                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00001F91                 pop     ebp
.text$yd:00001F92                 retn
.text$yd:00001F92 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00001F92
.text$yd:00001F92 ; ---------------------------------------------------------------------------
.text$yd:00001F93                 align 4
.text$yd:00001F93 _text$yd        ends
.text$yd:00001F93
.text$yd:00001F94 ; ===========================================================================
.text$yd:00001F94
.text$yd:00001F94 ; Segment type: Pure code
.text$yd:00001F94 ; Segment permissions: Read/Execute
.text$yd:00001F94 _text$yd        segment para public 'CODE' use32
.text$yd:00001F94                 assume cs:_text$yd
.text$yd:00001F94                 ;org 1F94h
.text$yd:00001F94 ; COMDAT (pick any)
.text$yd:00001F94                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001F94
.text$yd:00001F94 ; =============== S U B R O U T I N E =======================================
.text$yd:00001F94
.text$yd:00001F94 ; Attributes: bp-based frame
.text$yd:00001F94
.text$yd:00001F94 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00001F94 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00001F94                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00001F94                 push    ebp
.text$yd:00001F95                 mov     ebp, esp
.text$yd:00001F97                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00001F9C                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00001FA1                 pop     ebp
.text$yd:00001FA2                 retn
.text$yd:00001FA2 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00001FA2
.text$yd:00001FA2 ; ---------------------------------------------------------------------------
.text$yd:00001FA3                 align 4
.text$yd:00001FA3 _text$yd        ends
.text$yd:00001FA3
.text$yd:00001FA4 ; ===========================================================================
.text$yd:00001FA4
.text$yd:00001FA4 ; Segment type: Pure code
.text$yd:00001FA4 ; Segment permissions: Read/Execute
.text$yd:00001FA4 _text$yd        segment para public 'CODE' use32
.text$yd:00001FA4                 assume cs:_text$yd
.text$yd:00001FA4                 ;org 1FA4h
.text$yd:00001FA4 ; COMDAT (pick any)
.text$yd:00001FA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$yd:00001FA4
.text$yd:00001FA4 ; =============== S U B R O U T I N E =======================================
.text$yd:00001FA4
.text$yd:00001FA4 ; Attributes: bp-based frame
.text$yd:00001FA4
.text$yd:00001FA4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00001FA4 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00001FA4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00001FA4                 push    ebp
.text$yd:00001FA5                 mov     ebp, esp
.text$yd:00001FA7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00001FAC                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00001FB1                 pop     ebp
.text$yd:00001FB2                 retn
.text$yd:00001FB2 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00001FB2
.text$yd:00001FB2 ; ---------------------------------------------------------------------------
.text$yd:00001FB3                 align 4
.text$yd:00001FB3 _text$yd        ends
.text$yd:00001FB3
.text$mn:00001FB4 ; ===========================================================================
.text$mn:00001FB4
.text$mn:00001FB4 ; Segment type: Pure code
.text$mn:00001FB4 ; Segment permissions: Read/Execute
.text$mn:00001FB4 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB4                 assume cs:_text$mn
.text$mn:00001FB4                 ;org 1FB4h
.text$mn:00001FB4 ; COMDAT (pick any)
.text$mn:00001FB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FB4
.text$mn:00001FB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB4
.text$mn:00001FB4 ; Attributes: bp-based frame
.text$mn:00001FB4
.text$mn:00001FB4 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00001FB4                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00001FB4 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00001FB4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00001FB4
.text$mn:00001FB4 var_10          = byte ptr -10h
.text$mn:00001FB4 var_8           = dword ptr -8
.text$mn:00001FB4 var_1           = byte ptr -1
.text$mn:00001FB4
.text$mn:00001FB4                 push    ebp
.text$mn:00001FB5                 mov     ebp, esp
.text$mn:00001FB7                 sub     esp, 10h
.text$mn:00001FBA                 mov     [ebp+var_8], ecx
.text$mn:00001FBD                 lea     ecx, [ebp+var_1]
.text$mn:00001FC0                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00001FC5                 push    1
.text$mn:00001FC7                 lea     ecx, [ebp+var_1]
.text$mn:00001FCA                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00001FCF                 mov     ecx, [ebp+var_8]
.text$mn:00001FD2                 mov     [ecx], eax
.text$mn:00001FD4                 lea     ecx, [ebp+var_10] ; this
.text$mn:00001FD7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00001FDC                 push    eax             ; int
.text$mn:00001FDD                 mov     edx, [ebp+var_8]
.text$mn:00001FE0                 mov     eax, [edx]
.text$mn:00001FE2                 push    eax             ; void *
.text$mn:00001FE3                 lea     ecx, [ebp+var_1]
.text$mn:00001FE6                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00001FEB                 mov     ecx, [ebp+var_8]
.text$mn:00001FEE                 mov     edx, [ecx]
.text$mn:00001FF0                 mov     eax, [ebp+var_8]
.text$mn:00001FF3                 mov     [edx], eax
.text$mn:00001FF5                 mov     esp, ebp
.text$mn:00001FF7                 pop     ebp
.text$mn:00001FF8                 retn
.text$mn:00001FF8 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00001FF8
.text$mn:00001FF8 ; ---------------------------------------------------------------------------
.text$mn:00001FF9                 align 4
.text$mn:00001FF9 _text$mn        ends
.text$mn:00001FF9
.text$mn:00001FFC ; ===========================================================================
.text$mn:00001FFC
.text$mn:00001FFC ; Segment type: Pure code
.text$mn:00001FFC ; Segment permissions: Read/Execute
.text$mn:00001FFC _text$mn        segment para public 'CODE' use32
.text$mn:00001FFC                 assume cs:_text$mn
.text$mn:00001FFC                 ;org 1FFCh
.text$mn:00001FFC ; COMDAT (pick any)
.text$mn:00001FFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00001FFC
.text$mn:00001FFC ; =============== S U B R O U T I N E =======================================
.text$mn:00001FFC
.text$mn:00001FFC ; Attributes: bp-based frame
.text$mn:00001FFC
.text$mn:00001FFC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00001FFC                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00001FFC ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00001FFC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00001FFC
.text$mn:00001FFC var_20          = dword ptr -20h
.text$mn:00001FFC var_1C          = dword ptr -1Ch
.text$mn:00001FFC var_18          = dword ptr -18h
.text$mn:00001FFC var_11          = byte ptr -11h
.text$mn:00001FFC var_10          = dword ptr -10h
.text$mn:00001FFC var_C           = byte ptr -0Ch
.text$mn:00001FFC var_4           = dword ptr -4
.text$mn:00001FFC arg_0           = dword ptr  8
.text$mn:00001FFC
.text$mn:00001FFC ; FUNCTION CHUNK AT .text$mn:0000211E SIZE 00000009 BYTES
.text$mn:00001FFC
.text$mn:00001FFC                 push    ebp
.text$mn:00001FFD                 mov     ebp, esp
.text$mn:00001FFF                 push    0FFFFFFFFh
.text$mn:00002001                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00002006                 mov     eax, large fs:0
.text$mn:0000200C                 push    eax
.text$mn:0000200D                 push    ecx
.text$mn:0000200E                 sub     esp, 10h
.text$mn:00002011                 push    ebx
.text$mn:00002012                 push    esi
.text$mn:00002013                 push    edi
.text$mn:00002014                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002019                 xor     eax, ebp
.text$mn:0000201B                 push    eax
.text$mn:0000201C                 lea     eax, [ebp+var_C]
.text$mn:0000201F                 mov     large fs:0, eax
.text$mn:00002025                 mov     [ebp+var_10], esp
.text$mn:00002028                 mov     [ebp+var_18], ecx
.text$mn:0000202B                 mov     eax, [ebp+arg_0]
.text$mn:0000202E                 or      eax, 0Fh
.text$mn:00002031                 mov     [ebp+var_1C], eax
.text$mn:00002034                 mov     ecx, [ebp+var_18]
.text$mn:00002037                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000203C                 cmp     eax, [ebp+var_1C]
.text$mn:0000203F                 jnb     short loc_2049
.text$mn:00002041                 mov     ecx, [ebp+arg_0]
.text$mn:00002044                 mov     [ebp+var_1C], ecx
.text$mn:00002047                 jmp     short loc_209B
.text$mn:00002049 ; ---------------------------------------------------------------------------
.text$mn:00002049
.text$mn:00002049 loc_2049:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00002049                 mov     edx, [ebp+var_18]
.text$mn:0000204C                 mov     ecx, [edx+18h]
.text$mn:0000204F                 shr     ecx, 1
.text$mn:00002051                 mov     eax, [ebp+var_1C]
.text$mn:00002054                 xor     edx, edx
.text$mn:00002056                 mov     esi, 3
.text$mn:0000205B                 div     esi
.text$mn:0000205D                 cmp     ecx, eax
.text$mn:0000205F                 ja      short loc_2063
.text$mn:00002061                 jmp     short loc_209B
.text$mn:00002063 ; ---------------------------------------------------------------------------
.text$mn:00002063
.text$mn:00002063 loc_2063:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00002063                 mov     ecx, [ebp+var_18]
.text$mn:00002066                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000206B                 mov     edx, [ebp+var_18]
.text$mn:0000206E                 mov     ecx, [edx+18h]
.text$mn:00002071                 shr     ecx, 1
.text$mn:00002073                 sub     eax, ecx
.text$mn:00002075                 mov     edx, [ebp+var_18]
.text$mn:00002078                 cmp     [edx+18h], eax
.text$mn:0000207B                 ja      short loc_2090
.text$mn:0000207D                 mov     eax, [ebp+var_18]
.text$mn:00002080                 mov     ecx, [eax+18h]
.text$mn:00002083                 shr     ecx, 1
.text$mn:00002085                 mov     edx, [ebp+var_18]
.text$mn:00002088                 add     ecx, [edx+18h]
.text$mn:0000208B                 mov     [ebp+var_1C], ecx
.text$mn:0000208E                 jmp     short loc_209B
.text$mn:00002090 ; ---------------------------------------------------------------------------
.text$mn:00002090
.text$mn:00002090 loc_2090:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00002090                 mov     ecx, [ebp+var_18]
.text$mn:00002093                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00002098                 mov     [ebp+var_1C], eax
.text$mn:0000209B
.text$mn:0000209B loc_209B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:0000209B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:0000209B                 mov     [ebp+var_4], 0
.text$mn:000020A2                 mov     eax, [ebp+var_1C]
.text$mn:000020A5                 add     eax, 1
.text$mn:000020A8                 push    eax
.text$mn:000020A9                 lea     ecx, [ebp+var_11]
.text$mn:000020AC                 push    ecx
.text$mn:000020AD                 mov     ecx, [ebp+var_18]
.text$mn:000020B0                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000020B5                 mov     ecx, eax
.text$mn:000020B7                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000020BC                 mov     [ebp+var_20], eax
.text$mn:000020BF                 jmp     short loc_211E
.text$mn:000020BF ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:000020BF
.text$mn:000020C1
.text$mn:000020C1 ; =============== S U B R O U T I N E =======================================
.text$mn:000020C1
.text$mn:000020C1
.text$mn:000020C1 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:000020C1                                         ; DATA XREF: .xdata$x:00002F98o
.text$mn:000020C1
.text$mn:000020C1 ; FUNCTION CHUNK AT .text$mn:00002108 SIZE 00000009 BYTES
.text$mn:000020C1 ; FUNCTION CHUNK AT .text$mn:00002118 SIZE 00000006 BYTES
.text$mn:000020C1
.text$mn:000020C1                 mov     [ebp-10h], esp
.text$mn:000020C4                 mov     edx, [ebp+8]
.text$mn:000020C7                 mov     [ebp-1Ch], edx
.text$mn:000020CA                 mov     byte ptr [ebp-4], 2
.text$mn:000020CE                 mov     eax, [ebp-1Ch]
.text$mn:000020D1                 add     eax, 1
.text$mn:000020D4                 push    eax
.text$mn:000020D5                 lea     ecx, [ebp-12h]
.text$mn:000020D8                 push    ecx
.text$mn:000020D9                 mov     ecx, [ebp-18h]
.text$mn:000020DC                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000020E1                 mov     ecx, eax
.text$mn:000020E3                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:000020E8                 mov     [ebp-20h], eax
.text$mn:000020EB                 jmp     short loc_2108
.text$mn:000020EB __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:000020EB
.text$mn:000020ED
.text$mn:000020ED ; =============== S U B R O U T I N E =======================================
.text$mn:000020ED
.text$mn:000020ED ; Attributes: noreturn
.text$mn:000020ED
.text$mn:000020ED __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:000020ED                                         ; DATA XREF: .xdata$x:00002FA8o
.text$mn:000020ED                 push    0               ; Size
.text$mn:000020EF                 push    1               ; char
.text$mn:000020F1                 mov     ecx, [ebp-18h]
.text$mn:000020F4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000020F9                 push    0
.text$mn:000020FB                 push    0
.text$mn:000020FD                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000020FD __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:000020FD
.text$mn:00002102 ; ---------------------------------------------------------------------------
.text$mn:00002102                 mov     eax, offset $LN17
.text$mn:00002107                 retn
.text$mn:00002108 ; ---------------------------------------------------------------------------
.text$mn:00002108 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002108
.text$mn:00002108 loc_2108:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00002108                 mov     dword ptr [ebp-4], 1
.text$mn:0000210F                 jmp     short loc_2118
.text$mn:0000210F ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002111
.text$mn:00002111 ; =============== S U B R O U T I N E =======================================
.text$mn:00002111
.text$mn:00002111
.text$mn:00002111 $LN17           proc near               ; DATA XREF: .text$mn:00002102o
.text$mn:00002111                 mov     dword ptr [ebp-4], 1
.text$mn:00002111 $LN17           endp ; sp-analysis failed
.text$mn:00002111
.text$mn:00002118 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00002118
.text$mn:00002118 loc_2118:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00002118                 mov     eax, offset $LN19
.text$mn:0000211D                 retn
.text$mn:0000211D ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:0000211E ; ---------------------------------------------------------------------------
.text$mn:0000211E ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:0000211E
.text$mn:0000211E loc_211E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:0000211E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002125                 jmp     short loc_212E
.text$mn:00002125 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00002127
.text$mn:00002127 ; =============== S U B R O U T I N E =======================================
.text$mn:00002127
.text$mn:00002127
.text$mn:00002127 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_2118o
.text$mn:00002127                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:0000212E
.text$mn:0000212E loc_212E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:0000212E                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00002132                 jbe     short loc_214D
.text$mn:00002134                 mov     edx, [ebp+0Ch]
.text$mn:00002137                 push    edx             ; Size
.text$mn:00002138                 mov     ecx, [ebp-18h]
.text$mn:0000213B                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002140                 push    eax             ; Src
.text$mn:00002141                 mov     eax, [ebp-20h]
.text$mn:00002144                 push    eax             ; Dst
.text$mn:00002145                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000214A                 add     esp, 0Ch
.text$mn:0000214D
.text$mn:0000214D loc_214D:                               ; CODE XREF: $LN19+Bj
.text$mn:0000214D                 push    0               ; Size
.text$mn:0000214F                 push    1               ; char
.text$mn:00002151                 mov     ecx, [ebp-18h]
.text$mn:00002154                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002159                 lea     ecx, [ebp-20h]
.text$mn:0000215C                 push    ecx             ; int
.text$mn:0000215D                 mov     edx, [ebp-18h]
.text$mn:00002160                 add     edx, 4
.text$mn:00002163                 push    edx             ; void *
.text$mn:00002164                 lea     eax, [ebp-13h]
.text$mn:00002167                 push    eax
.text$mn:00002168                 mov     ecx, [ebp-18h]
.text$mn:0000216B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002170                 mov     ecx, eax
.text$mn:00002172                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002177                 mov     ecx, [ebp-18h]
.text$mn:0000217A                 mov     edx, [ebp-1Ch]
.text$mn:0000217D                 mov     [ecx+18h], edx
.text$mn:00002180                 mov     eax, [ebp+0Ch]
.text$mn:00002183                 push    eax
.text$mn:00002184                 mov     ecx, [ebp-18h]
.text$mn:00002187                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000218C                 mov     ecx, [ebp-0Ch]
.text$mn:0000218F                 mov     large fs:0, ecx
.text$mn:00002196                 pop     ecx
.text$mn:00002197                 pop     edi
.text$mn:00002198                 pop     esi
.text$mn:00002199                 pop     ebx
.text$mn:0000219A                 mov     esp, ebp
.text$mn:0000219C                 pop     ebp
.text$mn:0000219D                 retn    8
.text$mn:0000219D $LN19           endp ; sp-analysis failed
.text$mn:0000219D
.text$mn:0000219D _text$mn        ends
.text$mn:0000219D
.text$x:000021A0 ; ===========================================================================
.text$x:000021A0
.text$x:000021A0 ; Segment type: Pure code
.text$x:000021A0 ; Segment permissions: Read/Execute
.text$x:000021A0 _text$x         segment para public 'CODE' use32
.text$x:000021A0                 assume cs:_text$x
.text$x:000021A0                 ;org 21A0h
.text$x:000021A0 ; COMDAT (pick associative to section at 1FFC)
.text$x:000021A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:000021A0
.text$x:000021A0 ; =============== S U B R O U T I N E =======================================
.text$x:000021A0
.text$x:000021A0
.text$x:000021A0 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:000021A0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:000021A0
.text$x:000021A0 arg_4           = dword ptr  8
.text$x:000021A0
.text$x:000021A0                 mov     edx, [esp+arg_4]
.text$x:000021A4                 lea     eax, [edx+0Ch]
.text$x:000021A7                 mov     ecx, [edx-24h]
.text$x:000021AA                 xor     ecx, eax
.text$x:000021AC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000021B1                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:000021B6                 jmp     ___CxxFrameHandler3
.text$x:000021B6 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:000021B6
.text$x:000021B6 ; ---------------------------------------------------------------------------
.text$x:000021BB                 align 4
.text$x:000021BB _text$x         ends
.text$x:000021BB
.text$mn:000021BC ; ===========================================================================
.text$mn:000021BC
.text$mn:000021BC ; Segment type: Pure code
.text$mn:000021BC ; Segment permissions: Read/Execute
.text$mn:000021BC _text$mn        segment para public 'CODE' use32
.text$mn:000021BC                 assume cs:_text$mn
.text$mn:000021BC                 ;org 21BCh
.text$mn:000021BC ; COMDAT (pick any)
.text$mn:000021BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021BC
.text$mn:000021BC ; =============== S U B R O U T I N E =======================================
.text$mn:000021BC
.text$mn:000021BC ; Attributes: bp-based frame
.text$mn:000021BC
.text$mn:000021BC ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:000021BC                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:000021BC ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:000021BC                                         ; CODE XREF: $LN19+60p
.text$mn:000021BC                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:000021BC
.text$mn:000021BC var_8           = dword ptr -8
.text$mn:000021BC var_1           = byte ptr -1
.text$mn:000021BC arg_0           = dword ptr  8
.text$mn:000021BC
.text$mn:000021BC                 push    ebp
.text$mn:000021BD                 mov     ebp, esp
.text$mn:000021BF                 sub     esp, 8
.text$mn:000021C2                 mov     [ebp+var_8], ecx
.text$mn:000021C5                 mov     [ebp+var_1], 0
.text$mn:000021C9                 mov     eax, [ebp+var_8]
.text$mn:000021CC                 mov     ecx, [ebp+arg_0]
.text$mn:000021CF                 mov     [eax+14h], ecx
.text$mn:000021D2                 lea     edx, [ebp+var_1]
.text$mn:000021D5                 push    edx
.text$mn:000021D6                 mov     ecx, [ebp+var_8]
.text$mn:000021D9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000021DE                 add     eax, [ebp+arg_0]
.text$mn:000021E1                 push    eax
.text$mn:000021E2                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:000021E7                 add     esp, 8
.text$mn:000021EA                 mov     esp, ebp
.text$mn:000021EC                 pop     ebp
.text$mn:000021ED                 retn    4
.text$mn:000021ED ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:000021ED
.text$mn:000021ED _text$mn        ends
.text$mn:000021ED
.text$mn:000021F0 ; ===========================================================================
.text$mn:000021F0
.text$mn:000021F0 ; Segment type: Pure code
.text$mn:000021F0 ; Segment permissions: Read/Execute
.text$mn:000021F0 _text$mn        segment para public 'CODE' use32
.text$mn:000021F0                 assume cs:_text$mn
.text$mn:000021F0                 ;org 21F0h
.text$mn:000021F0 ; COMDAT (pick any)
.text$mn:000021F0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000021F0
.text$mn:000021F0 ; =============== S U B R O U T I N E =======================================
.text$mn:000021F0
.text$mn:000021F0 ; Attributes: bp-based frame
.text$mn:000021F0
.text$mn:000021F0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:000021F0                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:000021F0 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:000021F0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:000021F0
.text$mn:000021F0 var_8           = dword ptr -8
.text$mn:000021F0 var_1           = byte ptr -1
.text$mn:000021F0
.text$mn:000021F0                 push    ebp
.text$mn:000021F1                 mov     ebp, esp
.text$mn:000021F3                 sub     esp, 8
.text$mn:000021F6                 mov     [ebp+var_8], ecx
.text$mn:000021F9                 lea     ecx, [ebp+var_1]
.text$mn:000021FC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002201                 mov     ecx, [ebp+var_8] ; this
.text$mn:00002204                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00002209                 mov     eax, [ebp+var_8]
.text$mn:0000220C                 mov     ecx, [eax]
.text$mn:0000220E                 push    ecx
.text$mn:0000220F                 lea     ecx, [ebp+var_1]
.text$mn:00002212                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00002217                 push    1               ; int
.text$mn:00002219                 mov     edx, [ebp+var_8]
.text$mn:0000221C                 mov     eax, [edx]
.text$mn:0000221E                 push    eax             ; void *
.text$mn:0000221F                 lea     ecx, [ebp+var_1]
.text$mn:00002222                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00002227                 mov     ecx, [ebp+var_8]
.text$mn:0000222A                 mov     dword ptr [ecx], 0
.text$mn:00002230                 mov     esp, ebp
.text$mn:00002232                 pop     ebp
.text$mn:00002233                 retn
.text$mn:00002233 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00002233
.text$mn:00002233 _text$mn        ends
.text$mn:00002233
.text$mn:00002234 ; ===========================================================================
.text$mn:00002234
.text$mn:00002234 ; Segment type: Pure code
.text$mn:00002234 ; Segment permissions: Read/Execute
.text$mn:00002234 _text$mn        segment para public 'CODE' use32
.text$mn:00002234                 assume cs:_text$mn
.text$mn:00002234                 ;org 2234h
.text$mn:00002234 ; COMDAT (pick any)
.text$mn:00002234                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002234
.text$mn:00002234 ; =============== S U B R O U T I N E =======================================
.text$mn:00002234
.text$mn:00002234 ; Attributes: bp-based frame
.text$mn:00002234
.text$mn:00002234 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00002234                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00002234 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00002234                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00002234                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00002234
.text$mn:00002234 var_4           = dword ptr -4
.text$mn:00002234 arg_0           = dword ptr  8
.text$mn:00002234
.text$mn:00002234                 push    ebp
.text$mn:00002235                 mov     ebp, esp
.text$mn:00002237                 push    ecx
.text$mn:00002238                 mov     [ebp+var_4], ecx
.text$mn:0000223B                 mov     ecx, [ebp+arg_0]
.text$mn:0000223E                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00002243                 mov     eax, [ebp+arg_0]
.text$mn:00002246                 mov     esp, ebp
.text$mn:00002248                 pop     ebp
.text$mn:00002249                 retn    4
.text$mn:00002249 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:00002249
.text$mn:00002249 _text$mn        ends
.text$mn:00002249
.text$mn:0000224C ; ===========================================================================
.text$mn:0000224C
.text$mn:0000224C ; Segment type: Pure code
.text$mn:0000224C ; Segment permissions: Read/Execute
.text$mn:0000224C _text$mn        segment para public 'CODE' use32
.text$mn:0000224C                 assume cs:_text$mn
.text$mn:0000224C                 ;org 224Ch
.text$mn:0000224C ; COMDAT (pick any)
.text$mn:0000224C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000224C
.text$mn:0000224C ; =============== S U B R O U T I N E =======================================
.text$mn:0000224C
.text$mn:0000224C ; Attributes: bp-based frame
.text$mn:0000224C
.text$mn:0000224C ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:0000224C                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:0000224C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:0000224C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:0000224C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:0000224C
.text$mn:0000224C var_C           = dword ptr -0Ch
.text$mn:0000224C Size            = dword ptr -8
.text$mn:0000224C var_4           = dword ptr -4
.text$mn:0000224C arg_0           = dword ptr  8
.text$mn:0000224C arg_4           = byte ptr  0Ch
.text$mn:0000224C
.text$mn:0000224C                 push    ebp
.text$mn:0000224D                 mov     ebp, esp
.text$mn:0000224F                 sub     esp, 0Ch
.text$mn:00002252                 mov     [ebp+var_4], ecx
.text$mn:00002255                 mov     ecx, [ebp+var_4]
.text$mn:00002258                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:0000225D                 cmp     eax, [ebp+arg_0]
.text$mn:00002260                 jnb     short loc_226A
.text$mn:00002262                 mov     ecx, [ebp+var_4]
.text$mn:00002265                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:0000226A
.text$mn:0000226A loc_226A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:0000226A                 mov     eax, [ebp+var_4]
.text$mn:0000226D                 mov     ecx, [eax+18h]
.text$mn:00002270                 cmp     ecx, [ebp+arg_0]
.text$mn:00002273                 jnb     short loc_228A
.text$mn:00002275                 mov     edx, [ebp+var_4]
.text$mn:00002278                 mov     eax, [edx+14h]
.text$mn:0000227B                 push    eax
.text$mn:0000227C                 mov     ecx, [ebp+arg_0]
.text$mn:0000227F                 push    ecx
.text$mn:00002280                 mov     ecx, [ebp+var_4]
.text$mn:00002283                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:00002288                 jmp     short loc_22D4
.text$mn:0000228A ; ---------------------------------------------------------------------------
.text$mn:0000228A
.text$mn:0000228A loc_228A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:0000228A                 movzx   edx, [ebp+arg_4]
.text$mn:0000228E                 test    edx, edx
.text$mn:00002290                 jz      short loc_22C4
.text$mn:00002292                 cmp     [ebp+arg_0], 10h
.text$mn:00002296                 jnb     short loc_22C4
.text$mn:00002298                 mov     eax, [ebp+var_4]
.text$mn:0000229B                 mov     ecx, [ebp+arg_0]
.text$mn:0000229E                 cmp     ecx, [eax+14h]
.text$mn:000022A1                 jnb     short loc_22AB
.text$mn:000022A3                 mov     edx, [ebp+arg_0]
.text$mn:000022A6                 mov     [ebp+Size], edx
.text$mn:000022A9                 jmp     short loc_22B4
.text$mn:000022AB ; ---------------------------------------------------------------------------
.text$mn:000022AB
.text$mn:000022AB loc_22AB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000022AB                 mov     eax, [ebp+var_4]
.text$mn:000022AE                 mov     ecx, [eax+14h]
.text$mn:000022B1                 mov     [ebp+Size], ecx
.text$mn:000022B4
.text$mn:000022B4 loc_22B4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000022B4                 mov     edx, [ebp+Size]
.text$mn:000022B7                 push    edx             ; Size
.text$mn:000022B8                 push    1               ; char
.text$mn:000022BA                 mov     ecx, [ebp+var_4]
.text$mn:000022BD                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000022C2                 jmp     short loc_22D4
.text$mn:000022C4 ; ---------------------------------------------------------------------------
.text$mn:000022C4
.text$mn:000022C4 loc_22C4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000022C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000022C4                 cmp     [ebp+arg_0], 0
.text$mn:000022C8                 jnz     short loc_22D4
.text$mn:000022CA                 push    0
.text$mn:000022CC                 mov     ecx, [ebp+var_4]
.text$mn:000022CF                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000022D4
.text$mn:000022D4 loc_22D4:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:000022D4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:000022D4                 cmp     [ebp+arg_0], 0
.text$mn:000022D8                 jbe     short loc_22E3
.text$mn:000022DA                 mov     [ebp+var_C], 1
.text$mn:000022E1                 jmp     short loc_22EA
.text$mn:000022E3 ; ---------------------------------------------------------------------------
.text$mn:000022E3
.text$mn:000022E3 loc_22E3:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:000022E3                 mov     [ebp+var_C], 0
.text$mn:000022EA
.text$mn:000022EA loc_22EA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:000022EA                 mov     al, byte ptr [ebp+var_C]
.text$mn:000022ED                 mov     esp, ebp
.text$mn:000022EF                 pop     ebp
.text$mn:000022F0                 retn    8
.text$mn:000022F0 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:000022F0
.text$mn:000022F0 ; ---------------------------------------------------------------------------
.text$mn:000022F3                 align 4
.text$mn:000022F3 _text$mn        ends
.text$mn:000022F3
.text$mn:000022F4 ; ===========================================================================
.text$mn:000022F4
.text$mn:000022F4 ; Segment type: Pure code
.text$mn:000022F4 ; Segment permissions: Read/Execute
.text$mn:000022F4 _text$mn        segment para public 'CODE' use32
.text$mn:000022F4                 assume cs:_text$mn
.text$mn:000022F4                 ;org 22F4h
.text$mn:000022F4 ; COMDAT (pick any)
.text$mn:000022F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000022F4
.text$mn:000022F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022F4
.text$mn:000022F4 ; Attributes: bp-based frame
.text$mn:000022F4
.text$mn:000022F4 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:000022F4                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:000022F4 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:000022F4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:000022F4
.text$mn:000022F4 var_4           = dword ptr -4
.text$mn:000022F4 arg_0           = dword ptr  8
.text$mn:000022F4
.text$mn:000022F4                 push    ebp
.text$mn:000022F5                 mov     ebp, esp
.text$mn:000022F7                 push    ecx
.text$mn:000022F8                 mov     [ebp+var_4], ecx
.text$mn:000022FB                 cmp     [ebp+arg_0], 0
.text$mn:000022FF                 jz      short loc_2321
.text$mn:00002301                 mov     ecx, [ebp+var_4]
.text$mn:00002304                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002309                 cmp     [ebp+arg_0], eax
.text$mn:0000230C                 jb      short loc_2321
.text$mn:0000230E                 mov     ecx, [ebp+var_4]
.text$mn:00002311                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002316                 mov     ecx, [ebp+var_4]
.text$mn:00002319                 add     eax, [ecx+14h]
.text$mn:0000231C                 cmp     eax, [ebp+arg_0]
.text$mn:0000231F                 ja      short loc_2327
.text$mn:00002321
.text$mn:00002321 loc_2321:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:00002321                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:00002321                 xor     al, al
.text$mn:00002323                 jmp     short loc_2329
.text$mn:00002325 ; ---------------------------------------------------------------------------
.text$mn:00002325                 jmp     short loc_2329
.text$mn:00002327 ; ---------------------------------------------------------------------------
.text$mn:00002327
.text$mn:00002327 loc_2327:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00002327                 mov     al, 1
.text$mn:00002329
.text$mn:00002329 loc_2329:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00002329                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00002329                 mov     esp, ebp
.text$mn:0000232B                 pop     ebp
.text$mn:0000232C                 retn    4
.text$mn:0000232C ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:0000232C
.text$mn:0000232C ; ---------------------------------------------------------------------------
.text$mn:0000232F                 align 10h
.text$mn:0000232F _text$mn        ends
.text$mn:0000232F
.text$mn:00002330 ; ===========================================================================
.text$mn:00002330
.text$mn:00002330 ; Segment type: Pure code
.text$mn:00002330 ; Segment permissions: Read/Execute
.text$mn:00002330 _text$mn        segment para public 'CODE' use32
.text$mn:00002330                 assume cs:_text$mn
.text$mn:00002330                 ;org 2330h
.text$mn:00002330 ; COMDAT (pick any)
.text$mn:00002330                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002330
.text$mn:00002330 ; =============== S U B R O U T I N E =======================================
.text$mn:00002330
.text$mn:00002330 ; Attributes: bp-based frame
.text$mn:00002330
.text$mn:00002330 ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002330                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:00002330 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:00002330                                         ; CODE XREF: $LN19+14p
.text$mn:00002330                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:00002330
.text$mn:00002330 var_8           = dword ptr -8
.text$mn:00002330 var_4           = dword ptr -4
.text$mn:00002330
.text$mn:00002330                 push    ebp
.text$mn:00002331                 mov     ebp, esp
.text$mn:00002333                 sub     esp, 8
.text$mn:00002336                 mov     [ebp+var_4], ecx
.text$mn:00002339                 mov     eax, [ebp+var_4]
.text$mn:0000233C                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002340                 jb      short loc_2356
.text$mn:00002342                 mov     ecx, [ebp+var_4]
.text$mn:00002345                 mov     edx, [ecx+4]
.text$mn:00002348                 push    edx
.text$mn:00002349                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000234E                 add     esp, 4
.text$mn:00002351                 mov     [ebp+var_8], eax
.text$mn:00002354                 jmp     short loc_235F
.text$mn:00002356 ; ---------------------------------------------------------------------------
.text$mn:00002356
.text$mn:00002356 loc_2356:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00002356                 mov     eax, [ebp+var_4]
.text$mn:00002359                 add     eax, 4
.text$mn:0000235C                 mov     [ebp+var_8], eax
.text$mn:0000235F
.text$mn:0000235F loc_235F:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000235F                 mov     eax, [ebp+var_8]
.text$mn:00002362                 mov     esp, ebp
.text$mn:00002364                 pop     ebp
.text$mn:00002365                 retn
.text$mn:00002365 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00002365
.text$mn:00002365 ; ---------------------------------------------------------------------------
.text$mn:00002366                 align 4
.text$mn:00002366 _text$mn        ends
.text$mn:00002366
.text$mn:00002368 ; ===========================================================================
.text$mn:00002368
.text$mn:00002368 ; Segment type: Pure code
.text$mn:00002368 ; Segment permissions: Read/Execute
.text$mn:00002368 _text$mn        segment para public 'CODE' use32
.text$mn:00002368                 assume cs:_text$mn
.text$mn:00002368                 ;org 2368h
.text$mn:00002368 ; COMDAT (pick any)
.text$mn:00002368                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002368
.text$mn:00002368 ; =============== S U B R O U T I N E =======================================
.text$mn:00002368
.text$mn:00002368 ; Attributes: bp-based frame
.text$mn:00002368
.text$mn:00002368 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00002368                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00002368 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00002368                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00002368
.text$mn:00002368 var_8           = dword ptr -8
.text$mn:00002368 var_4           = dword ptr -4
.text$mn:00002368
.text$mn:00002368                 push    ebp
.text$mn:00002369                 mov     ebp, esp
.text$mn:0000236B                 sub     esp, 8
.text$mn:0000236E                 mov     [ebp+var_4], ecx
.text$mn:00002371                 mov     eax, [ebp+var_4]
.text$mn:00002374                 cmp     dword ptr [eax+18h], 10h
.text$mn:00002378                 jb      short loc_238E
.text$mn:0000237A                 mov     ecx, [ebp+var_4]
.text$mn:0000237D                 mov     edx, [ecx+4]
.text$mn:00002380                 push    edx
.text$mn:00002381                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00002386                 add     esp, 4
.text$mn:00002389                 mov     [ebp+var_8], eax
.text$mn:0000238C                 jmp     short loc_2397
.text$mn:0000238E ; ---------------------------------------------------------------------------
.text$mn:0000238E
.text$mn:0000238E loc_238E:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:0000238E                 mov     eax, [ebp+var_4]
.text$mn:00002391                 add     eax, 4
.text$mn:00002394                 mov     [ebp+var_8], eax
.text$mn:00002397
.text$mn:00002397 loc_2397:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:00002397                 mov     eax, [ebp+var_8]
.text$mn:0000239A                 mov     esp, ebp
.text$mn:0000239C                 pop     ebp
.text$mn:0000239D                 retn
.text$mn:0000239D ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:0000239D
.text$mn:0000239D ; ---------------------------------------------------------------------------
.text$mn:0000239E                 align 10h
.text$mn:0000239E _text$mn        ends
.text$mn:0000239E
.text$mn:000023A0 ; ===========================================================================
.text$mn:000023A0
.text$mn:000023A0 ; Segment type: Pure code
.text$mn:000023A0 ; Segment permissions: Read/Execute
.text$mn:000023A0 _text$mn        segment para public 'CODE' use32
.text$mn:000023A0                 assume cs:_text$mn
.text$mn:000023A0                 ;org 23A0h
.text$mn:000023A0 ; COMDAT (pick any)
.text$mn:000023A0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023A0
.text$mn:000023A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000023A0
.text$mn:000023A0 ; Attributes: bp-based frame
.text$mn:000023A0
.text$mn:000023A0 ; public: wchar_t const * __thiscall std::_String_val<struct std::_Simple_types<wchar_t>>::_Myptr(void)const
.text$mn:000023A0                 public ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ
.text$mn:000023A0 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ proc near
.text$mn:000023A0                                         ; CODE XREF: std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)+Ap
.text$mn:000023A0
.text$mn:000023A0 var_8           = dword ptr -8
.text$mn:000023A0 var_4           = dword ptr -4
.text$mn:000023A0
.text$mn:000023A0                 push    ebp
.text$mn:000023A1                 mov     ebp, esp
.text$mn:000023A3                 sub     esp, 8
.text$mn:000023A6                 mov     [ebp+var_4], ecx
.text$mn:000023A9                 mov     eax, [ebp+var_4]
.text$mn:000023AC                 cmp     dword ptr [eax+18h], 8
.text$mn:000023B0                 jb      short loc_23C6
.text$mn:000023B2                 mov     ecx, [ebp+var_4]
.text$mn:000023B5                 mov     edx, [ecx+4]
.text$mn:000023B8                 push    edx
.text$mn:000023B9                 call    ??$addressof@_W@std@@YAPA_WAA_W@Z ; std::addressof<wchar_t>(wchar_t &)
.text$mn:000023BE                 add     esp, 4
.text$mn:000023C1                 mov     [ebp+var_8], eax
.text$mn:000023C4                 jmp     short loc_23CF
.text$mn:000023C6 ; ---------------------------------------------------------------------------
.text$mn:000023C6
.text$mn:000023C6 loc_23C6:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+10j
.text$mn:000023C6                 mov     eax, [ebp+var_4]
.text$mn:000023C9                 add     eax, 4
.text$mn:000023CC                 mov     [ebp+var_8], eax
.text$mn:000023CF
.text$mn:000023CF loc_23CF:                               ; CODE XREF: std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)+24j
.text$mn:000023CF                 mov     eax, [ebp+var_8]
.text$mn:000023D2                 mov     esp, ebp
.text$mn:000023D4                 pop     ebp
.text$mn:000023D5                 retn
.text$mn:000023D5 ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ endp
.text$mn:000023D5
.text$mn:000023D5 ; ---------------------------------------------------------------------------
.text$mn:000023D6                 align 4
.text$mn:000023D6 _text$mn        ends
.text$mn:000023D6
.text$mn:000023D8 ; ===========================================================================
.text$mn:000023D8
.text$mn:000023D8 ; Segment type: Pure code
.text$mn:000023D8 ; Segment permissions: Read/Execute
.text$mn:000023D8 _text$mn        segment para public 'CODE' use32
.text$mn:000023D8                 assume cs:_text$mn
.text$mn:000023D8                 ;org 23D8h
.text$mn:000023D8 ; COMDAT (pick any)
.text$mn:000023D8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000023D8
.text$mn:000023D8 ; =============== S U B R O U T I N E =======================================
.text$mn:000023D8
.text$mn:000023D8 ; Attributes: bp-based frame
.text$mn:000023D8
.text$mn:000023D8 ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000023D8                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000023D8 ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000023D8                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000023D8                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p
.text$mn:000023D8
.text$mn:000023D8 var_18          = byte ptr -18h
.text$mn:000023D8 var_14          = dword ptr -14h
.text$mn:000023D8 var_10          = dword ptr -10h
.text$mn:000023D8 var_C           = dword ptr -0Ch
.text$mn:000023D8 var_4           = dword ptr -4
.text$mn:000023D8
.text$mn:000023D8                 push    ebp
.text$mn:000023D9                 mov     ebp, esp
.text$mn:000023DB                 push    0FFFFFFFFh
.text$mn:000023DD                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000023E2                 mov     eax, large fs:0
.text$mn:000023E8                 push    eax
.text$mn:000023E9                 sub     esp, 0Ch
.text$mn:000023EC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000023F1                 xor     eax, ebp
.text$mn:000023F3                 push    eax
.text$mn:000023F4                 lea     eax, [ebp+var_C]
.text$mn:000023F7                 mov     large fs:0, eax
.text$mn:000023FD                 mov     [ebp+var_14], ecx
.text$mn:00002400                 mov     eax, [ebp+var_14]
.text$mn:00002403                 cmp     dword ptr [eax], 0
.text$mn:00002406                 jz      short loc_2463
.text$mn:00002408                 push    3               ; int
.text$mn:0000240A                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000240D                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00002412                 mov     [ebp+var_4], 0
.text$mn:00002419                 mov     ecx, [ebp+var_14]
.text$mn:0000241C                 mov     edx, [ecx]
.text$mn:0000241E                 add     edx, 4
.text$mn:00002421                 mov     [ebp+var_10], edx
.text$mn:00002424                 jmp     short loc_2433
.text$mn:00002426 ; ---------------------------------------------------------------------------
.text$mn:00002426
.text$mn:00002426 loc_2426:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:00002426                 mov     eax, [ebp+var_10]
.text$mn:00002429                 mov     ecx, [eax]
.text$mn:0000242B                 mov     edx, [ebp+var_10]
.text$mn:0000242E                 mov     eax, [ecx+4]
.text$mn:00002431                 mov     [edx], eax
.text$mn:00002433
.text$mn:00002433 loc_2433:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00002433                 mov     ecx, [ebp+var_10]
.text$mn:00002436                 cmp     dword ptr [ecx], 0
.text$mn:00002439                 jz      short loc_2448
.text$mn:0000243B                 mov     edx, [ebp+var_10]
.text$mn:0000243E                 mov     eax, [edx]
.text$mn:00002440                 mov     dword ptr [eax], 0
.text$mn:00002446                 jmp     short loc_2426
.text$mn:00002448 ; ---------------------------------------------------------------------------
.text$mn:00002448
.text$mn:00002448 loc_2448:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:00002448                 mov     ecx, [ebp+var_14]
.text$mn:0000244B                 mov     edx, [ecx]
.text$mn:0000244D                 mov     dword ptr [edx+4], 0
.text$mn:00002454                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000245B                 lea     ecx, [ebp+var_18] ; this
.text$mn:0000245E                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00002463
.text$mn:00002463 loc_2463:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00002463                 mov     ecx, [ebp+var_C]
.text$mn:00002466                 mov     large fs:0, ecx
.text$mn:0000246D                 pop     ecx
.text$mn:0000246E                 mov     esp, ebp
.text$mn:00002470                 pop     ebp
.text$mn:00002471                 retn
.text$mn:00002471 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00002471
.text$mn:00002471 ; ---------------------------------------------------------------------------
.text$mn:00002472                 align 4
.text$mn:00002472 _text$mn        ends
.text$mn:00002472
.text$x:00002474 ; ===========================================================================
.text$x:00002474
.text$x:00002474 ; Segment type: Pure code
.text$x:00002474 ; Segment permissions: Read/Execute
.text$x:00002474 _text$x         segment para public 'CODE' use32
.text$x:00002474                 assume cs:_text$x
.text$x:00002474                 ;org 2474h
.text$x:00002474 ; COMDAT (pick associative to section at 23D8)
.text$x:00002474                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002474
.text$x:00002474 ; =============== S U B R O U T I N E =======================================
.text$x:00002474
.text$x:00002474
.text$x:00002474 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00002474                                         ; DATA XREF: .xdata$x:00002E5Co
.text$x:00002474                 lea     ecx, [ebp-18h]  ; this
.text$x:00002477                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00002477 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:00002477
.text$x:0000247C
.text$x:0000247C ; =============== S U B R O U T I N E =======================================
.text$x:0000247C
.text$x:0000247C
.text$x:0000247C __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:0000247C                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:0000247C
.text$x:0000247C arg_4           = dword ptr  8
.text$x:0000247C
.text$x:0000247C                 mov     edx, [esp+arg_4]
.text$x:00002480                 lea     eax, [edx+0Ch]
.text$x:00002483                 mov     ecx, [edx-10h]
.text$x:00002486                 xor     ecx, eax
.text$x:00002488                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000248D                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00002492                 jmp     ___CxxFrameHandler3
.text$x:00002492 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00002492
.text$x:00002492 ; ---------------------------------------------------------------------------
.text$x:00002497                 align 4
.text$x:00002497 _text$x         ends
.text$x:00002497
.text$mn:00002498 ; ===========================================================================
.text$mn:00002498
.text$mn:00002498 ; Segment type: Pure code
.text$mn:00002498 ; Segment permissions: Read/Execute
.text$mn:00002498 _text$mn        segment para public 'CODE' use32
.text$mn:00002498                 assume cs:_text$mn
.text$mn:00002498                 ;org 2498h
.text$mn:00002498 ; COMDAT (pick any)
.text$mn:00002498                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002498
.text$mn:00002498 ; =============== S U B R O U T I N E =======================================
.text$mn:00002498
.text$mn:00002498 ; Attributes: bp-based frame
.text$mn:00002498
.text$mn:00002498 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00002498                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00002498 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00002498                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00002498                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00002498
.text$mn:00002498 var_C           = dword ptr -0Ch
.text$mn:00002498 var_8           = dword ptr -8
.text$mn:00002498 var_2           = byte ptr -2
.text$mn:00002498 var_1           = byte ptr -1
.text$mn:00002498 arg_0           = byte ptr  8
.text$mn:00002498 Size            = dword ptr  0Ch
.text$mn:00002498
.text$mn:00002498                 push    ebp
.text$mn:00002499                 mov     ebp, esp
.text$mn:0000249B                 sub     esp, 0Ch
.text$mn:0000249E                 mov     [ebp+var_8], ecx
.text$mn:000024A1                 movzx   eax, [ebp+arg_0]
.text$mn:000024A5                 test    eax, eax
.text$mn:000024A7                 jnz     short loc_24AB
.text$mn:000024A9                 jmp     short loc_251E
.text$mn:000024AB ; ---------------------------------------------------------------------------
.text$mn:000024AB
.text$mn:000024AB loc_24AB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:000024AB                 mov     ecx, [ebp+var_8]
.text$mn:000024AE                 cmp     dword ptr [ecx+18h], 10h
.text$mn:000024B2                 jb      short loc_251E
.text$mn:000024B4                 mov     edx, [ebp+var_8]
.text$mn:000024B7                 mov     eax, [edx+4]
.text$mn:000024BA                 mov     [ebp+var_C], eax
.text$mn:000024BD                 mov     ecx, [ebp+var_8]
.text$mn:000024C0                 add     ecx, 4
.text$mn:000024C3                 push    ecx
.text$mn:000024C4                 lea     edx, [ebp+var_1]
.text$mn:000024C7                 push    edx
.text$mn:000024C8                 mov     ecx, [ebp+var_8]
.text$mn:000024CB                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:000024D0                 mov     ecx, eax
.text$mn:000024D2                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:000024D7                 cmp     [ebp+Size], 0
.text$mn:000024DB                 jbe     short loc_24FD
.text$mn:000024DD                 mov     eax, [ebp+Size]
.text$mn:000024E0                 push    eax             ; Size
.text$mn:000024E1                 mov     ecx, [ebp+var_C]
.text$mn:000024E4                 push    ecx
.text$mn:000024E5                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000024EA                 add     esp, 4
.text$mn:000024ED                 push    eax             ; Src
.text$mn:000024EE                 mov     edx, [ebp+var_8]
.text$mn:000024F1                 add     edx, 4
.text$mn:000024F4                 push    edx             ; Dst
.text$mn:000024F5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000024FA                 add     esp, 0Ch
.text$mn:000024FD
.text$mn:000024FD loc_24FD:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:000024FD                 mov     eax, [ebp+var_8]
.text$mn:00002500                 mov     ecx, [eax+18h]
.text$mn:00002503                 add     ecx, 1
.text$mn:00002506                 push    ecx             ; int
.text$mn:00002507                 mov     edx, [ebp+var_C]
.text$mn:0000250A                 push    edx             ; void *
.text$mn:0000250B                 lea     eax, [ebp+var_2]
.text$mn:0000250E                 push    eax
.text$mn:0000250F                 mov     ecx, [ebp+var_8]
.text$mn:00002512                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002517                 mov     ecx, eax
.text$mn:00002519                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:0000251E
.text$mn:0000251E loc_251E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:0000251E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:0000251E                 mov     ecx, [ebp+var_8]
.text$mn:00002521                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00002528                 mov     edx, [ebp+Size]
.text$mn:0000252B                 push    edx
.text$mn:0000252C                 mov     ecx, [ebp+var_8]
.text$mn:0000252F                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002534                 mov     esp, ebp
.text$mn:00002536                 pop     ebp
.text$mn:00002537                 retn    8
.text$mn:00002537 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:00002537
.text$mn:00002537 ; ---------------------------------------------------------------------------
.text$mn:0000253A                 align 4
.text$mn:0000253A _text$mn        ends
.text$mn:0000253A
.text$mn:0000253C ; ===========================================================================
.text$mn:0000253C
.text$mn:0000253C ; Segment type: Pure code
.text$mn:0000253C ; Segment permissions: Read/Execute
.text$mn:0000253C _text$mn        segment para public 'CODE' use32
.text$mn:0000253C                 assume cs:_text$mn
.text$mn:0000253C                 ;org 253Ch
.text$mn:0000253C ; COMDAT (pick any)
.text$mn:0000253C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000253C
.text$mn:0000253C ; =============== S U B R O U T I N E =======================================
.text$mn:0000253C
.text$mn:0000253C ; Attributes: bp-based frame
.text$mn:0000253C
.text$mn:0000253C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:0000253C                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:0000253C ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:0000253C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:0000253C
.text$mn:0000253C var_4           = dword ptr -4
.text$mn:0000253C
.text$mn:0000253C                 push    ebp
.text$mn:0000253D                 mov     ebp, esp
.text$mn:0000253F                 push    ecx
.text$mn:00002540                 mov     [ebp+var_4], ecx
.text$mn:00002543                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00002548                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000254D                 mov     esp, ebp
.text$mn:0000254F                 pop     ebp
.text$mn:00002550                 retn
.text$mn:00002550 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002550
.text$mn:00002550 ; ---------------------------------------------------------------------------
.text$mn:00002551                 align 4
.text$mn:00002551 _text$mn        ends
.text$mn:00002551
.text$mn:00002554 ; ===========================================================================
.text$mn:00002554
.text$mn:00002554 ; Segment type: Pure code
.text$mn:00002554 ; Segment permissions: Read/Execute
.text$mn:00002554 _text$mn        segment para public 'CODE' use32
.text$mn:00002554                 assume cs:_text$mn
.text$mn:00002554                 ;org 2554h
.text$mn:00002554 ; COMDAT (pick any)
.text$mn:00002554                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002554
.text$mn:00002554 ; =============== S U B R O U T I N E =======================================
.text$mn:00002554
.text$mn:00002554 ; Attributes: bp-based frame
.text$mn:00002554
.text$mn:00002554 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00002554                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00002554 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00002554                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00002554                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00002554
.text$mn:00002554 var_4           = dword ptr -4
.text$mn:00002554
.text$mn:00002554                 push    ebp
.text$mn:00002555                 mov     ebp, esp
.text$mn:00002557                 push    ecx
.text$mn:00002558                 mov     [ebp+var_4], ecx
.text$mn:0000255B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00002560                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00002565                 mov     esp, ebp
.text$mn:00002567                 pop     ebp
.text$mn:00002568                 retn
.text$mn:00002568 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00002568
.text$mn:00002568 ; ---------------------------------------------------------------------------
.text$mn:00002569                 align 4
.text$mn:00002569 _text$mn        ends
.text$mn:00002569
.text$mn:0000256C ; ===========================================================================
.text$mn:0000256C
.text$mn:0000256C ; Segment type: Pure code
.text$mn:0000256C ; Segment permissions: Read/Execute
.text$mn:0000256C _text$mn        segment para public 'CODE' use32
.text$mn:0000256C                 assume cs:_text$mn
.text$mn:0000256C                 ;org 256Ch
.text$mn:0000256C ; COMDAT (pick any)
.text$mn:0000256C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000256C
.text$mn:0000256C ; =============== S U B R O U T I N E =======================================
.text$mn:0000256C
.text$mn:0000256C ; Attributes: bp-based frame
.text$mn:0000256C
.text$mn:0000256C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000256C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000256C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000256C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000256C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000256C
.text$mn:0000256C var_4           = dword ptr -4
.text$mn:0000256C arg_0           = dword ptr  8
.text$mn:0000256C
.text$mn:0000256C                 push    ebp
.text$mn:0000256D                 mov     ebp, esp
.text$mn:0000256F                 push    ecx
.text$mn:00002570                 mov     [ebp+var_4], ecx
.text$mn:00002573                 mov     eax, [ebp+arg_0]
.text$mn:00002576                 push    eax
.text$mn:00002577                 mov     ecx, [ebp+var_4]
.text$mn:0000257A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000257F                 mov     esp, ebp
.text$mn:00002581                 pop     ebp
.text$mn:00002582                 retn    4
.text$mn:00002582 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00002582
.text$mn:00002582 ; ---------------------------------------------------------------------------
.text$mn:00002585                 align 4
.text$mn:00002585 _text$mn        ends
.text$mn:00002585
.text$mn:00002588 ; ===========================================================================
.text$mn:00002588
.text$mn:00002588 ; Segment type: Pure code
.text$mn:00002588 ; Segment permissions: Read/Execute
.text$mn:00002588 _text$mn        segment para public 'CODE' use32
.text$mn:00002588                 assume cs:_text$mn
.text$mn:00002588                 ;org 2588h
.text$mn:00002588 ; COMDAT (pick any)
.text$mn:00002588                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002588
.text$mn:00002588 ; =============== S U B R O U T I N E =======================================
.text$mn:00002588
.text$mn:00002588 ; Attributes: bp-based frame
.text$mn:00002588
.text$mn:00002588 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:00002588                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:00002588 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:00002588                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:00002588
.text$mn:00002588 var_4           = dword ptr -4
.text$mn:00002588 arg_0           = dword ptr  8
.text$mn:00002588
.text$mn:00002588                 push    ebp
.text$mn:00002589                 mov     ebp, esp
.text$mn:0000258B                 push    ecx
.text$mn:0000258C                 mov     [ebp+var_4], ecx
.text$mn:0000258F                 push    0
.text$mn:00002591                 mov     eax, [ebp+arg_0]
.text$mn:00002594                 push    eax
.text$mn:00002595                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:0000259A                 add     esp, 8
.text$mn:0000259D                 mov     esp, ebp
.text$mn:0000259F                 pop     ebp
.text$mn:000025A0                 retn    4
.text$mn:000025A0 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000025A0
.text$mn:000025A0 ; ---------------------------------------------------------------------------
.text$mn:000025A3                 align 4
.text$mn:000025A3 _text$mn        ends
.text$mn:000025A3
.text$mn:000025A4 ; ===========================================================================
.text$mn:000025A4
.text$mn:000025A4 ; Segment type: Pure code
.text$mn:000025A4 ; Segment permissions: Read/Execute
.text$mn:000025A4 _text$mn        segment para public 'CODE' use32
.text$mn:000025A4                 assume cs:_text$mn
.text$mn:000025A4                 ;org 25A4h
.text$mn:000025A4 ; COMDAT (pick any)
.text$mn:000025A4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025A4
.text$mn:000025A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000025A4
.text$mn:000025A4 ; Attributes: bp-based frame
.text$mn:000025A4
.text$mn:000025A4 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:000025A4                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000025A4 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000025A4                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:000025A4
.text$mn:000025A4 var_4           = dword ptr -4
.text$mn:000025A4 arg_0           = dword ptr  8
.text$mn:000025A4
.text$mn:000025A4                 push    ebp
.text$mn:000025A5                 mov     ebp, esp
.text$mn:000025A7                 push    ecx
.text$mn:000025A8                 mov     [ebp+var_4], ecx
.text$mn:000025AB                 push    0
.text$mn:000025AD                 mov     eax, [ebp+arg_0]
.text$mn:000025B0                 push    eax
.text$mn:000025B1                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:000025B6                 add     esp, 8
.text$mn:000025B9                 mov     esp, ebp
.text$mn:000025BB                 pop     ebp
.text$mn:000025BC                 retn    4
.text$mn:000025BC ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000025BC
.text$mn:000025BC ; ---------------------------------------------------------------------------
.text$mn:000025BF                 align 10h
.text$mn:000025BF _text$mn        ends
.text$mn:000025BF
.text$mn:000025C0 ; ===========================================================================
.text$mn:000025C0
.text$mn:000025C0 ; Segment type: Pure code
.text$mn:000025C0 ; Segment permissions: Read/Execute
.text$mn:000025C0 _text$mn        segment para public 'CODE' use32
.text$mn:000025C0                 assume cs:_text$mn
.text$mn:000025C0                 ;org 25C0h
.text$mn:000025C0 ; COMDAT (pick any)
.text$mn:000025C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000025C0
.text$mn:000025C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000025C0
.text$mn:000025C0 ; Attributes: bp-based frame
.text$mn:000025C0
.text$mn:000025C0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:000025C0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:000025C0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:000025C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:000025C0
.text$mn:000025C0 Size            = dword ptr -8
.text$mn:000025C0 var_4           = dword ptr -4
.text$mn:000025C0 arg_0           = dword ptr  8
.text$mn:000025C0 arg_4           = dword ptr  0Ch
.text$mn:000025C0 arg_8           = dword ptr  10h
.text$mn:000025C0
.text$mn:000025C0                 push    ebp
.text$mn:000025C1                 mov     ebp, esp
.text$mn:000025C3                 sub     esp, 8
.text$mn:000025C6                 mov     [ebp+var_4], ecx
.text$mn:000025C9                 mov     ecx, [ebp+arg_0]
.text$mn:000025CC                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000025D1                 cmp     eax, [ebp+arg_4]
.text$mn:000025D4                 jnb     short loc_25DE
.text$mn:000025D6                 mov     ecx, [ebp+var_4]
.text$mn:000025D9                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000025DE
.text$mn:000025DE loc_25DE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:000025DE                 mov     ecx, [ebp+arg_0]
.text$mn:000025E1                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:000025E6                 sub     eax, [ebp+arg_4]
.text$mn:000025E9                 mov     [ebp+Size], eax
.text$mn:000025EC                 mov     eax, [ebp+arg_8]
.text$mn:000025EF                 cmp     eax, [ebp+Size]
.text$mn:000025F2                 jnb     short loc_25FA
.text$mn:000025F4                 mov     ecx, [ebp+arg_8]
.text$mn:000025F7                 mov     [ebp+Size], ecx
.text$mn:000025FA
.text$mn:000025FA loc_25FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:000025FA                 mov     edx, [ebp+var_4]
.text$mn:000025FD                 cmp     edx, [ebp+arg_0]
.text$mn:00002600                 jnz     short loc_2621
.text$mn:00002602                 mov     eax, [ebp+arg_4]
.text$mn:00002605                 add     eax, [ebp+Size]
.text$mn:00002608                 push    eax
.text$mn:00002609                 mov     ecx, [ebp+var_4]
.text$mn:0000260C                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00002611                 mov     ecx, [ebp+arg_4]
.text$mn:00002614                 push    ecx
.text$mn:00002615                 push    0
.text$mn:00002617                 mov     ecx, [ebp+var_4]
.text$mn:0000261A                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:0000261F                 jmp     short loc_2663
.text$mn:00002621 ; ---------------------------------------------------------------------------
.text$mn:00002621
.text$mn:00002621 loc_2621:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00002621                 push    0
.text$mn:00002623                 mov     edx, [ebp+Size]
.text$mn:00002626                 push    edx
.text$mn:00002627                 mov     ecx, [ebp+var_4]
.text$mn:0000262A                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000262F                 movzx   eax, al
.text$mn:00002632                 test    eax, eax
.text$mn:00002634                 jz      short loc_2663
.text$mn:00002636                 mov     ecx, [ebp+Size]
.text$mn:00002639                 push    ecx             ; Size
.text$mn:0000263A                 mov     ecx, [ebp+arg_0]
.text$mn:0000263D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002642                 add     eax, [ebp+arg_4]
.text$mn:00002645                 push    eax             ; Src
.text$mn:00002646                 mov     ecx, [ebp+var_4]
.text$mn:00002649                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000264E                 push    eax             ; Dst
.text$mn:0000264F                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002654                 add     esp, 0Ch
.text$mn:00002657                 mov     edx, [ebp+Size]
.text$mn:0000265A                 push    edx
.text$mn:0000265B                 mov     ecx, [ebp+var_4]
.text$mn:0000265E                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002663
.text$mn:00002663 loc_2663:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:00002663                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:00002663                 mov     eax, [ebp+var_4]
.text$mn:00002666                 mov     esp, ebp
.text$mn:00002668                 pop     ebp
.text$mn:00002669                 retn    0Ch
.text$mn:00002669 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:00002669
.text$mn:00002669 _text$mn        ends
.text$mn:00002669
.text$mn:0000266C ; ===========================================================================
.text$mn:0000266C
.text$mn:0000266C ; Segment type: Pure code
.text$mn:0000266C ; Segment permissions: Read/Execute
.text$mn:0000266C _text$mn        segment para public 'CODE' use32
.text$mn:0000266C                 assume cs:_text$mn
.text$mn:0000266C                 ;org 266Ch
.text$mn:0000266C ; COMDAT (pick any)
.text$mn:0000266C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000266C
.text$mn:0000266C ; =============== S U B R O U T I N E =======================================
.text$mn:0000266C
.text$mn:0000266C ; Attributes: bp-based frame
.text$mn:0000266C
.text$mn:0000266C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:0000266C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:0000266C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:0000266C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:0000266C
.text$mn:0000266C var_4           = dword ptr -4
.text$mn:0000266C Str             = dword ptr  8
.text$mn:0000266C
.text$mn:0000266C                 push    ebp
.text$mn:0000266D                 mov     ebp, esp
.text$mn:0000266F                 push    ecx
.text$mn:00002670                 mov     [ebp+var_4], ecx
.text$mn:00002673                 push    490h            ; unsigned int
.text$mn:00002678                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000267D                 mov     eax, [ebp+Str]
.text$mn:00002680                 push    eax             ; int
.text$mn:00002681                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:00002686                 add     esp, 0Ch
.text$mn:00002689                 mov     ecx, [ebp+Str]
.text$mn:0000268C                 push    ecx             ; Str
.text$mn:0000268D                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:00002692                 add     esp, 4
.text$mn:00002695                 push    eax             ; Size
.text$mn:00002696                 mov     edx, [ebp+Str]
.text$mn:00002699                 push    edx             ; Src
.text$mn:0000269A                 mov     ecx, [ebp+var_4]
.text$mn:0000269D                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:000026A2                 mov     esp, ebp
.text$mn:000026A4                 pop     ebp
.text$mn:000026A5                 retn    4
.text$mn:000026A5 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:000026A5
.text$mn:000026A5 _text$mn        ends
.text$mn:000026A5
.text$mn:000026A8 ; ===========================================================================
.text$mn:000026A8
.text$mn:000026A8 ; Segment type: Pure code
.text$mn:000026A8 ; Segment permissions: Read/Execute
.text$mn:000026A8 _text$mn        segment para public 'CODE' use32
.text$mn:000026A8                 assume cs:_text$mn
.text$mn:000026A8                 ;org 26A8h
.text$mn:000026A8 ; COMDAT (pick any)
.text$mn:000026A8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000026A8
.text$mn:000026A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000026A8
.text$mn:000026A8 ; Attributes: bp-based frame
.text$mn:000026A8
.text$mn:000026A8 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:000026A8                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:000026A8 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:000026A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:000026A8
.text$mn:000026A8 var_4           = dword ptr -4
.text$mn:000026A8 Src             = dword ptr  8
.text$mn:000026A8 Size            = dword ptr  0Ch
.text$mn:000026A8
.text$mn:000026A8                 push    ebp
.text$mn:000026A9                 mov     ebp, esp
.text$mn:000026AB                 push    ecx
.text$mn:000026AC                 mov     [ebp+var_4], ecx
.text$mn:000026AF                 cmp     [ebp+Size], 0
.text$mn:000026B3                 jz      short loc_26CB
.text$mn:000026B5                 push    47Fh            ; unsigned int
.text$mn:000026BA                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000026BF                 mov     eax, [ebp+Src]
.text$mn:000026C2                 push    eax             ; int
.text$mn:000026C3                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000026C8                 add     esp, 0Ch
.text$mn:000026CB
.text$mn:000026CB loc_26CB:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:000026CB                 mov     ecx, [ebp+Src]
.text$mn:000026CE                 push    ecx
.text$mn:000026CF                 mov     ecx, [ebp+var_4]
.text$mn:000026D2                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:000026D7                 movzx   edx, al
.text$mn:000026DA                 test    edx, edx
.text$mn:000026DC                 jz      short loc_26FE
.text$mn:000026DE                 mov     eax, [ebp+Size]
.text$mn:000026E1                 push    eax
.text$mn:000026E2                 mov     ecx, [ebp+var_4]
.text$mn:000026E5                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000026EA                 mov     ecx, [ebp+Src]
.text$mn:000026ED                 sub     ecx, eax
.text$mn:000026EF                 push    ecx
.text$mn:000026F0                 mov     edx, [ebp+var_4]
.text$mn:000026F3                 push    edx
.text$mn:000026F4                 mov     ecx, [ebp+var_4]
.text$mn:000026F7                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:000026FC                 jmp     short loc_273B
.text$mn:000026FE ; ---------------------------------------------------------------------------
.text$mn:000026FE
.text$mn:000026FE loc_26FE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:000026FE                 push    0
.text$mn:00002700                 mov     eax, [ebp+Size]
.text$mn:00002703                 push    eax
.text$mn:00002704                 mov     ecx, [ebp+var_4]
.text$mn:00002707                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:0000270C                 movzx   ecx, al
.text$mn:0000270F                 test    ecx, ecx
.text$mn:00002711                 jz      short loc_2738
.text$mn:00002713                 mov     edx, [ebp+Size]
.text$mn:00002716                 push    edx             ; Size
.text$mn:00002717                 mov     eax, [ebp+Src]
.text$mn:0000271A                 push    eax             ; Src
.text$mn:0000271B                 mov     ecx, [ebp+var_4]
.text$mn:0000271E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002723                 push    eax             ; Dst
.text$mn:00002724                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00002729                 add     esp, 0Ch
.text$mn:0000272C                 mov     ecx, [ebp+Size]
.text$mn:0000272F                 push    ecx
.text$mn:00002730                 mov     ecx, [ebp+var_4]
.text$mn:00002733                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002738
.text$mn:00002738 loc_2738:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:00002738                 mov     eax, [ebp+var_4]
.text$mn:0000273B
.text$mn:0000273B loc_273B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000273B                 mov     esp, ebp
.text$mn:0000273D                 pop     ebp
.text$mn:0000273E                 retn    8
.text$mn:0000273E ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:0000273E
.text$mn:0000273E ; ---------------------------------------------------------------------------
.text$mn:00002741                 align 4
.text$mn:00002741 _text$mn        ends
.text$mn:00002741
.text$mn:00002744 ; ===========================================================================
.text$mn:00002744
.text$mn:00002744 ; Segment type: Pure code
.text$mn:00002744 ; Segment permissions: Read/Execute
.text$mn:00002744 _text$mn        segment para public 'CODE' use32
.text$mn:00002744                 assume cs:_text$mn
.text$mn:00002744                 ;org 2744h
.text$mn:00002744 ; COMDAT (pick any)
.text$mn:00002744                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002744
.text$mn:00002744 ; =============== S U B R O U T I N E =======================================
.text$mn:00002744
.text$mn:00002744 ; Attributes: bp-based frame
.text$mn:00002744
.text$mn:00002744 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:00002744                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:00002744 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:00002744                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:00002744
.text$mn:00002744 arg_0           = dword ptr  8
.text$mn:00002744 arg_4           = dword ptr  0Ch
.text$mn:00002744
.text$mn:00002744                 push    ebp
.text$mn:00002745                 mov     ebp, esp
.text$mn:00002747                 mov     eax, [ebp+arg_0]
.text$mn:0000274A                 mov     ecx, [ebp+arg_4]
.text$mn:0000274D                 mov     dl, [ecx]
.text$mn:0000274F                 mov     [eax], dl
.text$mn:00002751                 pop     ebp
.text$mn:00002752                 retn
.text$mn:00002752 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:00002752
.text$mn:00002752 ; ---------------------------------------------------------------------------
.text$mn:00002753                 align 4
.text$mn:00002753 _text$mn        ends
.text$mn:00002753
.text$mn:00002754 ; ===========================================================================
.text$mn:00002754
.text$mn:00002754 ; Segment type: Pure code
.text$mn:00002754 ; Segment permissions: Read/Execute
.text$mn:00002754 _text$mn        segment para public 'CODE' use32
.text$mn:00002754                 assume cs:_text$mn
.text$mn:00002754                 ;org 2754h
.text$mn:00002754 ; COMDAT (pick any)
.text$mn:00002754                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002754
.text$mn:00002754 ; =============== S U B R O U T I N E =======================================
.text$mn:00002754
.text$mn:00002754 ; Attributes: bp-based frame
.text$mn:00002754
.text$mn:00002754 ; public: wchar_t const * __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::c_str(void)const
.text$mn:00002754                 public ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ
.text$mn:00002754 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ proc near
.text$mn:00002754                                         ; CODE XREF: Buffer::getFullPathName(void)+10p
.text$mn:00002754
.text$mn:00002754 var_4           = dword ptr -4
.text$mn:00002754
.text$mn:00002754                 push    ebp
.text$mn:00002755                 mov     ebp, esp
.text$mn:00002757                 push    ecx
.text$mn:00002758                 mov     [ebp+var_4], ecx
.text$mn:0000275B                 mov     ecx, [ebp+var_4]
.text$mn:0000275E                 call    ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QBEPB_WXZ ; std::_String_val<std::_Simple_types<wchar_t>>::_Myptr(void)
.text$mn:00002763                 mov     esp, ebp
.text$mn:00002765                 pop     ebp
.text$mn:00002766                 retn
.text$mn:00002766 ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ endp
.text$mn:00002766
.text$mn:00002766 ; ---------------------------------------------------------------------------
.text$mn:00002767                 align 4
.text$mn:00002767 _text$mn        ends
.text$mn:00002767
.text$mn:00002768 ; ===========================================================================
.text$mn:00002768
.text$mn:00002768 ; Segment type: Pure code
.text$mn:00002768 ; Segment permissions: Read/Execute
.text$mn:00002768 _text$mn        segment para public 'CODE' use32
.text$mn:00002768                 assume cs:_text$mn
.text$mn:00002768                 ;org 2768h
.text$mn:00002768 ; COMDAT (pick any)
.text$mn:00002768                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002768
.text$mn:00002768 ; =============== S U B R O U T I N E =======================================
.text$mn:00002768
.text$mn:00002768 ; Attributes: bp-based frame
.text$mn:00002768
.text$mn:00002768 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00002768                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00002768 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00002768                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00002768
.text$mn:00002768 var_4           = dword ptr -4
.text$mn:00002768
.text$mn:00002768                 push    ebp
.text$mn:00002769                 mov     ebp, esp
.text$mn:0000276B                 push    ecx
.text$mn:0000276C                 mov     [ebp+var_4], ecx
.text$mn:0000276F                 mov     eax, [ebp+var_4]
.text$mn:00002772                 mov     eax, [eax+4]
.text$mn:00002775                 mov     esp, ebp
.text$mn:00002777                 pop     ebp
.text$mn:00002778                 retn
.text$mn:00002778 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00002778
.text$mn:00002778 ; ---------------------------------------------------------------------------
.text$mn:00002779                 align 4
.text$mn:00002779 _text$mn        ends
.text$mn:00002779
.text$mn:0000277C ; ===========================================================================
.text$mn:0000277C
.text$mn:0000277C ; Segment type: Pure code
.text$mn:0000277C ; Segment permissions: Read/Execute
.text$mn:0000277C _text$mn        segment para public 'CODE' use32
.text$mn:0000277C                 assume cs:_text$mn
.text$mn:0000277C                 ;org 277Ch
.text$mn:0000277C ; COMDAT (pick any)
.text$mn:0000277C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000277C
.text$mn:0000277C ; =============== S U B R O U T I N E =======================================
.text$mn:0000277C
.text$mn:0000277C ; Attributes: bp-based frame
.text$mn:0000277C
.text$mn:0000277C ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:0000277C                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:0000277C ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:0000277C                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:0000277C                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:0000277C
.text$mn:0000277C var_4           = dword ptr -4
.text$mn:0000277C
.text$mn:0000277C                 push    ebp
.text$mn:0000277D                 mov     ebp, esp
.text$mn:0000277F                 push    ecx
.text$mn:00002780                 mov     [ebp+var_4], ecx
.text$mn:00002783                 mov     eax, [ebp+var_4]
.text$mn:00002786                 mov     eax, [eax+4]
.text$mn:00002789                 mov     esp, ebp
.text$mn:0000278B                 pop     ebp
.text$mn:0000278C                 retn
.text$mn:0000278C ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:0000278C
.text$mn:0000278C ; ---------------------------------------------------------------------------
.text$mn:0000278D                 align 10h
.text$mn:0000278D _text$mn        ends
.text$mn:0000278D
.text$mn:00002790 ; ===========================================================================
.text$mn:00002790
.text$mn:00002790 ; Segment type: Pure code
.text$mn:00002790 ; Segment permissions: Read/Execute
.text$mn:00002790 _text$mn        segment para public 'CODE' use32
.text$mn:00002790                 assume cs:_text$mn
.text$mn:00002790                 ;org 2790h
.text$mn:00002790 ; COMDAT (pick any)
.text$mn:00002790                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002790
.text$mn:00002790 ; =============== S U B R O U T I N E =======================================
.text$mn:00002790
.text$mn:00002790 ; Attributes: bp-based frame
.text$mn:00002790
.text$mn:00002790 ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:00002790                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002790 ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:00002790                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:00002790
.text$mn:00002790 var_4           = dword ptr -4
.text$mn:00002790 Dst             = dword ptr  8
.text$mn:00002790 Src             = dword ptr  0Ch
.text$mn:00002790 Size            = dword ptr  10h
.text$mn:00002790
.text$mn:00002790                 push    ebp
.text$mn:00002791                 mov     ebp, esp
.text$mn:00002793                 push    ecx
.text$mn:00002794                 cmp     [ebp+Size], 0
.text$mn:00002798                 jnz     short loc_27A2
.text$mn:0000279A                 mov     eax, [ebp+Dst]
.text$mn:0000279D                 mov     [ebp+var_4], eax
.text$mn:000027A0                 jmp     short loc_27B9
.text$mn:000027A2 ; ---------------------------------------------------------------------------
.text$mn:000027A2
.text$mn:000027A2 loc_27A2:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:000027A2                 mov     ecx, [ebp+Size]
.text$mn:000027A5                 push    ecx             ; Size
.text$mn:000027A6                 mov     edx, [ebp+Src]
.text$mn:000027A9                 push    edx             ; Src
.text$mn:000027AA                 mov     eax, [ebp+Dst]
.text$mn:000027AD                 push    eax             ; Dst
.text$mn:000027AE                 call    _memcpy
.text$mn:000027B3                 add     esp, 0Ch
.text$mn:000027B6                 mov     [ebp+var_4], eax
.text$mn:000027B9
.text$mn:000027B9 loc_27B9:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000027B9                 mov     eax, [ebp+var_4]
.text$mn:000027BC                 mov     esp, ebp
.text$mn:000027BE                 pop     ebp
.text$mn:000027BF                 retn
.text$mn:000027BF ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000027BF
.text$mn:000027BF _text$mn        ends
.text$mn:000027BF
.text$mn:000027C0 ; ===========================================================================
.text$mn:000027C0
.text$mn:000027C0 ; Segment type: Pure code
.text$mn:000027C0 ; Segment permissions: Read/Execute
.text$mn:000027C0 _text$mn        segment para public 'CODE' use32
.text$mn:000027C0                 assume cs:_text$mn
.text$mn:000027C0                 ;org 27C0h
.text$mn:000027C0 ; COMDAT (pick any)
.text$mn:000027C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027C0
.text$mn:000027C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027C0
.text$mn:000027C0 ; Attributes: bp-based frame
.text$mn:000027C0
.text$mn:000027C0 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000027C0                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000027C0 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000027C0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000027C0
.text$mn:000027C0 var_4           = dword ptr -4
.text$mn:000027C0 arg_0           = dword ptr  8
.text$mn:000027C0 arg_4           = dword ptr  0Ch
.text$mn:000027C0
.text$mn:000027C0                 push    ebp
.text$mn:000027C1                 mov     ebp, esp
.text$mn:000027C3                 push    ecx
.text$mn:000027C4                 mov     [ebp+var_4], ecx
.text$mn:000027C7                 mov     eax, [ebp+arg_4]
.text$mn:000027CA                 push    eax             ; int
.text$mn:000027CB                 mov     ecx, [ebp+arg_0]
.text$mn:000027CE                 push    ecx             ; void *
.text$mn:000027CF                 mov     ecx, [ebp+var_4]
.text$mn:000027D2                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000027D7                 mov     esp, ebp
.text$mn:000027D9                 pop     ebp
.text$mn:000027DA                 retn    8
.text$mn:000027DA ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000027DA
.text$mn:000027DA ; ---------------------------------------------------------------------------
.text$mn:000027DD                 align 10h
.text$mn:000027DD _text$mn        ends
.text$mn:000027DD
.text$mn:000027E0 ; ===========================================================================
.text$mn:000027E0
.text$mn:000027E0 ; Segment type: Pure code
.text$mn:000027E0 ; Segment permissions: Read/Execute
.text$mn:000027E0 _text$mn        segment para public 'CODE' use32
.text$mn:000027E0                 assume cs:_text$mn
.text$mn:000027E0                 ;org 27E0h
.text$mn:000027E0 ; COMDAT (pick any)
.text$mn:000027E0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027E0
.text$mn:000027E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000027E0
.text$mn:000027E0 ; Attributes: bp-based frame
.text$mn:000027E0
.text$mn:000027E0 ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:000027E0                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:000027E0 ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:000027E0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:000027E0
.text$mn:000027E0 var_4           = dword ptr -4
.text$mn:000027E0 arg_0           = dword ptr  8
.text$mn:000027E0
.text$mn:000027E0                 push    ebp
.text$mn:000027E1                 mov     ebp, esp
.text$mn:000027E3                 push    ecx
.text$mn:000027E4                 mov     [ebp+var_4], ecx
.text$mn:000027E7                 mov     eax, [ebp+arg_0]
.text$mn:000027EA                 push    eax             ; void *
.text$mn:000027EB                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000027F0                 add     esp, 4
.text$mn:000027F3                 mov     esp, ebp
.text$mn:000027F5                 pop     ebp
.text$mn:000027F6                 retn    8
.text$mn:000027F6 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:000027F6
.text$mn:000027F6 ; ---------------------------------------------------------------------------
.text$mn:000027F9                 align 4
.text$mn:000027F9 _text$mn        ends
.text$mn:000027F9
.text$mn:000027FC ; ===========================================================================
.text$mn:000027FC
.text$mn:000027FC ; Segment type: Pure code
.text$mn:000027FC ; Segment permissions: Read/Execute
.text$mn:000027FC _text$mn        segment para public 'CODE' use32
.text$mn:000027FC                 assume cs:_text$mn
.text$mn:000027FC                 ;org 27FCh
.text$mn:000027FC ; COMDAT (pick any)
.text$mn:000027FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000027FC
.text$mn:000027FC ; =============== S U B R O U T I N E =======================================
.text$mn:000027FC
.text$mn:000027FC ; Attributes: bp-based frame
.text$mn:000027FC
.text$mn:000027FC ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:000027FC                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000027FC ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000027FC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:000027FC
.text$mn:000027FC var_4           = dword ptr -4
.text$mn:000027FC arg_0           = dword ptr  8
.text$mn:000027FC
.text$mn:000027FC                 push    ebp
.text$mn:000027FD                 mov     ebp, esp
.text$mn:000027FF                 push    ecx
.text$mn:00002800                 mov     [ebp+var_4], ecx
.text$mn:00002803                 mov     eax, [ebp+arg_0]
.text$mn:00002806                 push    eax             ; void *
.text$mn:00002807                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000280C                 add     esp, 4
.text$mn:0000280F                 mov     esp, ebp
.text$mn:00002811                 pop     ebp
.text$mn:00002812                 retn    8
.text$mn:00002812 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00002812
.text$mn:00002812 ; ---------------------------------------------------------------------------
.text$mn:00002815                 align 4
.text$mn:00002815 _text$mn        ends
.text$mn:00002815
.text$mn:00002818 ; ===========================================================================
.text$mn:00002818
.text$mn:00002818 ; Segment type: Pure code
.text$mn:00002818 ; Segment permissions: Read/Execute
.text$mn:00002818 _text$mn        segment para public 'CODE' use32
.text$mn:00002818                 assume cs:_text$mn
.text$mn:00002818                 ;org 2818h
.text$mn:00002818 ; COMDAT (pick any)
.text$mn:00002818                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002818
.text$mn:00002818 ; =============== S U B R O U T I N E =======================================
.text$mn:00002818
.text$mn:00002818 ; Attributes: bp-based frame
.text$mn:00002818
.text$mn:00002818 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00002818                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002818 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002818                                         ; DATA XREF: .rdata:0000329Co
.text$mn:00002818
.text$mn:00002818 var_4           = dword ptr -4
.text$mn:00002818 arg_0           = dword ptr  8
.text$mn:00002818 arg_4           = dword ptr  0Ch
.text$mn:00002818
.text$mn:00002818                 push    ebp
.text$mn:00002819                 mov     ebp, esp
.text$mn:0000281B                 push    ecx
.text$mn:0000281C                 mov     [ebp+var_4], ecx
.text$mn:0000281F                 mov     eax, [ebp+arg_4]
.text$mn:00002822                 push    eax             ; int
.text$mn:00002823                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002828                 add     esp, 4
.text$mn:0000282B                 test    eax, eax
.text$mn:0000282D                 jz      short loc_2848
.text$mn:0000282F                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:00002834                 push    eax             ; struct std::error_category *
.text$mn:00002835                 mov     ecx, [ebp+arg_4]
.text$mn:00002838                 push    ecx             ; int
.text$mn:00002839                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000283C                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00002841                 mov     eax, [ebp+arg_0]
.text$mn:00002844                 jmp     short loc_285D
.text$mn:00002846 ; ---------------------------------------------------------------------------
.text$mn:00002846                 jmp     short loc_285D
.text$mn:00002848 ; ---------------------------------------------------------------------------
.text$mn:00002848
.text$mn:00002848 loc_2848:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00002848                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:0000284D                 push    eax             ; struct std::error_category *
.text$mn:0000284E                 mov     edx, [ebp+arg_4]
.text$mn:00002851                 push    edx             ; int
.text$mn:00002852                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002855                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000285A                 mov     eax, [ebp+arg_0]
.text$mn:0000285D
.text$mn:0000285D loc_285D:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:0000285D                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:0000285D                 mov     esp, ebp
.text$mn:0000285F                 pop     ebp
.text$mn:00002860                 retn    8
.text$mn:00002860 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002860
.text$mn:00002860 ; ---------------------------------------------------------------------------
.text$mn:00002863                 align 4
.text$mn:00002863 _text$mn        ends
.text$mn:00002863
.text$mn:00002864 ; ===========================================================================
.text$mn:00002864
.text$mn:00002864 ; Segment type: Pure code
.text$mn:00002864 ; Segment permissions: Read/Execute
.text$mn:00002864 _text$mn        segment para public 'CODE' use32
.text$mn:00002864                 assume cs:_text$mn
.text$mn:00002864                 ;org 2864h
.text$mn:00002864 ; COMDAT (pick any)
.text$mn:00002864                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002864
.text$mn:00002864 ; =============== S U B R O U T I N E =======================================
.text$mn:00002864
.text$mn:00002864 ; Attributes: bp-based frame
.text$mn:00002864
.text$mn:00002864 ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:00002864                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00002864 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00002864                                         ; DATA XREF: .rdata:0000320Co
.text$mn:00002864                                         ; .rdata:00003228o ...
.text$mn:00002864
.text$mn:00002864 var_4           = dword ptr -4
.text$mn:00002864 arg_0           = dword ptr  8
.text$mn:00002864 arg_4           = dword ptr  0Ch
.text$mn:00002864
.text$mn:00002864                 push    ebp
.text$mn:00002865                 mov     ebp, esp
.text$mn:00002867                 push    ecx
.text$mn:00002868                 mov     [ebp+var_4], ecx
.text$mn:0000286B                 mov     eax, [ebp+var_4]
.text$mn:0000286E                 push    eax             ; struct std::error_category *
.text$mn:0000286F                 mov     ecx, [ebp+arg_4]
.text$mn:00002872                 push    ecx             ; int
.text$mn:00002873                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002876                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:0000287B                 mov     eax, [ebp+arg_0]
.text$mn:0000287E                 mov     esp, ebp
.text$mn:00002880                 pop     ebp
.text$mn:00002881                 retn    8
.text$mn:00002881 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:00002881
.text$mn:00002881 _text$mn        ends
.text$mn:00002881
.text$mn:00002884 ; ===========================================================================
.text$mn:00002884
.text$mn:00002884 ; Segment type: Pure code
.text$mn:00002884 ; Segment permissions: Read/Execute
.text$mn:00002884 _text$mn        segment para public 'CODE' use32
.text$mn:00002884                 assume cs:_text$mn
.text$mn:00002884                 ;org 2884h
.text$mn:00002884 ; COMDAT (pick any)
.text$mn:00002884                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002884
.text$mn:00002884 ; =============== S U B R O U T I N E =======================================
.text$mn:00002884
.text$mn:00002884 ; Attributes: bp-based frame
.text$mn:00002884
.text$mn:00002884 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00002884                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00002884 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00002884                                         ; DATA XREF: .rdata:00003210o
.text$mn:00002884                                         ; .rdata:0000322Co ...
.text$mn:00002884
.text$mn:00002884 var_8           = dword ptr -8
.text$mn:00002884 var_4           = dword ptr -4
.text$mn:00002884 arg_0           = dword ptr  8
.text$mn:00002884 arg_4           = dword ptr  0Ch
.text$mn:00002884
.text$mn:00002884                 push    ebp
.text$mn:00002885                 mov     ebp, esp
.text$mn:00002887                 sub     esp, 8
.text$mn:0000288A                 mov     [ebp+var_8], ecx
.text$mn:0000288D                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00002890                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00002895                 push    eax
.text$mn:00002896                 mov     ecx, [ebp+var_8]
.text$mn:00002899                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000289E                 movzx   eax, al
.text$mn:000028A1                 test    eax, eax
.text$mn:000028A3                 jz      short loc_28BB
.text$mn:000028A5                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000028A8                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:000028AD                 cmp     eax, [ebp+arg_4]
.text$mn:000028B0                 jnz     short loc_28BB
.text$mn:000028B2                 mov     [ebp+var_4], 1
.text$mn:000028B9                 jmp     short loc_28C2
.text$mn:000028BB ; ---------------------------------------------------------------------------
.text$mn:000028BB
.text$mn:000028BB loc_28BB:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:000028BB                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:000028BB                 mov     [ebp+var_4], 0
.text$mn:000028C2
.text$mn:000028C2 loc_28C2:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000028C2                 mov     al, byte ptr [ebp+var_4]
.text$mn:000028C5                 mov     esp, ebp
.text$mn:000028C7                 pop     ebp
.text$mn:000028C8                 retn    8
.text$mn:000028C8 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000028C8
.text$mn:000028C8 ; ---------------------------------------------------------------------------
.text$mn:000028CB                 align 4
.text$mn:000028CB _text$mn        ends
.text$mn:000028CB
.text$mn:000028CC ; ===========================================================================
.text$mn:000028CC
.text$mn:000028CC ; Segment type: Pure code
.text$mn:000028CC ; Segment permissions: Read/Execute
.text$mn:000028CC _text$mn        segment para public 'CODE' use32
.text$mn:000028CC                 assume cs:_text$mn
.text$mn:000028CC                 ;org 28CCh
.text$mn:000028CC ; COMDAT (pick any)
.text$mn:000028CC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028CC
.text$mn:000028CC ; =============== S U B R O U T I N E =======================================
.text$mn:000028CC
.text$mn:000028CC ; Attributes: bp-based frame
.text$mn:000028CC
.text$mn:000028CC ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000028CC                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000028CC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000028CC                                         ; DATA XREF: .rdata:00003214o
.text$mn:000028CC                                         ; .rdata:00003230o ...
.text$mn:000028CC
.text$mn:000028CC var_C           = byte ptr -0Ch
.text$mn:000028CC var_4           = dword ptr -4
.text$mn:000028CC arg_0           = dword ptr  8
.text$mn:000028CC arg_4           = dword ptr  0Ch
.text$mn:000028CC
.text$mn:000028CC                 push    ebp
.text$mn:000028CD                 mov     ebp, esp
.text$mn:000028CF                 sub     esp, 0Ch
.text$mn:000028D2                 mov     [ebp+var_4], ecx
.text$mn:000028D5                 mov     eax, [ebp+arg_4]
.text$mn:000028D8                 push    eax             ; std::error_condition *
.text$mn:000028D9                 mov     ecx, [ebp+arg_0]
.text$mn:000028DC                 push    ecx
.text$mn:000028DD                 lea     edx, [ebp+var_C]
.text$mn:000028E0                 push    edx
.text$mn:000028E1                 mov     eax, [ebp+var_4]
.text$mn:000028E4                 mov     edx, [eax]
.text$mn:000028E6                 mov     ecx, [ebp+var_4]
.text$mn:000028E9                 mov     eax, [edx+0Ch]
.text$mn:000028EC                 call    eax
.text$mn:000028EE                 mov     ecx, eax
.text$mn:000028F0                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000028F5                 mov     esp, ebp
.text$mn:000028F7                 pop     ebp
.text$mn:000028F8                 retn    8
.text$mn:000028F8 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000028F8
.text$mn:000028F8 ; ---------------------------------------------------------------------------
.text$mn:000028FB                 align 4
.text$mn:000028FB _text$mn        ends
.text$mn:000028FB
.text$mn:000028FC ; ===========================================================================
.text$mn:000028FC
.text$mn:000028FC ; Segment type: Pure code
.text$mn:000028FC ; Segment permissions: Read/Execute
.text$mn:000028FC _text$mn        segment para public 'CODE' use32
.text$mn:000028FC                 assume cs:_text$mn
.text$mn:000028FC                 ;org 28FCh
.text$mn:000028FC ; COMDAT (pick any)
.text$mn:000028FC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000028FC
.text$mn:000028FC ; =============== S U B R O U T I N E =======================================
.text$mn:000028FC
.text$mn:000028FC ; Attributes: bp-based frame
.text$mn:000028FC
.text$mn:000028FC ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000028FC                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000028FC ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000028FC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000028FC
.text$mn:000028FC var_4           = dword ptr -4
.text$mn:000028FC arg_0           = dword ptr  8
.text$mn:000028FC
.text$mn:000028FC                 push    ebp
.text$mn:000028FD                 mov     ebp, esp
.text$mn:000028FF                 push    ecx
.text$mn:00002900                 mov     [ebp+var_4], ecx
.text$mn:00002903                 mov     eax, [ebp+var_4]
.text$mn:00002906                 mov     ecx, [eax+14h]
.text$mn:00002909                 cmp     ecx, [ebp+arg_0]
.text$mn:0000290C                 jnb     short loc_2916
.text$mn:0000290E                 mov     ecx, [ebp+var_4]
.text$mn:00002911                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002916
.text$mn:00002916 loc_2916:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:00002916                 mov     edx, [ebp+arg_0]
.text$mn:00002919                 push    edx
.text$mn:0000291A                 mov     ecx, [ebp+var_4]
.text$mn:0000291D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002922                 mov     eax, [ebp+var_4]
.text$mn:00002925                 mov     esp, ebp
.text$mn:00002927                 pop     ebp
.text$mn:00002928                 retn    4
.text$mn:00002928 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00002928
.text$mn:00002928 ; ---------------------------------------------------------------------------
.text$mn:0000292B                 align 4
.text$mn:0000292B _text$mn        ends
.text$mn:0000292B
.text$mn:0000292C ; ===========================================================================
.text$mn:0000292C
.text$mn:0000292C ; Segment type: Pure code
.text$mn:0000292C ; Segment permissions: Read/Execute
.text$mn:0000292C _text$mn        segment para public 'CODE' use32
.text$mn:0000292C                 assume cs:_text$mn
.text$mn:0000292C                 ;org 292Ch
.text$mn:0000292C ; COMDAT (pick any)
.text$mn:0000292C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:0000292C
.text$mn:0000292C ; =============== S U B R O U T I N E =======================================
.text$mn:0000292C
.text$mn:0000292C ; Attributes: bp-based frame
.text$mn:0000292C
.text$mn:0000292C ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:0000292C                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:0000292C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:0000292C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:0000292C
.text$mn:0000292C var_C           = dword ptr -0Ch
.text$mn:0000292C Dst             = dword ptr -8
.text$mn:0000292C var_4           = dword ptr -4
.text$mn:0000292C arg_0           = dword ptr  8
.text$mn:0000292C arg_4           = dword ptr  0Ch
.text$mn:0000292C
.text$mn:0000292C                 push    ebp
.text$mn:0000292D                 mov     ebp, esp
.text$mn:0000292F                 sub     esp, 0Ch
.text$mn:00002932                 mov     [ebp+var_4], ecx
.text$mn:00002935                 mov     eax, [ebp+var_4]
.text$mn:00002938                 mov     ecx, [eax+14h]
.text$mn:0000293B                 cmp     ecx, [ebp+arg_0]
.text$mn:0000293E                 jnb     short loc_2948
.text$mn:00002940                 mov     ecx, [ebp+var_4]
.text$mn:00002943                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00002948
.text$mn:00002948 loc_2948:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00002948                 mov     edx, [ebp+var_4]
.text$mn:0000294B                 mov     eax, [edx+14h]
.text$mn:0000294E                 sub     eax, [ebp+arg_0]
.text$mn:00002951                 cmp     eax, [ebp+arg_4]
.text$mn:00002954                 ja      short loc_2964
.text$mn:00002956                 mov     ecx, [ebp+arg_0]
.text$mn:00002959                 push    ecx
.text$mn:0000295A                 mov     ecx, [ebp+var_4]
.text$mn:0000295D                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00002962                 jmp     short loc_29AA
.text$mn:00002964 ; ---------------------------------------------------------------------------
.text$mn:00002964
.text$mn:00002964 loc_2964:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00002964                 cmp     [ebp+arg_4], 0
.text$mn:00002968                 jbe     short loc_29AA
.text$mn:0000296A                 mov     ecx, [ebp+var_4]
.text$mn:0000296D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00002972                 add     eax, [ebp+arg_0]
.text$mn:00002975                 mov     [ebp+Dst], eax
.text$mn:00002978                 mov     edx, [ebp+var_4]
.text$mn:0000297B                 mov     eax, [edx+14h]
.text$mn:0000297E                 sub     eax, [ebp+arg_4]
.text$mn:00002981                 mov     [ebp+var_C], eax
.text$mn:00002984                 mov     ecx, [ebp+var_C]
.text$mn:00002987                 sub     ecx, [ebp+arg_0]
.text$mn:0000298A                 push    ecx             ; Size
.text$mn:0000298B                 mov     edx, [ebp+Dst]
.text$mn:0000298E                 add     edx, [ebp+arg_4]
.text$mn:00002991                 push    edx             ; Src
.text$mn:00002992                 mov     eax, [ebp+Dst]
.text$mn:00002995                 push    eax             ; Dst
.text$mn:00002996                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:0000299B                 add     esp, 0Ch
.text$mn:0000299E                 mov     ecx, [ebp+var_C]
.text$mn:000029A1                 push    ecx
.text$mn:000029A2                 mov     ecx, [ebp+var_4]
.text$mn:000029A5                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000029AA
.text$mn:000029AA loc_29AA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:000029AA                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:000029AA                 mov     eax, [ebp+var_4]
.text$mn:000029AD                 mov     esp, ebp
.text$mn:000029AF                 pop     ebp
.text$mn:000029B0                 retn    8
.text$mn:000029B0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:000029B0
.text$mn:000029B0 ; ---------------------------------------------------------------------------
.text$mn:000029B3                 align 4
.text$mn:000029B3 _text$mn        ends
.text$mn:000029B3
.text$mn:000029B4 ; ===========================================================================
.text$mn:000029B4
.text$mn:000029B4 ; Segment type: Pure code
.text$mn:000029B4 ; Segment permissions: Read/Execute
.text$mn:000029B4 _text$mn        segment para public 'CODE' use32
.text$mn:000029B4                 assume cs:_text$mn
.text$mn:000029B4                 ;org 29B4h
.text$mn:000029B4 ; COMDAT (pick any)
.text$mn:000029B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029B4
.text$mn:000029B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029B4
.text$mn:000029B4 ; Attributes: bp-based frame
.text$mn:000029B4
.text$mn:000029B4 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:000029B4                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:000029B4 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:000029B4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:000029B4                 push    ebp
.text$mn:000029B5                 mov     ebp, esp
.text$mn:000029B7                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:000029BC                 pop     ebp
.text$mn:000029BD                 retn
.text$mn:000029BD ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:000029BD
.text$mn:000029BD ; ---------------------------------------------------------------------------
.text$mn:000029BE                 align 10h
.text$mn:000029BE _text$mn        ends
.text$mn:000029BE
.text$mn:000029C0 ; ===========================================================================
.text$mn:000029C0
.text$mn:000029C0 ; Segment type: Pure code
.text$mn:000029C0 ; Segment permissions: Read/Execute
.text$mn:000029C0 _text$mn        segment para public 'CODE' use32
.text$mn:000029C0                 assume cs:_text$mn
.text$mn:000029C0                 ;org 29C0h
.text$mn:000029C0 ; COMDAT (pick any)
.text$mn:000029C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029C0
.text$mn:000029C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029C0
.text$mn:000029C0 ; Attributes: bp-based frame
.text$mn:000029C0
.text$mn:000029C0 ; struct Buffer *__thiscall FileManager::getBufferByID(FileManager *this, struct Buffer *)
.text$mn:000029C0                 public ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z
.text$mn:000029C0 ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z proc near
.text$mn:000029C0                                         ; CODE XREF: DocTabView::addBuffer(Buffer *)+35p
.text$mn:000029C0                                         ; DocTabView::findBufferByName(wchar_t const *)+5Fp ...
.text$mn:000029C0
.text$mn:000029C0 var_4           = dword ptr -4
.text$mn:000029C0 arg_0           = dword ptr  8
.text$mn:000029C0
.text$mn:000029C0                 push    ebp
.text$mn:000029C1                 mov     ebp, esp
.text$mn:000029C3                 push    ecx
.text$mn:000029C4                 mov     [ebp+var_4], ecx
.text$mn:000029C7                 mov     eax, [ebp+arg_0]
.text$mn:000029CA                 mov     esp, ebp
.text$mn:000029CC                 pop     ebp
.text$mn:000029CD                 retn    4
.text$mn:000029CD ?getBufferByID@FileManager@@QAEPAVBuffer@@PAV2@@Z endp
.text$mn:000029CD
.text$mn:000029CD _text$mn        ends
.text$mn:000029CD
.text$mn:000029D0 ; ===========================================================================
.text$mn:000029D0
.text$mn:000029D0 ; Segment type: Pure code
.text$mn:000029D0 ; Segment permissions: Read/Execute
.text$mn:000029D0 _text$mn        segment para public 'CODE' use32
.text$mn:000029D0                 assume cs:_text$mn
.text$mn:000029D0                 ;org 29D0h
.text$mn:000029D0 ; COMDAT (pick any)
.text$mn:000029D0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029D0
.text$mn:000029D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000029D0
.text$mn:000029D0 ; Attributes: bp-based frame
.text$mn:000029D0
.text$mn:000029D0 ; int __thiscall TabBar::getCurrentTabIndex(TabBar *__hidden this)
.text$mn:000029D0                 public ?getCurrentTabIndex@TabBar@@QBEHXZ
.text$mn:000029D0 ?getCurrentTabIndex@TabBar@@QBEHXZ proc near
.text$mn:000029D0                                         ; CODE XREF: DocTabView::activeBuffer(void)+Cp
.text$mn:000029D0
.text$mn:000029D0 var_4           = dword ptr -4
.text$mn:000029D0
.text$mn:000029D0                 push    ebp
.text$mn:000029D1                 mov     ebp, esp
.text$mn:000029D3                 push    ecx
.text$mn:000029D4                 mov     [ebp+var_4], ecx
.text$mn:000029D7                 push    0               ; lParam
.text$mn:000029D9                 push    0               ; wParam
.text$mn:000029DB                 push    130Bh           ; Msg
.text$mn:000029E0                 mov     eax, [ebp+var_4]
.text$mn:000029E3                 mov     ecx, [eax+0Ch]
.text$mn:000029E6                 push    ecx             ; hWnd
.text$mn:000029E7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:000029ED                 mov     esp, ebp
.text$mn:000029EF                 pop     ebp
.text$mn:000029F0                 retn
.text$mn:000029F0 ?getCurrentTabIndex@TabBar@@QBEHXZ endp
.text$mn:000029F0
.text$mn:000029F0 ; ---------------------------------------------------------------------------
.text$mn:000029F1                 align 4
.text$mn:000029F1 _text$mn        ends
.text$mn:000029F1
.text$mn:000029F4 ; ===========================================================================
.text$mn:000029F4
.text$mn:000029F4 ; Segment type: Pure code
.text$mn:000029F4 ; Segment permissions: Read/Execute
.text$mn:000029F4 _text$mn        segment para public 'CODE' use32
.text$mn:000029F4                 assume cs:_text$mn
.text$mn:000029F4                 ;org 29F4h
.text$mn:000029F4 ; COMDAT (pick any)
.text$mn:000029F4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:000029F4
.text$mn:000029F4 ; =============== S U B R O U T I N E =======================================
.text$mn:000029F4
.text$mn:000029F4 ; Attributes: bp-based frame
.text$mn:000029F4
.text$mn:000029F4 ; const wchar_t *__thiscall Buffer::getFileName(Buffer *__hidden this)
.text$mn:000029F4                 public ?getFileName@Buffer@@QBEPB_WXZ
.text$mn:000029F4 ?getFileName@Buffer@@QBEPB_WXZ proc near
.text$mn:000029F4                                         ; CODE XREF: DocTabView::addBuffer(Buffer *)+66p
.text$mn:000029F4                                         ; DocTabView::bufferUpdated(Buffer *,int)+EAp
.text$mn:000029F4
.text$mn:000029F4 var_4           = dword ptr -4
.text$mn:000029F4
.text$mn:000029F4                 push    ebp
.text$mn:000029F5                 mov     ebp, esp
.text$mn:000029F7                 push    ecx
.text$mn:000029F8                 mov     [ebp+var_4], ecx
.text$mn:000029FB                 mov     eax, [ebp+var_4]
.text$mn:000029FE                 mov     eax, [eax+0A8h]
.text$mn:00002A04                 mov     esp, ebp
.text$mn:00002A06                 pop     ebp
.text$mn:00002A07                 retn
.text$mn:00002A07 ?getFileName@Buffer@@QBEPB_WXZ endp
.text$mn:00002A07
.text$mn:00002A07 _text$mn        ends
.text$mn:00002A07
.text$mn:00002A08 ; ===========================================================================
.text$mn:00002A08
.text$mn:00002A08 ; Segment type: Pure code
.text$mn:00002A08 ; Segment permissions: Read/Execute
.text$mn:00002A08 _text$mn        segment para public 'CODE' use32
.text$mn:00002A08                 assume cs:_text$mn
.text$mn:00002A08                 ;org 2A08h
.text$mn:00002A08 ; COMDAT (pick any)
.text$mn:00002A08                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A08
.text$mn:00002A08 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A08
.text$mn:00002A08 ; Attributes: bp-based frame
.text$mn:00002A08
.text$mn:00002A08 ; const wchar_t *__thiscall Buffer::getFullPathName(Buffer *__hidden this)
.text$mn:00002A08                 public ?getFullPathName@Buffer@@QBEPB_WXZ
.text$mn:00002A08 ?getFullPathName@Buffer@@QBEPB_WXZ proc near
.text$mn:00002A08                                         ; CODE XREF: DocTabView::findBufferByName(wchar_t const *)+6Ap
.text$mn:00002A08
.text$mn:00002A08 var_4           = dword ptr -4
.text$mn:00002A08
.text$mn:00002A08                 push    ebp
.text$mn:00002A09                 mov     ebp, esp
.text$mn:00002A0B                 push    ecx
.text$mn:00002A0C                 mov     [ebp+var_4], ecx
.text$mn:00002A0F                 mov     ecx, [ebp+var_4]
.text$mn:00002A12                 add     ecx, 8Ch ; 'î'
.text$mn:00002A18                 call    ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEPB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>::c_str(void)
.text$mn:00002A1D                 mov     esp, ebp
.text$mn:00002A1F                 pop     ebp
.text$mn:00002A20                 retn
.text$mn:00002A20 ?getFullPathName@Buffer@@QBEPB_WXZ endp
.text$mn:00002A20
.text$mn:00002A20 ; ---------------------------------------------------------------------------
.text$mn:00002A21                 align 4
.text$mn:00002A21 _text$mn        ends
.text$mn:00002A21
.text$mn:00002A24 ; ===========================================================================
.text$mn:00002A24
.text$mn:00002A24 ; Segment type: Pure code
.text$mn:00002A24 ; Segment permissions: Read/Execute
.text$mn:00002A24 _text$mn        segment para public 'CODE' use32
.text$mn:00002A24                 assume cs:_text$mn
.text$mn:00002A24                 ;org 2A24h
.text$mn:00002A24 ; COMDAT (pick any)
.text$mn:00002A24                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A24
.text$mn:00002A24 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A24
.text$mn:00002A24 ; Attributes: bp-based frame
.text$mn:00002A24
.text$mn:00002A24 ; struct Buffer *__thiscall Buffer::getID(Buffer *__hidden this)
.text$mn:00002A24                 public ?getID@Buffer@@QBEPAV1@XZ
.text$mn:00002A24 ?getID@Buffer@@QBEPAV1@XZ proc near     ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+1Cp
.text$mn:00002A24
.text$mn:00002A24 var_4           = dword ptr -4
.text$mn:00002A24
.text$mn:00002A24                 push    ebp
.text$mn:00002A25                 mov     ebp, esp
.text$mn:00002A27                 push    ecx
.text$mn:00002A28                 mov     [ebp+var_4], ecx
.text$mn:00002A2B                 mov     eax, [ebp+var_4]
.text$mn:00002A2E                 mov     eax, [eax+0Ch]
.text$mn:00002A31                 mov     esp, ebp
.text$mn:00002A33                 pop     ebp
.text$mn:00002A34                 retn
.text$mn:00002A34 ?getID@Buffer@@QBEPAV1@XZ endp
.text$mn:00002A34
.text$mn:00002A34 ; ---------------------------------------------------------------------------
.text$mn:00002A35                 align 4
.text$mn:00002A35 _text$mn        ends
.text$mn:00002A35
.text$mn:00002A38 ; ===========================================================================
.text$mn:00002A38
.text$mn:00002A38 ; Segment type: Pure code
.text$mn:00002A38 ; Segment permissions: Read/Execute
.text$mn:00002A38 _text$mn        segment para public 'CODE' use32
.text$mn:00002A38                 assume cs:_text$mn
.text$mn:00002A38                 ;org 2A38h
.text$mn:00002A38 ; COMDAT (pick any)
.text$mn:00002A38                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A38
.text$mn:00002A38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A38
.text$mn:00002A38 ; Attributes: bp-based frame
.text$mn:00002A38
.text$mn:00002A38 ; struct FileManager *__cdecl FileManager::getInstance()
.text$mn:00002A38                 public ?getInstance@FileManager@@SAPAV1@XZ
.text$mn:00002A38 ?getInstance@FileManager@@SAPAV1@XZ proc near
.text$mn:00002A38                                         ; CODE XREF: DocTabView::addBuffer(Buffer *)+2Ep
.text$mn:00002A38                                         ; DocTabView::findBufferByName(wchar_t const *)+58p ...
.text$mn:00002A38                 push    ebp
.text$mn:00002A39                 mov     ebp, esp
.text$mn:00002A3B                 mov     eax, dword ptr ds:?_pSelf@FileManager@@0PAV1@A ; FileManager * FileManager::_pSelf
.text$mn:00002A40                 pop     ebp
.text$mn:00002A41                 retn
.text$mn:00002A41 ?getInstance@FileManager@@SAPAV1@XZ endp
.text$mn:00002A41
.text$mn:00002A41 ; ---------------------------------------------------------------------------
.text$mn:00002A42                 align 4
.text$mn:00002A42 _text$mn        ends
.text$mn:00002A42
.text$mn:00002A44 ; ===========================================================================
.text$mn:00002A44
.text$mn:00002A44 ; Segment type: Pure code
.text$mn:00002A44 ; Segment permissions: Read/Execute
.text$mn:00002A44 _text$mn        segment para public 'CODE' use32
.text$mn:00002A44                 assume cs:_text$mn
.text$mn:00002A44                 ;org 2A44h
.text$mn:00002A44 ; COMDAT (pick any)
.text$mn:00002A44                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A44
.text$mn:00002A44 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A44
.text$mn:00002A44 ; Attributes: bp-based frame
.text$mn:00002A44
.text$mn:00002A44 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00002A44                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00002A44 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00002A44                                         ; CODE XREF: DocTabView::reSizeTo(tagRECT &)+13p
.text$mn:00002A44                 push    ebp
.text$mn:00002A45                 mov     ebp, esp
.text$mn:00002A47                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00002A4C                 pop     ebp
.text$mn:00002A4D                 retn
.text$mn:00002A4D ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00002A4D
.text$mn:00002A4D ; ---------------------------------------------------------------------------
.text$mn:00002A4E                 align 10h
.text$mn:00002A4E _text$mn        ends
.text$mn:00002A4E
.text$mn:00002A50 ; ===========================================================================
.text$mn:00002A50
.text$mn:00002A50 ; Segment type: Pure code
.text$mn:00002A50 ; Segment permissions: Read/Execute
.text$mn:00002A50 _text$mn        segment para public 'CODE' use32
.text$mn:00002A50                 assume cs:_text$mn
.text$mn:00002A50                 ;org 2A50h
.text$mn:00002A50 ; COMDAT (pick any)
.text$mn:00002A50                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A50
.text$mn:00002A50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A50
.text$mn:00002A50 ; Attributes: bp-based frame
.text$mn:00002A50
.text$mn:00002A50 ; const struct ScintillaViewParams *__thiscall NppParameters::getSVP(NppParameters *__hidden this)
.text$mn:00002A50                 public ?getSVP@NppParameters@@QBEABUScintillaViewParams@@XZ
.text$mn:00002A50 ?getSVP@NppParameters@@QBEABUScintillaViewParams@@XZ proc near
.text$mn:00002A50                                         ; CODE XREF: DocTabView::reSizeTo(tagRECT &)+1Ap
.text$mn:00002A50
.text$mn:00002A50 var_4           = dword ptr -4
.text$mn:00002A50
.text$mn:00002A50                 push    ebp
.text$mn:00002A51                 mov     ebp, esp
.text$mn:00002A53                 push    ecx
.text$mn:00002A54                 mov     [ebp+var_4], ecx
.text$mn:00002A57                 mov     eax, [ebp+var_4]
.text$mn:00002A5A                 add     eax, 7BCh
.text$mn:00002A5F                 mov     esp, ebp
.text$mn:00002A61                 pop     ebp
.text$mn:00002A62                 retn
.text$mn:00002A62 ?getSVP@NppParameters@@QBEABUScintillaViewParams@@XZ endp
.text$mn:00002A62
.text$mn:00002A62 ; ---------------------------------------------------------------------------
.text$mn:00002A63                 align 4
.text$mn:00002A63 _text$mn        ends
.text$mn:00002A63
.text$mn:00002A64 ; ===========================================================================
.text$mn:00002A64
.text$mn:00002A64 ; Segment type: Pure code
.text$mn:00002A64 ; Segment permissions: Read/Execute
.text$mn:00002A64 _text$mn        segment para public 'CODE' use32
.text$mn:00002A64                 assume cs:_text$mn
.text$mn:00002A64                 ;org 2A64h
.text$mn:00002A64 ; COMDAT (pick any)
.text$mn:00002A64                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A64
.text$mn:00002A64 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A64
.text$mn:00002A64 ; Attributes: bp-based frame
.text$mn:00002A64
.text$mn:00002A64 ; bool __thiscall Buffer::isDirty(Buffer *__hidden this)
.text$mn:00002A64                 public ?isDirty@Buffer@@QBE_NXZ
.text$mn:00002A64 ?isDirty@Buffer@@QBE_NXZ proc near      ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+77p
.text$mn:00002A64
.text$mn:00002A64 var_4           = dword ptr -4
.text$mn:00002A64
.text$mn:00002A64                 push    ebp
.text$mn:00002A65                 mov     ebp, esp
.text$mn:00002A67                 push    ecx
.text$mn:00002A68                 mov     [ebp+var_4], ecx
.text$mn:00002A6B                 mov     eax, [ebp+var_4]
.text$mn:00002A6E                 mov     al, [eax+34h]
.text$mn:00002A71                 mov     esp, ebp
.text$mn:00002A73                 pop     ebp
.text$mn:00002A74                 retn
.text$mn:00002A74 ?isDirty@Buffer@@QBE_NXZ endp
.text$mn:00002A74
.text$mn:00002A74 ; ---------------------------------------------------------------------------
.text$mn:00002A75                 align 4
.text$mn:00002A75 _text$mn        ends
.text$mn:00002A75
.text$mn:00002A78 ; ===========================================================================
.text$mn:00002A78
.text$mn:00002A78 ; Segment type: Pure code
.text$mn:00002A78 ; Segment permissions: Read/Execute
.text$mn:00002A78 _text$mn        segment para public 'CODE' use32
.text$mn:00002A78                 assume cs:_text$mn
.text$mn:00002A78                 ;org 2A78h
.text$mn:00002A78 ; COMDAT (pick any)
.text$mn:00002A78                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002A78
.text$mn:00002A78 ; =============== S U B R O U T I N E =======================================
.text$mn:00002A78
.text$mn:00002A78 ; Attributes: bp-based frame
.text$mn:00002A78
.text$mn:00002A78 ; bool __thiscall Buffer::isReadOnly(Buffer *__hidden this)
.text$mn:00002A78                 public ?isReadOnly@Buffer@@QBE_NXZ
.text$mn:00002A78 ?isReadOnly@Buffer@@QBE_NXZ proc near   ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+A8p
.text$mn:00002A78
.text$mn:00002A78 var_8           = dword ptr -8
.text$mn:00002A78 var_4           = dword ptr -4
.text$mn:00002A78
.text$mn:00002A78                 push    ebp
.text$mn:00002A79                 mov     ebp, esp
.text$mn:00002A7B                 sub     esp, 8
.text$mn:00002A7E                 mov     [ebp+var_4], ecx
.text$mn:00002A81                 mov     eax, [ebp+var_4]
.text$mn:00002A84                 movzx   ecx, byte ptr [eax+44h]
.text$mn:00002A88                 test    ecx, ecx
.text$mn:00002A8A                 jnz     short loc_2AA3
.text$mn:00002A8C                 mov     edx, [ebp+var_4]
.text$mn:00002A8F                 movzx   eax, byte ptr [edx+88h]
.text$mn:00002A96                 test    eax, eax
.text$mn:00002A98                 jnz     short loc_2AA3
.text$mn:00002A9A                 mov     [ebp+var_8], 0
.text$mn:00002AA1                 jmp     short loc_2AAA
.text$mn:00002AA3 ; ---------------------------------------------------------------------------
.text$mn:00002AA3
.text$mn:00002AA3 loc_2AA3:                               ; CODE XREF: Buffer::isReadOnly(void)+12j
.text$mn:00002AA3                                         ; Buffer::isReadOnly(void)+20j
.text$mn:00002AA3                 mov     [ebp+var_8], 1
.text$mn:00002AAA
.text$mn:00002AAA loc_2AAA:                               ; CODE XREF: Buffer::isReadOnly(void)+29j
.text$mn:00002AAA                 mov     al, byte ptr [ebp+var_8]
.text$mn:00002AAD                 mov     esp, ebp
.text$mn:00002AAF                 pop     ebp
.text$mn:00002AB0                 retn
.text$mn:00002AB0 ?isReadOnly@Buffer@@QBE_NXZ endp
.text$mn:00002AB0
.text$mn:00002AB0 ; ---------------------------------------------------------------------------
.text$mn:00002AB1                 align 4
.text$mn:00002AB1 _text$mn        ends
.text$mn:00002AB1
.text$mn:00002AB4 ; ===========================================================================
.text$mn:00002AB4
.text$mn:00002AB4 ; Segment type: Pure code
.text$mn:00002AB4 ; Segment permissions: Read/Execute
.text$mn:00002AB4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AB4                 assume cs:_text$mn
.text$mn:00002AB4                 ;org 2AB4h
.text$mn:00002AB4 ; COMDAT (pick any)
.text$mn:00002AB4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AB4
.text$mn:00002AB4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AB4
.text$mn:00002AB4 ; Attributes: bp-based frame
.text$mn:00002AB4
.text$mn:00002AB4 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00002AB4                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00002AB4 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00002AB4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00002AB4
.text$mn:00002AB4 var_4           = dword ptr -4
.text$mn:00002AB4 Str             = dword ptr  8
.text$mn:00002AB4
.text$mn:00002AB4                 push    ebp
.text$mn:00002AB5                 mov     ebp, esp
.text$mn:00002AB7                 push    ecx
.text$mn:00002AB8                 mov     eax, [ebp+Str]
.text$mn:00002ABB                 movsx   ecx, byte ptr [eax]
.text$mn:00002ABE                 test    ecx, ecx
.text$mn:00002AC0                 jnz     short loc_2ACB
.text$mn:00002AC2                 mov     [ebp+var_4], 0
.text$mn:00002AC9                 jmp     short loc_2ADA
.text$mn:00002ACB ; ---------------------------------------------------------------------------
.text$mn:00002ACB
.text$mn:00002ACB loc_2ACB:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00002ACB                 mov     edx, [ebp+Str]
.text$mn:00002ACE                 push    edx             ; Str
.text$mn:00002ACF                 call    _strlen
.text$mn:00002AD4                 add     esp, 4
.text$mn:00002AD7                 mov     [ebp+var_4], eax
.text$mn:00002ADA
.text$mn:00002ADA loc_2ADA:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00002ADA                 mov     eax, [ebp+var_4]
.text$mn:00002ADD                 mov     esp, ebp
.text$mn:00002ADF                 pop     ebp
.text$mn:00002AE0                 retn
.text$mn:00002AE0 ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00002AE0
.text$mn:00002AE0 ; ---------------------------------------------------------------------------
.text$mn:00002AE1                 align 4
.text$mn:00002AE1 _text$mn        ends
.text$mn:00002AE1
.text$mn:00002AE4 ; ===========================================================================
.text$mn:00002AE4
.text$mn:00002AE4 ; Segment type: Pure code
.text$mn:00002AE4 ; Segment permissions: Read/Execute
.text$mn:00002AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AE4                 assume cs:_text$mn
.text$mn:00002AE4                 ;org 2AE4h
.text$mn:00002AE4 ; COMDAT (pick any)
.text$mn:00002AE4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AE4
.text$mn:00002AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AE4
.text$mn:00002AE4 ; Attributes: bp-based frame
.text$mn:00002AE4
.text$mn:00002AE4 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00002AE4                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00002AE4 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00002AE4                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00002AE4
.text$mn:00002AE4 var_4           = dword ptr -4
.text$mn:00002AE4
.text$mn:00002AE4                 push    ebp
.text$mn:00002AE5                 mov     ebp, esp
.text$mn:00002AE7                 push    ecx
.text$mn:00002AE8                 mov     [ebp+var_4], ecx
.text$mn:00002AEB                 mov     eax, [ebp+var_4]
.text$mn:00002AEE                 push    eax
.text$mn:00002AEF                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00002AF4                 add     esp, 4
.text$mn:00002AF7                 mov     esp, ebp
.text$mn:00002AF9                 pop     ebp
.text$mn:00002AFA                 retn
.text$mn:00002AFA ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00002AFA
.text$mn:00002AFA ; ---------------------------------------------------------------------------
.text$mn:00002AFB                 align 4
.text$mn:00002AFB _text$mn        ends
.text$mn:00002AFB
.text$mn:00002AFC ; ===========================================================================
.text$mn:00002AFC
.text$mn:00002AFC ; Segment type: Pure code
.text$mn:00002AFC ; Segment permissions: Read/Execute
.text$mn:00002AFC _text$mn        segment para public 'CODE' use32
.text$mn:00002AFC                 assume cs:_text$mn
.text$mn:00002AFC                 ;org 2AFCh
.text$mn:00002AFC ; COMDAT (pick any)
.text$mn:00002AFC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002AFC
.text$mn:00002AFC ; =============== S U B R O U T I N E =======================================
.text$mn:00002AFC
.text$mn:00002AFC ; Attributes: bp-based frame
.text$mn:00002AFC
.text$mn:00002AFC ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00002AFC                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00002AFC ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00002AFC                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00002AFC
.text$mn:00002AFC var_4           = dword ptr -4
.text$mn:00002AFC
.text$mn:00002AFC                 push    ebp
.text$mn:00002AFD                 mov     ebp, esp
.text$mn:00002AFF                 push    ecx
.text$mn:00002B00                 mov     [ebp+var_4], ecx
.text$mn:00002B03                 or      eax, 0FFFFFFFFh
.text$mn:00002B06                 mov     esp, ebp
.text$mn:00002B08                 pop     ebp
.text$mn:00002B09                 retn
.text$mn:00002B09 ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00002B09
.text$mn:00002B09 ; ---------------------------------------------------------------------------
.text$mn:00002B0A                 align 4
.text$mn:00002B0A _text$mn        ends
.text$mn:00002B0A
.text$mn:00002B0C ; ===========================================================================
.text$mn:00002B0C
.text$mn:00002B0C ; Segment type: Pure code
.text$mn:00002B0C ; Segment permissions: Read/Execute
.text$mn:00002B0C _text$mn        segment para public 'CODE' use32
.text$mn:00002B0C                 assume cs:_text$mn
.text$mn:00002B0C                 ;org 2B0Ch
.text$mn:00002B0C ; COMDAT (pick any)
.text$mn:00002B0C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B0C
.text$mn:00002B0C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B0C
.text$mn:00002B0C ; Attributes: bp-based frame
.text$mn:00002B0C
.text$mn:00002B0C ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00002B0C                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00002B0C ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00002B0C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00002B0C
.text$mn:00002B0C arg_0           = dword ptr  8
.text$mn:00002B0C
.text$mn:00002B0C                 push    ebp
.text$mn:00002B0D                 mov     ebp, esp
.text$mn:00002B0F                 mov     ecx, [ebp+arg_0]
.text$mn:00002B12                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00002B17                 pop     ebp
.text$mn:00002B18                 retn
.text$mn:00002B18 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00002B18
.text$mn:00002B18 ; ---------------------------------------------------------------------------
.text$mn:00002B19                 align 4
.text$mn:00002B19 _text$mn        ends
.text$mn:00002B19
.text$mn:00002B1C ; ===========================================================================
.text$mn:00002B1C
.text$mn:00002B1C ; Segment type: Pure code
.text$mn:00002B1C ; Segment permissions: Read/Execute
.text$mn:00002B1C _text$mn        segment para public 'CODE' use32
.text$mn:00002B1C                 assume cs:_text$mn
.text$mn:00002B1C                 ;org 2B1Ch
.text$mn:00002B1C ; COMDAT (pick any)
.text$mn:00002B1C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B1C
.text$mn:00002B1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B1C
.text$mn:00002B1C ; Attributes: bp-based frame
.text$mn:00002B1C
.text$mn:00002B1C ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00002B1C                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002B1C ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002B1C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00002B1C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00002B1C
.text$mn:00002B1C var_10          = dword ptr -10h
.text$mn:00002B1C var_C           = dword ptr -0Ch
.text$mn:00002B1C var_8           = dword ptr -8
.text$mn:00002B1C var_1           = byte ptr -1
.text$mn:00002B1C
.text$mn:00002B1C                 push    ebp
.text$mn:00002B1D                 mov     ebp, esp
.text$mn:00002B1F                 sub     esp, 10h
.text$mn:00002B22                 mov     [ebp+var_10], ecx
.text$mn:00002B25                 lea     eax, [ebp+var_1]
.text$mn:00002B28                 push    eax
.text$mn:00002B29                 mov     ecx, [ebp+var_10]
.text$mn:00002B2C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00002B31                 mov     ecx, eax
.text$mn:00002B33                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00002B38                 mov     [ebp+var_8], eax
.text$mn:00002B3B                 cmp     [ebp+var_8], 1
.text$mn:00002B3F                 ja      short loc_2B4A
.text$mn:00002B41                 mov     [ebp+var_C], 1
.text$mn:00002B48                 jmp     short loc_2B53
.text$mn:00002B4A ; ---------------------------------------------------------------------------
.text$mn:00002B4A
.text$mn:00002B4A loc_2B4A:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00002B4A                 mov     ecx, [ebp+var_8]
.text$mn:00002B4D                 sub     ecx, 1
.text$mn:00002B50                 mov     [ebp+var_C], ecx
.text$mn:00002B53
.text$mn:00002B53 loc_2B53:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00002B53                 mov     eax, [ebp+var_C]
.text$mn:00002B56                 mov     esp, ebp
.text$mn:00002B58                 pop     ebp
.text$mn:00002B59                 retn
.text$mn:00002B59 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002B59
.text$mn:00002B59 ; ---------------------------------------------------------------------------
.text$mn:00002B5A                 align 4
.text$mn:00002B5A _text$mn        ends
.text$mn:00002B5A
.text$mn:00002B5C ; ===========================================================================
.text$mn:00002B5C
.text$mn:00002B5C ; Segment type: Pure code
.text$mn:00002B5C ; Segment permissions: Read/Execute
.text$mn:00002B5C _text$mn        segment para public 'CODE' use32
.text$mn:00002B5C                 assume cs:_text$mn
.text$mn:00002B5C                 ;org 2B5Ch
.text$mn:00002B5C ; COMDAT (pick any)
.text$mn:00002B5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002B5C
.text$mn:00002B5C ; =============== S U B R O U T I N E =======================================
.text$mn:00002B5C
.text$mn:00002B5C ; Attributes: bp-based frame
.text$mn:00002B5C
.text$mn:00002B5C ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00002B5C                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002B5C ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002B5C                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00002B5C                                         ; DATA XREF: .rdata:00003224o
.text$mn:00002B5C
.text$mn:00002B5C var_1C          = dword ptr -1Ch
.text$mn:00002B5C var_18          = dword ptr -18h
.text$mn:00002B5C Str             = dword ptr -14h
.text$mn:00002B5C var_10          = dword ptr -10h
.text$mn:00002B5C var_C           = dword ptr -0Ch
.text$mn:00002B5C var_4           = dword ptr -4
.text$mn:00002B5C arg_0           = dword ptr  8
.text$mn:00002B5C arg_4           = dword ptr  0Ch
.text$mn:00002B5C
.text$mn:00002B5C                 push    ebp
.text$mn:00002B5D                 mov     ebp, esp
.text$mn:00002B5F                 push    0FFFFFFFFh
.text$mn:00002B61                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002B66                 mov     eax, large fs:0
.text$mn:00002B6C                 push    eax
.text$mn:00002B6D                 sub     esp, 10h
.text$mn:00002B70                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B75                 xor     eax, ebp
.text$mn:00002B77                 push    eax
.text$mn:00002B78                 lea     eax, [ebp+var_C]
.text$mn:00002B7B                 mov     large fs:0, eax
.text$mn:00002B81                 mov     [ebp+var_1C], ecx
.text$mn:00002B84                 mov     [ebp+var_18], 0
.text$mn:00002B8B                 mov     eax, [ebp+arg_4]
.text$mn:00002B8E                 push    eax             ; int
.text$mn:00002B8F                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00002B94                 add     esp, 4
.text$mn:00002B97                 mov     [ebp+var_10], eax
.text$mn:00002B9A                 cmp     [ebp+var_10], 0
.text$mn:00002B9E                 jz      short loc_2BA8
.text$mn:00002BA0                 mov     ecx, [ebp+var_10]
.text$mn:00002BA3                 mov     [ebp+Str], ecx
.text$mn:00002BA6                 jmp     short loc_2BAF
.text$mn:00002BA8 ; ---------------------------------------------------------------------------
.text$mn:00002BA8
.text$mn:00002BA8 loc_2BA8:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00002BA8                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002BAF
.text$mn:00002BAF loc_2BAF:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00002BAF                 mov     edx, [ebp+Str]
.text$mn:00002BB2                 push    edx             ; Str
.text$mn:00002BB3                 mov     ecx, [ebp+arg_0]
.text$mn:00002BB6                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002BBB                 mov     [ebp+var_4], 0
.text$mn:00002BC2                 mov     eax, [ebp+var_18]
.text$mn:00002BC5                 or      eax, 1
.text$mn:00002BC8                 mov     [ebp+var_18], eax
.text$mn:00002BCB                 mov     eax, [ebp+arg_0]
.text$mn:00002BCE                 mov     ecx, [ebp+var_C]
.text$mn:00002BD1                 mov     large fs:0, ecx
.text$mn:00002BD8                 pop     ecx
.text$mn:00002BD9                 mov     esp, ebp
.text$mn:00002BDB                 pop     ebp
.text$mn:00002BDC                 retn    8
.text$mn:00002BDC ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002BDC
.text$mn:00002BDC ; ---------------------------------------------------------------------------
.text$mn:00002BDF                 align 10h
.text$mn:00002BDF _text$mn        ends
.text$mn:00002BDF
.text$x:00002BE0 ; ===========================================================================
.text$x:00002BE0
.text$x:00002BE0 ; Segment type: Pure code
.text$x:00002BE0 ; Segment permissions: Read/Execute
.text$x:00002BE0 _text$x         segment para public 'CODE' use32
.text$x:00002BE0                 assume cs:_text$x
.text$x:00002BE0                 ;org 2BE0h
.text$x:00002BE0 ; COMDAT (pick associative to section at 2B5C)
.text$x:00002BE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002BE0
.text$x:00002BE0 ; =============== S U B R O U T I N E =======================================
.text$x:00002BE0
.text$x:00002BE0
.text$x:00002BE0 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002BE0                                         ; DATA XREF: .xdata$x:00003048o
.text$x:00002BE0                 mov     eax, [ebp-18h]
.text$x:00002BE3                 and     eax, 1
.text$x:00002BE6                 jz      $LN6
.text$x:00002BEC                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002BF0                 mov     ecx, [ebp+8]
.text$x:00002BF3                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002BF8 ; ---------------------------------------------------------------------------
.text$x:00002BF8
.text$x:00002BF8 $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002BF8                 retn
.text$x:00002BF8 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002BF8
.text$x:00002BF9
.text$x:00002BF9 ; =============== S U B R O U T I N E =======================================
.text$x:00002BF9
.text$x:00002BF9
.text$x:00002BF9 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002BF9                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00002BF9
.text$x:00002BF9 arg_4           = dword ptr  8
.text$x:00002BF9
.text$x:00002BF9                 mov     edx, [esp+arg_4]
.text$x:00002BFD                 lea     eax, [edx+0Ch]
.text$x:00002C00                 mov     ecx, [edx-14h]
.text$x:00002C03                 xor     ecx, eax
.text$x:00002C05                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002C0A                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002C0F                 jmp     ___CxxFrameHandler3
.text$x:00002C0F __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002C0F
.text$x:00002C0F _text$x         ends
.text$x:00002C0F
.text$mn:00002C14 ; ===========================================================================
.text$mn:00002C14
.text$mn:00002C14 ; Segment type: Pure code
.text$mn:00002C14 ; Segment permissions: Read/Execute
.text$mn:00002C14 _text$mn        segment para public 'CODE' use32
.text$mn:00002C14                 assume cs:_text$mn
.text$mn:00002C14                 ;org 2C14h
.text$mn:00002C14 ; COMDAT (pick any)
.text$mn:00002C14                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002C14
.text$mn:00002C14 ; =============== S U B R O U T I N E =======================================
.text$mn:00002C14
.text$mn:00002C14 ; Attributes: bp-based frame
.text$mn:00002C14
.text$mn:00002C14 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00002C14                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002C14 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002C14                                         ; DATA XREF: .rdata:00003258o
.text$mn:00002C14
.text$mn:00002C14 var_14          = dword ptr -14h
.text$mn:00002C14 var_10          = dword ptr -10h
.text$mn:00002C14 var_C           = dword ptr -0Ch
.text$mn:00002C14 var_4           = dword ptr -4
.text$mn:00002C14 arg_0           = dword ptr  8
.text$mn:00002C14 arg_4           = dword ptr  0Ch
.text$mn:00002C14
.text$mn:00002C14                 push    ebp
.text$mn:00002C15                 mov     ebp, esp
.text$mn:00002C17                 push    0FFFFFFFFh
.text$mn:00002C19                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002C1E                 mov     eax, large fs:0
.text$mn:00002C24                 push    eax
.text$mn:00002C25                 sub     esp, 8
.text$mn:00002C28                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C2D                 xor     eax, ebp
.text$mn:00002C2F                 push    eax
.text$mn:00002C30                 lea     eax, [ebp+var_C]
.text$mn:00002C33                 mov     large fs:0, eax
.text$mn:00002C39                 mov     [ebp+var_14], ecx
.text$mn:00002C3C                 mov     [ebp+var_10], 0
.text$mn:00002C43                 cmp     [ebp+arg_4], 1
.text$mn:00002C47                 jnz     short loc_2C6D
.text$mn:00002C49                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00002C4E                 mov     ecx, [ebp+arg_0]
.text$mn:00002C51                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002C56                 mov     [ebp+var_4], 0
.text$mn:00002C5D                 mov     eax, [ebp+var_10]
.text$mn:00002C60                 or      eax, 1
.text$mn:00002C63                 mov     [ebp+var_10], eax
.text$mn:00002C66                 mov     eax, [ebp+arg_0]
.text$mn:00002C69                 jmp     short loc_2C90
.text$mn:00002C6B ; ---------------------------------------------------------------------------
.text$mn:00002C6B                 jmp     short loc_2C90
.text$mn:00002C6D ; ---------------------------------------------------------------------------
.text$mn:00002C6D
.text$mn:00002C6D loc_2C6D:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00002C6D                 mov     ecx, [ebp+arg_4]
.text$mn:00002C70                 push    ecx
.text$mn:00002C71                 mov     edx, [ebp+arg_0]
.text$mn:00002C74                 push    edx
.text$mn:00002C75                 mov     ecx, [ebp+var_14]
.text$mn:00002C78                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00002C7D                 mov     [ebp+var_4], 0
.text$mn:00002C84                 mov     eax, [ebp+var_10]
.text$mn:00002C87                 or      eax, 1
.text$mn:00002C8A                 mov     [ebp+var_10], eax
.text$mn:00002C8D                 mov     eax, [ebp+arg_0]
.text$mn:00002C90
.text$mn:00002C90 loc_2C90:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00002C90                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00002C90                 mov     ecx, [ebp+var_C]
.text$mn:00002C93                 mov     large fs:0, ecx
.text$mn:00002C9A                 pop     ecx
.text$mn:00002C9B                 mov     esp, ebp
.text$mn:00002C9D                 pop     ebp
.text$mn:00002C9E                 retn    8
.text$mn:00002C9E ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002C9E
.text$mn:00002C9E ; ---------------------------------------------------------------------------
.text$mn:00002CA1                 align 4
.text$mn:00002CA1 _text$mn        ends
.text$mn:00002CA1
.text$x:00002CA4 ; ===========================================================================
.text$x:00002CA4
.text$x:00002CA4 ; Segment type: Pure code
.text$x:00002CA4 ; Segment permissions: Read/Execute
.text$x:00002CA4 _text$x         segment para public 'CODE' use32
.text$x:00002CA4                 assume cs:_text$x
.text$x:00002CA4                 ;org 2CA4h
.text$x:00002CA4 ; COMDAT (pick associative to section at 2C14)
.text$x:00002CA4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002CA4
.text$x:00002CA4 ; =============== S U B R O U T I N E =======================================
.text$x:00002CA4
.text$x:00002CA4
.text$x:00002CA4 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002CA4                                         ; DATA XREF: .xdata$x:000030CCo
.text$x:00002CA4                 mov     eax, [ebp-10h]
.text$x:00002CA7                 and     eax, 1
.text$x:00002CAA                 jz      $LN6_0
.text$x:00002CB0                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00002CB4                 mov     ecx, [ebp+8]
.text$x:00002CB7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002CBC ; ---------------------------------------------------------------------------
.text$x:00002CBC
.text$x:00002CBC $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002CBC                 retn
.text$x:00002CBC __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002CBC
.text$x:00002CBD
.text$x:00002CBD ; =============== S U B R O U T I N E =======================================
.text$x:00002CBD
.text$x:00002CBD
.text$x:00002CBD __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002CBD                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00002CBD
.text$x:00002CBD arg_4           = dword ptr  8
.text$x:00002CBD
.text$x:00002CBD                 mov     edx, [esp+arg_4]
.text$x:00002CC1                 lea     eax, [edx+0Ch]
.text$x:00002CC4                 mov     ecx, [edx-0Ch]
.text$x:00002CC7                 xor     ecx, eax
.text$x:00002CC9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002CCE                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002CD3                 jmp     ___CxxFrameHandler3
.text$x:00002CD3 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002CD3
.text$x:00002CD3 _text$x         ends
.text$x:00002CD3
.text$mn:00002CD8 ; ===========================================================================
.text$mn:00002CD8
.text$mn:00002CD8 ; Segment type: Pure code
.text$mn:00002CD8 ; Segment permissions: Read/Execute
.text$mn:00002CD8 _text$mn        segment para public 'CODE' use32
.text$mn:00002CD8                 assume cs:_text$mn
.text$mn:00002CD8                 ;org 2CD8h
.text$mn:00002CD8 ; COMDAT (pick any)
.text$mn:00002CD8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002CD8
.text$mn:00002CD8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002CD8
.text$mn:00002CD8 ; Attributes: bp-based frame
.text$mn:00002CD8
.text$mn:00002CD8 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00002CD8                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002CD8 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00002CD8                                         ; DATA XREF: .rdata:00003298o
.text$mn:00002CD8
.text$mn:00002CD8 var_1C          = dword ptr -1Ch
.text$mn:00002CD8 var_18          = dword ptr -18h
.text$mn:00002CD8 Str             = dword ptr -14h
.text$mn:00002CD8 var_10          = dword ptr -10h
.text$mn:00002CD8 var_C           = dword ptr -0Ch
.text$mn:00002CD8 var_4           = dword ptr -4
.text$mn:00002CD8 arg_0           = dword ptr  8
.text$mn:00002CD8 arg_4           = dword ptr  0Ch
.text$mn:00002CD8
.text$mn:00002CD8                 push    ebp
.text$mn:00002CD9                 mov     ebp, esp
.text$mn:00002CDB                 push    0FFFFFFFFh
.text$mn:00002CDD                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00002CE2                 mov     eax, large fs:0
.text$mn:00002CE8                 push    eax
.text$mn:00002CE9                 sub     esp, 10h
.text$mn:00002CEC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002CF1                 xor     eax, ebp
.text$mn:00002CF3                 push    eax
.text$mn:00002CF4                 lea     eax, [ebp+var_C]
.text$mn:00002CF7                 mov     large fs:0, eax
.text$mn:00002CFD                 mov     [ebp+var_1C], ecx
.text$mn:00002D00                 mov     [ebp+var_18], 0
.text$mn:00002D07                 mov     eax, [ebp+arg_4]
.text$mn:00002D0A                 push    eax             ; int
.text$mn:00002D0B                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00002D10                 add     esp, 4
.text$mn:00002D13                 mov     [ebp+var_10], eax
.text$mn:00002D16                 cmp     [ebp+var_10], 0
.text$mn:00002D1A                 jz      short loc_2D24
.text$mn:00002D1C                 mov     ecx, [ebp+var_10]
.text$mn:00002D1F                 mov     [ebp+Str], ecx
.text$mn:00002D22                 jmp     short loc_2D2B
.text$mn:00002D24 ; ---------------------------------------------------------------------------
.text$mn:00002D24
.text$mn:00002D24 loc_2D24:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00002D24                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00002D2B
.text$mn:00002D2B loc_2D2B:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00002D2B                 mov     edx, [ebp+Str]
.text$mn:00002D2E                 push    edx             ; Str
.text$mn:00002D2F                 mov     ecx, [ebp+arg_0]
.text$mn:00002D32                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00002D37                 mov     [ebp+var_4], 0
.text$mn:00002D3E                 mov     eax, [ebp+var_18]
.text$mn:00002D41                 or      eax, 1
.text$mn:00002D44                 mov     [ebp+var_18], eax
.text$mn:00002D47                 mov     eax, [ebp+arg_0]
.text$mn:00002D4A                 mov     ecx, [ebp+var_C]
.text$mn:00002D4D                 mov     large fs:0, ecx
.text$mn:00002D54                 pop     ecx
.text$mn:00002D55                 mov     esp, ebp
.text$mn:00002D57                 pop     ebp
.text$mn:00002D58                 retn    8
.text$mn:00002D58 ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00002D58
.text$mn:00002D58 ; ---------------------------------------------------------------------------
.text$mn:00002D5B                 align 4
.text$mn:00002D5B _text$mn        ends
.text$mn:00002D5B
.text$x:00002D5C ; ===========================================================================
.text$x:00002D5C
.text$x:00002D5C ; Segment type: Pure code
.text$x:00002D5C ; Segment permissions: Read/Execute
.text$x:00002D5C _text$x         segment para public 'CODE' use32
.text$x:00002D5C                 assume cs:_text$x
.text$x:00002D5C                 ;org 2D5Ch
.text$x:00002D5C ; COMDAT (pick associative to section at 2CD8)
.text$x:00002D5C                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$x:00002D5C
.text$x:00002D5C ; =============== S U B R O U T I N E =======================================
.text$x:00002D5C
.text$x:00002D5C
.text$x:00002D5C __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00002D5C                                         ; DATA XREF: .xdata$x:00003150o
.text$x:00002D5C                 mov     eax, [ebp-18h]
.text$x:00002D5F                 and     eax, 1
.text$x:00002D62                 jz      $LN6_1
.text$x:00002D68                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00002D6C                 mov     ecx, [ebp+8]
.text$x:00002D6F                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00002D74 ; ---------------------------------------------------------------------------
.text$x:00002D74
.text$x:00002D74 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00002D74                 retn
.text$x:00002D74 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00002D74
.text$x:00002D75
.text$x:00002D75 ; =============== S U B R O U T I N E =======================================
.text$x:00002D75
.text$x:00002D75
.text$x:00002D75 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00002D75                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00002D75
.text$x:00002D75 arg_4           = dword ptr  8
.text$x:00002D75
.text$x:00002D75                 mov     edx, [esp+arg_4]
.text$x:00002D79                 lea     eax, [edx+0Ch]
.text$x:00002D7C                 mov     ecx, [edx-14h]
.text$x:00002D7F                 xor     ecx, eax
.text$x:00002D81                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D86                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00002D8B                 jmp     ___CxxFrameHandler3
.text$x:00002D8B __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00002D8B
.text$x:00002D8B _text$x         ends
.text$x:00002D8B
.text$mn:00002D90 ; ===========================================================================
.text$mn:00002D90
.text$mn:00002D90 ; Segment type: Pure code
.text$mn:00002D90 ; Segment permissions: Read/Execute
.text$mn:00002D90 _text$mn        segment para public 'CODE' use32
.text$mn:00002D90                 assume cs:_text$mn
.text$mn:00002D90                 ;org 2D90h
.text$mn:00002D90 ; COMDAT (pick any)
.text$mn:00002D90                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002D90
.text$mn:00002D90 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D90
.text$mn:00002D90 ; Attributes: bp-based frame
.text$mn:00002D90
.text$mn:00002D90 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00002D90                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00002D90 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00002D90                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00002D90
.text$mn:00002D90 var_4           = dword ptr -4
.text$mn:00002D90 Dst             = dword ptr  8
.text$mn:00002D90 Src             = dword ptr  0Ch
.text$mn:00002D90 Size            = dword ptr  10h
.text$mn:00002D90
.text$mn:00002D90                 push    ebp
.text$mn:00002D91                 mov     ebp, esp
.text$mn:00002D93                 push    ecx
.text$mn:00002D94                 cmp     [ebp+Size], 0
.text$mn:00002D98                 jnz     short loc_2DA2
.text$mn:00002D9A                 mov     eax, [ebp+Dst]
.text$mn:00002D9D                 mov     [ebp+var_4], eax
.text$mn:00002DA0                 jmp     short loc_2DB9
.text$mn:00002DA2 ; ---------------------------------------------------------------------------
.text$mn:00002DA2
.text$mn:00002DA2 loc_2DA2:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00002DA2                 mov     ecx, [ebp+Size]
.text$mn:00002DA5                 push    ecx             ; Size
.text$mn:00002DA6                 mov     edx, [ebp+Src]
.text$mn:00002DA9                 push    edx             ; Src
.text$mn:00002DAA                 mov     eax, [ebp+Dst]
.text$mn:00002DAD                 push    eax             ; Dst
.text$mn:00002DAE                 call    _memmove
.text$mn:00002DB3                 add     esp, 0Ch
.text$mn:00002DB6                 mov     [ebp+var_4], eax
.text$mn:00002DB9
.text$mn:00002DB9 loc_2DB9:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00002DB9                 mov     eax, [ebp+var_4]
.text$mn:00002DBC                 mov     esp, ebp
.text$mn:00002DBE                 pop     ebp
.text$mn:00002DBF                 retn
.text$mn:00002DBF ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00002DBF
.text$mn:00002DBF _text$mn        ends
.text$mn:00002DBF
.text$mn:00002DC0 ; ===========================================================================
.text$mn:00002DC0
.text$mn:00002DC0 ; Segment type: Pure code
.text$mn:00002DC0 ; Segment permissions: Read/Execute
.text$mn:00002DC0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DC0                 assume cs:_text$mn
.text$mn:00002DC0                 ;org 2DC0h
.text$mn:00002DC0 ; COMDAT (pick any)
.text$mn:00002DC0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DC0
.text$mn:00002DC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DC0
.text$mn:00002DC0 ; Attributes: bp-based frame
.text$mn:00002DC0
.text$mn:00002DC0 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00002DC0                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00002DC0 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00002DC0                                         ; DATA XREF: .rdata:00003220o
.text$mn:00002DC0
.text$mn:00002DC0 var_4           = dword ptr -4
.text$mn:00002DC0
.text$mn:00002DC0                 push    ebp
.text$mn:00002DC1                 mov     ebp, esp
.text$mn:00002DC3                 push    ecx
.text$mn:00002DC4                 mov     [ebp+var_4], ecx
.text$mn:00002DC7                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00002DCC                 mov     esp, ebp
.text$mn:00002DCE                 pop     ebp
.text$mn:00002DCF                 retn
.text$mn:00002DCF ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00002DCF
.text$mn:00002DCF _text$mn        ends
.text$mn:00002DCF
.text$mn:00002DD0 ; ===========================================================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Segment type: Pure code
.text$mn:00002DD0 ; Segment permissions: Read/Execute
.text$mn:00002DD0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DD0                 assume cs:_text$mn
.text$mn:00002DD0                 ;org 2DD0h
.text$mn:00002DD0 ; COMDAT (pick any)
.text$mn:00002DD0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DD0
.text$mn:00002DD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DD0
.text$mn:00002DD0 ; Attributes: bp-based frame
.text$mn:00002DD0
.text$mn:00002DD0 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00002DD0                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00002DD0 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00002DD0                                         ; DATA XREF: .rdata:00003254o
.text$mn:00002DD0
.text$mn:00002DD0 var_4           = dword ptr -4
.text$mn:00002DD0
.text$mn:00002DD0                 push    ebp
.text$mn:00002DD1                 mov     ebp, esp
.text$mn:00002DD3                 push    ecx
.text$mn:00002DD4                 mov     [ebp+var_4], ecx
.text$mn:00002DD7                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00002DDC                 mov     esp, ebp
.text$mn:00002DDE                 pop     ebp
.text$mn:00002DDF                 retn
.text$mn:00002DDF ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00002DDF
.text$mn:00002DDF _text$mn        ends
.text$mn:00002DDF
.text$mn:00002DE0 ; ===========================================================================
.text$mn:00002DE0
.text$mn:00002DE0 ; Segment type: Pure code
.text$mn:00002DE0 ; Segment permissions: Read/Execute
.text$mn:00002DE0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DE0                 assume cs:_text$mn
.text$mn:00002DE0                 ;org 2DE0h
.text$mn:00002DE0 ; COMDAT (pick any)
.text$mn:00002DE0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DE0
.text$mn:00002DE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DE0
.text$mn:00002DE0 ; Attributes: bp-based frame
.text$mn:00002DE0
.text$mn:00002DE0 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00002DE0                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00002DE0 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00002DE0                                         ; DATA XREF: .rdata:00003294o
.text$mn:00002DE0
.text$mn:00002DE0 var_4           = dword ptr -4
.text$mn:00002DE0
.text$mn:00002DE0                 push    ebp
.text$mn:00002DE1                 mov     ebp, esp
.text$mn:00002DE3                 push    ecx
.text$mn:00002DE4                 mov     [ebp+var_4], ecx
.text$mn:00002DE7                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00002DEC                 mov     esp, ebp
.text$mn:00002DEE                 pop     ebp
.text$mn:00002DEF                 retn
.text$mn:00002DEF ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00002DEF
.text$mn:00002DEF _text$mn        ends
.text$mn:00002DEF
.text$mn:00002DF0 ; ===========================================================================
.text$mn:00002DF0
.text$mn:00002DF0 ; Segment type: Pure code
.text$mn:00002DF0 ; Segment permissions: Read/Execute
.text$mn:00002DF0 _text$mn        segment para public 'CODE' use32
.text$mn:00002DF0                 assume cs:_text$mn
.text$mn:00002DF0                 ;org 2DF0h
.text$mn:00002DF0 ; COMDAT (pick any)
.text$mn:00002DF0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002DF0
.text$mn:00002DF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002DF0
.text$mn:00002DF0 ; Attributes: bp-based frame
.text$mn:00002DF0
.text$mn:00002DF0 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00002DF0                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00002DF0 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00002DF0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00002DF0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00002DF0
.text$mn:00002DF0 var_4           = dword ptr -4
.text$mn:00002DF0
.text$mn:00002DF0                 push    ebp
.text$mn:00002DF1                 mov     ebp, esp
.text$mn:00002DF3                 push    ecx
.text$mn:00002DF4                 mov     [ebp+var_4], ecx
.text$mn:00002DF7                 mov     eax, [ebp+var_4]
.text$mn:00002DFA                 mov     eax, [eax+14h]
.text$mn:00002DFD                 mov     esp, ebp
.text$mn:00002DFF                 pop     ebp
.text$mn:00002E00                 retn
.text$mn:00002E00 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00002E00
.text$mn:00002E00 ; ---------------------------------------------------------------------------
.text$mn:00002E01                 align 4
.text$mn:00002E01 _text$mn        ends
.text$mn:00002E01
.text$mn:00002E04 ; ===========================================================================
.text$mn:00002E04
.text$mn:00002E04 ; Segment type: Pure code
.text$mn:00002E04 ; Segment permissions: Read/Execute
.text$mn:00002E04 _text$mn        segment para public 'CODE' use32
.text$mn:00002E04                 assume cs:_text$mn
.text$mn:00002E04                 ;org 2E04h
.text$mn:00002E04 ; COMDAT (pick any)
.text$mn:00002E04                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E04
.text$mn:00002E04 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E04
.text$mn:00002E04 ; Attributes: bp-based frame
.text$mn:00002E04
.text$mn:00002E04 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00002E04                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00002E04 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00002E04                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_2848p
.text$mn:00002E04                 push    ebp
.text$mn:00002E05                 mov     ebp, esp
.text$mn:00002E07                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00002E0C                 pop     ebp
.text$mn:00002E0D                 retn
.text$mn:00002E0D ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00002E0D
.text$mn:00002E0D ; ---------------------------------------------------------------------------
.text$mn:00002E0E                 align 10h
.text$mn:00002E0E _text$mn        ends
.text$mn:00002E0E
.text$mn:00002E10 ; ===========================================================================
.text$mn:00002E10
.text$mn:00002E10 ; Segment type: Pure code
.text$mn:00002E10 ; Segment permissions: Read/Execute
.text$mn:00002E10 _text$mn        segment para public 'CODE' use32
.text$mn:00002E10                 assume cs:_text$mn
.text$mn:00002E10                 ;org 2E10h
.text$mn:00002E10 ; COMDAT (pick any)
.text$mn:00002E10                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E10
.text$mn:00002E10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E10
.text$mn:00002E10 ; Attributes: bp-based frame
.text$mn:00002E10
.text$mn:00002E10 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00002E10                 public ?value@error_code@std@@QBEHXZ
.text$mn:00002E10 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00002E10
.text$mn:00002E10 var_4           = dword ptr -4
.text$mn:00002E10
.text$mn:00002E10                 push    ebp
.text$mn:00002E11                 mov     ebp, esp
.text$mn:00002E13                 push    ecx
.text$mn:00002E14                 mov     [ebp+var_4], ecx
.text$mn:00002E17                 mov     eax, [ebp+var_4]
.text$mn:00002E1A                 mov     eax, [eax]
.text$mn:00002E1C                 mov     esp, ebp
.text$mn:00002E1E                 pop     ebp
.text$mn:00002E1F                 retn
.text$mn:00002E1F ?value@error_code@std@@QBEHXZ endp
.text$mn:00002E1F
.text$mn:00002E1F _text$mn        ends
.text$mn:00002E1F
.text$mn:00002E20 ; ===========================================================================
.text$mn:00002E20
.text$mn:00002E20 ; Segment type: Pure code
.text$mn:00002E20 ; Segment permissions: Read/Execute
.text$mn:00002E20 _text$mn        segment para public 'CODE' use32
.text$mn:00002E20                 assume cs:_text$mn
.text$mn:00002E20                 ;org 2E20h
.text$mn:00002E20 ; COMDAT (pick any)
.text$mn:00002E20                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E20
.text$mn:00002E20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E20
.text$mn:00002E20 ; Attributes: bp-based frame
.text$mn:00002E20
.text$mn:00002E20 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00002E20                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00002E20 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00002E20                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00002E20                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00002E20
.text$mn:00002E20 var_4           = dword ptr -4
.text$mn:00002E20
.text$mn:00002E20                 push    ebp
.text$mn:00002E21                 mov     ebp, esp
.text$mn:00002E23                 push    ecx
.text$mn:00002E24                 mov     [ebp+var_4], ecx
.text$mn:00002E27                 mov     eax, [ebp+var_4]
.text$mn:00002E2A                 mov     eax, [eax]
.text$mn:00002E2C                 mov     esp, ebp
.text$mn:00002E2E                 pop     ebp
.text$mn:00002E2F                 retn
.text$mn:00002E2F ?value@error_condition@std@@QBEHXZ endp
.text$mn:00002E2F
.text$mn:00002E2F _text$mn        ends
.text$mn:00002E2F
.text$mn:00002E30 ; ===========================================================================
.text$mn:00002E30
.text$mn:00002E30 ; Segment type: Pure code
.text$mn:00002E30 ; Segment permissions: Read/Execute
.text$mn:00002E30 _text$mn        segment para public 'CODE' use32
.text$mn:00002E30                 assume cs:_text$mn
.text$mn:00002E30                 ;org 2E30h
.text$mn:00002E30 ; COMDAT (pick any)
.text$mn:00002E30                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.text$mn:00002E30
.text$mn:00002E30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E30
.text$mn:00002E30 ; Attributes: bp-based frame
.text$mn:00002E30
.text$mn:00002E30                 public _hypot
.text$mn:00002E30 _hypot          proc near
.text$mn:00002E30
.text$mn:00002E30 var_10          = qword ptr -10h
.text$mn:00002E30 var_8           = qword ptr -8
.text$mn:00002E30 arg_0           = qword ptr  8
.text$mn:00002E30 arg_8           = qword ptr  10h
.text$mn:00002E30
.text$mn:00002E30                 push    ebp
.text$mn:00002E31                 mov     ebp, esp
.text$mn:00002E33                 sub     esp, 8
.text$mn:00002E36                 movsd   xmm0, [ebp+arg_8]
.text$mn:00002E3B                 movsd   [esp+8+var_8], xmm0
.text$mn:00002E40                 sub     esp, 8
.text$mn:00002E43                 movsd   xmm0, [ebp+arg_0]
.text$mn:00002E48                 movsd   [esp+10h+var_10], xmm0
.text$mn:00002E4D                 call    __hypot
.text$mn:00002E52                 add     esp, 10h
.text$mn:00002E55                 pop     ebp
.text$mn:00002E56                 retn
.text$mn:00002E56 _hypot          endp
.text$mn:00002E56
.text$mn:00002E56 ; ---------------------------------------------------------------------------
.text$mn:00002E57                 align 4
.text$mn:00002E57 _text$mn        ends
.text$mn:00002E57
.xdata$x:00002E58 ; ===========================================================================
.xdata$x:00002E58
.xdata$x:00002E58 ; Segment type: Pure data
.xdata$x:00002E58 ; Segment permissions: Read
.xdata$x:00002E58 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E58                 assume cs:_xdata$x
.xdata$x:00002E58                 ;org 2E58h
.xdata$x:00002E58 ; COMDAT (pick associative to section at 23D8)
.xdata$x:00002E58 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00002E58                                         ; DATA XREF: .xdata$x:00002E68o
.xdata$x:00002E59                 db 0FFh
.xdata$x:00002E5A                 db 0FFh
.xdata$x:00002E5B                 db 0FFh
.xdata$x:00002E5C                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00002E60 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00002E60                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00002E61                 db    5
.xdata$x:00002E62                 db  93h ; ô
.xdata$x:00002E63                 db  19h
.xdata$x:00002E64                 db    1
.xdata$x:00002E65                 db    0
.xdata$x:00002E66                 db    0
.xdata$x:00002E67                 db    0
.xdata$x:00002E68                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:00002E6C                 db    0
.xdata$x:00002E6D                 db    0
.xdata$x:00002E6E                 db    0
.xdata$x:00002E6F                 db    0
.xdata$x:00002E70                 db    0
.xdata$x:00002E71                 db    0
.xdata$x:00002E72                 db    0
.xdata$x:00002E73                 db    0
.xdata$x:00002E74                 db    0
.xdata$x:00002E75                 db    0
.xdata$x:00002E76                 db    0
.xdata$x:00002E77                 db    0
.xdata$x:00002E78                 db    0
.xdata$x:00002E79                 db    0
.xdata$x:00002E7A                 db    0
.xdata$x:00002E7B                 db    0
.xdata$x:00002E7C                 db    0
.xdata$x:00002E7D                 db    0
.xdata$x:00002E7E                 db    0
.xdata$x:00002E7F                 db    0
.xdata$x:00002E80                 db    0
.xdata$x:00002E81                 db    0
.xdata$x:00002E82                 db    0
.xdata$x:00002E83                 db    0
.xdata$x:00002E83 _xdata$x        ends
.xdata$x:00002E83
.xdata$x:00002E84 ; ===========================================================================
.xdata$x:00002E84
.xdata$x:00002E84 ; Segment type: Pure data
.xdata$x:00002E84 ; Segment permissions: Read
.xdata$x:00002E84 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002E84                 assume cs:_xdata$x
.xdata$x:00002E84                 ;org 2E84h
.xdata$x:00002E84 ; COMDAT (pick associative to section at 1710)
.xdata$x:00002E84 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002E84                                         ; DATA XREF: .xdata$x:00002E94o
.xdata$x:00002E85                 db 0FFh
.xdata$x:00002E86                 db 0FFh
.xdata$x:00002E87                 db 0FFh
.xdata$x:00002E88                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002E8C __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002E8C                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002E8D                 db    5
.xdata$x:00002E8E                 db  93h ; ô
.xdata$x:00002E8F                 db  19h
.xdata$x:00002E90                 db    1
.xdata$x:00002E91                 db    0
.xdata$x:00002E92                 db    0
.xdata$x:00002E93                 db    0
.xdata$x:00002E94                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002E98                 db    0
.xdata$x:00002E99                 db    0
.xdata$x:00002E9A                 db    0
.xdata$x:00002E9B                 db    0
.xdata$x:00002E9C                 db    0
.xdata$x:00002E9D                 db    0
.xdata$x:00002E9E                 db    0
.xdata$x:00002E9F                 db    0
.xdata$x:00002EA0                 db    0
.xdata$x:00002EA1                 db    0
.xdata$x:00002EA2                 db    0
.xdata$x:00002EA3                 db    0
.xdata$x:00002EA4                 db    0
.xdata$x:00002EA5                 db    0
.xdata$x:00002EA6                 db    0
.xdata$x:00002EA7                 db    0
.xdata$x:00002EA8                 db    0
.xdata$x:00002EA9                 db    0
.xdata$x:00002EAA                 db    0
.xdata$x:00002EAB                 db    0
.xdata$x:00002EAC                 db    0
.xdata$x:00002EAD                 db    0
.xdata$x:00002EAE                 db    0
.xdata$x:00002EAF                 db    0
.xdata$x:00002EAF _xdata$x        ends
.xdata$x:00002EAF
.xdata$x:00002EB0 ; ===========================================================================
.xdata$x:00002EB0
.xdata$x:00002EB0 ; Segment type: Pure data
.xdata$x:00002EB0 ; Segment permissions: Read
.xdata$x:00002EB0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EB0                 assume cs:_xdata$x
.xdata$x:00002EB0                 ;org 2EB0h
.xdata$x:00002EB0 ; COMDAT (pick associative to section at 1AF4)
.xdata$x:00002EB0 __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002EB0                                         ; DATA XREF: .xdata$x:00002EC0o
.xdata$x:00002EB1                 db 0FFh
.xdata$x:00002EB2                 db 0FFh
.xdata$x:00002EB3                 db 0FFh
.xdata$x:00002EB4                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:00002EB8 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002EB8                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:00002EB9                 db    5
.xdata$x:00002EBA                 db  93h ; ô
.xdata$x:00002EBB                 db  19h
.xdata$x:00002EBC                 db    1
.xdata$x:00002EBD                 db    0
.xdata$x:00002EBE                 db    0
.xdata$x:00002EBF                 db    0
.xdata$x:00002EC0                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:00002EC4                 db    0
.xdata$x:00002EC5                 db    0
.xdata$x:00002EC6                 db    0
.xdata$x:00002EC7                 db    0
.xdata$x:00002EC8                 db    0
.xdata$x:00002EC9                 db    0
.xdata$x:00002ECA                 db    0
.xdata$x:00002ECB                 db    0
.xdata$x:00002ECC                 db    0
.xdata$x:00002ECD                 db    0
.xdata$x:00002ECE                 db    0
.xdata$x:00002ECF                 db    0
.xdata$x:00002ED0                 db    0
.xdata$x:00002ED1                 db    0
.xdata$x:00002ED2                 db    0
.xdata$x:00002ED3                 db    0
.xdata$x:00002ED4                 db    0
.xdata$x:00002ED5                 db    0
.xdata$x:00002ED6                 db    0
.xdata$x:00002ED7                 db    0
.xdata$x:00002ED8                 db    0
.xdata$x:00002ED9                 db    0
.xdata$x:00002EDA                 db    0
.xdata$x:00002EDB                 db    0
.xdata$x:00002EDB _xdata$x        ends
.xdata$x:00002EDB
.xdata$x:00002EDC ; ===========================================================================
.xdata$x:00002EDC
.xdata$x:00002EDC ; Segment type: Pure data
.xdata$x:00002EDC ; Segment permissions: Read
.xdata$x:00002EDC _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002EDC                 assume cs:_xdata$x
.xdata$x:00002EDC                 ;org 2EDCh
.xdata$x:00002EDC ; COMDAT (pick associative to section at 1694)
.xdata$x:00002EDC __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00002EDC                                         ; DATA XREF: .xdata$x:00002EECo
.xdata$x:00002EDD                 db 0FFh
.xdata$x:00002EDE                 db 0FFh
.xdata$x:00002EDF                 db 0FFh
.xdata$x:00002EE0                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00002EE4 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00002EE4                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00002EE5                 db    5
.xdata$x:00002EE6                 db  93h ; ô
.xdata$x:00002EE7                 db  19h
.xdata$x:00002EE8                 db    1
.xdata$x:00002EE9                 db    0
.xdata$x:00002EEA                 db    0
.xdata$x:00002EEB                 db    0
.xdata$x:00002EEC                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:00002EF0                 db    0
.xdata$x:00002EF1                 db    0
.xdata$x:00002EF2                 db    0
.xdata$x:00002EF3                 db    0
.xdata$x:00002EF4                 db    0
.xdata$x:00002EF5                 db    0
.xdata$x:00002EF6                 db    0
.xdata$x:00002EF7                 db    0
.xdata$x:00002EF8                 db    0
.xdata$x:00002EF9                 db    0
.xdata$x:00002EFA                 db    0
.xdata$x:00002EFB                 db    0
.xdata$x:00002EFC                 db    0
.xdata$x:00002EFD                 db    0
.xdata$x:00002EFE                 db    0
.xdata$x:00002EFF                 db    0
.xdata$x:00002F00                 db    0
.xdata$x:00002F01                 db    0
.xdata$x:00002F02                 db    0
.xdata$x:00002F03                 db    0
.xdata$x:00002F04                 db    0
.xdata$x:00002F05                 db    0
.xdata$x:00002F06                 db    0
.xdata$x:00002F07                 db    0
.xdata$x:00002F07 _xdata$x        ends
.xdata$x:00002F07
.xdata$x:00002F08 ; ===========================================================================
.xdata$x:00002F08
.xdata$x:00002F08 ; Segment type: Pure data
.xdata$x:00002F08 ; Segment permissions: Read
.xdata$x:00002F08 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F08                 assume cs:_xdata$x
.xdata$x:00002F08                 ;org 2F08h
.xdata$x:00002F08 ; COMDAT (pick associative to section at 1A7C)
.xdata$x:00002F08 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00002F08                                         ; DATA XREF: .xdata$x:00002F18o
.xdata$x:00002F09                 db 0FFh
.xdata$x:00002F0A                 db 0FFh
.xdata$x:00002F0B                 db 0FFh
.xdata$x:00002F0C                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00002F10 __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00002F10                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00002F11                 db    5
.xdata$x:00002F12                 db  93h ; ô
.xdata$x:00002F13                 db  19h
.xdata$x:00002F14                 db    1
.xdata$x:00002F15                 db    0
.xdata$x:00002F16                 db    0
.xdata$x:00002F17                 db    0
.xdata$x:00002F18                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00002F1C                 db    0
.xdata$x:00002F1D                 db    0
.xdata$x:00002F1E                 db    0
.xdata$x:00002F1F                 db    0
.xdata$x:00002F20                 db    0
.xdata$x:00002F21                 db    0
.xdata$x:00002F22                 db    0
.xdata$x:00002F23                 db    0
.xdata$x:00002F24                 db    0
.xdata$x:00002F25                 db    0
.xdata$x:00002F26                 db    0
.xdata$x:00002F27                 db    0
.xdata$x:00002F28                 db    0
.xdata$x:00002F29                 db    0
.xdata$x:00002F2A                 db    0
.xdata$x:00002F2B                 db    0
.xdata$x:00002F2C                 db    0
.xdata$x:00002F2D                 db    0
.xdata$x:00002F2E                 db    0
.xdata$x:00002F2F                 db    0
.xdata$x:00002F30                 db    0
.xdata$x:00002F31                 db    0
.xdata$x:00002F32                 db    0
.xdata$x:00002F33                 db    0
.xdata$x:00002F33 _xdata$x        ends
.xdata$x:00002F33
.xdata$x:00002F34 ; ===========================================================================
.xdata$x:00002F34
.xdata$x:00002F34 ; Segment type: Pure data
.xdata$x:00002F34 ; Segment permissions: Read
.xdata$x:00002F34 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F34                 assume cs:_xdata$x
.xdata$x:00002F34                 ;org 2F34h
.xdata$x:00002F34 ; COMDAT (pick associative to section at 17D0)
.xdata$x:00002F34 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00002F34                                         ; DATA XREF: .xdata$x:00002F44o
.xdata$x:00002F35                 db 0FFh
.xdata$x:00002F36                 db 0FFh
.xdata$x:00002F37                 db 0FFh
.xdata$x:00002F38                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00002F3C __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00002F3C                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00002F3D                 db    5
.xdata$x:00002F3E                 db  93h ; ô
.xdata$x:00002F3F                 db  19h
.xdata$x:00002F40                 db    1
.xdata$x:00002F41                 db    0
.xdata$x:00002F42                 db    0
.xdata$x:00002F43                 db    0
.xdata$x:00002F44                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00002F48                 align 20h
.xdata$x:00002F48 _xdata$x        ends
.xdata$x:00002F48
.xdata$x:00002F60 ; ===========================================================================
.xdata$x:00002F60
.xdata$x:00002F60 ; Segment type: Pure data
.xdata$x:00002F60 ; Segment permissions: Read
.xdata$x:00002F60 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F60                 assume cs:_xdata$x
.xdata$x:00002F60                 ;org 2F60h
.xdata$x:00002F60 ; COMDAT (pick associative to section at 1B64)
.xdata$x:00002F60 __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:00002F60                                         ; DATA XREF: .xdata$x:00002F70o
.xdata$x:00002F61                 db 0FFh
.xdata$x:00002F62                 db 0FFh
.xdata$x:00002F63                 db 0FFh
.xdata$x:00002F64                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00002F68 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00002F68                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00002F69                 db    5
.xdata$x:00002F6A                 db  93h ; ô
.xdata$x:00002F6B                 db  19h
.xdata$x:00002F6C                 db    1
.xdata$x:00002F6D                 db    0
.xdata$x:00002F6E                 db    0
.xdata$x:00002F6F                 db    0
.xdata$x:00002F70                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:00002F74                 db    0
.xdata$x:00002F75                 db    0
.xdata$x:00002F76                 db    0
.xdata$x:00002F77                 db    0
.xdata$x:00002F78                 db    0
.xdata$x:00002F79                 db    0
.xdata$x:00002F7A                 db    0
.xdata$x:00002F7B                 db    0
.xdata$x:00002F7C                 db    0
.xdata$x:00002F7D                 db    0
.xdata$x:00002F7E                 db    0
.xdata$x:00002F7F                 db    0
.xdata$x:00002F80                 db    0
.xdata$x:00002F81                 db    0
.xdata$x:00002F82                 db    0
.xdata$x:00002F83                 db    0
.xdata$x:00002F84                 db    0
.xdata$x:00002F85                 db    0
.xdata$x:00002F86                 db    0
.xdata$x:00002F87                 db    0
.xdata$x:00002F88                 db    0
.xdata$x:00002F89                 db    0
.xdata$x:00002F8A                 db    0
.xdata$x:00002F8B                 db    0
.xdata$x:00002F8B _xdata$x        ends
.xdata$x:00002F8B
.xdata$x:00002F8C ; ===========================================================================
.xdata$x:00002F8C
.xdata$x:00002F8C ; Segment type: Pure data
.xdata$x:00002F8C ; Segment permissions: Read
.xdata$x:00002F8C _xdata$x        segment dword public 'DATA' use32
.xdata$x:00002F8C                 assume cs:_xdata$x
.xdata$x:00002F8C                 ;org 2F8Ch
.xdata$x:00002F8C ; COMDAT (pick associative to section at 1FFC)
.xdata$x:00002F8C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:00002F8C                                         ; DATA XREF: .xdata$x:00003014o
.xdata$x:00002F8D                 db    0
.xdata$x:00002F8E                 db    0
.xdata$x:00002F8F                 db    0
.xdata$x:00002F90                 db    0
.xdata$x:00002F91                 db    0
.xdata$x:00002F92                 db    0
.xdata$x:00002F93                 db    0
.xdata$x:00002F94                 db    0
.xdata$x:00002F95                 db    0
.xdata$x:00002F96                 db    0
.xdata$x:00002F97                 db    0
.xdata$x:00002F98                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:00002F9C __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:00002F9C                                         ; DATA XREF: .xdata$x:00003000o
.xdata$x:00002F9D                 db    0
.xdata$x:00002F9E                 db    0
.xdata$x:00002F9F                 db    0
.xdata$x:00002FA0                 db    0
.xdata$x:00002FA1                 db    0
.xdata$x:00002FA2                 db    0
.xdata$x:00002FA3                 db    0
.xdata$x:00002FA4                 db    0
.xdata$x:00002FA5                 db    0
.xdata$x:00002FA6                 db    0
.xdata$x:00002FA7                 db    0
.xdata$x:00002FA8                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:00002FAC __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:00002FAC                                         ; DATA XREF: .xdata$x:00002FD4o
.xdata$x:00002FAD                 db 0FFh
.xdata$x:00002FAE                 db 0FFh
.xdata$x:00002FAF                 db 0FFh
.xdata$x:00002FB0                 db    0
.xdata$x:00002FB1                 db    0
.xdata$x:00002FB2                 db    0
.xdata$x:00002FB3                 db    0
.xdata$x:00002FB4                 db 0FFh
.xdata$x:00002FB5                 db 0FFh
.xdata$x:00002FB6                 db 0FFh
.xdata$x:00002FB7                 db 0FFh
.xdata$x:00002FB8                 db    0
.xdata$x:00002FB9                 db    0
.xdata$x:00002FBA                 db    0
.xdata$x:00002FBB                 db    0
.xdata$x:00002FBC                 db    1
.xdata$x:00002FBD                 db    0
.xdata$x:00002FBE                 db    0
.xdata$x:00002FBF                 db    0
.xdata$x:00002FC0                 db    0
.xdata$x:00002FC1                 db    0
.xdata$x:00002FC2                 db    0
.xdata$x:00002FC3                 db    0
.xdata$x:00002FC4                 db    1
.xdata$x:00002FC5                 db    0
.xdata$x:00002FC6                 db    0
.xdata$x:00002FC7                 db    0
.xdata$x:00002FC8                 db    0
.xdata$x:00002FC9                 db    0
.xdata$x:00002FCA                 db    0
.xdata$x:00002FCB                 db    0
.xdata$x:00002FCC __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:00002FCC                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:00002FCD                 db    5
.xdata$x:00002FCE                 db  93h ; ô
.xdata$x:00002FCF                 db  19h
.xdata$x:00002FD0                 db    4
.xdata$x:00002FD1                 db    0
.xdata$x:00002FD2                 db    0
.xdata$x:00002FD3                 db    0
.xdata$x:00002FD4                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002FD8                 db    2
.xdata$x:00002FD9                 db    0
.xdata$x:00002FDA                 db    0
.xdata$x:00002FDB                 db    0
.xdata$x:00002FDC                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00002FE0                 db    0
.xdata$x:00002FE1                 db    0
.xdata$x:00002FE2                 db    0
.xdata$x:00002FE3                 db    0
.xdata$x:00002FE4                 db    0
.xdata$x:00002FE5                 db    0
.xdata$x:00002FE6                 db    0
.xdata$x:00002FE7                 db    0
.xdata$x:00002FE8                 db    0
.xdata$x:00002FE9                 db    0
.xdata$x:00002FEA                 db    0
.xdata$x:00002FEB                 db    0
.xdata$x:00002FEC                 db    0
.xdata$x:00002FED                 db    0
.xdata$x:00002FEE                 db    0
.xdata$x:00002FEF                 db    0
.xdata$x:00002FF0 __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:00002FF0                                         ; DATA XREF: .xdata$x:00002FDCo
.xdata$x:00002FF1                 db    0
.xdata$x:00002FF2                 db    0
.xdata$x:00002FF3                 db    0
.xdata$x:00002FF4                 db    2
.xdata$x:00002FF5                 db    0
.xdata$x:00002FF6                 db    0
.xdata$x:00002FF7                 db    0
.xdata$x:00002FF8                 db    3
.xdata$x:00002FF9                 db    0
.xdata$x:00002FFA                 db    0
.xdata$x:00002FFB                 db    0
.xdata$x:00002FFC                 db    1
.xdata$x:00002FFD                 db    0
.xdata$x:00002FFE                 db    0
.xdata$x:00002FFF                 db    0
.xdata$x:00003000                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00003004                 db    0
.xdata$x:00003005                 db    0
.xdata$x:00003006                 db    0
.xdata$x:00003007                 db    0
.xdata$x:00003008                 db    0
.xdata$x:00003009                 db    0
.xdata$x:0000300A                 db    0
.xdata$x:0000300B                 db    0
.xdata$x:0000300C                 db    3
.xdata$x:0000300D                 db    0
.xdata$x:0000300E                 db    0
.xdata$x:0000300F                 db    0
.xdata$x:00003010                 db    1
.xdata$x:00003011                 db    0
.xdata$x:00003012                 db    0
.xdata$x:00003013                 db    0
.xdata$x:00003014                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00003014 _xdata$x        ends
.xdata$x:00003014
.xdata$x:00003018 ; ===========================================================================
.xdata$x:00003018
.xdata$x:00003018 ; Segment type: Pure data
.xdata$x:00003018 ; Segment permissions: Read
.xdata$x:00003018 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003018                 assume cs:_xdata$x
.xdata$x:00003018                 ;org 3018h
.xdata$x:00003018 ; COMDAT (pick associative to section at 18A4)
.xdata$x:00003018 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003018                                         ; DATA XREF: .xdata$x:00003028o
.xdata$x:00003019                 db 0FFh
.xdata$x:0000301A                 db 0FFh
.xdata$x:0000301B                 db 0FFh
.xdata$x:0000301C                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:00003020 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003020                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:00003021                 db    5
.xdata$x:00003022                 db  93h ; ô
.xdata$x:00003023                 db  19h
.xdata$x:00003024                 db    1
.xdata$x:00003025                 db    0
.xdata$x:00003026                 db    0
.xdata$x:00003027                 db    0
.xdata$x:00003028                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:0000302C                 db    0
.xdata$x:0000302D                 db    0
.xdata$x:0000302E                 db    0
.xdata$x:0000302F                 db    0
.xdata$x:00003030                 db    0
.xdata$x:00003031                 db    0
.xdata$x:00003032                 db    0
.xdata$x:00003033                 db    0
.xdata$x:00003034                 db    0
.xdata$x:00003035                 db    0
.xdata$x:00003036                 db    0
.xdata$x:00003037                 db    0
.xdata$x:00003038                 db    0
.xdata$x:00003039                 db    0
.xdata$x:0000303A                 db    0
.xdata$x:0000303B                 db    0
.xdata$x:0000303C                 db    0
.xdata$x:0000303D                 db    0
.xdata$x:0000303E                 db    0
.xdata$x:0000303F                 db    0
.xdata$x:00003040                 db    0
.xdata$x:00003041                 db    0
.xdata$x:00003042                 db    0
.xdata$x:00003043                 db    0
.xdata$x:00003043 _xdata$x        ends
.xdata$x:00003043
.xdata$x:00003044 ; ===========================================================================
.xdata$x:00003044
.xdata$x:00003044 ; Segment type: Pure data
.xdata$x:00003044 ; Segment permissions: Read
.xdata$x:00003044 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003044                 assume cs:_xdata$x
.xdata$x:00003044                 ;org 3044h
.xdata$x:00003044 ; COMDAT (pick associative to section at 2B5C)
.xdata$x:00003044 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00003044                                         ; DATA XREF: .xdata$x:00003054o
.xdata$x:00003045                 db 0FFh
.xdata$x:00003046                 db 0FFh
.xdata$x:00003047                 db 0FFh
.xdata$x:00003048                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:0000304C __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:0000304C                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:0000304D                 db    5
.xdata$x:0000304E                 db  93h ; ô
.xdata$x:0000304F                 db  19h
.xdata$x:00003050                 db    1
.xdata$x:00003051                 db    0
.xdata$x:00003052                 db    0
.xdata$x:00003053                 db    0
.xdata$x:00003054                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003058                 db    0
.xdata$x:00003059                 db    0
.xdata$x:0000305A                 db    0
.xdata$x:0000305B                 db    0
.xdata$x:0000305C                 db    0
.xdata$x:0000305D                 db    0
.xdata$x:0000305E                 db    0
.xdata$x:0000305F                 db    0
.xdata$x:00003060                 db    0
.xdata$x:00003061                 db    0
.xdata$x:00003062                 db    0
.xdata$x:00003063                 db    0
.xdata$x:00003064                 db    0
.xdata$x:00003065                 db    0
.xdata$x:00003066                 db    0
.xdata$x:00003067                 db    0
.xdata$x:00003068                 db    0
.xdata$x:00003069                 db    0
.xdata$x:0000306A                 db    0
.xdata$x:0000306B                 db    0
.xdata$x:0000306C                 db    0
.xdata$x:0000306D                 db    0
.xdata$x:0000306E                 db    0
.xdata$x:0000306F                 db    0
.xdata$x:0000306F _xdata$x        ends
.xdata$x:0000306F
.xdata$x:00003070 ; ===========================================================================
.xdata$x:00003070
.xdata$x:00003070 ; Segment type: Pure data
.xdata$x:00003070 ; Segment permissions: Read
.xdata$x:00003070 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003070                 assume cs:_xdata$x
.xdata$x:00003070                 ;org 3070h
.xdata$x:00003070 ; COMDAT (pick associative to section at 1BF4)
.xdata$x:00003070 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003070                                         ; DATA XREF: .xdata$x:00003080o
.xdata$x:00003071                 db 0FFh
.xdata$x:00003072                 db 0FFh
.xdata$x:00003073                 db 0FFh
.xdata$x:00003074                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00003078 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003078                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00003079                 db    5
.xdata$x:0000307A                 db  93h ; ô
.xdata$x:0000307B                 db  19h
.xdata$x:0000307C                 db    1
.xdata$x:0000307D                 db    0
.xdata$x:0000307E                 db    0
.xdata$x:0000307F                 db    0
.xdata$x:00003080                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00003084                 db    0
.xdata$x:00003085                 db    0
.xdata$x:00003086                 db    0
.xdata$x:00003087                 db    0
.xdata$x:00003088                 db    0
.xdata$x:00003089                 db    0
.xdata$x:0000308A                 db    0
.xdata$x:0000308B                 db    0
.xdata$x:0000308C                 db    0
.xdata$x:0000308D                 db    0
.xdata$x:0000308E                 db    0
.xdata$x:0000308F                 db    0
.xdata$x:00003090                 db    0
.xdata$x:00003091                 db    0
.xdata$x:00003092                 db    0
.xdata$x:00003093                 db    0
.xdata$x:00003094                 db    0
.xdata$x:00003095                 db    0
.xdata$x:00003096                 db    0
.xdata$x:00003097                 db    0
.xdata$x:00003098                 db    0
.xdata$x:00003099                 db    0
.xdata$x:0000309A                 db    0
.xdata$x:0000309B                 db    0
.xdata$x:0000309B _xdata$x        ends
.xdata$x:0000309B
.xdata$x:0000309C ; ===========================================================================
.xdata$x:0000309C
.xdata$x:0000309C ; Segment type: Pure data
.xdata$x:0000309C ; Segment permissions: Read
.xdata$x:0000309C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000309C                 assume cs:_xdata$x
.xdata$x:0000309C                 ;org 309Ch
.xdata$x:0000309C ; COMDAT (pick associative to section at 1930)
.xdata$x:0000309C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000309C                                         ; DATA XREF: .xdata$x:000030ACo
.xdata$x:0000309D                 db 0FFh
.xdata$x:0000309E                 db 0FFh
.xdata$x:0000309F                 db 0FFh
.xdata$x:000030A0                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:000030A4 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000030A4                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:000030A5                 db    5
.xdata$x:000030A6                 db  93h ; ô
.xdata$x:000030A7                 db  19h
.xdata$x:000030A8                 db    1
.xdata$x:000030A9                 db    0
.xdata$x:000030AA                 db    0
.xdata$x:000030AB                 db    0
.xdata$x:000030AC                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:000030B0                 db    0
.xdata$x:000030B1                 db    0
.xdata$x:000030B2                 db    0
.xdata$x:000030B3                 db    0
.xdata$x:000030B4                 db    0
.xdata$x:000030B5                 db    0
.xdata$x:000030B6                 db    0
.xdata$x:000030B7                 db    0
.xdata$x:000030B8                 db    0
.xdata$x:000030B9                 db    0
.xdata$x:000030BA                 db    0
.xdata$x:000030BB                 db    0
.xdata$x:000030BC                 db    0
.xdata$x:000030BD                 db    0
.xdata$x:000030BE                 db    0
.xdata$x:000030BF                 db    0
.xdata$x:000030C0                 db    0
.xdata$x:000030C1                 db    0
.xdata$x:000030C2                 db    0
.xdata$x:000030C3                 db    0
.xdata$x:000030C4                 db    0
.xdata$x:000030C5                 db    0
.xdata$x:000030C6                 db    0
.xdata$x:000030C7                 db    0
.xdata$x:000030C7 _xdata$x        ends
.xdata$x:000030C7
.xdata$x:000030C8 ; ===========================================================================
.xdata$x:000030C8
.xdata$x:000030C8 ; Segment type: Pure data
.xdata$x:000030C8 ; Segment permissions: Read
.xdata$x:000030C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000030C8                 assume cs:_xdata$x
.xdata$x:000030C8                 ;org 30C8h
.xdata$x:000030C8 ; COMDAT (pick associative to section at 2C14)
.xdata$x:000030C8 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000030C8                                         ; DATA XREF: .xdata$x:000030D8o
.xdata$x:000030C9                 db 0FFh
.xdata$x:000030CA                 db 0FFh
.xdata$x:000030CB                 db 0FFh
.xdata$x:000030CC                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000030D0 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000030D0                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000030D1                 db    5
.xdata$x:000030D2                 db  93h ; ô
.xdata$x:000030D3                 db  19h
.xdata$x:000030D4                 db    1
.xdata$x:000030D5                 db    0
.xdata$x:000030D6                 db    0
.xdata$x:000030D7                 db    0
.xdata$x:000030D8                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:000030DC                 db    0
.xdata$x:000030DD                 db    0
.xdata$x:000030DE                 db    0
.xdata$x:000030DF                 db    0
.xdata$x:000030E0                 db    0
.xdata$x:000030E1                 db    0
.xdata$x:000030E2                 db    0
.xdata$x:000030E3                 db    0
.xdata$x:000030E4                 db    0
.xdata$x:000030E5                 db    0
.xdata$x:000030E6                 db    0
.xdata$x:000030E7                 db    0
.xdata$x:000030E8                 db    0
.xdata$x:000030E9                 db    0
.xdata$x:000030EA                 db    0
.xdata$x:000030EB                 db    0
.xdata$x:000030EC                 db    0
.xdata$x:000030ED                 db    0
.xdata$x:000030EE                 db    0
.xdata$x:000030EF                 db    0
.xdata$x:000030F0                 db    0
.xdata$x:000030F1                 db    0
.xdata$x:000030F2                 db    0
.xdata$x:000030F3                 db    0
.xdata$x:000030F3 _xdata$x        ends
.xdata$x:000030F3
.xdata$x:000030F4 ; ===========================================================================
.xdata$x:000030F4
.xdata$x:000030F4 ; Segment type: Pure data
.xdata$x:000030F4 ; Segment permissions: Read
.xdata$x:000030F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000030F4                 assume cs:_xdata$x
.xdata$x:000030F4                 ;org 30F4h
.xdata$x:000030F4 ; COMDAT (pick associative to section at 1C64)
.xdata$x:000030F4 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000030F4                                         ; DATA XREF: .xdata$x:00003104o
.xdata$x:000030F5                 db 0FFh
.xdata$x:000030F6                 db 0FFh
.xdata$x:000030F7                 db 0FFh
.xdata$x:000030F8                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000030FC __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000030FC                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000030FD                 db    5
.xdata$x:000030FE                 db  93h ; ô
.xdata$x:000030FF                 db  19h
.xdata$x:00003100                 db    1
.xdata$x:00003101                 db    0
.xdata$x:00003102                 db    0
.xdata$x:00003103                 db    0
.xdata$x:00003104                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:00003108                 align 20h
.xdata$x:00003108 _xdata$x        ends
.xdata$x:00003108
.xdata$x:00003120 ; ===========================================================================
.xdata$x:00003120
.xdata$x:00003120 ; Segment type: Pure data
.xdata$x:00003120 ; Segment permissions: Read
.xdata$x:00003120 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003120                 assume cs:_xdata$x
.xdata$x:00003120                 ;org 3120h
.xdata$x:00003120 ; COMDAT (pick associative to section at 19AC)
.xdata$x:00003120 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:00003120                                         ; DATA XREF: .xdata$x:00003130o
.xdata$x:00003121                 db 0FFh
.xdata$x:00003122                 db 0FFh
.xdata$x:00003123                 db 0FFh
.xdata$x:00003124                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:00003128 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00003128                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:00003129                 db    5
.xdata$x:0000312A                 db  93h ; ô
.xdata$x:0000312B                 db  19h
.xdata$x:0000312C                 db    1
.xdata$x:0000312D                 db    0
.xdata$x:0000312E                 db    0
.xdata$x:0000312F                 db    0
.xdata$x:00003130                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:00003134                 db    0
.xdata$x:00003135                 db    0
.xdata$x:00003136                 db    0
.xdata$x:00003137                 db    0
.xdata$x:00003138                 db    0
.xdata$x:00003139                 db    0
.xdata$x:0000313A                 db    0
.xdata$x:0000313B                 db    0
.xdata$x:0000313C                 db    0
.xdata$x:0000313D                 db    0
.xdata$x:0000313E                 db    0
.xdata$x:0000313F                 db    0
.xdata$x:00003140                 db    0
.xdata$x:00003141                 db    0
.xdata$x:00003142                 db    0
.xdata$x:00003143                 db    0
.xdata$x:00003144                 db    0
.xdata$x:00003145                 db    0
.xdata$x:00003146                 db    0
.xdata$x:00003147                 db    0
.xdata$x:00003148                 db    0
.xdata$x:00003149                 db    0
.xdata$x:0000314A                 db    0
.xdata$x:0000314B                 db    0
.xdata$x:0000314B _xdata$x        ends
.xdata$x:0000314B
.xdata$x:0000314C ; ===========================================================================
.xdata$x:0000314C
.xdata$x:0000314C ; Segment type: Pure data
.xdata$x:0000314C ; Segment permissions: Read
.xdata$x:0000314C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000314C                 assume cs:_xdata$x
.xdata$x:0000314C                 ;org 314Ch
.xdata$x:0000314C ; COMDAT (pick associative to section at 2CD8)
.xdata$x:0000314C __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:0000314C                                         ; DATA XREF: .xdata$x:0000315Co
.xdata$x:0000314D                 db 0FFh
.xdata$x:0000314E                 db 0FFh
.xdata$x:0000314F                 db 0FFh
.xdata$x:00003150                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00003154 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00003154                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00003155                 db    5
.xdata$x:00003156                 db  93h ; ô
.xdata$x:00003157                 db  19h
.xdata$x:00003158                 db    1
.xdata$x:00003159                 db    0
.xdata$x:0000315A                 db    0
.xdata$x:0000315B                 db    0
.xdata$x:0000315C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00003160                 db    0
.xdata$x:00003161                 db    0
.xdata$x:00003162                 db    0
.xdata$x:00003163                 db    0
.xdata$x:00003164                 db    0
.xdata$x:00003165                 db    0
.xdata$x:00003166                 db    0
.xdata$x:00003167                 db    0
.xdata$x:00003168                 db    0
.xdata$x:00003169                 db    0
.xdata$x:0000316A                 db    0
.xdata$x:0000316B                 db    0
.xdata$x:0000316C                 db    0
.xdata$x:0000316D                 db    0
.xdata$x:0000316E                 db    0
.xdata$x:0000316F                 db    0
.xdata$x:00003170                 db    0
.xdata$x:00003171                 db    0
.xdata$x:00003172                 db    0
.xdata$x:00003173                 db    0
.xdata$x:00003174                 db    0
.xdata$x:00003175                 db    0
.xdata$x:00003176                 db    0
.xdata$x:00003177                 db    0
.xdata$x:00003177 _xdata$x        ends
.xdata$x:00003177
.xdata$x:00003178 ; ===========================================================================
.xdata$x:00003178
.xdata$x:00003178 ; Segment type: Pure data
.xdata$x:00003178 ; Segment permissions: Read
.xdata$x:00003178 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00003178                 assume cs:_xdata$x
.xdata$x:00003178                 ;org 3178h
.xdata$x:00003178 ; COMDAT (pick associative to section at 1CD4)
.xdata$x:00003178 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00003178                                         ; DATA XREF: .xdata$x:00003188o
.xdata$x:00003179                 db 0FFh
.xdata$x:0000317A                 db 0FFh
.xdata$x:0000317B                 db 0FFh
.xdata$x:0000317C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00003180 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00003180                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00003181                 db    5
.xdata$x:00003182                 db  93h ; ô
.xdata$x:00003183                 db  19h
.xdata$x:00003184                 db    1
.xdata$x:00003185                 db    0
.xdata$x:00003186                 db    0
.xdata$x:00003187                 db    0
.xdata$x:00003188                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000318C                 db    0
.xdata$x:0000318D                 db    0
.xdata$x:0000318E                 db    0
.xdata$x:0000318F                 db    0
.xdata$x:00003190                 db    0
.xdata$x:00003191                 db    0
.xdata$x:00003192                 db    0
.xdata$x:00003193                 db    0
.xdata$x:00003194                 db    0
.xdata$x:00003195                 db    0
.xdata$x:00003196                 db    0
.xdata$x:00003197                 db    0
.xdata$x:00003198                 db    0
.xdata$x:00003199                 db    0
.xdata$x:0000319A                 db    0
.xdata$x:0000319B                 db    0
.xdata$x:0000319C                 db    0
.xdata$x:0000319D                 db    0
.xdata$x:0000319E                 db    0
.xdata$x:0000319F                 db    0
.xdata$x:000031A0                 db    0
.xdata$x:000031A1                 db    0
.xdata$x:000031A2                 db    0
.xdata$x:000031A3                 db    0
.xdata$x:000031A3 _xdata$x        ends
.xdata$x:000031A3
.xdata$x:000031A4 ; ===========================================================================
.xdata$x:000031A4
.xdata$x:000031A4 ; Segment type: Pure data
.xdata$x:000031A4 ; Segment permissions: Read
.xdata$x:000031A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000031A4                 assume cs:_xdata$x
.xdata$x:000031A4                 ;org 31A4h
.xdata$x:000031A4 ; COMDAT (pick associative to section at 1578)
.xdata$x:000031A4 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000031A4                                         ; DATA XREF: .xdata$x:000031B4o
.xdata$x:000031A5                 db 0FFh
.xdata$x:000031A6                 db 0FFh
.xdata$x:000031A7                 db 0FFh
.xdata$x:000031A8                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000031AC __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000031AC                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000031AD                 db    5
.xdata$x:000031AE                 db  93h ; ô
.xdata$x:000031AF                 db  19h
.xdata$x:000031B0                 db    1
.xdata$x:000031B1                 db    0
.xdata$x:000031B2                 db    0
.xdata$x:000031B3                 db    0
.xdata$x:000031B4                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000031B8                 db    0
.xdata$x:000031B9                 db    0
.xdata$x:000031BA                 db    0
.xdata$x:000031BB                 db    0
.xdata$x:000031BC                 db    0
.xdata$x:000031BD                 db    0
.xdata$x:000031BE                 db    0
.xdata$x:000031BF                 db    0
.xdata$x:000031C0                 db    0
.xdata$x:000031C1                 db    0
.xdata$x:000031C2                 db    0
.xdata$x:000031C3                 db    0
.xdata$x:000031C4                 db    0
.xdata$x:000031C5                 db    0
.xdata$x:000031C6                 db    0
.xdata$x:000031C7                 db    0
.xdata$x:000031C8                 db    0
.xdata$x:000031C9                 db    0
.xdata$x:000031CA                 db    0
.xdata$x:000031CB                 db    0
.xdata$x:000031CC                 db    0
.xdata$x:000031CD                 db    0
.xdata$x:000031CE                 db    0
.xdata$x:000031CF                 db    0
.xdata$x:000031CF _xdata$x        ends
.xdata$x:000031CF
.xdata$x:000031D0 ; ===========================================================================
.xdata$x:000031D0
.xdata$x:000031D0 ; Segment type: Pure data
.xdata$x:000031D0 ; Segment permissions: Read
.xdata$x:000031D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000031D0                 assume cs:_xdata$x
.xdata$x:000031D0                 ;org 31D0h
.xdata$x:000031D0 ; COMDAT (pick associative to section at 14A4)
.xdata$x:000031D0 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:000031D0                                         ; DATA XREF: .xdata$x:000031E0o
.xdata$x:000031D1                 db 0FFh
.xdata$x:000031D2                 db 0FFh
.xdata$x:000031D3                 db 0FFh
.xdata$x:000031D4                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:000031D8 __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:000031D8                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:000031D9                 db    5
.xdata$x:000031DA                 db  93h ; ô
.xdata$x:000031DB                 db  19h
.xdata$x:000031DC                 db    1
.xdata$x:000031DD                 db    0
.xdata$x:000031DE                 db    0
.xdata$x:000031DF                 db    0
.xdata$x:000031E0                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:000031E4                 db    0
.xdata$x:000031E5                 db    0
.xdata$x:000031E6                 db    0
.xdata$x:000031E7                 db    0
.xdata$x:000031E8                 db    0
.xdata$x:000031E9                 db    0
.xdata$x:000031EA                 db    0
.xdata$x:000031EB                 db    0
.xdata$x:000031EC                 db    0
.xdata$x:000031ED                 db    0
.xdata$x:000031EE                 db    0
.xdata$x:000031EF                 db    0
.xdata$x:000031F0                 db    0
.xdata$x:000031F1                 db    0
.xdata$x:000031F2                 db    0
.xdata$x:000031F3                 db    0
.xdata$x:000031F4                 db    0
.xdata$x:000031F5                 db    0
.xdata$x:000031F6                 db    0
.xdata$x:000031F7                 db    0
.xdata$x:000031F8                 db    0
.xdata$x:000031F9                 db    0
.xdata$x:000031FA                 db    0
.xdata$x:000031FB                 db    0
.xdata$x:000031FB _xdata$x        ends
.xdata$x:000031FB
.rdata:000031FC ; ===========================================================================
.rdata:000031FC
.rdata:000031FC ; Segment type: Pure data
.rdata:000031FC ; Segment permissions: Read
.rdata:000031FC _rdata          segment dword public 'DATA' use32
.rdata:000031FC                 assume cs:_rdata
.rdata:000031FC                 ;org 31FCh
.rdata:000031FC ; COMDAT (pick largest)
.rdata:000031FC                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:00003200                 public ??_7error_category@std@@6B@
.rdata:00003200 ; const std::error_category::`vftable'
.rdata:00003200 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:00003200                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:00003200                                         ; std::error_category::~error_category(void)+Ao
.rdata:00003200                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:00003204                 dd offset __purecall
.rdata:00003208                 dd offset __purecall
.rdata:0000320C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003210                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003214                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003214 _rdata          ends
.rdata:00003214
.rdata:00003218 ; ===========================================================================
.rdata:00003218
.rdata:00003218 ; Segment type: Pure data
.rdata:00003218 ; Segment permissions: Read
.rdata:00003218 _rdata          segment dword public 'DATA' use32
.rdata:00003218                 assume cs:_rdata
.rdata:00003218                 ;org 3218h
.rdata:00003218 ; COMDAT (pick largest)
.rdata:00003218                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:0000321C                 public ??_7_Generic_error_category@std@@6B@
.rdata:0000321C ; const std::_Generic_error_category::`vftable'
.rdata:0000321C ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:0000321C                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:0000321C                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00003220                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00003224                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00003228                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:0000322C                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003230                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003230 _rdata          ends
.rdata:00003230
.rdata:00003234 ; ===========================================================================
.rdata:00003234
.rdata:00003234 ; Segment type: Pure data
.rdata:00003234 ; Segment permissions: Read
.rdata:00003234 _rdata          segment dword public 'DATA' use32
.rdata:00003234                 assume cs:_rdata
.rdata:00003234                 ;org 3234h
.rdata:00003234 ; COMDAT (pick any)
.rdata:00003234                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00003234 ; `string'
.rdata:00003234 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00003234                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00003234 _rdata          ends
.rdata:00003234
.rdata:0000323C ; ===========================================================================
.rdata:0000323C
.rdata:0000323C ; Segment type: Pure data
.rdata:0000323C ; Segment permissions: Read
.rdata:0000323C _rdata          segment dword public 'DATA' use32
.rdata:0000323C                 assume cs:_rdata
.rdata:0000323C                 ;org 323Ch
.rdata:0000323C ; COMDAT (pick any)
.rdata:0000323C                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:0000323C ; `string'
.rdata:0000323C ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:0000323C                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_2BA8o
.rdata:0000323C                                         ; std::_System_error_category::message(int):loc_2D24o
.rdata:0000324A                 align 4
.rdata:0000324A _rdata          ends
.rdata:0000324A
.rdata:0000324C ; ===========================================================================
.rdata:0000324C
.rdata:0000324C ; Segment type: Pure data
.rdata:0000324C ; Segment permissions: Read
.rdata:0000324C _rdata          segment dword public 'DATA' use32
.rdata:0000324C                 assume cs:_rdata
.rdata:0000324C                 ;org 324Ch
.rdata:0000324C ; COMDAT (pick largest)
.rdata:0000324C                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00003250                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00003250 ; const std::_Iostream_error_category::`vftable'
.rdata:00003250 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00003250                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00003250                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00003254                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00003258                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:0000325C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00003260                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00003264                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00003264 _rdata          ends
.rdata:00003264
.rdata:00003268 ; ===========================================================================
.rdata:00003268
.rdata:00003268 ; Segment type: Pure data
.rdata:00003268 ; Segment permissions: Read
.rdata:00003268 _rdata          segment dword public 'DATA' use32
.rdata:00003268                 assume cs:_rdata
.rdata:00003268                 ;org 3268h
.rdata:00003268 ; COMDAT (pick any)
.rdata:00003268                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00003268 ; `string'
.rdata:00003268 ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00003268                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00003271                 align 4
.rdata:00003271 _rdata          ends
.rdata:00003271
.rdata:00003274 ; ===========================================================================
.rdata:00003274
.rdata:00003274 ; Segment type: Pure data
.rdata:00003274 ; Segment permissions: Read
.rdata:00003274 _rdata          segment dword public 'DATA' use32
.rdata:00003274                 assume cs:_rdata
.rdata:00003274                 ;org 3274h
.rdata:00003274 ; COMDAT (pick any)
.rdata:00003274                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00003274 ; char `string'[]
.rdata:00003274 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00003274                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:0000328A                 align 4
.rdata:0000328A _rdata          ends
.rdata:0000328A
.rdata:0000328C ; ===========================================================================
.rdata:0000328C
.rdata:0000328C ; Segment type: Pure data
.rdata:0000328C ; Segment permissions: Read
.rdata:0000328C _rdata          segment dword public 'DATA' use32
.rdata:0000328C                 assume cs:_rdata
.rdata:0000328C                 ;org 328Ch
.rdata:0000328C ; COMDAT (pick largest)
.rdata:0000328C                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00003290                 public ??_7_System_error_category@std@@6B@
.rdata:00003290 ; const std::_System_error_category::`vftable'
.rdata:00003290 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00003290                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00003290                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00003294                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00003298                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:0000329C                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:000032A0                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:000032A4                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:000032A4 _rdata          ends
.rdata:000032A4
.rdata:000032A8 ; ===========================================================================
.rdata:000032A8
.rdata:000032A8 ; Segment type: Pure data
.rdata:000032A8 ; Segment permissions: Read
.rdata:000032A8 _rdata          segment dword public 'DATA' use32
.rdata:000032A8                 assume cs:_rdata
.rdata:000032A8                 ;org 32A8h
.rdata:000032A8 ; COMDAT (pick any)
.rdata:000032A8                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:000032A8 ; `string'
.rdata:000032A8 ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:000032A8                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:000032AF                 align 10h
.rdata:000032AF _rdata          ends
.rdata:000032AF
.bss:000032B0 ; ===========================================================================
.bss:000032B0
.bss:000032B0 ; Segment type: Uninitialized
.bss:000032B0 ; Segment permissions: Read/Write
.bss:000032B0 _bss            segment dword public 'BSS' use32
.bss:000032B0                 assume cs:_bss
.bss:000032B0                 ;org 32B0h
.bss:000032B0 ; COMDAT (pick any)
.bss:000032B0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000032B0                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:000032B0 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:000032B0 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:000032B0                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:000032B0                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:000032B1                 db    ? ;
.bss:000032B2                 db    ? ;
.bss:000032B3                 db    ? ;
.bss:000032B3 _bss            ends
.bss:000032B3
.bss:000032B4 ; ===========================================================================
.bss:000032B4
.bss:000032B4 ; Segment type: Uninitialized
.bss:000032B4 ; Segment permissions: Read/Write
.bss:000032B4 _bss            segment dword public 'BSS' use32
.bss:000032B4                 assume cs:_bss
.bss:000032B4                 ;org 32B4h
.bss:000032B4 ; COMDAT (pick any)
.bss:000032B4                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000032B4                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:000032B4 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:000032B4 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:000032B4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000032B4                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:000032B5                 db    ? ;
.bss:000032B6                 db    ? ;
.bss:000032B7                 db    ? ;
.bss:000032B7 _bss            ends
.bss:000032B7
.bss:000032B8 ; ===========================================================================
.bss:000032B8
.bss:000032B8 ; Segment type: Uninitialized
.bss:000032B8 ; Segment permissions: Read/Write
.bss:000032B8 _bss            segment dword public 'BSS' use32
.bss:000032B8                 assume cs:_bss
.bss:000032B8                 ;org 32B8h
.bss:000032B8 ; COMDAT (pick any)
.bss:000032B8                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000032B8                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:000032B8 ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:000032B8 ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:000032B8                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:000032B8                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:000032B9                 db    ? ;
.bss:000032BA                 db    ? ;
.bss:000032BB                 db    ? ;
.bss:000032BB _bss            ends
.bss:000032BB
.bss:000032BC ; ===========================================================================
.bss:000032BC
.bss:000032BC ; Segment type: Uninitialized
.bss:000032BC ; Segment permissions: Read/Write
.bss:000032BC _bss            segment dword public 'BSS' use32
.bss:000032BC                 assume cs:_bss
.bss:000032BC                 ;org 32BCh
.bss:000032BC ; COMDAT (pick any)
.bss:000032BC                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000032BC                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000032BC ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:000032BC ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000032BC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:000032BD                 db    ? ;
.bss:000032BE                 db    ? ;
.bss:000032BF                 db    ? ;
.bss:000032BF _bss            ends
.bss:000032BF
.bss:000032C0 ; ===========================================================================
.bss:000032C0
.bss:000032C0 ; Segment type: Uninitialized
.bss:000032C0 ; Segment permissions: Read/Write
.bss:000032C0 _bss            segment dword public 'BSS' use32
.bss:000032C0                 assume cs:_bss
.bss:000032C0                 ;org 32C0h
.bss:000032C0 ; COMDAT (pick any)
.bss:000032C0                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:000032C0                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:000032C0 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:000032C0 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:000032C0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:000032C1                 db    ? ;
.bss:000032C2                 db    ? ;
.bss:000032C3                 db    ? ;
.bss:000032C3 _bss            ends
.bss:000032C3
.rdata:000032C4 ; ===========================================================================
.rdata:000032C4
.rdata:000032C4 ; Segment type: Pure data
.rdata:000032C4 ; Segment permissions: Read
.rdata:000032C4 ; Segment alignment 'qword' can not be represented in assembly
.rdata:000032C4 _rdata          segment para public 'DATA' use32
.rdata:000032C4                 assume cs:_rdata
.rdata:000032C4                 ;org 32C4h
.rdata:000032C4 ; COMDAT (pick any)
.rdata:000032C4                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:000032C4 ; wchar_t `string'
.rdata:000032C4 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:000032C4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:000032C4                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:000032C4                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:000032C4                 unicode 0, <clude\xstring>,0
.rdata:00003352                 align 4
.rdata:00003352 _rdata          ends
.rdata:00003352
.bss:00003354 ; ===========================================================================
.bss:00003354
.bss:00003354 ; Segment type: Uninitialized
.bss:00003354 ; Segment permissions: Read/Write
.bss:00003354 _bss            segment dword public 'BSS' use32
.bss:00003354                 assume cs:_bss
.bss:00003354                 ;org 3354h
.bss:00003354 ; COMDAT (pick any)
.bss:00003354                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003354                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00003354 ; std::locale::id std::numpunct<char>::id
.bss:00003354 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00003354                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00003355                 db    ? ;
.bss:00003356                 db    ? ;
.bss:00003357                 db    ? ;
.bss:00003357 _bss            ends
.bss:00003357
.bss:00003358 ; ===========================================================================
.bss:00003358
.bss:00003358 ; Segment type: Uninitialized
.bss:00003358 ; Segment permissions: Read/Write
.bss:00003358 _bss            segment dword public 'BSS' use32
.bss:00003358                 assume cs:_bss
.bss:00003358                 ;org 3358h
.bss:00003358 ; COMDAT (pick any)
.bss:00003358                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing
.bss:00003358                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00003358 ; std::locale::id std::numpunct<wchar_t>::id
.bss:00003358 ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00003358                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00003359                 db    ? ;
.bss:0000335A                 db    ? ;
.bss:0000335B                 db    ? ;
.bss:0000335B _bss            ends
.bss:0000335B
.rdata:0000335C ; ===========================================================================
.rdata:0000335C
.rdata:0000335C ; Segment type: Pure data
.rdata:0000335C ; Segment permissions: Read
.rdata:0000335C _rdata          segment dword public 'DATA' use32
.rdata:0000335C                 assume cs:_rdata
.rdata:0000335C                 ;org 335Ch
.rdata:0000335C ; COMDAT (pick any)
.rdata:0000335C                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:0000335C ; char `string'[]
.rdata:0000335C ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:0000335C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:0000335C _rdata          ends
.rdata:0000335C
.rdata:0000336C ; ===========================================================================
.rdata:0000336C
.rdata:0000336C ; Segment type: Pure data
.rdata:0000336C ; Segment permissions: Read
.rdata:0000336C _rdata          segment dword public 'DATA' use32
.rdata:0000336C                 assume cs:_rdata
.rdata:0000336C                 ;org 336Ch
.rdata:0000336C ; COMDAT (pick any)
.rdata:0000336C                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:0000336C ; char `string'[]
.rdata:0000336C ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:0000336C                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:0000336C _rdata          ends
.rdata:0000336C
.rdata:00003384 ; ===========================================================================
.rdata:00003384
.rdata:00003384 ; Segment type: Pure data
.rdata:00003384 ; Segment permissions: Read
.rdata:00003384 _rdata          segment dword public 'DATA' use32
.rdata:00003384                 assume cs:_rdata
.rdata:00003384                 ;org 3384h
.rdata:00003384 ; COMDAT (pick any)
.rdata:00003384                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00003384 ; wchar_t `string'
.rdata:00003384 ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00003384                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00003384                 unicode 0, <invalid null pointer>,0
.rdata:000033AE                 align 10h
.rdata:000033AE _rdata          ends
.rdata:000033AE
.rdata$r:000033B0 ; ===========================================================================
.rdata$r:000033B0
.rdata$r:000033B0 ; Segment type: Pure data
.rdata$r:000033B0 ; Segment permissions: Read
.rdata$r:000033B0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033B0                 assume cs:_rdata$r
.rdata$r:000033B0                 ;org 33B0h
.rdata$r:000033B0 ; COMDAT (pick any)
.rdata$r:000033B0                 public ??_R4error_category@std@@6B@
.rdata$r:000033B0 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:000033B0 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000031FCo
.rdata$r:000033B1                 db    0
.rdata$r:000033B2                 db    0
.rdata$r:000033B3                 db    0
.rdata$r:000033B4                 db    0
.rdata$r:000033B5                 db    0
.rdata$r:000033B6                 db    0
.rdata$r:000033B7                 db    0
.rdata$r:000033B8                 db    0
.rdata$r:000033B9                 db    0
.rdata$r:000033BA                 db    0
.rdata$r:000033BB                 db    0
.rdata$r:000033BC                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:000033C0                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033C0 _rdata$r        ends
.rdata$r:000033C0
.data$r:000033C4 ; ===========================================================================
.data$r:000033C4
.data$r:000033C4 ; Segment type: Pure data
.data$r:000033C4 ; Segment permissions: Read/Write
.data$r:000033C4 _data$r         segment dword public 'DATA' use32
.data$r:000033C4                 assume cs:_data$r
.data$r:000033C4                 ;org 33C4h
.data$r:000033C4 ; COMDAT (pick any)
.data$r:000033C4                 public ??_R0?AVerror_category@std@@@8
.data$r:000033C4 ; class std::error_category `RTTI Type Descriptor'
.data$r:000033C4 ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000033C4                                         ; DATA XREF: .rdata$r:000033BCo
.data$r:000033C4                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000033C4                                         ; const type_info::`vftable'
.data$r:000033C8                 db    0
.data$r:000033C9                 db    0
.data$r:000033CA                 db    0
.data$r:000033CB                 db    0
.data$r:000033CC                 db  2Eh ; .
.data$r:000033CD                 db  3Fh ; ?
.data$r:000033CE                 db  41h ; A
.data$r:000033CF                 db  56h ; V
.data$r:000033D0                 db  65h ; e
.data$r:000033D1                 db  72h ; r
.data$r:000033D2                 db  72h ; r
.data$r:000033D3                 db  6Fh ; o
.data$r:000033D4                 db  72h ; r
.data$r:000033D5                 db  5Fh ; _
.data$r:000033D6                 db  63h ; c
.data$r:000033D7                 db  61h ; a
.data$r:000033D8                 db  74h ; t
.data$r:000033D9                 db  65h ; e
.data$r:000033DA                 db  67h ; g
.data$r:000033DB                 db  6Fh ; o
.data$r:000033DC                 db  72h ; r
.data$r:000033DD                 db  79h ; y
.data$r:000033DE                 db  40h ; @
.data$r:000033DF                 db  73h ; s
.data$r:000033E0                 db  74h ; t
.data$r:000033E1                 db  64h ; d
.data$r:000033E2                 db  40h ; @
.data$r:000033E3                 db  40h ; @
.data$r:000033E4                 db    0
.data$r:000033E5                 align 4
.data$r:000033E5 _data$r         ends
.data$r:000033E5
.rdata$r:000033E8 ; ===========================================================================
.rdata$r:000033E8
.rdata$r:000033E8 ; Segment type: Pure data
.rdata$r:000033E8 ; Segment permissions: Read
.rdata$r:000033E8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033E8                 assume cs:_rdata$r
.rdata$r:000033E8                 ;org 33E8h
.rdata$r:000033E8 ; COMDAT (pick any)
.rdata$r:000033E8                 public ??_R3error_category@std@@8
.rdata$r:000033E8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000033E8 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:000033C0o
.rdata$r:000033E8                                         ; .rdata$r:00003418o
.rdata$r:000033E9                 db    0
.rdata$r:000033EA                 db    0
.rdata$r:000033EB                 db    0
.rdata$r:000033EC                 db    0
.rdata$r:000033ED                 db    0
.rdata$r:000033EE                 db    0
.rdata$r:000033EF                 db    0
.rdata$r:000033F0                 db    1
.rdata$r:000033F1                 db    0
.rdata$r:000033F2                 db    0
.rdata$r:000033F3                 db    0
.rdata$r:000033F4                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000033F4 _rdata$r        ends
.rdata$r:000033F4
.rdata$r:000033F8 ; ===========================================================================
.rdata$r:000033F8
.rdata$r:000033F8 ; Segment type: Pure data
.rdata$r:000033F8 ; Segment permissions: Read
.rdata$r:000033F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000033F8                 assume cs:_rdata$r
.rdata$r:000033F8                 ;org 33F8h
.rdata$r:000033F8 ; COMDAT (pick any)
.rdata$r:000033F8                 public ??_R2error_category@std@@8
.rdata$r:000033F8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:000033F8 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:000033F8                                         ; DATA XREF: .rdata$r:000033F4o
.rdata$r:000033F8                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000033FC                 db    0
.rdata$r:000033FD                 align 10h
.rdata$r:000033FD _rdata$r        ends
.rdata$r:000033FD
.rdata$r:00003400 ; ===========================================================================
.rdata$r:00003400
.rdata$r:00003400 ; Segment type: Pure data
.rdata$r:00003400 ; Segment permissions: Read
.rdata$r:00003400 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003400                 assume cs:_rdata$r
.rdata$r:00003400                 ;org 3400h
.rdata$r:00003400 ; COMDAT (pick any)
.rdata$r:00003400                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00003400 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003400 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00003400                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00003400                                         ; .rdata$r:00003470o ...
.rdata$r:00003400                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00003404                 db    0
.rdata$r:00003405                 db    0
.rdata$r:00003406                 db    0
.rdata$r:00003407                 db    0
.rdata$r:00003408                 db    0
.rdata$r:00003409                 db    0
.rdata$r:0000340A                 db    0
.rdata$r:0000340B                 db    0
.rdata$r:0000340C                 db 0FFh
.rdata$r:0000340D                 db 0FFh
.rdata$r:0000340E                 db 0FFh
.rdata$r:0000340F                 db 0FFh
.rdata$r:00003410                 db    0
.rdata$r:00003411                 db    0
.rdata$r:00003412                 db    0
.rdata$r:00003413                 db    0
.rdata$r:00003414                 db  40h ; @
.rdata$r:00003415                 db    0
.rdata$r:00003416                 db    0
.rdata$r:00003417                 db    0
.rdata$r:00003418                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003418 _rdata$r        ends
.rdata$r:00003418
.rdata$r:0000341C ; ===========================================================================
.rdata$r:0000341C
.rdata$r:0000341C ; Segment type: Pure data
.rdata$r:0000341C ; Segment permissions: Read
.rdata$r:0000341C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000341C                 assume cs:_rdata$r
.rdata$r:0000341C                 ;org 341Ch
.rdata$r:0000341C ; COMDAT (pick any)
.rdata$r:0000341C                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:0000341C ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:0000341C ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:0000341C                                         ; DATA XREF: .rdata:00003218o
.rdata$r:0000341D                 db    0
.rdata$r:0000341E                 db    0
.rdata$r:0000341F                 db    0
.rdata$r:00003420                 db    0
.rdata$r:00003421                 db    0
.rdata$r:00003422                 db    0
.rdata$r:00003423                 db    0
.rdata$r:00003424                 db    0
.rdata$r:00003425                 db    0
.rdata$r:00003426                 db    0
.rdata$r:00003427                 db    0
.rdata$r:00003428                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000342C                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000342C _rdata$r        ends
.rdata$r:0000342C
.data$r:00003430 ; ===========================================================================
.data$r:00003430
.data$r:00003430 ; Segment type: Pure data
.data$r:00003430 ; Segment permissions: Read/Write
.data$r:00003430 _data$r         segment dword public 'DATA' use32
.data$r:00003430                 assume cs:_data$r
.data$r:00003430                 ;org 3430h
.data$r:00003430 ; COMDAT (pick any)
.data$r:00003430                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00003430 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00003430 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003430                                         ; DATA XREF: .rdata$r:00003428o
.data$r:00003430                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003430                                         ; const type_info::`vftable'
.data$r:00003434                 align 8
.data$r:00003438 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:0000345A                 align 4
.data$r:0000345A _data$r         ends
.data$r:0000345A
.rdata$r:0000345C ; ===========================================================================
.rdata$r:0000345C
.rdata$r:0000345C ; Segment type: Pure data
.rdata$r:0000345C ; Segment permissions: Read
.rdata$r:0000345C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000345C                 assume cs:_rdata$r
.rdata$r:0000345C                 ;org 345Ch
.rdata$r:0000345C ; COMDAT (pick any)
.rdata$r:0000345C                 public ??_R3_Generic_error_category@std@@8
.rdata$r:0000345C ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000345C ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:0000345C                                         ; DATA XREF: .rdata$r:0000342Co
.rdata$r:0000345C                                         ; .rdata$r:00003490o
.rdata$r:0000345D                 db    0
.rdata$r:0000345E                 db    0
.rdata$r:0000345F                 db    0
.rdata$r:00003460                 db    0
.rdata$r:00003461                 db    0
.rdata$r:00003462                 db    0
.rdata$r:00003463                 db    0
.rdata$r:00003464                 db    2
.rdata$r:00003465                 db    0
.rdata$r:00003466                 db    0
.rdata$r:00003467                 db    0
.rdata$r:00003468                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00003468 _rdata$r        ends
.rdata$r:00003468
.rdata$r:0000346C ; ===========================================================================
.rdata$r:0000346C
.rdata$r:0000346C ; Segment type: Pure data
.rdata$r:0000346C ; Segment permissions: Read
.rdata$r:0000346C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000346C                 assume cs:_rdata$r
.rdata$r:0000346C                 ;org 346Ch
.rdata$r:0000346C ; COMDAT (pick any)
.rdata$r:0000346C                 public ??_R2_Generic_error_category@std@@8
.rdata$r:0000346C ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:0000346C ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:0000346C                                         ; DATA XREF: .rdata$r:00003468o
.rdata$r:0000346C                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003470                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003474                 db    0
.rdata$r:00003475                 align 4
.rdata$r:00003475 _rdata$r        ends
.rdata$r:00003475
.rdata$r:00003478 ; ===========================================================================
.rdata$r:00003478
.rdata$r:00003478 ; Segment type: Pure data
.rdata$r:00003478 ; Segment permissions: Read
.rdata$r:00003478 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003478                 assume cs:_rdata$r
.rdata$r:00003478                 ;org 3478h
.rdata$r:00003478 ; COMDAT (pick any)
.rdata$r:00003478                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00003478 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003478 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00003478                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00003478                                         ; .rdata$r:000034E8o ...
.rdata$r:00003478                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:0000347C                 db    1
.rdata$r:0000347D                 db    0
.rdata$r:0000347E                 db    0
.rdata$r:0000347F                 db    0
.rdata$r:00003480                 db    0
.rdata$r:00003481                 db    0
.rdata$r:00003482                 db    0
.rdata$r:00003483                 db    0
.rdata$r:00003484                 db 0FFh
.rdata$r:00003485                 db 0FFh
.rdata$r:00003486                 db 0FFh
.rdata$r:00003487                 db 0FFh
.rdata$r:00003488                 db    0
.rdata$r:00003489                 db    0
.rdata$r:0000348A                 db    0
.rdata$r:0000348B                 db    0
.rdata$r:0000348C                 db  40h ; @
.rdata$r:0000348D                 db    0
.rdata$r:0000348E                 db    0
.rdata$r:0000348F                 db    0
.rdata$r:00003490                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003490 _rdata$r        ends
.rdata$r:00003490
.rdata$r:00003494 ; ===========================================================================
.rdata$r:00003494
.rdata$r:00003494 ; Segment type: Pure data
.rdata$r:00003494 ; Segment permissions: Read
.rdata$r:00003494 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003494                 assume cs:_rdata$r
.rdata$r:00003494                 ;org 3494h
.rdata$r:00003494 ; COMDAT (pick any)
.rdata$r:00003494                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:00003494 ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:00003494 ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:00003494                                         ; DATA XREF: .rdata:0000324Co
.rdata$r:00003495                 db    0
.rdata$r:00003496                 db    0
.rdata$r:00003497                 db    0
.rdata$r:00003498                 db    0
.rdata$r:00003499                 db    0
.rdata$r:0000349A                 db    0
.rdata$r:0000349B                 db    0
.rdata$r:0000349C                 db    0
.rdata$r:0000349D                 db    0
.rdata$r:0000349E                 db    0
.rdata$r:0000349F                 db    0
.rdata$r:000034A0                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000034A4                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000034A4 _rdata$r        ends
.rdata$r:000034A4
.data$r:000034A8 ; ===========================================================================
.data$r:000034A8
.data$r:000034A8 ; Segment type: Pure data
.data$r:000034A8 ; Segment permissions: Read/Write
.data$r:000034A8 _data$r         segment dword public 'DATA' use32
.data$r:000034A8                 assume cs:_data$r
.data$r:000034A8                 ;org 34A8h
.data$r:000034A8 ; COMDAT (pick any)
.data$r:000034A8                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:000034A8 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:000034A8 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000034A8                                         ; DATA XREF: .rdata$r:000034A0o
.data$r:000034A8                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000034A8                                         ; const type_info::`vftable'
.data$r:000034AC                 align 10h
.data$r:000034B0 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:000034D3                 align 4
.data$r:000034D3 _data$r         ends
.data$r:000034D3
.rdata$r:000034D4 ; ===========================================================================
.rdata$r:000034D4
.rdata$r:000034D4 ; Segment type: Pure data
.rdata$r:000034D4 ; Segment permissions: Read
.rdata$r:000034D4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034D4                 assume cs:_rdata$r
.rdata$r:000034D4                 ;org 34D4h
.rdata$r:000034D4 ; COMDAT (pick any)
.rdata$r:000034D4                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000034D4 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000034D4 ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000034D4                                         ; DATA XREF: .rdata$r:000034A4o
.rdata$r:000034D4                                         ; .rdata$r:0000350Co
.rdata$r:000034D5                 db    0
.rdata$r:000034D6                 db    0
.rdata$r:000034D7                 db    0
.rdata$r:000034D8                 db    0
.rdata$r:000034D9                 db    0
.rdata$r:000034DA                 db    0
.rdata$r:000034DB                 db    0
.rdata$r:000034DC                 db    3
.rdata$r:000034DD                 db    0
.rdata$r:000034DE                 db    0
.rdata$r:000034DF                 db    0
.rdata$r:000034E0                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000034E0 _rdata$r        ends
.rdata$r:000034E0
.rdata$r:000034E4 ; ===========================================================================
.rdata$r:000034E4
.rdata$r:000034E4 ; Segment type: Pure data
.rdata$r:000034E4 ; Segment permissions: Read
.rdata$r:000034E4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034E4                 assume cs:_rdata$r
.rdata$r:000034E4                 ;org 34E4h
.rdata$r:000034E4 ; COMDAT (pick any)
.rdata$r:000034E4                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000034E4 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000034E4 ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000034E4                                         ; DATA XREF: .rdata$r:000034E0o
.rdata$r:000034E4                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034E8                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034EC                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000034F0                 db    0
.rdata$r:000034F1                 align 4
.rdata$r:000034F1 _rdata$r        ends
.rdata$r:000034F1
.rdata$r:000034F4 ; ===========================================================================
.rdata$r:000034F4
.rdata$r:000034F4 ; Segment type: Pure data
.rdata$r:000034F4 ; Segment permissions: Read
.rdata$r:000034F4 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000034F4                 assume cs:_rdata$r
.rdata$r:000034F4                 ;org 34F4h
.rdata$r:000034F4 ; COMDAT (pick any)
.rdata$r:000034F4                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000034F4 ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000034F4 ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000034F4                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000034F4                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000034F8                 db    2
.rdata$r:000034F9                 db    0
.rdata$r:000034FA                 db    0
.rdata$r:000034FB                 db    0
.rdata$r:000034FC                 db    0
.rdata$r:000034FD                 db    0
.rdata$r:000034FE                 db    0
.rdata$r:000034FF                 db    0
.rdata$r:00003500                 db 0FFh
.rdata$r:00003501                 db 0FFh
.rdata$r:00003502                 db 0FFh
.rdata$r:00003503                 db 0FFh
.rdata$r:00003504                 db    0
.rdata$r:00003505                 db    0
.rdata$r:00003506                 db    0
.rdata$r:00003507                 db    0
.rdata$r:00003508                 db  40h ; @
.rdata$r:00003509                 db    0
.rdata$r:0000350A                 db    0
.rdata$r:0000350B                 db    0
.rdata$r:0000350C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000350C _rdata$r        ends
.rdata$r:0000350C
.rdata$r:00003510 ; ===========================================================================
.rdata$r:00003510
.rdata$r:00003510 ; Segment type: Pure data
.rdata$r:00003510 ; Segment permissions: Read
.rdata$r:00003510 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003510                 assume cs:_rdata$r
.rdata$r:00003510                 ;org 3510h
.rdata$r:00003510 ; COMDAT (pick any)
.rdata$r:00003510                 public ??_R4_System_error_category@std@@6B@
.rdata$r:00003510 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:00003510 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:0000328Co
.rdata$r:00003511                 db    0
.rdata$r:00003512                 db    0
.rdata$r:00003513                 db    0
.rdata$r:00003514                 db    0
.rdata$r:00003515                 db    0
.rdata$r:00003516                 db    0
.rdata$r:00003517                 db    0
.rdata$r:00003518                 db    0
.rdata$r:00003519                 db    0
.rdata$r:0000351A                 db    0
.rdata$r:0000351B                 db    0
.rdata$r:0000351C                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003520                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003520 _rdata$r        ends
.rdata$r:00003520
.data$r:00003524 ; ===========================================================================
.data$r:00003524
.data$r:00003524 ; Segment type: Pure data
.data$r:00003524 ; Segment permissions: Read/Write
.data$r:00003524 _data$r         segment dword public 'DATA' use32
.data$r:00003524                 assume cs:_data$r
.data$r:00003524                 ;org 3524h
.data$r:00003524 ; COMDAT (pick any)
.data$r:00003524                 public ??_R0?AV_System_error_category@std@@@8
.data$r:00003524 ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:00003524 ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00003524                                         ; DATA XREF: .rdata$r:0000351Co
.data$r:00003524                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00003524                                         ; const type_info::`vftable'
.data$r:00003528                 db    0
.data$r:00003529                 db    0
.data$r:0000352A                 db    0
.data$r:0000352B                 db    0
.data$r:0000352C                 db  2Eh ; .
.data$r:0000352D                 db  3Fh ; ?
.data$r:0000352E                 db  41h ; A
.data$r:0000352F                 db  56h ; V
.data$r:00003530                 db  5Fh ; _
.data$r:00003531                 db  53h ; S
.data$r:00003532                 db  79h ; y
.data$r:00003533                 db  73h ; s
.data$r:00003534                 db  74h ; t
.data$r:00003535                 db  65h ; e
.data$r:00003536                 db  6Dh ; m
.data$r:00003537                 db  5Fh ; _
.data$r:00003538                 db  65h ; e
.data$r:00003539                 db  72h ; r
.data$r:0000353A                 db  72h ; r
.data$r:0000353B                 db  6Fh ; o
.data$r:0000353C                 db  72h ; r
.data$r:0000353D                 db  5Fh ; _
.data$r:0000353E                 db  63h ; c
.data$r:0000353F                 db  61h ; a
.data$r:00003540                 db  74h ; t
.data$r:00003541                 db  65h ; e
.data$r:00003542                 db  67h ; g
.data$r:00003543                 db  6Fh ; o
.data$r:00003544                 db  72h ; r
.data$r:00003545                 db  79h ; y
.data$r:00003546                 db  40h ; @
.data$r:00003547                 db  73h ; s
.data$r:00003548                 db  74h ; t
.data$r:00003549                 db  64h ; d
.data$r:0000354A                 db  40h ; @
.data$r:0000354B                 db  40h ; @
.data$r:0000354C                 db    0
.data$r:0000354D                 align 10h
.data$r:0000354D _data$r         ends
.data$r:0000354D
.rdata$r:00003550 ; ===========================================================================
.rdata$r:00003550
.rdata$r:00003550 ; Segment type: Pure data
.rdata$r:00003550 ; Segment permissions: Read
.rdata$r:00003550 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003550                 assume cs:_rdata$r
.rdata$r:00003550                 ;org 3550h
.rdata$r:00003550 ; COMDAT (pick any)
.rdata$r:00003550                 public ??_R3_System_error_category@std@@8
.rdata$r:00003550 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003550 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00003520o
.rdata$r:00003550                                         ; .rdata$r:00003588o
.rdata$r:00003551                 db    0
.rdata$r:00003552                 db    0
.rdata$r:00003553                 db    0
.rdata$r:00003554                 db    0
.rdata$r:00003555                 db    0
.rdata$r:00003556                 db    0
.rdata$r:00003557                 db    0
.rdata$r:00003558                 db    3
.rdata$r:00003559                 db    0
.rdata$r:0000355A                 db    0
.rdata$r:0000355B                 db    0
.rdata$r:0000355C                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:0000355C _rdata$r        ends
.rdata$r:0000355C
.rdata$r:00003560 ; ===========================================================================
.rdata$r:00003560
.rdata$r:00003560 ; Segment type: Pure data
.rdata$r:00003560 ; Segment permissions: Read
.rdata$r:00003560 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003560                 assume cs:_rdata$r
.rdata$r:00003560                 ;org 3560h
.rdata$r:00003560 ; COMDAT (pick any)
.rdata$r:00003560                 public ??_R2_System_error_category@std@@8
.rdata$r:00003560 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00003560 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003560                                         ; DATA XREF: .rdata$r:0000355Co
.rdata$r:00003560                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003564                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00003568                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000356C                 db    0
.rdata$r:0000356D                 align 10h
.rdata$r:0000356D _rdata$r        ends
.rdata$r:0000356D
.rdata$r:00003570 ; ===========================================================================
.rdata$r:00003570
.rdata$r:00003570 ; Segment type: Pure data
.rdata$r:00003570 ; Segment permissions: Read
.rdata$r:00003570 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00003570                 assume cs:_rdata$r
.rdata$r:00003570                 ;org 3570h
.rdata$r:00003570 ; COMDAT (pick any)
.rdata$r:00003570                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00003570 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00003570 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00003570                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00003570                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00003574                 db    2
.rdata$r:00003575                 db    0
.rdata$r:00003576                 db    0
.rdata$r:00003577                 db    0
.rdata$r:00003578                 db    0
.rdata$r:00003579                 db    0
.rdata$r:0000357A                 db    0
.rdata$r:0000357B                 db    0
.rdata$r:0000357C                 db 0FFh
.rdata$r:0000357D                 db 0FFh
.rdata$r:0000357E                 db 0FFh
.rdata$r:0000357F                 db 0FFh
.rdata$r:00003580                 db    0
.rdata$r:00003581                 db    0
.rdata$r:00003582                 db    0
.rdata$r:00003583                 db    0
.rdata$r:00003584                 db  40h ; @
.rdata$r:00003585                 db    0
.rdata$r:00003586                 db    0
.rdata$r:00003587                 db    0
.rdata$r:00003588                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00003588 _rdata$r        ends
.rdata$r:00003588
.CRT$XCU:0000358C ; ===========================================================================
.CRT$XCU:0000358C
.CRT$XCU:0000358C ; Segment type: Pure data
.CRT$XCU:0000358C ; Segment permissions: Read
.CRT$XCU:0000358C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000358C                 assume cs:_CRT$XCU
.CRT$XCU:0000358C                 ;org 358Ch
.CRT$XCU:0000358C _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00003590 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00003594 _ignore$initializer$ dd offset ??__Eignore@std@@YAXXZ ; std::`dynamic initializer for 'ignore''(void)
.CRT$XCU:00003598 __Tuple_alloc$initializer$ dd offset ??__E_Tuple_alloc@std@@YAXXZ ; std::`dynamic initializer for '_Tuple_alloc''(void)
.CRT$XCU:00003598 _CRT$XCU        ends
.CRT$XCU:00003598
.CRT$XCU:0000359C ; ===========================================================================
.CRT$XCU:0000359C
.CRT$XCU:0000359C ; Segment type: Pure data
.CRT$XCU:0000359C ; Segment permissions: Read
.CRT$XCU:0000359C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000359C                 assume cs:_CRT$XCU
.CRT$XCU:0000359C                 ;org 359Ch
.CRT$XCU:0000359C ; COMDAT (pick associative to section at 32B0)
.CRT$XCU:0000359C ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000359C ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000359C _CRT$XCU        ends
.CRT$XCU:0000359C
.CRT$XCU:000035A0 ; ===========================================================================
.CRT$XCU:000035A0
.CRT$XCU:000035A0 ; Segment type: Pure data
.CRT$XCU:000035A0 ; Segment permissions: Read
.CRT$XCU:000035A0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035A0                 assume cs:_CRT$XCU
.CRT$XCU:000035A0                 ;org 35A0h
.CRT$XCU:000035A0 ; COMDAT (pick associative to section at 32B4)
.CRT$XCU:000035A0 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:000035A0 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:000035A0 _CRT$XCU        ends
.CRT$XCU:000035A0
.CRT$XCU:000035A4 ; ===========================================================================
.CRT$XCU:000035A4
.CRT$XCU:000035A4 ; Segment type: Pure data
.CRT$XCU:000035A4 ; Segment permissions: Read
.CRT$XCU:000035A4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035A4                 assume cs:_CRT$XCU
.CRT$XCU:000035A4                 ;org 35A4h
.CRT$XCU:000035A4 ; COMDAT (pick associative to section at 32B8)
.CRT$XCU:000035A4 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:000035A4 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:000035A4 _CRT$XCU        ends
.CRT$XCU:000035A4
.CRT$XCU:000035A8 ; ===========================================================================
.CRT$XCU:000035A8
.CRT$XCU:000035A8 ; Segment type: Pure data
.CRT$XCU:000035A8 ; Segment permissions: Read
.CRT$XCU:000035A8 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035A8                 assume cs:_CRT$XCU
.CRT$XCU:000035A8                 ;org 35A8h
.CRT$XCU:000035A8 ; COMDAT (pick associative to section at 32BC)
.CRT$XCU:000035A8 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:000035A8 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:000035A8 _CRT$XCU        ends
.CRT$XCU:000035A8
.CRT$XCU:000035AC ; ===========================================================================
.CRT$XCU:000035AC
.CRT$XCU:000035AC ; Segment type: Pure data
.CRT$XCU:000035AC ; Segment permissions: Read
.CRT$XCU:000035AC _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035AC                 assume cs:_CRT$XCU
.CRT$XCU:000035AC                 ;org 35ACh
.CRT$XCU:000035AC ; COMDAT (pick associative to section at 32C0)
.CRT$XCU:000035AC ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:000035AC ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:000035AC _CRT$XCU        ends
.CRT$XCU:000035AC
.CRT$XCU:000035B0 ; ===========================================================================
.CRT$XCU:000035B0
.CRT$XCU:000035B0 ; Segment type: Pure data
.CRT$XCU:000035B0 ; Segment permissions: Read
.CRT$XCU:000035B0 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035B0                 assume cs:_CRT$XCU
.CRT$XCU:000035B0                 ;org 35B0h
.CRT$XCU:000035B0 ; COMDAT (pick associative to section at 3354)
.CRT$XCU:000035B0 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:000035B0 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:000035B0 _CRT$XCU        ends
.CRT$XCU:000035B0
.CRT$XCU:000035B4 ; ===========================================================================
.CRT$XCU:000035B4
.CRT$XCU:000035B4 ; Segment type: Pure data
.CRT$XCU:000035B4 ; Segment permissions: Read
.CRT$XCU:000035B4 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:000035B4                 assume cs:_CRT$XCU
.CRT$XCU:000035B4                 ;org 35B4h
.CRT$XCU:000035B4 ; COMDAT (pick associative to section at 3358)
.CRT$XCU:000035B4 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:000035B4 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:000035B4 _CRT$XCU        ends
.CRT$XCU:000035B4
UNDEF:000035C0 ; ===========================================================================
UNDEF:000035C0
UNDEF:000035C0 ; Segment type: Externs
UNDEF:000035C0 ; UNDEF
UNDEF:000035C0                 extrn __purecall:near   ; DATA XREF: .rdata:00003204o
UNDEF:000035C0                                         ; .rdata:00003208o
UNDEF:000035C4 ; void *__cdecl operator new(unsigned int)
UNDEF:000035C4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000035C4                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+23p
UNDEF:000035C8 ; void __cdecl operator delete(void *)
UNDEF:000035C8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp
UNDEF:000035C8                                         ; std::_Iostream_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000035CC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000035CC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000035CC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000035D0 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000035D0                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000035D4 ; size_t __cdecl strlen(const char *Str)
UNDEF:000035D4                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000035D8 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000035D8                 extrn _memmove:near     ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000035DC ; int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2)
UNDEF:000035DC                 extrn __imp__lstrcmpW@8:near
UNDEF:000035DC                                         ; CODE XREF: DocTabView::findBufferByName(wchar_t const *)+74p
UNDEF:000035DC                                         ; DATA XREF: DocTabView::findBufferByName(wchar_t const *)+74r
UNDEF:000035E0 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000035E0                 extrn __imp__SendMessageW@16:near
UNDEF:000035E0                                         ; CODE XREF: DocTabView::addBuffer(Buffer *)+A0p
UNDEF:000035E0                                         ; DocTabView::addBuffer(Buffer *)+C4p ...
UNDEF:000035E4 ; void __thiscall TabBar::reSizeTo(TabBar *__hidden this, struct tagRECT *)
UNDEF:000035E4                 extrn ?reSizeTo@TabBar@@UAEXAAUtagRECT@@@Z:near
UNDEF:000035E4                                         ; CODE XREF: DocTabView::reSizeTo(tagRECT &)+51p
UNDEF:000035E4                                         ; DocTabView::reSizeTo(tagRECT &)+76p
UNDEF:000035E8 ; void __thiscall TabBar::activateAt(TabBar *__hidden this, int)
UNDEF:000035E8                 extrn ?activateAt@TabBar@@QBEXH@Z:near
UNDEF:000035E8                                         ; CODE XREF: DocTabView::activateBuffer(Buffer *)+29p
UNDEF:000035EC ; void __thiscall TabBar::deletItemAt(TabBar *__hidden this, unsigned int)
UNDEF:000035EC                 extrn ?deletItemAt@TabBar@@QAEXI@Z:near
UNDEF:000035EC                                         ; CODE XREF: DocTabView::closeBuffer(Buffer *)+1Fp
UNDEF:000035F0 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:000035F0                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:000035F0                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+35p
UNDEF:000035F4 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:000035F4                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:000035F4                                         ; CODE XREF: std::_Container_base12::_Orphan_all(void)+86p
UNDEF:000035F4                                         ; __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0+3j
UNDEF:000035F8                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:000035FC ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:000035FC                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:000035FC                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00003600 ; void __cdecl std::_Xbad_alloc()
UNDEF:00003600                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00003600                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_13FAp
UNDEF:00003600                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *):loc_143Cp
UNDEF:00003604 ; void __cdecl std::_Xlength_error(const char *)
UNDEF:00003604                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:00003604                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:00003608 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00003608                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00003608                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:0000360C ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000360C                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000360C                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:00003610 ; const char *__cdecl std::_Syserror_map(int)
UNDEF:00003610                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:00003610                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:00003610                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:00003614 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:00003614                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:00003614                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:00003618 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003618                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003618                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:0000361C ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:0000361C                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:0000361C                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:00003620 ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:00003620                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00003620                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:00003624 ; __fastcall __security_check_cookie(x)
UNDEF:00003624                 extrn @__security_check_cookie@4:near
UNDEF:00003624                                         ; CODE XREF: DocTabView::bufferUpdated(Buffer *,int)+221p
UNDEF:00003624                                         ; DocTabView::reSizeTo(tagRECT &)+D9p ...
UNDEF:00003628 ; __stdcall _CxxThrowException(x, x)
UNDEF:00003628                 extrn __CxxThrowException@8:near
UNDEF:00003628                                         ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1+10p
UNDEF:0000362C                 extrn ___CxxFrameHandler3:near
UNDEF:0000362C                                         ; CODE XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+16j
UNDEF:0000362C                                         ; __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+16j ...
UNDEF:00003630 ; const type_info::`vftable'
UNDEF:00003630                 extrn ??_7type_info@@6B@:near
UNDEF:00003630                                         ; DATA XREF: .data$r:std::error_category `RTTI Type Descriptor'o
UNDEF:00003630                                         ; .data$r:std::_Generic_error_category `RTTI Type Descriptor'o ...
UNDEF:00003634 ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:00003634                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:00003634                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:00003638 ; private: static class FileManager * FileManager::_pSelf
UNDEF:00003638                 extrn ?_pSelf@FileManager@@0PAV1@A:near
UNDEF:00003638                                         ; DATA XREF: FileManager::getInstance(void)+3r
UNDEF:0000363C                 extrn ___security_cookie:near
UNDEF:0000363C                                         ; DATA XREF: DocTabView::bufferUpdated(Buffer *,int)+9r
UNDEF:0000363C                                         ; DocTabView::reSizeTo(tagRECT &)+6r ...
UNDEF:00003640                 extrn __fltused:near
UNDEF:00003640
UNDEF:00003640
UNDEF:00003640                 end