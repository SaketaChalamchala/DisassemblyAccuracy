.rdata:00000000 ;
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ; |   This file has been generated by The Interactive Disassembler (IDA)    |
.rdata:00000000 ; |           Copyright (c) 2015 Hex-Rays, <support@hex-rays.com>           |
.rdata:00000000 ; |                      License info: 48-3677-7074-51                      |
.rdata:00000000 ; |             Michalis Polychronakis, Stony Brook University              |
.rdata:00000000 ; +-------------------------------------------------------------------------+
.rdata:00000000 ;
.rdata:00000000 ; Input MD5   : 52FDC35F83DE9ECE35DEC447F047B49F
.rdata:00000000 ; Input CRC32 : ED7D7A03
.rdata:00000000
.rdata:00000000 ; File Name   : C:\workspace\notepad-plus-plus-6.7.9.2\PowerEditor\visual.net\Unicode Debug\Gripper.obj
.rdata:00000000 ; Format      : COFF (X386MAGIC)
.rdata:00000000 ; includelib "uuid.lib"
.rdata:00000000 ; includelib "libcpmtd"
.rdata:00000000 ; must resolve: ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.rdata:00000000 ; must resolve: ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.rdata:00000000 ; must resolve: ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@D@std@@2V0locale@2@A
.rdata:00000000 ; must resolve: ?id@?$numpunct@_W@std@@2V0locale@2@A
.rdata:00000000 ; includelib "LIBCMTD"
.rdata:00000000 ; includelib "OLDNAMES"
.rdata:00000000
.rdata:00000000                 include uni.inc ; see unicode subdir of ida for info on unicode
.rdata:00000000
.rdata:00000000                 .686p
.rdata:00000000                 .mmx
.rdata:00000000                 .model flat
.rdata:00000000
.rdata:00000000 ; ===========================================================================
.rdata:00000000
.rdata:00000000 ; Segment type: Pure data
.rdata:00000000 ; Segment permissions: Read
.rdata:00000000 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00000000 _rdata          segment para public 'DATA' use32
.rdata:00000000                 assume cs:_rdata
.rdata:00000000 $SG125965:                              ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+83o
.rdata:00000000                 unicode 0, <moveDlg>,0
.rdata:00000010 ; char _SG125969[]
.rdata:00000010 $SG125969       db 'Gripper::startGrip : RegisterClass() function failed',0
.rdata:00000010                                         ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+9Bo
.rdata:00000045                 align 4
.rdata:00000048 ; const WCHAR _SG125975
.rdata:00000048 $SG125975       dw 0                    ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+E4o
.rdata:0000004A                 align 4
.rdata:0000004C ; const WCHAR _SG125976
.rdata:0000004C $SG125976:                              ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+E9o
.rdata:0000004C                 unicode 0, <moveDlg>,0
.rdata:0000005C ; char _SG125980[]
.rdata:0000005C $SG125980       db 'Gripper::startGrip : CreateWindowEx() function return null',0
.rdata:0000005C                                         ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+111o
.rdata:00000097                 align 4
.rdata:00000098 ; const WCHAR _SG126036
.rdata:00000098 $SG126036:                              ; DATA XREF: Gripper::create(void)+C5o
.rdata:00000098                 unicode 0, <GetLastError() returned %lu>,0
.rdata:000000D0 ; const WCHAR _SG126037
.rdata:000000D0 $SG126037:                              ; DATA XREF: Gripper::create(void)+DCo
.rdata:000000D0                 unicode 0, <SetWindowsHookEx(MOUSE) failed on Gripper::create()>,0
.rdata:00000138 ; const WCHAR _SG126075
.rdata:00000138 $SG126075:                              ; DATA XREF: Gripper::create(void)+13Bo
.rdata:00000138                 unicode 0, <GetLastError() returned %lu>,0
.rdata:00000170 ; const WCHAR _SG126076
.rdata:00000170 $SG126076:                              ; DATA XREF: Gripper::create(void)+152o
.rdata:00000170                 unicode 0, <SetWindowsHookEx(KEYBOARD) failed on Gripper::create()>,0
.rdata:000001DE                 align 10h
.rdata:000001E0 _DotPattern:                            ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+BAo
.rdata:000001E0                 unicode 0, <ªUªUªUªU>
.rdata:000001E0 _rdata          ends
.rdata:000001E0
.bss:000001F0 ; ===========================================================================
.bss:000001F0
.bss:000001F0 ; Segment type: Uninitialized
.bss:000001F0 ; Segment permissions: Read/Write
.bss:000001F0 _bss            segment dword public 'BSS' use32
.bss:000001F0                 assume cs:_bss
.bss:000001F0                 ;org 1F0h
.bss:000001F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:000001F0                 public ?_isRegistered@Gripper@@0HA
.bss:000001F0 ; private: static int Gripper::_isRegistered
.bss:000001F0 ?_isRegistered@Gripper@@0HA dd ?        ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+2Dr
.bss:000001F0                                         ; Gripper::startGrip(DockingCont *,DockingManager *):loc_3DAw
.bss:000001F4 ; HWND hWndServer
.bss:000001F4 _hWndServer     dd ?                    ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+102w
.bss:000001F4                                         ; hookProcMouse(int,uint,long)+49r ...
.bss:000001F8 ; HHOOK hookMouse
.bss:000001F8 _hookMouse      dd ?                    ; DATA XREF: Gripper::create(void)+A4w
.bss:000001F8                                         ; Gripper::create(void)+A9r ...
.bss:000001FC ; HHOOK hookKeyboard
.bss:000001FC _hookKeyboard   dd ?                    ; DATA XREF: Gripper::create(void)+11Aw
.bss:000001FC                                         ; Gripper::create(void)+11Fr ...
.bss:00000200 _allocator_arg  db    ? ;
.bss:00000201 _piecewise_construct db    ? ;
.bss:00000202                 align 4
.bss:00000202 _bss            ends
.bss:00000202
.text$mn:00000204 ; ===========================================================================
.text$mn:00000204
.text$mn:00000204 ; Segment type: Pure code
.text$mn:00000204 ; Segment permissions: Read/Execute
.text$mn:00000204 _text$mn        segment para public 'CODE' use32
.text$mn:00000204                 assume cs:_text$mn
.text$mn:00000204                 ;org 204h
.text$mn:00000204                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00000204
.text$mn:00000204 ; =============== S U B R O U T I N E =======================================
.text$mn:00000204
.text$mn:00000204 ; Attributes: bp-based frame
.text$mn:00000204
.text$mn:00000204 ; _DWORD __thiscall Gripper::Gripper(Gripper *__hidden this)
.text$mn:00000204                 public ??0Gripper@@QAE@XZ
.text$mn:00000204 ??0Gripper@@QAE@XZ proc near
.text$mn:00000204
.text$mn:00000204 var_4           = dword ptr -4
.text$mn:00000204
.text$mn:00000204                 push    ebp
.text$mn:00000205                 mov     ebp, esp
.text$mn:00000207                 push    ecx
.text$mn:00000208                 mov     [ebp+var_4], ecx
.text$mn:0000020B                 mov     eax, [ebp+var_4]
.text$mn:0000020E                 mov     dword ptr [eax], 0
.text$mn:00000214                 mov     ecx, [ebp+var_4]
.text$mn:00000217                 mov     dword ptr [ecx+4], 0
.text$mn:0000021E                 mov     edx, [ebp+var_4]
.text$mn:00000221                 mov     dword ptr [edx+8], 0
.text$mn:00000228                 mov     eax, [ebp+var_4]
.text$mn:0000022B                 mov     dword ptr [eax+50h], 0
.text$mn:00000232                 mov     ecx, [ebp+var_4]
.text$mn:00000235                 mov     dword ptr [ecx+54h], 0
.text$mn:0000023C                 mov     edx, [ebp+var_4]
.text$mn:0000023F                 mov     dword ptr [edx+58h], 0
.text$mn:00000246                 mov     eax, [ebp+var_4]
.text$mn:00000249                 mov     dword ptr [eax+5Ch], 0
.text$mn:00000250                 mov     ecx, [ebp+var_4]
.text$mn:00000253                 mov     dword ptr [ecx+60h], 0
.text$mn:0000025A                 mov     edx, [ebp+var_4]
.text$mn:0000025D                 mov     dword ptr [edx+64h], 0
.text$mn:00000264                 mov     eax, [ebp+var_4]
.text$mn:00000267                 mov     dword ptr [eax+68h], 0
.text$mn:0000026E                 mov     ecx, [ebp+var_4]
.text$mn:00000271                 mov     dword ptr [ecx+7Ch], 0
.text$mn:00000278                 mov     edx, [ebp+var_4]
.text$mn:0000027B                 mov     dword ptr [edx+80h], 0
.text$mn:00000285                 mov     eax, [ebp+var_4]
.text$mn:00000288                 mov     dword ptr [eax+84h], 0
.text$mn:00000292                 mov     ecx, [ebp+var_4]
.text$mn:00000295                 mov     dword ptr [ecx+88h], 0
.text$mn:0000029F                 mov     edx, [ebp+var_4]
.text$mn:000002A2                 mov     dword ptr [edx+0B8h], 0
.text$mn:000002AC                 mov     eax, [ebp+var_4]
.text$mn:000002AF                 mov     dword ptr [eax+0BCh], 0
.text$mn:000002B9                 mov     ecx, [ebp+var_4]
.text$mn:000002BC                 mov     dword ptr [ecx+0C0h], 0
.text$mn:000002C6                 push    10h             ; Size
.text$mn:000002C8                 push    0               ; Val
.text$mn:000002CA                 mov     edx, [ebp+var_4]
.text$mn:000002CD                 add     edx, 6Ch ; 'l'
.text$mn:000002D0                 push    edx             ; Dst
.text$mn:000002D1                 call    _memset
.text$mn:000002D6                 add     esp, 0Ch
.text$mn:000002D9                 push    10h             ; Size
.text$mn:000002DB                 push    0               ; Val
.text$mn:000002DD                 mov     eax, [ebp+var_4]
.text$mn:000002E0                 add     eax, 8Ch ; 'î'
.text$mn:000002E5                 push    eax             ; Dst
.text$mn:000002E6                 call    _memset
.text$mn:000002EB                 add     esp, 0Ch
.text$mn:000002EE                 push    1Ch             ; Size
.text$mn:000002F0                 push    0               ; Val
.text$mn:000002F2                 mov     ecx, [ebp+var_4]
.text$mn:000002F5                 add     ecx, 9Ch ; '£'
.text$mn:000002FB                 push    ecx             ; Dst
.text$mn:000002FC                 call    _memset
.text$mn:00000301                 add     esp, 0Ch
.text$mn:00000304                 push    44h ; 'D'       ; Size
.text$mn:00000306                 push    0               ; Val
.text$mn:00000308                 mov     edx, [ebp+var_4]
.text$mn:0000030B                 add     edx, 0Ch
.text$mn:0000030E                 push    edx             ; Dst
.text$mn:0000030F                 call    _memset
.text$mn:00000314                 add     esp, 0Ch
.text$mn:00000317                 mov     eax, [ebp+var_4]
.text$mn:0000031A                 mov     esp, ebp
.text$mn:0000031C                 pop     ebp
.text$mn:0000031D                 retn
.text$mn:0000031D ??0Gripper@@QAE@XZ endp
.text$mn:0000031D
.text$mn:0000031D ; ---------------------------------------------------------------------------
.text$mn:0000031E                 db 6 dup(0CCh)
.text$mn:00000324
.text$mn:00000324 ; =============== S U B R O U T I N E =======================================
.text$mn:00000324
.text$mn:00000324 ; Attributes: bp-based frame
.text$mn:00000324
.text$mn:00000324 ; void __thiscall Gripper::startGrip(Gripper *this, struct DockingCont *, struct DockingManager *)
.text$mn:00000324                 public ?startGrip@Gripper@@QAEXPAVDockingCont@@PAVDockingManager@@@Z
.text$mn:00000324 ?startGrip@Gripper@@QAEXPAVDockingCont@@PAVDockingManager@@@Z proc near
.text$mn:00000324
.text$mn:00000324 WndClass        = WNDCLASSW ptr -44h
.text$mn:00000324 var_1C          = byte ptr -1Ch
.text$mn:00000324 var_10          = byte ptr -10h
.text$mn:00000324 lpParam         = dword ptr -4
.text$mn:00000324 arg_0           = dword ptr  8
.text$mn:00000324 arg_4           = dword ptr  0Ch
.text$mn:00000324
.text$mn:00000324                 push    ebp
.text$mn:00000325                 mov     ebp, esp
.text$mn:00000327                 sub     esp, 44h
.text$mn:0000032A                 mov     [ebp+lpParam], ecx
.text$mn:0000032D                 mov     eax, [ebp+lpParam]
.text$mn:00000330                 mov     ecx, [ebp+arg_4]
.text$mn:00000333                 mov     [eax+50h], ecx
.text$mn:00000336                 mov     edx, [ebp+lpParam]
.text$mn:00000339                 mov     eax, [ebp+arg_0]
.text$mn:0000033C                 mov     [edx+54h], eax
.text$mn:0000033F                 mov     ecx, [ebp+lpParam]
.text$mn:00000342                 add     ecx, 0Ch
.text$mn:00000345                 push    ecx             ; struct tDockMgr *
.text$mn:00000346                 mov     edx, [ebp+lpParam]
.text$mn:00000349                 mov     ecx, [edx+50h]  ; this
.text$mn:0000034C                 call    ?getDockInfo@DockingManager@@QAEXPAUtDockMgr@@@Z ; DockingManager::getDockInfo(tDockMgr *)
.text$mn:00000351                 cmp     ds:?_isRegistered@Gripper@@0HA, 0 ; int Gripper::_isRegistered
.text$mn:00000358                 jnz     loc_3E4
.text$mn:0000035E                 mov     [ebp+WndClass.style], 0
.text$mn:00000365                 mov     [ebp+WndClass.lpfnWndProc], offset ?staticWinProc@Gripper@@KGJPAUHWND__@@IIJ@Z ; Gripper::staticWinProc(HWND__ *,uint,uint,long)
.text$mn:0000036C                 mov     [ebp+WndClass.cbClsExtra], 0
.text$mn:00000373                 mov     [ebp+WndClass.cbWndExtra], 0
.text$mn:0000037A                 mov     eax, [ebp+lpParam]
.text$mn:0000037D                 mov     ecx, [eax]
.text$mn:0000037F                 mov     [ebp+WndClass.hInstance], ecx
.text$mn:00000382                 mov     [ebp+WndClass.hIcon], 0
.text$mn:00000389                 push    7F00h           ; lpCursorName
.text$mn:0000038E                 push    0               ; hInstance
.text$mn:00000390                 call    dword ptr ds:__imp__LoadCursorW@8 ; LoadCursorW(x,x)
.text$mn:00000396                 mov     [ebp+WndClass.hCursor], eax
.text$mn:00000399                 mov     [ebp+WndClass.hbrBackground], 0
.text$mn:000003A0                 mov     [ebp+WndClass.lpszMenuName], 0
.text$mn:000003A7                 mov     [ebp+WndClass.lpszClassName], offset $SG125965 ; "moveDlg"
.text$mn:000003AE                 lea     edx, [ebp+WndClass]
.text$mn:000003B1                 push    edx             ; lpWndClass
.text$mn:000003B2                 call    dword ptr ds:__imp__RegisterClassW@4 ; RegisterClassW(x)
.text$mn:000003B8                 movzx   eax, ax
.text$mn:000003BB                 test    eax, eax
.text$mn:000003BD                 jnz     short loc_3DA
.text$mn:000003BF                 push    offset $SG125969 ; "Gripper::startGrip : RegisterClass() fu"...
.text$mn:000003C4                 lea     ecx, [ebp+var_10] ; this
.text$mn:000003C7                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:000003CC                 push    offset __TI2?AVruntime_error@std@@
.text$mn:000003D1                 lea     ecx, [ebp+var_10]
.text$mn:000003D4                 push    ecx
.text$mn:000003D5                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:000003DA ; ---------------------------------------------------------------------------
.text$mn:000003DA
.text$mn:000003DA loc_3DA:                                ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+99j
.text$mn:000003DA                 mov     ds:?_isRegistered@Gripper@@0HA, 1 ; int Gripper::_isRegistered
.text$mn:000003E4
.text$mn:000003E4 loc_3E4:                                ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+34j
.text$mn:000003E4                 mov     edx, [ebp+lpParam]
.text$mn:000003E7                 push    edx             ; lpParam
.text$mn:000003E8                 mov     eax, [ebp+lpParam]
.text$mn:000003EB                 mov     ecx, [eax]
.text$mn:000003ED                 push    ecx             ; hInstance
.text$mn:000003EE                 push    0               ; hMenu
.text$mn:000003F0                 push    0               ; hWndParent
.text$mn:000003F2                 push    80000000h       ; nHeight
.text$mn:000003F7                 push    80000000h       ; nWidth
.text$mn:000003FC                 push    80000000h       ; Y
.text$mn:00000401                 push    80000000h       ; X
.text$mn:00000406                 push    0               ; dwStyle
.text$mn:00000408                 push    offset $SG125975 ; lpWindowName
.text$mn:0000040D                 push    offset $SG125976 ; "moveDlg"
.text$mn:00000412                 push    0               ; dwExStyle
.text$mn:00000414                 call    dword ptr ds:__imp__CreateWindowExW@48 ; CreateWindowExW(x,x,x,x,x,x,x,x,x,x,x,x)
.text$mn:0000041A                 mov     edx, [ebp+lpParam]
.text$mn:0000041D                 mov     [edx+8], eax
.text$mn:00000420                 mov     eax, [ebp+lpParam]
.text$mn:00000423                 mov     ecx, [eax+8]
.text$mn:00000426                 mov     ds:_hWndServer, ecx
.text$mn:0000042C                 mov     edx, [ebp+lpParam]
.text$mn:0000042F                 cmp     dword ptr [edx+8], 0
.text$mn:00000433                 jnz     short loc_450
.text$mn:00000435                 push    offset $SG125980 ; "Gripper::startGrip : CreateWindowEx() f"...
.text$mn:0000043A                 lea     ecx, [ebp+var_1C] ; this
.text$mn:0000043D                 call    ??0runtime_error@std@@QAE@PBD@Z ; std::runtime_error::runtime_error(char const *)
.text$mn:00000442                 push    offset __TI2?AVruntime_error@std@@
.text$mn:00000447                 lea     eax, [ebp+var_1C]
.text$mn:0000044A                 push    eax
.text$mn:0000044B                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00000450 ; ---------------------------------------------------------------------------
.text$mn:00000450
.text$mn:00000450 loc_450:                                ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+10Fj
.text$mn:00000450                 mov     esp, ebp
.text$mn:00000452                 pop     ebp
.text$mn:00000453                 retn    8
.text$mn:00000453 ?startGrip@Gripper@@QAEXPAVDockingCont@@PAVDockingManager@@@Z endp
.text$mn:00000453
.text$mn:00000453 ; ---------------------------------------------------------------------------
.text$mn:00000456                 db 0Eh dup(0CCh)
.text$mn:00000464
.text$mn:00000464 ; =============== S U B R O U T I N E =======================================
.text$mn:00000464
.text$mn:00000464 ; Attributes: bp-based frame
.text$mn:00000464
.text$mn:00000464 ; void __thiscall Gripper::create(Gripper *__hidden this)
.text$mn:00000464                 public ?create@Gripper@@IAEXXZ
.text$mn:00000464 ?create@Gripper@@IAEXXZ proc near       ; CODE XREF: Gripper::runProc(uint,uint,long)+62p
.text$mn:00000464
.text$mn:00000464 var_22C         = dword ptr -22Ch
.text$mn:00000464 var_228         = dword ptr -228h
.text$mn:00000464 Point           = tagPOINT ptr -224h
.text$mn:00000464 var_21C         = dword ptr -21Ch
.text$mn:00000464 var_218         = dword ptr -218h
.text$mn:00000464 Rect            = tagRECT ptr -214h
.text$mn:00000464 Text            = word ptr -204h
.text$mn:00000464 var_104         = word ptr -104h
.text$mn:00000464 var_4           = dword ptr -4
.text$mn:00000464
.text$mn:00000464                 push    ebp
.text$mn:00000465                 mov     ebp, esp
.text$mn:00000467                 sub     esp, 22Ch
.text$mn:0000046D                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000472                 xor     eax, ebp
.text$mn:00000474                 mov     [ebp+var_4], eax
.text$mn:00000477                 mov     [ebp+var_218], ecx
.text$mn:0000047D                 mov     [ebp+Rect.left], 0
.text$mn:00000487                 xor     eax, eax
.text$mn:00000489                 mov     [ebp+Rect.top], eax
.text$mn:0000048F                 mov     [ebp+Rect.right], eax
.text$mn:00000495                 mov     [ebp+Rect.bottom], eax
.text$mn:0000049B                 mov     [ebp+Point.x], 0
.text$mn:000004A5                 xor     ecx, ecx
.text$mn:000004A7                 mov     [ebp+Point.y], ecx
.text$mn:000004AD                 push    3               ; uFlags
.text$mn:000004AF                 push    0               ; cy
.text$mn:000004B1                 push    0               ; cx
.text$mn:000004B3                 push    0               ; Y
.text$mn:000004B5                 push    0               ; X
.text$mn:000004B7                 push    0FFFFFFFFh      ; hWndInsertAfter
.text$mn:000004B9                 mov     edx, [ebp+var_218]
.text$mn:000004BF                 mov     ecx, [edx+54h]  ; this
.text$mn:000004C2                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:000004C7                 push    eax             ; hWnd
.text$mn:000004C8                 call    dword ptr ds:__imp__SetWindowPos@28 ; SetWindowPos(x,x,x,x,x,x,x)
.text$mn:000004CE                 mov     eax, [ebp+var_218]
.text$mn:000004D4                 mov     ecx, [eax+8]
.text$mn:000004D7                 push    ecx             ; hWnd
.text$mn:000004D8                 call    dword ptr ds:__imp__SetCapture@4 ; SetCapture(x)
.text$mn:000004DE                 call    ?getInstance@NppParameters@@SAPAV1@XZ ; NppParameters::getInstance(void)
.text$mn:000004E3                 mov     ecx, eax
.text$mn:000004E5                 call    ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ ; NppParameters::getWinVersion(void)
.text$mn:000004EA                 mov     [ebp+var_21C], eax
.text$mn:000004F0                 push    0               ; dwThreadId
.text$mn:000004F2                 mov     edx, [ebp+var_218]
.text$mn:000004F8                 mov     eax, [edx]
.text$mn:000004FA                 push    eax             ; hmod
.text$mn:000004FB                 push    offset ?hookProcMouse@@YGJHIJ@Z ; lpfn
.text$mn:00000500                 push    0Eh             ; idHook
.text$mn:00000502                 call    dword ptr ds:__imp__SetWindowsHookExW@16 ; SetWindowsHookExW(x,x,x,x)
.text$mn:00000508                 mov     ds:_hookMouse, eax
.text$mn:0000050D                 cmp     ds:_hookMouse, 0
.text$mn:00000514                 jnz     short loc_554
.text$mn:00000516                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text$mn:0000051C                 mov     [ebp+var_22C], eax
.text$mn:00000522                 mov     ecx, [ebp+var_22C]
.text$mn:00000528                 push    ecx
.text$mn:00000529                 push    offset $SG126036 ; "GetLastError() returned %lu"
.text$mn:0000052E                 lea     edx, [ebp+Text]
.text$mn:00000534                 push    edx             ; LPWSTR
.text$mn:00000535                 call    dword ptr ds:__imp__wsprintfW
.text$mn:0000053B                 add     esp, 0Ch
.text$mn:0000053E                 push    10h             ; uType
.text$mn:00000540                 push    offset $SG126037 ; "SetWindowsHookEx(MOUSE) failed on Gripp"...
.text$mn:00000545                 lea     eax, [ebp+Text]
.text$mn:0000054B                 push    eax             ; lpText
.text$mn:0000054C                 push    0               ; hWnd
.text$mn:0000054E                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:00000554
.text$mn:00000554 loc_554:                                ; CODE XREF: Gripper::create(void)+B0j
.text$mn:00000554                 cmp     [ebp+var_21C], 0
.text$mn:0000055B                 jz      short loc_5CA
.text$mn:0000055D                 cmp     [ebp+var_21C], 0Ah
.text$mn:00000564                 jge     short loc_5CA
.text$mn:00000566                 push    0               ; dwThreadId
.text$mn:00000568                 mov     ecx, [ebp+var_218]
.text$mn:0000056E                 mov     edx, [ecx]
.text$mn:00000570                 push    edx             ; hmod
.text$mn:00000571                 push    offset ?hookProcKeyboard@@YGJHIJ@Z ; lpfn
.text$mn:00000576                 push    0Dh             ; idHook
.text$mn:00000578                 call    dword ptr ds:__imp__SetWindowsHookExW@16 ; SetWindowsHookExW(x,x,x,x)
.text$mn:0000057E                 mov     ds:_hookKeyboard, eax
.text$mn:00000583                 cmp     ds:_hookKeyboard, 0
.text$mn:0000058A                 jnz     short loc_5CA
.text$mn:0000058C                 call    dword ptr ds:__imp__GetLastError@0 ; GetLastError()
.text$mn:00000592                 mov     [ebp+var_228], eax
.text$mn:00000598                 mov     eax, [ebp+var_228]
.text$mn:0000059E                 push    eax
.text$mn:0000059F                 push    offset $SG126075 ; "GetLastError() returned %lu"
.text$mn:000005A4                 lea     ecx, [ebp+var_104]
.text$mn:000005AA                 push    ecx             ; LPWSTR
.text$mn:000005AB                 call    dword ptr ds:__imp__wsprintfW
.text$mn:000005B1                 add     esp, 0Ch
.text$mn:000005B4                 push    10h             ; uType
.text$mn:000005B6                 push    offset $SG126076 ; "SetWindowsHookEx(KEYBOARD) failed on Gr"...
.text$mn:000005BB                 lea     edx, [ebp+var_104]
.text$mn:000005C1                 push    edx             ; lpText
.text$mn:000005C2                 push    0               ; hWnd
.text$mn:000005C4                 call    dword ptr ds:__imp__MessageBoxW@16 ; MessageBoxW(x,x,x,x)
.text$mn:000005CA
.text$mn:000005CA loc_5CA:                                ; CODE XREF: Gripper::create(void)+F7j
.text$mn:000005CA                                         ; Gripper::create(void)+100j ...
.text$mn:000005CA                 lea     eax, [ebp+Point]
.text$mn:000005D0                 push    eax             ; lpPoint
.text$mn:000005D1                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:000005D7                 mov     ecx, [ebp+var_218] ; this
.text$mn:000005DD                 call    ?initTabInformation@Gripper@@IAEXXZ ; Gripper::initTabInformation(void)
.text$mn:000005E2                 mov     ecx, [ebp+var_218]
.text$mn:000005E8                 mov     ecx, [ecx+54h]  ; this
.text$mn:000005EB                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:000005F0                 movzx   edx, al
.text$mn:000005F3                 cmp     edx, 1
.text$mn:000005F6                 jnz     short loc_616
.text$mn:000005F8                 lea     eax, [ebp+Rect]
.text$mn:000005FE                 push    eax             ; lpRect
.text$mn:000005FF                 mov     ecx, [ebp+var_218]
.text$mn:00000605                 mov     ecx, [ecx+54h]  ; this
.text$mn:00000608                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000060D                 push    eax             ; hWnd
.text$mn:0000060E                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00000614                 jmp     short loc_652
.text$mn:00000616 ; ---------------------------------------------------------------------------
.text$mn:00000616
.text$mn:00000616 loc_616:                                ; CODE XREF: Gripper::create(void)+192j
.text$mn:00000616                 lea     edx, [ebp+Rect]
.text$mn:0000061C                 push    edx
.text$mn:0000061D                 mov     eax, [ebp+var_218]
.text$mn:00000623                 mov     ecx, [eax+54h]
.text$mn:00000626                 mov     edx, [ebp+var_218]
.text$mn:0000062C                 mov     eax, [ecx]
.text$mn:0000062E                 mov     ecx, [edx+54h]
.text$mn:00000631                 mov     edx, [eax+1Ch]
.text$mn:00000634                 call    edx
.text$mn:00000636                 lea     eax, [ebp+Point]
.text$mn:0000063C                 push    eax             ; lpPoint
.text$mn:0000063D                 mov     ecx, [ebp+var_218]
.text$mn:00000643                 mov     ecx, [ecx+54h]  ; this
.text$mn:00000646                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:0000064B                 push    eax             ; hWnd
.text$mn:0000064C                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:00000652
.text$mn:00000652 loc_652:                                ; CODE XREF: Gripper::create(void)+1B0j
.text$mn:00000652                 mov     edx, [ebp+Point.x]
.text$mn:00000658                 sub     edx, [ebp+Rect.left]
.text$mn:0000065E                 mov     eax, [ebp+var_218]
.text$mn:00000664                 mov     [eax+58h], edx
.text$mn:00000667                 mov     ecx, [ebp+Point.y]
.text$mn:0000066D                 sub     ecx, [ebp+Rect.top]
.text$mn:00000673                 mov     edx, [ebp+var_218]
.text$mn:00000679                 mov     [edx+5Ch], ecx
.text$mn:0000067C                 mov     ecx, [ebp+var_4]
.text$mn:0000067F                 xor     ecx, ebp
.text$mn:00000681                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000686                 mov     esp, ebp
.text$mn:00000688                 pop     ebp
.text$mn:00000689                 retn
.text$mn:00000689 ?create@Gripper@@IAEXXZ endp
.text$mn:00000689
.text$mn:00000689 ; ---------------------------------------------------------------------------
.text$mn:0000068A                 db 0Ah dup(0CCh)
.text$mn:00000694
.text$mn:00000694 ; =============== S U B R O U T I N E =======================================
.text$mn:00000694
.text$mn:00000694 ; Attributes: bp-based frame
.text$mn:00000694
.text$mn:00000694 ; __int32 __stdcall Gripper::staticWinProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
.text$mn:00000694                 public ?staticWinProc@Gripper@@KGJPAUHWND__@@IIJ@Z
.text$mn:00000694 ?staticWinProc@Gripper@@KGJPAUHWND__@@IIJ@Z proc near
.text$mn:00000694                                         ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+41o
.text$mn:00000694
.text$mn:00000694 var_8           = dword ptr -8
.text$mn:00000694 dwNewLong       = dword ptr -4
.text$mn:00000694 hWnd            = dword ptr  8
.text$mn:00000694 Msg             = dword ptr  0Ch
.text$mn:00000694 wParam          = dword ptr  10h
.text$mn:00000694 lParam          = dword ptr  14h
.text$mn:00000694
.text$mn:00000694                 push    ebp
.text$mn:00000695                 mov     ebp, esp
.text$mn:00000697                 sub     esp, 8
.text$mn:0000069A                 mov     [ebp+dwNewLong], 0
.text$mn:000006A1                 mov     eax, [ebp+Msg]
.text$mn:000006A4                 mov     [ebp+var_8], eax
.text$mn:000006A7                 cmp     [ebp+var_8], 81h ; 'ü'
.text$mn:000006AE                 jz      short loc_6B2
.text$mn:000006B0                 jmp     short loc_6DA
.text$mn:000006B2 ; ---------------------------------------------------------------------------
.text$mn:000006B2
.text$mn:000006B2 loc_6B2:                                ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+1Aj
.text$mn:000006B2                 mov     ecx, [ebp+lParam]
.text$mn:000006B5                 mov     edx, [ecx]
.text$mn:000006B7                 mov     [ebp+dwNewLong], edx
.text$mn:000006BA                 mov     eax, [ebp+dwNewLong]
.text$mn:000006BD                 mov     ecx, [ebp+hWnd]
.text$mn:000006C0                 mov     [eax+8], ecx
.text$mn:000006C3                 mov     edx, [ebp+dwNewLong]
.text$mn:000006C6                 push    edx             ; dwNewLong
.text$mn:000006C7                 push    0FFFFFFEBh      ; nIndex
.text$mn:000006C9                 mov     eax, [ebp+hWnd]
.text$mn:000006CC                 push    eax             ; hWnd
.text$mn:000006CD                 call    dword ptr ds:__imp__SetWindowLongW@12 ; SetWindowLongW(x,x,x)
.text$mn:000006D3                 mov     eax, 1
.text$mn:000006D8                 jmp     short loc_71B
.text$mn:000006DA ; ---------------------------------------------------------------------------
.text$mn:000006DA
.text$mn:000006DA loc_6DA:                                ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+1Cj
.text$mn:000006DA                 push    0FFFFFFEBh      ; nIndex
.text$mn:000006DC                 mov     ecx, [ebp+hWnd]
.text$mn:000006DF                 push    ecx             ; hWnd
.text$mn:000006E0                 call    dword ptr ds:__imp__GetWindowLongW@8 ; GetWindowLongW(x,x)
.text$mn:000006E6                 mov     [ebp+dwNewLong], eax
.text$mn:000006E9                 cmp     [ebp+dwNewLong], 0
.text$mn:000006ED                 jnz     short loc_707
.text$mn:000006EF                 mov     edx, [ebp+lParam]
.text$mn:000006F2                 push    edx             ; lParam
.text$mn:000006F3                 mov     eax, [ebp+wParam]
.text$mn:000006F6                 push    eax             ; wParam
.text$mn:000006F7                 mov     ecx, [ebp+Msg]
.text$mn:000006FA                 push    ecx             ; Msg
.text$mn:000006FB                 mov     edx, [ebp+hWnd]
.text$mn:000006FE                 push    edx             ; hWnd
.text$mn:000006FF                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:00000705                 jmp     short loc_71B
.text$mn:00000707 ; ---------------------------------------------------------------------------
.text$mn:00000707
.text$mn:00000707 loc_707:                                ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+59j
.text$mn:00000707                 mov     eax, [ebp+lParam]
.text$mn:0000070A                 push    eax             ; __int32
.text$mn:0000070B                 mov     ecx, [ebp+wParam]
.text$mn:0000070E                 push    ecx             ; wParam
.text$mn:0000070F                 mov     edx, [ebp+Msg]
.text$mn:00000712                 push    edx             ; Msg
.text$mn:00000713                 mov     ecx, [ebp+dwNewLong] ; this
.text$mn:00000716                 call    ?runProc@Gripper@@IAEJIIJ@Z ; Gripper::runProc(uint,uint,long)
.text$mn:0000071B
.text$mn:0000071B loc_71B:                                ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+44j
.text$mn:0000071B                                         ; Gripper::staticWinProc(HWND__ *,uint,uint,long)+71j
.text$mn:0000071B                 mov     esp, ebp
.text$mn:0000071D                 pop     ebp
.text$mn:0000071E                 retn    10h
.text$mn:0000071E ?staticWinProc@Gripper@@KGJPAUHWND__@@IIJ@Z endp
.text$mn:0000071E
.text$mn:0000071E ; ---------------------------------------------------------------------------
.text$mn:00000721                 align 4
.text$mn:00000724
.text$mn:00000724 ; =============== S U B R O U T I N E =======================================
.text$mn:00000724
.text$mn:00000724 ; Attributes: bp-based frame
.text$mn:00000724
.text$mn:00000724 ; __int32 __thiscall Gripper::runProc(Gripper *this, UINT Msg, WPARAM wParam, __int32)
.text$mn:00000724                 public ?runProc@Gripper@@IAEJIIJ@Z
.text$mn:00000724 ?runProc@Gripper@@IAEJIIJ@Z proc near   ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+82p
.text$mn:00000724
.text$mn:00000724 var_24          = tagPOINT ptr -24h
.text$mn:00000724 Point           = tagPOINT ptr -1Ch
.text$mn:00000724 var_14          = dword ptr -14h
.text$mn:00000724 var_10          = dword ptr -10h
.text$mn:00000724 var_C           = dword ptr -0Ch
.text$mn:00000724 var_8           = dword ptr -8
.text$mn:00000724 var_4           = dword ptr -4
.text$mn:00000724 Msg             = dword ptr  8
.text$mn:00000724 wParam          = dword ptr  0Ch
.text$mn:00000724 lParam          = dword ptr  10h
.text$mn:00000724
.text$mn:00000724                 push    ebp
.text$mn:00000725                 mov     ebp, esp
.text$mn:00000727                 sub     esp, 24h
.text$mn:0000072A                 mov     [ebp+var_4], ecx
.text$mn:0000072D                 mov     eax, [ebp+Msg]
.text$mn:00000730                 mov     [ebp+var_8], eax
.text$mn:00000733                 cmp     [ebp+var_8], 0A2h ; 'ó'
.text$mn:0000073A                 ja      short loc_763
.text$mn:0000073C                 cmp     [ebp+var_8], 0A2h ; 'ó'
.text$mn:00000743                 jz      short loc_7A2
.text$mn:00000745                 cmp     [ebp+var_8], 1
.text$mn:00000749                 jz      short loc_783
.text$mn:0000074B                 cmp     [ebp+var_8], 2
.text$mn:0000074F                 jz      loc_862
.text$mn:00000755                 cmp     [ebp+var_8], 0A0h ; 'á'
.text$mn:0000075C                 jz      short loc_790
.text$mn:0000075E                 jmp     loc_8BE
.text$mn:00000763 ; ---------------------------------------------------------------------------
.text$mn:00000763
.text$mn:00000763 loc_763:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+16j
.text$mn:00000763                 cmp     [ebp+var_8], 200h
.text$mn:0000076A                 jz      short loc_790
.text$mn:0000076C                 cmp     [ebp+var_8], 202h
.text$mn:00000773                 jz      short loc_7A2
.text$mn:00000775                 cmp     [ebp+var_8], 500Ch
.text$mn:0000077C                 jz      short loc_7F8
.text$mn:0000077E                 jmp     loc_8BE
.text$mn:00000783 ; ---------------------------------------------------------------------------
.text$mn:00000783
.text$mn:00000783 loc_783:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+25j
.text$mn:00000783                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000786                 call    ?create@Gripper@@IAEXXZ ; Gripper::create(void)
.text$mn:0000078B                 jmp     loc_8BE
.text$mn:00000790 ; ---------------------------------------------------------------------------
.text$mn:00000790
.text$mn:00000790 loc_790:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+38j
.text$mn:00000790                                         ; Gripper::runProc(uint,uint,long)+46j
.text$mn:00000790                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000793                 call    ?onMove@Gripper@@IAEXXZ ; Gripper::onMove(void)
.text$mn:00000798                 mov     eax, 1
.text$mn:0000079D                 jmp     loc_8D7
.text$mn:000007A2 ; ---------------------------------------------------------------------------
.text$mn:000007A2
.text$mn:000007A2 loc_7A2:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+1Fj
.text$mn:000007A2                                         ; Gripper::runProc(uint,uint,long)+4Fj
.text$mn:000007A2                 cmp     ds:_hookMouse, 0
.text$mn:000007A9                 jz      short loc_7D9
.text$mn:000007AB                 mov     ecx, ds:_hookMouse
.text$mn:000007B1                 push    ecx             ; hhk
.text$mn:000007B2                 call    dword ptr ds:__imp__UnhookWindowsHookEx@4 ; UnhookWindowsHookEx(x)
.text$mn:000007B8                 mov     edx, ds:_hookKeyboard
.text$mn:000007BE                 push    edx             ; hhk
.text$mn:000007BF                 call    dword ptr ds:__imp__UnhookWindowsHookEx@4 ; UnhookWindowsHookEx(x)
.text$mn:000007C5                 mov     ds:_hookMouse, 0
.text$mn:000007CF                 mov     ds:_hookKeyboard, 0
.text$mn:000007D9
.text$mn:000007D9 loc_7D9:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+85j
.text$mn:000007D9                 mov     ecx, [ebp+var_4] ; this
.text$mn:000007DC                 call    ?onButtonUp@Gripper@@IAEXXZ ; Gripper::onButtonUp(void)
.text$mn:000007E1                 mov     eax, [ebp+var_4]
.text$mn:000007E4                 mov     ecx, [eax+8]
.text$mn:000007E7                 push    ecx             ; hWnd
.text$mn:000007E8                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:000007EE                 mov     eax, 1
.text$mn:000007F3                 jmp     loc_8D7
.text$mn:000007F8 ; ---------------------------------------------------------------------------
.text$mn:000007F8
.text$mn:000007F8 loc_7F8:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+58j
.text$mn:000007F8                 mov     [ebp+Point.x], 0
.text$mn:000007FF                 mov     [ebp+Point.y], 0
.text$mn:00000806                 mov     [ebp+var_24.x], 0
.text$mn:0000080D                 mov     [ebp+var_24.y], 0
.text$mn:00000814                 lea     edx, [ebp+Point]
.text$mn:00000817                 push    edx             ; lpPoint
.text$mn:00000818                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:0000081E                 lea     eax, [ebp+var_24]
.text$mn:00000821                 push    eax             ; struct tagPOINT *
.text$mn:00000822                 lea     ecx, [ebp+Point]
.text$mn:00000825                 push    ecx             ; struct tagPOINT *
.text$mn:00000826                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000829                 call    ?getMousePoints@Gripper@@IAEXPAUtagPOINT@@0@Z ; Gripper::getMousePoints(tagPOINT *,tagPOINT *)
.text$mn:0000082E                 push    0               ; struct tagPOINT *
.text$mn:00000830                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000833                 call    ?drawRectangle@Gripper@@IAEXPBUtagPOINT@@@Z ; Gripper::drawRectangle(tagPOINT const *)
.text$mn:00000838                 mov     edx, ds:_hookMouse
.text$mn:0000083E                 push    edx             ; hhk
.text$mn:0000083F                 call    dword ptr ds:__imp__UnhookWindowsHookEx@4 ; UnhookWindowsHookEx(x)
.text$mn:00000845                 mov     eax, ds:_hookKeyboard
.text$mn:0000084A                 push    eax             ; hhk
.text$mn:0000084B                 call    dword ptr ds:__imp__UnhookWindowsHookEx@4 ; UnhookWindowsHookEx(x)
.text$mn:00000851                 mov     ecx, [ebp+var_4]
.text$mn:00000854                 mov     edx, [ecx+8]
.text$mn:00000857                 push    edx             ; hWnd
.text$mn:00000858                 call    dword ptr ds:__imp__DestroyWindow@4 ; DestroyWindow(x)
.text$mn:0000085E                 xor     eax, eax
.text$mn:00000860                 jmp     short loc_8D7
.text$mn:00000862 ; ---------------------------------------------------------------------------
.text$mn:00000862
.text$mn:00000862 loc_862:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+2Bj
.text$mn:00000862                 push    0               ; dwExtraInfo
.text$mn:00000864                 push    0               ; dwData
.text$mn:00000866                 push    0               ; dy
.text$mn:00000868                 push    0               ; dx
.text$mn:0000086A                 push    4               ; dwFlags
.text$mn:0000086C                 call    dword ptr ds:__imp__mouse_event@20 ; mouse_event(x,x,x,x,x)
.text$mn:00000872                 push    3               ; uFlags
.text$mn:00000874                 push    0               ; cy
.text$mn:00000876                 push    0               ; cx
.text$mn:00000878                 push    0               ; Y
.text$mn:0000087A                 push    0               ; X
.text$mn:0000087C                 push    0FFFFFFFEh      ; hWndInsertAfter
.text$mn:0000087E                 mov     eax, [ebp+var_4]
.text$mn:00000881                 mov     ecx, [eax+4]
.text$mn:00000884                 push    ecx             ; hWnd
.text$mn:00000885                 call    dword ptr ds:__imp__SetWindowPos@28 ; SetWindowPos(x,x,x,x,x,x,x)
.text$mn:0000088B                 mov     edx, [ebp+var_4]
.text$mn:0000088E                 mov     ecx, [edx+54h]  ; this
.text$mn:00000891                 call    ?focusClient@DockingCont@@QAEXXZ ; DockingCont::focusClient(void)
.text$mn:00000896                 mov     eax, [ebp+var_4]
.text$mn:00000899                 mov     [ebp+var_10], eax
.text$mn:0000089C                 mov     ecx, [ebp+var_10]
.text$mn:0000089F                 mov     [ebp+var_C], ecx
.text$mn:000008A2                 cmp     [ebp+var_C], 0
.text$mn:000008A6                 jz      short loc_8B7
.text$mn:000008A8                 push    1
.text$mn:000008AA                 mov     ecx, [ebp+var_C]
.text$mn:000008AD                 call    ??_GGripper@@QAEPAXI@Z ; Gripper::`scalar deleting destructor'(uint)
.text$mn:000008B2                 mov     [ebp+var_14], eax
.text$mn:000008B5                 jmp     short loc_8BE
.text$mn:000008B7 ; ---------------------------------------------------------------------------
.text$mn:000008B7
.text$mn:000008B7 loc_8B7:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+182j
.text$mn:000008B7                 mov     [ebp+var_14], 0
.text$mn:000008BE
.text$mn:000008BE loc_8BE:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+3Aj
.text$mn:000008BE                                         ; Gripper::runProc(uint,uint,long)+5Aj ...
.text$mn:000008BE                 mov     edx, [ebp+lParam]
.text$mn:000008C1                 push    edx             ; lParam
.text$mn:000008C2                 mov     eax, [ebp+wParam]
.text$mn:000008C5                 push    eax             ; wParam
.text$mn:000008C6                 mov     ecx, [ebp+Msg]
.text$mn:000008C9                 push    ecx             ; Msg
.text$mn:000008CA                 mov     edx, [ebp+var_4]
.text$mn:000008CD                 mov     eax, [edx+8]
.text$mn:000008D0                 push    eax             ; hWnd
.text$mn:000008D1                 call    dword ptr ds:__imp__DefWindowProcW@16 ; DefWindowProcW(x,x,x,x)
.text$mn:000008D7
.text$mn:000008D7 loc_8D7:                                ; CODE XREF: Gripper::runProc(uint,uint,long)+79j
.text$mn:000008D7                                         ; Gripper::runProc(uint,uint,long)+CFj ...
.text$mn:000008D7                 mov     esp, ebp
.text$mn:000008D9                 pop     ebp
.text$mn:000008DA                 retn    0Ch
.text$mn:000008DA ?runProc@Gripper@@IAEJIIJ@Z endp
.text$mn:000008DA
.text$mn:000008DA ; ---------------------------------------------------------------------------
.text$mn:000008DD                 db 7 dup(0CCh)
.text$mn:000008E4
.text$mn:000008E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000008E4
.text$mn:000008E4 ; Attributes: bp-based frame
.text$mn:000008E4
.text$mn:000008E4 ; void __thiscall Gripper::onMove(Gripper *__hidden this)
.text$mn:000008E4                 public ?onMove@Gripper@@IAEXXZ
.text$mn:000008E4 ?onMove@Gripper@@IAEXXZ proc near       ; CODE XREF: Gripper::runProc(uint,uint,long)+6Fp
.text$mn:000008E4
.text$mn:000008E4 var_14          = tagPOINT ptr -14h
.text$mn:000008E4 Point           = tagPOINT ptr -0Ch
.text$mn:000008E4 var_4           = dword ptr -4
.text$mn:000008E4
.text$mn:000008E4                 push    ebp
.text$mn:000008E5                 mov     ebp, esp
.text$mn:000008E7                 sub     esp, 14h
.text$mn:000008EA                 mov     [ebp+var_4], ecx
.text$mn:000008ED                 mov     [ebp+Point.x], 0
.text$mn:000008F4                 mov     [ebp+Point.y], 0
.text$mn:000008FB                 mov     [ebp+var_14.x], 0
.text$mn:00000902                 mov     [ebp+var_14.y], 0
.text$mn:00000909                 lea     eax, [ebp+Point]
.text$mn:0000090C                 push    eax             ; lpPoint
.text$mn:0000090D                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:00000913                 lea     ecx, [ebp+var_14]
.text$mn:00000916                 push    ecx             ; struct tagPOINT *
.text$mn:00000917                 lea     edx, [ebp+Point]
.text$mn:0000091A                 push    edx             ; struct tagPOINT *
.text$mn:0000091B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000091E                 call    ?getMousePoints@Gripper@@IAEXPAUtagPOINT@@0@Z ; Gripper::getMousePoints(tagPOINT *,tagPOINT *)
.text$mn:00000923                 mov     eax, [ebp+var_4]
.text$mn:00000926                 cmp     dword ptr [eax+84h], 1
.text$mn:0000092D                 jnz     short loc_93F
.text$mn:0000092F                 mov     ecx, [ebp+Point.y]
.text$mn:00000932                 push    ecx
.text$mn:00000933                 mov     edx, [ebp+Point.x]
.text$mn:00000936                 push    edx             ; struct tagPOINT
.text$mn:00000937                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000093A                 call    ?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z ; Gripper::doTabReordering(tagPOINT)
.text$mn:0000093F
.text$mn:0000093F loc_93F:                                ; CODE XREF: Gripper::onMove(void)+49j
.text$mn:0000093F                 lea     eax, [ebp+Point]
.text$mn:00000942                 push    eax             ; struct tagPOINT *
.text$mn:00000943                 mov     ecx, [ebp+var_4] ; this
.text$mn:00000946                 call    ?drawRectangle@Gripper@@IAEXPBUtagPOINT@@@Z ; Gripper::drawRectangle(tagPOINT const *)
.text$mn:0000094B                 mov     esp, ebp
.text$mn:0000094D                 pop     ebp
.text$mn:0000094E                 retn
.text$mn:0000094E ?onMove@Gripper@@IAEXXZ endp
.text$mn:0000094E
.text$mn:0000094E ; ---------------------------------------------------------------------------
.text$mn:0000094F                 db 5 dup(0CCh)
.text$mn:00000954
.text$mn:00000954 ; =============== S U B R O U T I N E =======================================
.text$mn:00000954
.text$mn:00000954 ; Attributes: bp-based frame
.text$mn:00000954
.text$mn:00000954 ; void __thiscall Gripper::onButtonUp(Gripper *__hidden this)
.text$mn:00000954                 public ?onButtonUp@Gripper@@IAEXXZ
.text$mn:00000954 ?onButtonUp@Gripper@@IAEXXZ proc near   ; CODE XREF: Gripper::runProc(uint,uint,long)+B8p
.text$mn:00000954
.text$mn:00000954 var_40          = tagPOINT ptr -40h
.text$mn:00000954 Point           = tagPOINT ptr -38h
.text$mn:00000954 var_30          = dword ptr -30h
.text$mn:00000954 var_2C          = dword ptr -2Ch
.text$mn:00000954 var_28          = dword ptr -28h
.text$mn:00000954 var_24          = tagRECT ptr -24h
.text$mn:00000954 X               = dword ptr -14h
.text$mn:00000954 Y               = dword ptr -10h
.text$mn:00000954 nWidth          = dword ptr -0Ch
.text$mn:00000954 nHeight         = dword ptr -8
.text$mn:00000954 var_4           = dword ptr -4
.text$mn:00000954
.text$mn:00000954                 push    ebp
.text$mn:00000955                 mov     ebp, esp
.text$mn:00000957                 sub     esp, 40h
.text$mn:0000095A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000095F                 xor     eax, ebp
.text$mn:00000961                 mov     [ebp+var_4], eax
.text$mn:00000964                 mov     [ebp+var_28], ecx
.text$mn:00000967                 mov     [ebp+Point.x], 0
.text$mn:0000096E                 mov     [ebp+Point.y], 0
.text$mn:00000975                 mov     [ebp+var_40.x], 0
.text$mn:0000097C                 mov     [ebp+var_40.y], 0
.text$mn:00000983                 mov     [ebp+X], 0
.text$mn:0000098A                 xor     eax, eax
.text$mn:0000098C                 mov     [ebp+Y], eax
.text$mn:0000098F                 mov     [ebp+nWidth], eax
.text$mn:00000992                 mov     [ebp+nHeight], eax
.text$mn:00000995                 mov     [ebp+var_24.left], 0
.text$mn:0000099C                 xor     ecx, ecx
.text$mn:0000099E                 mov     [ebp+var_24.top], ecx
.text$mn:000009A1                 mov     [ebp+var_24.right], ecx
.text$mn:000009A4                 mov     [ebp+var_24.bottom], ecx
.text$mn:000009A7                 mov     [ebp+var_30], 0
.text$mn:000009AE                 lea     edx, [ebp+Point]
.text$mn:000009B1                 push    edx             ; lpPoint
.text$mn:000009B2                 call    dword ptr ds:__imp__GetCursorPos@4 ; GetCursorPos(x)
.text$mn:000009B8                 lea     eax, [ebp+var_40]
.text$mn:000009BB                 push    eax             ; struct tagPOINT *
.text$mn:000009BC                 lea     ecx, [ebp+Point]
.text$mn:000009BF                 push    ecx             ; struct tagPOINT *
.text$mn:000009C0                 mov     ecx, [ebp+var_28] ; this
.text$mn:000009C3                 call    ?getMousePoints@Gripper@@IAEXPAUtagPOINT@@0@Z ; Gripper::getMousePoints(tagPOINT *,tagPOINT *)
.text$mn:000009C8                 mov     edx, [ebp+var_28]
.text$mn:000009CB                 cmp     dword ptr [edx+68h], 0
.text$mn:000009CF                 jnz     short loc_9D6
.text$mn:000009D1                 jmp     loc_C0C
.text$mn:000009D6 ; ---------------------------------------------------------------------------
.text$mn:000009D6
.text$mn:000009D6 loc_9D6:                                ; CODE XREF: Gripper::onButtonUp(void)+7Bj
.text$mn:000009D6                 push    0               ; struct tagPOINT *
.text$mn:000009D8                 mov     ecx, [ebp+var_28] ; this
.text$mn:000009DB                 call    ?drawRectangle@Gripper@@IAEXPBUtagPOINT@@@Z ; Gripper::drawRectangle(tagPOINT const *)
.text$mn:000009E0                 mov     eax, [ebp+Point.y]
.text$mn:000009E3                 push    eax
.text$mn:000009E4                 mov     ecx, [ebp+Point.x]
.text$mn:000009E7                 push    ecx             ; struct tagPOINT
.text$mn:000009E8                 mov     ecx, [ebp+var_28] ; this
.text$mn:000009EB                 call    ?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z ; Gripper::contHitTest(tagPOINT)
.text$mn:000009F0                 mov     [ebp+var_2C], eax
.text$mn:000009F3                 cmp     [ebp+var_2C], 0
.text$mn:000009F7                 jnz     short loc_A0E
.text$mn:000009F9                 push    0               ; struct tagRECT *
.text$mn:000009FB                 mov     edx, [ebp+Point.y]
.text$mn:000009FE                 push    edx
.text$mn:000009FF                 mov     eax, [ebp+Point.x]
.text$mn:00000A02                 push    eax             ; pt
.text$mn:00000A03                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000A06                 call    ?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z ; Gripper::workHitTest(tagPOINT,tagRECT *)
.text$mn:00000A0B                 mov     [ebp+var_2C], eax
.text$mn:00000A0E
.text$mn:00000A0E loc_A0E:                                ; CODE XREF: Gripper::onButtonUp(void)+A3j
.text$mn:00000A0E                 cmp     [ebp+var_2C], 0
.text$mn:00000A12                 jnz     loc_BA9
.text$mn:00000A18                 mov     ecx, [ebp+var_28]
.text$mn:00000A1B                 mov     ecx, [ecx+54h]  ; this
.text$mn:00000A1E                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:00000A23                 add     eax, 18h
.text$mn:00000A26                 mov     edx, [eax]
.text$mn:00000A28                 mov     [ebp+X], edx
.text$mn:00000A2B                 mov     ecx, [eax+4]
.text$mn:00000A2E                 mov     [ebp+Y], ecx
.text$mn:00000A31                 mov     edx, [eax+8]
.text$mn:00000A34                 mov     [ebp+nWidth], edx
.text$mn:00000A37                 mov     eax, [eax+0Ch]
.text$mn:00000A3A                 mov     [ebp+nHeight], eax
.text$mn:00000A3D                 lea     ecx, [ebp+var_24]
.text$mn:00000A40                 push    ecx
.text$mn:00000A41                 mov     edx, [ebp+var_28]
.text$mn:00000A44                 mov     eax, [edx+54h]
.text$mn:00000A47                 mov     ecx, [ebp+var_28]
.text$mn:00000A4A                 mov     edx, [eax]
.text$mn:00000A4C                 mov     ecx, [ecx+54h]
.text$mn:00000A4F                 mov     eax, [edx+1Ch]
.text$mn:00000A52                 call    eax
.text$mn:00000A54                 lea     ecx, [ebp+X]
.text$mn:00000A57                 push    ecx             ; struct tagRECT *
.text$mn:00000A58                 mov     edx, [ebp+var_28]
.text$mn:00000A5B                 mov     eax, [edx+0Ch]
.text$mn:00000A5E                 push    eax             ; HWND
.text$mn:00000A5F                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000A62                 call    ?CalcRectToScreen@Gripper@@IAEXPAUHWND__@@PAUtagRECT@@@Z ; Gripper::CalcRectToScreen(HWND__ *,tagRECT *)
.text$mn:00000A67                 lea     ecx, [ebp+var_24]
.text$mn:00000A6A                 push    ecx             ; struct tagRECT *
.text$mn:00000A6B                 mov     edx, [ebp+var_28]
.text$mn:00000A6E                 mov     eax, [edx+0Ch]
.text$mn:00000A71                 push    eax             ; HWND
.text$mn:00000A72                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000A75                 call    ?CalcRectToScreen@Gripper@@IAEXPAUHWND__@@PAUtagRECT@@@Z ; Gripper::CalcRectToScreen(HWND__ *,tagRECT *)
.text$mn:00000A7A                 mov     ecx, [ebp+var_28]
.text$mn:00000A7D                 mov     edx, [ebp+Point.x]
.text$mn:00000A80                 sub     edx, [ecx+58h]
.text$mn:00000A83                 mov     [ebp+X], edx
.text$mn:00000A86                 mov     eax, [ebp+var_28]
.text$mn:00000A89                 mov     ecx, [ebp+Point.y]
.text$mn:00000A8C                 sub     ecx, [eax+5Ch]
.text$mn:00000A8F                 mov     [ebp+Y], ecx
.text$mn:00000A92                 mov     edx, [ebp+Point.y]
.text$mn:00000A95                 push    edx
.text$mn:00000A96                 mov     eax, [ebp+Point.x]
.text$mn:00000A99                 push    eax             ; struct tagPOINT
.text$mn:00000A9A                 sub     esp, 10h
.text$mn:00000A9D                 mov     ecx, esp
.text$mn:00000A9F                 mov     edx, [ebp+var_24.left]
.text$mn:00000AA2                 mov     [ecx], edx
.text$mn:00000AA4                 mov     eax, [ebp+var_24.top]
.text$mn:00000AA7                 mov     [ecx+4], eax
.text$mn:00000AAA                 mov     edx, [ebp+var_24.right]
.text$mn:00000AAD                 mov     [ecx+8], edx
.text$mn:00000AB0                 mov     eax, [ebp+var_24.bottom]
.text$mn:00000AB3                 mov     [ecx+0Ch], eax
.text$mn:00000AB6                 lea     ecx, [ebp+X]
.text$mn:00000AB9                 push    ecx             ; struct tagRECT *
.text$mn:00000ABA                 mov     ecx, [ebp+var_28] ; this
.text$mn:00000ABD                 call    ?DoCalcGripperRect@Gripper@@IAEXPAUtagRECT@@U2@UtagPOINT@@@Z ; Gripper::DoCalcGripperRect(tagRECT *,tagRECT,tagPOINT)
.text$mn:00000AC2                 mov     edx, [ebp+var_28]
.text$mn:00000AC5                 cmp     dword ptr [edx+84h], 1
.text$mn:00000ACC                 jnz     short loc_B32
.text$mn:00000ACE                 mov     eax, [ebp+var_28]
.text$mn:00000AD1                 mov     ecx, [eax+54h]  ; this
.text$mn:00000AD4                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:00000AD9                 movzx   ecx, al
.text$mn:00000ADC                 test    ecx, ecx
.text$mn:00000ADE                 jz      short loc_B10
.text$mn:00000AE0                 mov     edx, [ebp+var_28]
.text$mn:00000AE3                 mov     ecx, [edx+54h]  ; this
.text$mn:00000AE6                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:00000AEB                 movzx   eax, al
.text$mn:00000AEE                 test    eax, eax
.text$mn:00000AF0                 jz      short loc_B30
.text$mn:00000AF2                 push    0               ; lParam
.text$mn:00000AF4                 push    0               ; wParam
.text$mn:00000AF6                 push    1304h           ; Msg
.text$mn:00000AFB                 mov     ecx, [ebp+var_28]
.text$mn:00000AFE                 mov     edx, [ecx+80h]
.text$mn:00000B04                 push    edx             ; hWnd
.text$mn:00000B05                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000B0B                 cmp     eax, 1
.text$mn:00000B0E                 jle     short loc_B30
.text$mn:00000B10
.text$mn:00000B10 loc_B10:                                ; CODE XREF: Gripper::onButtonUp(void)+18Aj
.text$mn:00000B10                 lea     eax, [ebp+X]
.text$mn:00000B13                 push    eax             ; struct tagRECT *
.text$mn:00000B14                 push    1               ; int
.text$mn:00000B16                 push    5003h           ; unsigned int
.text$mn:00000B1B                 mov     ecx, [ebp+var_28]
.text$mn:00000B1E                 mov     edx, [ecx+54h]
.text$mn:00000B21                 push    edx             ; struct DockingCont *
.text$mn:00000B22                 mov     eax, [ebp+var_28]
.text$mn:00000B25                 mov     ecx, [eax+50h]  ; this
.text$mn:00000B28                 call    ?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z ; DockingManager::toggleActiveTb(DockingCont *,uint,int,tagRECT *)
.text$mn:00000B2D                 mov     [ebp+var_30], eax
.text$mn:00000B30
.text$mn:00000B30 loc_B30:                                ; CODE XREF: Gripper::onButtonUp(void)+19Cj
.text$mn:00000B30                                         ; Gripper::onButtonUp(void)+1BAj
.text$mn:00000B30                 jmp     short loc_B62
.text$mn:00000B32 ; ---------------------------------------------------------------------------
.text$mn:00000B32
.text$mn:00000B32 loc_B32:                                ; CODE XREF: Gripper::onButtonUp(void)+178j
.text$mn:00000B32                 mov     ecx, [ebp+var_28]
.text$mn:00000B35                 mov     ecx, [ecx+54h]  ; this
.text$mn:00000B38                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:00000B3D                 movzx   edx, al
.text$mn:00000B40                 test    edx, edx
.text$mn:00000B42                 jnz     short loc_B62
.text$mn:00000B44                 lea     eax, [ebp+X]
.text$mn:00000B47                 push    eax             ; struct tagRECT *
.text$mn:00000B48                 push    5003h           ; unsigned int
.text$mn:00000B4D                 mov     ecx, [ebp+var_28]
.text$mn:00000B50                 mov     edx, [ecx+54h]
.text$mn:00000B53                 push    edx             ; struct DockingCont *
.text$mn:00000B54                 mov     eax, [ebp+var_28]
.text$mn:00000B57                 mov     ecx, [eax+50h]  ; this
.text$mn:00000B5A                 call    ?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z ; DockingManager::toggleVisTb(DockingCont *,uint,tagRECT *)
.text$mn:00000B5F                 mov     [ebp+var_30], eax
.text$mn:00000B62
.text$mn:00000B62 loc_B62:                                ; CODE XREF: Gripper::onButtonUp(void):loc_B30j
.text$mn:00000B62                                         ; Gripper::onButtonUp(void)+1EEj
.text$mn:00000B62                 cmp     [ebp+var_30], 0
.text$mn:00000B66                 jnz     short loc_B71
.text$mn:00000B68                 mov     ecx, [ebp+var_28]
.text$mn:00000B6B                 mov     edx, [ecx+54h]
.text$mn:00000B6E                 mov     [ebp+var_30], edx
.text$mn:00000B71
.text$mn:00000B71 loc_B71:                                ; CODE XREF: Gripper::onButtonUp(void)+212j
.text$mn:00000B71                 push    1               ; bRepaint
.text$mn:00000B73                 mov     eax, [ebp+nHeight]
.text$mn:00000B76                 push    eax             ; nHeight
.text$mn:00000B77                 mov     ecx, [ebp+nWidth]
.text$mn:00000B7A                 push    ecx             ; nWidth
.text$mn:00000B7B                 mov     edx, [ebp+Y]
.text$mn:00000B7E                 push    edx             ; Y
.text$mn:00000B7F                 mov     eax, [ebp+X]
.text$mn:00000B82                 push    eax             ; X
.text$mn:00000B83                 mov     ecx, [ebp+var_30] ; this
.text$mn:00000B86                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000B8B                 push    eax             ; hWnd
.text$mn:00000B8C                 call    dword ptr ds:__imp__MoveWindow@24 ; MoveWindow(x,x,x,x,x,x)
.text$mn:00000B92                 push    0               ; lParam
.text$mn:00000B94                 push    0               ; wParam
.text$mn:00000B96                 push    5               ; Msg
.text$mn:00000B98                 mov     ecx, [ebp+var_30] ; this
.text$mn:00000B9B                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00000BA0                 push    eax             ; hWnd
.text$mn:00000BA1                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000BA7                 jmp     short loc_C0C
.text$mn:00000BA9 ; ---------------------------------------------------------------------------
.text$mn:00000BA9
.text$mn:00000BA9 loc_BA9:                                ; CODE XREF: Gripper::onButtonUp(void)+BEj
.text$mn:00000BA9                 mov     ecx, [ebp+var_28]
.text$mn:00000BAC                 mov     edx, [ecx+54h]
.text$mn:00000BAF                 cmp     edx, [ebp+var_2C]
.text$mn:00000BB2                 jz      short loc_C0C
.text$mn:00000BB4                 mov     eax, [ebp+var_28]
.text$mn:00000BB7                 cmp     dword ptr [eax+84h], 1
.text$mn:00000BBE                 jnz     short loc_BF6
.text$mn:00000BC0                 push    0               ; lParam
.text$mn:00000BC2                 push    0               ; wParam
.text$mn:00000BC4                 push    1304h           ; Msg
.text$mn:00000BC9                 mov     ecx, [ebp+var_28]
.text$mn:00000BCC                 mov     edx, [ecx+80h]
.text$mn:00000BD2                 push    edx             ; hWnd
.text$mn:00000BD3                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000BD9                 cmp     eax, 1
.text$mn:00000BDC                 jz      short loc_BF6
.text$mn:00000BDE                 mov     eax, [ebp+var_2C]
.text$mn:00000BE1                 push    eax             ; struct DockingCont *
.text$mn:00000BE2                 mov     ecx, [ebp+var_28]
.text$mn:00000BE5                 mov     edx, [ecx+54h]
.text$mn:00000BE8                 push    edx             ; struct DockingCont *
.text$mn:00000BE9                 mov     eax, [ebp+var_28]
.text$mn:00000BEC                 mov     ecx, [eax+50h]  ; this
.text$mn:00000BEF                 call    ?toggleActiveTb@DockingManager@@QAEXPAVDockingCont@@0@Z ; DockingManager::toggleActiveTb(DockingCont *,DockingCont *)
.text$mn:00000BF4                 jmp     short loc_C0C
.text$mn:00000BF6 ; ---------------------------------------------------------------------------
.text$mn:00000BF6
.text$mn:00000BF6 loc_BF6:                                ; CODE XREF: Gripper::onButtonUp(void)+26Aj
.text$mn:00000BF6                                         ; Gripper::onButtonUp(void)+288j
.text$mn:00000BF6                 mov     ecx, [ebp+var_2C]
.text$mn:00000BF9                 push    ecx             ; struct DockingCont *
.text$mn:00000BFA                 mov     edx, [ebp+var_28]
.text$mn:00000BFD                 mov     eax, [edx+54h]
.text$mn:00000C00                 push    eax             ; struct DockingCont *
.text$mn:00000C01                 mov     ecx, [ebp+var_28]
.text$mn:00000C04                 mov     ecx, [ecx+50h]  ; this
.text$mn:00000C07                 call    ?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z ; DockingManager::toggleVisTb(DockingCont *,DockingCont *)
.text$mn:00000C0C
.text$mn:00000C0C loc_C0C:                                ; CODE XREF: Gripper::onButtonUp(void)+7Dj
.text$mn:00000C0C                                         ; Gripper::onButtonUp(void)+253j ...
.text$mn:00000C0C                 mov     ecx, [ebp+var_4]
.text$mn:00000C0F                 xor     ecx, ebp
.text$mn:00000C11                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00000C16                 mov     esp, ebp
.text$mn:00000C18                 pop     ebp
.text$mn:00000C19                 retn
.text$mn:00000C19 ?onButtonUp@Gripper@@IAEXXZ endp
.text$mn:00000C19
.text$mn:00000C19 ; ---------------------------------------------------------------------------
.text$mn:00000C1A                 db 0Ah dup(0CCh)
.text$mn:00000C24
.text$mn:00000C24 ; =============== S U B R O U T I N E =======================================
.text$mn:00000C24
.text$mn:00000C24 ; Attributes: bp-based frame
.text$mn:00000C24
.text$mn:00000C24 ; void __thiscall Gripper::doTabReordering(Gripper *this, struct tagPOINT)
.text$mn:00000C24                 public ?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z
.text$mn:00000C24 ?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z proc near
.text$mn:00000C24                                         ; CODE XREF: Gripper::onMove(void)+56p
.text$mn:00000C24
.text$mn:00000C24 var_68          = byte ptr -68h
.text$mn:00000C24 var_58          = dword ptr -58h
.text$mn:00000C24 var_54          = dword ptr -54h
.text$mn:00000C24 var_50          = dword ptr -50h
.text$mn:00000C24 var_4C          = dword ptr -4Ch
.text$mn:00000C24 var_48          = dword ptr -48h
.text$mn:00000C24 var_44          = dword ptr -44h
.text$mn:00000C24 wParam          = dword ptr -40h
.text$mn:00000C24 var_3C          = dword ptr -3Ch
.text$mn:00000C24 var_38          = dword ptr -38h
.text$mn:00000C24 hWnd            = dword ptr -34h
.text$mn:00000C24 var_30          = dword ptr -30h
.text$mn:00000C24 Point           = tagPOINT ptr -2Ch
.text$mn:00000C24 var_24          = dword ptr -24h
.text$mn:00000C24 Rect            = tagRECT ptr -20h
.text$mn:00000C24 var_10          = dword ptr -10h
.text$mn:00000C24 var_C           = dword ptr -0Ch
.text$mn:00000C24 var_4           = dword ptr -4
.text$mn:00000C24 pt              = POINT ptr  8
.text$mn:00000C24
.text$mn:00000C24                 push    ebp
.text$mn:00000C25                 mov     ebp, esp
.text$mn:00000C27                 push    0FFFFFFFFh
.text$mn:00000C29                 push    offset __ehhandler$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z
.text$mn:00000C2E                 mov     eax, large fs:0
.text$mn:00000C34                 push    eax
.text$mn:00000C35                 sub     esp, 5Ch
.text$mn:00000C38                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00000C3D                 xor     eax, ebp
.text$mn:00000C3F                 mov     [ebp+var_10], eax
.text$mn:00000C42                 push    eax
.text$mn:00000C43                 lea     eax, [ebp+var_C]
.text$mn:00000C46                 mov     large fs:0, eax
.text$mn:00000C4C                 mov     [ebp+var_30], ecx
.text$mn:00000C4F                 mov     eax, [ebp+var_30]
.text$mn:00000C52                 mov     ecx, [eax+50h]
.text$mn:00000C55                 call    ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ ; DockingManager::getContainerInfo(void)
.text$mn:00000C5A                 push    eax
.text$mn:00000C5B                 lea     ecx, [ebp+var_68]
.text$mn:00000C5E                 call    ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)
.text$mn:00000C63                 mov     [ebp+var_4], 0
.text$mn:00000C6A                 mov     [ebp+var_48], 0
.text$mn:00000C71                 mov     [ebp+hWnd], 0
.text$mn:00000C78                 mov     ecx, [ebp+var_30]
.text$mn:00000C7B                 mov     edx, [ecx+7Ch]
.text$mn:00000C7E                 mov     [ebp+var_3C], edx
.text$mn:00000C81                 mov     [ebp+wParam], 0FFFFFFFFh
.text$mn:00000C88                 mov     eax, [ebp+var_30]
.text$mn:00000C8B                 mov     ecx, [eax+88h]
.text$mn:00000C91                 mov     [ebp+var_38], ecx
.text$mn:00000C94                 mov     [ebp+var_44], 0
.text$mn:00000C9B                 lea     ecx, [ebp+var_68]
.text$mn:00000C9E                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00000CA3                 mov     [ebp+var_54], eax
.text$mn:00000CA6                 jmp     short loc_CB1
.text$mn:00000CA8 ; ---------------------------------------------------------------------------
.text$mn:00000CA8
.text$mn:00000CA8 loc_CA8:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT):loc_E6Dj
.text$mn:00000CA8                 mov     edx, [ebp+var_44]
.text$mn:00000CAB                 add     edx, 1
.text$mn:00000CAE                 mov     [ebp+var_44], edx
.text$mn:00000CB1
.text$mn:00000CB1 loc_CB1:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+82j
.text$mn:00000CB1                 mov     eax, [ebp+var_44]
.text$mn:00000CB4                 cmp     eax, [ebp+var_54]
.text$mn:00000CB7                 jnb     loc_E72
.text$mn:00000CBD                 mov     ecx, [ebp+var_44]
.text$mn:00000CC0                 push    ecx
.text$mn:00000CC1                 lea     ecx, [ebp+var_68]
.text$mn:00000CC4                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00000CC9                 mov     ecx, [eax]      ; this
.text$mn:00000CCB                 call    ?getTabWnd@DockingCont@@QAEPAUHWND__@@XZ ; DockingCont::getTabWnd(void)
.text$mn:00000CD0                 mov     [ebp+hWnd], eax
.text$mn:00000CD3                 mov     edx, [ebp+hWnd]
.text$mn:00000CD6                 push    edx             ; hWnd
.text$mn:00000CD7                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00000CDD                 cmp     eax, 1
.text$mn:00000CE0                 jnz     loc_E6D
.text$mn:00000CE6                 mov     [ebp+Rect.left], 0
.text$mn:00000CED                 xor     eax, eax
.text$mn:00000CEF                 mov     [ebp+Rect.top], eax
.text$mn:00000CF2                 mov     [ebp+Rect.right], eax
.text$mn:00000CF5                 mov     [ebp+Rect.bottom], eax
.text$mn:00000CF8                 lea     ecx, [ebp+Rect]
.text$mn:00000CFB                 push    ecx             ; lpRect
.text$mn:00000CFC                 mov     edx, [ebp+hWnd]
.text$mn:00000CFF                 push    edx             ; hWnd
.text$mn:00000D00                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00000D06                 mov     eax, [ebp+pt.y]
.text$mn:00000D09                 push    eax
.text$mn:00000D0A                 mov     ecx, [ebp+pt.x]
.text$mn:00000D0D                 push    ecx             ; pt
.text$mn:00000D0E                 lea     edx, [ebp+Rect]
.text$mn:00000D11                 push    edx             ; lprc
.text$mn:00000D12                 call    dword ptr ds:__imp__PtInRect@12 ; PtInRect(x,x,x)
.text$mn:00000D18                 cmp     eax, 1
.text$mn:00000D1B                 jnz     loc_E6D
.text$mn:00000D21                 mov     [ebp+Point.x], 0
.text$mn:00000D28                 xor     eax, eax
.text$mn:00000D2A                 mov     [ebp+Point.y], eax
.text$mn:00000D2D                 mov     [ebp+var_24], eax
.text$mn:00000D30                 mov     ecx, [ebp+var_30]
.text$mn:00000D33                 cmp     dword ptr [ecx+7Ch], 0
.text$mn:00000D37                 jnz     short loc_D56
.text$mn:00000D39                 mov     ecx, [ebp+var_30] ; this
.text$mn:00000D3C                 call    ?initTabInformation@Gripper@@IAEXXZ ; Gripper::initTabInformation(void)
.text$mn:00000D41                 mov     edx, [ebp+var_30]
.text$mn:00000D44                 mov     eax, [edx+7Ch]
.text$mn:00000D47                 mov     [ebp+var_3C], eax
.text$mn:00000D4A                 mov     ecx, [ebp+var_30]
.text$mn:00000D4D                 mov     edx, [ecx+88h]
.text$mn:00000D53                 mov     [ebp+var_38], edx
.text$mn:00000D56
.text$mn:00000D56 loc_D56:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+113j
.text$mn:00000D56                 mov     eax, [ebp+pt.x]
.text$mn:00000D59                 mov     [ebp+Point.x], eax
.text$mn:00000D5C                 mov     ecx, [ebp+pt.y]
.text$mn:00000D5F                 mov     [ebp+Point.y], ecx
.text$mn:00000D62                 lea     edx, [ebp+Point]
.text$mn:00000D65                 push    edx             ; lpPoint
.text$mn:00000D66                 mov     eax, [ebp+hWnd]
.text$mn:00000D69                 push    eax             ; hWnd
.text$mn:00000D6A                 call    dword ptr ds:__imp__ScreenToClient@8 ; ScreenToClient(x,x)
.text$mn:00000D70                 lea     ecx, [ebp+Point]
.text$mn:00000D73                 push    ecx             ; lParam
.text$mn:00000D74                 push    0               ; wParam
.text$mn:00000D76                 push    130Dh           ; Msg
.text$mn:00000D7B                 mov     edx, [ebp+hWnd]
.text$mn:00000D7E                 push    edx             ; hWnd
.text$mn:00000D7F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000D85                 mov     [ebp+wParam], eax
.text$mn:00000D88                 cmp     [ebp+wParam], 0FFFFFFFFh
.text$mn:00000D8C                 jz      short loc_DF1
.text$mn:00000D8E                 lea     eax, [ebp+Rect]
.text$mn:00000D91                 push    eax             ; lParam
.text$mn:00000D92                 mov     ecx, [ebp+wParam]
.text$mn:00000D95                 push    ecx             ; wParam
.text$mn:00000D96                 push    130Ah           ; Msg
.text$mn:00000D9B                 mov     edx, [ebp+hWnd]
.text$mn:00000D9E                 push    edx             ; hWnd
.text$mn:00000D9F                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000DA5                 lea     eax, [ebp+Rect]
.text$mn:00000DA8                 push    eax             ; struct tagRECT *
.text$mn:00000DA9                 mov     ecx, [ebp+hWnd]
.text$mn:00000DAC                 push    ecx             ; HWND
.text$mn:00000DAD                 call    ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z ; ClientRectToScreenRect(HWND__ *,tagRECT *)
.text$mn:00000DB2                 add     esp, 8
.text$mn:00000DB5                 mov     edx, [ebp+var_30]
.text$mn:00000DB8                 mov     eax, [ebp+var_30]
.text$mn:00000DBB                 mov     ecx, [edx+94h]
.text$mn:00000DC1                 sub     ecx, [eax+8Ch]
.text$mn:00000DC7                 add     ecx, [ebp+Rect.left]
.text$mn:00000DCA                 cmp     ecx, [ebp+pt.x]
.text$mn:00000DCD                 jge     short loc_DE3
.text$mn:00000DCF                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000DD6                 lea     ecx, [ebp+var_68]
.text$mn:00000DD9                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:00000DDE                 jmp     loc_FF4
.text$mn:00000DE3 ; ---------------------------------------------------------------------------
.text$mn:00000DE3
.text$mn:00000DE3 loc_DE3:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+1A9j
.text$mn:00000DE3                 mov     edx, [ebp+var_30]
.text$mn:00000DE6                 mov     eax, [ebp+wParam]
.text$mn:00000DE9                 mov     [edx+88h], eax
.text$mn:00000DEF                 jmp     short loc_E5B
.text$mn:00000DF1 ; ---------------------------------------------------------------------------
.text$mn:00000DF1
.text$mn:00000DF1 loc_DF1:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+168j
.text$mn:00000DF1                 mov     ecx, [ebp+var_30]
.text$mn:00000DF4                 cmp     dword ptr [ecx+7Ch], 0
.text$mn:00000DF8                 jz      short loc_E5B
.text$mn:00000DFA                 mov     edx, [ebp+var_30]
.text$mn:00000DFD                 mov     eax, [ebp+hWnd]
.text$mn:00000E00                 cmp     eax, [edx+7Ch]
.text$mn:00000E03                 jnz     short loc_E11
.text$mn:00000E05                 mov     ecx, [ebp+var_30]
.text$mn:00000E08                 cmp     dword ptr [ecx+88h], 0FFFFFFFFh
.text$mn:00000E0F                 jnz     short loc_E5B
.text$mn:00000E11
.text$mn:00000E11 loc_E11:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+1DFj
.text$mn:00000E11                 push    0               ; lParam
.text$mn:00000E13                 push    0               ; wParam
.text$mn:00000E15                 push    1304h           ; Msg
.text$mn:00000E1A                 mov     edx, [ebp+hWnd]
.text$mn:00000E1D                 push    edx             ; hWnd
.text$mn:00000E1E                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E24                 sub     eax, 1
.text$mn:00000E27                 mov     [ebp+var_4C], eax
.text$mn:00000E2A                 lea     eax, [ebp+Rect]
.text$mn:00000E2D                 push    eax             ; lParam
.text$mn:00000E2E                 mov     ecx, [ebp+var_4C]
.text$mn:00000E31                 push    ecx             ; wParam
.text$mn:00000E32                 push    130Ah           ; Msg
.text$mn:00000E37                 mov     edx, [ebp+hWnd]
.text$mn:00000E3A                 push    edx             ; hWnd
.text$mn:00000E3B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000E41                 mov     eax, [ebp+Rect.left]
.text$mn:00000E44                 add     eax, [ebp+Rect.right]
.text$mn:00000E47                 cmp     eax, [ebp+pt.x]
.text$mn:00000E4A                 jge     short loc_E5B
.text$mn:00000E4C                 mov     ecx, [ebp+var_4C]
.text$mn:00000E4F                 add     ecx, 1
.text$mn:00000E52                 mov     edx, [ebp+var_30]
.text$mn:00000E55                 mov     [edx+88h], ecx
.text$mn:00000E5B
.text$mn:00000E5B loc_E5B:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+1CBj
.text$mn:00000E5B                                         ; Gripper::doTabReordering(tagPOINT)+1D4j ...
.text$mn:00000E5B                 mov     eax, [ebp+var_30]
.text$mn:00000E5E                 mov     ecx, [ebp+hWnd]
.text$mn:00000E61                 mov     [eax+7Ch], ecx
.text$mn:00000E64                 mov     [ebp+var_48], 1
.text$mn:00000E6B                 jmp     short loc_E72
.text$mn:00000E6D ; ---------------------------------------------------------------------------
.text$mn:00000E6D
.text$mn:00000E6D loc_E6D:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+BCj
.text$mn:00000E6D                                         ; Gripper::doTabReordering(tagPOINT)+F7j
.text$mn:00000E6D                 jmp     loc_CA8
.text$mn:00000E72 ; ---------------------------------------------------------------------------
.text$mn:00000E72
.text$mn:00000E72 loc_E72:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+93j
.text$mn:00000E72                                         ; Gripper::doTabReordering(tagPOINT)+247j
.text$mn:00000E72                 cmp     [ebp+var_48], 1
.text$mn:00000E76                 jnz     short loc_EEF
.text$mn:00000E78                 mov     edx, [ebp+var_30]
.text$mn:00000E7B                 mov     eax, [ebp+var_38]
.text$mn:00000E7E                 cmp     eax, [edx+88h]
.text$mn:00000E84                 jz      short loc_EEF
.text$mn:00000E86                 mov     ecx, [ebp+var_30]
.text$mn:00000E89                 mov     edx, [ebp+var_30]
.text$mn:00000E8C                 mov     eax, [ecx+7Ch]
.text$mn:00000E8F                 cmp     eax, [edx+80h]
.text$mn:00000E95                 jnz     short loc_ECA
.text$mn:00000E97                 push    0               ; lParam
.text$mn:00000E99                 push    0               ; wParam
.text$mn:00000E9B                 push    130Bh           ; Msg
.text$mn:00000EA0                 mov     ecx, [ebp+var_30]
.text$mn:00000EA3                 mov     edx, [ecx+7Ch]
.text$mn:00000EA6                 push    edx             ; hWnd
.text$mn:00000EA7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000EAD                 mov     [ebp+var_58], eax
.text$mn:00000EB0                 push    0               ; lParam
.text$mn:00000EB2                 mov     eax, [ebp+var_58]
.text$mn:00000EB5                 push    eax             ; wParam
.text$mn:00000EB6                 push    1308h           ; Msg
.text$mn:00000EBB                 mov     ecx, [ebp+var_30]
.text$mn:00000EBE                 mov     edx, [ecx+7Ch]
.text$mn:00000EC1                 push    edx             ; hWnd
.text$mn:00000EC2                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000EC8                 jmp     short loc_EED
.text$mn:00000ECA ; ---------------------------------------------------------------------------
.text$mn:00000ECA
.text$mn:00000ECA loc_ECA:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+271j
.text$mn:00000ECA                 mov     eax, [ebp+var_30]
.text$mn:00000ECD                 mov     ecx, [eax+7Ch]
.text$mn:00000ED0                 cmp     ecx, [ebp+var_3C]
.text$mn:00000ED3                 jnz     short loc_EED
.text$mn:00000ED5                 push    0               ; lParam
.text$mn:00000ED7                 mov     edx, [ebp+var_38]
.text$mn:00000EDA                 push    edx             ; wParam
.text$mn:00000EDB                 push    1308h           ; Msg
.text$mn:00000EE0                 mov     eax, [ebp+var_30]
.text$mn:00000EE3                 mov     ecx, [eax+7Ch]
.text$mn:00000EE6                 push    ecx             ; hWnd
.text$mn:00000EE7                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000EED
.text$mn:00000EED loc_EED:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+2A4j
.text$mn:00000EED                                         ; Gripper::doTabReordering(tagPOINT)+2AFj
.text$mn:00000EED                 jmp     short loc_F25
.text$mn:00000EEF ; ---------------------------------------------------------------------------
.text$mn:00000EEF
.text$mn:00000EEF loc_EEF:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+252j
.text$mn:00000EEF                                         ; Gripper::doTabReordering(tagPOINT)+260j
.text$mn:00000EEF                 cmp     [ebp+var_48], 0
.text$mn:00000EF3                 jnz     short loc_F25
.text$mn:00000EF5                 mov     edx, [ebp+var_30]
.text$mn:00000EF8                 mov     eax, [ebp+var_3C]
.text$mn:00000EFB                 cmp     eax, [edx+80h]
.text$mn:00000F01                 jz      short loc_F18
.text$mn:00000F03                 push    0               ; lParam
.text$mn:00000F05                 mov     ecx, [ebp+var_38]
.text$mn:00000F08                 push    ecx             ; wParam
.text$mn:00000F09                 push    1308h           ; Msg
.text$mn:00000F0E                 mov     edx, [ebp+var_3C]
.text$mn:00000F11                 push    edx             ; hWnd
.text$mn:00000F12                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000F18
.text$mn:00000F18 loc_F18:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+2DDj
.text$mn:00000F18                 mov     eax, [ebp+var_30]
.text$mn:00000F1B                 mov     dword ptr [eax+88h], 0FFFFFFFFh
.text$mn:00000F25
.text$mn:00000F25 loc_F25:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT):loc_EEDj
.text$mn:00000F25                                         ; Gripper::doTabReordering(tagPOINT)+2CFj
.text$mn:00000F25                 mov     ecx, [ebp+var_30]
.text$mn:00000F28                 cmp     dword ptr [ecx+7Ch], 0
.text$mn:00000F2C                 jz      short loc_F9D
.text$mn:00000F2E                 mov     edx, [ebp+var_30]
.text$mn:00000F31                 mov     eax, [edx+7Ch]
.text$mn:00000F34                 cmp     eax, [ebp+var_3C]
.text$mn:00000F37                 jnz     short loc_F47
.text$mn:00000F39                 mov     ecx, [ebp+var_30]
.text$mn:00000F3C                 mov     edx, [ecx+88h]
.text$mn:00000F42                 cmp     edx, [ebp+var_38]
.text$mn:00000F45                 jz      short loc_F9D
.text$mn:00000F47
.text$mn:00000F47 loc_F47:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+313j
.text$mn:00000F47                 mov     eax, [ebp+var_30]
.text$mn:00000F4A                 mov     ecx, [ebp+var_30]
.text$mn:00000F4D                 mov     edx, [eax+7Ch]
.text$mn:00000F50                 cmp     edx, [ecx+80h]
.text$mn:00000F56                 jnz     short loc_F61
.text$mn:00000F58                 mov     [ebp+var_50], 1
.text$mn:00000F5F                 jmp     short loc_F68
.text$mn:00000F61 ; ---------------------------------------------------------------------------
.text$mn:00000F61
.text$mn:00000F61 loc_F61:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+332j
.text$mn:00000F61                 mov     [ebp+var_50], 0
.text$mn:00000F68
.text$mn:00000F68 loc_F68:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+33Bj
.text$mn:00000F68                 mov     eax, [ebp+var_50]
.text$mn:00000F6B                 or      eax, 8
.text$mn:00000F6E                 mov     ecx, [ebp+var_30]
.text$mn:00000F71                 mov     [ecx+9Ch], eax
.text$mn:00000F77                 mov     edx, [ebp+var_30]
.text$mn:00000F7A                 add     edx, 9Ch ; '£'
.text$mn:00000F80                 push    edx             ; lParam
.text$mn:00000F81                 mov     eax, [ebp+var_30]
.text$mn:00000F84                 mov     ecx, [eax+88h]
.text$mn:00000F8A                 push    ecx             ; wParam
.text$mn:00000F8B                 push    133Eh           ; Msg
.text$mn:00000F90                 mov     edx, [ebp+var_30]
.text$mn:00000F93                 mov     eax, [edx+7Ch]
.text$mn:00000F96                 push    eax             ; hWnd
.text$mn:00000F97                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000F9D
.text$mn:00000F9D loc_F9D:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+308j
.text$mn:00000F9D                                         ; Gripper::doTabReordering(tagPOINT)+321j
.text$mn:00000F9D                 mov     ecx, [ebp+var_30]
.text$mn:00000FA0                 mov     edx, [ebp+var_30]
.text$mn:00000FA3                 mov     eax, [ecx+7Ch]
.text$mn:00000FA6                 cmp     eax, [edx+80h]
.text$mn:00000FAC                 jnz     short loc_FD8
.text$mn:00000FAE                 mov     ecx, [ebp+var_30]
.text$mn:00000FB1                 cmp     dword ptr [ecx+88h], 0FFFFFFFFh
.text$mn:00000FB8                 jz      short loc_FD8
.text$mn:00000FBA                 push    0               ; lParam
.text$mn:00000FBC                 mov     edx, [ebp+var_30]
.text$mn:00000FBF                 mov     eax, [edx+88h]
.text$mn:00000FC5                 push    eax             ; wParam
.text$mn:00000FC6                 push    130Ch           ; Msg
.text$mn:00000FCB                 mov     ecx, [ebp+var_30]
.text$mn:00000FCE                 mov     edx, [ecx+7Ch]
.text$mn:00000FD1                 push    edx             ; hWnd
.text$mn:00000FD2                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00000FD8
.text$mn:00000FD8 loc_FD8:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+388j
.text$mn:00000FD8                                         ; Gripper::doTabReordering(tagPOINT)+394j
.text$mn:00000FD8                 mov     eax, [ebp+var_30]
.text$mn:00000FDB                 mov     ecx, [eax+4]
.text$mn:00000FDE                 push    ecx             ; hWnd
.text$mn:00000FDF                 call    dword ptr ds:__imp__UpdateWindow@4 ; UpdateWindow(x)
.text$mn:00000FE5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00000FEC                 lea     ecx, [ebp+var_68]
.text$mn:00000FEF                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:00000FF4
.text$mn:00000FF4 loc_FF4:                                ; CODE XREF: Gripper::doTabReordering(tagPOINT)+1BAj
.text$mn:00000FF4                 mov     ecx, [ebp+var_C]
.text$mn:00000FF7                 mov     large fs:0, ecx
.text$mn:00000FFE                 pop     ecx
.text$mn:00000FFF                 mov     ecx, [ebp+var_10]
.text$mn:00001002                 xor     ecx, ebp
.text$mn:00001004                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001009                 mov     esp, ebp
.text$mn:0000100B                 pop     ebp
.text$mn:0000100C                 retn    8
.text$mn:0000100C ?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z endp
.text$mn:0000100C
.text$mn:0000100C ; ---------------------------------------------------------------------------
.text$mn:0000100F                 db 5 dup(0CCh)
.text$mn:00001014
.text$mn:00001014 ; =============== S U B R O U T I N E =======================================
.text$mn:00001014
.text$mn:00001014 ; Attributes: bp-based frame
.text$mn:00001014
.text$mn:00001014 ; void __thiscall Gripper::drawRectangle(Gripper *this, const struct tagPOINT *)
.text$mn:00001014                 public ?drawRectangle@Gripper@@IAEXPBUtagPOINT@@@Z
.text$mn:00001014 ?drawRectangle@Gripper@@IAEXPBUtagPOINT@@@Z proc near
.text$mn:00001014                                         ; CODE XREF: Gripper::runProc(uint,uint,long)+10Fp
.text$mn:00001014                                         ; Gripper::onMove(void)+62p ...
.text$mn:00001014
.text$mn:00001014 var_60          = dword ptr -60h
.text$mn:00001014 var_5C          = dword ptr -5Ch
.text$mn:00001014 var_58          = dword ptr -58h
.text$mn:00001014 flags           = dword ptr -54h
.text$mn:00001014 hWndLock        = dword ptr -50h
.text$mn:00001014 var_4C          = dword ptr -4Ch
.text$mn:00001014 h               = dword ptr -48h
.text$mn:00001014 var_44          = dword ptr -44h
.text$mn:00001014 var_40          = dword ptr -40h
.text$mn:00001014 hdc             = dword ptr -3Ch
.text$mn:00001014 var_38          = dword ptr -38h
.text$mn:00001014 x1              = dword ptr -34h
.text$mn:00001014 y1              = dword ptr -30h
.text$mn:00001014 var_2C          = dword ptr -2Ch
.text$mn:00001014 cy              = dword ptr -28h
.text$mn:00001014 x               = dword ptr -24h
.text$mn:00001014 y               = dword ptr -20h
.text$mn:00001014 w               = dword ptr -1Ch
.text$mn:00001014 var_18          = dword ptr -18h
.text$mn:00001014 var_14          = tagRECT ptr -14h
.text$mn:00001014 var_4           = dword ptr -4
.text$mn:00001014 arg_0           = dword ptr  8
.text$mn:00001014
.text$mn:00001014                 push    ebp
.text$mn:00001015                 mov     ebp, esp
.text$mn:00001017                 sub     esp, 60h
.text$mn:0000101A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000101F                 xor     eax, ebp
.text$mn:00001021                 mov     [ebp+var_4], eax
.text$mn:00001024                 mov     [ebp+var_38], ecx
.text$mn:00001027                 mov     [ebp+var_5C], 0
.text$mn:0000102E                 mov     [ebp+var_44], 0
.text$mn:00001035                 mov     [ebp+x1], 0
.text$mn:0000103C                 xor     eax, eax
.text$mn:0000103E                 mov     [ebp+y1], eax
.text$mn:00001041                 mov     [ebp+var_2C], eax
.text$mn:00001044                 mov     [ebp+cy], eax
.text$mn:00001047                 mov     [ebp+var_14.left], 0
.text$mn:0000104E                 xor     ecx, ecx
.text$mn:00001050                 mov     [ebp+var_14.top], ecx
.text$mn:00001053                 mov     [ebp+var_14.right], ecx
.text$mn:00001056                 mov     [ebp+var_14.bottom], ecx
.text$mn:00001059                 mov     edx, [ebp+var_38]
.text$mn:0000105C                 add     edx, 6Ch ; 'l'
.text$mn:0000105F                 mov     eax, [edx]
.text$mn:00001061                 mov     [ebp+x], eax
.text$mn:00001064                 mov     ecx, [edx+4]
.text$mn:00001067                 mov     [ebp+y], ecx
.text$mn:0000106A                 mov     eax, [edx+8]
.text$mn:0000106D                 mov     [ebp+w], eax
.text$mn:00001070                 mov     ecx, [edx+0Ch]
.text$mn:00001073                 mov     [ebp+var_18], ecx
.text$mn:00001076                 mov     edx, [ebp+var_38]
.text$mn:00001079                 cmp     dword ptr [edx+0B8h], 0
.text$mn:00001080                 jnz     short loc_10C2
.text$mn:00001082                 call    dword ptr ds:__imp__GetDesktopWindow@0 ; GetDesktopWindow()
.text$mn:00001088                 mov     [ebp+hWndLock], eax
.text$mn:0000108B                 mov     eax, [ebp+hWndLock]
.text$mn:0000108E                 push    eax             ; hWndLock
.text$mn:0000108F                 call    dword ptr ds:__imp__LockWindowUpdate@4 ; LockWindowUpdate(x)
.text$mn:00001095                 test    eax, eax
.text$mn:00001097                 jz      short loc_10A2
.text$mn:00001099                 mov     [ebp+flags], 403h
.text$mn:000010A0                 jmp     short loc_10A9
.text$mn:000010A2 ; ---------------------------------------------------------------------------
.text$mn:000010A2
.text$mn:000010A2 loc_10A2:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+83j
.text$mn:000010A2                 mov     [ebp+flags], 3
.text$mn:000010A9
.text$mn:000010A9 loc_10A9:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+8Cj
.text$mn:000010A9                 mov     ecx, [ebp+flags]
.text$mn:000010AC                 push    ecx             ; flags
.text$mn:000010AD                 push    0               ; hrgnClip
.text$mn:000010AF                 mov     edx, [ebp+hWndLock]
.text$mn:000010B2                 push    edx             ; hWnd
.text$mn:000010B3                 call    dword ptr ds:__imp__GetDCEx@12 ; GetDCEx(x,x,x)
.text$mn:000010B9                 mov     ecx, [ebp+var_38]
.text$mn:000010BC                 mov     [ecx+0B8h], eax
.text$mn:000010C2
.text$mn:000010C2 loc_10C2:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+6Cj
.text$mn:000010C2                 mov     edx, [ebp+var_38]
.text$mn:000010C5                 cmp     dword ptr [edx+0BCh], 0
.text$mn:000010CC                 jnz     short loc_10EA
.text$mn:000010CE                 push    offset _DotPattern ; "ªUªUªUªU"
.text$mn:000010D3                 push    1               ; nBitCount
.text$mn:000010D5                 push    1               ; nPlanes
.text$mn:000010D7                 push    8               ; nHeight
.text$mn:000010D9                 push    8               ; nWidth
.text$mn:000010DB                 call    dword ptr ds:__imp__CreateBitmap@20 ; CreateBitmap(x,x,x,x,x)
.text$mn:000010E1                 mov     ecx, [ebp+var_38]
.text$mn:000010E4                 mov     [ecx+0BCh], eax
.text$mn:000010EA
.text$mn:000010EA loc_10EA:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+B8j
.text$mn:000010EA                 mov     edx, [ebp+var_38]
.text$mn:000010ED                 cmp     dword ptr [edx+0C0h], 0
.text$mn:000010F4                 jnz     short loc_110F
.text$mn:000010F6                 mov     eax, [ebp+var_38]
.text$mn:000010F9                 mov     ecx, [eax+0BCh]
.text$mn:000010FF                 push    ecx             ; hbm
.text$mn:00001100                 call    dword ptr ds:__imp__CreatePatternBrush@4 ; CreatePatternBrush(x)
.text$mn:00001106                 mov     edx, [ebp+var_38]
.text$mn:00001109                 mov     [edx+0C0h], eax
.text$mn:0000110F
.text$mn:0000110F loc_110F:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+E0j
.text$mn:0000110F                 cmp     [ebp+arg_0], 0
.text$mn:00001113                 jz      loc_1238
.text$mn:00001119                 lea     eax, [ebp+var_14]
.text$mn:0000111C                 push    eax             ; struct tagRECT *
.text$mn:0000111D                 mov     ecx, [ebp+arg_0]
.text$mn:00001120                 mov     edx, [ecx+4]
.text$mn:00001123                 push    edx
.text$mn:00001124                 mov     eax, [ecx]
.text$mn:00001126                 push    eax             ; pt
.text$mn:00001127                 mov     ecx, [ebp+var_38] ; this
.text$mn:0000112A                 call    ?getMovingRect@Gripper@@IAEXUtagPOINT@@PAUtagRECT@@@Z ; Gripper::getMovingRect(tagPOINT,tagRECT *)
.text$mn:0000112F                 mov     ecx, [ebp+var_38]
.text$mn:00001132                 add     ecx, 6Ch ; 'l'
.text$mn:00001135                 mov     edx, [ebp+var_14.left]
.text$mn:00001138                 mov     [ecx], edx
.text$mn:0000113A                 mov     eax, [ebp+var_14.top]
.text$mn:0000113D                 mov     [ecx+4], eax
.text$mn:00001140                 mov     edx, [ebp+var_14.right]
.text$mn:00001143                 mov     [ecx+8], edx
.text$mn:00001146                 mov     eax, [ebp+var_14.bottom]
.text$mn:00001149                 mov     [ecx+0Ch], eax
.text$mn:0000114C                 mov     ecx, [ebp+var_38]
.text$mn:0000114F                 cmp     dword ptr [ecx+68h], 0
.text$mn:00001153                 jz      loc_121E
.text$mn:00001159                 mov     edx, [ebp+x]
.text$mn:0000115C                 cmp     edx, [ebp+var_14.left]
.text$mn:0000115F                 jnz     short loc_117E
.text$mn:00001161                 mov     eax, [ebp+w]
.text$mn:00001164                 cmp     eax, [ebp+var_14.right]
.text$mn:00001167                 jnz     short loc_117E
.text$mn:00001169                 mov     ecx, [ebp+y]
.text$mn:0000116C                 cmp     ecx, [ebp+var_14.top]
.text$mn:0000116F                 jnz     short loc_117E
.text$mn:00001171                 mov     edx, [ebp+var_18]
.text$mn:00001174                 cmp     edx, [ebp+var_14.bottom]
.text$mn:00001177                 jnz     short loc_117E
.text$mn:00001179                 jmp     loc_1474
.text$mn:0000117E ; ---------------------------------------------------------------------------
.text$mn:0000117E
.text$mn:0000117E loc_117E:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+14Bj
.text$mn:0000117E                                         ; Gripper::drawRectangle(tagPOINT const *)+153j ...
.text$mn:0000117E                 mov     eax, [ebp+x]
.text$mn:00001181                 cmp     eax, [ebp+var_14.left]
.text$mn:00001184                 jge     short loc_118E
.text$mn:00001186                 mov     ecx, [ebp+x]
.text$mn:00001189                 mov     [ebp+var_58], ecx
.text$mn:0000118C                 jmp     short loc_1194
.text$mn:0000118E ; ---------------------------------------------------------------------------
.text$mn:0000118E
.text$mn:0000118E loc_118E:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+170j
.text$mn:0000118E                 mov     edx, [ebp+var_14.left]
.text$mn:00001191                 mov     [ebp+var_58], edx
.text$mn:00001194
.text$mn:00001194 loc_1194:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+178j
.text$mn:00001194                 mov     eax, [ebp+var_58]
.text$mn:00001197                 mov     [ebp+x1], eax
.text$mn:0000119A                 mov     ecx, [ebp+y]
.text$mn:0000119D                 cmp     ecx, [ebp+var_14.top]
.text$mn:000011A0                 jge     short loc_11AA
.text$mn:000011A2                 mov     edx, [ebp+y]
.text$mn:000011A5                 mov     [ebp+var_60], edx
.text$mn:000011A8                 jmp     short loc_11B0
.text$mn:000011AA ; ---------------------------------------------------------------------------
.text$mn:000011AA
.text$mn:000011AA loc_11AA:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+18Cj
.text$mn:000011AA                 mov     eax, [ebp+var_14.top]
.text$mn:000011AD                 mov     [ebp+var_60], eax
.text$mn:000011B0
.text$mn:000011B0 loc_11B0:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+194j
.text$mn:000011B0                 mov     ecx, [ebp+var_60]
.text$mn:000011B3                 mov     [ebp+y1], ecx
.text$mn:000011B6                 mov     edx, [ebp+x]
.text$mn:000011B9                 add     edx, [ebp+w]
.text$mn:000011BC                 mov     eax, [ebp+var_14.left]
.text$mn:000011BF                 add     eax, [ebp+var_14.right]
.text$mn:000011C2                 cmp     edx, eax
.text$mn:000011C4                 jle     short loc_11D1
.text$mn:000011C6                 mov     ecx, [ebp+x]
.text$mn:000011C9                 add     ecx, [ebp+w]
.text$mn:000011CC                 mov     [ebp+var_40], ecx
.text$mn:000011CF                 jmp     short loc_11DA
.text$mn:000011D1 ; ---------------------------------------------------------------------------
.text$mn:000011D1
.text$mn:000011D1 loc_11D1:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+1B0j
.text$mn:000011D1                 mov     edx, [ebp+var_14.left]
.text$mn:000011D4                 add     edx, [ebp+var_14.right]
.text$mn:000011D7                 mov     [ebp+var_40], edx
.text$mn:000011DA
.text$mn:000011DA loc_11DA:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+1BBj
.text$mn:000011DA                 mov     eax, [ebp+var_40]
.text$mn:000011DD                 mov     [ebp+var_2C], eax
.text$mn:000011E0                 mov     ecx, [ebp+y]
.text$mn:000011E3                 add     ecx, [ebp+var_18]
.text$mn:000011E6                 mov     edx, [ebp+var_14.top]
.text$mn:000011E9                 add     edx, [ebp+var_14.bottom]
.text$mn:000011EC                 cmp     ecx, edx
.text$mn:000011EE                 jle     short loc_11FB
.text$mn:000011F0                 mov     eax, [ebp+y]
.text$mn:000011F3                 add     eax, [ebp+var_18]
.text$mn:000011F6                 mov     [ebp+var_4C], eax
.text$mn:000011F9                 jmp     short loc_1204
.text$mn:000011FB ; ---------------------------------------------------------------------------
.text$mn:000011FB
.text$mn:000011FB loc_11FB:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+1DAj
.text$mn:000011FB                 mov     ecx, [ebp+var_14.top]
.text$mn:000011FE                 add     ecx, [ebp+var_14.bottom]
.text$mn:00001201                 mov     [ebp+var_4C], ecx
.text$mn:00001204
.text$mn:00001204 loc_1204:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+1E5j
.text$mn:00001204                 mov     edx, [ebp+var_4C]
.text$mn:00001207                 mov     [ebp+cy], edx
.text$mn:0000120A                 mov     eax, [ebp+var_2C]
.text$mn:0000120D                 sub     eax, [ebp+x1]
.text$mn:00001210                 mov     [ebp+var_2C], eax
.text$mn:00001213                 mov     ecx, [ebp+cy]
.text$mn:00001216                 sub     ecx, [ebp+y1]
.text$mn:00001219                 mov     [ebp+cy], ecx
.text$mn:0000121C                 jmp     short loc_1236
.text$mn:0000121E ; ---------------------------------------------------------------------------
.text$mn:0000121E
.text$mn:0000121E loc_121E:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+13Fj
.text$mn:0000121E                 mov     edx, [ebp+var_14.left]
.text$mn:00001221                 mov     [ebp+x1], edx
.text$mn:00001224                 mov     eax, [ebp+var_14.top]
.text$mn:00001227                 mov     [ebp+y1], eax
.text$mn:0000122A                 mov     ecx, [ebp+var_14.right]
.text$mn:0000122D                 mov     [ebp+var_2C], ecx
.text$mn:00001230                 mov     edx, [ebp+var_14.bottom]
.text$mn:00001233                 mov     [ebp+cy], edx
.text$mn:00001236
.text$mn:00001236 loc_1236:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+208j
.text$mn:00001236                 jmp     short loc_1250
.text$mn:00001238 ; ---------------------------------------------------------------------------
.text$mn:00001238
.text$mn:00001238 loc_1238:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+FFj
.text$mn:00001238                 mov     eax, [ebp+x]
.text$mn:0000123B                 mov     [ebp+x1], eax
.text$mn:0000123E                 mov     ecx, [ebp+y]
.text$mn:00001241                 mov     [ebp+y1], ecx
.text$mn:00001244                 mov     edx, [ebp+w]
.text$mn:00001247                 mov     [ebp+var_2C], edx
.text$mn:0000124A                 mov     eax, [ebp+var_18]
.text$mn:0000124D                 mov     [ebp+cy], eax
.text$mn:00001250
.text$mn:00001250 loc_1250:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *):loc_1236j
.text$mn:00001250                 mov     ecx, [ebp+x]
.text$mn:00001253                 sub     ecx, [ebp+x1]
.text$mn:00001256                 mov     [ebp+x], ecx
.text$mn:00001259                 mov     edx, [ebp+y]
.text$mn:0000125C                 sub     edx, [ebp+y1]
.text$mn:0000125F                 mov     [ebp+y], edx
.text$mn:00001262                 mov     eax, [ebp+var_14.left]
.text$mn:00001265                 sub     eax, [ebp+x1]
.text$mn:00001268                 mov     [ebp+var_14.left], eax
.text$mn:0000126B                 mov     ecx, [ebp+var_14.top]
.text$mn:0000126E                 sub     ecx, [ebp+y1]
.text$mn:00001271                 mov     [ebp+var_14.top], ecx
.text$mn:00001274                 mov     edx, [ebp+var_38]
.text$mn:00001277                 mov     eax, [edx+0B8h]
.text$mn:0000127D                 push    eax             ; hdc
.text$mn:0000127E                 call    dword ptr ds:__imp__CreateCompatibleDC@4 ; CreateCompatibleDC(x)
.text$mn:00001284                 mov     [ebp+hdc], eax
.text$mn:00001287                 mov     ecx, [ebp+cy]
.text$mn:0000128A                 push    ecx             ; cy
.text$mn:0000128B                 mov     edx, [ebp+var_2C]
.text$mn:0000128E                 push    edx             ; cx
.text$mn:0000128F                 mov     eax, [ebp+var_38]
.text$mn:00001292                 mov     ecx, [eax+0B8h]
.text$mn:00001298                 push    ecx             ; hdc
.text$mn:00001299                 call    dword ptr ds:__imp__CreateCompatibleBitmap@12 ; CreateCompatibleBitmap(x,x,x)
.text$mn:0000129F                 mov     [ebp+h], eax
.text$mn:000012A2                 mov     edx, [ebp+h]
.text$mn:000012A5                 push    edx             ; h
.text$mn:000012A6                 mov     eax, [ebp+hdc]
.text$mn:000012A9                 push    eax             ; hdc
.text$mn:000012AA                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:000012B0                 mov     [ebp+var_5C], eax
.text$mn:000012B3                 push    0               ; lppt
.text$mn:000012B5                 mov     ecx, [ebp+y1]
.text$mn:000012B8                 and     ecx, 80000007h
.text$mn:000012BE                 jns     short loc_12C5
.text$mn:000012C0                 dec     ecx
.text$mn:000012C1                 or      ecx, 0FFFFFFF8h
.text$mn:000012C4                 inc     ecx
.text$mn:000012C5
.text$mn:000012C5 loc_12C5:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+2AAj
.text$mn:000012C5                 push    ecx             ; y
.text$mn:000012C6                 mov     edx, [ebp+x1]
.text$mn:000012C9                 and     edx, 80000007h
.text$mn:000012CF                 jns     short loc_12D6
.text$mn:000012D1                 dec     edx
.text$mn:000012D2                 or      edx, 0FFFFFFF8h
.text$mn:000012D5                 inc     edx
.text$mn:000012D6
.text$mn:000012D6 loc_12D6:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+2BBj
.text$mn:000012D6                 push    edx             ; x
.text$mn:000012D7                 mov     eax, [ebp+hdc]
.text$mn:000012DA                 push    eax             ; hdc
.text$mn:000012DB                 call    dword ptr ds:__imp__SetBrushOrgEx@16 ; SetBrushOrgEx(x,x,x,x)
.text$mn:000012E1                 mov     ecx, [ebp+var_38]
.text$mn:000012E4                 mov     edx, [ecx+0C0h]
.text$mn:000012EA                 push    edx             ; h
.text$mn:000012EB                 mov     eax, [ebp+hdc]
.text$mn:000012EE                 push    eax             ; hdc
.text$mn:000012EF                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:000012F5                 mov     [ebp+var_44], eax
.text$mn:000012F8                 push    0CC0020h        ; rop
.text$mn:000012FD                 mov     ecx, [ebp+y1]
.text$mn:00001300                 push    ecx             ; y1
.text$mn:00001301                 mov     edx, [ebp+x1]
.text$mn:00001304                 push    edx             ; x1
.text$mn:00001305                 mov     eax, [ebp+var_38]
.text$mn:00001308                 mov     ecx, [eax+0B8h]
.text$mn:0000130E                 push    ecx             ; hdcSrc
.text$mn:0000130F                 mov     edx, [ebp+cy]
.text$mn:00001312                 push    edx             ; cy
.text$mn:00001313                 mov     eax, [ebp+var_2C]
.text$mn:00001316                 push    eax             ; cx
.text$mn:00001317                 push    0               ; y
.text$mn:00001319                 push    0               ; x
.text$mn:0000131B                 mov     ecx, [ebp+hdc]
.text$mn:0000131E                 push    ecx             ; hdc
.text$mn:0000131F                 call    dword ptr ds:__imp__BitBlt@36 ; BitBlt(x,x,x,x,x,x,x,x,x)
.text$mn:00001325                 mov     edx, [ebp+var_38]
.text$mn:00001328                 cmp     dword ptr [edx+68h], 0
.text$mn:0000132C                 jz      short loc_1378
.text$mn:0000132E                 push    5A0049h         ; rop
.text$mn:00001333                 mov     eax, [ebp+var_18]
.text$mn:00001336                 push    eax             ; h
.text$mn:00001337                 mov     ecx, [ebp+w]
.text$mn:0000133A                 push    ecx             ; w
.text$mn:0000133B                 mov     edx, [ebp+y]
.text$mn:0000133E                 push    edx             ; y
.text$mn:0000133F                 mov     eax, [ebp+x]
.text$mn:00001342                 push    eax             ; x
.text$mn:00001343                 mov     ecx, [ebp+hdc]
.text$mn:00001346                 push    ecx             ; hdc
.text$mn:00001347                 call    dword ptr ds:__imp__PatBlt@24 ; PatBlt(x,x,x,x,x,x)
.text$mn:0000134D                 push    5A0049h         ; rop
.text$mn:00001352                 mov     edx, [ebp+var_18]
.text$mn:00001355                 sub     edx, 6
.text$mn:00001358                 push    edx             ; h
.text$mn:00001359                 mov     eax, [ebp+w]
.text$mn:0000135C                 sub     eax, 6
.text$mn:0000135F                 push    eax             ; w
.text$mn:00001360                 mov     ecx, [ebp+y]
.text$mn:00001363                 add     ecx, 3
.text$mn:00001366                 push    ecx             ; y
.text$mn:00001367                 mov     edx, [ebp+x]
.text$mn:0000136A                 add     edx, 3
.text$mn:0000136D                 push    edx             ; x
.text$mn:0000136E                 mov     eax, [ebp+hdc]
.text$mn:00001371                 push    eax             ; hdc
.text$mn:00001372                 call    dword ptr ds:__imp__PatBlt@24 ; PatBlt(x,x,x,x,x,x)
.text$mn:00001378
.text$mn:00001378 loc_1378:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+318j
.text$mn:00001378                 cmp     [ebp+arg_0], 0
.text$mn:0000137C                 jz      short loc_13C8
.text$mn:0000137E                 push    5A0049h         ; rop
.text$mn:00001383                 mov     ecx, [ebp+var_14.bottom]
.text$mn:00001386                 push    ecx             ; h
.text$mn:00001387                 mov     edx, [ebp+var_14.right]
.text$mn:0000138A                 push    edx             ; w
.text$mn:0000138B                 mov     eax, [ebp+var_14.top]
.text$mn:0000138E                 push    eax             ; y
.text$mn:0000138F                 mov     ecx, [ebp+var_14.left]
.text$mn:00001392                 push    ecx             ; x
.text$mn:00001393                 mov     edx, [ebp+hdc]
.text$mn:00001396                 push    edx             ; hdc
.text$mn:00001397                 call    dword ptr ds:__imp__PatBlt@24 ; PatBlt(x,x,x,x,x,x)
.text$mn:0000139D                 push    5A0049h         ; rop
.text$mn:000013A2                 mov     eax, [ebp+var_14.bottom]
.text$mn:000013A5                 sub     eax, 6
.text$mn:000013A8                 push    eax             ; h
.text$mn:000013A9                 mov     ecx, [ebp+var_14.right]
.text$mn:000013AC                 sub     ecx, 6
.text$mn:000013AF                 push    ecx             ; w
.text$mn:000013B0                 mov     edx, [ebp+var_14.top]
.text$mn:000013B3                 add     edx, 3
.text$mn:000013B6                 push    edx             ; y
.text$mn:000013B7                 mov     eax, [ebp+var_14.left]
.text$mn:000013BA                 add     eax, 3
.text$mn:000013BD                 push    eax             ; x
.text$mn:000013BE                 mov     ecx, [ebp+hdc]
.text$mn:000013C1                 push    ecx             ; hdc
.text$mn:000013C2                 call    dword ptr ds:__imp__PatBlt@24 ; PatBlt(x,x,x,x,x,x)
.text$mn:000013C8
.text$mn:000013C8 loc_13C8:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+368j
.text$mn:000013C8                 push    0CC0020h        ; rop
.text$mn:000013CD                 push    0               ; y1
.text$mn:000013CF                 push    0               ; x1
.text$mn:000013D1                 mov     edx, [ebp+hdc]
.text$mn:000013D4                 push    edx             ; hdcSrc
.text$mn:000013D5                 mov     eax, [ebp+cy]
.text$mn:000013D8                 push    eax             ; cy
.text$mn:000013D9                 mov     ecx, [ebp+var_2C]
.text$mn:000013DC                 push    ecx             ; cx
.text$mn:000013DD                 mov     edx, [ebp+y1]
.text$mn:000013E0                 push    edx             ; y
.text$mn:000013E1                 mov     eax, [ebp+x1]
.text$mn:000013E4                 push    eax             ; x
.text$mn:000013E5                 mov     ecx, [ebp+var_38]
.text$mn:000013E8                 mov     edx, [ecx+0B8h]
.text$mn:000013EE                 push    edx             ; hdc
.text$mn:000013EF                 call    dword ptr ds:__imp__BitBlt@36 ; BitBlt(x,x,x,x,x,x,x,x,x)
.text$mn:000013F5                 mov     eax, [ebp+var_5C]
.text$mn:000013F8                 push    eax             ; h
.text$mn:000013F9                 mov     ecx, [ebp+hdc]
.text$mn:000013FC                 push    ecx             ; hdc
.text$mn:000013FD                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00001403                 mov     edx, [ebp+var_44]
.text$mn:00001406                 push    edx             ; h
.text$mn:00001407                 mov     eax, [ebp+hdc]
.text$mn:0000140A                 push    eax             ; hdc
.text$mn:0000140B                 call    dword ptr ds:__imp__SelectObject@8 ; SelectObject(x,x)
.text$mn:00001411                 mov     ecx, [ebp+h]
.text$mn:00001414                 push    ecx             ; ho
.text$mn:00001415                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000141B                 mov     edx, [ebp+hdc]
.text$mn:0000141E                 push    edx             ; hdc
.text$mn:0000141F                 call    dword ptr ds:__imp__DeleteDC@4 ; DeleteDC(x)
.text$mn:00001425                 cmp     [ebp+arg_0], 0
.text$mn:00001429                 jnz     short loc_146A
.text$mn:0000142B                 push    0               ; hWndLock
.text$mn:0000142D                 call    dword ptr ds:__imp__LockWindowUpdate@4 ; LockWindowUpdate(x)
.text$mn:00001433                 mov     eax, [ebp+var_38]
.text$mn:00001436                 mov     dword ptr [eax+68h], 0
.text$mn:0000143D                 mov     ecx, [ebp+var_38]
.text$mn:00001440                 cmp     dword ptr [ecx+0B8h], 0
.text$mn:00001447                 jz      short loc_1468
.text$mn:00001449                 mov     edx, [ebp+var_38]
.text$mn:0000144C                 mov     eax, [edx+0B8h]
.text$mn:00001452                 push    eax             ; hDC
.text$mn:00001453                 push    0               ; hWnd
.text$mn:00001455                 call    dword ptr ds:__imp__ReleaseDC@8 ; ReleaseDC(x,x)
.text$mn:0000145B                 mov     ecx, [ebp+var_38]
.text$mn:0000145E                 mov     dword ptr [ecx+0B8h], 0
.text$mn:00001468
.text$mn:00001468 loc_1468:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+433j
.text$mn:00001468                 jmp     short loc_1474
.text$mn:0000146A ; ---------------------------------------------------------------------------
.text$mn:0000146A
.text$mn:0000146A loc_146A:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+415j
.text$mn:0000146A                 mov     edx, [ebp+var_38]
.text$mn:0000146D                 mov     dword ptr [edx+68h], 1
.text$mn:00001474
.text$mn:00001474 loc_1474:                               ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+165j
.text$mn:00001474                                         ; Gripper::drawRectangle(tagPOINT const *):loc_1468j
.text$mn:00001474                 mov     ecx, [ebp+var_4]
.text$mn:00001477                 xor     ecx, ebp
.text$mn:00001479                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:0000147E                 mov     esp, ebp
.text$mn:00001480                 pop     ebp
.text$mn:00001481                 retn    4
.text$mn:00001481 ?drawRectangle@Gripper@@IAEXPBUtagPOINT@@@Z endp
.text$mn:00001481
.text$mn:00001484
.text$mn:00001484 ; =============== S U B R O U T I N E =======================================
.text$mn:00001484
.text$mn:00001484 ; Attributes: bp-based frame
.text$mn:00001484
.text$mn:00001484 ; void __thiscall Gripper::getMousePoints(Gripper *this, struct tagPOINT *, struct tagPOINT *)
.text$mn:00001484                 public ?getMousePoints@Gripper@@IAEXPAUtagPOINT@@0@Z
.text$mn:00001484 ?getMousePoints@Gripper@@IAEXPAUtagPOINT@@0@Z proc near
.text$mn:00001484                                         ; CODE XREF: Gripper::runProc(uint,uint,long)+105p
.text$mn:00001484                                         ; Gripper::onMove(void)+3Ap ...
.text$mn:00001484
.text$mn:00001484 var_4           = dword ptr -4
.text$mn:00001484 arg_0           = dword ptr  8
.text$mn:00001484 arg_4           = dword ptr  0Ch
.text$mn:00001484
.text$mn:00001484                 push    ebp
.text$mn:00001485                 mov     ebp, esp
.text$mn:00001487                 push    ecx
.text$mn:00001488                 mov     [ebp+var_4], ecx
.text$mn:0000148B                 mov     eax, [ebp+var_4]
.text$mn:0000148E                 mov     ecx, [eax+60h]
.text$mn:00001491                 mov     edx, [eax+64h]
.text$mn:00001494                 mov     eax, [ebp+arg_4]
.text$mn:00001497                 mov     [eax], ecx
.text$mn:00001499                 mov     [eax+4], edx
.text$mn:0000149C                 mov     ecx, [ebp+arg_0]
.text$mn:0000149F                 mov     edx, [ecx]
.text$mn:000014A1                 mov     eax, [ecx+4]
.text$mn:000014A4                 mov     ecx, [ebp+var_4]
.text$mn:000014A7                 mov     [ecx+60h], edx
.text$mn:000014AA                 mov     [ecx+64h], eax
.text$mn:000014AD                 mov     esp, ebp
.text$mn:000014AF                 pop     ebp
.text$mn:000014B0                 retn    8
.text$mn:000014B0 ?getMousePoints@Gripper@@IAEXPAUtagPOINT@@0@Z endp
.text$mn:000014B0
.text$mn:000014B0 ; ---------------------------------------------------------------------------
.text$mn:000014B3                 align 4
.text$mn:000014B4
.text$mn:000014B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000014B4
.text$mn:000014B4 ; Attributes: bp-based frame
.text$mn:000014B4
.text$mn:000014B4 ; void __thiscall Gripper::getMovingRect(Gripper *this, POINT pt, struct tagRECT *)
.text$mn:000014B4                 public ?getMovingRect@Gripper@@IAEXUtagPOINT@@PAUtagRECT@@@Z
.text$mn:000014B4 ?getMovingRect@Gripper@@IAEXUtagPOINT@@PAUtagRECT@@@Z proc near
.text$mn:000014B4                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+116p
.text$mn:000014B4
.text$mn:000014B4 var_1C          = dword ptr -1Ch
.text$mn:000014B4 var_18          = dword ptr -18h
.text$mn:000014B4 var_14          = tagRECT ptr -14h
.text$mn:000014B4 var_4           = dword ptr -4
.text$mn:000014B4 pt              = POINT ptr  8
.text$mn:000014B4 lpRect          = dword ptr  10h
.text$mn:000014B4
.text$mn:000014B4                 push    ebp
.text$mn:000014B5                 mov     ebp, esp
.text$mn:000014B7                 sub     esp, 1Ch
.text$mn:000014BA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000014BF                 xor     eax, ebp
.text$mn:000014C1                 mov     [ebp+var_4], eax
.text$mn:000014C4                 mov     [ebp+var_18], ecx
.text$mn:000014C7                 mov     [ebp+var_14.left], 0
.text$mn:000014CE                 xor     eax, eax
.text$mn:000014D0                 mov     [ebp+var_14.top], eax
.text$mn:000014D3                 mov     [ebp+var_14.right], eax
.text$mn:000014D6                 mov     [ebp+var_14.bottom], eax
.text$mn:000014D9                 mov     [ebp+var_1C], 0
.text$mn:000014E0                 mov     ecx, [ebp+pt.y]
.text$mn:000014E3                 push    ecx
.text$mn:000014E4                 mov     edx, [ebp+pt.x]
.text$mn:000014E7                 push    edx             ; struct tagPOINT
.text$mn:000014E8                 mov     ecx, [ebp+var_18] ; this
.text$mn:000014EB                 call    ?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z ; Gripper::contHitTest(tagPOINT)
.text$mn:000014F0                 mov     [ebp+var_1C], eax
.text$mn:000014F3                 cmp     [ebp+var_1C], 0
.text$mn:000014F7                 jz      loc_15AE
.text$mn:000014FD                 mov     eax, [ebp+lpRect]
.text$mn:00001500                 push    eax             ; lpRect
.text$mn:00001501                 mov     ecx, [ebp+var_1C] ; this
.text$mn:00001504                 call    ?getHSelf@Window@@QBEPAUHWND__@@XZ ; Window::getHSelf(void)
.text$mn:00001509                 push    eax             ; hWnd
.text$mn:0000150A                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:00001510                 mov     ecx, [ebp+var_18]
.text$mn:00001513                 mov     ecx, [ecx+54h]  ; this
.text$mn:00001516                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:0000151B                 movzx   edx, al
.text$mn:0000151E                 cmp     edx, 1
.text$mn:00001521                 jnz     short loc_154A
.text$mn:00001523                 mov     eax, [ebp+var_18]
.text$mn:00001526                 mov     ecx, [eax+54h]  ; this
.text$mn:00001529                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:0000152E                 add     eax, 18h
.text$mn:00001531                 mov     ecx, [eax]
.text$mn:00001533                 mov     [ebp+var_14.left], ecx
.text$mn:00001536                 mov     edx, [eax+4]
.text$mn:00001539                 mov     [ebp+var_14.top], edx
.text$mn:0000153C                 mov     ecx, [eax+8]
.text$mn:0000153F                 mov     [ebp+var_14.right], ecx
.text$mn:00001542                 mov     edx, [eax+0Ch]
.text$mn:00001545                 mov     [ebp+var_14.bottom], edx
.text$mn:00001548                 jmp     short loc_1561
.text$mn:0000154A ; ---------------------------------------------------------------------------
.text$mn:0000154A
.text$mn:0000154A loc_154A:                               ; CODE XREF: Gripper::getMovingRect(tagPOINT,tagRECT *)+6Dj
.text$mn:0000154A                 lea     eax, [ebp+var_14]
.text$mn:0000154D                 push    eax
.text$mn:0000154E                 mov     ecx, [ebp+var_18]
.text$mn:00001551                 mov     edx, [ecx+54h]
.text$mn:00001554                 mov     eax, [ebp+var_18]
.text$mn:00001557                 mov     edx, [edx]
.text$mn:00001559                 mov     ecx, [eax+54h]
.text$mn:0000155C                 mov     eax, [edx+1Ch]
.text$mn:0000155F                 call    eax
.text$mn:00001561
.text$mn:00001561 loc_1561:                               ; CODE XREF: Gripper::getMovingRect(tagPOINT,tagRECT *)+94j
.text$mn:00001561                 mov     ecx, [ebp+lpRect]
.text$mn:00001564                 push    ecx             ; struct tagRECT *
.text$mn:00001565                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001568                 call    ?ShrinkRcToSize@Gripper@@IAEXPAUtagRECT@@@Z ; Gripper::ShrinkRcToSize(tagRECT *)
.text$mn:0000156D                 lea     edx, [ebp+var_14]
.text$mn:00001570                 push    edx             ; struct tagRECT *
.text$mn:00001571                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001574                 call    ?ShrinkRcToSize@Gripper@@IAEXPAUtagRECT@@@Z ; Gripper::ShrinkRcToSize(tagRECT *)
.text$mn:00001579                 mov     eax, [ebp+pt.y]
.text$mn:0000157C                 push    eax
.text$mn:0000157D                 mov     ecx, [ebp+pt.x]
.text$mn:00001580                 push    ecx             ; struct tagPOINT
.text$mn:00001581                 sub     esp, 10h
.text$mn:00001584                 mov     edx, esp
.text$mn:00001586                 mov     eax, [ebp+var_14.left]
.text$mn:00001589                 mov     [edx], eax
.text$mn:0000158B                 mov     ecx, [ebp+var_14.top]
.text$mn:0000158E                 mov     [edx+4], ecx
.text$mn:00001591                 mov     eax, [ebp+var_14.right]
.text$mn:00001594                 mov     [edx+8], eax
.text$mn:00001597                 mov     ecx, [ebp+var_14.bottom]
.text$mn:0000159A                 mov     [edx+0Ch], ecx
.text$mn:0000159D                 mov     edx, [ebp+lpRect]
.text$mn:000015A0                 push    edx             ; struct tagRECT *
.text$mn:000015A1                 mov     ecx, [ebp+var_18] ; this
.text$mn:000015A4                 call    ?DoCalcGripperRect@Gripper@@IAEXPAUtagRECT@@U2@UtagPOINT@@@Z ; Gripper::DoCalcGripperRect(tagRECT *,tagRECT,tagPOINT)
.text$mn:000015A9                 jmp     loc_16AB
.text$mn:000015AE ; ---------------------------------------------------------------------------
.text$mn:000015AE
.text$mn:000015AE loc_15AE:                               ; CODE XREF: Gripper::getMovingRect(tagPOINT,tagRECT *)+43j
.text$mn:000015AE                 mov     eax, [ebp+lpRect]
.text$mn:000015B1                 push    eax             ; struct tagRECT *
.text$mn:000015B2                 mov     ecx, [ebp+pt.y]
.text$mn:000015B5                 push    ecx
.text$mn:000015B6                 mov     edx, [ebp+pt.x]
.text$mn:000015B9                 push    edx             ; pt
.text$mn:000015BA                 mov     ecx, [ebp+var_18] ; this
.text$mn:000015BD                 call    ?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z ; Gripper::workHitTest(tagPOINT,tagRECT *)
.text$mn:000015C2                 mov     [ebp+var_1C], eax
.text$mn:000015C5                 cmp     [ebp+var_1C], 0
.text$mn:000015C9                 jnz     loc_16AB
.text$mn:000015CF                 mov     eax, [ebp+var_18]
.text$mn:000015D2                 mov     ecx, [eax+54h]  ; this
.text$mn:000015D5                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:000015DA                 movzx   ecx, al
.text$mn:000015DD                 test    ecx, ecx
.text$mn:000015DF                 jnz     short loc_160A
.text$mn:000015E1                 mov     edx, [ebp+var_18]
.text$mn:000015E4                 mov     ecx, [edx+54h]  ; this
.text$mn:000015E7                 call    ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ ; DockingCont::getDataOfActiveTb(void)
.text$mn:000015EC                 add     eax, 18h
.text$mn:000015EF                 mov     ecx, [ebp+lpRect]
.text$mn:000015F2                 mov     edx, [eax]
.text$mn:000015F4                 mov     [ecx], edx
.text$mn:000015F6                 mov     edx, [eax+4]
.text$mn:000015F9                 mov     [ecx+4], edx
.text$mn:000015FC                 mov     edx, [eax+8]
.text$mn:000015FF                 mov     [ecx+8], edx
.text$mn:00001602                 mov     eax, [eax+0Ch]
.text$mn:00001605                 mov     [ecx+0Ch], eax
.text$mn:00001608                 jmp     short loc_1621
.text$mn:0000160A ; ---------------------------------------------------------------------------
.text$mn:0000160A
.text$mn:0000160A loc_160A:                               ; CODE XREF: Gripper::getMovingRect(tagPOINT,tagRECT *)+12Bj
.text$mn:0000160A                 mov     ecx, [ebp+lpRect]
.text$mn:0000160D                 push    ecx
.text$mn:0000160E                 mov     edx, [ebp+var_18]
.text$mn:00001611                 mov     eax, [edx+54h]
.text$mn:00001614                 mov     ecx, [ebp+var_18]
.text$mn:00001617                 mov     edx, [eax]
.text$mn:00001619                 mov     ecx, [ecx+54h]
.text$mn:0000161C                 mov     eax, [edx+20h]
.text$mn:0000161F                 call    eax
.text$mn:00001621
.text$mn:00001621 loc_1621:                               ; CODE XREF: Gripper::getMovingRect(tagPOINT,tagRECT *)+154j
.text$mn:00001621                 lea     ecx, [ebp+var_14]
.text$mn:00001624                 push    ecx
.text$mn:00001625                 mov     edx, [ebp+var_18]
.text$mn:00001628                 mov     eax, [edx+54h]
.text$mn:0000162B                 mov     ecx, [ebp+var_18]
.text$mn:0000162E                 mov     edx, [eax]
.text$mn:00001630                 mov     ecx, [ecx+54h]
.text$mn:00001633                 mov     eax, [edx+1Ch]
.text$mn:00001636                 call    eax
.text$mn:00001638                 mov     ecx, [ebp+lpRect]
.text$mn:0000163B                 push    ecx             ; struct tagRECT *
.text$mn:0000163C                 mov     edx, [ebp+var_18]
.text$mn:0000163F                 mov     eax, [edx+0Ch]
.text$mn:00001642                 push    eax             ; HWND
.text$mn:00001643                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001646                 call    ?CalcRectToScreen@Gripper@@IAEXPAUHWND__@@PAUtagRECT@@@Z ; Gripper::CalcRectToScreen(HWND__ *,tagRECT *)
.text$mn:0000164B                 lea     ecx, [ebp+var_14]
.text$mn:0000164E                 push    ecx             ; struct tagRECT *
.text$mn:0000164F                 mov     edx, [ebp+var_18]
.text$mn:00001652                 mov     eax, [edx+0Ch]
.text$mn:00001655                 push    eax             ; HWND
.text$mn:00001656                 mov     ecx, [ebp+var_18] ; this
.text$mn:00001659                 call    ?CalcRectToScreen@Gripper@@IAEXPAUHWND__@@PAUtagRECT@@@Z ; Gripper::CalcRectToScreen(HWND__ *,tagRECT *)
.text$mn:0000165E                 mov     ecx, [ebp+var_18]
.text$mn:00001661                 mov     edx, [ebp+pt.x]
.text$mn:00001664                 sub     edx, [ecx+58h]
.text$mn:00001667                 mov     eax, [ebp+lpRect]
.text$mn:0000166A                 mov     [eax], edx
.text$mn:0000166C                 mov     ecx, [ebp+var_18]
.text$mn:0000166F                 mov     edx, [ebp+pt.y]
.text$mn:00001672                 sub     edx, [ecx+5Ch]
.text$mn:00001675                 mov     eax, [ebp+lpRect]
.text$mn:00001678                 mov     [eax+4], edx
.text$mn:0000167B                 mov     ecx, [ebp+pt.y]
.text$mn:0000167E                 push    ecx
.text$mn:0000167F                 mov     edx, [ebp+pt.x]
.text$mn:00001682                 push    edx             ; struct tagPOINT
.text$mn:00001683                 sub     esp, 10h
.text$mn:00001686                 mov     eax, esp
.text$mn:00001688                 mov     ecx, [ebp+var_14.left]
.text$mn:0000168B                 mov     [eax], ecx
.text$mn:0000168D                 mov     edx, [ebp+var_14.top]
.text$mn:00001690                 mov     [eax+4], edx
.text$mn:00001693                 mov     ecx, [ebp+var_14.right]
.text$mn:00001696                 mov     [eax+8], ecx
.text$mn:00001699                 mov     edx, [ebp+var_14.bottom]
.text$mn:0000169C                 mov     [eax+0Ch], edx
.text$mn:0000169F                 mov     eax, [ebp+lpRect]
.text$mn:000016A2                 push    eax             ; struct tagRECT *
.text$mn:000016A3                 mov     ecx, [ebp+var_18] ; this
.text$mn:000016A6                 call    ?DoCalcGripperRect@Gripper@@IAEXPAUtagRECT@@U2@UtagPOINT@@@Z ; Gripper::DoCalcGripperRect(tagRECT *,tagRECT,tagPOINT)
.text$mn:000016AB
.text$mn:000016AB loc_16AB:                               ; CODE XREF: Gripper::getMovingRect(tagPOINT,tagRECT *)+F5j
.text$mn:000016AB                                         ; Gripper::getMovingRect(tagPOINT,tagRECT *)+115j
.text$mn:000016AB                 mov     ecx, [ebp+var_4]
.text$mn:000016AE                 xor     ecx, ebp
.text$mn:000016B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:000016B5                 mov     esp, ebp
.text$mn:000016B7                 pop     ebp
.text$mn:000016B8                 retn    0Ch
.text$mn:000016B8 ?getMovingRect@Gripper@@IAEXUtagPOINT@@PAUtagRECT@@@Z endp
.text$mn:000016B8
.text$mn:000016B8 ; ---------------------------------------------------------------------------
.text$mn:000016BB                 db 9 dup(0CCh)
.text$mn:000016C4
.text$mn:000016C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000016C4
.text$mn:000016C4 ; Attributes: bp-based frame
.text$mn:000016C4
.text$mn:000016C4 ; struct DockingCont *__thiscall Gripper::contHitTest(Gripper *this, struct tagPOINT)
.text$mn:000016C4                 public ?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z
.text$mn:000016C4 ?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z proc near
.text$mn:000016C4                                         ; CODE XREF: Gripper::onButtonUp(void)+97p
.text$mn:000016C4                                         ; Gripper::getMovingRect(tagPOINT,tagRECT *)+37p
.text$mn:000016C4
.text$mn:000016C4 var_68          = dword ptr -68h
.text$mn:000016C4 var_64          = dword ptr -64h
.text$mn:000016C4 var_60          = dword ptr -60h
.text$mn:000016C4 var_5C          = dword ptr -5Ch
.text$mn:000016C4 var_58          = dword ptr -58h
.text$mn:000016C4 var_54          = dword ptr -54h
.text$mn:000016C4 var_50          = dword ptr -50h
.text$mn:000016C4 var_4C          = dword ptr -4Ch
.text$mn:000016C4 var_48          = dword ptr -48h
.text$mn:000016C4 var_44          = byte ptr -44h
.text$mn:000016C4 var_34          = dword ptr -34h
.text$mn:000016C4 Rect            = tagRECT ptr -30h
.text$mn:000016C4 var_20          = dword ptr -20h
.text$mn:000016C4 var_1C          = dword ptr -1Ch
.text$mn:000016C4 var_18          = dword ptr -18h
.text$mn:000016C4 var_14          = dword ptr -14h
.text$mn:000016C4 var_10          = dword ptr -10h
.text$mn:000016C4 var_C           = dword ptr -0Ch
.text$mn:000016C4 var_4           = dword ptr -4
.text$mn:000016C4 Point           = POINT ptr  8
.text$mn:000016C4
.text$mn:000016C4                 push    ebp
.text$mn:000016C5                 mov     ebp, esp
.text$mn:000016C7                 push    0FFFFFFFFh
.text$mn:000016C9                 push    offset __ehhandler$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z
.text$mn:000016CE                 mov     eax, large fs:0
.text$mn:000016D4                 push    eax
.text$mn:000016D5                 sub     esp, 5Ch
.text$mn:000016D8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000016DD                 xor     eax, ebp
.text$mn:000016DF                 mov     [ebp+var_10], eax
.text$mn:000016E2                 push    eax
.text$mn:000016E3                 lea     eax, [ebp+var_C]
.text$mn:000016E6                 mov     large fs:0, eax
.text$mn:000016EC                 mov     [ebp+var_48], ecx
.text$mn:000016EF                 mov     eax, [ebp+var_48]
.text$mn:000016F2                 mov     ecx, [eax+50h]
.text$mn:000016F5                 call    ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ ; DockingManager::getContainerInfo(void)
.text$mn:000016FA                 push    eax
.text$mn:000016FB                 lea     ecx, [ebp+var_44]
.text$mn:000016FE                 call    ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)
.text$mn:00001703                 mov     [ebp+var_4], 0
.text$mn:0000170A                 mov     ecx, [ebp+Point.y]
.text$mn:0000170D                 push    ecx
.text$mn:0000170E                 mov     edx, [ebp+Point.x]
.text$mn:00001711                 push    edx             ; Point
.text$mn:00001712                 call    dword ptr ds:__imp__WindowFromPoint@8 ; WindowFromPoint(x,x)
.text$mn:00001718                 mov     [ebp+var_58], eax
.text$mn:0000171B                 mov     [ebp+var_34], 0
.text$mn:00001722                 lea     ecx, [ebp+var_44]
.text$mn:00001725                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:0000172A                 mov     [ebp+var_68], eax
.text$mn:0000172D                 jmp     short loc_1738
.text$mn:0000172F ; ---------------------------------------------------------------------------
.text$mn:0000172F
.text$mn:0000172F loc_172F:                               ; CODE XREF: Gripper::contHitTest(tagPOINT):loc_18D6j
.text$mn:0000172F                 mov     eax, [ebp+var_34]
.text$mn:00001732                 add     eax, 1
.text$mn:00001735                 mov     [ebp+var_34], eax
.text$mn:00001738
.text$mn:00001738 loc_1738:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+69j
.text$mn:00001738                 mov     ecx, [ebp+var_34]
.text$mn:0000173B                 cmp     ecx, [ebp+var_68]
.text$mn:0000173E                 jnb     loc_18DB
.text$mn:00001744                 mov     edx, [ebp+var_34]
.text$mn:00001747                 push    edx
.text$mn:00001748                 lea     ecx, [ebp+var_44]
.text$mn:0000174B                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001750                 mov     ecx, [eax]      ; this
.text$mn:00001752                 call    ?getCaptionWnd@DockingCont@@QAEPAUHWND__@@XZ ; DockingCont::getCaptionWnd(void)
.text$mn:00001757                 cmp     [ebp+var_58], eax
.text$mn:0000175A                 jnz     loc_184D
.text$mn:00001760                 mov     eax, [ebp+var_34]
.text$mn:00001763                 push    eax
.text$mn:00001764                 lea     ecx, [ebp+var_44]
.text$mn:00001767                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000176C                 mov     ecx, [eax]      ; this
.text$mn:0000176E                 call    ?isFloating@DockingCont@@QAE_NXZ ; DockingCont::isFloating(void)
.text$mn:00001773                 movzx   ecx, al
.text$mn:00001776                 test    ecx, ecx
.text$mn:00001778                 jz      loc_1825
.text$mn:0000177E                 mov     [ebp+var_20], 0
.text$mn:00001785                 xor     edx, edx
.text$mn:00001787                 mov     [ebp+var_1C], edx
.text$mn:0000178A                 mov     [ebp+var_18], edx
.text$mn:0000178D                 mov     [ebp+var_14], edx
.text$mn:00001790                 mov     eax, [ebp+var_34]
.text$mn:00001793                 push    eax
.text$mn:00001794                 lea     ecx, [ebp+var_44]
.text$mn:00001797                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000179C                 mov     ecx, [eax]
.text$mn:0000179E                 mov     [ebp+var_4C], ecx
.text$mn:000017A1                 lea     edx, [ebp+var_20]
.text$mn:000017A4                 push    edx
.text$mn:000017A5                 mov     eax, [ebp+var_4C]
.text$mn:000017A8                 mov     edx, [eax]
.text$mn:000017AA                 mov     ecx, [ebp+var_4C]
.text$mn:000017AD                 mov     eax, [edx+20h]
.text$mn:000017B0                 call    eax
.text$mn:000017B2                 mov     ecx, [ebp+var_1C]
.text$mn:000017B5                 cmp     ecx, [ebp+Point.y]
.text$mn:000017B8                 jge     short loc_1823
.text$mn:000017BA                 mov     edx, [ebp+var_1C]
.text$mn:000017BD                 add     edx, 18h
.text$mn:000017C0                 cmp     [ebp+Point.y], edx
.text$mn:000017C3                 jge     short loc_1823
.text$mn:000017C5                 mov     eax, [ebp+var_34]
.text$mn:000017C8                 push    eax
.text$mn:000017C9                 lea     ecx, [ebp+var_44]
.text$mn:000017CC                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000017D1                 mov     ecx, [ebp+var_48]
.text$mn:000017D4                 mov     edx, [eax]
.text$mn:000017D6                 cmp     edx, [ecx+54h]
.text$mn:000017D9                 jnz     short loc_17FB
.text$mn:000017DB                 mov     [ebp+var_60], 0
.text$mn:000017E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000017E9                 lea     ecx, [ebp+var_44]
.text$mn:000017EC                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:000017F1                 mov     eax, [ebp+var_60]
.text$mn:000017F4                 jmp     loc_18F4
.text$mn:000017F9 ; ---------------------------------------------------------------------------
.text$mn:000017F9                 jmp     short loc_1823
.text$mn:000017FB ; ---------------------------------------------------------------------------
.text$mn:000017FB
.text$mn:000017FB loc_17FB:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+115j
.text$mn:000017FB                 mov     eax, [ebp+var_34]
.text$mn:000017FE                 push    eax
.text$mn:000017FF                 lea     ecx, [ebp+var_44]
.text$mn:00001802                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001807                 mov     ecx, [eax]
.text$mn:00001809                 mov     [ebp+var_50], ecx
.text$mn:0000180C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001813                 lea     ecx, [ebp+var_44]
.text$mn:00001816                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:0000181B                 mov     eax, [ebp+var_50]
.text$mn:0000181E                 jmp     loc_18F4
.text$mn:00001823 ; ---------------------------------------------------------------------------
.text$mn:00001823
.text$mn:00001823 loc_1823:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+F4j
.text$mn:00001823                                         ; Gripper::contHitTest(tagPOINT)+FFj ...
.text$mn:00001823                 jmp     short loc_184D
.text$mn:00001825 ; ---------------------------------------------------------------------------
.text$mn:00001825
.text$mn:00001825 loc_1825:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+B4j
.text$mn:00001825                 mov     edx, [ebp+var_34]
.text$mn:00001828                 push    edx
.text$mn:00001829                 lea     ecx, [ebp+var_44]
.text$mn:0000182C                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001831                 mov     eax, [eax]
.text$mn:00001833                 mov     [ebp+var_64], eax
.text$mn:00001836                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000183D                 lea     ecx, [ebp+var_44]
.text$mn:00001840                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:00001845                 mov     eax, [ebp+var_64]
.text$mn:00001848                 jmp     loc_18F4
.text$mn:0000184D ; ---------------------------------------------------------------------------
.text$mn:0000184D
.text$mn:0000184D loc_184D:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+96j
.text$mn:0000184D                                         ; Gripper::contHitTest(tagPOINT):loc_1823j
.text$mn:0000184D                 mov     ecx, [ebp+var_34]
.text$mn:00001850                 push    ecx
.text$mn:00001851                 lea     ecx, [ebp+var_44]
.text$mn:00001854                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001859                 mov     ecx, [eax]      ; this
.text$mn:0000185B                 call    ?getTabWnd@DockingCont@@QAEPAUHWND__@@XZ ; DockingCont::getTabWnd(void)
.text$mn:00001860                 push    eax             ; hWnd
.text$mn:00001861                 call    dword ptr ds:__imp__IsWindowVisible@4 ; IsWindowVisible(x)
.text$mn:00001867                 test    eax, eax
.text$mn:00001869                 jz      short loc_18D6
.text$mn:0000186B                 mov     [ebp+Rect.left], 0
.text$mn:00001872                 xor     edx, edx
.text$mn:00001874                 mov     [ebp+Rect.top], edx
.text$mn:00001877                 mov     [ebp+Rect.right], edx
.text$mn:0000187A                 mov     [ebp+Rect.bottom], edx
.text$mn:0000187D                 lea     eax, [ebp+Rect]
.text$mn:00001880                 push    eax             ; lpRect
.text$mn:00001881                 mov     ecx, [ebp+var_34]
.text$mn:00001884                 push    ecx
.text$mn:00001885                 lea     ecx, [ebp+var_44]
.text$mn:00001888                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:0000188D                 mov     ecx, [eax]      ; this
.text$mn:0000188F                 call    ?getTabWnd@DockingCont@@QAEPAUHWND__@@XZ ; DockingCont::getTabWnd(void)
.text$mn:00001894                 push    eax             ; hWnd
.text$mn:00001895                 call    dword ptr ds:__imp__GetWindowRect@8 ; GetWindowRect(x,x)
.text$mn:0000189B                 mov     edx, [ebp+Point.y]
.text$mn:0000189E                 push    edx
.text$mn:0000189F                 mov     eax, [ebp+Point.x]
.text$mn:000018A2                 push    eax             ; pt
.text$mn:000018A3                 lea     ecx, [ebp+Rect]
.text$mn:000018A6                 push    ecx             ; lprc
.text$mn:000018A7                 call    dword ptr ds:__imp__PtInRect@12 ; PtInRect(x,x,x)
.text$mn:000018AD                 test    eax, eax
.text$mn:000018AF                 jz      short loc_18D6
.text$mn:000018B1                 mov     edx, [ebp+var_34]
.text$mn:000018B4                 push    edx
.text$mn:000018B5                 lea     ecx, [ebp+var_44]
.text$mn:000018B8                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000018BD                 mov     eax, [eax]
.text$mn:000018BF                 mov     [ebp+var_5C], eax
.text$mn:000018C2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018C9                 lea     ecx, [ebp+var_44]
.text$mn:000018CC                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:000018D1                 mov     eax, [ebp+var_5C]
.text$mn:000018D4                 jmp     short loc_18F4
.text$mn:000018D6 ; ---------------------------------------------------------------------------
.text$mn:000018D6
.text$mn:000018D6 loc_18D6:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+1A5j
.text$mn:000018D6                                         ; Gripper::contHitTest(tagPOINT)+1EBj
.text$mn:000018D6                 jmp     loc_172F
.text$mn:000018DB ; ---------------------------------------------------------------------------
.text$mn:000018DB
.text$mn:000018DB loc_18DB:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+7Aj
.text$mn:000018DB                 mov     [ebp+var_54], 0
.text$mn:000018E2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000018E9                 lea     ecx, [ebp+var_44]
.text$mn:000018EC                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:000018F1                 mov     eax, [ebp+var_54]
.text$mn:000018F4
.text$mn:000018F4 loc_18F4:                               ; CODE XREF: Gripper::contHitTest(tagPOINT)+130j
.text$mn:000018F4                                         ; Gripper::contHitTest(tagPOINT)+15Aj ...
.text$mn:000018F4                 mov     ecx, [ebp+var_C]
.text$mn:000018F7                 mov     large fs:0, ecx
.text$mn:000018FE                 pop     ecx
.text$mn:000018FF                 mov     ecx, [ebp+var_10]
.text$mn:00001902                 xor     ecx, ebp
.text$mn:00001904                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001909                 mov     esp, ebp
.text$mn:0000190B                 pop     ebp
.text$mn:0000190C                 retn    8
.text$mn:0000190C ?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z endp
.text$mn:0000190C
.text$mn:0000190C ; ---------------------------------------------------------------------------
.text$mn:0000190F                 db 5 dup(0CCh)
.text$mn:00001914
.text$mn:00001914 ; =============== S U B R O U T I N E =======================================
.text$mn:00001914
.text$mn:00001914 ; Attributes: bp-based frame
.text$mn:00001914
.text$mn:00001914 ; struct DockingCont *__thiscall Gripper::workHitTest(Gripper *this, POINT pt, struct tagRECT *)
.text$mn:00001914                 public ?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z
.text$mn:00001914 ?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z proc near
.text$mn:00001914                                         ; CODE XREF: Gripper::onButtonUp(void)+B2p
.text$mn:00001914                                         ; Gripper::getMovingRect(tagPOINT,tagRECT *)+109p
.text$mn:00001914
.text$mn:00001914 var_5C          = dword ptr -5Ch
.text$mn:00001914 var_58          = dword ptr -58h
.text$mn:00001914 var_54          = dword ptr -54h
.text$mn:00001914 var_50          = dword ptr -50h
.text$mn:00001914 var_4C          = byte ptr -4Ch
.text$mn:00001914 var_3C          = dword ptr -3Ch
.text$mn:00001914 var_38          = dword ptr -38h
.text$mn:00001914 var_34          = dword ptr -34h
.text$mn:00001914 var_30          = dword ptr -30h
.text$mn:00001914 var_2C          = dword ptr -2Ch
.text$mn:00001914 var_28          = dword ptr -28h
.text$mn:00001914 var_24          = dword ptr -24h
.text$mn:00001914 rc              = RECT ptr -20h
.text$mn:00001914 var_10          = dword ptr -10h
.text$mn:00001914 var_C           = dword ptr -0Ch
.text$mn:00001914 var_4           = dword ptr -4
.text$mn:00001914 pt              = POINT ptr  8
.text$mn:00001914 arg_8           = dword ptr  10h
.text$mn:00001914
.text$mn:00001914                 push    ebp
.text$mn:00001915                 mov     ebp, esp
.text$mn:00001917                 push    0FFFFFFFFh
.text$mn:00001919                 push    offset __ehhandler$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z
.text$mn:0000191E                 mov     eax, large fs:0
.text$mn:00001924                 push    eax
.text$mn:00001925                 sub     esp, 50h
.text$mn:00001928                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000192D                 xor     eax, ebp
.text$mn:0000192F                 mov     [ebp+var_10], eax
.text$mn:00001932                 push    eax
.text$mn:00001933                 lea     eax, [ebp+var_C]
.text$mn:00001936                 mov     large fs:0, eax
.text$mn:0000193C                 mov     [ebp+var_2C], ecx
.text$mn:0000193F                 mov     [ebp+rc.left], 0
.text$mn:00001946                 xor     eax, eax
.text$mn:00001948                 mov     [ebp+rc.top], eax
.text$mn:0000194B                 mov     [ebp+rc.right], eax
.text$mn:0000194E                 mov     [ebp+rc.bottom], eax
.text$mn:00001951                 mov     ecx, [ebp+var_2C]
.text$mn:00001954                 mov     ecx, [ecx+50h]
.text$mn:00001957                 call    ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ ; DockingManager::getContainerInfo(void)
.text$mn:0000195C                 push    eax
.text$mn:0000195D                 lea     ecx, [ebp+var_4C]
.text$mn:00001960                 call    ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)
.text$mn:00001965                 mov     [ebp+var_4], 0
.text$mn:0000196C                 mov     [ebp+var_28], 0
.text$mn:00001973                 lea     ecx, [ebp+var_4C]
.text$mn:00001976                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:0000197B                 mov     [ebp+var_54], eax
.text$mn:0000197E                 jmp     short loc_1989
.text$mn:00001980 ; ---------------------------------------------------------------------------
.text$mn:00001980
.text$mn:00001980 loc_1980:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *):loc_1A11j
.text$mn:00001980                 mov     edx, [ebp+var_28]
.text$mn:00001983                 add     edx, 1
.text$mn:00001986                 mov     [ebp+var_28], edx
.text$mn:00001989
.text$mn:00001989 loc_1989:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+6Aj
.text$mn:00001989                 mov     eax, [ebp+var_28]
.text$mn:0000198C                 cmp     eax, [ebp+var_54]
.text$mn:0000198F                 jnb     loc_1A16
.text$mn:00001995                 mov     ecx, [ebp+var_28]
.text$mn:00001998                 push    ecx
.text$mn:00001999                 lea     ecx, [ebp+var_4C]
.text$mn:0000199C                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000019A1                 mov     edx, [eax]
.text$mn:000019A3                 mov     [ebp+var_34], edx
.text$mn:000019A6                 mov     eax, [ebp+var_34]
.text$mn:000019A9                 mov     edx, [eax]
.text$mn:000019AB                 mov     ecx, [ebp+var_34]
.text$mn:000019AE                 mov     eax, [edx+2Ch]
.text$mn:000019B1                 call    eax
.text$mn:000019B3                 movzx   ecx, al
.text$mn:000019B6                 test    ecx, ecx
.text$mn:000019B8                 jz      short loc_1A11
.text$mn:000019BA                 mov     edx, [ebp+var_28]
.text$mn:000019BD                 push    edx
.text$mn:000019BE                 lea     ecx, [ebp+var_4C]
.text$mn:000019C1                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:000019C6                 mov     eax, [eax]
.text$mn:000019C8                 mov     [ebp+var_3C], eax
.text$mn:000019CB                 lea     ecx, [ebp+rc]
.text$mn:000019CE                 push    ecx
.text$mn:000019CF                 mov     edx, [ebp+var_3C]
.text$mn:000019D2                 mov     eax, [edx]
.text$mn:000019D4                 mov     ecx, [ebp+var_3C]
.text$mn:000019D7                 mov     edx, [eax+20h]
.text$mn:000019DA                 call    edx
.text$mn:000019DC                 mov     eax, [ebp+pt.y]
.text$mn:000019DF                 push    eax
.text$mn:000019E0                 mov     ecx, [ebp+pt.x]
.text$mn:000019E3                 push    ecx             ; pt
.text$mn:000019E4                 lea     edx, [ebp+rc]
.text$mn:000019E7                 push    edx             ; lprc
.text$mn:000019E8                 call    dword ptr ds:__imp__PtInRect@12 ; PtInRect(x,x,x)
.text$mn:000019EE                 cmp     eax, 1
.text$mn:000019F1                 jnz     short loc_1A11
.text$mn:000019F3                 mov     [ebp+var_50], 0
.text$mn:000019FA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001A01                 lea     ecx, [ebp+var_4C]
.text$mn:00001A04                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:00001A09                 mov     eax, [ebp+var_50]
.text$mn:00001A0C                 jmp     loc_1BBE
.text$mn:00001A11 ; ---------------------------------------------------------------------------
.text$mn:00001A11
.text$mn:00001A11 loc_1A11:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+A4j
.text$mn:00001A11                                         ; Gripper::workHitTest(tagPOINT,tagRECT *)+DDj
.text$mn:00001A11                 jmp     loc_1980
.text$mn:00001A16 ; ---------------------------------------------------------------------------
.text$mn:00001A16
.text$mn:00001A16 loc_1A16:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+7Bj
.text$mn:00001A16                 mov     [ebp+var_24], 0
.text$mn:00001A1D                 jmp     short loc_1A28
.text$mn:00001A1F ; ---------------------------------------------------------------------------
.text$mn:00001A1F
.text$mn:00001A1F loc_1A1F:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *):loc_1BA0j
.text$mn:00001A1F                 mov     eax, [ebp+var_24]
.text$mn:00001A22                 add     eax, 1
.text$mn:00001A25                 mov     [ebp+var_24], eax
.text$mn:00001A28
.text$mn:00001A28 loc_1A28:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+109j
.text$mn:00001A28                 cmp     [ebp+var_24], 4
.text$mn:00001A2C                 jge     loc_1BA5
.text$mn:00001A32                 mov     ecx, [ebp+var_24]
.text$mn:00001A35                 push    ecx
.text$mn:00001A36                 lea     ecx, [ebp+var_4C]
.text$mn:00001A39                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001A3E                 mov     edx, [eax]
.text$mn:00001A40                 mov     [ebp+var_38], edx
.text$mn:00001A43                 mov     eax, [ebp+var_38]
.text$mn:00001A46                 mov     edx, [eax]
.text$mn:00001A48                 mov     ecx, [ebp+var_38]
.text$mn:00001A4B                 mov     eax, [edx+2Ch]
.text$mn:00001A4E                 call    eax
.text$mn:00001A50                 movzx   ecx, al
.text$mn:00001A53                 test    ecx, ecx
.text$mn:00001A55                 jnz     loc_1BA0
.text$mn:00001A5B                 mov     edx, [ebp+var_24]
.text$mn:00001A5E                 shl     edx, 4
.text$mn:00001A61                 mov     eax, [ebp+var_2C]
.text$mn:00001A64                 lea     ecx, [eax+edx+10h]
.text$mn:00001A68                 mov     edx, [ecx]
.text$mn:00001A6A                 mov     [ebp+rc.left], edx
.text$mn:00001A6D                 mov     eax, [ecx+4]
.text$mn:00001A70                 mov     [ebp+rc.top], eax
.text$mn:00001A73                 mov     edx, [ecx+8]
.text$mn:00001A76                 mov     [ebp+rc.right], edx
.text$mn:00001A79                 mov     eax, [ecx+0Ch]
.text$mn:00001A7C                 mov     [ebp+rc.bottom], eax
.text$mn:00001A7F                 mov     ecx, [ebp+rc.right]
.text$mn:00001A82                 add     ecx, [ebp+rc.left]
.text$mn:00001A85                 mov     [ebp+rc.right], ecx
.text$mn:00001A88                 mov     edx, [ebp+rc.bottom]
.text$mn:00001A8B                 add     edx, [ebp+rc.top]
.text$mn:00001A8E                 mov     [ebp+rc.bottom], edx
.text$mn:00001A91                 cmp     [ebp+arg_8], 0
.text$mn:00001A95                 jz      short loc_1AB1
.text$mn:00001A97                 mov     eax, [ebp+arg_8]
.text$mn:00001A9A                 mov     ecx, [ebp+rc.left]
.text$mn:00001A9D                 mov     [eax], ecx
.text$mn:00001A9F                 mov     edx, [ebp+rc.top]
.text$mn:00001AA2                 mov     [eax+4], edx
.text$mn:00001AA5                 mov     ecx, [ebp+rc.right]
.text$mn:00001AA8                 mov     [eax+8], ecx
.text$mn:00001AAB                 mov     edx, [ebp+rc.bottom]
.text$mn:00001AAE                 mov     [eax+0Ch], edx
.text$mn:00001AB1
.text$mn:00001AB1 loc_1AB1:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+181j
.text$mn:00001AB1                 mov     eax, [ebp+var_24]
.text$mn:00001AB4                 mov     [ebp+var_30], eax
.text$mn:00001AB7                 cmp     [ebp+var_30], 3 ; switch 4 cases
.text$mn:00001ABB                 ja      short loc_1B15  ; jumptable 00001AC0 default case
.text$mn:00001ABD                 mov     ecx, [ebp+var_30]
.text$mn:00001AC0                 jmp     ds:$LN24[ecx*4] ; switch jump
.text$mn:00001AC7 ; ---------------------------------------------------------------------------
.text$mn:00001AC7
.text$mn:00001AC7 $LN7:                                   ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+1ACj
.text$mn:00001AC7                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:00001AC7                 mov     edx, [ebp+rc.left] ; jumptable 00001AC0 case 0
.text$mn:00001ACA                 add     edx, 14h
.text$mn:00001ACD                 mov     [ebp+rc.right], edx
.text$mn:00001AD0                 mov     eax, [ebp+rc.left]
.text$mn:00001AD3                 sub     eax, 14h
.text$mn:00001AD6                 mov     [ebp+rc.left], eax
.text$mn:00001AD9                 jmp     short loc_1B15  ; jumptable 00001AC0 default case
.text$mn:00001ADB ; ---------------------------------------------------------------------------
.text$mn:00001ADB
.text$mn:00001ADB $LN6_2:                                 ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+1ACj
.text$mn:00001ADB                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:00001ADB                 mov     ecx, [ebp+rc.right] ; jumptable 00001AC0 case 1
.text$mn:00001ADE                 sub     ecx, 14h
.text$mn:00001AE1                 mov     [ebp+rc.left], ecx
.text$mn:00001AE4                 mov     edx, [ebp+rc.right]
.text$mn:00001AE7                 add     edx, 14h
.text$mn:00001AEA                 mov     [ebp+rc.right], edx
.text$mn:00001AED                 jmp     short loc_1B15  ; jumptable 00001AC0 default case
.text$mn:00001AEF ; ---------------------------------------------------------------------------
.text$mn:00001AEF
.text$mn:00001AEF $LN5:                                   ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+1ACj
.text$mn:00001AEF                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:00001AEF                 mov     eax, [ebp+rc.top] ; jumptable 00001AC0 case 2
.text$mn:00001AF2                 add     eax, 14h
.text$mn:00001AF5                 mov     [ebp+rc.bottom], eax
.text$mn:00001AF8                 mov     ecx, [ebp+rc.top]
.text$mn:00001AFB                 sub     ecx, 14h
.text$mn:00001AFE                 mov     [ebp+rc.top], ecx
.text$mn:00001B01                 jmp     short loc_1B15  ; jumptable 00001AC0 default case
.text$mn:00001B03 ; ---------------------------------------------------------------------------
.text$mn:00001B03
.text$mn:00001B03 $LN4:                                   ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+1ACj
.text$mn:00001B03                                         ; DATA XREF: .text$mn:$LN24o
.text$mn:00001B03                 mov     edx, [ebp+rc.bottom] ; jumptable 00001AC0 case 3
.text$mn:00001B06                 sub     edx, 14h
.text$mn:00001B09                 mov     [ebp+rc.top], edx
.text$mn:00001B0C                 mov     eax, [ebp+rc.bottom]
.text$mn:00001B0F                 add     eax, 14h
.text$mn:00001B12                 mov     [ebp+rc.bottom], eax
.text$mn:00001B15
.text$mn:00001B15 loc_1B15:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+1A7j
.text$mn:00001B15                                         ; Gripper::workHitTest(tagPOINT,tagRECT *)+1C5j ...
.text$mn:00001B15                 lea     ecx, [ebp+rc]   ; jumptable 00001AC0 default case
.text$mn:00001B18                 push    ecx             ; struct tagRECT *
.text$mn:00001B19                 mov     edx, [ebp+var_2C]
.text$mn:00001B1C                 mov     eax, [edx+0Ch]
.text$mn:00001B1F                 push    eax             ; HWND
.text$mn:00001B20                 call    ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z ; ClientRectToScreenRect(HWND__ *,tagRECT *)
.text$mn:00001B25                 add     esp, 8
.text$mn:00001B28                 mov     ecx, [ebp+pt.y]
.text$mn:00001B2B                 push    ecx
.text$mn:00001B2C                 mov     edx, [ebp+pt.x]
.text$mn:00001B2F                 push    edx             ; pt
.text$mn:00001B30                 lea     eax, [ebp+rc]
.text$mn:00001B33                 push    eax             ; lprc
.text$mn:00001B34                 call    dword ptr ds:__imp__PtInRect@12 ; PtInRect(x,x,x)
.text$mn:00001B3A                 cmp     eax, 1
.text$mn:00001B3D                 jnz     short loc_1BA0
.text$mn:00001B3F                 cmp     [ebp+arg_8], 0
.text$mn:00001B43                 jz      short loc_1B7B
.text$mn:00001B45                 mov     ecx, [ebp+arg_8]
.text$mn:00001B48                 push    ecx             ; struct tagRECT *
.text$mn:00001B49                 mov     edx, [ebp+var_2C]
.text$mn:00001B4C                 mov     eax, [edx+0Ch]
.text$mn:00001B4F                 push    eax             ; HWND
.text$mn:00001B50                 call    ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z ; ClientRectToScreenRect(HWND__ *,tagRECT *)
.text$mn:00001B55                 add     esp, 8
.text$mn:00001B58                 mov     ecx, [ebp+arg_8]
.text$mn:00001B5B                 mov     edx, [ebp+arg_8]
.text$mn:00001B5E                 mov     eax, [ecx+8]
.text$mn:00001B61                 sub     eax, [edx]
.text$mn:00001B63                 mov     ecx, [ebp+arg_8]
.text$mn:00001B66                 mov     [ecx+8], eax
.text$mn:00001B69                 mov     edx, [ebp+arg_8]
.text$mn:00001B6C                 mov     eax, [ebp+arg_8]
.text$mn:00001B6F                 mov     ecx, [edx+0Ch]
.text$mn:00001B72                 sub     ecx, [eax+4]
.text$mn:00001B75                 mov     edx, [ebp+arg_8]
.text$mn:00001B78                 mov     [edx+0Ch], ecx
.text$mn:00001B7B
.text$mn:00001B7B loc_1B7B:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+22Fj
.text$mn:00001B7B                 mov     eax, [ebp+var_24]
.text$mn:00001B7E                 push    eax
.text$mn:00001B7F                 lea     ecx, [ebp+var_4C]
.text$mn:00001B82                 call    ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)
.text$mn:00001B87                 mov     ecx, [eax]
.text$mn:00001B89                 mov     [ebp+var_5C], ecx
.text$mn:00001B8C                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001B93                 lea     ecx, [ebp+var_4C]
.text$mn:00001B96                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:00001B9B                 mov     eax, [ebp+var_5C]
.text$mn:00001B9E                 jmp     short loc_1BBE
.text$mn:00001BA0 ; ---------------------------------------------------------------------------
.text$mn:00001BA0
.text$mn:00001BA0 loc_1BA0:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+141j
.text$mn:00001BA0                                         ; Gripper::workHitTest(tagPOINT,tagRECT *)+229j
.text$mn:00001BA0                 jmp     loc_1A1F
.text$mn:00001BA5 ; ---------------------------------------------------------------------------
.text$mn:00001BA5
.text$mn:00001BA5 loc_1BA5:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+118j
.text$mn:00001BA5                 mov     [ebp+var_58], 0
.text$mn:00001BAC                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00001BB3                 lea     ecx, [ebp+var_4C]
.text$mn:00001BB6                 call    ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$mn:00001BBB                 mov     eax, [ebp+var_58]
.text$mn:00001BBE
.text$mn:00001BBE loc_1BBE:                               ; CODE XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+F8j
.text$mn:00001BBE                                         ; Gripper::workHitTest(tagPOINT,tagRECT *)+28Aj
.text$mn:00001BBE                 mov     ecx, [ebp+var_C]
.text$mn:00001BC1                 mov     large fs:0, ecx
.text$mn:00001BC8                 pop     ecx
.text$mn:00001BC9                 mov     ecx, [ebp+var_10]
.text$mn:00001BCC                 xor     ecx, ebp
.text$mn:00001BCE                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$mn:00001BD3                 mov     esp, ebp
.text$mn:00001BD5                 pop     ebp
.text$mn:00001BD6                 retn    0Ch
.text$mn:00001BD6 ?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z endp
.text$mn:00001BD6
.text$mn:00001BD6 ; ---------------------------------------------------------------------------
.text$mn:00001BD9                 align 4
.text$mn:00001BDC $LN24           dd offset $LN7          ; DATA XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+1ACr
.text$mn:00001BDC                 dd offset $LN6_2        ; jump table for switch statement
.text$mn:00001BDC                 dd offset $LN5
.text$mn:00001BDC                 dd offset $LN4
.text$mn:00001BEC                 db 8 dup(0CCh)
.text$mn:00001BF4
.text$mn:00001BF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001BF4
.text$mn:00001BF4 ; Attributes: bp-based frame
.text$mn:00001BF4
.text$mn:00001BF4 ; void __thiscall Gripper::initTabInformation(Gripper *__hidden this)
.text$mn:00001BF4                 public ?initTabInformation@Gripper@@IAEXXZ
.text$mn:00001BF4 ?initTabInformation@Gripper@@IAEXXZ proc near
.text$mn:00001BF4                                         ; CODE XREF: Gripper::create(void)+179p
.text$mn:00001BF4                                         ; Gripper::doTabReordering(tagPOINT)+118p
.text$mn:00001BF4
.text$mn:00001BF4 var_4           = dword ptr -4
.text$mn:00001BF4
.text$mn:00001BF4                 push    ebp
.text$mn:00001BF5                 mov     ebp, esp
.text$mn:00001BF7                 push    ecx
.text$mn:00001BF8                 mov     [ebp+var_4], ecx
.text$mn:00001BFB                 mov     eax, [ebp+var_4]
.text$mn:00001BFE                 mov     ecx, [eax+54h]  ; this
.text$mn:00001C01                 call    ?getTabWnd@DockingCont@@QAEPAUHWND__@@XZ ; DockingCont::getTabWnd(void)
.text$mn:00001C06                 mov     ecx, [ebp+var_4]
.text$mn:00001C09                 mov     [ecx+80h], eax
.text$mn:00001C0F                 mov     edx, [ebp+var_4]
.text$mn:00001C12                 mov     ecx, [edx+54h]  ; this
.text$mn:00001C15                 call    ?startMovingFromTab@DockingCont@@QAEHXZ ; DockingCont::startMovingFromTab(void)
.text$mn:00001C1A                 mov     ecx, [ebp+var_4]
.text$mn:00001C1D                 mov     [ecx+84h], eax
.text$mn:00001C23                 mov     edx, [ebp+var_4]
.text$mn:00001C26                 cmp     dword ptr [edx+84h], 0
.text$mn:00001C2D                 jnz     short loc_1C69
.text$mn:00001C2F                 push    0               ; lParam
.text$mn:00001C31                 push    0               ; wParam
.text$mn:00001C33                 push    1304h           ; Msg
.text$mn:00001C38                 mov     eax, [ebp+var_4]
.text$mn:00001C3B                 mov     ecx, [eax+80h]
.text$mn:00001C41                 push    ecx             ; hWnd
.text$mn:00001C42                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001C48                 cmp     eax, 1
.text$mn:00001C4B                 jnz     short loc_1C69
.text$mn:00001C4D                 mov     edx, [ebp+var_4]
.text$mn:00001C50                 mov     dword ptr [edx+84h], 1
.text$mn:00001C5A                 mov     eax, [ebp+var_4]
.text$mn:00001C5D                 mov     dword ptr [eax+88h], 0
.text$mn:00001C67                 jmp     short loc_1C8B
.text$mn:00001C69 ; ---------------------------------------------------------------------------
.text$mn:00001C69
.text$mn:00001C69 loc_1C69:                               ; CODE XREF: Gripper::initTabInformation(void)+39j
.text$mn:00001C69                                         ; Gripper::initTabInformation(void)+57j
.text$mn:00001C69                 push    0               ; lParam
.text$mn:00001C6B                 push    0               ; wParam
.text$mn:00001C6D                 push    130Bh           ; Msg
.text$mn:00001C72                 mov     ecx, [ebp+var_4]
.text$mn:00001C75                 mov     edx, [ecx+80h]
.text$mn:00001C7B                 push    edx             ; hWnd
.text$mn:00001C7C                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001C82                 mov     ecx, [ebp+var_4]
.text$mn:00001C85                 mov     [ecx+88h], eax
.text$mn:00001C8B
.text$mn:00001C8B loc_1C8B:                               ; CODE XREF: Gripper::initTabInformation(void)+73j
.text$mn:00001C8B                 mov     edx, [ebp+var_4]
.text$mn:00001C8E                 mov     eax, [ebp+var_4]
.text$mn:00001C91                 mov     ecx, [eax+80h]
.text$mn:00001C97                 mov     [edx+7Ch], ecx
.text$mn:00001C9A                 mov     edx, [ebp+var_4]
.text$mn:00001C9D                 add     edx, 8Ch ; 'î'
.text$mn:00001CA3                 push    edx             ; lParam
.text$mn:00001CA4                 mov     eax, [ebp+var_4]
.text$mn:00001CA7                 mov     ecx, [eax+88h]
.text$mn:00001CAD                 push    ecx             ; wParam
.text$mn:00001CAE                 push    130Ah           ; Msg
.text$mn:00001CB3                 mov     edx, [ebp+var_4]
.text$mn:00001CB6                 mov     eax, [edx+80h]
.text$mn:00001CBC                 push    eax             ; hWnd
.text$mn:00001CBD                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001CC3                 mov     ecx, [ebp+var_4]
.text$mn:00001CC6                 mov     dword ptr [ecx+9Ch], 9
.text$mn:00001CD0                 mov     edx, [ebp+var_4]
.text$mn:00001CD3                 mov     dword ptr [edx+0A8h], offset ?szText@?6??initTabInformation@Gripper@@IAEXXZ@4PA_WA ; wchar_t * `Gripper::initTabInformation(void)'::`7'::szText
.text$mn:00001CDD                 mov     eax, [ebp+var_4]
.text$mn:00001CE0                 mov     dword ptr [eax+0ACh], 40h ; '@'
.text$mn:00001CEA                 mov     ecx, [ebp+var_4]
.text$mn:00001CED                 add     ecx, 9Ch ; '£'
.text$mn:00001CF3                 push    ecx             ; lParam
.text$mn:00001CF4                 mov     edx, [ebp+var_4]
.text$mn:00001CF7                 mov     eax, [edx+88h]
.text$mn:00001CFD                 push    eax             ; wParam
.text$mn:00001CFE                 push    133Ch           ; Msg
.text$mn:00001D03                 mov     ecx, [ebp+var_4]
.text$mn:00001D06                 mov     edx, [ecx+80h]
.text$mn:00001D0C                 push    edx             ; hWnd
.text$mn:00001D0D                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001D13                 mov     esp, ebp
.text$mn:00001D15                 pop     ebp
.text$mn:00001D16                 retn
.text$mn:00001D16 ?initTabInformation@Gripper@@IAEXXZ endp
.text$mn:00001D16
.text$mn:00001D16 ; ---------------------------------------------------------------------------
.text$mn:00001D17                 db 0Dh dup(0CCh)
.text$mn:00001D24
.text$mn:00001D24 ; =============== S U B R O U T I N E =======================================
.text$mn:00001D24
.text$mn:00001D24 ; Attributes: bp-based frame
.text$mn:00001D24
.text$mn:00001D24 ; LRESULT __stdcall hookProcMouse(int code, WPARAM wParam, LPARAM lParam)
.text$mn:00001D24 ?hookProcMouse@@YGJHIJ@Z proc near      ; DATA XREF: Gripper::create(void)+97o
.text$mn:00001D24
.text$mn:00001D24 var_4           = dword ptr -4
.text$mn:00001D24 code            = dword ptr  8
.text$mn:00001D24 wParam          = dword ptr  0Ch
.text$mn:00001D24 lParam          = dword ptr  10h
.text$mn:00001D24
.text$mn:00001D24                 push    ebp
.text$mn:00001D25                 mov     ebp, esp
.text$mn:00001D27                 push    ecx
.text$mn:00001D28                 cmp     [ebp+code], 0
.text$mn:00001D2C                 jl      short loc_1D98
.text$mn:00001D2E                 mov     eax, [ebp+wParam]
.text$mn:00001D31                 mov     [ebp+var_4], eax
.text$mn:00001D34                 cmp     [ebp+var_4], 200h
.text$mn:00001D3B                 ja      short loc_1D5A
.text$mn:00001D3D                 cmp     [ebp+var_4], 200h
.text$mn:00001D44                 jz      short loc_1D65
.text$mn:00001D46                 cmp     [ebp+var_4], 0A0h ; 'á'
.text$mn:00001D4D                 jz      short loc_1D65
.text$mn:00001D4F                 cmp     [ebp+var_4], 0A2h ; 'ó'
.text$mn:00001D56                 jz      short loc_1D7C
.text$mn:00001D58                 jmp     short loc_1D98
.text$mn:00001D5A ; ---------------------------------------------------------------------------
.text$mn:00001D5A
.text$mn:00001D5A loc_1D5A:                               ; CODE XREF: hookProcMouse(int,uint,long)+17j
.text$mn:00001D5A                 cmp     [ebp+var_4], 202h
.text$mn:00001D61                 jz      short loc_1D7C
.text$mn:00001D63                 jmp     short loc_1D98
.text$mn:00001D65 ; ---------------------------------------------------------------------------
.text$mn:00001D65
.text$mn:00001D65 loc_1D65:                               ; CODE XREF: hookProcMouse(int,uint,long)+20j
.text$mn:00001D65                                         ; hookProcMouse(int,uint,long)+29j
.text$mn:00001D65                 push    0               ; lParam
.text$mn:00001D67                 push    0               ; wParam
.text$mn:00001D69                 mov     ecx, [ebp+wParam]
.text$mn:00001D6C                 push    ecx             ; Msg
.text$mn:00001D6D                 mov     edx, ds:_hWndServer
.text$mn:00001D73                 push    edx             ; hWnd
.text$mn:00001D74                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001D7A                 jmp     short loc_1D98
.text$mn:00001D7C ; ---------------------------------------------------------------------------
.text$mn:00001D7C
.text$mn:00001D7C loc_1D7C:                               ; CODE XREF: hookProcMouse(int,uint,long)+32j
.text$mn:00001D7C                                         ; hookProcMouse(int,uint,long)+3Dj
.text$mn:00001D7C                 push    0               ; lParam
.text$mn:00001D7E                 push    0               ; wParam
.text$mn:00001D80                 mov     eax, [ebp+wParam]
.text$mn:00001D83                 push    eax             ; Msg
.text$mn:00001D84                 mov     ecx, ds:_hWndServer
.text$mn:00001D8A                 push    ecx             ; hWnd
.text$mn:00001D8B                 call    dword ptr ds:__imp__SendMessageW@16 ; SendMessageW(x,x,x,x)
.text$mn:00001D91                 mov     eax, 1
.text$mn:00001D96                 jmp     short loc_1DB1
.text$mn:00001D98 ; ---------------------------------------------------------------------------
.text$mn:00001D98
.text$mn:00001D98 loc_1D98:                               ; CODE XREF: hookProcMouse(int,uint,long)+8j
.text$mn:00001D98                                         ; hookProcMouse(int,uint,long)+34j ...
.text$mn:00001D98                 mov     edx, [ebp+lParam]
.text$mn:00001D9B                 push    edx             ; lParam
.text$mn:00001D9C                 mov     eax, [ebp+wParam]
.text$mn:00001D9F                 push    eax             ; wParam
.text$mn:00001DA0                 mov     ecx, [ebp+code]
.text$mn:00001DA3                 push    ecx             ; nCode
.text$mn:00001DA4                 mov     edx, ds:_hookMouse
.text$mn:00001DAA                 push    edx             ; hhk
.text$mn:00001DAB                 call    dword ptr ds:__imp__CallNextHookEx@16 ; CallNextHookEx(x,x,x,x)
.text$mn:00001DB1
.text$mn:00001DB1 loc_1DB1:                               ; CODE XREF: hookProcMouse(int,uint,long)+72j
.text$mn:00001DB1                 mov     esp, ebp
.text$mn:00001DB3                 pop     ebp
.text$mn:00001DB4                 retn    0Ch
.text$mn:00001DB4 ?hookProcMouse@@YGJHIJ@Z endp
.text$mn:00001DB4
.text$mn:00001DB4 ; ---------------------------------------------------------------------------
.text$mn:00001DB7                 db 0Dh dup(0CCh)
.text$mn:00001DC4
.text$mn:00001DC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00001DC4
.text$mn:00001DC4 ; Attributes: bp-based frame
.text$mn:00001DC4
.text$mn:00001DC4 ; LRESULT __stdcall hookProcKeyboard(int code, WPARAM wParam, LPARAM lParam)
.text$mn:00001DC4 ?hookProcKeyboard@@YGJHIJ@Z proc near   ; DATA XREF: Gripper::create(void)+10Do
.text$mn:00001DC4
.text$mn:00001DC4 code            = dword ptr  8
.text$mn:00001DC4 wParam          = dword ptr  0Ch
.text$mn:00001DC4 lParam          = dword ptr  10h
.text$mn:00001DC4
.text$mn:00001DC4                 push    ebp
.text$mn:00001DC5                 mov     ebp, esp
.text$mn:00001DC7                 cmp     [ebp+code], 0
.text$mn:00001DCB                 jl      short loc_1DEC
.text$mn:00001DCD                 cmp     [ebp+wParam], 1Bh
.text$mn:00001DD1                 jnz     short loc_1DEC
.text$mn:00001DD3                 push    0               ; lParam
.text$mn:00001DD5                 push    0               ; wParam
.text$mn:00001DD7                 push    500Ch           ; Msg
.text$mn:00001DDC                 mov     eax, ds:_hWndServer
.text$mn:00001DE1                 push    eax             ; hWnd
.text$mn:00001DE2                 call    dword ptr ds:__imp__PostMessageW@16 ; PostMessageW(x,x,x,x)
.text$mn:00001DE8                 xor     eax, eax
.text$mn:00001DEA                 jmp     short loc_1E05
.text$mn:00001DEC ; ---------------------------------------------------------------------------
.text$mn:00001DEC
.text$mn:00001DEC loc_1DEC:                               ; CODE XREF: hookProcKeyboard(int,uint,long)+7j
.text$mn:00001DEC                                         ; hookProcKeyboard(int,uint,long)+Dj
.text$mn:00001DEC                 mov     ecx, [ebp+lParam]
.text$mn:00001DEF                 push    ecx             ; lParam
.text$mn:00001DF0                 mov     edx, [ebp+wParam]
.text$mn:00001DF3                 push    edx             ; wParam
.text$mn:00001DF4                 mov     eax, [ebp+code]
.text$mn:00001DF7                 push    eax             ; nCode
.text$mn:00001DF8                 mov     ecx, ds:_hookKeyboard
.text$mn:00001DFE                 push    ecx             ; hhk
.text$mn:00001DFF                 call    dword ptr ds:__imp__CallNextHookEx@16 ; CallNextHookEx(x,x,x,x)
.text$mn:00001E05
.text$mn:00001E05 loc_1E05:                               ; CODE XREF: hookProcKeyboard(int,uint,long)+26j
.text$mn:00001E05                 pop     ebp
.text$mn:00001E06                 retn    0Ch
.text$mn:00001E06 ?hookProcKeyboard@@YGJHIJ@Z endp
.text$mn:00001E06
.text$mn:00001E06 ; ---------------------------------------------------------------------------
.text$mn:00001E09                 align 4
.text$mn:00001E09 _text$mn        ends
.text$mn:00001E09
.text$x:00001E0C ; ===========================================================================
.text$x:00001E0C
.text$x:00001E0C ; Segment type: Pure code
.text$x:00001E0C ; Segment permissions: Read/Execute
.text$x:00001E0C _text$x         segment para public 'CODE' use32
.text$x:00001E0C                 assume cs:_text$x
.text$x:00001E0C                 ;org 1E0Ch
.text$x:00001E0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00001E0C
.text$x:00001E0C ; =============== S U B R O U T I N E =======================================
.text$x:00001E0C
.text$x:00001E0C
.text$x:00001E0C __unwindfunclet$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z$0 proc near
.text$x:00001E0C                                         ; DATA XREF: .xdata$x:00005468o
.text$x:00001E0C                 lea     ecx, [ebp-68h]
.text$x:00001E0F                 jmp     ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$x:00001E0F __unwindfunclet$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z$0 endp
.text$x:00001E0F
.text$x:00001E14
.text$x:00001E14 ; =============== S U B R O U T I N E =======================================
.text$x:00001E14
.text$x:00001E14
.text$x:00001E14 __ehhandler$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z proc near
.text$x:00001E14                                         ; DATA XREF: Gripper::doTabReordering(tagPOINT)+5o
.text$x:00001E14
.text$x:00001E14 arg_4           = dword ptr  8
.text$x:00001E14
.text$x:00001E14                 mov     edx, [esp+arg_4]
.text$x:00001E18                 lea     eax, [edx+0Ch]
.text$x:00001E1B                 mov     ecx, [edx-60h]
.text$x:00001E1E                 xor     ecx, eax
.text$x:00001E20                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E25                 mov     ecx, [edx-4]
.text$x:00001E28                 xor     ecx, eax
.text$x:00001E2A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E2F                 mov     eax, offset __ehfuncinfo$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z
.text$x:00001E34                 jmp     ___CxxFrameHandler3
.text$x:00001E34 __ehhandler$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z endp
.text$x:00001E34
.text$x:00001E39
.text$x:00001E39 ; =============== S U B R O U T I N E =======================================
.text$x:00001E39
.text$x:00001E39
.text$x:00001E39 __unwindfunclet$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z$0 proc near
.text$x:00001E39                                         ; DATA XREF: .xdata$x:00005460o
.text$x:00001E39                 lea     ecx, [ebp-44h]
.text$x:00001E3C                 jmp     ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$x:00001E3C __unwindfunclet$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z$0 endp
.text$x:00001E3C
.text$x:00001E41
.text$x:00001E41 ; =============== S U B R O U T I N E =======================================
.text$x:00001E41
.text$x:00001E41
.text$x:00001E41 __ehhandler$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z proc near
.text$x:00001E41                                         ; DATA XREF: Gripper::contHitTest(tagPOINT)+5o
.text$x:00001E41
.text$x:00001E41 arg_4           = dword ptr  8
.text$x:00001E41
.text$x:00001E41                 mov     edx, [esp+arg_4]
.text$x:00001E45                 lea     eax, [edx+0Ch]
.text$x:00001E48                 mov     ecx, [edx-60h]
.text$x:00001E4B                 xor     ecx, eax
.text$x:00001E4D                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E52                 mov     ecx, [edx-4]
.text$x:00001E55                 xor     ecx, eax
.text$x:00001E57                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E5C                 mov     eax, offset __ehfuncinfo$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z
.text$x:00001E61                 jmp     ___CxxFrameHandler3
.text$x:00001E61 __ehhandler$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z endp
.text$x:00001E61
.text$x:00001E66
.text$x:00001E66 ; =============== S U B R O U T I N E =======================================
.text$x:00001E66
.text$x:00001E66
.text$x:00001E66 __unwindfunclet$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z$0 proc near
.text$x:00001E66                                         ; DATA XREF: .xdata$x:00005458o
.text$x:00001E66                 lea     ecx, [ebp-4Ch]
.text$x:00001E69                 jmp     ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)
.text$x:00001E69 __unwindfunclet$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z$0 endp
.text$x:00001E69
.text$x:00001E6E
.text$x:00001E6E ; =============== S U B R O U T I N E =======================================
.text$x:00001E6E
.text$x:00001E6E
.text$x:00001E6E __ehhandler$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z proc near
.text$x:00001E6E                                         ; DATA XREF: Gripper::workHitTest(tagPOINT,tagRECT *)+5o
.text$x:00001E6E
.text$x:00001E6E arg_4           = dword ptr  8
.text$x:00001E6E
.text$x:00001E6E                 mov     edx, [esp+arg_4]
.text$x:00001E72                 lea     eax, [edx+0Ch]
.text$x:00001E75                 mov     ecx, [edx-54h]
.text$x:00001E78                 xor     ecx, eax
.text$x:00001E7A                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E7F                 mov     ecx, [edx-4]
.text$x:00001E82                 xor     ecx, eax
.text$x:00001E84                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00001E89                 mov     eax, offset __ehfuncinfo$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z
.text$x:00001E8E                 jmp     ___CxxFrameHandler3
.text$x:00001E8E __ehhandler$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z endp
.text$x:00001E8E
.text$x:00001E8E ; ---------------------------------------------------------------------------
.text$x:00001E93                 align 4
.text$x:00001E93 _text$x         ends
.text$x:00001E93
.text$mn:00001E94 ; ===========================================================================
.text$mn:00001E94
.text$mn:00001E94 ; Segment type: Pure code
.text$mn:00001E94 ; Segment permissions: Read/Execute
.text$mn:00001E94 _text$mn        segment para public 'CODE' use32
.text$mn:00001E94                 assume cs:_text$mn
.text$mn:00001E94                 ;org 1E94h
.text$mn:00001E94 ; COMDAT (pick any)
.text$mn:00001E94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001E94
.text$mn:00001E94 ; =============== S U B R O U T I N E =======================================
.text$mn:00001E94
.text$mn:00001E94 ; Attributes: bp-based frame
.text$mn:00001E94
.text$mn:00001E94 ; char * __cdecl std::_Allocate<char>(unsigned int, char *)
.text$mn:00001E94                 public ??$_Allocate@D@std@@YAPADIPAD@Z
.text$mn:00001E94 ??$_Allocate@D@std@@YAPADIPAD@Z proc near
.text$mn:00001E94                                         ; CODE XREF: std::allocator<char>::allocate(uint)+Dp
.text$mn:00001E94
.text$mn:00001E94 var_4           = dword ptr -4
.text$mn:00001E94 arg_0           = dword ptr  8
.text$mn:00001E94
.text$mn:00001E94                 push    ebp
.text$mn:00001E95                 mov     ebp, esp
.text$mn:00001E97                 push    ecx
.text$mn:00001E98                 mov     [ebp+var_4], 0
.text$mn:00001E9F                 cmp     [ebp+arg_0], 0
.text$mn:00001EA3                 jnz     short loc_1EA7
.text$mn:00001EA5                 jmp     short loc_1EC7
.text$mn:00001EA7 ; ---------------------------------------------------------------------------
.text$mn:00001EA7
.text$mn:00001EA7 loc_1EA7:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+Fj
.text$mn:00001EA7                 cmp     [ebp+arg_0], 0FFFFFFFFh
.text$mn:00001EAB                 ja      short loc_1EC2
.text$mn:00001EAD                 mov     eax, [ebp+arg_0]
.text$mn:00001EB0                 push    eax             ; unsigned int
.text$mn:00001EB1                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001EB6                 add     esp, 4
.text$mn:00001EB9                 mov     [ebp+var_4], eax
.text$mn:00001EBC                 cmp     [ebp+var_4], 0
.text$mn:00001EC0                 jnz     short loc_1EC7
.text$mn:00001EC2
.text$mn:00001EC2 loc_1EC2:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+17j
.text$mn:00001EC2                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001EC7
.text$mn:00001EC7 loc_1EC7:                               ; CODE XREF: std::_Allocate<char>(uint,char *)+11j
.text$mn:00001EC7                                         ; std::_Allocate<char>(uint,char *)+2Cj
.text$mn:00001EC7                 mov     eax, [ebp+var_4]
.text$mn:00001ECA                 mov     esp, ebp
.text$mn:00001ECC                 pop     ebp
.text$mn:00001ECD                 retn
.text$mn:00001ECD ??$_Allocate@D@std@@YAPADIPAD@Z endp
.text$mn:00001ECD
.text$mn:00001ECD ; ---------------------------------------------------------------------------
.text$mn:00001ECE                 align 10h
.text$mn:00001ECE _text$mn        ends
.text$mn:00001ECE
.text$mn:00001ED0 ; ===========================================================================
.text$mn:00001ED0
.text$mn:00001ED0 ; Segment type: Pure code
.text$mn:00001ED0 ; Segment permissions: Read/Execute
.text$mn:00001ED0 _text$mn        segment para public 'CODE' use32
.text$mn:00001ED0                 assume cs:_text$mn
.text$mn:00001ED0                 ;org 1ED0h
.text$mn:00001ED0 ; COMDAT (pick any)
.text$mn:00001ED0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001ED0
.text$mn:00001ED0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001ED0
.text$mn:00001ED0 ; Attributes: bp-based frame
.text$mn:00001ED0
.text$mn:00001ED0 ; class DockingCont * * __cdecl std::_Allocate<class DockingCont *>(unsigned int, class DockingCont * *)
.text$mn:00001ED0                 public ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z
.text$mn:00001ED0 ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z proc near
.text$mn:00001ED0                                         ; CODE XREF: std::allocator<DockingCont *>::allocate(uint)+Dp
.text$mn:00001ED0
.text$mn:00001ED0 var_4           = dword ptr -4
.text$mn:00001ED0 arg_0           = dword ptr  8
.text$mn:00001ED0
.text$mn:00001ED0                 push    ebp
.text$mn:00001ED1                 mov     ebp, esp
.text$mn:00001ED3                 push    ecx
.text$mn:00001ED4                 mov     [ebp+var_4], 0
.text$mn:00001EDB                 cmp     [ebp+arg_0], 0
.text$mn:00001EDF                 jnz     short loc_1EE3
.text$mn:00001EE1                 jmp     short loc_1F09
.text$mn:00001EE3 ; ---------------------------------------------------------------------------
.text$mn:00001EE3
.text$mn:00001EE3 loc_1EE3:                               ; CODE XREF: std::_Allocate<DockingCont *>(uint,DockingCont * *)+Fj
.text$mn:00001EE3                 cmp     [ebp+arg_0], 3FFFFFFFh
.text$mn:00001EEA                 ja      short loc_1F04
.text$mn:00001EEC                 mov     eax, [ebp+arg_0]
.text$mn:00001EEF                 shl     eax, 2
.text$mn:00001EF2                 push    eax             ; unsigned int
.text$mn:00001EF3                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001EF8                 add     esp, 4
.text$mn:00001EFB                 mov     [ebp+var_4], eax
.text$mn:00001EFE                 cmp     [ebp+var_4], 0
.text$mn:00001F02                 jnz     short loc_1F09
.text$mn:00001F04
.text$mn:00001F04 loc_1F04:                               ; CODE XREF: std::_Allocate<DockingCont *>(uint,DockingCont * *)+1Aj
.text$mn:00001F04                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001F09
.text$mn:00001F09 loc_1F09:                               ; CODE XREF: std::_Allocate<DockingCont *>(uint,DockingCont * *)+11j
.text$mn:00001F09                                         ; std::_Allocate<DockingCont *>(uint,DockingCont * *)+32j
.text$mn:00001F09                 mov     eax, [ebp+var_4]
.text$mn:00001F0C                 mov     esp, ebp
.text$mn:00001F0E                 pop     ebp
.text$mn:00001F0F                 retn
.text$mn:00001F0F ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z endp
.text$mn:00001F0F
.text$mn:00001F0F _text$mn        ends
.text$mn:00001F0F
.text$mn:00001F10 ; ===========================================================================
.text$mn:00001F10
.text$mn:00001F10 ; Segment type: Pure code
.text$mn:00001F10 ; Segment permissions: Read/Execute
.text$mn:00001F10 _text$mn        segment para public 'CODE' use32
.text$mn:00001F10                 assume cs:_text$mn
.text$mn:00001F10                 ;org 1F10h
.text$mn:00001F10 ; COMDAT (pick any)
.text$mn:00001F10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F10
.text$mn:00001F10 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F10
.text$mn:00001F10 ; Attributes: bp-based frame
.text$mn:00001F10
.text$mn:00001F10 ; struct std::_Container_proxy * __cdecl std::_Allocate<struct std::_Container_proxy>(unsigned int, struct std::_Container_proxy *)
.text$mn:00001F10                 public ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z
.text$mn:00001F10 ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z proc near
.text$mn:00001F10                                         ; CODE XREF: std::allocator<std::_Container_proxy>::allocate(uint)+Dp
.text$mn:00001F10
.text$mn:00001F10 var_4           = dword ptr -4
.text$mn:00001F10 arg_0           = dword ptr  8
.text$mn:00001F10
.text$mn:00001F10                 push    ebp
.text$mn:00001F11                 mov     ebp, esp
.text$mn:00001F13                 push    ecx
.text$mn:00001F14                 mov     [ebp+var_4], 0
.text$mn:00001F1B                 cmp     [ebp+arg_0], 0
.text$mn:00001F1F                 jnz     short loc_1F23
.text$mn:00001F21                 jmp     short loc_1F49
.text$mn:00001F23 ; ---------------------------------------------------------------------------
.text$mn:00001F23
.text$mn:00001F23 loc_1F23:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+Fj
.text$mn:00001F23                 cmp     [ebp+arg_0], 1FFFFFFFh
.text$mn:00001F2A                 ja      short loc_1F44
.text$mn:00001F2C                 mov     eax, [ebp+arg_0]
.text$mn:00001F2F                 shl     eax, 3
.text$mn:00001F32                 push    eax             ; unsigned int
.text$mn:00001F33                 call    ??2@YAPAXI@Z    ; operator new(uint)
.text$mn:00001F38                 add     esp, 4
.text$mn:00001F3B                 mov     [ebp+var_4], eax
.text$mn:00001F3E                 cmp     [ebp+var_4], 0
.text$mn:00001F42                 jnz     short loc_1F49
.text$mn:00001F44
.text$mn:00001F44 loc_1F44:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+1Aj
.text$mn:00001F44                 call    ?_Xbad_alloc@std@@YAXXZ ; std::_Xbad_alloc(void)
.text$mn:00001F49
.text$mn:00001F49 loc_1F49:                               ; CODE XREF: std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+11j
.text$mn:00001F49                                         ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)+32j
.text$mn:00001F49                 mov     eax, [ebp+var_4]
.text$mn:00001F4C                 mov     esp, ebp
.text$mn:00001F4E                 pop     ebp
.text$mn:00001F4F                 retn
.text$mn:00001F4F ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z endp
.text$mn:00001F4F
.text$mn:00001F4F _text$mn        ends
.text$mn:00001F4F
.text$mn:00001F50 ; ===========================================================================
.text$mn:00001F50
.text$mn:00001F50 ; Segment type: Pure code
.text$mn:00001F50 ; Segment permissions: Read/Execute
.text$mn:00001F50 _text$mn        segment para public 'CODE' use32
.text$mn:00001F50                 assume cs:_text$mn
.text$mn:00001F50                 ;org 1F50h
.text$mn:00001F50 ; COMDAT (pick any)
.text$mn:00001F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F50
.text$mn:00001F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F50
.text$mn:00001F50 ; Attributes: bp-based frame
.text$mn:00001F50
.text$mn:00001F50 ; int __cdecl std::_Debug_pointer<char>(int, wchar_t *, unsigned int)
.text$mn:00001F50                 public ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z
.text$mn:00001F50 ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z proc near
.text$mn:00001F50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+15p
.text$mn:00001F50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+1Bp
.text$mn:00001F50
.text$mn:00001F50 arg_0           = dword ptr  8
.text$mn:00001F50 arg_4           = dword ptr  0Ch
.text$mn:00001F50 arg_8           = dword ptr  10h
.text$mn:00001F50
.text$mn:00001F50                 push    ebp
.text$mn:00001F51                 mov     ebp, esp
.text$mn:00001F53                 cmp     [ebp+arg_0], 0
.text$mn:00001F57                 jnz     short loc_1F6E
.text$mn:00001F59                 mov     eax, [ebp+arg_8]
.text$mn:00001F5C                 push    eax             ; unsigned int
.text$mn:00001F5D                 mov     ecx, [ebp+arg_4]
.text$mn:00001F60                 push    ecx             ; wchar_t *
.text$mn:00001F61                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001F66                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001F6B                 add     esp, 0Ch
.text$mn:00001F6E
.text$mn:00001F6E loc_1F6E:                               ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+7j
.text$mn:00001F6E                 pop     ebp
.text$mn:00001F6F                 retn
.text$mn:00001F6F ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z endp
.text$mn:00001F6F
.text$mn:00001F6F _text$mn        ends
.text$mn:00001F6F
.text$mn:00001F70 ; ===========================================================================
.text$mn:00001F70
.text$mn:00001F70 ; Segment type: Pure code
.text$mn:00001F70 ; Segment permissions: Read/Execute
.text$mn:00001F70 _text$mn        segment para public 'CODE' use32
.text$mn:00001F70                 assume cs:_text$mn
.text$mn:00001F70                 ;org 1F70h
.text$mn:00001F70 ; COMDAT (pick any)
.text$mn:00001F70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F70
.text$mn:00001F70 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F70
.text$mn:00001F70 ; Attributes: bp-based frame
.text$mn:00001F70
.text$mn:00001F70 ; int __cdecl std::_Debug_pointer<DockingCont *>(int, wchar_t *, unsigned int)
.text$mn:00001F70                 public ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z
.text$mn:00001F70 ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z proc near
.text$mn:00001F70                                         ; CODE XREF: std::_Uninit_copy<DockingCont * const,DockingCont *>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)+2Cp
.text$mn:00001F70
.text$mn:00001F70 arg_0           = dword ptr  8
.text$mn:00001F70 arg_4           = dword ptr  0Ch
.text$mn:00001F70 arg_8           = dword ptr  10h
.text$mn:00001F70
.text$mn:00001F70                 push    ebp
.text$mn:00001F71                 mov     ebp, esp
.text$mn:00001F73                 cmp     [ebp+arg_0], 0
.text$mn:00001F77                 jnz     short loc_1F8E
.text$mn:00001F79                 mov     eax, [ebp+arg_8]
.text$mn:00001F7C                 push    eax             ; unsigned int
.text$mn:00001F7D                 mov     ecx, [ebp+arg_4]
.text$mn:00001F80                 push    ecx             ; wchar_t *
.text$mn:00001F81                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001F86                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001F8B                 add     esp, 0Ch
.text$mn:00001F8E
.text$mn:00001F8E loc_1F8E:                               ; CODE XREF: std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)+7j
.text$mn:00001F8E                 pop     ebp
.text$mn:00001F8F                 retn
.text$mn:00001F8F ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z endp
.text$mn:00001F8F
.text$mn:00001F8F _text$mn        ends
.text$mn:00001F8F
.text$mn:00001F90 ; ===========================================================================
.text$mn:00001F90
.text$mn:00001F90 ; Segment type: Pure code
.text$mn:00001F90 ; Segment permissions: Read/Execute
.text$mn:00001F90 _text$mn        segment para public 'CODE' use32
.text$mn:00001F90                 assume cs:_text$mn
.text$mn:00001F90                 ;org 1F90h
.text$mn:00001F90 ; COMDAT (pick any)
.text$mn:00001F90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001F90
.text$mn:00001F90 ; =============== S U B R O U T I N E =======================================
.text$mn:00001F90
.text$mn:00001F90 ; Attributes: bp-based frame
.text$mn:00001F90
.text$mn:00001F90 ; int __cdecl std::_Debug_pointer<DockingCont *>(int, wchar_t *, unsigned int)
.text$mn:00001F90                 public ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPBQAVDockingCont@@PB_WI@Z
.text$mn:00001F90 ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPBQAVDockingCont@@PB_WI@Z proc near
.text$mn:00001F90                                         ; CODE XREF: std::_Debug_range2<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint,std::random_access_iterator_tag)+17p
.text$mn:00001F90                                         ; std::_Debug_range2<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint,std::random_access_iterator_tag)+2Bp
.text$mn:00001F90
.text$mn:00001F90 arg_0           = dword ptr  8
.text$mn:00001F90 arg_4           = dword ptr  0Ch
.text$mn:00001F90 arg_8           = dword ptr  10h
.text$mn:00001F90
.text$mn:00001F90                 push    ebp
.text$mn:00001F91                 mov     ebp, esp
.text$mn:00001F93                 cmp     [ebp+arg_0], 0
.text$mn:00001F97                 jnz     short loc_1FAE
.text$mn:00001F99                 mov     eax, [ebp+arg_8]
.text$mn:00001F9C                 push    eax             ; unsigned int
.text$mn:00001F9D                 mov     ecx, [ebp+arg_4]
.text$mn:00001FA0                 push    ecx             ; wchar_t *
.text$mn:00001FA1                 push    offset ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@ ; "invalid null pointer"
.text$mn:00001FA6                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001FAB                 add     esp, 0Ch
.text$mn:00001FAE
.text$mn:00001FAE loc_1FAE:                               ; CODE XREF: std::_Debug_pointer<DockingCont *>(DockingCont * const *,wchar_t const *,uint)+7j
.text$mn:00001FAE                 pop     ebp
.text$mn:00001FAF                 retn
.text$mn:00001FAF ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPBQAVDockingCont@@PB_WI@Z endp
.text$mn:00001FAF
.text$mn:00001FAF _text$mn        ends
.text$mn:00001FAF
.text$mn:00001FB0 ; ===========================================================================
.text$mn:00001FB0
.text$mn:00001FB0 ; Segment type: Pure code
.text$mn:00001FB0 ; Segment permissions: Read/Execute
.text$mn:00001FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00001FB0                 assume cs:_text$mn
.text$mn:00001FB0                 ;org 1FB0h
.text$mn:00001FB0 ; COMDAT (pick any)
.text$mn:00001FB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00001FB0
.text$mn:00001FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00001FB0
.text$mn:00001FB0 ; Attributes: bp-based frame
.text$mn:00001FB0
.text$mn:00001FB0 ; int __cdecl std::_Debug_range2<DockingCont * const *>(int, int, wchar_t *, unsigned int)
.text$mn:00001FB0                 public ??$_Debug_range2@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z
.text$mn:00001FB0 ??$_Debug_range2@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z proc near
.text$mn:00001FB0                                         ; CODE XREF: std::_Debug_range<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint)+2Ap
.text$mn:00001FB0
.text$mn:00001FB0 arg_0           = dword ptr  8
.text$mn:00001FB0 arg_4           = dword ptr  0Ch
.text$mn:00001FB0 arg_8           = dword ptr  10h
.text$mn:00001FB0 arg_C           = dword ptr  14h
.text$mn:00001FB0
.text$mn:00001FB0                 push    ebp
.text$mn:00001FB1                 mov     ebp, esp
.text$mn:00001FB3                 mov     eax, [ebp+arg_0]
.text$mn:00001FB6                 cmp     eax, [ebp+arg_4]
.text$mn:00001FB9                 jz      short loc_2000
.text$mn:00001FBB                 mov     ecx, [ebp+arg_C]
.text$mn:00001FBE                 push    ecx             ; unsigned int
.text$mn:00001FBF                 mov     edx, [ebp+arg_8]
.text$mn:00001FC2                 push    edx             ; wchar_t *
.text$mn:00001FC3                 mov     eax, [ebp+arg_0]
.text$mn:00001FC6                 push    eax             ; int
.text$mn:00001FC7                 call    ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPBQAVDockingCont@@PB_WI@Z ; std::_Debug_pointer<DockingCont *>(DockingCont * const *,wchar_t const *,uint)
.text$mn:00001FCC                 add     esp, 0Ch
.text$mn:00001FCF                 mov     ecx, [ebp+arg_C]
.text$mn:00001FD2                 push    ecx             ; unsigned int
.text$mn:00001FD3                 mov     edx, [ebp+arg_8]
.text$mn:00001FD6                 push    edx             ; wchar_t *
.text$mn:00001FD7                 mov     eax, [ebp+arg_4]
.text$mn:00001FDA                 push    eax             ; int
.text$mn:00001FDB                 call    ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPBQAVDockingCont@@PB_WI@Z ; std::_Debug_pointer<DockingCont *>(DockingCont * const *,wchar_t const *,uint)
.text$mn:00001FE0                 add     esp, 0Ch
.text$mn:00001FE3                 mov     ecx, [ebp+arg_4]
.text$mn:00001FE6                 cmp     ecx, [ebp+arg_0]
.text$mn:00001FE9                 jnb     short loc_2000
.text$mn:00001FEB                 mov     edx, [ebp+arg_C]
.text$mn:00001FEE                 push    edx             ; unsigned int
.text$mn:00001FEF                 mov     eax, [ebp+arg_8]
.text$mn:00001FF2                 push    eax             ; wchar_t *
.text$mn:00001FF3                 push    offset ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "invalid iterator range"
.text$mn:00001FF8                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00001FFD                 add     esp, 0Ch
.text$mn:00002000
.text$mn:00002000 loc_2000:                               ; CODE XREF: std::_Debug_range2<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint,std::random_access_iterator_tag)+9j
.text$mn:00002000                                         ; std::_Debug_range2<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint,std::random_access_iterator_tag)+39j
.text$mn:00002000                 pop     ebp
.text$mn:00002001                 retn
.text$mn:00002001 ??$_Debug_range2@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z endp
.text$mn:00002001
.text$mn:00002001 ; ---------------------------------------------------------------------------
.text$mn:00002002                 align 4
.text$mn:00002002 _text$mn        ends
.text$mn:00002002
.text$mn:00002004 ; ===========================================================================
.text$mn:00002004
.text$mn:00002004 ; Segment type: Pure code
.text$mn:00002004 ; Segment permissions: Read/Execute
.text$mn:00002004 _text$mn        segment para public 'CODE' use32
.text$mn:00002004                 assume cs:_text$mn
.text$mn:00002004                 ;org 2004h
.text$mn:00002004 ; COMDAT (pick any)
.text$mn:00002004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002004
.text$mn:00002004 ; =============== S U B R O U T I N E =======================================
.text$mn:00002004
.text$mn:00002004 ; Attributes: bp-based frame
.text$mn:00002004
.text$mn:00002004 ; int __cdecl std::_Debug_range<DockingCont * const *>(int, int, wchar_t *, unsigned int)
.text$mn:00002004                 public ??$_Debug_range@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WI@Z
.text$mn:00002004 ??$_Debug_range@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WI@Z proc near
.text$mn:00002004                                         ; CODE XREF: std::_Uninit_copy<DockingCont * const,DockingCont *>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)+16p
.text$mn:00002004
.text$mn:00002004 var_1           = byte ptr -1
.text$mn:00002004 arg_0           = dword ptr  8
.text$mn:00002004 arg_4           = dword ptr  0Ch
.text$mn:00002004 arg_8           = dword ptr  10h
.text$mn:00002004 arg_C           = dword ptr  14h
.text$mn:00002004
.text$mn:00002004                 push    ebp
.text$mn:00002005                 mov     ebp, esp
.text$mn:00002007                 push    ecx
.text$mn:00002008                 lea     eax, [ebp+arg_0]
.text$mn:0000200B                 push    eax
.text$mn:0000200C                 lea     ecx, [ebp+var_1]
.text$mn:0000200F                 push    ecx
.text$mn:00002010                 call    ??$_Iter_cat@PBQAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAVDockingCont@@@Z ; std::_Iter_cat<DockingCont * const *>(DockingCont * const * const &)
.text$mn:00002015                 add     esp, 8
.text$mn:00002018                 mov     dl, [eax]
.text$mn:0000201A                 movzx   eax, dl
.text$mn:0000201D                 push    eax
.text$mn:0000201E                 mov     ecx, [ebp+arg_C]
.text$mn:00002021                 push    ecx             ; unsigned int
.text$mn:00002022                 mov     edx, [ebp+arg_8]
.text$mn:00002025                 push    edx             ; wchar_t *
.text$mn:00002026                 mov     eax, [ebp+arg_4]
.text$mn:00002029                 push    eax             ; int
.text$mn:0000202A                 mov     ecx, [ebp+arg_0]
.text$mn:0000202D                 push    ecx             ; int
.text$mn:0000202E                 call    ??$_Debug_range2@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint,std::random_access_iterator_tag)
.text$mn:00002033                 add     esp, 14h
.text$mn:00002036                 mov     esp, ebp
.text$mn:00002038                 pop     ebp
.text$mn:00002039                 retn
.text$mn:00002039 ??$_Debug_range@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WI@Z endp
.text$mn:00002039
.text$mn:00002039 ; ---------------------------------------------------------------------------
.text$mn:0000203A                 align 4
.text$mn:0000203A _text$mn        ends
.text$mn:0000203A
.text$mn:0000203C ; ===========================================================================
.text$mn:0000203C
.text$mn:0000203C ; Segment type: Pure code
.text$mn:0000203C ; Segment permissions: Read/Execute
.text$mn:0000203C _text$mn        segment para public 'CODE' use32
.text$mn:0000203C                 assume cs:_text$mn
.text$mn:0000203C                 ;org 203Ch
.text$mn:0000203C ; COMDAT (pick any)
.text$mn:0000203C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000203C
.text$mn:0000203C ; =============== S U B R O U T I N E =======================================
.text$mn:0000203C
.text$mn:0000203C ; Attributes: bp-based frame
.text$mn:0000203C
.text$mn:0000203C ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class DockingCont *>>>(class DockingCont * *, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> &)
.text$mn:0000203C                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$mn:0000203C ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z proc near
.text$mn:0000203C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Destroy(DockingCont * *,DockingCont * *)+21p
.text$mn:0000203C
.text$mn:0000203C var_1           = byte ptr -1
.text$mn:0000203C arg_0           = dword ptr  8
.text$mn:0000203C arg_4           = dword ptr  0Ch
.text$mn:0000203C arg_8           = dword ptr  10h
.text$mn:0000203C
.text$mn:0000203C                 push    ebp
.text$mn:0000203D                 mov     ebp, esp
.text$mn:0000203F                 push    ecx
.text$mn:00002040                 mov     eax, [ebp+arg_4]
.text$mn:00002043                 push    eax
.text$mn:00002044                 mov     ecx, [ebp+arg_0]
.text$mn:00002047                 push    ecx
.text$mn:00002048                 call    ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z ; std::_Ptr_cat<DockingCont *,DockingCont *>(DockingCont * *,DockingCont * *)
.text$mn:0000204D                 add     esp, 8
.text$mn:00002050                 mov     [ebp+var_1], al
.text$mn:00002053                 movzx   edx, [ebp+var_1]
.text$mn:00002057                 push    edx
.text$mn:00002058                 mov     eax, [ebp+arg_8]
.text$mn:0000205B                 push    eax
.text$mn:0000205C                 mov     ecx, [ebp+arg_4]
.text$mn:0000205F                 push    ecx
.text$mn:00002060                 mov     edx, [ebp+arg_0]
.text$mn:00002063                 push    edx
.text$mn:00002064                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002069                 add     esp, 10h
.text$mn:0000206C                 mov     esp, ebp
.text$mn:0000206E                 pop     ebp
.text$mn:0000206F                 retn
.text$mn:0000206F ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z endp
.text$mn:0000206F
.text$mn:0000206F _text$mn        ends
.text$mn:0000206F
.text$mn:00002070 ; ===========================================================================
.text$mn:00002070
.text$mn:00002070 ; Segment type: Pure code
.text$mn:00002070 ; Segment permissions: Read/Execute
.text$mn:00002070 _text$mn        segment para public 'CODE' use32
.text$mn:00002070                 assume cs:_text$mn
.text$mn:00002070                 ;org 2070h
.text$mn:00002070 ; COMDAT (pick any)
.text$mn:00002070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002070
.text$mn:00002070 ; =============== S U B R O U T I N E =======================================
.text$mn:00002070
.text$mn:00002070 ; Attributes: bp-based frame
.text$mn:00002070
.text$mn:00002070 ; void __cdecl std::_Destroy_range<struct std::_Wrap_alloc<class std::allocator<class DockingCont *>>>(class DockingCont * *, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> &, struct std::_Scalar_ptr_iterator_tag)
.text$mn:00002070                 public ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002070 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002070                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+28p
.text$mn:00002070                 push    ebp
.text$mn:00002071                 mov     ebp, esp
.text$mn:00002073                 pop     ebp
.text$mn:00002074                 retn
.text$mn:00002074 ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:00002074
.text$mn:00002074 ; ---------------------------------------------------------------------------
.text$mn:00002075                 align 4
.text$mn:00002075 _text$mn        ends
.text$mn:00002075
.text$mn:00002078 ; ===========================================================================
.text$mn:00002078
.text$mn:00002078 ; Segment type: Pure code
.text$mn:00002078 ; Segment permissions: Read/Execute
.text$mn:00002078 _text$mn        segment para public 'CODE' use32
.text$mn:00002078                 assume cs:_text$mn
.text$mn:00002078                 ;org 2078h
.text$mn:00002078 ; COMDAT (pick any)
.text$mn:00002078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002078
.text$mn:00002078 ; =============== S U B R O U T I N E =======================================
.text$mn:00002078
.text$mn:00002078 ; Attributes: bp-based frame
.text$mn:00002078
.text$mn:00002078 ; struct std::random_access_iterator_tag __cdecl std::_Iter_cat<class DockingCont * const *>(class DockingCont * const * const &)
.text$mn:00002078                 public ??$_Iter_cat@PBQAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAVDockingCont@@@Z
.text$mn:00002078 ??$_Iter_cat@PBQAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAVDockingCont@@@Z proc near
.text$mn:00002078                                         ; CODE XREF: std::_Debug_range<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint)+Cp
.text$mn:00002078
.text$mn:00002078 var_1           = byte ptr -1
.text$mn:00002078 arg_0           = dword ptr  8
.text$mn:00002078
.text$mn:00002078                 push    ebp
.text$mn:00002079                 mov     ebp, esp
.text$mn:0000207B                 push    ecx
.text$mn:0000207C                 mov     eax, [ebp+arg_0]
.text$mn:0000207F                 mov     cl, [ebp+var_1]
.text$mn:00002082                 mov     [eax], cl
.text$mn:00002084                 mov     eax, [ebp+arg_0]
.text$mn:00002087                 mov     esp, ebp
.text$mn:00002089                 pop     ebp
.text$mn:0000208A                 retn
.text$mn:0000208A ??$_Iter_cat@PBQAVDockingCont@@@std@@YA?AUrandom_access_iterator_tag@0@ABQBQAVDockingCont@@@Z endp
.text$mn:0000208A
.text$mn:0000208A ; ---------------------------------------------------------------------------
.text$mn:0000208B                 align 4
.text$mn:0000208B _text$mn        ends
.text$mn:0000208B
.text$mn:0000208C ; ===========================================================================
.text$mn:0000208C
.text$mn:0000208C ; Segment type: Pure code
.text$mn:0000208C ; Segment permissions: Read/Execute
.text$mn:0000208C _text$mn        segment para public 'CODE' use32
.text$mn:0000208C                 assume cs:_text$mn
.text$mn:0000208C                 ;org 208Ch
.text$mn:0000208C ; COMDAT (pick any)
.text$mn:0000208C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000208C
.text$mn:0000208C ; =============== S U B R O U T I N E =======================================
.text$mn:0000208C
.text$mn:0000208C ; Attributes: bp-based frame
.text$mn:0000208C
.text$mn:0000208C ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class DockingCont *, class DockingCont *>(class DockingCont * *, class DockingCont * *)
.text$mn:0000208C                 public ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z
.text$mn:0000208C ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z proc near
.text$mn:0000208C                                         ; CODE XREF: std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+Cp
.text$mn:0000208C
.text$mn:0000208C var_1           = byte ptr -1
.text$mn:0000208C
.text$mn:0000208C                 push    ebp
.text$mn:0000208D                 mov     ebp, esp
.text$mn:0000208F                 push    ecx
.text$mn:00002090                 mov     al, [ebp+var_1]
.text$mn:00002093                 mov     esp, ebp
.text$mn:00002095                 pop     ebp
.text$mn:00002096                 retn
.text$mn:00002096 ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PAPAVDockingCont@@0@Z endp
.text$mn:00002096
.text$mn:00002096 ; ---------------------------------------------------------------------------
.text$mn:00002097                 align 4
.text$mn:00002097 _text$mn        ends
.text$mn:00002097
.text$mn:00002098 ; ===========================================================================
.text$mn:00002098
.text$mn:00002098 ; Segment type: Pure code
.text$mn:00002098 ; Segment permissions: Read/Execute
.text$mn:00002098 _text$mn        segment para public 'CODE' use32
.text$mn:00002098                 assume cs:_text$mn
.text$mn:00002098                 ;org 2098h
.text$mn:00002098 ; COMDAT (pick any)
.text$mn:00002098                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002098
.text$mn:00002098 ; =============== S U B R O U T I N E =======================================
.text$mn:00002098
.text$mn:00002098 ; Attributes: bp-based frame
.text$mn:00002098
.text$mn:00002098 ; struct std::_Scalar_ptr_iterator_tag __cdecl std::_Ptr_cat<class DockingCont *, class DockingCont *>(class DockingCont * const *, class DockingCont * *)
.text$mn:00002098                 public ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVDockingCont@@PAPAV2@@Z
.text$mn:00002098 ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVDockingCont@@PAPAV2@@Z proc near
.text$mn:00002098                                         ; CODE XREF: std::_Uninit_copy<DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+Cp
.text$mn:00002098
.text$mn:00002098 var_1           = byte ptr -1
.text$mn:00002098
.text$mn:00002098                 push    ebp
.text$mn:00002099                 mov     ebp, esp
.text$mn:0000209B                 push    ecx
.text$mn:0000209C                 mov     al, [ebp+var_1]
.text$mn:0000209F                 mov     esp, ebp
.text$mn:000020A1                 pop     ebp
.text$mn:000020A2                 retn
.text$mn:000020A2 ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVDockingCont@@PAPAV2@@Z endp
.text$mn:000020A2
.text$mn:000020A2 ; ---------------------------------------------------------------------------
.text$mn:000020A3                 align 4
.text$mn:000020A3 _text$mn        ends
.text$mn:000020A3
.text$mn:000020A4 ; ===========================================================================
.text$mn:000020A4
.text$mn:000020A4 ; Segment type: Pure code
.text$mn:000020A4 ; Segment permissions: Read/Execute
.text$mn:000020A4 _text$mn        segment para public 'CODE' use32
.text$mn:000020A4                 assume cs:_text$mn
.text$mn:000020A4                 ;org 20A4h
.text$mn:000020A4 ; COMDAT (pick any)
.text$mn:000020A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020A4
.text$mn:000020A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020A4
.text$mn:000020A4 ; Attributes: bp-based frame
.text$mn:000020A4
.text$mn:000020A4 ; class DockingCont * * & __cdecl std::_Rechecked<class DockingCont * *, class DockingCont * *>(class DockingCont * * &, class DockingCont * *)
.text$mn:000020A4                 public ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z
.text$mn:000020A4 ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z proc near
.text$mn:000020A4                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+B2p
.text$mn:000020A4
.text$mn:000020A4 arg_0           = dword ptr  8
.text$mn:000020A4 arg_4           = dword ptr  0Ch
.text$mn:000020A4
.text$mn:000020A4                 push    ebp
.text$mn:000020A5                 mov     ebp, esp
.text$mn:000020A7                 mov     eax, [ebp+arg_0]
.text$mn:000020AA                 mov     ecx, [ebp+arg_4]
.text$mn:000020AD                 mov     [eax], ecx
.text$mn:000020AF                 mov     eax, [ebp+arg_0]
.text$mn:000020B2                 pop     ebp
.text$mn:000020B3                 retn
.text$mn:000020B3 ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z endp
.text$mn:000020B3
.text$mn:000020B3 _text$mn        ends
.text$mn:000020B3
.text$mn:000020B4 ; ===========================================================================
.text$mn:000020B4
.text$mn:000020B4 ; Segment type: Pure code
.text$mn:000020B4 ; Segment permissions: Read/Execute
.text$mn:000020B4 _text$mn        segment para public 'CODE' use32
.text$mn:000020B4                 assume cs:_text$mn
.text$mn:000020B4                 ;org 20B4h
.text$mn:000020B4 ; COMDAT (pick any)
.text$mn:000020B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000020B4
.text$mn:000020B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000020B4
.text$mn:000020B4 ; Attributes: bp-based frame
.text$mn:000020B4
.text$mn:000020B4 ; protected: class DockingCont * * __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Ucopy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>, class DockingCont * *)
.text$mn:000020B4                 public ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z
.text$mn:000020B4 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z proc near
.text$mn:000020B4                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+C0p
.text$mn:000020B4
.text$mn:000020B4 var_34          = dword ptr -34h
.text$mn:000020B4 var_30          = dword ptr -30h
.text$mn:000020B4 var_2C          = dword ptr -2Ch
.text$mn:000020B4 var_28          = dword ptr -28h
.text$mn:000020B4 var_24          = dword ptr -24h
.text$mn:000020B4 var_20          = dword ptr -20h
.text$mn:000020B4 var_1C          = dword ptr -1Ch
.text$mn:000020B4 var_18          = dword ptr -18h
.text$mn:000020B4 var_14          = dword ptr -14h
.text$mn:000020B4 var_D           = byte ptr -0Dh
.text$mn:000020B4 var_C           = dword ptr -0Ch
.text$mn:000020B4 var_4           = dword ptr -4
.text$mn:000020B4 arg_0           = byte ptr  8
.text$mn:000020B4 arg_C           = byte ptr  14h
.text$mn:000020B4 arg_18          = dword ptr  20h
.text$mn:000020B4
.text$mn:000020B4                 push    ebp
.text$mn:000020B5                 mov     ebp, esp
.text$mn:000020B7                 push    0FFFFFFFFh
.text$mn:000020B9                 push    offset __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z
.text$mn:000020BE                 mov     eax, large fs:0
.text$mn:000020C4                 push    eax
.text$mn:000020C5                 sub     esp, 28h
.text$mn:000020C8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000020CD                 xor     eax, ebp
.text$mn:000020CF                 push    eax
.text$mn:000020D0                 lea     eax, [ebp+var_C]
.text$mn:000020D3                 mov     large fs:0, eax
.text$mn:000020D9                 mov     [ebp+var_14], ecx
.text$mn:000020DC                 mov     [ebp+var_4], 1
.text$mn:000020E3                 lea     eax, [ebp+var_D]
.text$mn:000020E6                 push    eax
.text$mn:000020E7                 mov     ecx, [ebp+var_14]
.text$mn:000020EA                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:000020EF                 lea     ecx, [ebp+var_D]
.text$mn:000020F2                 push    ecx
.text$mn:000020F3                 mov     edx, [ebp+arg_18]
.text$mn:000020F6                 push    edx
.text$mn:000020F7                 sub     esp, 0Ch
.text$mn:000020FA                 mov     ecx, esp
.text$mn:000020FC                 mov     [ebp+var_28], esp
.text$mn:000020FF                 lea     eax, [ebp+arg_C]
.text$mn:00002102                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002103                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>> const &)
.text$mn:00002108                 mov     [ebp+var_18], eax
.text$mn:0000210B                 mov     ecx, [ebp+var_18]
.text$mn:0000210E                 mov     [ebp+var_2C], ecx
.text$mn:00002111                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002115                 sub     esp, 0Ch
.text$mn:00002118                 mov     ecx, esp
.text$mn:0000211A                 mov     [ebp+var_30], esp
.text$mn:0000211D                 lea     edx, [ebp+arg_0]
.text$mn:00002120                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:00002121                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>> const &)
.text$mn:00002126                 mov     [ebp+var_1C], eax
.text$mn:00002129                 mov     eax, [ebp+var_1C]
.text$mn:0000212C                 mov     [ebp+var_34], eax
.text$mn:0000212F                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002133                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002137                 call    ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)
.text$mn:0000213C                 add     esp, 20h
.text$mn:0000213F                 mov     [ebp+var_20], eax
.text$mn:00002142                 mov     ecx, [ebp+var_20]
.text$mn:00002145                 mov     [ebp+var_24], ecx
.text$mn:00002148                 mov     byte ptr [ebp+var_4], 0
.text$mn:0000214C                 lea     ecx, [ebp+arg_0]
.text$mn:0000214F                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$mn:00002154                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000215B                 lea     ecx, [ebp+arg_C]
.text$mn:0000215E                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$mn:00002163                 mov     eax, [ebp+var_24]
.text$mn:00002166                 mov     ecx, [ebp+var_C]
.text$mn:00002169                 mov     large fs:0, ecx
.text$mn:00002170                 pop     ecx
.text$mn:00002171                 mov     esp, ebp
.text$mn:00002173                 pop     ebp
.text$mn:00002174                 retn    1Ch
.text$mn:00002174 ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z endp
.text$mn:00002174
.text$mn:00002174 ; ---------------------------------------------------------------------------
.text$mn:00002177                 align 4
.text$mn:00002177 _text$mn        ends
.text$mn:00002177
.text$x:00002178 ; ===========================================================================
.text$x:00002178
.text$x:00002178 ; Segment type: Pure code
.text$x:00002178 ; Segment permissions: Read/Execute
.text$x:00002178 _text$x         segment para public 'CODE' use32
.text$x:00002178                 assume cs:_text$x
.text$x:00002178                 ;org 2178h
.text$x:00002178 ; COMDAT (pick associative to section at 20B4)
.text$x:00002178                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002178
.text$x:00002178 ; =============== S U B R O U T I N E =======================================
.text$x:00002178
.text$x:00002178
.text$x:00002178 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$0 proc near
.text$x:00002178                                         ; DATA XREF: .xdata$x:00005788o
.text$x:00002178                 lea     ecx, [ebp+14h]
.text$x:0000217B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:0000217B __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$0 endp
.text$x:0000217B
.text$x:00002180
.text$x:00002180 ; =============== S U B R O U T I N E =======================================
.text$x:00002180
.text$x:00002180
.text$x:00002180 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$1 proc near
.text$x:00002180                                         ; DATA XREF: .xdata$x:00005790o
.text$x:00002180                 lea     ecx, [ebp+8]
.text$x:00002183                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:00002183 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$1 endp
.text$x:00002183
.text$x:00002188
.text$x:00002188 ; =============== S U B R O U T I N E =======================================
.text$x:00002188
.text$x:00002188
.text$x:00002188 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$2 proc near
.text$x:00002188                                         ; DATA XREF: .xdata$x:00005798o
.text$x:00002188                 mov     ecx, [ebp-28h]
.text$x:0000218B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:0000218B __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$2 endp
.text$x:0000218B
.text$x:00002190
.text$x:00002190 ; =============== S U B R O U T I N E =======================================
.text$x:00002190
.text$x:00002190
.text$x:00002190 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$3 proc near
.text$x:00002190                                         ; DATA XREF: .xdata$x:000057A0o
.text$x:00002190                 mov     ecx, [ebp-30h]
.text$x:00002193                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:00002193 __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$3 endp
.text$x:00002193
.text$x:00002198
.text$x:00002198 ; =============== S U B R O U T I N E =======================================
.text$x:00002198
.text$x:00002198
.text$x:00002198 __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z proc near
.text$x:00002198                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)+5o
.text$x:00002198
.text$x:00002198 arg_4           = dword ptr  8
.text$x:00002198
.text$x:00002198                 mov     edx, [esp+arg_4]
.text$x:0000219C                 lea     eax, [edx+0Ch]
.text$x:0000219F                 mov     ecx, [edx-2Ch]
.text$x:000021A2                 xor     ecx, eax
.text$x:000021A4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000021A9                 mov     eax, offset __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z
.text$x:000021AE                 jmp     ___CxxFrameHandler3
.text$x:000021AE __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z endp
.text$x:000021AE
.text$x:000021AE ; ---------------------------------------------------------------------------
.text$x:000021B3                 align 4
.text$x:000021B3 _text$x         ends
.text$x:000021B3
.text$mn:000021B4 ; ===========================================================================
.text$mn:000021B4
.text$mn:000021B4 ; Segment type: Pure code
.text$mn:000021B4 ; Segment permissions: Read/Execute
.text$mn:000021B4 _text$mn        segment para public 'CODE' use32
.text$mn:000021B4                 assume cs:_text$mn
.text$mn:000021B4                 ;org 21B4h
.text$mn:000021B4 ; COMDAT (pick any)
.text$mn:000021B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021B4
.text$mn:000021B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000021B4
.text$mn:000021B4 ; Attributes: bp-based frame
.text$mn:000021B4
.text$mn:000021B4 ; class DockingCont * * __cdecl std::_Unchecked<class DockingCont * *>(class DockingCont * *)
.text$mn:000021B4                 public ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z
.text$mn:000021B4 ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z proc near
.text$mn:000021B4                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+34p
.text$mn:000021B4
.text$mn:000021B4 arg_0           = dword ptr  8
.text$mn:000021B4
.text$mn:000021B4                 push    ebp
.text$mn:000021B5                 mov     ebp, esp
.text$mn:000021B7                 mov     eax, [ebp+arg_0]
.text$mn:000021BA                 pop     ebp
.text$mn:000021BB                 retn
.text$mn:000021BB ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z endp
.text$mn:000021BB
.text$mn:000021BB _text$mn        ends
.text$mn:000021BB
.text$mn:000021BC ; ===========================================================================
.text$mn:000021BC
.text$mn:000021BC ; Segment type: Pure code
.text$mn:000021BC ; Segment permissions: Read/Execute
.text$mn:000021BC _text$mn        segment para public 'CODE' use32
.text$mn:000021BC                 assume cs:_text$mn
.text$mn:000021BC                 ;org 21BCh
.text$mn:000021BC ; COMDAT (pick any)
.text$mn:000021BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000021BC
.text$mn:000021BC ; =============== S U B R O U T I N E =======================================
.text$mn:000021BC
.text$mn:000021BC ; Attributes: bp-based frame
.text$mn:000021BC
.text$mn:000021BC ; class DockingCont * const * __cdecl std::_Unchecked<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>)
.text$mn:000021BC                 public ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z
.text$mn:000021BC ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z proc near
.text$mn:000021BC                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+5Fp
.text$mn:000021BC                                         ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+90p
.text$mn:000021BC
.text$mn:000021BC var_10          = dword ptr -10h
.text$mn:000021BC var_C           = dword ptr -0Ch
.text$mn:000021BC var_4           = dword ptr -4
.text$mn:000021BC arg_0           = byte ptr  8
.text$mn:000021BC
.text$mn:000021BC                 push    ebp
.text$mn:000021BD                 mov     ebp, esp
.text$mn:000021BF                 push    0FFFFFFFFh
.text$mn:000021C1                 push    offset __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z
.text$mn:000021C6                 mov     eax, large fs:0
.text$mn:000021CC                 push    eax
.text$mn:000021CD                 push    ecx
.text$mn:000021CE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000021D3                 xor     eax, ebp
.text$mn:000021D5                 push    eax
.text$mn:000021D6                 lea     eax, [ebp+var_C]
.text$mn:000021D9                 mov     large fs:0, eax
.text$mn:000021DF                 mov     [ebp+var_4], 0
.text$mn:000021E6                 lea     ecx, [ebp+arg_0]
.text$mn:000021E9                 call    ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QBEPBQAVDockingCont@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Unchecked(void)
.text$mn:000021EE                 mov     [ebp+var_10], eax
.text$mn:000021F1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000021F8                 lea     ecx, [ebp+arg_0]
.text$mn:000021FB                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$mn:00002200                 mov     eax, [ebp+var_10]
.text$mn:00002203                 mov     ecx, [ebp+var_C]
.text$mn:00002206                 mov     large fs:0, ecx
.text$mn:0000220D                 pop     ecx
.text$mn:0000220E                 mov     esp, ebp
.text$mn:00002210                 pop     ebp
.text$mn:00002211                 retn
.text$mn:00002211 ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z endp
.text$mn:00002211
.text$mn:00002211 ; ---------------------------------------------------------------------------
.text$mn:00002212                 align 4
.text$mn:00002212 _text$mn        ends
.text$mn:00002212
.text$x:00002214 ; ===========================================================================
.text$x:00002214
.text$x:00002214 ; Segment type: Pure code
.text$x:00002214 ; Segment permissions: Read/Execute
.text$x:00002214 _text$x         segment para public 'CODE' use32
.text$x:00002214                 assume cs:_text$x
.text$x:00002214                 ;org 2214h
.text$x:00002214 ; COMDAT (pick associative to section at 21BC)
.text$x:00002214                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002214
.text$x:00002214 ; =============== S U B R O U T I N E =======================================
.text$x:00002214
.text$x:00002214
.text$x:00002214 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z$0 proc near
.text$x:00002214                                         ; DATA XREF: .xdata$x:0000583Co
.text$x:00002214                 lea     ecx, [ebp+8]
.text$x:00002217                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:00002217 __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z$0 endp
.text$x:00002217
.text$x:0000221C
.text$x:0000221C ; =============== S U B R O U T I N E =======================================
.text$x:0000221C
.text$x:0000221C
.text$x:0000221C __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z proc near
.text$x:0000221C                                         ; DATA XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>)+5o
.text$x:0000221C
.text$x:0000221C arg_4           = dword ptr  8
.text$x:0000221C
.text$x:0000221C                 mov     edx, [esp+arg_4]
.text$x:00002220                 lea     eax, [edx+0Ch]
.text$x:00002223                 mov     ecx, [edx-8]
.text$x:00002226                 xor     ecx, eax
.text$x:00002228                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000222D                 mov     eax, offset __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z
.text$x:00002232                 jmp     ___CxxFrameHandler3
.text$x:00002232 __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z endp
.text$x:00002232
.text$x:00002232 ; ---------------------------------------------------------------------------
.text$x:00002237                 align 4
.text$x:00002237 _text$x         ends
.text$x:00002237
.text$mn:00002238 ; ===========================================================================
.text$mn:00002238
.text$mn:00002238 ; Segment type: Pure code
.text$mn:00002238 ; Segment permissions: Read/Execute
.text$mn:00002238 _text$mn        segment para public 'CODE' use32
.text$mn:00002238                 assume cs:_text$mn
.text$mn:00002238                 ;org 2238h
.text$mn:00002238 ; COMDAT (pick any)
.text$mn:00002238                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002238
.text$mn:00002238 ; =============== S U B R O U T I N E =======================================
.text$mn:00002238
.text$mn:00002238 ; Attributes: bp-based frame
.text$mn:00002238
.text$mn:00002238 ; int __cdecl std::_Uninit_copy<DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(void *Src, int, void *Dst, int)
.text$mn:00002238                 public ??$_Uninit_copy@PBQAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$mn:00002238 ??$_Uninit_copy@PBQAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z proc near
.text$mn:00002238                                         ; CODE XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+9Fp
.text$mn:00002238
.text$mn:00002238 var_1           = byte ptr -1
.text$mn:00002238 Src             = dword ptr  8
.text$mn:00002238 arg_4           = dword ptr  0Ch
.text$mn:00002238 Dst             = dword ptr  10h
.text$mn:00002238 arg_C           = dword ptr  14h
.text$mn:00002238
.text$mn:00002238                 push    ebp
.text$mn:00002239                 mov     ebp, esp
.text$mn:0000223B                 push    ecx
.text$mn:0000223C                 mov     eax, [ebp+Dst]
.text$mn:0000223F                 push    eax
.text$mn:00002240                 mov     ecx, [ebp+Src]
.text$mn:00002243                 push    ecx
.text$mn:00002244                 call    ??$_Ptr_cat@PAVDockingCont@@PAV1@@std@@YA?AU_Scalar_ptr_iterator_tag@0@PBQAVDockingCont@@PAPAV2@@Z ; std::_Ptr_cat<DockingCont *,DockingCont *>(DockingCont * const *,DockingCont * *)
.text$mn:00002249                 add     esp, 8
.text$mn:0000224C                 mov     [ebp+var_1], al
.text$mn:0000224F                 movzx   edx, [ebp+var_1]
.text$mn:00002253                 push    edx
.text$mn:00002254                 mov     eax, [ebp+arg_C]
.text$mn:00002257                 push    eax
.text$mn:00002258                 mov     ecx, [ebp+Dst]
.text$mn:0000225B                 push    ecx             ; Dst
.text$mn:0000225C                 mov     edx, [ebp+arg_4]
.text$mn:0000225F                 push    edx             ; int
.text$mn:00002260                 mov     eax, [ebp+Src]
.text$mn:00002263                 push    eax             ; Src
.text$mn:00002264                 call    ??$_Uninit_copy@QAVDockingCont@@PAV1@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Uninit_copy<DockingCont * const,DockingCont *>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)
.text$mn:00002269                 add     esp, 14h
.text$mn:0000226C                 mov     esp, ebp
.text$mn:0000226E                 pop     ebp
.text$mn:0000226F                 retn
.text$mn:0000226F ??$_Uninit_copy@PBQAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z endp
.text$mn:0000226F
.text$mn:0000226F _text$mn        ends
.text$mn:0000226F
.text$mn:00002270 ; ===========================================================================
.text$mn:00002270
.text$mn:00002270 ; Segment type: Pure code
.text$mn:00002270 ; Segment permissions: Read/Execute
.text$mn:00002270 _text$mn        segment para public 'CODE' use32
.text$mn:00002270                 assume cs:_text$mn
.text$mn:00002270                 ;org 2270h
.text$mn:00002270 ; COMDAT (pick any)
.text$mn:00002270                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002270
.text$mn:00002270 ; =============== S U B R O U T I N E =======================================
.text$mn:00002270
.text$mn:00002270 ; Attributes: bp-based frame
.text$mn:00002270
.text$mn:00002270 ; int __cdecl std::_Uninit_copy<DockingCont * const,DockingCont *>(void *Src, int, void *Dst)
.text$mn:00002270                 public ??$_Uninit_copy@QAVDockingCont@@PAV1@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z
.text$mn:00002270 ??$_Uninit_copy@QAVDockingCont@@PAV1@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z proc near
.text$mn:00002270                                         ; CODE XREF: std::_Uninit_copy<DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+2Cp
.text$mn:00002270
.text$mn:00002270 var_4           = dword ptr -4
.text$mn:00002270 Src             = dword ptr  8
.text$mn:00002270 arg_4           = dword ptr  0Ch
.text$mn:00002270 Dst             = dword ptr  10h
.text$mn:00002270
.text$mn:00002270                 push    ebp
.text$mn:00002271                 mov     ebp, esp
.text$mn:00002273                 push    ecx
.text$mn:00002274                 push    192h            ; unsigned int
.text$mn:00002279                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:0000227E                 mov     eax, [ebp+arg_4]
.text$mn:00002281                 push    eax             ; int
.text$mn:00002282                 mov     ecx, [ebp+Src]
.text$mn:00002285                 push    ecx             ; int
.text$mn:00002286                 call    ??$_Debug_range@PBQAVDockingCont@@@std@@YAXPBQAVDockingCont@@0PB_WI@Z ; std::_Debug_range<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint)
.text$mn:0000228B                 add     esp, 10h
.text$mn:0000228E                 push    193h            ; unsigned int
.text$mn:00002293                 push    offset ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00002298                 mov     edx, [ebp+Dst]
.text$mn:0000229B                 push    edx             ; int
.text$mn:0000229C                 call    ??$_Debug_pointer@PAVDockingCont@@@std@@YAXPAPAVDockingCont@@PB_WI@Z ; std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)
.text$mn:000022A1                 add     esp, 0Ch
.text$mn:000022A4                 mov     eax, [ebp+arg_4]
.text$mn:000022A7                 sub     eax, [ebp+Src]
.text$mn:000022AA                 sar     eax, 2
.text$mn:000022AD                 mov     [ebp+var_4], eax
.text$mn:000022B0                 mov     ecx, [ebp+var_4]
.text$mn:000022B3                 shl     ecx, 2
.text$mn:000022B6                 push    ecx             ; Size
.text$mn:000022B7                 mov     edx, [ebp+Src]
.text$mn:000022BA                 push    edx             ; Src
.text$mn:000022BB                 mov     eax, [ebp+Dst]
.text$mn:000022BE                 push    eax             ; Dst
.text$mn:000022BF                 call    _memmove
.text$mn:000022C4                 add     esp, 0Ch
.text$mn:000022C7                 mov     ecx, [ebp+var_4]
.text$mn:000022CA                 lea     eax, [eax+ecx*4]
.text$mn:000022CD                 mov     esp, ebp
.text$mn:000022CF                 pop     ebp
.text$mn:000022D0                 retn
.text$mn:000022D0 ??$_Uninit_copy@QAVDockingCont@@PAV1@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@U_Scalar_ptr_iterator_tag@0@@Z endp
.text$mn:000022D0
.text$mn:000022D0 ; ---------------------------------------------------------------------------
.text$mn:000022D1                 align 4
.text$mn:000022D1 _text$mn        ends
.text$mn:000022D1
.text$mn:000022D4 ; ===========================================================================
.text$mn:000022D4
.text$mn:000022D4 ; Segment type: Pure code
.text$mn:000022D4 ; Segment permissions: Read/Execute
.text$mn:000022D4 _text$mn        segment para public 'CODE' use32
.text$mn:000022D4                 assume cs:_text$mn
.text$mn:000022D4                 ;org 22D4h
.text$mn:000022D4 ; COMDAT (pick any)
.text$mn:000022D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000022D4
.text$mn:000022D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000022D4
.text$mn:000022D4 ; Attributes: bp-based frame
.text$mn:000022D4
.text$mn:000022D4 ; class DockingCont * * __cdecl std::_Uninitialized_copy<class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>>>(class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>, class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>, class DockingCont * *, struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> &)
.text$mn:000022D4                 public ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$mn:000022D4 ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z proc near
.text$mn:000022D4                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)+83p
.text$mn:000022D4
.text$mn:000022D4 var_34          = dword ptr -34h
.text$mn:000022D4 var_30          = dword ptr -30h
.text$mn:000022D4 var_2C          = dword ptr -2Ch
.text$mn:000022D4 var_28          = dword ptr -28h
.text$mn:000022D4 var_24          = dword ptr -24h
.text$mn:000022D4 var_20          = dword ptr -20h
.text$mn:000022D4 Src             = dword ptr -1Ch
.text$mn:000022D4 var_18          = dword ptr -18h
.text$mn:000022D4 var_14          = dword ptr -14h
.text$mn:000022D4 var_10          = dword ptr -10h
.text$mn:000022D4 var_C           = dword ptr -0Ch
.text$mn:000022D4 var_4           = dword ptr -4
.text$mn:000022D4 arg_0           = byte ptr  8
.text$mn:000022D4 arg_C           = byte ptr  14h
.text$mn:000022D4 arg_18          = dword ptr  20h
.text$mn:000022D4 arg_1C          = dword ptr  24h
.text$mn:000022D4
.text$mn:000022D4                 push    ebp
.text$mn:000022D5                 mov     ebp, esp
.text$mn:000022D7                 push    0FFFFFFFFh
.text$mn:000022D9                 push    offset __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$mn:000022DE                 mov     eax, large fs:0
.text$mn:000022E4                 push    eax
.text$mn:000022E5                 sub     esp, 28h
.text$mn:000022E8                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000022ED                 xor     eax, ebp
.text$mn:000022EF                 push    eax
.text$mn:000022F0                 lea     eax, [ebp+var_C]
.text$mn:000022F3                 mov     large fs:0, eax
.text$mn:000022F9                 mov     [ebp+var_4], 1
.text$mn:00002300                 mov     eax, [ebp+arg_1C]
.text$mn:00002303                 push    eax             ; int
.text$mn:00002304                 mov     ecx, [ebp+arg_18]
.text$mn:00002307                 push    ecx
.text$mn:00002308                 call    ??$_Unchecked@PAPAVDockingCont@@@std@@YAPAPAVDockingCont@@PAPAV1@@Z ; std::_Unchecked<DockingCont * *>(DockingCont * *)
.text$mn:0000230D                 add     esp, 4
.text$mn:00002310                 push    eax             ; Dst
.text$mn:00002311                 sub     esp, 0Ch
.text$mn:00002314                 mov     ecx, esp
.text$mn:00002316                 mov     [ebp+var_28], esp
.text$mn:00002319                 lea     edx, [ebp+arg_C]
.text$mn:0000231C                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000231D                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>> const &)
.text$mn:00002322                 mov     [ebp+var_10], eax
.text$mn:00002325                 mov     eax, [ebp+var_10]
.text$mn:00002328                 mov     [ebp+var_2C], eax
.text$mn:0000232B                 mov     byte ptr [ebp+var_4], 2
.text$mn:0000232F                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002333                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>)
.text$mn:00002338                 add     esp, 0Ch
.text$mn:0000233B                 mov     [ebp+var_14], eax
.text$mn:0000233E                 mov     ecx, [ebp+var_14]
.text$mn:00002341                 push    ecx             ; int
.text$mn:00002342                 sub     esp, 0Ch
.text$mn:00002345                 mov     ecx, esp
.text$mn:00002347                 mov     [ebp+var_30], esp
.text$mn:0000234A                 lea     edx, [ebp+arg_0]
.text$mn:0000234D                 push    edx             ; struct std::_Iterator_base12 *
.text$mn:0000234E                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>> const &)
.text$mn:00002353                 mov     [ebp+var_18], eax
.text$mn:00002356                 mov     eax, [ebp+var_18]
.text$mn:00002359                 mov     [ebp+var_34], eax
.text$mn:0000235C                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002360                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002364                 call    ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>)
.text$mn:00002369                 add     esp, 0Ch
.text$mn:0000236C                 mov     [ebp+Src], eax
.text$mn:0000236F                 mov     ecx, [ebp+Src]
.text$mn:00002372                 push    ecx             ; Src
.text$mn:00002373                 call    ??$_Uninit_copy@PBQAVDockingCont@@PAPAV1@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAPAPAVDockingCont@@PBQAV1@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z ; std::_Uninit_copy<DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)
.text$mn:00002378                 add     esp, 10h
.text$mn:0000237B                 mov     [ebp+var_20], eax
.text$mn:0000237E                 mov     edx, [ebp+var_20]
.text$mn:00002381                 push    edx
.text$mn:00002382                 lea     eax, [ebp+arg_18]
.text$mn:00002385                 push    eax
.text$mn:00002386                 call    ??$_Rechecked@PAPAVDockingCont@@PAPAV1@@std@@YAAAPAPAVDockingCont@@AAPAPAV1@PAPAV1@@Z ; std::_Rechecked<DockingCont * *,DockingCont * *>(DockingCont * * &,DockingCont * *)
.text$mn:0000238B                 add     esp, 8
.text$mn:0000238E                 mov     ecx, [eax]
.text$mn:00002390                 mov     [ebp+var_24], ecx
.text$mn:00002393                 mov     byte ptr [ebp+var_4], 0
.text$mn:00002397                 lea     ecx, [ebp+arg_0]
.text$mn:0000239A                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$mn:0000239F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000023A6                 lea     ecx, [ebp+arg_C]
.text$mn:000023A9                 call    ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$mn:000023AE                 mov     eax, [ebp+var_24]
.text$mn:000023B1                 mov     ecx, [ebp+var_C]
.text$mn:000023B4                 mov     large fs:0, ecx
.text$mn:000023BB                 pop     ecx
.text$mn:000023BC                 mov     esp, ebp
.text$mn:000023BE                 pop     ebp
.text$mn:000023BF                 retn
.text$mn:000023BF ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z endp
.text$mn:000023BF
.text$mn:000023BF _text$mn        ends
.text$mn:000023BF
.text$x:000023C0 ; ===========================================================================
.text$x:000023C0
.text$x:000023C0 ; Segment type: Pure code
.text$x:000023C0 ; Segment permissions: Read/Execute
.text$x:000023C0 _text$x         segment para public 'CODE' use32
.text$x:000023C0                 assume cs:_text$x
.text$x:000023C0                 ;org 23C0h
.text$x:000023C0 ; COMDAT (pick associative to section at 22D4)
.text$x:000023C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000023C0
.text$x:000023C0 ; =============== S U B R O U T I N E =======================================
.text$x:000023C0
.text$x:000023C0
.text$x:000023C0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$0 proc near
.text$x:000023C0                                         ; DATA XREF: .xdata$x:000057F8o
.text$x:000023C0                 lea     ecx, [ebp+14h]
.text$x:000023C3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:000023C3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$0 endp
.text$x:000023C3
.text$x:000023C8
.text$x:000023C8 ; =============== S U B R O U T I N E =======================================
.text$x:000023C8
.text$x:000023C8
.text$x:000023C8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$1 proc near
.text$x:000023C8                                         ; DATA XREF: .xdata$x:00005800o
.text$x:000023C8                 lea     ecx, [ebp+8]
.text$x:000023CB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:000023CB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$1 endp
.text$x:000023CB
.text$x:000023D0
.text$x:000023D0 ; =============== S U B R O U T I N E =======================================
.text$x:000023D0
.text$x:000023D0
.text$x:000023D0 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$2 proc near
.text$x:000023D0                                         ; DATA XREF: .xdata$x:00005808o
.text$x:000023D0                 mov     ecx, [ebp-28h]
.text$x:000023D3                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:000023D3 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$2 endp
.text$x:000023D3
.text$x:000023D8
.text$x:000023D8 ; =============== S U B R O U T I N E =======================================
.text$x:000023D8
.text$x:000023D8
.text$x:000023D8 __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$3 proc near
.text$x:000023D8                                         ; DATA XREF: .xdata$x:00005810o
.text$x:000023D8                 mov     ecx, [ebp-30h]
.text$x:000023DB                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:000023DB __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$3 endp
.text$x:000023DB
.text$x:000023E0
.text$x:000023E0 ; =============== S U B R O U T I N E =======================================
.text$x:000023E0
.text$x:000023E0
.text$x:000023E0 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z proc near
.text$x:000023E0                                         ; DATA XREF: std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)+5o
.text$x:000023E0
.text$x:000023E0 arg_4           = dword ptr  8
.text$x:000023E0
.text$x:000023E0                 mov     edx, [esp+arg_4]
.text$x:000023E4                 lea     eax, [edx+0Ch]
.text$x:000023E7                 mov     ecx, [edx-2Ch]
.text$x:000023EA                 xor     ecx, eax
.text$x:000023EC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000023F1                 mov     eax, offset __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.text$x:000023F6                 jmp     ___CxxFrameHandler3
.text$x:000023F6 __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z endp
.text$x:000023F6
.text$x:000023F6 ; ---------------------------------------------------------------------------
.text$x:000023FB                 align 4
.text$x:000023FB _text$x         ends
.text$x:000023FB
.text$mn:000023FC ; ===========================================================================
.text$mn:000023FC
.text$mn:000023FC ; Segment type: Pure code
.text$mn:000023FC ; Segment permissions: Read/Execute
.text$mn:000023FC _text$mn        segment para public 'CODE' use32
.text$mn:000023FC                 assume cs:_text$mn
.text$mn:000023FC                 ;org 23FCh
.text$mn:000023FC ; COMDAT (pick any)
.text$mn:000023FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000023FC
.text$mn:000023FC ; =============== S U B R O U T I N E =======================================
.text$mn:000023FC
.text$mn:000023FC ; Attributes: bp-based frame
.text$mn:000023FC
.text$mn:000023FC ; char * __cdecl std::addressof<char>(char &)
.text$mn:000023FC                 public ??$addressof@D@std@@YAPADAAD@Z
.text$mn:000023FC ??$addressof@D@std@@YAPADAAD@Z proc near
.text$mn:000023FC                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p
.text$mn:000023FC                                         ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)+19p ...
.text$mn:000023FC
.text$mn:000023FC arg_0           = dword ptr  8
.text$mn:000023FC
.text$mn:000023FC                 push    ebp
.text$mn:000023FD                 mov     ebp, esp
.text$mn:000023FF                 mov     eax, [ebp+arg_0]
.text$mn:00002402                 pop     ebp
.text$mn:00002403                 retn
.text$mn:00002403 ??$addressof@D@std@@YAPADAAD@Z endp
.text$mn:00002403
.text$mn:00002403 _text$mn        ends
.text$mn:00002403
.text$mn:00002404 ; ===========================================================================
.text$mn:00002404
.text$mn:00002404 ; Segment type: Pure code
.text$mn:00002404 ; Segment permissions: Read/Execute
.text$mn:00002404 _text$mn        segment para public 'CODE' use32
.text$mn:00002404                 assume cs:_text$mn
.text$mn:00002404                 ;org 2404h
.text$mn:00002404 ; COMDAT (pick any)
.text$mn:00002404                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002404
.text$mn:00002404 ; =============== S U B R O U T I N E =======================================
.text$mn:00002404
.text$mn:00002404 ; Attributes: bp-based frame
.text$mn:00002404
.text$mn:00002404 ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(void *, int)
.text$mn:00002404                 public ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
.text$mn:00002404 ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002404                                         ; CODE XREF: $LN19+4Bp
.text$mn:00002404
.text$mn:00002404 var_4           = dword ptr -4
.text$mn:00002404 arg_0           = dword ptr  8
.text$mn:00002404 arg_4           = dword ptr  0Ch
.text$mn:00002404
.text$mn:00002404                 push    ebp
.text$mn:00002405                 mov     ebp, esp
.text$mn:00002407                 push    ecx
.text$mn:00002408                 mov     [ebp+var_4], ecx
.text$mn:0000240B                 mov     eax, [ebp+arg_4]
.text$mn:0000240E                 push    eax
.text$mn:0000240F                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:00002414                 add     esp, 4
.text$mn:00002417                 push    eax             ; int
.text$mn:00002418                 mov     ecx, [ebp+arg_0]
.text$mn:0000241B                 push    ecx             ; void *
.text$mn:0000241C                 mov     edx, [ebp+var_4]
.text$mn:0000241F                 push    edx             ; int
.text$mn:00002420                 call    ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)
.text$mn:00002425                 add     esp, 0Ch
.text$mn:00002428                 mov     esp, ebp
.text$mn:0000242A                 pop     ebp
.text$mn:0000242B                 retn    8
.text$mn:0000242B ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z endp
.text$mn:0000242B
.text$mn:0000242B ; ---------------------------------------------------------------------------
.text$mn:0000242E                 align 10h
.text$mn:0000242E _text$mn        ends
.text$mn:0000242E
.text$mn:00002430 ; ===========================================================================
.text$mn:00002430
.text$mn:00002430 ; Segment type: Pure code
.text$mn:00002430 ; Segment permissions: Read/Execute
.text$mn:00002430 _text$mn        segment para public 'CODE' use32
.text$mn:00002430                 assume cs:_text$mn
.text$mn:00002430                 ;org 2430h
.text$mn:00002430 ; COMDAT (pick any)
.text$mn:00002430                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002430
.text$mn:00002430 ; =============== S U B R O U T I N E =======================================
.text$mn:00002430
.text$mn:00002430 ; Attributes: bp-based frame
.text$mn:00002430
.text$mn:00002430 ; int __stdcall std::allocator<char>::construct<char *,char * &>(void *, int)
.text$mn:00002430                 public ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:00002430 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$mn:00002430                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(std::allocator<char> &,char * *,char * &)+17p
.text$mn:00002430
.text$mn:00002430 var_1C          = dword ptr -1Ch
.text$mn:00002430 var_18          = dword ptr -18h
.text$mn:00002430 var_14          = dword ptr -14h
.text$mn:00002430 var_10          = dword ptr -10h
.text$mn:00002430 var_C           = dword ptr -0Ch
.text$mn:00002430 var_4           = dword ptr -4
.text$mn:00002430 arg_0           = dword ptr  8
.text$mn:00002430 arg_4           = dword ptr  0Ch
.text$mn:00002430
.text$mn:00002430                 push    ebp
.text$mn:00002431                 mov     ebp, esp
.text$mn:00002433                 push    0FFFFFFFFh
.text$mn:00002435                 push    offset __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$mn:0000243A                 mov     eax, large fs:0
.text$mn:00002440                 push    eax
.text$mn:00002441                 sub     esp, 10h
.text$mn:00002444                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002449                 xor     eax, ebp
.text$mn:0000244B                 push    eax
.text$mn:0000244C                 lea     eax, [ebp+var_C]
.text$mn:0000244F                 mov     large fs:0, eax
.text$mn:00002455                 mov     [ebp+var_18], ecx
.text$mn:00002458                 mov     eax, [ebp+arg_0]
.text$mn:0000245B                 push    eax             ; void *
.text$mn:0000245C                 push    4               ; unsigned int
.text$mn:0000245E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002463                 add     esp, 8
.text$mn:00002466                 mov     [ebp+var_10], eax
.text$mn:00002469                 mov     [ebp+var_4], 0
.text$mn:00002470                 cmp     [ebp+var_10], 0
.text$mn:00002474                 jz      short loc_2491
.text$mn:00002476                 mov     ecx, [ebp+arg_4]
.text$mn:00002479                 push    ecx
.text$mn:0000247A                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:0000247F                 add     esp, 4
.text$mn:00002482                 mov     edx, [ebp+var_10]
.text$mn:00002485                 mov     eax, [eax]
.text$mn:00002487                 mov     [edx], eax
.text$mn:00002489                 mov     ecx, [ebp+var_10]
.text$mn:0000248C                 mov     [ebp+var_14], ecx
.text$mn:0000248F                 jmp     short loc_2498
.text$mn:00002491 ; ---------------------------------------------------------------------------
.text$mn:00002491
.text$mn:00002491 loc_2491:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+44j
.text$mn:00002491                 mov     [ebp+var_14], 0
.text$mn:00002498
.text$mn:00002498 loc_2498:                               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5Fj
.text$mn:00002498                 mov     edx, [ebp+var_14]
.text$mn:0000249B                 mov     [ebp+var_1C], edx
.text$mn:0000249E                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000024A5                 mov     ecx, [ebp+var_C]
.text$mn:000024A8                 mov     large fs:0, ecx
.text$mn:000024AF                 pop     ecx
.text$mn:000024B0                 mov     esp, ebp
.text$mn:000024B2                 pop     ebp
.text$mn:000024B3                 retn    8
.text$mn:000024B3 ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$mn:000024B3
.text$mn:000024B3 ; ---------------------------------------------------------------------------
.text$mn:000024B6                 align 4
.text$mn:000024B6 _text$mn        ends
.text$mn:000024B6
.text$x:000024B8 ; ===========================================================================
.text$x:000024B8
.text$x:000024B8 ; Segment type: Pure code
.text$x:000024B8 ; Segment permissions: Read/Execute
.text$x:000024B8 _text$x         segment para public 'CODE' use32
.text$x:000024B8                 assume cs:_text$x
.text$x:000024B8                 ;org 24B8h
.text$x:000024B8 ; COMDAT (pick associative to section at 2430)
.text$x:000024B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000024B8
.text$x:000024B8 ; =============== S U B R O U T I N E =======================================
.text$x:000024B8
.text$x:000024B8
.text$x:000024B8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 proc near
.text$x:000024B8                                         ; DATA XREF: .xdata$x:00005868o
.text$x:000024B8                 mov     eax, [ebp+8]
.text$x:000024BB                 push    eax
.text$x:000024BC                 mov     eax, [ebp-10h]
.text$x:000024BF                 push    eax             ; void *
.text$x:000024C0                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000024C5                 add     esp, 8
.text$x:000024C8                 retn
.text$x:000024C8 __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0 endp
.text$x:000024C8
.text$x:000024C9
.text$x:000024C9 ; =============== S U B R O U T I N E =======================================
.text$x:000024C9
.text$x:000024C9
.text$x:000024C9 __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z proc near
.text$x:000024C9                                         ; DATA XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+5o
.text$x:000024C9
.text$x:000024C9 arg_4           = dword ptr  8
.text$x:000024C9
.text$x:000024C9                 mov     edx, [esp+arg_4]
.text$x:000024CD                 lea     eax, [edx+0Ch]
.text$x:000024D0                 mov     ecx, [edx-14h]
.text$x:000024D3                 xor     ecx, eax
.text$x:000024D5                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000024DA                 mov     eax, offset __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.text$x:000024DF                 jmp     ___CxxFrameHandler3
.text$x:000024DF __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z endp
.text$x:000024DF
.text$x:000024DF _text$x         ends
.text$x:000024DF
.text$mn:000024E4 ; ===========================================================================
.text$mn:000024E4
.text$mn:000024E4 ; Segment type: Pure code
.text$mn:000024E4 ; Segment permissions: Read/Execute
.text$mn:000024E4 _text$mn        segment para public 'CODE' use32
.text$mn:000024E4                 assume cs:_text$mn
.text$mn:000024E4                 ;org 24E4h
.text$mn:000024E4 ; COMDAT (pick any)
.text$mn:000024E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000024E4
.text$mn:000024E4 ; =============== S U B R O U T I N E =======================================
.text$mn:000024E4
.text$mn:000024E4 ; Attributes: bp-based frame
.text$mn:000024E4
.text$mn:000024E4 ; int __cdecl std::allocator_traits<std::allocator<char>>::construct<char *,char * &>(int, void *, int)
.text$mn:000024E4                 public ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
.text$mn:000024E4 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z proc near
.text$mn:000024E4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+1Cp
.text$mn:000024E4
.text$mn:000024E4 arg_0           = dword ptr  8
.text$mn:000024E4 arg_4           = dword ptr  0Ch
.text$mn:000024E4 arg_8           = dword ptr  10h
.text$mn:000024E4
.text$mn:000024E4                 push    ebp
.text$mn:000024E5                 mov     ebp, esp
.text$mn:000024E7                 mov     eax, [ebp+arg_8]
.text$mn:000024EA                 push    eax
.text$mn:000024EB                 call    ??$forward@AAPAD@std@@YAAAPADAAPAD@Z ; std::forward<char * &>(char * &)
.text$mn:000024F0                 add     esp, 4
.text$mn:000024F3                 push    eax             ; int
.text$mn:000024F4                 mov     ecx, [ebp+arg_4]
.text$mn:000024F7                 push    ecx             ; void *
.text$mn:000024F8                 mov     ecx, [ebp+arg_0]
.text$mn:000024FB                 call    ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)
.text$mn:00002500                 pop     ebp
.text$mn:00002501                 retn
.text$mn:00002501 ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z endp
.text$mn:00002501
.text$mn:00002501 ; ---------------------------------------------------------------------------
.text$mn:00002502                 align 4
.text$mn:00002502 _text$mn        ends
.text$mn:00002502
.text$mn:00002504 ; ===========================================================================
.text$mn:00002504
.text$mn:00002504 ; Segment type: Pure code
.text$mn:00002504 ; Segment permissions: Read/Execute
.text$mn:00002504 _text$mn        segment para public 'CODE' use32
.text$mn:00002504                 assume cs:_text$mn
.text$mn:00002504                 ;org 2504h
.text$mn:00002504 ; COMDAT (pick any)
.text$mn:00002504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002504
.text$mn:00002504 ; =============== S U B R O U T I N E =======================================
.text$mn:00002504
.text$mn:00002504 ; Attributes: bp-based frame
.text$mn:00002504
.text$mn:00002504 ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00002504                 public ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002504 ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00002504                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Alloc_proxy(void)+32p
.text$mn:00002504
.text$mn:00002504 var_4           = dword ptr -4
.text$mn:00002504 arg_0           = dword ptr  8
.text$mn:00002504 arg_4           = dword ptr  0Ch
.text$mn:00002504
.text$mn:00002504                 push    ebp
.text$mn:00002505                 mov     ebp, esp
.text$mn:00002507                 push    ecx
.text$mn:00002508                 mov     [ebp+var_4], ecx
.text$mn:0000250B                 mov     eax, [ebp+arg_4]
.text$mn:0000250E                 push    eax
.text$mn:0000250F                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:00002514                 add     esp, 4
.text$mn:00002517                 push    eax             ; int
.text$mn:00002518                 mov     ecx, [ebp+arg_0]
.text$mn:0000251B                 push    ecx             ; void *
.text$mn:0000251C                 mov     edx, [ebp+var_4]
.text$mn:0000251F                 push    edx             ; int
.text$mn:00002520                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00002525                 add     esp, 0Ch
.text$mn:00002528                 mov     esp, ebp
.text$mn:0000252A                 pop     ebp
.text$mn:0000252B                 retn    8
.text$mn:0000252B ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:0000252B
.text$mn:0000252B ; ---------------------------------------------------------------------------
.text$mn:0000252E                 align 10h
.text$mn:0000252E _text$mn        ends
.text$mn:0000252E
.text$mn:00002530 ; ===========================================================================
.text$mn:00002530
.text$mn:00002530 ; Segment type: Pure code
.text$mn:00002530 ; Segment permissions: Read/Execute
.text$mn:00002530 _text$mn        segment para public 'CODE' use32
.text$mn:00002530                 assume cs:_text$mn
.text$mn:00002530                 ;org 2530h
.text$mn:00002530 ; COMDAT (pick any)
.text$mn:00002530                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002530
.text$mn:00002530 ; =============== S U B R O U T I N E =======================================
.text$mn:00002530
.text$mn:00002530 ; Attributes: bp-based frame
.text$mn:00002530
.text$mn:00002530 ; int __stdcall std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(void *, int)
.text$mn:00002530                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:00002530 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$mn:00002530                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *,std::_Container_proxy &&)+17p
.text$mn:00002530                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+32p
.text$mn:00002530
.text$mn:00002530 var_1C          = dword ptr -1Ch
.text$mn:00002530 var_18          = dword ptr -18h
.text$mn:00002530 var_14          = dword ptr -14h
.text$mn:00002530 var_10          = dword ptr -10h
.text$mn:00002530 var_C           = dword ptr -0Ch
.text$mn:00002530 var_4           = dword ptr -4
.text$mn:00002530 arg_0           = dword ptr  8
.text$mn:00002530 arg_4           = dword ptr  0Ch
.text$mn:00002530
.text$mn:00002530                 push    ebp
.text$mn:00002531                 mov     ebp, esp
.text$mn:00002533                 push    0FFFFFFFFh
.text$mn:00002535                 push    offset __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$mn:0000253A                 mov     eax, large fs:0
.text$mn:00002540                 push    eax
.text$mn:00002541                 sub     esp, 10h
.text$mn:00002544                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002549                 xor     eax, ebp
.text$mn:0000254B                 push    eax
.text$mn:0000254C                 lea     eax, [ebp+var_C]
.text$mn:0000254F                 mov     large fs:0, eax
.text$mn:00002555                 mov     [ebp+var_18], ecx
.text$mn:00002558                 mov     eax, [ebp+arg_0]
.text$mn:0000255B                 push    eax             ; void *
.text$mn:0000255C                 push    8               ; unsigned int
.text$mn:0000255E                 call    ??2@YAPAXIPAX@Z ; operator new(uint,void *)
.text$mn:00002563                 add     esp, 8
.text$mn:00002566                 mov     [ebp+var_10], eax
.text$mn:00002569                 mov     [ebp+var_4], 0
.text$mn:00002570                 cmp     [ebp+var_10], 0
.text$mn:00002574                 jz      short loc_2597
.text$mn:00002576                 mov     ecx, [ebp+arg_4]
.text$mn:00002579                 push    ecx
.text$mn:0000257A                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:0000257F                 add     esp, 4
.text$mn:00002582                 mov     edx, [eax]
.text$mn:00002584                 mov     eax, [eax+4]
.text$mn:00002587                 mov     ecx, [ebp+var_10]
.text$mn:0000258A                 mov     [ecx], edx
.text$mn:0000258C                 mov     [ecx+4], eax
.text$mn:0000258F                 mov     edx, [ebp+var_10]
.text$mn:00002592                 mov     [ebp+var_14], edx
.text$mn:00002595                 jmp     short loc_259E
.text$mn:00002597 ; ---------------------------------------------------------------------------
.text$mn:00002597
.text$mn:00002597 loc_2597:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+44j
.text$mn:00002597                 mov     [ebp+var_14], 0
.text$mn:0000259E
.text$mn:0000259E loc_259E:                               ; CODE XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+65j
.text$mn:0000259E                 mov     eax, [ebp+var_14]
.text$mn:000025A1                 mov     [ebp+var_1C], eax
.text$mn:000025A4                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000025AB                 mov     ecx, [ebp+var_C]
.text$mn:000025AE                 mov     large fs:0, ecx
.text$mn:000025B5                 pop     ecx
.text$mn:000025B6                 mov     esp, ebp
.text$mn:000025B8                 pop     ebp
.text$mn:000025B9                 retn    8
.text$mn:000025B9 ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$mn:000025B9
.text$mn:000025B9 _text$mn        ends
.text$mn:000025B9
.text$x:000025BC ; ===========================================================================
.text$x:000025BC
.text$x:000025BC ; Segment type: Pure code
.text$x:000025BC ; Segment permissions: Read/Execute
.text$x:000025BC _text$x         segment para public 'CODE' use32
.text$x:000025BC                 assume cs:_text$x
.text$x:000025BC                 ;org 25BCh
.text$x:000025BC ; COMDAT (pick associative to section at 2530)
.text$x:000025BC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000025BC
.text$x:000025BC ; =============== S U B R O U T I N E =======================================
.text$x:000025BC
.text$x:000025BC
.text$x:000025BC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 proc near
.text$x:000025BC                                         ; DATA XREF: .xdata$x:000057CCo
.text$x:000025BC                 mov     eax, [ebp+8]
.text$x:000025BF                 push    eax
.text$x:000025C0                 mov     eax, [ebp-10h]
.text$x:000025C3                 push    eax             ; void *
.text$x:000025C4                 call    ??3@YAXPAX0@Z   ; operator delete(void *,void *)
.text$x:000025C9                 add     esp, 8
.text$x:000025CC                 retn
.text$x:000025CC __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0 endp
.text$x:000025CC
.text$x:000025CD
.text$x:000025CD ; =============== S U B R O U T I N E =======================================
.text$x:000025CD
.text$x:000025CD
.text$x:000025CD __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z proc near
.text$x:000025CD                                         ; DATA XREF: std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+5o
.text$x:000025CD
.text$x:000025CD arg_4           = dword ptr  8
.text$x:000025CD
.text$x:000025CD                 mov     edx, [esp+arg_4]
.text$x:000025D1                 lea     eax, [edx+0Ch]
.text$x:000025D4                 mov     ecx, [edx-14h]
.text$x:000025D7                 xor     ecx, eax
.text$x:000025D9                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000025DE                 mov     eax, offset __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.text$x:000025E3                 jmp     ___CxxFrameHandler3
.text$x:000025E3 __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z endp
.text$x:000025E3
.text$x:000025E3 _text$x         ends
.text$x:000025E3
.text$mn:000025E8 ; ===========================================================================
.text$mn:000025E8
.text$mn:000025E8 ; Segment type: Pure code
.text$mn:000025E8 ; Segment permissions: Read/Execute
.text$mn:000025E8 _text$mn        segment para public 'CODE' use32
.text$mn:000025E8                 assume cs:_text$mn
.text$mn:000025E8                 ;org 25E8h
.text$mn:000025E8 ; COMDAT (pick any)
.text$mn:000025E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000025E8
.text$mn:000025E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000025E8
.text$mn:000025E8 ; Attributes: bp-based frame
.text$mn:000025E8
.text$mn:000025E8 ; int __cdecl std::allocator_traits<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(int, void *, int)
.text$mn:000025E8                 public ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
.text$mn:000025E8 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z proc near
.text$mn:000025E8                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+1Cp
.text$mn:000025E8
.text$mn:000025E8 arg_0           = dword ptr  8
.text$mn:000025E8 arg_4           = dword ptr  0Ch
.text$mn:000025E8 arg_8           = dword ptr  10h
.text$mn:000025E8
.text$mn:000025E8                 push    ebp
.text$mn:000025E9                 mov     ebp, esp
.text$mn:000025EB                 mov     eax, [ebp+arg_8]
.text$mn:000025EE                 push    eax
.text$mn:000025EF                 call    ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>(std::_Container_proxy &)
.text$mn:000025F4                 add     esp, 4
.text$mn:000025F7                 push    eax             ; int
.text$mn:000025F8                 mov     ecx, [ebp+arg_4]
.text$mn:000025FB                 push    ecx             ; void *
.text$mn:000025FC                 mov     ecx, [ebp+arg_0]
.text$mn:000025FF                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00002604                 pop     ebp
.text$mn:00002605                 retn
.text$mn:00002605 ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z endp
.text$mn:00002605
.text$mn:00002605 ; ---------------------------------------------------------------------------
.text$mn:00002606                 align 4
.text$mn:00002606 _text$mn        ends
.text$mn:00002606
.text$mn:00002608 ; ===========================================================================
.text$mn:00002608
.text$mn:00002608 ; Segment type: Pure code
.text$mn:00002608 ; Segment permissions: Read/Execute
.text$mn:00002608 _text$mn        segment para public 'CODE' use32
.text$mn:00002608                 assume cs:_text$mn
.text$mn:00002608                 ;org 2608h
.text$mn:00002608 ; COMDAT (pick any)
.text$mn:00002608                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002608
.text$mn:00002608 ; =============== S U B R O U T I N E =======================================
.text$mn:00002608
.text$mn:00002608 ; Attributes: bp-based frame
.text$mn:00002608
.text$mn:00002608 ; public: void __thiscall std::_Wrap_alloc<class std::allocator<char>>::destroy<char *>(char * *)
.text$mn:00002608                 public ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
.text$mn:00002608 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z proc near
.text$mn:00002608                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+3Ap
.text$mn:00002608
.text$mn:00002608 var_4           = dword ptr -4
.text$mn:00002608 arg_0           = dword ptr  8
.text$mn:00002608
.text$mn:00002608                 push    ebp
.text$mn:00002609                 mov     ebp, esp
.text$mn:0000260B                 push    ecx
.text$mn:0000260C                 mov     [ebp+var_4], ecx
.text$mn:0000260F                 mov     eax, [ebp+arg_0]
.text$mn:00002612                 push    eax
.text$mn:00002613                 mov     ecx, [ebp+var_4]
.text$mn:00002616                 push    ecx
.text$mn:00002617                 call    ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)
.text$mn:0000261C                 add     esp, 8
.text$mn:0000261F                 mov     esp, ebp
.text$mn:00002621                 pop     ebp
.text$mn:00002622                 retn    4
.text$mn:00002622 ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z endp
.text$mn:00002622
.text$mn:00002622 ; ---------------------------------------------------------------------------
.text$mn:00002625                 align 4
.text$mn:00002625 _text$mn        ends
.text$mn:00002625
.text$mn:00002628 ; ===========================================================================
.text$mn:00002628
.text$mn:00002628 ; Segment type: Pure code
.text$mn:00002628 ; Segment permissions: Read/Execute
.text$mn:00002628 _text$mn        segment para public 'CODE' use32
.text$mn:00002628                 assume cs:_text$mn
.text$mn:00002628                 ;org 2628h
.text$mn:00002628 ; COMDAT (pick any)
.text$mn:00002628                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002628
.text$mn:00002628 ; =============== S U B R O U T I N E =======================================
.text$mn:00002628
.text$mn:00002628 ; Attributes: bp-based frame
.text$mn:00002628
.text$mn:00002628 ; public: void __thiscall std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002628                 public ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
.text$mn:00002628 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z proc near
.text$mn:00002628                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::destroy<char *>(std::allocator<char> &,char * *)+Ap
.text$mn:00002628
.text$mn:00002628 var_4           = dword ptr -4
.text$mn:00002628
.text$mn:00002628                 push    ebp
.text$mn:00002629                 mov     ebp, esp
.text$mn:0000262B                 push    ecx
.text$mn:0000262C                 mov     [ebp+var_4], ecx
.text$mn:0000262F                 mov     esp, ebp
.text$mn:00002631                 pop     ebp
.text$mn:00002632                 retn    4
.text$mn:00002632 ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z endp
.text$mn:00002632
.text$mn:00002632 ; ---------------------------------------------------------------------------
.text$mn:00002635                 align 4
.text$mn:00002635 _text$mn        ends
.text$mn:00002635
.text$mn:00002638 ; ===========================================================================
.text$mn:00002638
.text$mn:00002638 ; Segment type: Pure code
.text$mn:00002638 ; Segment permissions: Read/Execute
.text$mn:00002638 _text$mn        segment para public 'CODE' use32
.text$mn:00002638                 assume cs:_text$mn
.text$mn:00002638                 ;org 2638h
.text$mn:00002638 ; COMDAT (pick any)
.text$mn:00002638                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002638
.text$mn:00002638 ; =============== S U B R O U T I N E =======================================
.text$mn:00002638
.text$mn:00002638 ; Attributes: bp-based frame
.text$mn:00002638
.text$mn:00002638 ; public: static void __cdecl std::allocator_traits<class std::allocator<char>>::destroy<char *>(class std::allocator<char> &, char * *)
.text$mn:00002638                 public ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
.text$mn:00002638 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z proc near
.text$mn:00002638                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)+Fp
.text$mn:00002638
.text$mn:00002638 arg_0           = dword ptr  8
.text$mn:00002638 arg_4           = dword ptr  0Ch
.text$mn:00002638
.text$mn:00002638                 push    ebp
.text$mn:00002639                 mov     ebp, esp
.text$mn:0000263B                 mov     eax, [ebp+arg_4]
.text$mn:0000263E                 push    eax
.text$mn:0000263F                 mov     ecx, [ebp+arg_0]
.text$mn:00002642                 call    ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ; std::allocator<char>::destroy<char *>(char * *)
.text$mn:00002647                 pop     ebp
.text$mn:00002648                 retn
.text$mn:00002648 ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z endp
.text$mn:00002648
.text$mn:00002648 ; ---------------------------------------------------------------------------
.text$mn:00002649                 align 4
.text$mn:00002649 _text$mn        ends
.text$mn:00002649
.text$mn:0000264C ; ===========================================================================
.text$mn:0000264C
.text$mn:0000264C ; Segment type: Pure code
.text$mn:0000264C ; Segment permissions: Read/Execute
.text$mn:0000264C _text$mn        segment para public 'CODE' use32
.text$mn:0000264C                 assume cs:_text$mn
.text$mn:0000264C                 ;org 264Ch
.text$mn:0000264C ; COMDAT (pick any)
.text$mn:0000264C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000264C
.text$mn:0000264C ; =============== S U B R O U T I N E =======================================
.text$mn:0000264C
.text$mn:0000264C ; Attributes: bp-based frame
.text$mn:0000264C
.text$mn:0000264C ; public: void __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000264C                 public ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000264C ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000264C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Free_proxy(void)+22p
.text$mn:0000264C
.text$mn:0000264C var_4           = dword ptr -4
.text$mn:0000264C arg_0           = dword ptr  8
.text$mn:0000264C
.text$mn:0000264C                 push    ebp
.text$mn:0000264D                 mov     ebp, esp
.text$mn:0000264F                 push    ecx
.text$mn:00002650                 mov     [ebp+var_4], ecx
.text$mn:00002653                 mov     eax, [ebp+arg_0]
.text$mn:00002656                 push    eax
.text$mn:00002657                 mov     ecx, [ebp+var_4]
.text$mn:0000265A                 push    ecx
.text$mn:0000265B                 call    ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)
.text$mn:00002660                 add     esp, 8
.text$mn:00002663                 mov     esp, ebp
.text$mn:00002665                 pop     ebp
.text$mn:00002666                 retn    4
.text$mn:00002666 ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002666
.text$mn:00002666 ; ---------------------------------------------------------------------------
.text$mn:00002669                 align 4
.text$mn:00002669 _text$mn        ends
.text$mn:00002669
.text$mn:0000266C ; ===========================================================================
.text$mn:0000266C
.text$mn:0000266C ; Segment type: Pure code
.text$mn:0000266C ; Segment permissions: Read/Execute
.text$mn:0000266C _text$mn        segment para public 'CODE' use32
.text$mn:0000266C                 assume cs:_text$mn
.text$mn:0000266C                 ;org 266Ch
.text$mn:0000266C ; COMDAT (pick any)
.text$mn:0000266C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000266C
.text$mn:0000266C ; =============== S U B R O U T I N E =======================================
.text$mn:0000266C
.text$mn:0000266C ; Attributes: bp-based frame
.text$mn:0000266C
.text$mn:0000266C ; public: void __thiscall std::allocator<struct std::_Container_proxy>::destroy<struct std::_Container_proxy>(struct std::_Container_proxy *)
.text$mn:0000266C                 public ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
.text$mn:0000266C ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z proc near
.text$mn:0000266C                                         ; CODE XREF: std::allocator_traits<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::allocator<std::_Container_proxy> &,std::_Container_proxy *)+Ap
.text$mn:0000266C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+22p
.text$mn:0000266C
.text$mn:0000266C var_4           = dword ptr -4
.text$mn:0000266C
.text$mn:0000266C                 push    ebp
.text$mn:0000266D                 mov     ebp, esp
.text$mn:0000266F                 push    ecx
.text$mn:00002670                 mov     [ebp+var_4], ecx
.text$mn:00002673                 mov     esp, ebp
.text$mn:00002675                 pop     ebp
.text$mn:00002676                 retn    4
.text$mn:00002676 ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z endp
.text$mn:00002676
.text$mn:00002676 ; ---------------------------------------------------------------------------
.text$mn:00002679                 align 4
.text$mn:00002679 _text$mn        ends
.text$mn:00002679
.text$mn:0000267C ; ===========================================================================
.text$mn:0000267C
.text$mn:0000267C ; Segment type: Pure code
.text$mn:0000267C ; Segment permissions: Read/Execute
.text$mn:0000267C _text$mn        segment para public 'CODE' use32
.text$mn:0000267C                 assume cs:_text$mn
.text$mn:0000267C                 ;org 267Ch
.text$mn:0000267C ; COMDAT (pick any)
.text$mn:0000267C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000267C
.text$mn:0000267C ; =============== S U B R O U T I N E =======================================
.text$mn:0000267C
.text$mn:0000267C ; Attributes: bp-based frame
.text$mn:0000267C
.text$mn:0000267C ; public: static void __cdecl std::allocator_traits<class std::allocator<struct std::_Container_proxy>>::destroy<struct std::_Container_proxy>(class std::allocator<struct std::_Container_proxy> &, struct std::_Container_proxy *)
.text$mn:0000267C                 public ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
.text$mn:0000267C ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z proc near
.text$mn:0000267C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)+Fp
.text$mn:0000267C
.text$mn:0000267C arg_0           = dword ptr  8
.text$mn:0000267C arg_4           = dword ptr  0Ch
.text$mn:0000267C
.text$mn:0000267C                 push    ebp
.text$mn:0000267D                 mov     ebp, esp
.text$mn:0000267F                 mov     eax, [ebp+arg_4]
.text$mn:00002682                 push    eax
.text$mn:00002683                 mov     ecx, [ebp+arg_0]
.text$mn:00002686                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000268B                 pop     ebp
.text$mn:0000268C                 retn
.text$mn:0000268C ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z endp
.text$mn:0000268C
.text$mn:0000268C ; ---------------------------------------------------------------------------
.text$mn:0000268D                 align 10h
.text$mn:0000268D _text$mn        ends
.text$mn:0000268D
.text$mn:00002690 ; ===========================================================================
.text$mn:00002690
.text$mn:00002690 ; Segment type: Pure code
.text$mn:00002690 ; Segment permissions: Read/Execute
.text$mn:00002690 _text$mn        segment para public 'CODE' use32
.text$mn:00002690                 assume cs:_text$mn
.text$mn:00002690                 ;org 2690h
.text$mn:00002690 ; COMDAT (pick any)
.text$mn:00002690                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002690
.text$mn:00002690 ; =============== S U B R O U T I N E =======================================
.text$mn:00002690
.text$mn:00002690 ; Attributes: bp-based frame
.text$mn:00002690
.text$mn:00002690 ; char * & __cdecl std::forward<char * &>(char * &)
.text$mn:00002690                 public ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
.text$mn:00002690 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z proc near
.text$mn:00002690                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)+Bp
.text$mn:00002690                                         ; std::allocator<char>::construct<char *,char * &>(char * *,char * &)+4Ap ...
.text$mn:00002690
.text$mn:00002690 arg_0           = dword ptr  8
.text$mn:00002690
.text$mn:00002690                 push    ebp
.text$mn:00002691                 mov     ebp, esp
.text$mn:00002693                 mov     eax, [ebp+arg_0]
.text$mn:00002696                 pop     ebp
.text$mn:00002697                 retn
.text$mn:00002697 ??$forward@AAPAD@std@@YAAAPADAAPAD@Z endp
.text$mn:00002697
.text$mn:00002697 _text$mn        ends
.text$mn:00002697
.text$mn:00002698 ; ===========================================================================
.text$mn:00002698
.text$mn:00002698 ; Segment type: Pure code
.text$mn:00002698 ; Segment permissions: Read/Execute
.text$mn:00002698 _text$mn        segment para public 'CODE' use32
.text$mn:00002698                 assume cs:_text$mn
.text$mn:00002698                 ;org 2698h
.text$mn:00002698 ; COMDAT (pick any)
.text$mn:00002698                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002698
.text$mn:00002698 ; =============== S U B R O U T I N E =======================================
.text$mn:00002698
.text$mn:00002698 ; Attributes: bp-based frame
.text$mn:00002698
.text$mn:00002698 ; struct std::_Container_proxy && __cdecl std::forward<struct std::_Container_proxy>(struct std::_Container_proxy &)
.text$mn:00002698                 public ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
.text$mn:00002698 ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z proc near
.text$mn:00002698                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+Bp
.text$mn:00002698                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+4Ap ...
.text$mn:00002698
.text$mn:00002698 arg_0           = dword ptr  8
.text$mn:00002698
.text$mn:00002698                 push    ebp
.text$mn:00002699                 mov     ebp, esp
.text$mn:0000269B                 mov     eax, [ebp+arg_0]
.text$mn:0000269E                 pop     ebp
.text$mn:0000269F                 retn
.text$mn:0000269F ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z endp
.text$mn:0000269F
.text$mn:0000269F _text$mn        ends
.text$mn:0000269F
.text$mn:000026A0 ; ===========================================================================
.text$mn:000026A0
.text$mn:000026A0 ; Segment type: Pure code
.text$mn:000026A0 ; Segment permissions: Read/Execute
.text$mn:000026A0 _text$mn        segment para public 'CODE' use32
.text$mn:000026A0                 assume cs:_text$mn
.text$mn:000026A0                 ;org 26A0h
.text$mn:000026A0 ; COMDAT (pick any)
.text$mn:000026A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000026A0
.text$mn:000026A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000026A0
.text$mn:000026A0 ; Attributes: bp-based frame
.text$mn:000026A0
.text$mn:000026A0 ; int __stdcall std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(struct std::_Iterator_base12 *)
.text$mn:000026A0                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000026A0 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$mn:000026A0                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>> const &)+2Dp
.text$mn:000026A0
.text$mn:000026A0 var_10          = dword ptr -10h
.text$mn:000026A0 var_C           = dword ptr -0Ch
.text$mn:000026A0 var_4           = dword ptr -4
.text$mn:000026A0 arg_0           = dword ptr  8
.text$mn:000026A0
.text$mn:000026A0                 push    ebp
.text$mn:000026A1                 mov     ebp, esp
.text$mn:000026A3                 push    0FFFFFFFFh
.text$mn:000026A5                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$mn:000026AA                 mov     eax, large fs:0
.text$mn:000026B0                 push    eax
.text$mn:000026B1                 push    ecx
.text$mn:000026B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000026B7                 xor     eax, ebp
.text$mn:000026B9                 push    eax
.text$mn:000026BA                 lea     eax, [ebp+var_C]
.text$mn:000026BD                 mov     large fs:0, eax
.text$mn:000026C3                 mov     [ebp+var_10], ecx
.text$mn:000026C6                 mov     eax, [ebp+arg_0]
.text$mn:000026C9                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:000026CA                 mov     ecx, [ebp+var_10] ; this
.text$mn:000026CD                 call    ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)
.text$mn:000026D2                 mov     [ebp+var_4], 0
.text$mn:000026D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000026E0                 mov     eax, [ebp+var_10]
.text$mn:000026E3                 mov     ecx, [ebp+var_C]
.text$mn:000026E6                 mov     large fs:0, ecx
.text$mn:000026ED                 pop     ecx
.text$mn:000026EE                 mov     esp, ebp
.text$mn:000026F0                 pop     ebp
.text$mn:000026F1                 retn    4
.text$mn:000026F1 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$mn:000026F1
.text$mn:000026F1 _text$mn        ends
.text$mn:000026F1
.text$x:000026F4 ; ===========================================================================
.text$x:000026F4
.text$x:000026F4 ; Segment type: Pure code
.text$x:000026F4 ; Segment permissions: Read/Execute
.text$x:000026F4 _text$x         segment para public 'CODE' use32
.text$x:000026F4                 assume cs:_text$x
.text$x:000026F4                 ;org 26F4h
.text$x:000026F4 ; COMDAT (pick associative to section at 26A0)
.text$x:000026F4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000026F4
.text$x:000026F4 ; =============== S U B R O U T I N E =======================================
.text$x:000026F4
.text$x:000026F4
.text$x:000026F4 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 proc near
.text$x:000026F4                                         ; DATA XREF: .xdata$x:000056D8o
.text$x:000026F4                 mov     ecx, [ebp-10h]  ; this
.text$x:000026F7                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000026F7 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0 endp
.text$x:000026F7
.text$x:000026FC
.text$x:000026FC ; =============== S U B R O U T I N E =======================================
.text$x:000026FC
.text$x:000026FC
.text$x:000026FC __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z proc near
.text$x:000026FC                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12> const &)+5o
.text$x:000026FC
.text$x:000026FC arg_4           = dword ptr  8
.text$x:000026FC
.text$x:000026FC                 mov     edx, [esp+arg_4]
.text$x:00002700                 lea     eax, [edx+0Ch]
.text$x:00002703                 mov     ecx, [edx-8]
.text$x:00002706                 xor     ecx, eax
.text$x:00002708                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000270D                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.text$x:00002712                 jmp     ___CxxFrameHandler3
.text$x:00002712 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z endp
.text$x:00002712
.text$x:00002712 ; ---------------------------------------------------------------------------
.text$x:00002717                 align 4
.text$x:00002717 _text$x         ends
.text$x:00002717
.text$mn:00002718 ; ===========================================================================
.text$mn:00002718
.text$mn:00002718 ; Segment type: Pure code
.text$mn:00002718 ; Segment permissions: Read/Execute
.text$mn:00002718 _text$mn        segment para public 'CODE' use32
.text$mn:00002718                 assume cs:_text$mn
.text$mn:00002718                 ;org 2718h
.text$mn:00002718 ; COMDAT (pick any)
.text$mn:00002718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002718
.text$mn:00002718 ; =============== S U B R O U T I N E =======================================
.text$mn:00002718
.text$mn:00002718 ; Attributes: bp-based frame
.text$mn:00002718
.text$mn:00002718 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class DockingCont *, int, class DockingCont * const *, class DockingCont * const &, struct std::_Iterator_base12>::_Iterator012<struct std::random_access_iterator_tag, class DockingCont *, int, class DockingCont * const *, class DockingCont * const &, struct std::_Iterator_base12>(void)
.text$mn:00002718                 public ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002718 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00002718                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(DockingCont * *,std::_Container_base12 const *)+29p
.text$mn:00002718
.text$mn:00002718 var_10          = dword ptr -10h
.text$mn:00002718 var_C           = dword ptr -0Ch
.text$mn:00002718 var_4           = dword ptr -4
.text$mn:00002718
.text$mn:00002718                 push    ebp
.text$mn:00002719                 mov     ebp, esp
.text$mn:0000271B                 push    0FFFFFFFFh
.text$mn:0000271D                 push    offset __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00002722                 mov     eax, large fs:0
.text$mn:00002728                 push    eax
.text$mn:00002729                 push    ecx
.text$mn:0000272A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000272F                 xor     eax, ebp
.text$mn:00002731                 push    eax
.text$mn:00002732                 lea     eax, [ebp+var_C]
.text$mn:00002735                 mov     large fs:0, eax
.text$mn:0000273B                 mov     [ebp+var_10], ecx
.text$mn:0000273E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002741                 call    ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12(void)
.text$mn:00002746                 mov     [ebp+var_4], 0
.text$mn:0000274D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002754                 mov     eax, [ebp+var_10]
.text$mn:00002757                 mov     ecx, [ebp+var_C]
.text$mn:0000275A                 mov     large fs:0, ecx
.text$mn:00002761                 pop     ecx
.text$mn:00002762                 mov     esp, ebp
.text$mn:00002764                 pop     ebp
.text$mn:00002765                 retn
.text$mn:00002765 ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:00002765
.text$mn:00002765 ; ---------------------------------------------------------------------------
.text$mn:00002766                 align 4
.text$mn:00002766 _text$mn        ends
.text$mn:00002766
.text$x:00002768 ; ===========================================================================
.text$x:00002768
.text$x:00002768 ; Segment type: Pure code
.text$x:00002768 ; Segment permissions: Read/Execute
.text$x:00002768 _text$x         segment para public 'CODE' use32
.text$x:00002768                 assume cs:_text$x
.text$x:00002768                 ;org 2768h
.text$x:00002768 ; COMDAT (pick associative to section at 2718)
.text$x:00002768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002768
.text$x:00002768 ; =============== S U B R O U T I N E =======================================
.text$x:00002768
.text$x:00002768
.text$x:00002768 __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:00002768                                         ; DATA XREF: .xdata$x:00005680o
.text$x:00002768                 mov     ecx, [ebp-10h]  ; this
.text$x:0000276B                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:0000276B __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:0000276B
.text$x:00002770
.text$x:00002770 ; =============== S U B R O U T I N E =======================================
.text$x:00002770
.text$x:00002770
.text$x:00002770 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:00002770                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)+5o
.text$x:00002770
.text$x:00002770 arg_4           = dword ptr  8
.text$x:00002770
.text$x:00002770                 mov     edx, [esp+arg_4]
.text$x:00002774                 lea     eax, [edx+0Ch]
.text$x:00002777                 mov     ecx, [edx-8]
.text$x:0000277A                 xor     ecx, eax
.text$x:0000277C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002781                 mov     eax, offset __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:00002786                 jmp     ___CxxFrameHandler3
.text$x:00002786 __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:00002786
.text$x:00002786 ; ---------------------------------------------------------------------------
.text$x:0000278B                 align 4
.text$x:0000278B _text$x         ends
.text$x:0000278B
.text$mn:0000278C ; ===========================================================================
.text$mn:0000278C
.text$mn:0000278C ; Segment type: Pure code
.text$mn:0000278C ; Segment permissions: Read/Execute
.text$mn:0000278C _text$mn        segment para public 'CODE' use32
.text$mn:0000278C                 assume cs:_text$mn
.text$mn:0000278C                 ;org 278Ch
.text$mn:0000278C ; COMDAT (pick any)
.text$mn:0000278C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000278C
.text$mn:0000278C ; =============== S U B R O U T I N E =======================================
.text$mn:0000278C
.text$mn:0000278C ; Attributes: bp-based frame
.text$mn:0000278C
.text$mn:0000278C ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(class std::allocator<char> const &)
.text$mn:0000278C                 public ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:0000278C ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$mn:0000278C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+34p
.text$mn:0000278C
.text$mn:0000278C var_10          = dword ptr -10h
.text$mn:0000278C var_C           = dword ptr -0Ch
.text$mn:0000278C var_4           = dword ptr -4
.text$mn:0000278C
.text$mn:0000278C                 push    ebp
.text$mn:0000278D                 mov     ebp, esp
.text$mn:0000278F                 push    0FFFFFFFFh
.text$mn:00002791                 push    offset __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$mn:00002796                 mov     eax, large fs:0
.text$mn:0000279C                 push    eax
.text$mn:0000279D                 push    ecx
.text$mn:0000279E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000027A3                 xor     eax, ebp
.text$mn:000027A5                 push    eax
.text$mn:000027A6                 lea     eax, [ebp+var_C]
.text$mn:000027A9                 mov     large fs:0, eax
.text$mn:000027AF                 mov     [ebp+var_10], ecx
.text$mn:000027B2                 mov     ecx, [ebp+var_10]
.text$mn:000027B5                 call    ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)
.text$mn:000027BA                 mov     [ebp+var_4], 0
.text$mn:000027C1                 mov     ecx, [ebp+var_10]
.text$mn:000027C4                 call    ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:000027C9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000027D0                 mov     eax, [ebp+var_10]
.text$mn:000027D3                 mov     ecx, [ebp+var_C]
.text$mn:000027D6                 mov     large fs:0, ecx
.text$mn:000027DD                 pop     ecx
.text$mn:000027DE                 mov     esp, ebp
.text$mn:000027E0                 pop     ebp
.text$mn:000027E1                 retn    4
.text$mn:000027E1 ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$mn:000027E1
.text$mn:000027E1 _text$mn        ends
.text$mn:000027E1
.text$x:000027E4 ; ===========================================================================
.text$x:000027E4
.text$x:000027E4 ; Segment type: Pure code
.text$x:000027E4 ; Segment permissions: Read/Execute
.text$x:000027E4 _text$x         segment para public 'CODE' use32
.text$x:000027E4                 assume cs:_text$x
.text$x:000027E4                 ;org 27E4h
.text$x:000027E4 ; COMDAT (pick associative to section at 278C)
.text$x:000027E4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000027E4
.text$x:000027E4 ; =============== S U B R O U T I N E =======================================
.text$x:000027E4
.text$x:000027E4
.text$x:000027E4 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 proc near
.text$x:000027E4                                         ; DATA XREF: .xdata$x:0000510Co
.text$x:000027E4                 mov     ecx, [ebp-10h]
.text$x:000027E7                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:000027E7 __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0 endp
.text$x:000027E7
.text$x:000027EC
.text$x:000027EC ; =============== S U B R O U T I N E =======================================
.text$x:000027EC
.text$x:000027EC
.text$x:000027EC __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z proc near
.text$x:000027EC                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+5o
.text$x:000027EC
.text$x:000027EC arg_4           = dword ptr  8
.text$x:000027EC
.text$x:000027EC                 mov     edx, [esp+arg_4]
.text$x:000027F0                 lea     eax, [edx+0Ch]
.text$x:000027F3                 mov     ecx, [edx-8]
.text$x:000027F6                 xor     ecx, eax
.text$x:000027F8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000027FD                 mov     eax, offset __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.text$x:00002802                 jmp     ___CxxFrameHandler3
.text$x:00002802 __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z endp
.text$x:00002802
.text$x:00002802 ; ---------------------------------------------------------------------------
.text$x:00002807                 align 4
.text$x:00002807 _text$x         ends
.text$x:00002807
.text$mn:00002808 ; ===========================================================================
.text$mn:00002808
.text$mn:00002808 ; Segment type: Pure code
.text$mn:00002808 ; Segment permissions: Read/Execute
.text$mn:00002808 _text$mn        segment para public 'CODE' use32
.text$mn:00002808                 assume cs:_text$mn
.text$mn:00002808                 ;org 2808h
.text$mn:00002808 ; COMDAT (pick any)
.text$mn:00002808                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002808
.text$mn:00002808 ; =============== S U B R O U T I N E =======================================
.text$mn:00002808
.text$mn:00002808 ; Attributes: bp-based frame
.text$mn:00002808
.text$mn:00002808 ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::_String_val<struct std::_Simple_types<char>>(void)
.text$mn:00002808                 public ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002808 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:00002808                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+29p
.text$mn:00002808
.text$mn:00002808 var_10          = dword ptr -10h
.text$mn:00002808 var_C           = dword ptr -0Ch
.text$mn:00002808 var_4           = dword ptr -4
.text$mn:00002808
.text$mn:00002808                 push    ebp
.text$mn:00002809                 mov     ebp, esp
.text$mn:0000280B                 push    0FFFFFFFFh
.text$mn:0000280D                 push    offset __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00002812                 mov     eax, large fs:0
.text$mn:00002818                 push    eax
.text$mn:00002819                 push    ecx
.text$mn:0000281A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000281F                 xor     eax, ebp
.text$mn:00002821                 push    eax
.text$mn:00002822                 lea     eax, [ebp+var_C]
.text$mn:00002825                 mov     large fs:0, eax
.text$mn:0000282B                 mov     [ebp+var_10], ecx
.text$mn:0000282E                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002831                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002836                 mov     [ebp+var_4], 0
.text$mn:0000283D                 mov     eax, [ebp+var_10]
.text$mn:00002840                 mov     dword ptr [eax+14h], 0
.text$mn:00002847                 mov     ecx, [ebp+var_10]
.text$mn:0000284A                 mov     dword ptr [ecx+18h], 0
.text$mn:00002851                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002858                 mov     eax, [ebp+var_10]
.text$mn:0000285B                 mov     ecx, [ebp+var_C]
.text$mn:0000285E                 mov     large fs:0, ecx
.text$mn:00002865                 pop     ecx
.text$mn:00002866                 mov     esp, ebp
.text$mn:00002868                 pop     ebp
.text$mn:00002869                 retn
.text$mn:00002869 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:00002869
.text$mn:00002869 ; ---------------------------------------------------------------------------
.text$mn:0000286A                 align 4
.text$mn:0000286A _text$mn        ends
.text$mn:0000286A
.text$x:0000286C ; ===========================================================================
.text$x:0000286C
.text$x:0000286C ; Segment type: Pure code
.text$x:0000286C ; Segment permissions: Read/Execute
.text$x:0000286C _text$x         segment para public 'CODE' use32
.text$x:0000286C                 assume cs:_text$x
.text$x:0000286C                 ;org 286Ch
.text$x:0000286C ; COMDAT (pick associative to section at 2808)
.text$x:0000286C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000286C
.text$x:0000286C ; =============== S U B R O U T I N E =======================================
.text$x:0000286C
.text$x:0000286C
.text$x:0000286C __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:0000286C                                         ; DATA XREF: .xdata$x:000050B4o
.text$x:0000286C                 mov     ecx, [ebp-10h]  ; this
.text$x:0000286F                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:0000286F __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:0000286F
.text$x:00002874
.text$x:00002874 ; =============== S U B R O U T I N E =======================================
.text$x:00002874
.text$x:00002874
.text$x:00002874 __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:00002874                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+5o
.text$x:00002874
.text$x:00002874 arg_4           = dword ptr  8
.text$x:00002874
.text$x:00002874                 mov     edx, [esp+arg_4]
.text$x:00002878                 lea     eax, [edx+0Ch]
.text$x:0000287B                 mov     ecx, [edx-8]
.text$x:0000287E                 xor     ecx, eax
.text$x:00002880                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002885                 mov     eax, offset __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:0000288A                 jmp     ___CxxFrameHandler3
.text$x:0000288A __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:0000288A
.text$x:0000288A ; ---------------------------------------------------------------------------
.text$x:0000288F                 align 10h
.text$x:0000288F _text$x         ends
.text$x:0000288F
.text$mn:00002890 ; ===========================================================================
.text$mn:00002890
.text$mn:00002890 ; Segment type: Pure code
.text$mn:00002890 ; Segment permissions: Read/Execute
.text$mn:00002890 _text$mn        segment para public 'CODE' use32
.text$mn:00002890                 assume cs:_text$mn
.text$mn:00002890                 ;org 2890h
.text$mn:00002890 ; COMDAT (pick any)
.text$mn:00002890                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002890
.text$mn:00002890 ; =============== S U B R O U T I N E =======================================
.text$mn:00002890
.text$mn:00002890 ; Attributes: bp-based frame
.text$mn:00002890
.text$mn:00002890 ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>(class std::allocator<class DockingCont *> const &)
.text$mn:00002890                 public ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.text$mn:00002890 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z proc near
.text$mn:00002890                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+4Ap
.text$mn:00002890
.text$mn:00002890 var_10          = dword ptr -10h
.text$mn:00002890 var_C           = dword ptr -0Ch
.text$mn:00002890 var_4           = dword ptr -4
.text$mn:00002890
.text$mn:00002890                 push    ebp
.text$mn:00002891                 mov     ebp, esp
.text$mn:00002893                 push    0FFFFFFFFh
.text$mn:00002895                 push    offset __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.text$mn:0000289A                 mov     eax, large fs:0
.text$mn:000028A0                 push    eax
.text$mn:000028A1                 push    ecx
.text$mn:000028A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000028A7                 xor     eax, ebp
.text$mn:000028A9                 push    eax
.text$mn:000028AA                 lea     eax, [ebp+var_C]
.text$mn:000028AD                 mov     large fs:0, eax
.text$mn:000028B3                 mov     [ebp+var_10], ecx
.text$mn:000028B6                 mov     ecx, [ebp+var_10]
.text$mn:000028B9                 call    ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$mn:000028BE                 mov     [ebp+var_4], 0
.text$mn:000028C5                 mov     ecx, [ebp+var_10]
.text$mn:000028C8                 call    ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Alloc_proxy(void)
.text$mn:000028CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000028D4                 mov     eax, [ebp+var_10]
.text$mn:000028D7                 mov     ecx, [ebp+var_C]
.text$mn:000028DA                 mov     large fs:0, ecx
.text$mn:000028E1                 pop     ecx
.text$mn:000028E2                 mov     esp, ebp
.text$mn:000028E4                 pop     ebp
.text$mn:000028E5                 retn    4
.text$mn:000028E5 ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z endp
.text$mn:000028E5
.text$mn:000028E5 _text$mn        ends
.text$mn:000028E5
.text$x:000028E8 ; ===========================================================================
.text$x:000028E8
.text$x:000028E8 ; Segment type: Pure code
.text$x:000028E8 ; Segment permissions: Read/Execute
.text$x:000028E8 _text$x         segment para public 'CODE' use32
.text$x:000028E8                 assume cs:_text$x
.text$x:000028E8                 ;org 28E8h
.text$x:000028E8 ; COMDAT (pick associative to section at 2890)
.text$x:000028E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000028E8
.text$x:000028E8 ; =============== S U B R O U T I N E =======================================
.text$x:000028E8
.text$x:000028E8
.text$x:000028E8 __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0 proc near
.text$x:000028E8                                         ; DATA XREF: .xdata$x:00005534o
.text$x:000028E8                 mov     ecx, [ebp-10h]
.text$x:000028EB                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$x:000028EB __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0 endp
.text$x:000028EB
.text$x:000028F0
.text$x:000028F0 ; =============== S U B R O U T I N E =======================================
.text$x:000028F0
.text$x:000028F0
.text$x:000028F0 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z proc near
.text$x:000028F0                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)+5o
.text$x:000028F0
.text$x:000028F0 arg_4           = dword ptr  8
.text$x:000028F0
.text$x:000028F0                 mov     edx, [esp+arg_4]
.text$x:000028F4                 lea     eax, [edx+0Ch]
.text$x:000028F7                 mov     ecx, [edx-8]
.text$x:000028FA                 xor     ecx, eax
.text$x:000028FC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002901                 mov     eax, offset __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.text$x:00002906                 jmp     ___CxxFrameHandler3
.text$x:00002906 __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z endp
.text$x:00002906
.text$x:00002906 ; ---------------------------------------------------------------------------
.text$x:0000290B                 align 4
.text$x:0000290B _text$x         ends
.text$x:0000290B
.text$mn:0000290C ; ===========================================================================
.text$mn:0000290C
.text$mn:0000290C ; Segment type: Pure code
.text$mn:0000290C ; Segment permissions: Read/Execute
.text$mn:0000290C _text$mn        segment para public 'CODE' use32
.text$mn:0000290C                 assume cs:_text$mn
.text$mn:0000290C                 ;org 290Ch
.text$mn:0000290C ; COMDAT (pick any)
.text$mn:0000290C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000290C
.text$mn:0000290C ; =============== S U B R O U T I N E =======================================
.text$mn:0000290C
.text$mn:0000290C ; Attributes: bp-based frame
.text$mn:0000290C
.text$mn:0000290C ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(struct std::_Iterator_base12 *)
.text$mn:0000290C                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:0000290C ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:0000290C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)+4Fp
.text$mn:0000290C                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)+6Dp ...
.text$mn:0000290C
.text$mn:0000290C var_10          = dword ptr -10h
.text$mn:0000290C var_C           = dword ptr -0Ch
.text$mn:0000290C var_4           = dword ptr -4
.text$mn:0000290C arg_0           = dword ptr  8
.text$mn:0000290C
.text$mn:0000290C                 push    ebp
.text$mn:0000290D                 mov     ebp, esp
.text$mn:0000290F                 push    0FFFFFFFFh
.text$mn:00002911                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002916                 mov     eax, large fs:0
.text$mn:0000291C                 push    eax
.text$mn:0000291D                 push    ecx
.text$mn:0000291E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002923                 xor     eax, ebp
.text$mn:00002925                 push    eax
.text$mn:00002926                 lea     eax, [ebp+var_C]
.text$mn:00002929                 mov     large fs:0, eax
.text$mn:0000292F                 mov     [ebp+var_10], ecx
.text$mn:00002932                 mov     eax, [ebp+arg_0]
.text$mn:00002935                 push    eax             ; struct std::_Iterator_base12 *
.text$mn:00002936                 mov     ecx, [ebp+var_10]
.text$mn:00002939                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12> const &)
.text$mn:0000293E                 mov     [ebp+var_4], 0
.text$mn:00002945                 mov     ecx, [ebp+var_10]
.text$mn:00002948                 mov     edx, [ebp+arg_0]
.text$mn:0000294B                 mov     eax, [edx+8]
.text$mn:0000294E                 mov     [ecx+8], eax
.text$mn:00002951                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002958                 mov     eax, [ebp+var_10]
.text$mn:0000295B                 mov     ecx, [ebp+var_C]
.text$mn:0000295E                 mov     large fs:0, ecx
.text$mn:00002965                 pop     ecx
.text$mn:00002966                 mov     esp, ebp
.text$mn:00002968                 pop     ebp
.text$mn:00002969                 retn    4
.text$mn:00002969 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00002969
.text$mn:00002969 _text$mn        ends
.text$mn:00002969
.text$x:0000296C ; ===========================================================================
.text$x:0000296C
.text$x:0000296C ; Segment type: Pure code
.text$x:0000296C ; Segment permissions: Read/Execute
.text$x:0000296C _text$x         segment para public 'CODE' use32
.text$x:0000296C                 assume cs:_text$x
.text$x:0000296C                 ;org 296Ch
.text$x:0000296C ; COMDAT (pick associative to section at 290C)
.text$x:0000296C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000296C
.text$x:0000296C ; =============== S U B R O U T I N E =======================================
.text$x:0000296C
.text$x:0000296C
.text$x:0000296C __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$x:0000296C                                         ; DATA XREF: .xdata$x:0000575Co
.text$x:0000296C                 mov     ecx, [ebp-10h]
.text$x:0000296F                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)
.text$x:0000296F __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$x:0000296F
.text$x:00002974
.text$x:00002974 ; =============== S U B R O U T I N E =======================================
.text$x:00002974
.text$x:00002974
.text$x:00002974 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00002974                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>> const &)+5o
.text$x:00002974
.text$x:00002974 arg_4           = dword ptr  8
.text$x:00002974
.text$x:00002974                 mov     edx, [esp+arg_4]
.text$x:00002978                 lea     eax, [edx+0Ch]
.text$x:0000297B                 mov     ecx, [edx-8]
.text$x:0000297E                 xor     ecx, eax
.text$x:00002980                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002985                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z
.text$x:0000298A                 jmp     ___CxxFrameHandler3
.text$x:0000298A __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:0000298A
.text$x:0000298A ; ---------------------------------------------------------------------------
.text$x:0000298F                 align 10h
.text$x:0000298F _text$x         ends
.text$x:0000298F
.text$mn:00002990 ; ===========================================================================
.text$mn:00002990
.text$mn:00002990 ; Segment type: Pure code
.text$mn:00002990 ; Segment permissions: Read/Execute
.text$mn:00002990 _text$mn        segment para public 'CODE' use32
.text$mn:00002990                 assume cs:_text$mn
.text$mn:00002990                 ;org 2990h
.text$mn:00002990 ; COMDAT (pick any)
.text$mn:00002990                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002990
.text$mn:00002990 ; =============== S U B R O U T I N E =======================================
.text$mn:00002990
.text$mn:00002990 ; Attributes: bp-based frame
.text$mn:00002990
.text$mn:00002990 ; int __stdcall std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(int, struct std::_Container_base12 *)
.text$mn:00002990                 public ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z
.text$mn:00002990 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z proc near
.text$mn:00002990                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::begin(void)+3Dp
.text$mn:00002990                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::end(void)+3Dp
.text$mn:00002990
.text$mn:00002990 var_10          = dword ptr -10h
.text$mn:00002990 var_C           = dword ptr -0Ch
.text$mn:00002990 var_4           = dword ptr -4
.text$mn:00002990 arg_0           = dword ptr  8
.text$mn:00002990 arg_4           = dword ptr  0Ch
.text$mn:00002990
.text$mn:00002990                 push    ebp
.text$mn:00002991                 mov     ebp, esp
.text$mn:00002993                 push    0FFFFFFFFh
.text$mn:00002995                 push    offset __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z
.text$mn:0000299A                 mov     eax, large fs:0
.text$mn:000029A0                 push    eax
.text$mn:000029A1                 push    ecx
.text$mn:000029A2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000029A7                 xor     eax, ebp
.text$mn:000029A9                 push    eax
.text$mn:000029AA                 lea     eax, [ebp+var_C]
.text$mn:000029AD                 mov     large fs:0, eax
.text$mn:000029B3                 mov     [ebp+var_10], ecx
.text$mn:000029B6                 mov     ecx, [ebp+var_10]
.text$mn:000029B9                 call    ??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)
.text$mn:000029BE                 mov     [ebp+var_4], 0
.text$mn:000029C5                 mov     eax, [ebp+var_10]
.text$mn:000029C8                 mov     ecx, [ebp+arg_0]
.text$mn:000029CB                 mov     [eax+8], ecx
.text$mn:000029CE                 mov     edx, [ebp+arg_4]
.text$mn:000029D1                 push    edx             ; struct std::_Container_base12 *
.text$mn:000029D2                 mov     ecx, [ebp+var_10] ; this
.text$mn:000029D5                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:000029DA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000029E1                 mov     eax, [ebp+var_10]
.text$mn:000029E4                 mov     ecx, [ebp+var_C]
.text$mn:000029E7                 mov     large fs:0, ecx
.text$mn:000029EE                 pop     ecx
.text$mn:000029EF                 mov     esp, ebp
.text$mn:000029F1                 pop     ebp
.text$mn:000029F2                 retn    8
.text$mn:000029F2 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z endp
.text$mn:000029F2
.text$mn:000029F2 ; ---------------------------------------------------------------------------
.text$mn:000029F5                 align 4
.text$mn:000029F5 _text$mn        ends
.text$mn:000029F5
.text$x:000029F8 ; ===========================================================================
.text$x:000029F8
.text$x:000029F8 ; Segment type: Pure code
.text$x:000029F8 ; Segment permissions: Read/Execute
.text$x:000029F8 _text$x         segment para public 'CODE' use32
.text$x:000029F8                 assume cs:_text$x
.text$x:000029F8                 ;org 29F8h
.text$x:000029F8 ; COMDAT (pick associative to section at 2990)
.text$x:000029F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000029F8
.text$x:000029F8 ; =============== S U B R O U T I N E =======================================
.text$x:000029F8
.text$x:000029F8
.text$x:000029F8 __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z$0 proc near
.text$x:000029F8                                         ; DATA XREF: .xdata$x:00005704o
.text$x:000029F8                 mov     ecx, [ebp-10h]
.text$x:000029FB                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)
.text$x:000029FB __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z$0 endp
.text$x:000029FB
.text$x:00002A00
.text$x:00002A00 ; =============== S U B R O U T I N E =======================================
.text$x:00002A00
.text$x:00002A00
.text$x:00002A00 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z proc near
.text$x:00002A00                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(DockingCont * *,std::_Container_base12 const *)+5o
.text$x:00002A00
.text$x:00002A00 arg_4           = dword ptr  8
.text$x:00002A00
.text$x:00002A00                 mov     edx, [esp+arg_4]
.text$x:00002A04                 lea     eax, [edx+0Ch]
.text$x:00002A07                 mov     ecx, [edx-8]
.text$x:00002A0A                 xor     ecx, eax
.text$x:00002A0C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002A11                 mov     eax, offset __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z
.text$x:00002A16                 jmp     ___CxxFrameHandler3
.text$x:00002A16 __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z endp
.text$x:00002A16
.text$x:00002A16 ; ---------------------------------------------------------------------------
.text$x:00002A1B                 align 4
.text$x:00002A1B _text$x         ends
.text$x:00002A1B
.text$mn:00002A1C ; ===========================================================================
.text$mn:00002A1C
.text$mn:00002A1C ; Segment type: Pure code
.text$mn:00002A1C ; Segment permissions: Read/Execute
.text$mn:00002A1C _text$mn        segment para public 'CODE' use32
.text$mn:00002A1C                 assume cs:_text$mn
.text$mn:00002A1C                 ;org 2A1Ch
.text$mn:00002A1C ; COMDAT (pick any)
.text$mn:00002A1C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002A1C
.text$mn:00002A1C ; =============== S U B R O U T I N E =======================================
.text$mn:00002A1C
.text$mn:00002A1C ; Attributes: bp-based frame
.text$mn:00002A1C
.text$mn:00002A1C ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class DockingCont *>>::_Vector_val<struct std::_Simple_types<class DockingCont *>>(void)
.text$mn:00002A1C                 public ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00002A1C ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:00002A1C                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)+29p
.text$mn:00002A1C
.text$mn:00002A1C var_10          = dword ptr -10h
.text$mn:00002A1C var_C           = dword ptr -0Ch
.text$mn:00002A1C var_4           = dword ptr -4
.text$mn:00002A1C
.text$mn:00002A1C                 push    ebp
.text$mn:00002A1D                 mov     ebp, esp
.text$mn:00002A1F                 push    0FFFFFFFFh
.text$mn:00002A21                 push    offset __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00002A26                 mov     eax, large fs:0
.text$mn:00002A2C                 push    eax
.text$mn:00002A2D                 push    ecx
.text$mn:00002A2E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002A33                 xor     eax, ebp
.text$mn:00002A35                 push    eax
.text$mn:00002A36                 lea     eax, [ebp+var_C]
.text$mn:00002A39                 mov     large fs:0, eax
.text$mn:00002A3F                 mov     [ebp+var_10], ecx
.text$mn:00002A42                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002A45                 call    ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12(void)
.text$mn:00002A4A                 mov     [ebp+var_4], 0
.text$mn:00002A51                 mov     eax, [ebp+var_10]
.text$mn:00002A54                 mov     dword ptr [eax+4], 0
.text$mn:00002A5B                 mov     ecx, [ebp+var_10]
.text$mn:00002A5E                 mov     dword ptr [ecx+8], 0
.text$mn:00002A65                 mov     edx, [ebp+var_10]
.text$mn:00002A68                 mov     dword ptr [edx+0Ch], 0
.text$mn:00002A6F                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002A76                 mov     eax, [ebp+var_10]
.text$mn:00002A79                 mov     ecx, [ebp+var_C]
.text$mn:00002A7C                 mov     large fs:0, ecx
.text$mn:00002A83                 pop     ecx
.text$mn:00002A84                 mov     esp, ebp
.text$mn:00002A86                 pop     ebp
.text$mn:00002A87                 retn
.text$mn:00002A87 ??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:00002A87
.text$mn:00002A87 _text$mn        ends
.text$mn:00002A87
.text$x:00002A88 ; ===========================================================================
.text$x:00002A88
.text$x:00002A88 ; Segment type: Pure code
.text$x:00002A88 ; Segment permissions: Read/Execute
.text$x:00002A88 _text$x         segment para public 'CODE' use32
.text$x:00002A88                 assume cs:_text$x
.text$x:00002A88                 ;org 2A88h
.text$x:00002A88 ; COMDAT (pick associative to section at 2A1C)
.text$x:00002A88                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002A88
.text$x:00002A88 ; =============== S U B R O U T I N E =======================================
.text$x:00002A88
.text$x:00002A88
.text$x:00002A88 __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00002A88                                         ; DATA XREF: .xdata$x:000054DCo
.text$x:00002A88                 mov     ecx, [ebp-10h]  ; this
.text$x:00002A8B                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00002A8B __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 endp
.text$x:00002A8B
.text$x:00002A90
.text$x:00002A90 ; =============== S U B R O U T I N E =======================================
.text$x:00002A90
.text$x:00002A90
.text$x:00002A90 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$x:00002A90                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<DockingCont *>>::_Vector_val<std::_Simple_types<DockingCont *>>(void)+5o
.text$x:00002A90
.text$x:00002A90 arg_4           = dword ptr  8
.text$x:00002A90
.text$x:00002A90                 mov     edx, [esp+arg_4]
.text$x:00002A94                 lea     eax, [edx+0Ch]
.text$x:00002A97                 mov     ecx, [edx-8]
.text$x:00002A9A                 xor     ecx, eax
.text$x:00002A9C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002AA1                 mov     eax, offset __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$x:00002AA6                 jmp     ___CxxFrameHandler3
.text$x:00002AA6 __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$x:00002AA6
.text$x:00002AA6 ; ---------------------------------------------------------------------------
.text$x:00002AAB                 align 4
.text$x:00002AAB _text$x         ends
.text$x:00002AAB
.text$mn:00002AAC ; ===========================================================================
.text$mn:00002AAC
.text$mn:00002AAC ; Segment type: Pure code
.text$mn:00002AAC ; Segment permissions: Read/Execute
.text$mn:00002AAC _text$mn        segment para public 'CODE' use32
.text$mn:00002AAC                 assume cs:_text$mn
.text$mn:00002AAC                 ;org 2AACh
.text$mn:00002AAC ; COMDAT (pick any)
.text$mn:00002AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AAC
.text$mn:00002AAC ; =============== S U B R O U T I N E =======================================
.text$mn:00002AAC
.text$mn:00002AAC ; Attributes: bp-based frame
.text$mn:00002AAC
.text$mn:00002AAC ; public: __thiscall std::_Wrap_alloc<class std::allocator<char>>::_Wrap_alloc<class std::allocator<char>>(void)
.text$mn:00002AAC                 public ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
.text$mn:00002AAC ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ proc near
.text$mn:00002AAC                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)+Ap
.text$mn:00002AAC
.text$mn:00002AAC var_4           = dword ptr -4
.text$mn:00002AAC
.text$mn:00002AAC                 push    ebp
.text$mn:00002AAD                 mov     ebp, esp
.text$mn:00002AAF                 push    ecx
.text$mn:00002AB0                 mov     [ebp+var_4], ecx
.text$mn:00002AB3                 mov     ecx, [ebp+var_4]
.text$mn:00002AB6                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00002ABB                 mov     eax, [ebp+var_4]
.text$mn:00002ABE                 mov     esp, ebp
.text$mn:00002AC0                 pop     ebp
.text$mn:00002AC1                 retn
.text$mn:00002AC1 ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ endp
.text$mn:00002AC1
.text$mn:00002AC1 ; ---------------------------------------------------------------------------
.text$mn:00002AC2                 align 4
.text$mn:00002AC2 _text$mn        ends
.text$mn:00002AC2
.text$mn:00002AC4 ; ===========================================================================
.text$mn:00002AC4
.text$mn:00002AC4 ; Segment type: Pure code
.text$mn:00002AC4 ; Segment permissions: Read/Execute
.text$mn:00002AC4 _text$mn        segment para public 'CODE' use32
.text$mn:00002AC4                 assume cs:_text$mn
.text$mn:00002AC4                 ;org 2AC4h
.text$mn:00002AC4 ; COMDAT (pick any)
.text$mn:00002AC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AC4
.text$mn:00002AC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AC4
.text$mn:00002AC4 ; Attributes: bp-based frame
.text$mn:00002AC4
.text$mn:00002AC4 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::_Wrap_alloc<class std::allocator<class DockingCont *>>(class std::allocator<class DockingCont *> const &)
.text$mn:00002AC4                 public ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.text$mn:00002AC4 ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z proc near
.text$mn:00002AC4                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::select_on_container_copy_construction(void)+1Dp
.text$mn:00002AC4
.text$mn:00002AC4 var_4           = dword ptr -4
.text$mn:00002AC4 arg_0           = dword ptr  8
.text$mn:00002AC4
.text$mn:00002AC4                 push    ebp
.text$mn:00002AC5                 mov     ebp, esp
.text$mn:00002AC7                 push    ecx
.text$mn:00002AC8                 mov     [ebp+var_4], ecx
.text$mn:00002ACB                 mov     eax, [ebp+arg_0]
.text$mn:00002ACE                 push    eax
.text$mn:00002ACF                 mov     ecx, [ebp+var_4]
.text$mn:00002AD2                 call    ??0?$allocator@PAVDockingCont@@@std@@QAE@ABV01@@Z ; std::allocator<DockingCont *>::allocator<DockingCont *>(std::allocator<DockingCont *> const &)
.text$mn:00002AD7                 mov     eax, [ebp+var_4]
.text$mn:00002ADA                 mov     esp, ebp
.text$mn:00002ADC                 pop     ebp
.text$mn:00002ADD                 retn    4
.text$mn:00002ADD ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z endp
.text$mn:00002ADD
.text$mn:00002ADD _text$mn        ends
.text$mn:00002ADD
.text$mn:00002AE0 ; ===========================================================================
.text$mn:00002AE0
.text$mn:00002AE0 ; Segment type: Pure code
.text$mn:00002AE0 ; Segment permissions: Read/Execute
.text$mn:00002AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00002AE0                 assume cs:_text$mn
.text$mn:00002AE0                 ;org 2AE0h
.text$mn:00002AE0 ; COMDAT (pick any)
.text$mn:00002AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AE0
.text$mn:00002AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AE0
.text$mn:00002AE0 ; Attributes: bp-based frame
.text$mn:00002AE0
.text$mn:00002AE0 ; public: __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::_Wrap_alloc<class std::allocator<class DockingCont *>>(void)
.text$mn:00002AE0                 public ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:00002AE0 ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:00002AE0                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)+Ap
.text$mn:00002AE0
.text$mn:00002AE0 var_4           = dword ptr -4
.text$mn:00002AE0
.text$mn:00002AE0                 push    ebp
.text$mn:00002AE1                 mov     ebp, esp
.text$mn:00002AE3                 push    ecx
.text$mn:00002AE4                 mov     [ebp+var_4], ecx
.text$mn:00002AE7                 mov     ecx, [ebp+var_4]
.text$mn:00002AEA                 call    ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ ; std::allocator<DockingCont *>::allocator<DockingCont *>(void)
.text$mn:00002AEF                 mov     eax, [ebp+var_4]
.text$mn:00002AF2                 mov     esp, ebp
.text$mn:00002AF4                 pop     ebp
.text$mn:00002AF5                 retn
.text$mn:00002AF5 ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:00002AF5
.text$mn:00002AF5 ; ---------------------------------------------------------------------------
.text$mn:00002AF6                 align 4
.text$mn:00002AF6 _text$mn        ends
.text$mn:00002AF6
.text$mn:00002AF8 ; ===========================================================================
.text$mn:00002AF8
.text$mn:00002AF8 ; Segment type: Pure code
.text$mn:00002AF8 ; Segment permissions: Read/Execute
.text$mn:00002AF8 _text$mn        segment para public 'CODE' use32
.text$mn:00002AF8                 assume cs:_text$mn
.text$mn:00002AF8                 ;org 2AF8h
.text$mn:00002AF8 ; COMDAT (pick any)
.text$mn:00002AF8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002AF8
.text$mn:00002AF8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002AF8
.text$mn:00002AF8 ; Attributes: bp-based frame
.text$mn:00002AF8
.text$mn:00002AF8 ; public: __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>(void)
.text$mn:00002AF8                 public ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
.text$mn:00002AF8 ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00002AF8                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Alloc_proxy(void)+Cp
.text$mn:00002AF8                                         ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Free_proxy(void)+Cp
.text$mn:00002AF8
.text$mn:00002AF8 var_4           = dword ptr -4
.text$mn:00002AF8
.text$mn:00002AF8                 push    ebp
.text$mn:00002AF9                 mov     ebp, esp
.text$mn:00002AFB                 push    ecx
.text$mn:00002AFC                 mov     [ebp+var_4], ecx
.text$mn:00002AFF                 mov     ecx, [ebp+var_4]
.text$mn:00002B02                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00002B07                 mov     eax, [ebp+var_4]
.text$mn:00002B0A                 mov     esp, ebp
.text$mn:00002B0C                 pop     ebp
.text$mn:00002B0D                 retn
.text$mn:00002B0D ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ endp
.text$mn:00002B0D
.text$mn:00002B0D ; ---------------------------------------------------------------------------
.text$mn:00002B0E                 align 10h
.text$mn:00002B0E _text$mn        ends
.text$mn:00002B0E
.text$mn:00002B10 ; ===========================================================================
.text$mn:00002B10
.text$mn:00002B10 ; Segment type: Pure code
.text$mn:00002B10 ; Segment permissions: Read/Execute
.text$mn:00002B10 _text$mn        segment para public 'CODE' use32
.text$mn:00002B10                 assume cs:_text$mn
.text$mn:00002B10                 ;org 2B10h
.text$mn:00002B10 ; COMDAT (pick any)
.text$mn:00002B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B10
.text$mn:00002B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B10
.text$mn:00002B10 ; Attributes: bp-based frame
.text$mn:00002B10
.text$mn:00002B10 ; public: __thiscall std::allocator<char>::allocator<char>(void)
.text$mn:00002B10                 public ??0?$allocator@D@std@@QAE@XZ
.text$mn:00002B10 ??0?$allocator@D@std@@QAE@XZ proc near  ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)+Ap
.text$mn:00002B10                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+2Bp
.text$mn:00002B10
.text$mn:00002B10 var_4           = dword ptr -4
.text$mn:00002B10
.text$mn:00002B10                 push    ebp
.text$mn:00002B11                 mov     ebp, esp
.text$mn:00002B13                 push    ecx
.text$mn:00002B14                 mov     [ebp+var_4], ecx
.text$mn:00002B17                 mov     eax, [ebp+var_4]
.text$mn:00002B1A                 mov     esp, ebp
.text$mn:00002B1C                 pop     ebp
.text$mn:00002B1D                 retn
.text$mn:00002B1D ??0?$allocator@D@std@@QAE@XZ endp
.text$mn:00002B1D
.text$mn:00002B1D ; ---------------------------------------------------------------------------
.text$mn:00002B1E                 align 10h
.text$mn:00002B1E _text$mn        ends
.text$mn:00002B1E
.text$mn:00002B20 ; ===========================================================================
.text$mn:00002B20
.text$mn:00002B20 ; Segment type: Pure code
.text$mn:00002B20 ; Segment permissions: Read/Execute
.text$mn:00002B20 _text$mn        segment para public 'CODE' use32
.text$mn:00002B20                 assume cs:_text$mn
.text$mn:00002B20                 ;org 2B20h
.text$mn:00002B20 ; COMDAT (pick any)
.text$mn:00002B20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B20
.text$mn:00002B20 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B20
.text$mn:00002B20 ; Attributes: bp-based frame
.text$mn:00002B20
.text$mn:00002B20 ; public: __thiscall std::allocator<class DockingCont *>::allocator<class DockingCont *>(class std::allocator<class DockingCont *> const &)
.text$mn:00002B20                 public ??0?$allocator@PAVDockingCont@@@std@@QAE@ABV01@@Z
.text$mn:00002B20 ??0?$allocator@PAVDockingCont@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002B20                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::_Wrap_alloc<std::allocator<DockingCont *>>(std::allocator<DockingCont *> const &)+Ep
.text$mn:00002B20                                         ; std::allocator<DockingCont *>::select_on_container_copy_construction(void)+Ep
.text$mn:00002B20
.text$mn:00002B20 var_4           = dword ptr -4
.text$mn:00002B20
.text$mn:00002B20                 push    ebp
.text$mn:00002B21                 mov     ebp, esp
.text$mn:00002B23                 push    ecx
.text$mn:00002B24                 mov     [ebp+var_4], ecx
.text$mn:00002B27                 mov     eax, [ebp+var_4]
.text$mn:00002B2A                 mov     esp, ebp
.text$mn:00002B2C                 pop     ebp
.text$mn:00002B2D                 retn    4
.text$mn:00002B2D ??0?$allocator@PAVDockingCont@@@std@@QAE@ABV01@@Z endp
.text$mn:00002B2D
.text$mn:00002B2D _text$mn        ends
.text$mn:00002B2D
.text$mn:00002B30 ; ===========================================================================
.text$mn:00002B30
.text$mn:00002B30 ; Segment type: Pure code
.text$mn:00002B30 ; Segment permissions: Read/Execute
.text$mn:00002B30 _text$mn        segment para public 'CODE' use32
.text$mn:00002B30                 assume cs:_text$mn
.text$mn:00002B30                 ;org 2B30h
.text$mn:00002B30 ; COMDAT (pick any)
.text$mn:00002B30                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B30
.text$mn:00002B30 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B30
.text$mn:00002B30 ; Attributes: bp-based frame
.text$mn:00002B30
.text$mn:00002B30 ; public: __thiscall std::allocator<class DockingCont *>::allocator<class DockingCont *>(void)
.text$mn:00002B30                 public ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ
.text$mn:00002B30 ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ proc near
.text$mn:00002B30                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::_Wrap_alloc<std::allocator<DockingCont *>>(void)+Ap
.text$mn:00002B30
.text$mn:00002B30 var_4           = dword ptr -4
.text$mn:00002B30
.text$mn:00002B30                 push    ebp
.text$mn:00002B31                 mov     ebp, esp
.text$mn:00002B33                 push    ecx
.text$mn:00002B34                 mov     [ebp+var_4], ecx
.text$mn:00002B37                 mov     eax, [ebp+var_4]
.text$mn:00002B3A                 mov     esp, ebp
.text$mn:00002B3C                 pop     ebp
.text$mn:00002B3D                 retn
.text$mn:00002B3D ??0?$allocator@PAVDockingCont@@@std@@QAE@XZ endp
.text$mn:00002B3D
.text$mn:00002B3D ; ---------------------------------------------------------------------------
.text$mn:00002B3E                 align 10h
.text$mn:00002B3E _text$mn        ends
.text$mn:00002B3E
.text$mn:00002B40 ; ===========================================================================
.text$mn:00002B40
.text$mn:00002B40 ; Segment type: Pure code
.text$mn:00002B40 ; Segment permissions: Read/Execute
.text$mn:00002B40 _text$mn        segment para public 'CODE' use32
.text$mn:00002B40                 assume cs:_text$mn
.text$mn:00002B40                 ;org 2B40h
.text$mn:00002B40 ; COMDAT (pick any)
.text$mn:00002B40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B40
.text$mn:00002B40 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B40
.text$mn:00002B40 ; Attributes: bp-based frame
.text$mn:00002B40
.text$mn:00002B40 ; public: __thiscall std::allocator<struct std::_Container_proxy>::allocator<struct std::_Container_proxy>(void)
.text$mn:00002B40                 public ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ
.text$mn:00002B40 ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ proc near
.text$mn:00002B40                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)+Ap
.text$mn:00002B40                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+Cp ...
.text$mn:00002B40
.text$mn:00002B40 var_4           = dword ptr -4
.text$mn:00002B40
.text$mn:00002B40                 push    ebp
.text$mn:00002B41                 mov     ebp, esp
.text$mn:00002B43                 push    ecx
.text$mn:00002B44                 mov     [ebp+var_4], ecx
.text$mn:00002B47                 mov     eax, [ebp+var_4]
.text$mn:00002B4A                 mov     esp, ebp
.text$mn:00002B4C                 pop     ebp
.text$mn:00002B4D                 retn
.text$mn:00002B4D ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ endp
.text$mn:00002B4D
.text$mn:00002B4D ; ---------------------------------------------------------------------------
.text$mn:00002B4E                 align 10h
.text$mn:00002B4E _text$mn        ends
.text$mn:00002B4E
.text$mn:00002B50 ; ===========================================================================
.text$mn:00002B50
.text$mn:00002B50 ; Segment type: Pure code
.text$mn:00002B50 ; Segment permissions: Read/Execute
.text$mn:00002B50 _text$mn        segment para public 'CODE' use32
.text$mn:00002B50                 assume cs:_text$mn
.text$mn:00002B50                 ;org 2B50h
.text$mn:00002B50 ; COMDAT (pick any)
.text$mn:00002B50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002B50
.text$mn:00002B50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002B50
.text$mn:00002B50 ; Attributes: bp-based frame
.text$mn:00002B50
.text$mn:00002B50 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char *Str)
.text$mn:00002B50                 public ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00002B50 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$mn:00002B50                                         ; CODE XREF: std::_Generic_error_category::message(int)+5Ap
.text$mn:00002B50                                         ; std::_Iostream_error_category::message(int)+3Dp ...
.text$mn:00002B50
.text$mn:00002B50 var_14          = dword ptr -14h
.text$mn:00002B50 var_D           = byte ptr -0Dh
.text$mn:00002B50 var_C           = dword ptr -0Ch
.text$mn:00002B50 var_4           = dword ptr -4
.text$mn:00002B50 Str             = dword ptr  8
.text$mn:00002B50
.text$mn:00002B50                 push    ebp
.text$mn:00002B51                 mov     ebp, esp
.text$mn:00002B53                 push    0FFFFFFFFh
.text$mn:00002B55                 push    offset __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$mn:00002B5A                 mov     eax, large fs:0
.text$mn:00002B60                 push    eax
.text$mn:00002B61                 sub     esp, 8
.text$mn:00002B64                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002B69                 xor     eax, ebp
.text$mn:00002B6B                 push    eax
.text$mn:00002B6C                 lea     eax, [ebp+var_C]
.text$mn:00002B6F                 mov     large fs:0, eax
.text$mn:00002B75                 mov     [ebp+var_14], ecx
.text$mn:00002B78                 lea     ecx, [ebp+var_D]
.text$mn:00002B7B                 call    ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>(void)
.text$mn:00002B80                 push    eax
.text$mn:00002B81                 mov     ecx, [ebp+var_14]
.text$mn:00002B84                 call    ??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)
.text$mn:00002B89                 mov     [ebp+var_4], 0
.text$mn:00002B90                 push    0               ; Size
.text$mn:00002B92                 push    0               ; char
.text$mn:00002B94                 mov     ecx, [ebp+var_14]
.text$mn:00002B97                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00002B9C                 mov     eax, [ebp+Str]
.text$mn:00002B9F                 push    eax             ; Str
.text$mn:00002BA0                 mov     ecx, [ebp+var_14]
.text$mn:00002BA3                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)
.text$mn:00002BA8                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002BAF                 mov     eax, [ebp+var_14]
.text$mn:00002BB2                 mov     ecx, [ebp+var_C]
.text$mn:00002BB5                 mov     large fs:0, ecx
.text$mn:00002BBC                 pop     ecx
.text$mn:00002BBD                 mov     esp, ebp
.text$mn:00002BBF                 pop     ebp
.text$mn:00002BC0                 retn    4
.text$mn:00002BC0 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$mn:00002BC0
.text$mn:00002BC0 ; ---------------------------------------------------------------------------
.text$mn:00002BC3                 align 4
.text$mn:00002BC3 _text$mn        ends
.text$mn:00002BC3
.text$x:00002BC4 ; ===========================================================================
.text$x:00002BC4
.text$x:00002BC4 ; Segment type: Pure code
.text$x:00002BC4 ; Segment permissions: Read/Execute
.text$x:00002BC4 _text$x         segment para public 'CODE' use32
.text$x:00002BC4                 assume cs:_text$x
.text$x:00002BC4                 ;org 2BC4h
.text$x:00002BC4 ; COMDAT (pick associative to section at 2B50)
.text$x:00002BC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002BC4
.text$x:00002BC4 ; =============== S U B R O U T I N E =======================================
.text$x:00002BC4
.text$x:00002BC4
.text$x:00002BC4 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 proc near
.text$x:00002BC4                                         ; DATA XREF: .xdata$x:00005164o
.text$x:00002BC4                 mov     ecx, [ebp-14h]
.text$x:00002BC7                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:00002BC7 __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0 endp
.text$x:00002BC7
.text$x:00002BCC
.text$x:00002BCC ; =============== S U B R O U T I N E =======================================
.text$x:00002BCC
.text$x:00002BCC
.text$x:00002BCC __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z proc near
.text$x:00002BCC                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+5o
.text$x:00002BCC
.text$x:00002BCC arg_4           = dword ptr  8
.text$x:00002BCC
.text$x:00002BCC                 mov     edx, [esp+arg_4]
.text$x:00002BD0                 lea     eax, [edx+0Ch]
.text$x:00002BD3                 mov     ecx, [edx-0Ch]
.text$x:00002BD6                 xor     ecx, eax
.text$x:00002BD8                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002BDD                 mov     eax, offset __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.text$x:00002BE2                 jmp     ___CxxFrameHandler3
.text$x:00002BE2 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z endp
.text$x:00002BE2
.text$x:00002BE2 ; ---------------------------------------------------------------------------
.text$x:00002BE7                 align 4
.text$x:00002BE7 _text$x         ends
.text$x:00002BE7
.text$mn:00002BE8 ; ===========================================================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Segment type: Pure code
.text$mn:00002BE8 ; Segment permissions: Read/Execute
.text$mn:00002BE8 _text$mn        segment para public 'CODE' use32
.text$mn:00002BE8                 assume cs:_text$mn
.text$mn:00002BE8                 ;org 2BE8h
.text$mn:00002BE8 ; COMDAT (pick any)
.text$mn:00002BE8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002BE8
.text$mn:00002BE8 ; =============== S U B R O U T I N E =======================================
.text$mn:00002BE8
.text$mn:00002BE8 ; Attributes: bp-based frame
.text$mn:00002BE8
.text$mn:00002BE8 ; public: __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::vector<class DockingCont *, class std::allocator<class DockingCont *>>(class std::vector<class DockingCont *, class std::allocator<class DockingCont *>> const &)
.text$mn:00002BE8                 public ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002BE8 ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z proc near
.text$mn:00002BE8                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+3Ap
.text$mn:00002BE8                                         ; Gripper::contHitTest(tagPOINT)+3Ap ...
.text$mn:00002BE8
.text$mn:00002BE8 var_34          = dword ptr -34h
.text$mn:00002BE8 var_30          = dword ptr -30h
.text$mn:00002BE8 var_2C          = dword ptr -2Ch
.text$mn:00002BE8 var_28          = dword ptr -28h
.text$mn:00002BE8 var_24          = dword ptr -24h
.text$mn:00002BE8 var_20          = dword ptr -20h
.text$mn:00002BE8 var_1C          = dword ptr -1Ch
.text$mn:00002BE8 var_18          = dword ptr -18h
.text$mn:00002BE8 var_12          = byte ptr -12h
.text$mn:00002BE8 var_11          = byte ptr -11h
.text$mn:00002BE8 var_10          = dword ptr -10h
.text$mn:00002BE8 var_C           = dword ptr -0Ch
.text$mn:00002BE8 var_4           = dword ptr -4
.text$mn:00002BE8 arg_0           = dword ptr  8
.text$mn:00002BE8
.text$mn:00002BE8 ; FUNCTION CHUNK AT .text$mn:00002CD2 SIZE 00000009 BYTES
.text$mn:00002BE8 ; FUNCTION CHUNK AT .text$mn:00002CE2 SIZE 0000001E BYTES
.text$mn:00002BE8
.text$mn:00002BE8                 push    ebp
.text$mn:00002BE9                 mov     ebp, esp
.text$mn:00002BEB                 push    0FFFFFFFFh
.text$mn:00002BED                 push    offset __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002BF2                 mov     eax, large fs:0
.text$mn:00002BF8                 push    eax
.text$mn:00002BF9                 push    ecx
.text$mn:00002BFA                 sub     esp, 24h
.text$mn:00002BFD                 push    ebx
.text$mn:00002BFE                 push    esi
.text$mn:00002BFF                 push    edi
.text$mn:00002C00                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002C05                 xor     eax, ebp
.text$mn:00002C07                 push    eax
.text$mn:00002C08                 lea     eax, [ebp+var_C]
.text$mn:00002C0B                 mov     large fs:0, eax
.text$mn:00002C11                 mov     [ebp+var_10], esp
.text$mn:00002C14                 mov     [ebp+var_18], ecx
.text$mn:00002C17                 lea     eax, [ebp+var_11]
.text$mn:00002C1A                 push    eax
.text$mn:00002C1B                 lea     ecx, [ebp+var_12]
.text$mn:00002C1E                 push    ecx
.text$mn:00002C1F                 mov     ecx, [ebp+arg_0]
.text$mn:00002C22                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00002C27                 mov     ecx, eax
.text$mn:00002C29                 call    ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AU12@XZ ; std::_Wrap_alloc<std::allocator<DockingCont *>>::select_on_container_copy_construction(void)
.text$mn:00002C2E                 push    eax
.text$mn:00002C2F                 mov     ecx, [ebp+var_18]
.text$mn:00002C32                 call    ??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)
.text$mn:00002C37                 mov     [ebp+var_4], 0
.text$mn:00002C3E                 mov     ecx, [ebp+arg_0]
.text$mn:00002C41                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00002C46                 push    eax
.text$mn:00002C47                 mov     ecx, [ebp+var_18]
.text$mn:00002C4A                 call    ?_Buy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAE_NI@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)
.text$mn:00002C4F                 movzx   edx, al
.text$mn:00002C52                 test    edx, edx
.text$mn:00002C54                 jz      loc_2CE2
.text$mn:00002C5A                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002C5E                 mov     eax, [ebp+var_18]
.text$mn:00002C61                 mov     ecx, [eax+4]
.text$mn:00002C64                 push    ecx
.text$mn:00002C65                 sub     esp, 0Ch
.text$mn:00002C68                 mov     edx, esp
.text$mn:00002C6A                 mov     [ebp+var_28], esp
.text$mn:00002C6D                 push    edx
.text$mn:00002C6E                 mov     ecx, [ebp+arg_0]
.text$mn:00002C71                 call    ?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::end(void)
.text$mn:00002C76                 mov     [ebp+var_1C], eax
.text$mn:00002C79                 mov     eax, [ebp+var_1C]
.text$mn:00002C7C                 mov     [ebp+var_2C], eax
.text$mn:00002C7F                 mov     byte ptr [ebp+var_4], 2
.text$mn:00002C83                 sub     esp, 0Ch
.text$mn:00002C86                 mov     ecx, esp
.text$mn:00002C88                 mov     [ebp+var_30], esp
.text$mn:00002C8B                 push    ecx
.text$mn:00002C8C                 mov     ecx, [ebp+arg_0]
.text$mn:00002C8F                 call    ?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::begin(void)
.text$mn:00002C94                 mov     [ebp+var_20], eax
.text$mn:00002C97                 mov     edx, [ebp+var_20]
.text$mn:00002C9A                 mov     [ebp+var_34], edx
.text$mn:00002C9D                 mov     byte ptr [ebp+var_4], 3
.text$mn:00002CA1                 mov     byte ptr [ebp+var_4], 1
.text$mn:00002CA5                 mov     ecx, [ebp+var_18]
.text$mn:00002CA8                 call    ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)
.text$mn:00002CAD                 mov     [ebp+var_24], eax
.text$mn:00002CB0                 mov     eax, [ebp+var_18]
.text$mn:00002CB3                 mov     ecx, [ebp+var_24]
.text$mn:00002CB6                 mov     [eax+8], ecx
.text$mn:00002CB9                 jmp     short loc_2CD2
.text$mn:00002CB9 ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z endp
.text$mn:00002CB9
.text$mn:00002CBB
.text$mn:00002CBB ; =============== S U B R O U T I N E =======================================
.text$mn:00002CBB
.text$mn:00002CBB ; Attributes: noreturn
.text$mn:00002CBB
.text$mn:00002CBB __catch$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$0 proc near
.text$mn:00002CBB                                         ; DATA XREF: .xdata$x:00005594o
.text$mn:00002CBB                 mov     ecx, [ebp-18h]
.text$mn:00002CBE                 call    ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)
.text$mn:00002CC3                 push    0
.text$mn:00002CC5                 push    0
.text$mn:00002CC7                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00002CC7 __catch$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$0 endp
.text$mn:00002CC7
.text$mn:00002CCC ; ---------------------------------------------------------------------------
.text$mn:00002CCC                 mov     eax, offset $LN11
.text$mn:00002CD1                 retn
.text$mn:00002CD2 ; ---------------------------------------------------------------------------
.text$mn:00002CD2 ; START OF FUNCTION CHUNK FOR ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002CD2
.text$mn:00002CD2 loc_2CD2:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+D1j
.text$mn:00002CD2                 mov     [ebp+var_4], 0
.text$mn:00002CD9                 jmp     short loc_2CE2
.text$mn:00002CD9 ; END OF FUNCTION CHUNK FOR ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002CDB
.text$mn:00002CDB ; =============== S U B R O U T I N E =======================================
.text$mn:00002CDB
.text$mn:00002CDB
.text$mn:00002CDB $LN11           proc near               ; DATA XREF: .text$mn:00002CCCo
.text$mn:00002CDB                 mov     dword ptr [ebp-4], 0
.text$mn:00002CDB $LN11           endp ; sp-analysis failed
.text$mn:00002CDB
.text$mn:00002CE2 ; START OF FUNCTION CHUNK FOR ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002CE2
.text$mn:00002CE2 loc_2CE2:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+6Cj
.text$mn:00002CE2                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+F1j
.text$mn:00002CE2                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002CE9                 mov     eax, [ebp+var_18]
.text$mn:00002CEC                 mov     ecx, [ebp+var_C]
.text$mn:00002CEF                 mov     large fs:0, ecx
.text$mn:00002CF6                 pop     ecx
.text$mn:00002CF7                 pop     edi
.text$mn:00002CF8                 pop     esi
.text$mn:00002CF9                 pop     ebx
.text$mn:00002CFA                 mov     esp, ebp
.text$mn:00002CFC                 pop     ebp
.text$mn:00002CFD                 retn    4
.text$mn:00002CFD ; END OF FUNCTION CHUNK FOR ??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.text$mn:00002CFD _text$mn        ends
.text$mn:00002CFD
.text$x:00002D00 ; ===========================================================================
.text$x:00002D00
.text$x:00002D00 ; Segment type: Pure code
.text$x:00002D00 ; Segment permissions: Read/Execute
.text$x:00002D00 _text$x         segment para public 'CODE' use32
.text$x:00002D00                 assume cs:_text$x
.text$x:00002D00                 ;org 2D00h
.text$x:00002D00 ; COMDAT (pick associative to section at 2BE8)
.text$x:00002D00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002D00
.text$x:00002D00 ; =============== S U B R O U T I N E =======================================
.text$x:00002D00
.text$x:00002D00
.text$x:00002D00 __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$2 proc near
.text$x:00002D00                                         ; DATA XREF: .xdata$x:000055D4o
.text$x:00002D00                 mov     ecx, [ebp-18h]
.text$x:00002D03                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)
.text$x:00002D03 __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$2 endp
.text$x:00002D03
.text$x:00002D08
.text$x:00002D08 ; =============== S U B R O U T I N E =======================================
.text$x:00002D08
.text$x:00002D08
.text$x:00002D08 __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$3 proc near
.text$x:00002D08                                         ; DATA XREF: .xdata$x:000055E4o
.text$x:00002D08                 mov     ecx, [ebp-28h]
.text$x:00002D0B                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:00002D0B __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$3 endp
.text$x:00002D0B
.text$x:00002D10
.text$x:00002D10 ; =============== S U B R O U T I N E =======================================
.text$x:00002D10
.text$x:00002D10
.text$x:00002D10 __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$4 proc near
.text$x:00002D10                                         ; DATA XREF: .xdata$x:000055ECo
.text$x:00002D10                 mov     ecx, [ebp-30h]
.text$x:00002D13                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:00002D13 __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$4 endp
.text$x:00002D13
.text$x:00002D18
.text$x:00002D18 ; =============== S U B R O U T I N E =======================================
.text$x:00002D18
.text$x:00002D18
.text$x:00002D18 __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z proc near
.text$x:00002D18                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+5o
.text$x:00002D18
.text$x:00002D18 arg_4           = dword ptr  8
.text$x:00002D18
.text$x:00002D18                 mov     edx, [esp+arg_4]
.text$x:00002D1C                 lea     eax, [edx+0Ch]
.text$x:00002D1F                 mov     ecx, [edx-38h]
.text$x:00002D22                 xor     ecx, eax
.text$x:00002D24                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002D29                 mov     eax, offset __ehfuncinfo$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.text$x:00002D2E                 jmp     ___CxxFrameHandler3
.text$x:00002D2E __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z endp
.text$x:00002D2E
.text$x:00002D2E ; ---------------------------------------------------------------------------
.text$x:00002D33                 align 4
.text$x:00002D33 _text$x         ends
.text$x:00002D33
.text$mn:00002D34 ; ===========================================================================
.text$mn:00002D34
.text$mn:00002D34 ; Segment type: Pure code
.text$mn:00002D34 ; Segment permissions: Read/Execute
.text$mn:00002D34 _text$mn        segment para public 'CODE' use32
.text$mn:00002D34                 assume cs:_text$mn
.text$mn:00002D34                 ;org 2D34h
.text$mn:00002D34 ; COMDAT (pick any)
.text$mn:00002D34                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D34
.text$mn:00002D34 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D34
.text$mn:00002D34 ; Attributes: bp-based frame
.text$mn:00002D34
.text$mn:00002D34 ; _DWORD __thiscall std::_Container_base12::_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:00002D34                 public ??0_Container_base12@std@@QAE@XZ
.text$mn:00002D34 ??0_Container_base12@std@@QAE@XZ proc near
.text$mn:00002D34                                         ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_String_val<std::_Simple_types<char>>(void)+29p
.text$mn:00002D34                                         ; std::_Vector_val<std::_Simple_types<DockingCont *>>::_Vector_val<std::_Simple_types<DockingCont *>>(void)+29p
.text$mn:00002D34
.text$mn:00002D34 var_4           = dword ptr -4
.text$mn:00002D34
.text$mn:00002D34                 push    ebp
.text$mn:00002D35                 mov     ebp, esp
.text$mn:00002D37                 push    ecx
.text$mn:00002D38                 mov     [ebp+var_4], ecx
.text$mn:00002D3B                 mov     eax, [ebp+var_4]
.text$mn:00002D3E                 mov     dword ptr [eax], 0
.text$mn:00002D44                 mov     eax, [ebp+var_4]
.text$mn:00002D47                 mov     esp, ebp
.text$mn:00002D49                 pop     ebp
.text$mn:00002D4A                 retn
.text$mn:00002D4A ??0_Container_base12@std@@QAE@XZ endp
.text$mn:00002D4A
.text$mn:00002D4A ; ---------------------------------------------------------------------------
.text$mn:00002D4B                 align 4
.text$mn:00002D4B _text$mn        ends
.text$mn:00002D4B
.text$mn:00002D4C ; ===========================================================================
.text$mn:00002D4C
.text$mn:00002D4C ; Segment type: Pure code
.text$mn:00002D4C ; Segment permissions: Read/Execute
.text$mn:00002D4C _text$mn        segment para public 'CODE' use32
.text$mn:00002D4C                 assume cs:_text$mn
.text$mn:00002D4C                 ;org 2D4Ch
.text$mn:00002D4C ; COMDAT (pick any)
.text$mn:00002D4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D4C
.text$mn:00002D4C ; =============== S U B R O U T I N E =======================================
.text$mn:00002D4C
.text$mn:00002D4C ; Attributes: bp-based frame
.text$mn:00002D4C
.text$mn:00002D4C ; _DWORD __thiscall std::_Container_proxy::_Container_proxy(std::_Container_proxy *__hidden this)
.text$mn:00002D4C                 public ??0_Container_proxy@std@@QAE@XZ
.text$mn:00002D4C ??0_Container_proxy@std@@QAE@XZ proc near
.text$mn:00002D4C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+23p
.text$mn:00002D4C                                         ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Alloc_proxy(void)+23p
.text$mn:00002D4C
.text$mn:00002D4C var_4           = dword ptr -4
.text$mn:00002D4C
.text$mn:00002D4C                 push    ebp
.text$mn:00002D4D                 mov     ebp, esp
.text$mn:00002D4F                 push    ecx
.text$mn:00002D50                 mov     [ebp+var_4], ecx
.text$mn:00002D53                 mov     eax, [ebp+var_4]
.text$mn:00002D56                 mov     dword ptr [eax], 0
.text$mn:00002D5C                 mov     ecx, [ebp+var_4]
.text$mn:00002D5F                 mov     dword ptr [ecx+4], 0
.text$mn:00002D66                 mov     eax, [ebp+var_4]
.text$mn:00002D69                 mov     esp, ebp
.text$mn:00002D6B                 pop     ebp
.text$mn:00002D6C                 retn
.text$mn:00002D6C ??0_Container_proxy@std@@QAE@XZ endp
.text$mn:00002D6C
.text$mn:00002D6C ; ---------------------------------------------------------------------------
.text$mn:00002D6D                 align 10h
.text$mn:00002D6D _text$mn        ends
.text$mn:00002D6D
.text$mn:00002D70 ; ===========================================================================
.text$mn:00002D70
.text$mn:00002D70 ; Segment type: Pure code
.text$mn:00002D70 ; Segment permissions: Read/Execute
.text$mn:00002D70 _text$mn        segment para public 'CODE' use32
.text$mn:00002D70                 assume cs:_text$mn
.text$mn:00002D70                 ;org 2D70h
.text$mn:00002D70 ; COMDAT (pick any)
.text$mn:00002D70                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002D70
.text$mn:00002D70 ; =============== S U B R O U T I N E =======================================
.text$mn:00002D70
.text$mn:00002D70 ; Attributes: bp-based frame
.text$mn:00002D70
.text$mn:00002D70 ; _DWORD __thiscall std::_Generic_error_category::_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:00002D70                 public ??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002D70 ??0_Generic_error_category@std@@QAE@XZ proc near
.text$mn:00002D70                                         ; CODE XREF: std::_Iostream_error_category::_Iostream_error_category(void)+29p
.text$mn:00002D70                                         ; std::_System_error_category::_System_error_category(void)+29p ...
.text$mn:00002D70
.text$mn:00002D70 var_10          = dword ptr -10h
.text$mn:00002D70 var_C           = dword ptr -0Ch
.text$mn:00002D70 var_4           = dword ptr -4
.text$mn:00002D70
.text$mn:00002D70                 push    ebp
.text$mn:00002D71                 mov     ebp, esp
.text$mn:00002D73                 push    0FFFFFFFFh
.text$mn:00002D75                 push    offset __ehhandler$??0_Generic_error_category@std@@QAE@XZ
.text$mn:00002D7A                 mov     eax, large fs:0
.text$mn:00002D80                 push    eax
.text$mn:00002D81                 push    ecx
.text$mn:00002D82                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002D87                 xor     eax, ebp
.text$mn:00002D89                 push    eax
.text$mn:00002D8A                 lea     eax, [ebp+var_C]
.text$mn:00002D8D                 mov     large fs:0, eax
.text$mn:00002D93                 mov     [ebp+var_10], ecx
.text$mn:00002D96                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002D99                 call    ??0error_category@std@@QAE@XZ ; std::error_category::error_category(void)
.text$mn:00002D9E                 mov     [ebp+var_4], 0
.text$mn:00002DA5                 mov     eax, [ebp+var_10]
.text$mn:00002DA8                 mov     dword ptr [eax], offset ??_7_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`vftable'
.text$mn:00002DAE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002DB5                 mov     eax, [ebp+var_10]
.text$mn:00002DB8                 mov     ecx, [ebp+var_C]
.text$mn:00002DBB                 mov     large fs:0, ecx
.text$mn:00002DC2                 pop     ecx
.text$mn:00002DC3                 mov     esp, ebp
.text$mn:00002DC5                 pop     ebp
.text$mn:00002DC6                 retn
.text$mn:00002DC6 ??0_Generic_error_category@std@@QAE@XZ endp
.text$mn:00002DC6
.text$mn:00002DC6 ; ---------------------------------------------------------------------------
.text$mn:00002DC7                 align 4
.text$mn:00002DC7 _text$mn        ends
.text$mn:00002DC7
.text$x:00002DC8 ; ===========================================================================
.text$x:00002DC8
.text$x:00002DC8 ; Segment type: Pure code
.text$x:00002DC8 ; Segment permissions: Read/Execute
.text$x:00002DC8 _text$x         segment para public 'CODE' use32
.text$x:00002DC8                 assume cs:_text$x
.text$x:00002DC8                 ;org 2DC8h
.text$x:00002DC8 ; COMDAT (pick associative to section at 2D70)
.text$x:00002DC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002DC8
.text$x:00002DC8 ; =============== S U B R O U T I N E =======================================
.text$x:00002DC8
.text$x:00002DC8
.text$x:00002DC8 __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 proc near
.text$x:00002DC8                                         ; DATA XREF: .xdata$x:000052CCo
.text$x:00002DC8                 mov     ecx, [ebp-10h]  ; this
.text$x:00002DCB                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00002DCB __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0 endp
.text$x:00002DCB
.text$x:00002DD0
.text$x:00002DD0 ; =============== S U B R O U T I N E =======================================
.text$x:00002DD0
.text$x:00002DD0
.text$x:00002DD0 __ehhandler$??0_Generic_error_category@std@@QAE@XZ proc near
.text$x:00002DD0                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+5o
.text$x:00002DD0
.text$x:00002DD0 arg_4           = dword ptr  8
.text$x:00002DD0
.text$x:00002DD0                 mov     edx, [esp+arg_4]
.text$x:00002DD4                 lea     eax, [edx+0Ch]
.text$x:00002DD7                 mov     ecx, [edx-8]
.text$x:00002DDA                 xor     ecx, eax
.text$x:00002DDC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002DE1                 mov     eax, offset __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ
.text$x:00002DE6                 jmp     ___CxxFrameHandler3
.text$x:00002DE6 __ehhandler$??0_Generic_error_category@std@@QAE@XZ endp
.text$x:00002DE6
.text$x:00002DE6 ; ---------------------------------------------------------------------------
.text$x:00002DEB                 align 4
.text$x:00002DEB _text$x         ends
.text$x:00002DEB
.text$mn:00002DEC ; ===========================================================================
.text$mn:00002DEC
.text$mn:00002DEC ; Segment type: Pure code
.text$mn:00002DEC ; Segment permissions: Read/Execute
.text$mn:00002DEC _text$mn        segment para public 'CODE' use32
.text$mn:00002DEC                 assume cs:_text$mn
.text$mn:00002DEC                 ;org 2DECh
.text$mn:00002DEC ; COMDAT (pick any)
.text$mn:00002DEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002DEC
.text$mn:00002DEC ; =============== S U B R O U T I N E =======================================
.text$mn:00002DEC
.text$mn:00002DEC ; Attributes: bp-based frame
.text$mn:00002DEC
.text$mn:00002DEC ; _DWORD __thiscall std::_Iostream_error_category::_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00002DEC                 public ??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00002DEC ??0_Iostream_error_category@std@@QAE@XZ proc near
.text$mn:00002DEC                                         ; CODE XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00002DEC
.text$mn:00002DEC var_10          = dword ptr -10h
.text$mn:00002DEC var_C           = dword ptr -0Ch
.text$mn:00002DEC var_4           = dword ptr -4
.text$mn:00002DEC
.text$mn:00002DEC                 push    ebp
.text$mn:00002DED                 mov     ebp, esp
.text$mn:00002DEF                 push    0FFFFFFFFh
.text$mn:00002DF1                 push    offset __ehhandler$??0_Iostream_error_category@std@@QAE@XZ
.text$mn:00002DF6                 mov     eax, large fs:0
.text$mn:00002DFC                 push    eax
.text$mn:00002DFD                 push    ecx
.text$mn:00002DFE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002E03                 xor     eax, ebp
.text$mn:00002E05                 push    eax
.text$mn:00002E06                 lea     eax, [ebp+var_C]
.text$mn:00002E09                 mov     large fs:0, eax
.text$mn:00002E0F                 mov     [ebp+var_10], ecx
.text$mn:00002E12                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002E15                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00002E1A                 mov     [ebp+var_4], 0
.text$mn:00002E21                 mov     eax, [ebp+var_10]
.text$mn:00002E24                 mov     dword ptr [eax], offset ??_7_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`vftable'
.text$mn:00002E2A                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002E31                 mov     eax, [ebp+var_10]
.text$mn:00002E34                 mov     ecx, [ebp+var_C]
.text$mn:00002E37                 mov     large fs:0, ecx
.text$mn:00002E3E                 pop     ecx
.text$mn:00002E3F                 mov     esp, ebp
.text$mn:00002E41                 pop     ebp
.text$mn:00002E42                 retn
.text$mn:00002E42 ??0_Iostream_error_category@std@@QAE@XZ endp
.text$mn:00002E42
.text$mn:00002E42 ; ---------------------------------------------------------------------------
.text$mn:00002E43                 align 4
.text$mn:00002E43 _text$mn        ends
.text$mn:00002E43
.text$x:00002E44 ; ===========================================================================
.text$x:00002E44
.text$x:00002E44 ; Segment type: Pure code
.text$x:00002E44 ; Segment permissions: Read/Execute
.text$x:00002E44 _text$x         segment para public 'CODE' use32
.text$x:00002E44                 assume cs:_text$x
.text$x:00002E44                 ;org 2E44h
.text$x:00002E44 ; COMDAT (pick associative to section at 2DEC)
.text$x:00002E44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002E44
.text$x:00002E44 ; =============== S U B R O U T I N E =======================================
.text$x:00002E44
.text$x:00002E44
.text$x:00002E44 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 proc near
.text$x:00002E44                                         ; DATA XREF: .xdata$x:00005350o
.text$x:00002E44                 mov     ecx, [ebp-10h]  ; this
.text$x:00002E47                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002E47 __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0 endp
.text$x:00002E47
.text$x:00002E4C
.text$x:00002E4C ; =============== S U B R O U T I N E =======================================
.text$x:00002E4C
.text$x:00002E4C
.text$x:00002E4C __ehhandler$??0_Iostream_error_category@std@@QAE@XZ proc near
.text$x:00002E4C                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+5o
.text$x:00002E4C
.text$x:00002E4C arg_4           = dword ptr  8
.text$x:00002E4C
.text$x:00002E4C                 mov     edx, [esp+arg_4]
.text$x:00002E50                 lea     eax, [edx+0Ch]
.text$x:00002E53                 mov     ecx, [edx-8]
.text$x:00002E56                 xor     ecx, eax
.text$x:00002E58                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002E5D                 mov     eax, offset __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ
.text$x:00002E62                 jmp     ___CxxFrameHandler3
.text$x:00002E62 __ehhandler$??0_Iostream_error_category@std@@QAE@XZ endp
.text$x:00002E62
.text$x:00002E62 ; ---------------------------------------------------------------------------
.text$x:00002E67                 align 4
.text$x:00002E67 _text$x         ends
.text$x:00002E67
.text$mn:00002E68 ; ===========================================================================
.text$mn:00002E68
.text$mn:00002E68 ; Segment type: Pure code
.text$mn:00002E68 ; Segment permissions: Read/Execute
.text$mn:00002E68 _text$mn        segment para public 'CODE' use32
.text$mn:00002E68                 assume cs:_text$mn
.text$mn:00002E68                 ;org 2E68h
.text$mn:00002E68 ; COMDAT (pick any)
.text$mn:00002E68                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E68
.text$mn:00002E68 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E68
.text$mn:00002E68 ; Attributes: bp-based frame
.text$mn:00002E68
.text$mn:00002E68 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *this, const struct std::_Iterator_base12 *)
.text$mn:00002E68                 public ??0_Iterator_base12@std@@QAE@ABU01@@Z
.text$mn:00002E68 ??0_Iterator_base12@std@@QAE@ABU01@@Z proc near
.text$mn:00002E68                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12> const &)+2Dp
.text$mn:00002E68
.text$mn:00002E68 var_4           = dword ptr -4
.text$mn:00002E68 arg_0           = dword ptr  8
.text$mn:00002E68
.text$mn:00002E68                 push    ebp
.text$mn:00002E69                 mov     ebp, esp
.text$mn:00002E6B                 push    ecx
.text$mn:00002E6C                 mov     [ebp+var_4], ecx
.text$mn:00002E6F                 mov     eax, [ebp+var_4]
.text$mn:00002E72                 mov     dword ptr [eax], 0
.text$mn:00002E78                 mov     ecx, [ebp+var_4]
.text$mn:00002E7B                 mov     dword ptr [ecx+4], 0
.text$mn:00002E82                 mov     edx, [ebp+arg_0]
.text$mn:00002E85                 push    edx
.text$mn:00002E86                 mov     ecx, [ebp+var_4]
.text$mn:00002E89                 call    ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)
.text$mn:00002E8E                 mov     eax, [ebp+var_4]
.text$mn:00002E91                 mov     esp, ebp
.text$mn:00002E93                 pop     ebp
.text$mn:00002E94                 retn    4
.text$mn:00002E94 ??0_Iterator_base12@std@@QAE@ABU01@@Z endp
.text$mn:00002E94
.text$mn:00002E94 ; ---------------------------------------------------------------------------
.text$mn:00002E97                 align 4
.text$mn:00002E97 _text$mn        ends
.text$mn:00002E97
.text$mn:00002E98 ; ===========================================================================
.text$mn:00002E98
.text$mn:00002E98 ; Segment type: Pure code
.text$mn:00002E98 ; Segment permissions: Read/Execute
.text$mn:00002E98 _text$mn        segment para public 'CODE' use32
.text$mn:00002E98                 assume cs:_text$mn
.text$mn:00002E98                 ;org 2E98h
.text$mn:00002E98 ; COMDAT (pick any)
.text$mn:00002E98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002E98
.text$mn:00002E98 ; =============== S U B R O U T I N E =======================================
.text$mn:00002E98
.text$mn:00002E98 ; Attributes: bp-based frame
.text$mn:00002E98
.text$mn:00002E98 ; _DWORD __thiscall std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00002E98                 public ??0_Iterator_base12@std@@QAE@XZ
.text$mn:00002E98 ??0_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00002E98                                         ; CODE XREF: std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)+29p
.text$mn:00002E98
.text$mn:00002E98 var_4           = dword ptr -4
.text$mn:00002E98
.text$mn:00002E98                 push    ebp
.text$mn:00002E99                 mov     ebp, esp
.text$mn:00002E9B                 push    ecx
.text$mn:00002E9C                 mov     [ebp+var_4], ecx
.text$mn:00002E9F                 mov     eax, [ebp+var_4]
.text$mn:00002EA2                 mov     dword ptr [eax], 0
.text$mn:00002EA8                 mov     ecx, [ebp+var_4]
.text$mn:00002EAB                 mov     dword ptr [ecx+4], 0
.text$mn:00002EB2                 mov     eax, [ebp+var_4]
.text$mn:00002EB5                 mov     esp, ebp
.text$mn:00002EB7                 pop     ebp
.text$mn:00002EB8                 retn
.text$mn:00002EB8 ??0_Iterator_base12@std@@QAE@XZ endp
.text$mn:00002EB8
.text$mn:00002EB8 ; ---------------------------------------------------------------------------
.text$mn:00002EB9                 align 4
.text$mn:00002EB9 _text$mn        ends
.text$mn:00002EB9
.text$mn:00002EBC ; ===========================================================================
.text$mn:00002EBC
.text$mn:00002EBC ; Segment type: Pure code
.text$mn:00002EBC ; Segment permissions: Read/Execute
.text$mn:00002EBC _text$mn        segment para public 'CODE' use32
.text$mn:00002EBC                 assume cs:_text$mn
.text$mn:00002EBC                 ;org 2EBCh
.text$mn:00002EBC ; COMDAT (pick any)
.text$mn:00002EBC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002EBC
.text$mn:00002EBC ; =============== S U B R O U T I N E =======================================
.text$mn:00002EBC
.text$mn:00002EBC ; Attributes: bp-based frame
.text$mn:00002EBC
.text$mn:00002EBC ; _DWORD __thiscall std::_System_error_category::_System_error_category(std::_System_error_category *__hidden this)
.text$mn:00002EBC                 public ??0_System_error_category@std@@QAE@XZ
.text$mn:00002EBC ??0_System_error_category@std@@QAE@XZ proc near
.text$mn:00002EBC                                         ; CODE XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:00002EBC
.text$mn:00002EBC var_10          = dword ptr -10h
.text$mn:00002EBC var_C           = dword ptr -0Ch
.text$mn:00002EBC var_4           = dword ptr -4
.text$mn:00002EBC
.text$mn:00002EBC                 push    ebp
.text$mn:00002EBD                 mov     ebp, esp
.text$mn:00002EBF                 push    0FFFFFFFFh
.text$mn:00002EC1                 push    offset __ehhandler$??0_System_error_category@std@@QAE@XZ
.text$mn:00002EC6                 mov     eax, large fs:0
.text$mn:00002ECC                 push    eax
.text$mn:00002ECD                 push    ecx
.text$mn:00002ECE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002ED3                 xor     eax, ebp
.text$mn:00002ED5                 push    eax
.text$mn:00002ED6                 lea     eax, [ebp+var_C]
.text$mn:00002ED9                 mov     large fs:0, eax
.text$mn:00002EDF                 mov     [ebp+var_10], ecx
.text$mn:00002EE2                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002EE5                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$mn:00002EEA                 mov     [ebp+var_4], 0
.text$mn:00002EF1                 mov     eax, [ebp+var_10]
.text$mn:00002EF4                 mov     dword ptr [eax], offset ??_7_System_error_category@std@@6B@ ; const std::_System_error_category::`vftable'
.text$mn:00002EFA                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002F01                 mov     eax, [ebp+var_10]
.text$mn:00002F04                 mov     ecx, [ebp+var_C]
.text$mn:00002F07                 mov     large fs:0, ecx
.text$mn:00002F0E                 pop     ecx
.text$mn:00002F0F                 mov     esp, ebp
.text$mn:00002F11                 pop     ebp
.text$mn:00002F12                 retn
.text$mn:00002F12 ??0_System_error_category@std@@QAE@XZ endp
.text$mn:00002F12
.text$mn:00002F12 ; ---------------------------------------------------------------------------
.text$mn:00002F13                 align 4
.text$mn:00002F13 _text$mn        ends
.text$mn:00002F13
.text$x:00002F14 ; ===========================================================================
.text$x:00002F14
.text$x:00002F14 ; Segment type: Pure code
.text$x:00002F14 ; Segment permissions: Read/Execute
.text$x:00002F14 _text$x         segment para public 'CODE' use32
.text$x:00002F14                 assume cs:_text$x
.text$x:00002F14                 ;org 2F14h
.text$x:00002F14 ; COMDAT (pick associative to section at 2EBC)
.text$x:00002F14                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002F14
.text$x:00002F14 ; =============== S U B R O U T I N E =======================================
.text$x:00002F14
.text$x:00002F14
.text$x:00002F14 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 proc near
.text$x:00002F14                                         ; DATA XREF: .xdata$x:000053D4o
.text$x:00002F14                 mov     ecx, [ebp-10h]  ; this
.text$x:00002F17                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00002F17 __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0 endp
.text$x:00002F17
.text$x:00002F1C
.text$x:00002F1C ; =============== S U B R O U T I N E =======================================
.text$x:00002F1C
.text$x:00002F1C
.text$x:00002F1C __ehhandler$??0_System_error_category@std@@QAE@XZ proc near
.text$x:00002F1C                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+5o
.text$x:00002F1C
.text$x:00002F1C arg_4           = dword ptr  8
.text$x:00002F1C
.text$x:00002F1C                 mov     edx, [esp+arg_4]
.text$x:00002F20                 lea     eax, [edx+0Ch]
.text$x:00002F23                 mov     ecx, [edx-8]
.text$x:00002F26                 xor     ecx, eax
.text$x:00002F28                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00002F2D                 mov     eax, offset __ehfuncinfo$??0_System_error_category@std@@QAE@XZ
.text$x:00002F32                 jmp     ___CxxFrameHandler3
.text$x:00002F32 __ehhandler$??0_System_error_category@std@@QAE@XZ endp
.text$x:00002F32
.text$x:00002F32 ; ---------------------------------------------------------------------------
.text$x:00002F37                 align 4
.text$x:00002F37 _text$x         ends
.text$x:00002F37
.text$mn:00002F38 ; ===========================================================================
.text$mn:00002F38
.text$mn:00002F38 ; Segment type: Pure code
.text$mn:00002F38 ; Segment permissions: Read/Execute
.text$mn:00002F38 _text$mn        segment para public 'CODE' use32
.text$mn:00002F38                 assume cs:_text$mn
.text$mn:00002F38                 ;org 2F38h
.text$mn:00002F38 ; COMDAT (pick any)
.text$mn:00002F38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F38
.text$mn:00002F38 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F38
.text$mn:00002F38 ; Attributes: bp-based frame
.text$mn:00002F38
.text$mn:00002F38 ; _DWORD __thiscall std::error_category::error_category(std::error_category *__hidden this)
.text$mn:00002F38                 public ??0error_category@std@@QAE@XZ
.text$mn:00002F38 ??0error_category@std@@QAE@XZ proc near ; CODE XREF: std::_Generic_error_category::_Generic_error_category(void)+29p
.text$mn:00002F38
.text$mn:00002F38 var_4           = dword ptr -4
.text$mn:00002F38
.text$mn:00002F38                 push    ebp
.text$mn:00002F39                 mov     ebp, esp
.text$mn:00002F3B                 push    ecx
.text$mn:00002F3C                 mov     [ebp+var_4], ecx
.text$mn:00002F3F                 mov     eax, [ebp+var_4]
.text$mn:00002F42                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:00002F48                 mov     eax, [ebp+var_4]
.text$mn:00002F4B                 mov     esp, ebp
.text$mn:00002F4D                 pop     ebp
.text$mn:00002F4E                 retn
.text$mn:00002F4E ??0error_category@std@@QAE@XZ endp
.text$mn:00002F4E
.text$mn:00002F4E ; ---------------------------------------------------------------------------
.text$mn:00002F4F                 align 10h
.text$mn:00002F4F _text$mn        ends
.text$mn:00002F4F
.text$mn:00002F50 ; ===========================================================================
.text$mn:00002F50
.text$mn:00002F50 ; Segment type: Pure code
.text$mn:00002F50 ; Segment permissions: Read/Execute
.text$mn:00002F50 _text$mn        segment para public 'CODE' use32
.text$mn:00002F50                 assume cs:_text$mn
.text$mn:00002F50                 ;org 2F50h
.text$mn:00002F50 ; COMDAT (pick any)
.text$mn:00002F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F50
.text$mn:00002F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F50
.text$mn:00002F50 ; Attributes: bp-based frame
.text$mn:00002F50
.text$mn:00002F50 ; _DWORD __thiscall std::error_condition::error_condition(std::error_condition *this, int, const struct std::error_category *)
.text$mn:00002F50                 public ??0error_condition@std@@QAE@HABVerror_category@1@@Z
.text$mn:00002F50 ??0error_condition@std@@QAE@HABVerror_category@1@@Z proc near
.text$mn:00002F50                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+24p
.text$mn:00002F50                                         ; std::_System_error_category::default_error_condition(int)+3Dp ...
.text$mn:00002F50
.text$mn:00002F50 var_4           = dword ptr -4
.text$mn:00002F50 arg_0           = dword ptr  8
.text$mn:00002F50 arg_4           = dword ptr  0Ch
.text$mn:00002F50
.text$mn:00002F50                 push    ebp
.text$mn:00002F51                 mov     ebp, esp
.text$mn:00002F53                 push    ecx
.text$mn:00002F54                 mov     [ebp+var_4], ecx
.text$mn:00002F57                 mov     eax, [ebp+var_4]
.text$mn:00002F5A                 mov     ecx, [ebp+arg_0]
.text$mn:00002F5D                 mov     [eax], ecx
.text$mn:00002F5F                 mov     edx, [ebp+var_4]
.text$mn:00002F62                 mov     eax, [ebp+arg_4]
.text$mn:00002F65                 mov     [edx+4], eax
.text$mn:00002F68                 mov     eax, [ebp+var_4]
.text$mn:00002F6B                 mov     esp, ebp
.text$mn:00002F6D                 pop     ebp
.text$mn:00002F6E                 retn    8
.text$mn:00002F6E ??0error_condition@std@@QAE@HABVerror_category@1@@Z endp
.text$mn:00002F6E
.text$mn:00002F6E ; ---------------------------------------------------------------------------
.text$mn:00002F71                 align 4
.text$mn:00002F71 _text$mn        ends
.text$mn:00002F71
.text$mn:00002F74 ; ===========================================================================
.text$mn:00002F74
.text$mn:00002F74 ; Segment type: Pure code
.text$mn:00002F74 ; Segment permissions: Read/Execute
.text$mn:00002F74 _text$mn        segment para public 'CODE' use32
.text$mn:00002F74                 assume cs:_text$mn
.text$mn:00002F74                 ;org 2F74h
.text$mn:00002F74 ; COMDAT (pick any)
.text$mn:00002F74                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F74
.text$mn:00002F74 ; =============== S U B R O U T I N E =======================================
.text$mn:00002F74
.text$mn:00002F74 ; Attributes: bp-based frame
.text$mn:00002F74
.text$mn:00002F74 ; _DWORD __thiscall std::locale::id::id(std::locale::id *this, unsigned int)
.text$mn:00002F74                 public ??0id@locale@std@@QAE@I@Z
.text$mn:00002F74 ??0id@locale@std@@QAE@I@Z proc near     ; CODE XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+Ap
.text$mn:00002F74                                         ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+Ap ...
.text$mn:00002F74
.text$mn:00002F74 var_4           = dword ptr -4
.text$mn:00002F74 arg_0           = dword ptr  8
.text$mn:00002F74
.text$mn:00002F74                 push    ebp
.text$mn:00002F75                 mov     ebp, esp
.text$mn:00002F77                 push    ecx
.text$mn:00002F78                 mov     [ebp+var_4], ecx
.text$mn:00002F7B                 mov     eax, [ebp+var_4]
.text$mn:00002F7E                 mov     ecx, [ebp+arg_0]
.text$mn:00002F81                 mov     [eax], ecx
.text$mn:00002F83                 mov     eax, [ebp+var_4]
.text$mn:00002F86                 mov     esp, ebp
.text$mn:00002F88                 pop     ebp
.text$mn:00002F89                 retn    4
.text$mn:00002F89 ??0id@locale@std@@QAE@I@Z endp
.text$mn:00002F89
.text$mn:00002F89 _text$mn        ends
.text$mn:00002F89
.text$mn:00002F8C ; ===========================================================================
.text$mn:00002F8C
.text$mn:00002F8C ; Segment type: Pure code
.text$mn:00002F8C ; Segment permissions: Read/Execute
.text$mn:00002F8C _text$mn        segment para public 'CODE' use32
.text$mn:00002F8C                 assume cs:_text$mn
.text$mn:00002F8C                 ;org 2F8Ch
.text$mn:00002F8C ; COMDAT (pick any)
.text$mn:00002F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00002F8C
.text$mn:00002F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00002F8C
.text$mn:00002F8C ; Attributes: bp-based frame
.text$mn:00002F8C
.text$mn:00002F8C ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const struct std::runtime_error *)
.text$mn:00002F8C                 public ??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00002F8C ??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$mn:00002F8C                                         ; DATA XREF: .xdata$x:000059B4o
.text$mn:00002F8C
.text$mn:00002F8C var_10          = dword ptr -10h
.text$mn:00002F8C var_C           = dword ptr -0Ch
.text$mn:00002F8C var_4           = dword ptr -4
.text$mn:00002F8C arg_0           = dword ptr  8
.text$mn:00002F8C
.text$mn:00002F8C                 push    ebp
.text$mn:00002F8D                 mov     ebp, esp
.text$mn:00002F8F                 push    0FFFFFFFFh
.text$mn:00002F91                 push    offset __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
.text$mn:00002F96                 mov     eax, large fs:0
.text$mn:00002F9C                 push    eax
.text$mn:00002F9D                 push    ecx
.text$mn:00002F9E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00002FA3                 xor     eax, ebp
.text$mn:00002FA5                 push    eax
.text$mn:00002FA6                 lea     eax, [ebp+var_C]
.text$mn:00002FA9                 mov     large fs:0, eax
.text$mn:00002FAF                 mov     [ebp+var_10], ecx
.text$mn:00002FB2                 mov     eax, [ebp+arg_0]
.text$mn:00002FB5                 push    eax             ; struct std::exception *
.text$mn:00002FB6                 mov     ecx, [ebp+var_10] ; this
.text$mn:00002FB9                 call    ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.text$mn:00002FBE                 mov     [ebp+var_4], 0
.text$mn:00002FC5                 mov     ecx, [ebp+var_10]
.text$mn:00002FC8                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00002FCE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00002FD5                 mov     eax, [ebp+var_10]
.text$mn:00002FD8                 mov     ecx, [ebp+var_C]
.text$mn:00002FDB                 mov     large fs:0, ecx
.text$mn:00002FE2                 pop     ecx
.text$mn:00002FE3                 mov     esp, ebp
.text$mn:00002FE5                 pop     ebp
.text$mn:00002FE6                 retn    4
.text$mn:00002FE6 ??0runtime_error@std@@QAE@ABV01@@Z endp
.text$mn:00002FE6
.text$mn:00002FE6 ; ---------------------------------------------------------------------------
.text$mn:00002FE9                 align 4
.text$mn:00002FE9 _text$mn        ends
.text$mn:00002FE9
.text$x:00002FEC ; ===========================================================================
.text$x:00002FEC
.text$x:00002FEC ; Segment type: Pure code
.text$x:00002FEC ; Segment permissions: Read/Execute
.text$x:00002FEC _text$x         segment para public 'CODE' use32
.text$x:00002FEC                 assume cs:_text$x
.text$x:00002FEC                 ;org 2FECh
.text$x:00002FEC ; COMDAT (pick associative to section at 2F8C)
.text$x:00002FEC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00002FEC
.text$x:00002FEC ; =============== S U B R O U T I N E =======================================
.text$x:00002FEC
.text$x:00002FEC
.text$x:00002FEC __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 proc near
.text$x:00002FEC                                         ; DATA XREF: .xdata$x:000052A0o
.text$x:00002FEC                 mov     ecx, [ebp-10h]  ; this
.text$x:00002FEF                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00002FEF __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0 endp
.text$x:00002FEF
.text$x:00002FF4
.text$x:00002FF4 ; =============== S U B R O U T I N E =======================================
.text$x:00002FF4
.text$x:00002FF4
.text$x:00002FF4 __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z proc near
.text$x:00002FF4                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+5o
.text$x:00002FF4
.text$x:00002FF4 arg_4           = dword ptr  8
.text$x:00002FF4
.text$x:00002FF4                 mov     edx, [esp+arg_4]
.text$x:00002FF8                 lea     eax, [edx+0Ch]
.text$x:00002FFB                 mov     ecx, [edx-8]
.text$x:00002FFE                 xor     ecx, eax
.text$x:00003000                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003005                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
.text$x:0000300A                 jmp     ___CxxFrameHandler3
.text$x:0000300A __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z endp
.text$x:0000300A
.text$x:0000300A ; ---------------------------------------------------------------------------
.text$x:0000300F                 align 10h
.text$x:0000300F _text$x         ends
.text$x:0000300F
.text$mn:00003010 ; ===========================================================================
.text$mn:00003010
.text$mn:00003010 ; Segment type: Pure code
.text$mn:00003010 ; Segment permissions: Read/Execute
.text$mn:00003010 _text$mn        segment para public 'CODE' use32
.text$mn:00003010                 assume cs:_text$mn
.text$mn:00003010                 ;org 3010h
.text$mn:00003010 ; COMDAT (pick any)
.text$mn:00003010                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003010
.text$mn:00003010 ; =============== S U B R O U T I N E =======================================
.text$mn:00003010
.text$mn:00003010 ; Attributes: bp-based frame
.text$mn:00003010
.text$mn:00003010 ; _DWORD __thiscall std::runtime_error::runtime_error(std::runtime_error *this, const char *)
.text$mn:00003010                 public ??0runtime_error@std@@QAE@PBD@Z
.text$mn:00003010 ??0runtime_error@std@@QAE@PBD@Z proc near
.text$mn:00003010                                         ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+A3p
.text$mn:00003010                                         ; Gripper::startGrip(DockingCont *,DockingManager *)+119p
.text$mn:00003010
.text$mn:00003010 var_10          = dword ptr -10h
.text$mn:00003010 var_C           = dword ptr -0Ch
.text$mn:00003010 var_4           = dword ptr -4
.text$mn:00003010 arg_0           = dword ptr  8
.text$mn:00003010
.text$mn:00003010                 push    ebp
.text$mn:00003011                 mov     ebp, esp
.text$mn:00003013                 push    0FFFFFFFFh
.text$mn:00003015                 push    offset __ehhandler$??0runtime_error@std@@QAE@PBD@Z
.text$mn:0000301A                 mov     eax, large fs:0
.text$mn:00003020                 push    eax
.text$mn:00003021                 push    ecx
.text$mn:00003022                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003027                 xor     eax, ebp
.text$mn:00003029                 push    eax
.text$mn:0000302A                 lea     eax, [ebp+var_C]
.text$mn:0000302D                 mov     large fs:0, eax
.text$mn:00003033                 mov     [ebp+var_10], ecx
.text$mn:00003036                 lea     eax, [ebp+arg_0]
.text$mn:00003039                 push    eax             ; char **
.text$mn:0000303A                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000303D                 call    ??0exception@std@@QAE@ABQBD@Z ; std::exception::exception(char const * const &)
.text$mn:00003042                 mov     [ebp+var_4], 0
.text$mn:00003049                 mov     ecx, [ebp+var_10]
.text$mn:0000304C                 mov     dword ptr [ecx], offset ??_7runtime_error@std@@6B@ ; const std::runtime_error::`vftable'
.text$mn:00003052                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003059                 mov     eax, [ebp+var_10]
.text$mn:0000305C                 mov     ecx, [ebp+var_C]
.text$mn:0000305F                 mov     large fs:0, ecx
.text$mn:00003066                 pop     ecx
.text$mn:00003067                 mov     esp, ebp
.text$mn:00003069                 pop     ebp
.text$mn:0000306A                 retn    4
.text$mn:0000306A ??0runtime_error@std@@QAE@PBD@Z endp
.text$mn:0000306A
.text$mn:0000306A ; ---------------------------------------------------------------------------
.text$mn:0000306D                 align 10h
.text$mn:0000306D _text$mn        ends
.text$mn:0000306D
.text$x:00003070 ; ===========================================================================
.text$x:00003070
.text$x:00003070 ; Segment type: Pure code
.text$x:00003070 ; Segment permissions: Read/Execute
.text$x:00003070 _text$x         segment para public 'CODE' use32
.text$x:00003070                 assume cs:_text$x
.text$x:00003070                 ;org 3070h
.text$x:00003070 ; COMDAT (pick associative to section at 3010)
.text$x:00003070                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003070
.text$x:00003070 ; =============== S U B R O U T I N E =======================================
.text$x:00003070
.text$x:00003070
.text$x:00003070 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 proc near
.text$x:00003070                                         ; DATA XREF: .xdata$x:00005248o
.text$x:00003070                 mov     ecx, [ebp-10h]  ; this
.text$x:00003073                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:00003073 __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0 endp
.text$x:00003073
.text$x:00003078
.text$x:00003078 ; =============== S U B R O U T I N E =======================================
.text$x:00003078
.text$x:00003078
.text$x:00003078 __ehhandler$??0runtime_error@std@@QAE@PBD@Z proc near
.text$x:00003078                                         ; DATA XREF: std::runtime_error::runtime_error(char const *)+5o
.text$x:00003078
.text$x:00003078 arg_4           = dword ptr  8
.text$x:00003078
.text$x:00003078                 mov     edx, [esp+arg_4]
.text$x:0000307C                 lea     eax, [edx+0Ch]
.text$x:0000307F                 mov     ecx, [edx-8]
.text$x:00003082                 xor     ecx, eax
.text$x:00003084                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003089                 mov     eax, offset __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z
.text$x:0000308E                 jmp     ___CxxFrameHandler3
.text$x:0000308E __ehhandler$??0runtime_error@std@@QAE@PBD@Z endp
.text$x:0000308E
.text$x:0000308E ; ---------------------------------------------------------------------------
.text$x:00003093                 align 4
.text$x:00003093 _text$x         ends
.text$x:00003093
.text$mn:00003094 ; ===========================================================================
.text$mn:00003094
.text$mn:00003094 ; Segment type: Pure code
.text$mn:00003094 ; Segment permissions: Read/Execute
.text$mn:00003094 _text$mn        segment para public 'CODE' use32
.text$mn:00003094                 assume cs:_text$mn
.text$mn:00003094                 ;org 3094h
.text$mn:00003094 ; COMDAT (pick any)
.text$mn:00003094                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003094
.text$mn:00003094 ; =============== S U B R O U T I N E =======================================
.text$mn:00003094
.text$mn:00003094 ; Attributes: bp-based frame
.text$mn:00003094
.text$mn:00003094 ; public: __thiscall std::_Iterator012<struct std::random_access_iterator_tag, class DockingCont *, int, class DockingCont * const *, class DockingCont * const &, struct std::_Iterator_base12>::~_Iterator012<struct std::random_access_iterator_tag, class DockingCont *, int, class DockingCont * const *, class DockingCont * const &, struct std::_Iterator_base12>(void)
.text$mn:00003094                 public ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:00003094 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$mn:00003094                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z$0+3j
.text$mn:00003094                                         ; __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z$0+3j ...
.text$mn:00003094
.text$mn:00003094 var_10          = dword ptr -10h
.text$mn:00003094 var_C           = dword ptr -0Ch
.text$mn:00003094 var_4           = dword ptr -4
.text$mn:00003094
.text$mn:00003094                 push    ebp
.text$mn:00003095                 mov     ebp, esp
.text$mn:00003097                 push    0FFFFFFFFh
.text$mn:00003099                 push    offset __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$mn:0000309E                 mov     eax, large fs:0
.text$mn:000030A4                 push    eax
.text$mn:000030A5                 push    ecx
.text$mn:000030A6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000030AB                 xor     eax, ebp
.text$mn:000030AD                 push    eax
.text$mn:000030AE                 lea     eax, [ebp+var_C]
.text$mn:000030B1                 mov     large fs:0, eax
.text$mn:000030B7                 mov     [ebp+var_10], ecx
.text$mn:000030BA                 mov     [ebp+var_4], 0
.text$mn:000030C1                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000030C8                 mov     ecx, [ebp+var_10] ; this
.text$mn:000030CB                 call    ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$mn:000030D0                 mov     ecx, [ebp+var_C]
.text$mn:000030D3                 mov     large fs:0, ecx
.text$mn:000030DA                 pop     ecx
.text$mn:000030DB                 mov     esp, ebp
.text$mn:000030DD                 pop     ebp
.text$mn:000030DE                 retn
.text$mn:000030DE ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$mn:000030DE
.text$mn:000030DE ; ---------------------------------------------------------------------------
.text$mn:000030DF                 align 10h
.text$mn:000030DF _text$mn        ends
.text$mn:000030DF
.text$x:000030E0 ; ===========================================================================
.text$x:000030E0
.text$x:000030E0 ; Segment type: Pure code
.text$x:000030E0 ; Segment permissions: Read/Execute
.text$x:000030E0 _text$x         segment para public 'CODE' use32
.text$x:000030E0                 assume cs:_text$x
.text$x:000030E0                 ;org 30E0h
.text$x:000030E0 ; COMDAT (pick associative to section at 3094)
.text$x:000030E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000030E0
.text$x:000030E0 ; =============== S U B R O U T I N E =======================================
.text$x:000030E0
.text$x:000030E0
.text$x:000030E0 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 proc near
.text$x:000030E0                                         ; DATA XREF: .xdata$x:000056ACo
.text$x:000030E0                 mov     ecx, [ebp-10h]  ; this
.text$x:000030E3                 jmp     ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12(void)
.text$x:000030E3 __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0 endp
.text$x:000030E3
.text$x:000030E8
.text$x:000030E8 ; =============== S U B R O U T I N E =======================================
.text$x:000030E8
.text$x:000030E8
.text$x:000030E8 __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ proc near
.text$x:000030E8                                         ; DATA XREF: std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)+5o
.text$x:000030E8
.text$x:000030E8 arg_4           = dword ptr  8
.text$x:000030E8
.text$x:000030E8                 mov     edx, [esp+arg_4]
.text$x:000030EC                 lea     eax, [edx+0Ch]
.text$x:000030EF                 mov     ecx, [edx-8]
.text$x:000030F2                 xor     ecx, eax
.text$x:000030F4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000030F9                 mov     eax, offset __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.text$x:000030FE                 jmp     ___CxxFrameHandler3
.text$x:000030FE __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ endp
.text$x:000030FE
.text$x:000030FE ; ---------------------------------------------------------------------------
.text$x:00003103                 align 4
.text$x:00003103 _text$x         ends
.text$x:00003103
.text$mn:00003104 ; ===========================================================================
.text$mn:00003104
.text$mn:00003104 ; Segment type: Pure code
.text$mn:00003104 ; Segment permissions: Read/Execute
.text$mn:00003104 _text$mn        segment para public 'CODE' use32
.text$mn:00003104                 assume cs:_text$mn
.text$mn:00003104                 ;org 3104h
.text$mn:00003104 ; COMDAT (pick any)
.text$mn:00003104                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003104
.text$mn:00003104 ; =============== S U B R O U T I N E =======================================
.text$mn:00003104
.text$mn:00003104 ; Attributes: bp-based frame
.text$mn:00003104
.text$mn:00003104 ; public: __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::~_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>(void)
.text$mn:00003104                 public ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:00003104 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003104                                         ; CODE XREF: __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0+3j
.text$mn:00003104                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+43p ...
.text$mn:00003104
.text$mn:00003104 var_10          = dword ptr -10h
.text$mn:00003104 var_C           = dword ptr -0Ch
.text$mn:00003104 var_4           = dword ptr -4
.text$mn:00003104
.text$mn:00003104                 push    ebp
.text$mn:00003105                 mov     ebp, esp
.text$mn:00003107                 push    0FFFFFFFFh
.text$mn:00003109                 push    offset __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$mn:0000310E                 mov     eax, large fs:0
.text$mn:00003114                 push    eax
.text$mn:00003115                 push    ecx
.text$mn:00003116                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000311B                 xor     eax, ebp
.text$mn:0000311D                 push    eax
.text$mn:0000311E                 lea     eax, [ebp+var_C]
.text$mn:00003121                 mov     large fs:0, eax
.text$mn:00003127                 mov     [ebp+var_10], ecx
.text$mn:0000312A                 mov     [ebp+var_4], 0
.text$mn:00003131                 mov     ecx, [ebp+var_10]
.text$mn:00003134                 call    ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003139                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003140                 mov     ecx, [ebp+var_10]
.text$mn:00003143                 call    ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$mn:00003148                 mov     ecx, [ebp+var_C]
.text$mn:0000314B                 mov     large fs:0, ecx
.text$mn:00003152                 pop     ecx
.text$mn:00003153                 mov     esp, ebp
.text$mn:00003155                 pop     ebp
.text$mn:00003156                 retn
.text$mn:00003156 ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$mn:00003156
.text$mn:00003156 ; ---------------------------------------------------------------------------
.text$mn:00003157                 align 4
.text$mn:00003157 _text$mn        ends
.text$mn:00003157
.text$x:00003158 ; ===========================================================================
.text$x:00003158
.text$x:00003158 ; Segment type: Pure code
.text$x:00003158 ; Segment permissions: Read/Execute
.text$x:00003158 _text$x         segment para public 'CODE' use32
.text$x:00003158                 assume cs:_text$x
.text$x:00003158                 ;org 3158h
.text$x:00003158 ; COMDAT (pick associative to section at 3104)
.text$x:00003158                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003158
.text$x:00003158 ; =============== S U B R O U T I N E =======================================
.text$x:00003158
.text$x:00003158
.text$x:00003158 __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003158                                         ; DATA XREF: .xdata$x:00005138o
.text$x:00003158                 mov     ecx, [ebp-10h]
.text$x:0000315B                 jmp     ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)
.text$x:0000315B __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:0000315B
.text$x:00003160
.text$x:00003160 ; =============== S U B R O U T I N E =======================================
.text$x:00003160
.text$x:00003160
.text$x:00003160 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003160                                         ; DATA XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+5o
.text$x:00003160
.text$x:00003160 arg_4           = dword ptr  8
.text$x:00003160
.text$x:00003160                 mov     edx, [esp+arg_4]
.text$x:00003164                 lea     eax, [edx+0Ch]
.text$x:00003167                 mov     ecx, [edx-8]
.text$x:0000316A                 xor     ecx, eax
.text$x:0000316C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003171                 mov     eax, offset __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.text$x:00003176                 jmp     ___CxxFrameHandler3
.text$x:00003176 __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ endp
.text$x:00003176
.text$x:00003176 ; ---------------------------------------------------------------------------
.text$x:0000317B                 align 4
.text$x:0000317B _text$x         ends
.text$x:0000317B
.text$mn:0000317C ; ===========================================================================
.text$mn:0000317C
.text$mn:0000317C ; Segment type: Pure code
.text$mn:0000317C ; Segment permissions: Read/Execute
.text$mn:0000317C _text$mn        segment para public 'CODE' use32
.text$mn:0000317C                 assume cs:_text$mn
.text$mn:0000317C                 ;org 317Ch
.text$mn:0000317C ; COMDAT (pick any)
.text$mn:0000317C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000317C
.text$mn:0000317C ; =============== S U B R O U T I N E =======================================
.text$mn:0000317C
.text$mn:0000317C ; Attributes: bp-based frame
.text$mn:0000317C
.text$mn:0000317C ; public: __thiscall std::_String_val<struct std::_Simple_types<char>>::~_String_val<struct std::_Simple_types<char>>(void)
.text$mn:0000317C                 public ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:0000317C ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$mn:0000317C                                         ; CODE XREF: __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0+3j
.text$mn:0000317C                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+3Fp ...
.text$mn:0000317C
.text$mn:0000317C var_10          = dword ptr -10h
.text$mn:0000317C var_C           = dword ptr -0Ch
.text$mn:0000317C var_4           = dword ptr -4
.text$mn:0000317C
.text$mn:0000317C                 push    ebp
.text$mn:0000317D                 mov     ebp, esp
.text$mn:0000317F                 push    0FFFFFFFFh
.text$mn:00003181                 push    offset __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$mn:00003186                 mov     eax, large fs:0
.text$mn:0000318C                 push    eax
.text$mn:0000318D                 push    ecx
.text$mn:0000318E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003193                 xor     eax, ebp
.text$mn:00003195                 push    eax
.text$mn:00003196                 lea     eax, [ebp+var_C]
.text$mn:00003199                 mov     large fs:0, eax
.text$mn:0000319F                 mov     [ebp+var_10], ecx
.text$mn:000031A2                 mov     [ebp+var_4], 0
.text$mn:000031A9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000031B0                 mov     ecx, [ebp+var_10] ; this
.text$mn:000031B3                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:000031B8                 mov     ecx, [ebp+var_C]
.text$mn:000031BB                 mov     large fs:0, ecx
.text$mn:000031C2                 pop     ecx
.text$mn:000031C3                 mov     esp, ebp
.text$mn:000031C5                 pop     ebp
.text$mn:000031C6                 retn
.text$mn:000031C6 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$mn:000031C6
.text$mn:000031C6 ; ---------------------------------------------------------------------------
.text$mn:000031C7                 align 4
.text$mn:000031C7 _text$mn        ends
.text$mn:000031C7
.text$x:000031C8 ; ===========================================================================
.text$x:000031C8
.text$x:000031C8 ; Segment type: Pure code
.text$x:000031C8 ; Segment permissions: Read/Execute
.text$x:000031C8 _text$x         segment para public 'CODE' use32
.text$x:000031C8                 assume cs:_text$x
.text$x:000031C8                 ;org 31C8h
.text$x:000031C8 ; COMDAT (pick associative to section at 317C)
.text$x:000031C8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000031C8
.text$x:000031C8 ; =============== S U B R O U T I N E =======================================
.text$x:000031C8
.text$x:000031C8
.text$x:000031C8 __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 proc near
.text$x:000031C8                                         ; DATA XREF: .xdata$x:000050E0o
.text$x:000031C8                 mov     ecx, [ebp-10h]  ; this
.text$x:000031CB                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:000031CB __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0 endp
.text$x:000031CB
.text$x:000031D0
.text$x:000031D0 ; =============== S U B R O U T I N E =======================================
.text$x:000031D0
.text$x:000031D0
.text$x:000031D0 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ proc near
.text$x:000031D0                                         ; DATA XREF: std::_String_val<std::_Simple_types<char>>::~_String_val<std::_Simple_types<char>>(void)+5o
.text$x:000031D0
.text$x:000031D0 arg_4           = dword ptr  8
.text$x:000031D0
.text$x:000031D0                 mov     edx, [esp+arg_4]
.text$x:000031D4                 lea     eax, [edx+0Ch]
.text$x:000031D7                 mov     ecx, [edx-8]
.text$x:000031DA                 xor     ecx, eax
.text$x:000031DC                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000031E1                 mov     eax, offset __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.text$x:000031E6                 jmp     ___CxxFrameHandler3
.text$x:000031E6 __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ endp
.text$x:000031E6
.text$x:000031E6 ; ---------------------------------------------------------------------------
.text$x:000031EB                 align 4
.text$x:000031EB _text$x         ends
.text$x:000031EB
.text$mn:000031EC ; ===========================================================================
.text$mn:000031EC
.text$mn:000031EC ; Segment type: Pure code
.text$mn:000031EC ; Segment permissions: Read/Execute
.text$mn:000031EC _text$mn        segment para public 'CODE' use32
.text$mn:000031EC                 assume cs:_text$mn
.text$mn:000031EC                 ;org 31ECh
.text$mn:000031EC ; COMDAT (pick any)
.text$mn:000031EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000031EC
.text$mn:000031EC ; =============== S U B R O U T I N E =======================================
.text$mn:000031EC
.text$mn:000031EC ; Attributes: bp-based frame
.text$mn:000031EC
.text$mn:000031EC ; public: __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::~_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>(void)
.text$mn:000031EC                 public ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$mn:000031EC ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:000031EC                                         ; CODE XREF: __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$2+3j
.text$mn:000031EC                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)+3Fp ...
.text$mn:000031EC
.text$mn:000031EC var_10          = dword ptr -10h
.text$mn:000031EC var_C           = dword ptr -0Ch
.text$mn:000031EC var_4           = dword ptr -4
.text$mn:000031EC
.text$mn:000031EC                 push    ebp
.text$mn:000031ED                 mov     ebp, esp
.text$mn:000031EF                 push    0FFFFFFFFh
.text$mn:000031F1                 push    offset __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$mn:000031F6                 mov     eax, large fs:0
.text$mn:000031FC                 push    eax
.text$mn:000031FD                 push    ecx
.text$mn:000031FE                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003203                 xor     eax, ebp
.text$mn:00003205                 push    eax
.text$mn:00003206                 lea     eax, [ebp+var_C]
.text$mn:00003209                 mov     large fs:0, eax
.text$mn:0000320F                 mov     [ebp+var_10], ecx
.text$mn:00003212                 mov     [ebp+var_4], 0
.text$mn:00003219                 mov     ecx, [ebp+var_10]
.text$mn:0000321C                 call    ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Free_proxy(void)
.text$mn:00003221                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003228                 mov     ecx, [ebp+var_10]
.text$mn:0000322B                 call    ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$mn:00003230                 mov     ecx, [ebp+var_C]
.text$mn:00003233                 mov     large fs:0, ecx
.text$mn:0000323A                 pop     ecx
.text$mn:0000323B                 mov     esp, ebp
.text$mn:0000323D                 pop     ebp
.text$mn:0000323E                 retn
.text$mn:0000323E ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:0000323E
.text$mn:0000323E ; ---------------------------------------------------------------------------
.text$mn:0000323F                 align 10h
.text$mn:0000323F _text$mn        ends
.text$mn:0000323F
.text$x:00003240 ; ===========================================================================
.text$x:00003240
.text$x:00003240 ; Segment type: Pure code
.text$x:00003240 ; Segment permissions: Read/Execute
.text$x:00003240 _text$x         segment para public 'CODE' use32
.text$x:00003240                 assume cs:_text$x
.text$x:00003240                 ;org 3240h
.text$x:00003240 ; COMDAT (pick associative to section at 31EC)
.text$x:00003240                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003240
.text$x:00003240 ; =============== S U B R O U T I N E =======================================
.text$x:00003240
.text$x:00003240
.text$x:00003240 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003240                                         ; DATA XREF: .xdata$x:00005560o
.text$x:00003240                 mov     ecx, [ebp-10h]
.text$x:00003243                 jmp     ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)
.text$x:00003243 __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003243
.text$x:00003248
.text$x:00003248 ; =============== S U B R O U T I N E =======================================
.text$x:00003248
.text$x:00003248
.text$x:00003248 __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:00003248                                         ; DATA XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)+5o
.text$x:00003248
.text$x:00003248 arg_4           = dword ptr  8
.text$x:00003248
.text$x:00003248                 mov     edx, [esp+arg_4]
.text$x:0000324C                 lea     eax, [edx+0Ch]
.text$x:0000324F                 mov     ecx, [edx-8]
.text$x:00003252                 xor     ecx, eax
.text$x:00003254                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003259                 mov     eax, offset __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$x:0000325E                 jmp     ___CxxFrameHandler3
.text$x:0000325E __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ endp
.text$x:0000325E
.text$x:0000325E ; ---------------------------------------------------------------------------
.text$x:00003263                 align 4
.text$x:00003263 _text$x         ends
.text$x:00003263
.text$mn:00003264 ; ===========================================================================
.text$mn:00003264
.text$mn:00003264 ; Segment type: Pure code
.text$mn:00003264 ; Segment permissions: Read/Execute
.text$mn:00003264 _text$mn        segment para public 'CODE' use32
.text$mn:00003264                 assume cs:_text$mn
.text$mn:00003264                 ;org 3264h
.text$mn:00003264 ; COMDAT (pick any)
.text$mn:00003264                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003264
.text$mn:00003264 ; =============== S U B R O U T I N E =======================================
.text$mn:00003264
.text$mn:00003264 ; Attributes: bp-based frame
.text$mn:00003264
.text$mn:00003264 ; public: __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>::~_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>(void)
.text$mn:00003264                 public ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$mn:00003264 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ proc near
.text$mn:00003264                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)+9Bp
.text$mn:00003264                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)+AAp ...
.text$mn:00003264
.text$mn:00003264 var_10          = dword ptr -10h
.text$mn:00003264 var_C           = dword ptr -0Ch
.text$mn:00003264 var_4           = dword ptr -4
.text$mn:00003264
.text$mn:00003264                 push    ebp
.text$mn:00003265                 mov     ebp, esp
.text$mn:00003267                 push    0FFFFFFFFh
.text$mn:00003269                 push    offset __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$mn:0000326E                 mov     eax, large fs:0
.text$mn:00003274                 push    eax
.text$mn:00003275                 push    ecx
.text$mn:00003276                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000327B                 xor     eax, ebp
.text$mn:0000327D                 push    eax
.text$mn:0000327E                 lea     eax, [ebp+var_C]
.text$mn:00003281                 mov     large fs:0, eax
.text$mn:00003287                 mov     [ebp+var_10], ecx
.text$mn:0000328A                 mov     [ebp+var_4], 0
.text$mn:00003291                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003298                 mov     ecx, [ebp+var_10]
.text$mn:0000329B                 call    ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)
.text$mn:000032A0                 mov     ecx, [ebp+var_C]
.text$mn:000032A3                 mov     large fs:0, ecx
.text$mn:000032AA                 pop     ecx
.text$mn:000032AB                 mov     esp, ebp
.text$mn:000032AD                 pop     ebp
.text$mn:000032AE                 retn
.text$mn:000032AE ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ endp
.text$mn:000032AE
.text$mn:000032AE ; ---------------------------------------------------------------------------
.text$mn:000032AF                 align 10h
.text$mn:000032AF _text$mn        ends
.text$mn:000032AF
.text$x:000032B0 ; ===========================================================================
.text$x:000032B0
.text$x:000032B0 ; Segment type: Pure code
.text$x:000032B0 ; Segment permissions: Read/Execute
.text$x:000032B0 _text$x         segment para public 'CODE' use32
.text$x:000032B0                 assume cs:_text$x
.text$x:000032B0                 ;org 32B0h
.text$x:000032B0 ; COMDAT (pick associative to section at 3264)
.text$x:000032B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000032B0
.text$x:000032B0 ; =============== S U B R O U T I N E =======================================
.text$x:000032B0
.text$x:000032B0
.text$x:000032B0 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0 proc near
.text$x:000032B0                                         ; DATA XREF: .xdata$x:00005730o
.text$x:000032B0                 mov     ecx, [ebp-10h]
.text$x:000032B3                 jmp     ??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,DockingCont *,int,DockingCont * const *,DockingCont * const &,std::_Iterator_base12>(void)
.text$x:000032B3 __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0 endp
.text$x:000032B3
.text$x:000032B8
.text$x:000032B8 ; =============== S U B R O U T I N E =======================================
.text$x:000032B8
.text$x:000032B8
.text$x:000032B8 __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ proc near
.text$x:000032B8                                         ; DATA XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)+5o
.text$x:000032B8
.text$x:000032B8 arg_4           = dword ptr  8
.text$x:000032B8
.text$x:000032B8                 mov     edx, [esp+arg_4]
.text$x:000032BC                 lea     eax, [edx+0Ch]
.text$x:000032BF                 mov     ecx, [edx-8]
.text$x:000032C2                 xor     ecx, eax
.text$x:000032C4                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000032C9                 mov     eax, offset __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.text$x:000032CE                 jmp     ___CxxFrameHandler3
.text$x:000032CE __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ endp
.text$x:000032CE
.text$x:000032CE ; ---------------------------------------------------------------------------
.text$x:000032D3                 align 4
.text$x:000032D3 _text$x         ends
.text$x:000032D3
.text$mn:000032D4 ; ===========================================================================
.text$mn:000032D4
.text$mn:000032D4 ; Segment type: Pure code
.text$mn:000032D4 ; Segment permissions: Read/Execute
.text$mn:000032D4 _text$mn        segment para public 'CODE' use32
.text$mn:000032D4                 assume cs:_text$mn
.text$mn:000032D4                 ;org 32D4h
.text$mn:000032D4 ; COMDAT (pick any)
.text$mn:000032D4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000032D4
.text$mn:000032D4 ; =============== S U B R O U T I N E =======================================
.text$mn:000032D4
.text$mn:000032D4 ; Attributes: bp-based frame
.text$mn:000032D4
.text$mn:000032D4 ; public: __thiscall std::_Vector_val<struct std::_Simple_types<class DockingCont *>>::~_Vector_val<struct std::_Simple_types<class DockingCont *>>(void)
.text$mn:000032D4                 public ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:000032D4 ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:000032D4                                         ; CODE XREF: __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0+3j
.text$mn:000032D4                                         ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)+3Fp ...
.text$mn:000032D4
.text$mn:000032D4 var_10          = dword ptr -10h
.text$mn:000032D4 var_C           = dword ptr -0Ch
.text$mn:000032D4 var_4           = dword ptr -4
.text$mn:000032D4
.text$mn:000032D4                 push    ebp
.text$mn:000032D5                 mov     ebp, esp
.text$mn:000032D7                 push    0FFFFFFFFh
.text$mn:000032D9                 push    offset __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:000032DE                 mov     eax, large fs:0
.text$mn:000032E4                 push    eax
.text$mn:000032E5                 push    ecx
.text$mn:000032E6                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000032EB                 xor     eax, ebp
.text$mn:000032ED                 push    eax
.text$mn:000032EE                 lea     eax, [ebp+var_C]
.text$mn:000032F1                 mov     large fs:0, eax
.text$mn:000032F7                 mov     [ebp+var_10], ecx
.text$mn:000032FA                 mov     [ebp+var_4], 0
.text$mn:00003301                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003308                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000330B                 call    ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$mn:00003310                 mov     ecx, [ebp+var_C]
.text$mn:00003313                 mov     large fs:0, ecx
.text$mn:0000331A                 pop     ecx
.text$mn:0000331B                 mov     esp, ebp
.text$mn:0000331D                 pop     ebp
.text$mn:0000331E                 retn
.text$mn:0000331E ??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:0000331E
.text$mn:0000331E ; ---------------------------------------------------------------------------
.text$mn:0000331F                 align 10h
.text$mn:0000331F _text$mn        ends
.text$mn:0000331F
.text$x:00003320 ; ===========================================================================
.text$x:00003320
.text$x:00003320 ; Segment type: Pure code
.text$x:00003320 ; Segment permissions: Read/Execute
.text$x:00003320 _text$x         segment para public 'CODE' use32
.text$x:00003320                 assume cs:_text$x
.text$x:00003320                 ;org 3320h
.text$x:00003320 ; COMDAT (pick associative to section at 32D4)
.text$x:00003320                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003320
.text$x:00003320 ; =============== S U B R O U T I N E =======================================
.text$x:00003320
.text$x:00003320
.text$x:00003320 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003320                                         ; DATA XREF: .xdata$x:00005508o
.text$x:00003320                 mov     ecx, [ebp-10h]  ; this
.text$x:00003323                 jmp     ??1_Container_base12@std@@QAE@XZ ; std::_Container_base12::~_Container_base12(void)
.text$x:00003323 __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003323
.text$x:00003328
.text$x:00003328 ; =============== S U B R O U T I N E =======================================
.text$x:00003328
.text$x:00003328
.text$x:00003328 __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$x:00003328                                         ; DATA XREF: std::_Vector_val<std::_Simple_types<DockingCont *>>::~_Vector_val<std::_Simple_types<DockingCont *>>(void)+5o
.text$x:00003328
.text$x:00003328 arg_4           = dword ptr  8
.text$x:00003328
.text$x:00003328                 mov     edx, [esp+arg_4]
.text$x:0000332C                 lea     eax, [edx+0Ch]
.text$x:0000332F                 mov     ecx, [edx-8]
.text$x:00003332                 xor     ecx, eax
.text$x:00003334                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003339                 mov     eax, offset __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$x:0000333E                 jmp     ___CxxFrameHandler3
.text$x:0000333E __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$x:0000333E
.text$x:0000333E ; ---------------------------------------------------------------------------
.text$x:00003343                 align 4
.text$x:00003343 _text$x         ends
.text$x:00003343
.text$mn:00003344 ; ===========================================================================
.text$mn:00003344
.text$mn:00003344 ; Segment type: Pure code
.text$mn:00003344 ; Segment permissions: Read/Execute
.text$mn:00003344 _text$mn        segment para public 'CODE' use32
.text$mn:00003344                 assume cs:_text$mn
.text$mn:00003344                 ;org 3344h
.text$mn:00003344 ; COMDAT (pick any)
.text$mn:00003344                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003344
.text$mn:00003344 ; =============== S U B R O U T I N E =======================================
.text$mn:00003344
.text$mn:00003344 ; Attributes: bp-based frame
.text$mn:00003344
.text$mn:00003344 ; public: __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::~basic_string<char, struct std::char_traits<char>, class std::allocator<char>>(void)
.text$mn:00003344                 public ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:00003344 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$mn:00003344                                         ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j
.text$mn:00003344                                         ; __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+13j ...
.text$mn:00003344
.text$mn:00003344 var_10          = dword ptr -10h
.text$mn:00003344 var_C           = dword ptr -0Ch
.text$mn:00003344 var_4           = dword ptr -4
.text$mn:00003344
.text$mn:00003344                 push    ebp
.text$mn:00003345                 mov     ebp, esp
.text$mn:00003347                 push    0FFFFFFFFh
.text$mn:00003349                 push    offset __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$mn:0000334E                 mov     eax, large fs:0
.text$mn:00003354                 push    eax
.text$mn:00003355                 push    ecx
.text$mn:00003356                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000335B                 xor     eax, ebp
.text$mn:0000335D                 push    eax
.text$mn:0000335E                 lea     eax, [ebp+var_C]
.text$mn:00003361                 mov     large fs:0, eax
.text$mn:00003367                 mov     [ebp+var_10], ecx
.text$mn:0000336A                 mov     [ebp+var_4], 0
.text$mn:00003371                 push    0               ; Size
.text$mn:00003373                 push    1               ; char
.text$mn:00003375                 mov     ecx, [ebp+var_10]
.text$mn:00003378                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:0000337D                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003384                 mov     ecx, [ebp+var_10]
.text$mn:00003387                 call    ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$mn:0000338C                 mov     ecx, [ebp+var_C]
.text$mn:0000338F                 mov     large fs:0, ecx
.text$mn:00003396                 pop     ecx
.text$mn:00003397                 mov     esp, ebp
.text$mn:00003399                 pop     ebp
.text$mn:0000339A                 retn
.text$mn:0000339A ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$mn:0000339A
.text$mn:0000339A ; ---------------------------------------------------------------------------
.text$mn:0000339B                 align 4
.text$mn:0000339B _text$mn        ends
.text$mn:0000339B
.text$x:0000339C ; ===========================================================================
.text$x:0000339C
.text$x:0000339C ; Segment type: Pure code
.text$x:0000339C ; Segment permissions: Read/Execute
.text$x:0000339C _text$x         segment para public 'CODE' use32
.text$x:0000339C                 assume cs:_text$x
.text$x:0000339C                 ;org 339Ch
.text$x:0000339C ; COMDAT (pick associative to section at 3344)
.text$x:0000339C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:0000339C
.text$x:0000339C ; =============== S U B R O U T I N E =======================================
.text$x:0000339C
.text$x:0000339C
.text$x:0000339C __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 proc near
.text$x:0000339C                                         ; DATA XREF: .xdata$x:00005190o
.text$x:0000339C                 mov     ecx, [ebp-10h]
.text$x:0000339F                 jmp     ??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)
.text$x:0000339F __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0 endp
.text$x:0000339F
.text$x:000033A4
.text$x:000033A4 ; =============== S U B R O U T I N E =======================================
.text$x:000033A4
.text$x:000033A4
.text$x:000033A4 __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ proc near
.text$x:000033A4                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+5o
.text$x:000033A4
.text$x:000033A4 arg_4           = dword ptr  8
.text$x:000033A4
.text$x:000033A4                 mov     edx, [esp+arg_4]
.text$x:000033A8                 lea     eax, [edx+0Ch]
.text$x:000033AB                 mov     ecx, [edx-8]
.text$x:000033AE                 xor     ecx, eax
.text$x:000033B0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000033B5                 mov     eax, offset __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.text$x:000033BA                 jmp     ___CxxFrameHandler3
.text$x:000033BA __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ endp
.text$x:000033BA
.text$x:000033BA ; ---------------------------------------------------------------------------
.text$x:000033BF                 align 10h
.text$x:000033BF _text$x         ends
.text$x:000033BF
.text$mn:000033C0 ; ===========================================================================
.text$mn:000033C0
.text$mn:000033C0 ; Segment type: Pure code
.text$mn:000033C0 ; Segment permissions: Read/Execute
.text$mn:000033C0 _text$mn        segment para public 'CODE' use32
.text$mn:000033C0                 assume cs:_text$mn
.text$mn:000033C0                 ;org 33C0h
.text$mn:000033C0 ; COMDAT (pick any)
.text$mn:000033C0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000033C0
.text$mn:000033C0 ; =============== S U B R O U T I N E =======================================
.text$mn:000033C0
.text$mn:000033C0 ; Attributes: bp-based frame
.text$mn:000033C0
.text$mn:000033C0 ; public: __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::~vector<class DockingCont *, class std::allocator<class DockingCont *>>(void)
.text$mn:000033C0                 public ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:000033C0 ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$mn:000033C0                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+1B5p
.text$mn:000033C0                                         ; Gripper::doTabReordering(tagPOINT)+3CBp ...
.text$mn:000033C0
.text$mn:000033C0 var_10          = dword ptr -10h
.text$mn:000033C0 var_C           = dword ptr -0Ch
.text$mn:000033C0 var_4           = dword ptr -4
.text$mn:000033C0
.text$mn:000033C0                 push    ebp
.text$mn:000033C1                 mov     ebp, esp
.text$mn:000033C3                 push    0FFFFFFFFh
.text$mn:000033C5                 push    offset __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$mn:000033CA                 mov     eax, large fs:0
.text$mn:000033D0                 push    eax
.text$mn:000033D1                 push    ecx
.text$mn:000033D2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000033D7                 xor     eax, ebp
.text$mn:000033D9                 push    eax
.text$mn:000033DA                 lea     eax, [ebp+var_C]
.text$mn:000033DD                 mov     large fs:0, eax
.text$mn:000033E3                 mov     [ebp+var_10], ecx
.text$mn:000033E6                 mov     [ebp+var_4], 0
.text$mn:000033ED                 mov     ecx, [ebp+var_10]
.text$mn:000033F0                 call    ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)
.text$mn:000033F5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000033FC                 mov     ecx, [ebp+var_10]
.text$mn:000033FF                 call    ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)
.text$mn:00003404                 mov     ecx, [ebp+var_C]
.text$mn:00003407                 mov     large fs:0, ecx
.text$mn:0000340E                 pop     ecx
.text$mn:0000340F                 mov     esp, ebp
.text$mn:00003411                 pop     ebp
.text$mn:00003412                 retn
.text$mn:00003412 ??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$mn:00003412
.text$mn:00003412 ; ---------------------------------------------------------------------------
.text$mn:00003413                 align 4
.text$mn:00003413 _text$mn        ends
.text$mn:00003413
.text$x:00003414 ; ===========================================================================
.text$x:00003414
.text$x:00003414 ; Segment type: Pure code
.text$x:00003414 ; Segment permissions: Read/Execute
.text$x:00003414 _text$x         segment para public 'CODE' use32
.text$x:00003414                 assume cs:_text$x
.text$x:00003414                 ;org 3414h
.text$x:00003414 ; COMDAT (pick associative to section at 33C0)
.text$x:00003414                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003414
.text$x:00003414 ; =============== S U B R O U T I N E =======================================
.text$x:00003414
.text$x:00003414
.text$x:00003414 __unwindfunclet$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0 proc near
.text$x:00003414                                         ; DATA XREF: .xdata$x:000055FCo
.text$x:00003414                 mov     ecx, [ebp-10h]
.text$x:00003417                 jmp     ??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)
.text$x:00003417 __unwindfunclet$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0 endp
.text$x:00003417
.text$x:0000341C
.text$x:0000341C ; =============== S U B R O U T I N E =======================================
.text$x:0000341C
.text$x:0000341C
.text$x:0000341C __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ proc near
.text$x:0000341C                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)+5o
.text$x:0000341C
.text$x:0000341C arg_4           = dword ptr  8
.text$x:0000341C
.text$x:0000341C                 mov     edx, [esp+arg_4]
.text$x:00003420                 lea     eax, [edx+0Ch]
.text$x:00003423                 mov     ecx, [edx-8]
.text$x:00003426                 xor     ecx, eax
.text$x:00003428                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000342D                 mov     eax, offset __ehfuncinfo$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.text$x:00003432                 jmp     ___CxxFrameHandler3
.text$x:00003432 __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ endp
.text$x:00003432
.text$x:00003432 ; ---------------------------------------------------------------------------
.text$x:00003437                 align 4
.text$x:00003437 _text$x         ends
.text$x:00003437
.text$mn:00003438 ; ===========================================================================
.text$mn:00003438
.text$mn:00003438 ; Segment type: Pure code
.text$mn:00003438 ; Segment permissions: Read/Execute
.text$mn:00003438 _text$mn        segment para public 'CODE' use32
.text$mn:00003438                 assume cs:_text$mn
.text$mn:00003438                 ;org 3438h
.text$mn:00003438 ; COMDAT (pick any)
.text$mn:00003438                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003438
.text$mn:00003438 ; =============== S U B R O U T I N E =======================================
.text$mn:00003438
.text$mn:00003438 ; Attributes: bp-based frame
.text$mn:00003438
.text$mn:00003438 ; _DWORD __thiscall Gripper::~Gripper(Gripper *__hidden this)
.text$mn:00003438                 public ??1Gripper@@QAE@XZ
.text$mn:00003438 ??1Gripper@@QAE@XZ proc near            ; CODE XREF: Gripper::`scalar deleting destructor'(uint)+Ap
.text$mn:00003438
.text$mn:00003438 var_4           = dword ptr -4
.text$mn:00003438
.text$mn:00003438                 push    ebp
.text$mn:00003439                 mov     ebp, esp
.text$mn:0000343B                 push    ecx
.text$mn:0000343C                 mov     [ebp+var_4], ecx
.text$mn:0000343F                 mov     eax, [ebp+var_4]
.text$mn:00003442                 cmp     dword ptr [eax+0B8h], 0
.text$mn:00003449                 jz      short loc_3465
.text$mn:0000344B                 push    0               ; hWndLock
.text$mn:0000344D                 call    dword ptr ds:__imp__LockWindowUpdate@4 ; LockWindowUpdate(x)
.text$mn:00003453                 mov     ecx, [ebp+var_4]
.text$mn:00003456                 mov     edx, [ecx+0B8h]
.text$mn:0000345C                 push    edx             ; hDC
.text$mn:0000345D                 push    0               ; hWnd
.text$mn:0000345F                 call    dword ptr ds:__imp__ReleaseDC@8 ; ReleaseDC(x,x)
.text$mn:00003465
.text$mn:00003465 loc_3465:                               ; CODE XREF: Gripper::~Gripper(void)+11j
.text$mn:00003465                 mov     eax, [ebp+var_4]
.text$mn:00003468                 cmp     dword ptr [eax+0BCh], 0
.text$mn:0000346F                 jz      short loc_3481
.text$mn:00003471                 mov     ecx, [ebp+var_4]
.text$mn:00003474                 mov     edx, [ecx+0BCh]
.text$mn:0000347A                 push    edx             ; ho
.text$mn:0000347B                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:00003481
.text$mn:00003481 loc_3481:                               ; CODE XREF: Gripper::~Gripper(void)+37j
.text$mn:00003481                 mov     eax, [ebp+var_4]
.text$mn:00003484                 cmp     dword ptr [eax+0C0h], 0
.text$mn:0000348B                 jz      short loc_349D
.text$mn:0000348D                 mov     ecx, [ebp+var_4]
.text$mn:00003490                 mov     edx, [ecx+0C0h]
.text$mn:00003496                 push    edx             ; ho
.text$mn:00003497                 call    dword ptr ds:__imp__DeleteObject@4 ; DeleteObject(x)
.text$mn:0000349D
.text$mn:0000349D loc_349D:                               ; CODE XREF: Gripper::~Gripper(void)+53j
.text$mn:0000349D                 mov     esp, ebp
.text$mn:0000349F                 pop     ebp
.text$mn:000034A0                 retn
.text$mn:000034A0 ??1Gripper@@QAE@XZ endp
.text$mn:000034A0
.text$mn:000034A0 ; ---------------------------------------------------------------------------
.text$mn:000034A1                 align 4
.text$mn:000034A1 _text$mn        ends
.text$mn:000034A1
.text$mn:000034A4 ; ===========================================================================
.text$mn:000034A4
.text$mn:000034A4 ; Segment type: Pure code
.text$mn:000034A4 ; Segment permissions: Read/Execute
.text$mn:000034A4 _text$mn        segment para public 'CODE' use32
.text$mn:000034A4                 assume cs:_text$mn
.text$mn:000034A4                 ;org 34A4h
.text$mn:000034A4 ; COMDAT (pick any)
.text$mn:000034A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034A4
.text$mn:000034A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000034A4
.text$mn:000034A4 ; Attributes: bp-based frame
.text$mn:000034A4
.text$mn:000034A4 ; _DWORD __thiscall std::_Container_base12::~_Container_base12(std::_Container_base12 *__hidden this)
.text$mn:000034A4                 public ??1_Container_base12@std@@QAE@XZ
.text$mn:000034A4 ??1_Container_base12@std@@QAE@XZ proc near
.text$mn:000034A4                                         ; CODE XREF: __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0+3j
.text$mn:000034A4                                         ; __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0+3j ...
.text$mn:000034A4
.text$mn:000034A4 var_4           = dword ptr -4
.text$mn:000034A4
.text$mn:000034A4                 push    ebp
.text$mn:000034A5                 mov     ebp, esp
.text$mn:000034A7                 push    ecx
.text$mn:000034A8                 mov     [ebp+var_4], ecx
.text$mn:000034AB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000034AE                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000034B3                 mov     esp, ebp
.text$mn:000034B5                 pop     ebp
.text$mn:000034B6                 retn
.text$mn:000034B6 ??1_Container_base12@std@@QAE@XZ endp
.text$mn:000034B6
.text$mn:000034B6 ; ---------------------------------------------------------------------------
.text$mn:000034B7                 align 4
.text$mn:000034B7 _text$mn        ends
.text$mn:000034B7
.text$mn:000034B8 ; ===========================================================================
.text$mn:000034B8
.text$mn:000034B8 ; Segment type: Pure code
.text$mn:000034B8 ; Segment permissions: Read/Execute
.text$mn:000034B8 _text$mn        segment para public 'CODE' use32
.text$mn:000034B8                 assume cs:_text$mn
.text$mn:000034B8                 ;org 34B8h
.text$mn:000034B8 ; COMDAT (pick any)
.text$mn:000034B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000034B8
.text$mn:000034B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000034B8
.text$mn:000034B8 ; Attributes: bp-based frame
.text$mn:000034B8
.text$mn:000034B8 ; _DWORD __thiscall std::_Generic_error_category::~_Generic_error_category(std::_Generic_error_category *__hidden this)
.text$mn:000034B8                 public ??1_Generic_error_category@std@@UAE@XZ
.text$mn:000034B8 ??1_Generic_error_category@std@@UAE@XZ proc near
.text$mn:000034B8                                         ; CODE XREF: __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0+3j
.text$mn:000034B8                                         ; __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0+3j ...
.text$mn:000034B8
.text$mn:000034B8 var_10          = dword ptr -10h
.text$mn:000034B8 var_C           = dword ptr -0Ch
.text$mn:000034B8 var_4           = dword ptr -4
.text$mn:000034B8
.text$mn:000034B8                 push    ebp
.text$mn:000034B9                 mov     ebp, esp
.text$mn:000034BB                 push    0FFFFFFFFh
.text$mn:000034BD                 push    offset __ehhandler$??1_Generic_error_category@std@@UAE@XZ
.text$mn:000034C2                 mov     eax, large fs:0
.text$mn:000034C8                 push    eax
.text$mn:000034C9                 push    ecx
.text$mn:000034CA                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000034CF                 xor     eax, ebp
.text$mn:000034D1                 push    eax
.text$mn:000034D2                 lea     eax, [ebp+var_C]
.text$mn:000034D5                 mov     large fs:0, eax
.text$mn:000034DB                 mov     [ebp+var_10], ecx
.text$mn:000034DE                 mov     [ebp+var_4], 0
.text$mn:000034E5                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000034EC                 mov     ecx, [ebp+var_10] ; this
.text$mn:000034EF                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000034F4                 mov     ecx, [ebp+var_C]
.text$mn:000034F7                 mov     large fs:0, ecx
.text$mn:000034FE                 pop     ecx
.text$mn:000034FF                 mov     esp, ebp
.text$mn:00003501                 pop     ebp
.text$mn:00003502                 retn
.text$mn:00003502 ??1_Generic_error_category@std@@UAE@XZ endp
.text$mn:00003502
.text$mn:00003502 ; ---------------------------------------------------------------------------
.text$mn:00003503                 align 4
.text$mn:00003503 _text$mn        ends
.text$mn:00003503
.text$x:00003504 ; ===========================================================================
.text$x:00003504
.text$x:00003504 ; Segment type: Pure code
.text$x:00003504 ; Segment permissions: Read/Execute
.text$x:00003504 _text$x         segment para public 'CODE' use32
.text$x:00003504                 assume cs:_text$x
.text$x:00003504                 ;org 3504h
.text$x:00003504 ; COMDAT (pick associative to section at 34B8)
.text$x:00003504                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003504
.text$x:00003504 ; =============== S U B R O U T I N E =======================================
.text$x:00003504
.text$x:00003504
.text$x:00003504 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 proc near
.text$x:00003504                                         ; DATA XREF: .xdata$x:00005324o
.text$x:00003504                 mov     ecx, [ebp-10h]  ; this
.text$x:00003507                 jmp     ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$x:00003507 __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0 endp
.text$x:00003507
.text$x:0000350C
.text$x:0000350C ; =============== S U B R O U T I N E =======================================
.text$x:0000350C
.text$x:0000350C
.text$x:0000350C __ehhandler$??1_Generic_error_category@std@@UAE@XZ proc near
.text$x:0000350C                                         ; DATA XREF: std::_Generic_error_category::~_Generic_error_category(void)+5o
.text$x:0000350C
.text$x:0000350C arg_4           = dword ptr  8
.text$x:0000350C
.text$x:0000350C                 mov     edx, [esp+arg_4]
.text$x:00003510                 lea     eax, [edx+0Ch]
.text$x:00003513                 mov     ecx, [edx-8]
.text$x:00003516                 xor     ecx, eax
.text$x:00003518                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000351D                 mov     eax, offset __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ
.text$x:00003522                 jmp     ___CxxFrameHandler3
.text$x:00003522 __ehhandler$??1_Generic_error_category@std@@UAE@XZ endp
.text$x:00003522
.text$x:00003522 ; ---------------------------------------------------------------------------
.text$x:00003527                 align 4
.text$x:00003527 _text$x         ends
.text$x:00003527
.text$mn:00003528 ; ===========================================================================
.text$mn:00003528
.text$mn:00003528 ; Segment type: Pure code
.text$mn:00003528 ; Segment permissions: Read/Execute
.text$mn:00003528 _text$mn        segment para public 'CODE' use32
.text$mn:00003528                 assume cs:_text$mn
.text$mn:00003528                 ;org 3528h
.text$mn:00003528 ; COMDAT (pick any)
.text$mn:00003528                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003528
.text$mn:00003528 ; =============== S U B R O U T I N E =======================================
.text$mn:00003528
.text$mn:00003528 ; Attributes: bp-based frame
.text$mn:00003528
.text$mn:00003528 ; _DWORD __thiscall std::_Iostream_error_category::~_Iostream_error_category(std::_Iostream_error_category *__hidden this)
.text$mn:00003528                 public ??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003528 ??1_Iostream_error_category@std@@UAE@XZ proc near
.text$mn:00003528                                         ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:00003528                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+8p
.text$mn:00003528
.text$mn:00003528 var_10          = dword ptr -10h
.text$mn:00003528 var_C           = dword ptr -0Ch
.text$mn:00003528 var_4           = dword ptr -4
.text$mn:00003528
.text$mn:00003528                 push    ebp
.text$mn:00003529                 mov     ebp, esp
.text$mn:0000352B                 push    0FFFFFFFFh
.text$mn:0000352D                 push    offset __ehhandler$??1_Iostream_error_category@std@@UAE@XZ
.text$mn:00003532                 mov     eax, large fs:0
.text$mn:00003538                 push    eax
.text$mn:00003539                 push    ecx
.text$mn:0000353A                 mov     eax, dword ptr ds:___security_cookie
.text$mn:0000353F                 xor     eax, ebp
.text$mn:00003541                 push    eax
.text$mn:00003542                 lea     eax, [ebp+var_C]
.text$mn:00003545                 mov     large fs:0, eax
.text$mn:0000354B                 mov     [ebp+var_10], ecx
.text$mn:0000354E                 mov     [ebp+var_4], 0
.text$mn:00003555                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000355C                 mov     ecx, [ebp+var_10] ; this
.text$mn:0000355F                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003564                 mov     ecx, [ebp+var_C]
.text$mn:00003567                 mov     large fs:0, ecx
.text$mn:0000356E                 pop     ecx
.text$mn:0000356F                 mov     esp, ebp
.text$mn:00003571                 pop     ebp
.text$mn:00003572                 retn
.text$mn:00003572 ??1_Iostream_error_category@std@@UAE@XZ endp
.text$mn:00003572
.text$mn:00003572 ; ---------------------------------------------------------------------------
.text$mn:00003573                 align 4
.text$mn:00003573 _text$mn        ends
.text$mn:00003573
.text$x:00003574 ; ===========================================================================
.text$x:00003574
.text$x:00003574 ; Segment type: Pure code
.text$x:00003574 ; Segment permissions: Read/Execute
.text$x:00003574 _text$x         segment para public 'CODE' use32
.text$x:00003574                 assume cs:_text$x
.text$x:00003574                 ;org 3574h
.text$x:00003574 ; COMDAT (pick associative to section at 3528)
.text$x:00003574                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003574
.text$x:00003574 ; =============== S U B R O U T I N E =======================================
.text$x:00003574
.text$x:00003574
.text$x:00003574 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 proc near
.text$x:00003574                                         ; DATA XREF: .xdata$x:000053A8o
.text$x:00003574                 mov     ecx, [ebp-10h]  ; this
.text$x:00003577                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:00003577 __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0 endp
.text$x:00003577
.text$x:0000357C
.text$x:0000357C ; =============== S U B R O U T I N E =======================================
.text$x:0000357C
.text$x:0000357C
.text$x:0000357C __ehhandler$??1_Iostream_error_category@std@@UAE@XZ proc near
.text$x:0000357C                                         ; DATA XREF: std::_Iostream_error_category::~_Iostream_error_category(void)+5o
.text$x:0000357C
.text$x:0000357C arg_4           = dword ptr  8
.text$x:0000357C
.text$x:0000357C                 mov     edx, [esp+arg_4]
.text$x:00003580                 lea     eax, [edx+0Ch]
.text$x:00003583                 mov     ecx, [edx-8]
.text$x:00003586                 xor     ecx, eax
.text$x:00003588                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000358D                 mov     eax, offset __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ
.text$x:00003592                 jmp     ___CxxFrameHandler3
.text$x:00003592 __ehhandler$??1_Iostream_error_category@std@@UAE@XZ endp
.text$x:00003592
.text$x:00003592 ; ---------------------------------------------------------------------------
.text$x:00003597                 align 4
.text$x:00003597 _text$x         ends
.text$x:00003597
.text$mn:00003598 ; ===========================================================================
.text$mn:00003598
.text$mn:00003598 ; Segment type: Pure code
.text$mn:00003598 ; Segment permissions: Read/Execute
.text$mn:00003598 _text$mn        segment para public 'CODE' use32
.text$mn:00003598                 assume cs:_text$mn
.text$mn:00003598                 ;org 3598h
.text$mn:00003598 ; COMDAT (pick any)
.text$mn:00003598                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003598
.text$mn:00003598 ; =============== S U B R O U T I N E =======================================
.text$mn:00003598
.text$mn:00003598 ; Attributes: bp-based frame
.text$mn:00003598
.text$mn:00003598 ; _DWORD __thiscall std::_Iterator_base12::~_Iterator_base12(std::_Iterator_base12 *__hidden this)
.text$mn:00003598                 public ??1_Iterator_base12@std@@QAE@XZ
.text$mn:00003598 ??1_Iterator_base12@std@@QAE@XZ proc near
.text$mn:00003598                                         ; CODE XREF: __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0+3j
.text$mn:00003598                                         ; __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0+3j ...
.text$mn:00003598
.text$mn:00003598 var_14          = byte ptr -14h
.text$mn:00003598 var_10          = dword ptr -10h
.text$mn:00003598 var_C           = dword ptr -0Ch
.text$mn:00003598 var_4           = dword ptr -4
.text$mn:00003598
.text$mn:00003598                 push    ebp
.text$mn:00003599                 mov     ebp, esp
.text$mn:0000359B                 push    0FFFFFFFFh
.text$mn:0000359D                 push    offset __ehhandler$??1_Iterator_base12@std@@QAE@XZ
.text$mn:000035A2                 mov     eax, large fs:0
.text$mn:000035A8                 push    eax
.text$mn:000035A9                 sub     esp, 8
.text$mn:000035AC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000035B1                 xor     eax, ebp
.text$mn:000035B3                 push    eax
.text$mn:000035B4                 lea     eax, [ebp+var_C]
.text$mn:000035B7                 mov     large fs:0, eax
.text$mn:000035BD                 mov     [ebp+var_10], ecx
.text$mn:000035C0                 push    3               ; int
.text$mn:000035C2                 lea     ecx, [ebp+var_14] ; this
.text$mn:000035C5                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:000035CA                 mov     [ebp+var_4], 0
.text$mn:000035D1                 mov     ecx, [ebp+var_10] ; this
.text$mn:000035D4                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:000035D9                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000035E0                 lea     ecx, [ebp+var_14] ; this
.text$mn:000035E3                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:000035E8                 mov     ecx, [ebp+var_C]
.text$mn:000035EB                 mov     large fs:0, ecx
.text$mn:000035F2                 pop     ecx
.text$mn:000035F3                 mov     esp, ebp
.text$mn:000035F5                 pop     ebp
.text$mn:000035F6                 retn
.text$mn:000035F6 ??1_Iterator_base12@std@@QAE@XZ endp
.text$mn:000035F6
.text$mn:000035F6 ; ---------------------------------------------------------------------------
.text$mn:000035F7                 align 4
.text$mn:000035F7 _text$mn        ends
.text$mn:000035F7
.text$x:000035F8 ; ===========================================================================
.text$x:000035F8
.text$x:000035F8 ; Segment type: Pure code
.text$x:000035F8 ; Segment permissions: Read/Execute
.text$x:000035F8 _text$x         segment para public 'CODE' use32
.text$x:000035F8                 assume cs:_text$x
.text$x:000035F8                 ;org 35F8h
.text$x:000035F8 ; COMDAT (pick associative to section at 3598)
.text$x:000035F8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000035F8
.text$x:000035F8 ; =============== S U B R O U T I N E =======================================
.text$x:000035F8
.text$x:000035F8
.text$x:000035F8 __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 proc near
.text$x:000035F8                                         ; DATA XREF: .xdata$x:00005054o
.text$x:000035F8                 lea     ecx, [ebp-14h]  ; this
.text$x:000035FB                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000035FB __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0 endp
.text$x:000035FB
.text$x:00003600
.text$x:00003600 ; =============== S U B R O U T I N E =======================================
.text$x:00003600
.text$x:00003600
.text$x:00003600 __ehhandler$??1_Iterator_base12@std@@QAE@XZ proc near
.text$x:00003600                                         ; DATA XREF: std::_Iterator_base12::~_Iterator_base12(void)+5o
.text$x:00003600
.text$x:00003600 arg_4           = dword ptr  8
.text$x:00003600
.text$x:00003600                 mov     edx, [esp+arg_4]
.text$x:00003604                 lea     eax, [edx+0Ch]
.text$x:00003607                 mov     ecx, [edx-0Ch]
.text$x:0000360A                 xor     ecx, eax
.text$x:0000360C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003611                 mov     eax, offset __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
.text$x:00003616                 jmp     ___CxxFrameHandler3
.text$x:00003616 __ehhandler$??1_Iterator_base12@std@@QAE@XZ endp
.text$x:00003616
.text$x:00003616 ; ---------------------------------------------------------------------------
.text$x:0000361B                 align 4
.text$x:0000361B _text$x         ends
.text$x:0000361B
.text$mn:0000361C ; ===========================================================================
.text$mn:0000361C
.text$mn:0000361C ; Segment type: Pure code
.text$mn:0000361C ; Segment permissions: Read/Execute
.text$mn:0000361C _text$mn        segment para public 'CODE' use32
.text$mn:0000361C                 assume cs:_text$mn
.text$mn:0000361C                 ;org 361Ch
.text$mn:0000361C ; COMDAT (pick any)
.text$mn:0000361C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000361C
.text$mn:0000361C ; =============== S U B R O U T I N E =======================================
.text$mn:0000361C
.text$mn:0000361C ; Attributes: bp-based frame
.text$mn:0000361C
.text$mn:0000361C ; _DWORD __thiscall std::_System_error_category::~_System_error_category(std::_System_error_category *__hidden this)
.text$mn:0000361C                 public ??1_System_error_category@std@@UAE@XZ
.text$mn:0000361C ??1_System_error_category@std@@UAE@XZ proc near
.text$mn:0000361C                                         ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+Ap
.text$mn:0000361C                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+8p
.text$mn:0000361C
.text$mn:0000361C var_10          = dword ptr -10h
.text$mn:0000361C var_C           = dword ptr -0Ch
.text$mn:0000361C var_4           = dword ptr -4
.text$mn:0000361C
.text$mn:0000361C                 push    ebp
.text$mn:0000361D                 mov     ebp, esp
.text$mn:0000361F                 push    0FFFFFFFFh
.text$mn:00003621                 push    offset __ehhandler$??1_System_error_category@std@@UAE@XZ
.text$mn:00003626                 mov     eax, large fs:0
.text$mn:0000362C                 push    eax
.text$mn:0000362D                 push    ecx
.text$mn:0000362E                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003633                 xor     eax, ebp
.text$mn:00003635                 push    eax
.text$mn:00003636                 lea     eax, [ebp+var_C]
.text$mn:00003639                 mov     large fs:0, eax
.text$mn:0000363F                 mov     [ebp+var_10], ecx
.text$mn:00003642                 mov     [ebp+var_4], 0
.text$mn:00003649                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003650                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003653                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003658                 mov     ecx, [ebp+var_C]
.text$mn:0000365B                 mov     large fs:0, ecx
.text$mn:00003662                 pop     ecx
.text$mn:00003663                 mov     esp, ebp
.text$mn:00003665                 pop     ebp
.text$mn:00003666                 retn
.text$mn:00003666 ??1_System_error_category@std@@UAE@XZ endp
.text$mn:00003666
.text$mn:00003666 ; ---------------------------------------------------------------------------
.text$mn:00003667                 align 4
.text$mn:00003667 _text$mn        ends
.text$mn:00003667
.text$x:00003668 ; ===========================================================================
.text$x:00003668
.text$x:00003668 ; Segment type: Pure code
.text$x:00003668 ; Segment permissions: Read/Execute
.text$x:00003668 _text$x         segment para public 'CODE' use32
.text$x:00003668                 assume cs:_text$x
.text$x:00003668                 ;org 3668h
.text$x:00003668 ; COMDAT (pick associative to section at 361C)
.text$x:00003668                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003668
.text$x:00003668 ; =============== S U B R O U T I N E =======================================
.text$x:00003668
.text$x:00003668
.text$x:00003668 __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 proc near
.text$x:00003668                                         ; DATA XREF: .xdata$x:0000542Co
.text$x:00003668                 mov     ecx, [ebp-10h]  ; this
.text$x:0000366B                 jmp     ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$x:0000366B __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0 endp
.text$x:0000366B
.text$x:00003670
.text$x:00003670 ; =============== S U B R O U T I N E =======================================
.text$x:00003670
.text$x:00003670
.text$x:00003670 __ehhandler$??1_System_error_category@std@@UAE@XZ proc near
.text$x:00003670                                         ; DATA XREF: std::_System_error_category::~_System_error_category(void)+5o
.text$x:00003670
.text$x:00003670 arg_4           = dword ptr  8
.text$x:00003670
.text$x:00003670                 mov     edx, [esp+arg_4]
.text$x:00003674                 lea     eax, [edx+0Ch]
.text$x:00003677                 mov     ecx, [edx-8]
.text$x:0000367A                 xor     ecx, eax
.text$x:0000367C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003681                 mov     eax, offset __ehfuncinfo$??1_System_error_category@std@@UAE@XZ
.text$x:00003686                 jmp     ___CxxFrameHandler3
.text$x:00003686 __ehhandler$??1_System_error_category@std@@UAE@XZ endp
.text$x:00003686
.text$x:00003686 ; ---------------------------------------------------------------------------
.text$x:0000368B                 align 4
.text$x:0000368B _text$x         ends
.text$x:0000368B
.text$mn:0000368C ; ===========================================================================
.text$mn:0000368C
.text$mn:0000368C ; Segment type: Pure code
.text$mn:0000368C ; Segment permissions: Read/Execute
.text$mn:0000368C _text$mn        segment para public 'CODE' use32
.text$mn:0000368C                 assume cs:_text$mn
.text$mn:0000368C                 ;org 368Ch
.text$mn:0000368C ; COMDAT (pick any)
.text$mn:0000368C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000368C
.text$mn:0000368C ; =============== S U B R O U T I N E =======================================
.text$mn:0000368C
.text$mn:0000368C ; Attributes: bp-based frame
.text$mn:0000368C
.text$mn:0000368C ; _DWORD __thiscall std::error_category::~error_category(std::error_category *__hidden this)
.text$mn:0000368C                 public ??1error_category@std@@UAE@XZ
.text$mn:0000368C ??1error_category@std@@UAE@XZ proc near ; CODE XREF: __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0+3j
.text$mn:0000368C                                         ; std::_Generic_error_category::~_Generic_error_category(void)+37p ...
.text$mn:0000368C
.text$mn:0000368C var_4           = dword ptr -4
.text$mn:0000368C
.text$mn:0000368C                 push    ebp
.text$mn:0000368D                 mov     ebp, esp
.text$mn:0000368F                 push    ecx
.text$mn:00003690                 mov     [ebp+var_4], ecx
.text$mn:00003693                 mov     eax, [ebp+var_4]
.text$mn:00003696                 mov     dword ptr [eax], offset ??_7error_category@std@@6B@ ; const std::error_category::`vftable'
.text$mn:0000369C                 mov     esp, ebp
.text$mn:0000369E                 pop     ebp
.text$mn:0000369F                 retn
.text$mn:0000369F ??1error_category@std@@UAE@XZ endp
.text$mn:0000369F
.text$mn:0000369F _text$mn        ends
.text$mn:0000369F
.text$mn:000036A0 ; ===========================================================================
.text$mn:000036A0
.text$mn:000036A0 ; Segment type: Pure code
.text$mn:000036A0 ; Segment permissions: Read/Execute
.text$mn:000036A0 _text$mn        segment para public 'CODE' use32
.text$mn:000036A0                 assume cs:_text$mn
.text$mn:000036A0                 ;org 36A0h
.text$mn:000036A0 ; COMDAT (pick any)
.text$mn:000036A0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000036A0
.text$mn:000036A0 ; =============== S U B R O U T I N E =======================================
.text$mn:000036A0
.text$mn:000036A0 ; Attributes: bp-based frame
.text$mn:000036A0
.text$mn:000036A0 ; _DWORD __thiscall std::runtime_error::~runtime_error(std::runtime_error *__hidden this)
.text$mn:000036A0                 public ??1runtime_error@std@@UAE@XZ
.text$mn:000036A0 ??1runtime_error@std@@UAE@XZ proc near  ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+Ap
.text$mn:000036A0                                         ; DATA XREF: .xdata$x:00005964o
.text$mn:000036A0
.text$mn:000036A0 var_10          = dword ptr -10h
.text$mn:000036A0 var_C           = dword ptr -0Ch
.text$mn:000036A0 var_4           = dword ptr -4
.text$mn:000036A0
.text$mn:000036A0                 push    ebp
.text$mn:000036A1                 mov     ebp, esp
.text$mn:000036A3                 push    0FFFFFFFFh
.text$mn:000036A5                 push    offset __ehhandler$??1runtime_error@std@@UAE@XZ
.text$mn:000036AA                 mov     eax, large fs:0
.text$mn:000036B0                 push    eax
.text$mn:000036B1                 push    ecx
.text$mn:000036B2                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000036B7                 xor     eax, ebp
.text$mn:000036B9                 push    eax
.text$mn:000036BA                 lea     eax, [ebp+var_C]
.text$mn:000036BD                 mov     large fs:0, eax
.text$mn:000036C3                 mov     [ebp+var_10], ecx
.text$mn:000036C6                 mov     [ebp+var_4], 0
.text$mn:000036CD                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:000036D4                 mov     ecx, [ebp+var_10] ; this
.text$mn:000036D7                 call    ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$mn:000036DC                 mov     ecx, [ebp+var_C]
.text$mn:000036DF                 mov     large fs:0, ecx
.text$mn:000036E6                 pop     ecx
.text$mn:000036E7                 mov     esp, ebp
.text$mn:000036E9                 pop     ebp
.text$mn:000036EA                 retn
.text$mn:000036EA ??1runtime_error@std@@UAE@XZ endp
.text$mn:000036EA
.text$mn:000036EA ; ---------------------------------------------------------------------------
.text$mn:000036EB                 align 4
.text$mn:000036EB _text$mn        ends
.text$mn:000036EB
.text$x:000036EC ; ===========================================================================
.text$x:000036EC
.text$x:000036EC ; Segment type: Pure code
.text$x:000036EC ; Segment permissions: Read/Execute
.text$x:000036EC _text$x         segment para public 'CODE' use32
.text$x:000036EC                 assume cs:_text$x
.text$x:000036EC                 ;org 36ECh
.text$x:000036EC ; COMDAT (pick associative to section at 36A0)
.text$x:000036EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000036EC
.text$x:000036EC ; =============== S U B R O U T I N E =======================================
.text$x:000036EC
.text$x:000036EC
.text$x:000036EC __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 proc near
.text$x:000036EC                                         ; DATA XREF: .xdata$x:00005274o
.text$x:000036EC                 mov     ecx, [ebp-10h]  ; this
.text$x:000036EF                 jmp     ??1exception@std@@UAE@XZ ; std::exception::~exception(void)
.text$x:000036EF __unwindfunclet$??1runtime_error@std@@UAE@XZ$0 endp
.text$x:000036EF
.text$x:000036F4
.text$x:000036F4 ; =============== S U B R O U T I N E =======================================
.text$x:000036F4
.text$x:000036F4
.text$x:000036F4 __ehhandler$??1runtime_error@std@@UAE@XZ proc near
.text$x:000036F4                                         ; DATA XREF: std::runtime_error::~runtime_error(void)+5o
.text$x:000036F4
.text$x:000036F4 arg_4           = dword ptr  8
.text$x:000036F4
.text$x:000036F4                 mov     edx, [esp+arg_4]
.text$x:000036F8                 lea     eax, [edx+0Ch]
.text$x:000036FB                 mov     ecx, [edx-8]
.text$x:000036FE                 xor     ecx, eax
.text$x:00003700                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003705                 mov     eax, offset __ehfuncinfo$??1runtime_error@std@@UAE@XZ
.text$x:0000370A                 jmp     ___CxxFrameHandler3
.text$x:0000370A __ehhandler$??1runtime_error@std@@UAE@XZ endp
.text$x:0000370A
.text$x:0000370A ; ---------------------------------------------------------------------------
.text$x:0000370F                 align 10h
.text$x:0000370F _text$x         ends
.text$x:0000370F
.text$mn:00003710 ; ===========================================================================
.text$mn:00003710
.text$mn:00003710 ; Segment type: Pure code
.text$mn:00003710 ; Segment permissions: Read/Execute
.text$mn:00003710 _text$mn        segment para public 'CODE' use32
.text$mn:00003710                 assume cs:_text$mn
.text$mn:00003710                 ;org 3710h
.text$mn:00003710 ; COMDAT (pick any)
.text$mn:00003710                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003710
.text$mn:00003710 ; =============== S U B R O U T I N E =======================================
.text$mn:00003710
.text$mn:00003710 ; Attributes: bp-based frame
.text$mn:00003710
.text$mn:00003710 ; void *__cdecl operator new(unsigned int, void *)
.text$mn:00003710                 public ??2@YAPAXIPAX@Z
.text$mn:00003710 ??2@YAPAXIPAX@Z proc near               ; CODE XREF: std::allocator<char>::construct<char *,char * &>(char * *,char * &)+2Ep
.text$mn:00003710                                         ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)+2Ep
.text$mn:00003710
.text$mn:00003710 arg_4           = dword ptr  0Ch
.text$mn:00003710
.text$mn:00003710                 push    ebp
.text$mn:00003711                 mov     ebp, esp
.text$mn:00003713                 mov     eax, [ebp+arg_4]
.text$mn:00003716                 pop     ebp
.text$mn:00003717                 retn
.text$mn:00003717 ??2@YAPAXIPAX@Z endp
.text$mn:00003717
.text$mn:00003717 _text$mn        ends
.text$mn:00003717
.text$mn:00003718 ; ===========================================================================
.text$mn:00003718
.text$mn:00003718 ; Segment type: Pure code
.text$mn:00003718 ; Segment permissions: Read/Execute
.text$mn:00003718 _text$mn        segment para public 'CODE' use32
.text$mn:00003718                 assume cs:_text$mn
.text$mn:00003718                 ;org 3718h
.text$mn:00003718 ; COMDAT (pick any)
.text$mn:00003718                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003718
.text$mn:00003718 ; =============== S U B R O U T I N E =======================================
.text$mn:00003718
.text$mn:00003718 ; Attributes: bp-based frame
.text$mn:00003718
.text$mn:00003718 ; void __cdecl operator delete(void *)
.text$mn:00003718                 public ??3@YAXPAX0@Z
.text$mn:00003718 ??3@YAXPAX0@Z   proc near               ; CODE XREF: __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0+8p
.text$mn:00003718                                         ; __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0+8p
.text$mn:00003718                 push    ebp
.text$mn:00003719                 mov     ebp, esp
.text$mn:0000371B                 pop     ebp
.text$mn:0000371C                 retn
.text$mn:0000371C ??3@YAXPAX0@Z   endp
.text$mn:0000371C
.text$mn:0000371C ; ---------------------------------------------------------------------------
.text$mn:0000371D                 align 10h
.text$mn:0000371D _text$mn        ends
.text$mn:0000371D
.text$mn:00003720 ; ===========================================================================
.text$mn:00003720
.text$mn:00003720 ; Segment type: Pure code
.text$mn:00003720 ; Segment permissions: Read/Execute
.text$mn:00003720 _text$mn        segment para public 'CODE' use32
.text$mn:00003720                 assume cs:_text$mn
.text$mn:00003720                 ;org 3720h
.text$mn:00003720 ; COMDAT (pick any)
.text$mn:00003720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003720
.text$mn:00003720 ; =============== S U B R O U T I N E =======================================
.text$mn:00003720
.text$mn:00003720 ; Attributes: bp-based frame
.text$mn:00003720
.text$mn:00003720 ; public: struct std::_Iterator_base12 & __thiscall std::_Iterator_base12::operator=(struct std::_Iterator_base12 const &)
.text$mn:00003720                 public ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:00003720 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$mn:00003720                                         ; CODE XREF: std::_Iterator_base12::_Iterator_base12(std::_Iterator_base12 const &)+21p
.text$mn:00003720
.text$mn:00003720 var_14          = byte ptr -14h
.text$mn:00003720 var_10          = dword ptr -10h
.text$mn:00003720 var_C           = dword ptr -0Ch
.text$mn:00003720 var_4           = dword ptr -4
.text$mn:00003720 arg_0           = dword ptr  8
.text$mn:00003720
.text$mn:00003720                 push    ebp
.text$mn:00003721                 mov     ebp, esp
.text$mn:00003723                 push    0FFFFFFFFh
.text$mn:00003725                 push    offset __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$mn:0000372A                 mov     eax, large fs:0
.text$mn:00003730                 push    eax
.text$mn:00003731                 sub     esp, 8
.text$mn:00003734                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003739                 xor     eax, ebp
.text$mn:0000373B                 push    eax
.text$mn:0000373C                 lea     eax, [ebp+var_C]
.text$mn:0000373F                 mov     large fs:0, eax
.text$mn:00003745                 mov     [ebp+var_10], ecx
.text$mn:00003748                 mov     eax, [ebp+var_10]
.text$mn:0000374B                 mov     ecx, [ebp+arg_0]
.text$mn:0000374E                 mov     edx, [eax]
.text$mn:00003750                 cmp     edx, [ecx]
.text$mn:00003752                 jnz     short loc_3756
.text$mn:00003754                 jmp     short loc_3798
.text$mn:00003756 ; ---------------------------------------------------------------------------
.text$mn:00003756
.text$mn:00003756 loc_3756:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+32j
.text$mn:00003756                 mov     eax, [ebp+arg_0]
.text$mn:00003759                 cmp     dword ptr [eax], 0
.text$mn:0000375C                 jz      short loc_3770
.text$mn:0000375E                 mov     ecx, [ebp+arg_0]
.text$mn:00003761                 mov     edx, [ecx]
.text$mn:00003763                 mov     eax, [edx]
.text$mn:00003765                 push    eax             ; struct std::_Container_base12 *
.text$mn:00003766                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003769                 call    ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)
.text$mn:0000376E                 jmp     short loc_3798
.text$mn:00003770 ; ---------------------------------------------------------------------------
.text$mn:00003770
.text$mn:00003770 loc_3770:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+3Cj
.text$mn:00003770                 push    3               ; int
.text$mn:00003772                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003775                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:0000377A                 mov     [ebp+var_4], 0
.text$mn:00003781                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003784                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003789                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003790                 lea     ecx, [ebp+var_14] ; this
.text$mn:00003793                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003798
.text$mn:00003798 loc_3798:                               ; CODE XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+34j
.text$mn:00003798                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+4Ej
.text$mn:00003798                 mov     eax, [ebp+var_10]
.text$mn:0000379B                 mov     ecx, [ebp+var_C]
.text$mn:0000379E                 mov     large fs:0, ecx
.text$mn:000037A5                 pop     ecx
.text$mn:000037A6                 mov     esp, ebp
.text$mn:000037A8                 pop     ebp
.text$mn:000037A9                 retn    4
.text$mn:000037A9 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$mn:000037A9
.text$mn:000037A9 _text$mn        ends
.text$mn:000037A9
.text$x:000037AC ; ===========================================================================
.text$x:000037AC
.text$x:000037AC ; Segment type: Pure code
.text$x:000037AC ; Segment permissions: Read/Execute
.text$x:000037AC _text$x         segment para public 'CODE' use32
.text$x:000037AC                 assume cs:_text$x
.text$x:000037AC                 ;org 37ACh
.text$x:000037AC ; COMDAT (pick associative to section at 3720)
.text$x:000037AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:000037AC
.text$x:000037AC ; =============== S U B R O U T I N E =======================================
.text$x:000037AC
.text$x:000037AC
.text$x:000037AC __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 proc near
.text$x:000037AC                                         ; DATA XREF: .xdata$x:00005028o
.text$x:000037AC                 lea     ecx, [ebp-14h]  ; this
.text$x:000037AF                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:000037AF __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0 endp
.text$x:000037AF
.text$x:000037B4
.text$x:000037B4 ; =============== S U B R O U T I N E =======================================
.text$x:000037B4
.text$x:000037B4
.text$x:000037B4 __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z proc near
.text$x:000037B4                                         ; DATA XREF: std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+5o
.text$x:000037B4
.text$x:000037B4 arg_4           = dword ptr  8
.text$x:000037B4
.text$x:000037B4                 mov     edx, [esp+arg_4]
.text$x:000037B8                 lea     eax, [edx+0Ch]
.text$x:000037BB                 mov     ecx, [edx-0Ch]
.text$x:000037BE                 xor     ecx, eax
.text$x:000037C0                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:000037C5                 mov     eax, offset __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.text$x:000037CA                 jmp     ___CxxFrameHandler3
.text$x:000037CA __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z endp
.text$x:000037CA
.text$x:000037CA ; ---------------------------------------------------------------------------
.text$x:000037CF                 align 10h
.text$x:000037CF _text$x         ends
.text$x:000037CF
.text$mn:000037D0 ; ===========================================================================
.text$mn:000037D0
.text$mn:000037D0 ; Segment type: Pure code
.text$mn:000037D0 ; Segment permissions: Read/Execute
.text$mn:000037D0 _text$mn        segment para public 'CODE' use32
.text$mn:000037D0                 assume cs:_text$mn
.text$mn:000037D0                 ;org 37D0h
.text$mn:000037D0 ; COMDAT (pick any)
.text$mn:000037D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037D0
.text$mn:000037D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000037D0
.text$mn:000037D0 ; Attributes: bp-based frame
.text$mn:000037D0
.text$mn:000037D0 ; public: bool __thiscall std::error_category::operator==(class std::error_category const &)const
.text$mn:000037D0                 public ??8error_category@std@@QBE_NABV01@@Z
.text$mn:000037D0 ??8error_category@std@@QBE_NABV01@@Z proc near
.text$mn:000037D0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+1Dp
.text$mn:000037D0                                         ; std::error_category::equivalent(std::error_code const &,int)+15p
.text$mn:000037D0
.text$mn:000037D0 var_8           = dword ptr -8
.text$mn:000037D0 var_4           = dword ptr -4
.text$mn:000037D0 arg_0           = dword ptr  8
.text$mn:000037D0
.text$mn:000037D0                 push    ebp
.text$mn:000037D1                 mov     ebp, esp
.text$mn:000037D3                 sub     esp, 8
.text$mn:000037D6                 mov     [ebp+var_8], ecx
.text$mn:000037D9                 mov     eax, [ebp+var_8]
.text$mn:000037DC                 cmp     eax, [ebp+arg_0]
.text$mn:000037DF                 jnz     short loc_37EA
.text$mn:000037E1                 mov     [ebp+var_4], 1
.text$mn:000037E8                 jmp     short loc_37F1
.text$mn:000037EA ; ---------------------------------------------------------------------------
.text$mn:000037EA
.text$mn:000037EA loc_37EA:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+Fj
.text$mn:000037EA                 mov     [ebp+var_4], 0
.text$mn:000037F1
.text$mn:000037F1 loc_37F1:                               ; CODE XREF: std::error_category::operator==(std::error_category const &)+18j
.text$mn:000037F1                 mov     al, byte ptr [ebp+var_4]
.text$mn:000037F4                 mov     esp, ebp
.text$mn:000037F6                 pop     ebp
.text$mn:000037F7                 retn    4
.text$mn:000037F7 ??8error_category@std@@QBE_NABV01@@Z endp
.text$mn:000037F7
.text$mn:000037F7 ; ---------------------------------------------------------------------------
.text$mn:000037FA                 align 4
.text$mn:000037FA _text$mn        ends
.text$mn:000037FA
.text$mn:000037FC ; ===========================================================================
.text$mn:000037FC
.text$mn:000037FC ; Segment type: Pure code
.text$mn:000037FC ; Segment permissions: Read/Execute
.text$mn:000037FC _text$mn        segment para public 'CODE' use32
.text$mn:000037FC                 assume cs:_text$mn
.text$mn:000037FC                 ;org 37FCh
.text$mn:000037FC ; COMDAT (pick any)
.text$mn:000037FC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000037FC
.text$mn:000037FC ; =============== S U B R O U T I N E =======================================
.text$mn:000037FC
.text$mn:000037FC ; Attributes: bp-based frame
.text$mn:000037FC
.text$mn:000037FC ; int __stdcall std::error_condition::operator==(std::error_condition *)
.text$mn:000037FC                 public ??8error_condition@std@@QBE_NABV01@@Z
.text$mn:000037FC ??8error_condition@std@@QBE_NABV01@@Z proc near
.text$mn:000037FC                                         ; CODE XREF: std::error_category::equivalent(int,std::error_condition const &)+24p
.text$mn:000037FC
.text$mn:000037FC var_8           = dword ptr -8
.text$mn:000037FC var_4           = dword ptr -4
.text$mn:000037FC arg_0           = dword ptr  8
.text$mn:000037FC
.text$mn:000037FC                 push    ebp
.text$mn:000037FD                 mov     ebp, esp
.text$mn:000037FF                 sub     esp, 8
.text$mn:00003802                 push    esi
.text$mn:00003803                 mov     [ebp+var_4], ecx
.text$mn:00003806                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003809                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:0000380E                 push    eax
.text$mn:0000380F                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003812                 call    ?category@error_condition@std@@QBEABVerror_category@2@XZ ; std::error_condition::category(void)
.text$mn:00003817                 mov     ecx, eax
.text$mn:00003819                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:0000381E                 movzx   eax, al
.text$mn:00003821                 test    eax, eax
.text$mn:00003823                 jz      short loc_3844
.text$mn:00003825                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003828                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:0000382D                 mov     esi, eax
.text$mn:0000382F                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00003832                 call    ?value@error_condition@std@@QBEHXZ ; std::error_condition::value(void)
.text$mn:00003837                 cmp     esi, eax
.text$mn:00003839                 jnz     short loc_3844
.text$mn:0000383B                 mov     [ebp+var_8], 1
.text$mn:00003842                 jmp     short loc_384B
.text$mn:00003844 ; ---------------------------------------------------------------------------
.text$mn:00003844
.text$mn:00003844 loc_3844:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+27j
.text$mn:00003844                                         ; std::error_condition::operator==(std::error_condition const &)+3Dj
.text$mn:00003844                 mov     [ebp+var_8], 0
.text$mn:0000384B
.text$mn:0000384B loc_384B:                               ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+46j
.text$mn:0000384B                 mov     al, byte ptr [ebp+var_8]
.text$mn:0000384E                 pop     esi
.text$mn:0000384F                 mov     esp, ebp
.text$mn:00003851                 pop     ebp
.text$mn:00003852                 retn    4
.text$mn:00003852 ??8error_condition@std@@QBE_NABV01@@Z endp
.text$mn:00003852
.text$mn:00003852 ; ---------------------------------------------------------------------------
.text$mn:00003855                 align 4
.text$mn:00003855 _text$mn        ends
.text$mn:00003855
.text$mn:00003858 ; ===========================================================================
.text$mn:00003858
.text$mn:00003858 ; Segment type: Pure code
.text$mn:00003858 ; Segment permissions: Read/Execute
.text$mn:00003858 _text$mn        segment para public 'CODE' use32
.text$mn:00003858                 assume cs:_text$mn
.text$mn:00003858                 ;org 3858h
.text$mn:00003858 ; COMDAT (pick any)
.text$mn:00003858                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003858
.text$mn:00003858 ; =============== S U B R O U T I N E =======================================
.text$mn:00003858
.text$mn:00003858 ; Attributes: bp-based frame
.text$mn:00003858
.text$mn:00003858 ; public: class DockingCont * & __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::operator[](unsigned int)
.text$mn:00003858                 public ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z
.text$mn:00003858 ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z proc near
.text$mn:00003858                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+A0p
.text$mn:00003858                                         ; Gripper::contHitTest(tagPOINT)+87p ...
.text$mn:00003858
.text$mn:00003858 var_4           = dword ptr -4
.text$mn:00003858 arg_0           = dword ptr  8
.text$mn:00003858
.text$mn:00003858                 push    ebp
.text$mn:00003859                 mov     ebp, esp
.text$mn:0000385B                 push    ecx
.text$mn:0000385C                 mov     [ebp+var_4], ecx
.text$mn:0000385F                 mov     ecx, [ebp+var_4]
.text$mn:00003862                 call    ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::size(void)
.text$mn:00003867                 cmp     eax, [ebp+arg_0]
.text$mn:0000386A                 ja      short loc_38D4
.text$mn:0000386C                 push    4B1h            ; unsigned int
.text$mn:00003871                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00003876                 push    offset ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; "vector subscript out of range"
.text$mn:0000387B                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:00003880                 add     esp, 0Ch
.text$mn:00003883                 mov     eax, offset ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; "Standard C++ Libraries Out of Range"
.text$mn:00003888                 test    eax, eax
.text$mn:0000388A                 jz      short loc_3890
.text$mn:0000388C                 xor     ecx, ecx
.text$mn:0000388E                 jnz     short loc_38B6
.text$mn:00003890
.text$mn:00003890 loc_3890:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+32j
.text$mn:00003890                 push    offset ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; "\"Standard C++ Libraries Out of Range\""...
.text$mn:00003895                 push    offset ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ ; "%s"
.text$mn:0000389A                 push    0
.text$mn:0000389C                 push    4B2h
.text$mn:000038A1                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000038A6                 push    2
.text$mn:000038A8                 call    __CrtDbgReportW
.text$mn:000038AD                 add     esp, 18h
.text$mn:000038B0                 cmp     eax, 1
.text$mn:000038B3                 jnz     short loc_38B6
.text$mn:000038B5                 int     3               ; Trap to Debugger
.text$mn:000038B6
.text$mn:000038B6 loc_38B6:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+36j
.text$mn:000038B6                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+5Bj
.text$mn:000038B6                 push    0
.text$mn:000038B8                 push    4B2h
.text$mn:000038BD                 push    offset ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000038C2                 push    offset ??_C@_1LC@HLAKEHED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAC?$AAo?$AAn?$AAt?$AA?5?$AA?$CK?$AA?0@ ; "std::vector<class DockingCont *,class s"...
.text$mn:000038C7                 push    offset ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; "\"out of range\""
.text$mn:000038CC                 call    __invalid_parameter
.text$mn:000038D1                 add     esp, 14h
.text$mn:000038D4
.text$mn:000038D4 loc_38D4:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+12j
.text$mn:000038D4                 mov     eax, [ebp+var_4]
.text$mn:000038D7                 mov     ecx, [eax+4]
.text$mn:000038DA                 mov     edx, [ebp+arg_0]
.text$mn:000038DD                 lea     eax, [ecx+edx*4]
.text$mn:000038E0                 mov     esp, ebp
.text$mn:000038E2                 pop     ebp
.text$mn:000038E3                 retn    4
.text$mn:000038E3 ??A?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAEAAPAVDockingCont@@I@Z endp
.text$mn:000038E3
.text$mn:000038E3 ; ---------------------------------------------------------------------------
.text$mn:000038E6                 align 4
.text$mn:000038E6 _text$mn        ends
.text$mn:000038E6
.text$mn:000038E8 ; ===========================================================================
.text$mn:000038E8
.text$mn:000038E8 ; Segment type: Pure code
.text$mn:000038E8 ; Segment permissions: Read/Execute
.text$mn:000038E8 _text$mn        segment para public 'CODE' use32
.text$mn:000038E8                 assume cs:_text$mn
.text$mn:000038E8                 ;org 38E8h
.text$mn:000038E8 ; COMDAT (pick any)
.text$mn:000038E8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000038E8
.text$mn:000038E8 ; =============== S U B R O U T I N E =======================================
.text$mn:000038E8
.text$mn:000038E8 ; Attributes: bp-based frame
.text$mn:000038E8
.text$mn:000038E8 ; public: void * __thiscall Gripper::`scalar deleting destructor'(unsigned int)
.text$mn:000038E8                 public ??_GGripper@@QAEPAXI@Z
.text$mn:000038E8 ??_GGripper@@QAEPAXI@Z proc near        ; CODE XREF: Gripper::runProc(uint,uint,long)+189p
.text$mn:000038E8
.text$mn:000038E8 var_4           = dword ptr -4
.text$mn:000038E8 arg_0           = dword ptr  8
.text$mn:000038E8
.text$mn:000038E8                 push    ebp
.text$mn:000038E9                 mov     ebp, esp
.text$mn:000038EB                 push    ecx
.text$mn:000038EC                 mov     [ebp+var_4], ecx
.text$mn:000038EF                 mov     ecx, [ebp+var_4] ; this
.text$mn:000038F2                 call    ??1Gripper@@QAE@XZ ; Gripper::~Gripper(void)
.text$mn:000038F7                 mov     eax, [ebp+arg_0]
.text$mn:000038FA                 and     eax, 1
.text$mn:000038FD                 jz      short loc_390B
.text$mn:000038FF                 mov     ecx, [ebp+var_4]
.text$mn:00003902                 push    ecx             ; void *
.text$mn:00003903                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003908                 add     esp, 4
.text$mn:0000390B
.text$mn:0000390B loc_390B:                               ; CODE XREF: Gripper::`scalar deleting destructor'(uint)+15j
.text$mn:0000390B                 mov     eax, [ebp+var_4]
.text$mn:0000390E                 mov     esp, ebp
.text$mn:00003910                 pop     ebp
.text$mn:00003911                 retn    4
.text$mn:00003911 ??_GGripper@@QAEPAXI@Z endp
.text$mn:00003911
.text$mn:00003911 _text$mn        ends
.text$mn:00003911
.text$mn:00003914 ; ===========================================================================
.text$mn:00003914
.text$mn:00003914 ; Segment type: Pure code
.text$mn:00003914 ; Segment permissions: Read/Execute
.text$mn:00003914 _text$mn        segment para public 'CODE' use32
.text$mn:00003914                 assume cs:_text$mn
.text$mn:00003914                 ;org 3914h
.text$mn:00003914 ; COMDAT (pick any)
.text$mn:00003914                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003914
.text$mn:00003914 ; =============== S U B R O U T I N E =======================================
.text$mn:00003914
.text$mn:00003914 ; Attributes: bp-based frame
.text$mn:00003914
.text$mn:00003914 ; public: virtual void * __thiscall std::_Generic_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003914                 public ??_G_Generic_error_category@std@@UAEPAXI@Z
.text$mn:00003914 ??_G_Generic_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003914
.text$mn:00003914 var_4           = dword ptr -4
.text$mn:00003914 arg_0           = dword ptr  8
.text$mn:00003914
.text$mn:00003914                 push    ebp
.text$mn:00003915                 mov     ebp, esp
.text$mn:00003917                 push    ecx
.text$mn:00003918                 mov     [ebp+var_4], ecx
.text$mn:0000391B                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000391E                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$mn:00003923                 mov     eax, [ebp+arg_0]
.text$mn:00003926                 and     eax, 1
.text$mn:00003929                 jz      short loc_3937
.text$mn:0000392B                 mov     ecx, [ebp+var_4]
.text$mn:0000392E                 push    ecx             ; void *
.text$mn:0000392F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003934                 add     esp, 4
.text$mn:00003937
.text$mn:00003937 loc_3937:                               ; CODE XREF: std::_Generic_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00003937                 mov     eax, [ebp+var_4]
.text$mn:0000393A                 mov     esp, ebp
.text$mn:0000393C                 pop     ebp
.text$mn:0000393D                 retn    4
.text$mn:0000393D ??_G_Generic_error_category@std@@UAEPAXI@Z endp
.text$mn:0000393D
.text$mn:0000393D _text$mn        ends
.text$mn:0000393D
.text$mn:00003940 ; ===========================================================================
.text$mn:00003940
.text$mn:00003940 ; Segment type: Pure code
.text$mn:00003940 ; Segment permissions: Read/Execute
.text$mn:00003940 _text$mn        segment para public 'CODE' use32
.text$mn:00003940                 assume cs:_text$mn
.text$mn:00003940                 ;org 3940h
.text$mn:00003940 ; COMDAT (pick any)
.text$mn:00003940                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003940
.text$mn:00003940 ; =============== S U B R O U T I N E =======================================
.text$mn:00003940
.text$mn:00003940 ; Attributes: bp-based frame
.text$mn:00003940
.text$mn:00003940 ; public: virtual void * __thiscall std::_Iostream_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003940                 public ??_G_Iostream_error_category@std@@UAEPAXI@Z
.text$mn:00003940 ??_G_Iostream_error_category@std@@UAEPAXI@Z proc near
.text$mn:00003940
.text$mn:00003940 var_4           = dword ptr -4
.text$mn:00003940 arg_0           = dword ptr  8
.text$mn:00003940
.text$mn:00003940                 push    ebp
.text$mn:00003941                 mov     ebp, esp
.text$mn:00003943                 push    ecx
.text$mn:00003944                 mov     [ebp+var_4], ecx
.text$mn:00003947                 mov     ecx, [ebp+var_4] ; this
.text$mn:0000394A                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$mn:0000394F                 mov     eax, [ebp+arg_0]
.text$mn:00003952                 and     eax, 1
.text$mn:00003955                 jz      short loc_3963
.text$mn:00003957                 mov     ecx, [ebp+var_4]
.text$mn:0000395A                 push    ecx             ; void *
.text$mn:0000395B                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00003960                 add     esp, 4
.text$mn:00003963
.text$mn:00003963 loc_3963:                               ; CODE XREF: std::_Iostream_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:00003963                 mov     eax, [ebp+var_4]
.text$mn:00003966                 mov     esp, ebp
.text$mn:00003968                 pop     ebp
.text$mn:00003969                 retn    4
.text$mn:00003969 ??_G_Iostream_error_category@std@@UAEPAXI@Z endp
.text$mn:00003969
.text$mn:00003969 _text$mn        ends
.text$mn:00003969
.text$mn:0000396C ; ===========================================================================
.text$mn:0000396C
.text$mn:0000396C ; Segment type: Pure code
.text$mn:0000396C ; Segment permissions: Read/Execute
.text$mn:0000396C _text$mn        segment para public 'CODE' use32
.text$mn:0000396C                 assume cs:_text$mn
.text$mn:0000396C                 ;org 396Ch
.text$mn:0000396C ; COMDAT (pick any)
.text$mn:0000396C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000396C
.text$mn:0000396C ; =============== S U B R O U T I N E =======================================
.text$mn:0000396C
.text$mn:0000396C ; Attributes: bp-based frame
.text$mn:0000396C
.text$mn:0000396C ; public: virtual void * __thiscall std::_System_error_category::`scalar deleting destructor'(unsigned int)
.text$mn:0000396C                 public ??_G_System_error_category@std@@UAEPAXI@Z
.text$mn:0000396C ??_G_System_error_category@std@@UAEPAXI@Z proc near
.text$mn:0000396C
.text$mn:0000396C var_4           = dword ptr -4
.text$mn:0000396C arg_0           = dword ptr  8
.text$mn:0000396C
.text$mn:0000396C                 push    ebp
.text$mn:0000396D                 mov     ebp, esp
.text$mn:0000396F                 push    ecx
.text$mn:00003970                 mov     [ebp+var_4], ecx
.text$mn:00003973                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003976                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$mn:0000397B                 mov     eax, [ebp+arg_0]
.text$mn:0000397E                 and     eax, 1
.text$mn:00003981                 jz      short loc_398F
.text$mn:00003983                 mov     ecx, [ebp+var_4]
.text$mn:00003986                 push    ecx             ; void *
.text$mn:00003987                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000398C                 add     esp, 4
.text$mn:0000398F
.text$mn:0000398F loc_398F:                               ; CODE XREF: std::_System_error_category::`scalar deleting destructor'(uint)+15j
.text$mn:0000398F                 mov     eax, [ebp+var_4]
.text$mn:00003992                 mov     esp, ebp
.text$mn:00003994                 pop     ebp
.text$mn:00003995                 retn    4
.text$mn:00003995 ??_G_System_error_category@std@@UAEPAXI@Z endp
.text$mn:00003995
.text$mn:00003995 _text$mn        ends
.text$mn:00003995
.text$mn:00003998 ; ===========================================================================
.text$mn:00003998
.text$mn:00003998 ; Segment type: Pure code
.text$mn:00003998 ; Segment permissions: Read/Execute
.text$mn:00003998 _text$mn        segment para public 'CODE' use32
.text$mn:00003998                 assume cs:_text$mn
.text$mn:00003998                 ;org 3998h
.text$mn:00003998 ; COMDAT (pick any)
.text$mn:00003998                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003998
.text$mn:00003998 ; =============== S U B R O U T I N E =======================================
.text$mn:00003998
.text$mn:00003998 ; Attributes: bp-based frame
.text$mn:00003998
.text$mn:00003998 ; public: virtual void * __thiscall std::error_category::`scalar deleting destructor'(unsigned int)
.text$mn:00003998                 public ??_Gerror_category@std@@UAEPAXI@Z
.text$mn:00003998 ??_Gerror_category@std@@UAEPAXI@Z proc near
.text$mn:00003998
.text$mn:00003998 var_4           = dword ptr -4
.text$mn:00003998 arg_0           = dword ptr  8
.text$mn:00003998
.text$mn:00003998                 push    ebp
.text$mn:00003999                 mov     ebp, esp
.text$mn:0000399B                 push    ecx
.text$mn:0000399C                 mov     [ebp+var_4], ecx
.text$mn:0000399F                 mov     ecx, [ebp+var_4] ; this
.text$mn:000039A2                 call    ??1error_category@std@@UAE@XZ ; std::error_category::~error_category(void)
.text$mn:000039A7                 mov     eax, [ebp+arg_0]
.text$mn:000039AA                 and     eax, 1
.text$mn:000039AD                 jz      short loc_39BB
.text$mn:000039AF                 mov     ecx, [ebp+var_4]
.text$mn:000039B2                 push    ecx             ; void *
.text$mn:000039B3                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000039B8                 add     esp, 4
.text$mn:000039BB
.text$mn:000039BB loc_39BB:                               ; CODE XREF: std::error_category::`scalar deleting destructor'(uint)+15j
.text$mn:000039BB                 mov     eax, [ebp+var_4]
.text$mn:000039BE                 mov     esp, ebp
.text$mn:000039C0                 pop     ebp
.text$mn:000039C1                 retn    4
.text$mn:000039C1 ??_Gerror_category@std@@UAEPAXI@Z endp
.text$mn:000039C1
.text$mn:000039C1 _text$mn        ends
.text$mn:000039C1
.text$mn:000039C4 ; ===========================================================================
.text$mn:000039C4
.text$mn:000039C4 ; Segment type: Pure code
.text$mn:000039C4 ; Segment permissions: Read/Execute
.text$mn:000039C4 _text$mn        segment para public 'CODE' use32
.text$mn:000039C4                 assume cs:_text$mn
.text$mn:000039C4                 ;org 39C4h
.text$mn:000039C4 ; COMDAT (pick any)
.text$mn:000039C4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000039C4
.text$mn:000039C4 ; =============== S U B R O U T I N E =======================================
.text$mn:000039C4
.text$mn:000039C4 ; Attributes: bp-based frame
.text$mn:000039C4
.text$mn:000039C4 ; public: virtual void * __thiscall std::runtime_error::`scalar deleting destructor'(unsigned int)
.text$mn:000039C4                 public ??_Gruntime_error@std@@UAEPAXI@Z
.text$mn:000039C4 ??_Gruntime_error@std@@UAEPAXI@Z proc near
.text$mn:000039C4
.text$mn:000039C4 var_4           = dword ptr -4
.text$mn:000039C4 arg_0           = dword ptr  8
.text$mn:000039C4
.text$mn:000039C4                 push    ebp
.text$mn:000039C5                 mov     ebp, esp
.text$mn:000039C7                 push    ecx
.text$mn:000039C8                 mov     [ebp+var_4], ecx
.text$mn:000039CB                 mov     ecx, [ebp+var_4] ; this
.text$mn:000039CE                 call    ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.text$mn:000039D3                 mov     eax, [ebp+arg_0]
.text$mn:000039D6                 and     eax, 1
.text$mn:000039D9                 jz      short loc_39E7
.text$mn:000039DB                 mov     ecx, [ebp+var_4]
.text$mn:000039DE                 push    ecx             ; void *
.text$mn:000039DF                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:000039E4                 add     esp, 4
.text$mn:000039E7
.text$mn:000039E7 loc_39E7:                               ; CODE XREF: std::runtime_error::`scalar deleting destructor'(uint)+15j
.text$mn:000039E7                 mov     eax, [ebp+var_4]
.text$mn:000039EA                 mov     esp, ebp
.text$mn:000039EC                 pop     ebp
.text$mn:000039ED                 retn    4
.text$mn:000039ED ??_Gruntime_error@std@@UAEPAXI@Z endp
.text$mn:000039ED
.text$mn:000039ED _text$mn        ends
.text$mn:000039ED
.text$di:000039F0 ; ===========================================================================
.text$di:000039F0
.text$di:000039F0 ; Segment type: Pure code
.text$di:000039F0 ; Segment permissions: Read/Execute
.text$di:000039F0 _text$di        segment para public 'CODE' use32
.text$di:000039F0                 assume cs:_text$di
.text$di:000039F0                 ;org 39F0h
.text$di:000039F0 ; COMDAT (pick any)
.text$di:000039F0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:000039F0
.text$di:000039F0 ; =============== S U B R O U T I N E =======================================
.text$di:000039F0
.text$di:000039F0 ; Attributes: bp-based frame
.text$di:000039F0
.text$di:000039F0 ; void __cdecl `dynamic initializer for 'public: static class std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.text$di:000039F0 ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$di:000039F0                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Generic_object$initializer$)(void)o
.text$di:000039F0                 push    ebp
.text$di:000039F1                 mov     ebp, esp
.text$di:000039F3                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$di:000039F8                 call    ??0_Generic_error_category@std@@QAE@XZ ; std::_Generic_error_category::_Generic_error_category(void)
.text$di:000039FD                 push    offset ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00003A02                 call    _atexit
.text$di:00003A07                 add     esp, 4
.text$di:00003A0A                 pop     ebp
.text$di:00003A0B                 retn
.text$di:00003A0B ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$di:00003A0B
.text$di:00003A0B _text$di        ends
.text$di:00003A0B
.text$di:00003A0C ; ===========================================================================
.text$di:00003A0C
.text$di:00003A0C ; Segment type: Pure code
.text$di:00003A0C ; Segment permissions: Read/Execute
.text$di:00003A0C _text$di        segment para public 'CODE' use32
.text$di:00003A0C                 assume cs:_text$di
.text$di:00003A0C                 ;org 3A0Ch
.text$di:00003A0C ; COMDAT (pick any)
.text$di:00003A0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003A0C
.text$di:00003A0C ; =============== S U B R O U T I N E =======================================
.text$di:00003A0C
.text$di:00003A0C ; Attributes: bp-based frame
.text$di:00003A0C
.text$di:00003A0C ; void __cdecl `dynamic initializer for 'public: static class std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.text$di:00003A0C ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$di:00003A0C                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_Iostream_object$initializer$)(void)o
.text$di:00003A0C                 push    ebp
.text$di:00003A0D                 mov     ebp, esp
.text$di:00003A0F                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$di:00003A14                 call    ??0_Iostream_error_category@std@@QAE@XZ ; std::_Iostream_error_category::_Iostream_error_category(void)
.text$di:00003A19                 push    offset ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00003A1E                 call    _atexit
.text$di:00003A23                 add     esp, 4
.text$di:00003A26                 pop     ebp
.text$di:00003A27                 retn
.text$di:00003A27 ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$di:00003A27
.text$di:00003A27 _text$di        ends
.text$di:00003A27
.text$di:00003A28 ; ===========================================================================
.text$di:00003A28
.text$di:00003A28 ; Segment type: Pure code
.text$di:00003A28 ; Segment permissions: Read/Execute
.text$di:00003A28 _text$di        segment para public 'CODE' use32
.text$di:00003A28                 assume cs:_text$di
.text$di:00003A28                 ;org 3A28h
.text$di:00003A28 ; COMDAT (pick any)
.text$di:00003A28                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003A28
.text$di:00003A28 ; =============== S U B R O U T I N E =======================================
.text$di:00003A28
.text$di:00003A28 ; Attributes: bp-based frame
.text$di:00003A28
.text$di:00003A28 ; void __cdecl `dynamic initializer for 'public: static class std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.text$di:00003A28 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$di:00003A28                                         ; DATA XREF: .CRT$XCU:void (*std::_Error_objects<int>::_System_object$initializer$)(void)o
.text$di:00003A28                 push    ebp
.text$di:00003A29                 mov     ebp, esp
.text$di:00003A2B                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$di:00003A30                 call    ??0_System_error_category@std@@QAE@XZ ; std::_System_error_category::_System_error_category(void)
.text$di:00003A35                 push    offset ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; void (__cdecl *)()
.text$di:00003A3A                 call    _atexit
.text$di:00003A3F                 add     esp, 4
.text$di:00003A42                 pop     ebp
.text$di:00003A43                 retn
.text$di:00003A43 ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$di:00003A43
.text$di:00003A43 _text$di        ends
.text$di:00003A43
.text$di:00003A44 ; ===========================================================================
.text$di:00003A44
.text$di:00003A44 ; Segment type: Pure code
.text$di:00003A44 ; Segment permissions: Read/Execute
.text$di:00003A44 _text$di        segment para public 'CODE' use32
.text$di:00003A44                 assume cs:_text$di
.text$di:00003A44                 ;org 3A44h
.text$di:00003A44 ; COMDAT (pick any)
.text$di:00003A44                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003A44
.text$di:00003A44 ; =============== S U B R O U T I N E =======================================
.text$di:00003A44
.text$di:00003A44 ; Attributes: bp-based frame
.text$di:00003A44
.text$di:00003A44 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id''(void)
.text$di:00003A44 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003A44                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id$initializer$)(void)o
.text$di:00003A44                 push    ebp
.text$di:00003A45                 mov     ebp, esp
.text$di:00003A47                 push    0               ; unsigned int
.text$di:00003A49                 mov     ecx, offset ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00003A4E                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003A53                 pop     ebp
.text$di:00003A54                 retn
.text$di:00003A54 ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003A54
.text$di:00003A54 ; ---------------------------------------------------------------------------
.text$di:00003A55                 align 4
.text$di:00003A55 _text$di        ends
.text$di:00003A55
.text$di:00003A58 ; ===========================================================================
.text$di:00003A58
.text$di:00003A58 ; Segment type: Pure code
.text$di:00003A58 ; Segment permissions: Read/Execute
.text$di:00003A58 _text$di        segment para public 'CODE' use32
.text$di:00003A58                 assume cs:_text$di
.text$di:00003A58                 ;org 3A58h
.text$di:00003A58 ; COMDAT (pick any)
.text$di:00003A58                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003A58
.text$di:00003A58 ; =============== S U B R O U T I N E =======================================
.text$di:00003A58
.text$di:00003A58 ; Attributes: bp-based frame
.text$di:00003A58
.text$di:00003A58 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id''(void)
.text$di:00003A58 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003A58                                         ; DATA XREF: .CRT$XCU:void (*std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id$initializer$)(void)o
.text$di:00003A58                 push    ebp
.text$di:00003A59                 mov     ebp, esp
.text$di:00003A5B                 push    0               ; unsigned int
.text$di:00003A5D                 mov     ecx, offset ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A ; this
.text$di:00003A62                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003A67                 pop     ebp
.text$di:00003A68                 retn
.text$di:00003A68 ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003A68
.text$di:00003A68 ; ---------------------------------------------------------------------------
.text$di:00003A69                 align 4
.text$di:00003A69 _text$di        ends
.text$di:00003A69
.text$di:00003A6C ; ===========================================================================
.text$di:00003A6C
.text$di:00003A6C ; Segment type: Pure code
.text$di:00003A6C ; Segment permissions: Read/Execute
.text$di:00003A6C _text$di        segment para public 'CODE' use32
.text$di:00003A6C                 assume cs:_text$di
.text$di:00003A6C                 ;org 3A6Ch
.text$di:00003A6C ; COMDAT (pick any)
.text$di:00003A6C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003A6C
.text$di:00003A6C ; =============== S U B R O U T I N E =======================================
.text$di:00003A6C
.text$di:00003A6C ; Attributes: bp-based frame
.text$di:00003A6C
.text$di:00003A6C ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<char>::id''(void)
.text$di:00003A6C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003A6C                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<char>::id$initializer$)(void)o
.text$di:00003A6C                 push    ebp
.text$di:00003A6D                 mov     ebp, esp
.text$di:00003A6F                 push    0               ; unsigned int
.text$di:00003A71                 mov     ecx, offset ?id@?$numpunct@D@std@@2V0locale@2@A ; this
.text$di:00003A76                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003A7B                 pop     ebp
.text$di:00003A7C                 retn
.text$di:00003A7C ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003A7C
.text$di:00003A7C ; ---------------------------------------------------------------------------
.text$di:00003A7D                 align 10h
.text$di:00003A7D _text$di        ends
.text$di:00003A7D
.text$di:00003A80 ; ===========================================================================
.text$di:00003A80
.text$di:00003A80 ; Segment type: Pure code
.text$di:00003A80 ; Segment permissions: Read/Execute
.text$di:00003A80 _text$di        segment para public 'CODE' use32
.text$di:00003A80                 assume cs:_text$di
.text$di:00003A80                 ;org 3A80h
.text$di:00003A80 ; COMDAT (pick any)
.text$di:00003A80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003A80
.text$di:00003A80 ; =============== S U B R O U T I N E =======================================
.text$di:00003A80
.text$di:00003A80 ; Attributes: bp-based frame
.text$di:00003A80
.text$di:00003A80 ; void __cdecl `dynamic initializer for 'public: static class std::locale::id std::numpunct<wchar_t>::id''(void)
.text$di:00003A80 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ proc near
.text$di:00003A80                                         ; DATA XREF: .CRT$XCU:void (*std::numpunct<wchar_t>::id$initializer$)(void)o
.text$di:00003A80                 push    ebp
.text$di:00003A81                 mov     ebp, esp
.text$di:00003A83                 push    0               ; unsigned int
.text$di:00003A85                 mov     ecx, offset ?id@?$numpunct@_W@std@@2V0locale@2@A ; this
.text$di:00003A8A                 call    ??0id@locale@std@@QAE@I@Z ; std::locale::id::id(uint)
.text$di:00003A8F                 pop     ebp
.text$di:00003A90                 retn
.text$di:00003A90 ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ endp
.text$di:00003A90
.text$di:00003A90 ; ---------------------------------------------------------------------------
.text$di:00003A91                 align 4
.text$di:00003A91 _text$di        ends
.text$di:00003A91
.text$di:00003A94 ; ===========================================================================
.text$di:00003A94
.text$di:00003A94 ; Segment type: Pure code
.text$di:00003A94 ; Segment permissions: Read/Execute
.text$di:00003A94 _text$di        segment para public 'CODE' use32
.text$di:00003A94                 assume cs:_text$di
.text$di:00003A94                 ;org 3A94h
.text$di:00003A94 ; COMDAT (pick any)
.text$di:00003A94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003A94
.text$di:00003A94 ; =============== S U B R O U T I N E =======================================
.text$di:00003A94
.text$di:00003A94 ; Attributes: bp-based frame
.text$di:00003A94
.text$di:00003A94 ; void __cdecl std::`dynamic initializer for 'allocator_arg''(void)
.text$di:00003A94 ??__Eallocator_arg@std@@YAXXZ proc near ; DATA XREF: .CRT$XCU:_allocator_arg$initializer$o
.text$di:00003A94
.text$di:00003A94 var_1           = byte ptr -1
.text$di:00003A94
.text$di:00003A94                 push    ebp
.text$di:00003A95                 mov     ebp, esp
.text$di:00003A97                 push    ecx
.text$di:00003A98                 xor     eax, eax
.text$di:00003A9A                 mov     [ebp+var_1], al
.text$di:00003A9D                 mov     esp, ebp
.text$di:00003A9F                 pop     ebp
.text$di:00003AA0                 retn
.text$di:00003AA0 ??__Eallocator_arg@std@@YAXXZ endp
.text$di:00003AA0
.text$di:00003AA0 ; ---------------------------------------------------------------------------
.text$di:00003AA1                 align 4
.text$di:00003AA1 _text$di        ends
.text$di:00003AA1
.text$di:00003AA4 ; ===========================================================================
.text$di:00003AA4
.text$di:00003AA4 ; Segment type: Pure code
.text$di:00003AA4 ; Segment permissions: Read/Execute
.text$di:00003AA4 _text$di        segment para public 'CODE' use32
.text$di:00003AA4                 assume cs:_text$di
.text$di:00003AA4                 ;org 3AA4h
.text$di:00003AA4 ; COMDAT (pick any)
.text$di:00003AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$di:00003AA4
.text$di:00003AA4 ; =============== S U B R O U T I N E =======================================
.text$di:00003AA4
.text$di:00003AA4 ; Attributes: bp-based frame
.text$di:00003AA4
.text$di:00003AA4 ; void __cdecl std::`dynamic initializer for 'piecewise_construct''(void)
.text$di:00003AA4 ??__Epiecewise_construct@std@@YAXXZ proc near
.text$di:00003AA4                                         ; DATA XREF: .CRT$XCU:_piecewise_construct$initializer$o
.text$di:00003AA4
.text$di:00003AA4 var_1           = byte ptr -1
.text$di:00003AA4
.text$di:00003AA4                 push    ebp
.text$di:00003AA5                 mov     ebp, esp
.text$di:00003AA7                 push    ecx
.text$di:00003AA8                 xor     eax, eax
.text$di:00003AAA                 mov     [ebp+var_1], al
.text$di:00003AAD                 mov     esp, ebp
.text$di:00003AAF                 pop     ebp
.text$di:00003AB0                 retn
.text$di:00003AB0 ??__Epiecewise_construct@std@@YAXXZ endp
.text$di:00003AB0
.text$di:00003AB0 ; ---------------------------------------------------------------------------
.text$di:00003AB1                 align 4
.text$di:00003AB1 _text$di        ends
.text$di:00003AB1
.text$yd:00003AB4 ; ===========================================================================
.text$yd:00003AB4
.text$yd:00003AB4 ; Segment type: Pure code
.text$yd:00003AB4 ; Segment permissions: Read/Execute
.text$yd:00003AB4 _text$yd        segment para public 'CODE' use32
.text$yd:00003AB4                 assume cs:_text$yd
.text$yd:00003AB4                 ;org 3AB4h
.text$yd:00003AB4 ; COMDAT (pick any)
.text$yd:00003AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00003AB4
.text$yd:00003AB4 ; =============== S U B R O U T I N E =======================================
.text$yd:00003AB4
.text$yd:00003AB4 ; Attributes: bp-based frame
.text$yd:00003AB4
.text$yd:00003AB4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Generic_error_category std::_Error_objects<int>::_Generic_object''()
.text$yd:00003AB4 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ proc near
.text$yd:00003AB4                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+Do
.text$yd:00003AB4                 push    ebp
.text$yd:00003AB5                 mov     ebp, esp
.text$yd:00003AB7                 mov     ecx, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; this
.text$yd:00003ABC                 call    ??1_Generic_error_category@std@@UAE@XZ ; std::_Generic_error_category::~_Generic_error_category(void)
.text$yd:00003AC1                 pop     ebp
.text$yd:00003AC2                 retn
.text$yd:00003AC2 ??__F?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ endp
.text$yd:00003AC2
.text$yd:00003AC2 ; ---------------------------------------------------------------------------
.text$yd:00003AC3                 align 4
.text$yd:00003AC3 _text$yd        ends
.text$yd:00003AC3
.text$yd:00003AC4 ; ===========================================================================
.text$yd:00003AC4
.text$yd:00003AC4 ; Segment type: Pure code
.text$yd:00003AC4 ; Segment permissions: Read/Execute
.text$yd:00003AC4 _text$yd        segment para public 'CODE' use32
.text$yd:00003AC4                 assume cs:_text$yd
.text$yd:00003AC4                 ;org 3AC4h
.text$yd:00003AC4 ; COMDAT (pick any)
.text$yd:00003AC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00003AC4
.text$yd:00003AC4 ; =============== S U B R O U T I N E =======================================
.text$yd:00003AC4
.text$yd:00003AC4 ; Attributes: bp-based frame
.text$yd:00003AC4
.text$yd:00003AC4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''()
.text$yd:00003AC4 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ proc near
.text$yd:00003AC4                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+Do
.text$yd:00003AC4                 push    ebp
.text$yd:00003AC5                 mov     ebp, esp
.text$yd:00003AC7                 mov     ecx, offset ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A ; this
.text$yd:00003ACC                 call    ??1_Iostream_error_category@std@@UAE@XZ ; std::_Iostream_error_category::~_Iostream_error_category(void)
.text$yd:00003AD1                 pop     ebp
.text$yd:00003AD2                 retn
.text$yd:00003AD2 ??__F?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ endp
.text$yd:00003AD2
.text$yd:00003AD2 ; ---------------------------------------------------------------------------
.text$yd:00003AD3                 align 4
.text$yd:00003AD3 _text$yd        ends
.text$yd:00003AD3
.text$yd:00003AD4 ; ===========================================================================
.text$yd:00003AD4
.text$yd:00003AD4 ; Segment type: Pure code
.text$yd:00003AD4 ; Segment permissions: Read/Execute
.text$yd:00003AD4 _text$yd        segment para public 'CODE' use32
.text$yd:00003AD4                 assume cs:_text$yd
.text$yd:00003AD4                 ;org 3AD4h
.text$yd:00003AD4 ; COMDAT (pick any)
.text$yd:00003AD4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$yd:00003AD4
.text$yd:00003AD4 ; =============== S U B R O U T I N E =======================================
.text$yd:00003AD4
.text$yd:00003AD4 ; Attributes: bp-based frame
.text$yd:00003AD4
.text$yd:00003AD4 ; void __cdecl `dynamic atexit destructor for 'public: static std::_System_error_category std::_Error_objects<int>::_System_object''()
.text$yd:00003AD4 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ proc near
.text$yd:00003AD4                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+Do
.text$yd:00003AD4                 push    ebp
.text$yd:00003AD5                 mov     ebp, esp
.text$yd:00003AD7                 mov     ecx, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; this
.text$yd:00003ADC                 call    ??1_System_error_category@std@@UAE@XZ ; std::_System_error_category::~_System_error_category(void)
.text$yd:00003AE1                 pop     ebp
.text$yd:00003AE2                 retn
.text$yd:00003AE2 ??__F?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ endp
.text$yd:00003AE2
.text$yd:00003AE2 ; ---------------------------------------------------------------------------
.text$yd:00003AE3                 align 4
.text$yd:00003AE3 _text$yd        ends
.text$yd:00003AE3
.text$mn:00003AE4 ; ===========================================================================
.text$mn:00003AE4
.text$mn:00003AE4 ; Segment type: Pure code
.text$mn:00003AE4 ; Segment permissions: Read/Execute
.text$mn:00003AE4 _text$mn        segment para public 'CODE' use32
.text$mn:00003AE4                 assume cs:_text$mn
.text$mn:00003AE4                 ;org 3AE4h
.text$mn:00003AE4 ; COMDAT (pick any)
.text$mn:00003AE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003AE4
.text$mn:00003AE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003AE4
.text$mn:00003AE4 ; Attributes: bp-based frame
.text$mn:00003AE4
.text$mn:00003AE4 ; void __thiscall Gripper::CalcRectToScreen(Gripper *this, HWND, struct tagRECT *)
.text$mn:00003AE4                 public ?CalcRectToScreen@Gripper@@IAEXPAUHWND__@@PAUtagRECT@@@Z
.text$mn:00003AE4 ?CalcRectToScreen@Gripper@@IAEXPAUHWND__@@PAUtagRECT@@@Z proc near
.text$mn:00003AE4                                         ; CODE XREF: Gripper::onButtonUp(void)+10Ep
.text$mn:00003AE4                                         ; Gripper::onButtonUp(void)+121p ...
.text$mn:00003AE4
.text$mn:00003AE4 var_4           = dword ptr -4
.text$mn:00003AE4 arg_0           = dword ptr  8
.text$mn:00003AE4 arg_4           = dword ptr  0Ch
.text$mn:00003AE4
.text$mn:00003AE4                 push    ebp
.text$mn:00003AE5                 mov     ebp, esp
.text$mn:00003AE7                 push    ecx
.text$mn:00003AE8                 mov     [ebp+var_4], ecx
.text$mn:00003AEB                 mov     eax, [ebp+arg_4]
.text$mn:00003AEE                 push    eax             ; struct tagRECT *
.text$mn:00003AEF                 mov     ecx, [ebp+arg_0]
.text$mn:00003AF2                 push    ecx             ; HWND
.text$mn:00003AF3                 call    ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z ; ClientRectToScreenRect(HWND__ *,tagRECT *)
.text$mn:00003AF8                 add     esp, 8
.text$mn:00003AFB                 mov     edx, [ebp+arg_4]
.text$mn:00003AFE                 push    edx             ; struct tagRECT *
.text$mn:00003AFF                 mov     ecx, [ebp+var_4] ; this
.text$mn:00003B02                 call    ?ShrinkRcToSize@Gripper@@IAEXPAUtagRECT@@@Z ; Gripper::ShrinkRcToSize(tagRECT *)
.text$mn:00003B07                 mov     esp, ebp
.text$mn:00003B09                 pop     ebp
.text$mn:00003B0A                 retn    8
.text$mn:00003B0A ?CalcRectToScreen@Gripper@@IAEXPAUHWND__@@PAUtagRECT@@@Z endp
.text$mn:00003B0A
.text$mn:00003B0A ; ---------------------------------------------------------------------------
.text$mn:00003B0D                 align 10h
.text$mn:00003B0D _text$mn        ends
.text$mn:00003B0D
.text$mn:00003B10 ; ===========================================================================
.text$mn:00003B10
.text$mn:00003B10 ; Segment type: Pure code
.text$mn:00003B10 ; Segment permissions: Read/Execute
.text$mn:00003B10 _text$mn        segment para public 'CODE' use32
.text$mn:00003B10                 assume cs:_text$mn
.text$mn:00003B10                 ;org 3B10h
.text$mn:00003B10 ; COMDAT (pick any)
.text$mn:00003B10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B10
.text$mn:00003B10 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B10
.text$mn:00003B10 ; Attributes: bp-based frame
.text$mn:00003B10
.text$mn:00003B10 ; void __thiscall Gripper::DoCalcGripperRect(Gripper *this, struct tagRECT *, struct tagRECT, struct tagPOINT)
.text$mn:00003B10                 public ?DoCalcGripperRect@Gripper@@IAEXPAUtagRECT@@U2@UtagPOINT@@@Z
.text$mn:00003B10 ?DoCalcGripperRect@Gripper@@IAEXPAUtagRECT@@U2@UtagPOINT@@@Z proc near
.text$mn:00003B10                                         ; CODE XREF: Gripper::onButtonUp(void)+169p
.text$mn:00003B10                                         ; Gripper::getMovingRect(tagPOINT,tagRECT *)+F0p ...
.text$mn:00003B10
.text$mn:00003B10 var_4           = dword ptr -4
.text$mn:00003B10 arg_0           = dword ptr  8
.text$mn:00003B10 arg_10          = dword ptr  18h
.text$mn:00003B10 arg_14          = tagPOINT ptr  1Ch
.text$mn:00003B10
.text$mn:00003B10                 push    ebp
.text$mn:00003B11                 mov     ebp, esp
.text$mn:00003B13                 push    ecx
.text$mn:00003B14                 mov     [ebp+var_4], ecx
.text$mn:00003B17                 mov     eax, [ebp+arg_0]
.text$mn:00003B1A                 mov     ecx, [eax]
.text$mn:00003B1C                 mov     edx, [ebp+arg_0]
.text$mn:00003B1F                 add     ecx, [edx+8]
.text$mn:00003B22                 cmp     ecx, [ebp+arg_14.x]
.text$mn:00003B25                 jge     short loc_3B32
.text$mn:00003B27                 mov     eax, [ebp+arg_14.x]
.text$mn:00003B2A                 sub     eax, 14h
.text$mn:00003B2D                 mov     ecx, [ebp+arg_0]
.text$mn:00003B30                 mov     [ecx], eax
.text$mn:00003B32
.text$mn:00003B32 loc_3B32:                               ; CODE XREF: Gripper::DoCalcGripperRect(tagRECT *,tagRECT,tagPOINT)+15j
.text$mn:00003B32                 mov     edx, [ebp+arg_0]
.text$mn:00003B35                 mov     eax, [edx+4]
.text$mn:00003B38                 mov     ecx, [ebp+arg_0]
.text$mn:00003B3B                 add     eax, [ecx+0Ch]
.text$mn:00003B3E                 cmp     eax, [ebp+arg_14.y]
.text$mn:00003B41                 jge     short loc_3B58
.text$mn:00003B43                 mov     edx, [ebp+arg_0]
.text$mn:00003B46                 mov     eax, [ebp+arg_10]
.text$mn:00003B49                 sub     eax, [edx+0Ch]
.text$mn:00003B4C                 mov     ecx, [ebp+arg_0]
.text$mn:00003B4F                 add     eax, [ecx+4]
.text$mn:00003B52                 mov     edx, [ebp+arg_0]
.text$mn:00003B55                 mov     [edx+4], eax
.text$mn:00003B58
.text$mn:00003B58 loc_3B58:                               ; CODE XREF: Gripper::DoCalcGripperRect(tagRECT *,tagRECT,tagPOINT)+31j
.text$mn:00003B58                 mov     esp, ebp
.text$mn:00003B5A                 pop     ebp
.text$mn:00003B5B                 retn    1Ch
.text$mn:00003B5B ?DoCalcGripperRect@Gripper@@IAEXPAUtagRECT@@U2@UtagPOINT@@@Z endp
.text$mn:00003B5B
.text$mn:00003B5B ; ---------------------------------------------------------------------------
.text$mn:00003B5E                 align 10h
.text$mn:00003B5E _text$mn        ends
.text$mn:00003B5E
.text$mn:00003B60 ; ===========================================================================
.text$mn:00003B60
.text$mn:00003B60 ; Segment type: Pure code
.text$mn:00003B60 ; Segment permissions: Read/Execute
.text$mn:00003B60 _text$mn        segment para public 'CODE' use32
.text$mn:00003B60                 assume cs:_text$mn
.text$mn:00003B60                 ;org 3B60h
.text$mn:00003B60 ; COMDAT (pick any)
.text$mn:00003B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B60
.text$mn:00003B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B60
.text$mn:00003B60 ; Attributes: bp-based frame
.text$mn:00003B60
.text$mn:00003B60 ; void __thiscall Gripper::ShrinkRcToSize(Gripper *this, struct tagRECT *)
.text$mn:00003B60                 public ?ShrinkRcToSize@Gripper@@IAEXPAUtagRECT@@@Z
.text$mn:00003B60 ?ShrinkRcToSize@Gripper@@IAEXPAUtagRECT@@@Z proc near
.text$mn:00003B60                                         ; CODE XREF: Gripper::getMovingRect(tagPOINT,tagRECT *)+B4p
.text$mn:00003B60                                         ; Gripper::getMovingRect(tagPOINT,tagRECT *)+C0p ...
.text$mn:00003B60
.text$mn:00003B60 var_4           = dword ptr -4
.text$mn:00003B60 arg_0           = dword ptr  8
.text$mn:00003B60
.text$mn:00003B60                 push    ebp
.text$mn:00003B61                 mov     ebp, esp
.text$mn:00003B63                 push    ecx
.text$mn:00003B64                 mov     [ebp+var_4], ecx
.text$mn:00003B67                 mov     eax, [ebp+arg_0]
.text$mn:00003B6A                 mov     ecx, [ebp+arg_0]
.text$mn:00003B6D                 mov     edx, [eax+8]
.text$mn:00003B70                 sub     edx, [ecx]
.text$mn:00003B72                 mov     eax, [ebp+arg_0]
.text$mn:00003B75                 mov     [eax+8], edx
.text$mn:00003B78                 mov     ecx, [ebp+arg_0]
.text$mn:00003B7B                 mov     edx, [ebp+arg_0]
.text$mn:00003B7E                 mov     eax, [ecx+0Ch]
.text$mn:00003B81                 sub     eax, [edx+4]
.text$mn:00003B84                 mov     ecx, [ebp+arg_0]
.text$mn:00003B87                 mov     [ecx+0Ch], eax
.text$mn:00003B8A                 mov     esp, ebp
.text$mn:00003B8C                 pop     ebp
.text$mn:00003B8D                 retn    4
.text$mn:00003B8D ?ShrinkRcToSize@Gripper@@IAEXPAUtagRECT@@@Z endp
.text$mn:00003B8D
.text$mn:00003B8D _text$mn        ends
.text$mn:00003B8D
.text$mn:00003B90 ; ===========================================================================
.text$mn:00003B90
.text$mn:00003B90 ; Segment type: Pure code
.text$mn:00003B90 ; Segment permissions: Read/Execute
.text$mn:00003B90 _text$mn        segment para public 'CODE' use32
.text$mn:00003B90                 assume cs:_text$mn
.text$mn:00003B90                 ;org 3B90h
.text$mn:00003B90 ; COMDAT (pick any)
.text$mn:00003B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003B90
.text$mn:00003B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00003B90
.text$mn:00003B90 ; Attributes: bp-based frame
.text$mn:00003B90
.text$mn:00003B90 ; void __thiscall std::_Iterator_base12::_Adopt(std::_Iterator_base12 *this, const struct std::_Container_base12 *)
.text$mn:00003B90                 public ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00003B90 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$mn:00003B90                                         ; CODE XREF: std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(DockingCont * *,std::_Container_base12 const *)+45p
.text$mn:00003B90                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+49p
.text$mn:00003B90
.text$mn:00003B90 var_1C          = byte ptr -1Ch
.text$mn:00003B90 var_18          = byte ptr -18h
.text$mn:00003B90 var_14          = dword ptr -14h
.text$mn:00003B90 var_10          = dword ptr -10h
.text$mn:00003B90 var_C           = dword ptr -0Ch
.text$mn:00003B90 var_4           = dword ptr -4
.text$mn:00003B90 arg_0           = dword ptr  8
.text$mn:00003B90
.text$mn:00003B90                 push    ebp
.text$mn:00003B91                 mov     ebp, esp
.text$mn:00003B93                 push    0FFFFFFFFh
.text$mn:00003B95                 push    offset __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$mn:00003B9A                 mov     eax, large fs:0
.text$mn:00003BA0                 push    eax
.text$mn:00003BA1                 sub     esp, 10h
.text$mn:00003BA4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003BA9                 xor     eax, ebp
.text$mn:00003BAB                 push    eax
.text$mn:00003BAC                 lea     eax, [ebp+var_C]
.text$mn:00003BAF                 mov     large fs:0, eax
.text$mn:00003BB5                 mov     [ebp+var_10], ecx
.text$mn:00003BB8                 cmp     [ebp+arg_0], 0
.text$mn:00003BBC                 jnz     short loc_3BE8
.text$mn:00003BBE                 push    3               ; int
.text$mn:00003BC0                 lea     ecx, [ebp+var_18] ; this
.text$mn:00003BC3                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003BC8                 mov     [ebp+var_4], 0
.text$mn:00003BCF                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003BD2                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003BD7                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003BDE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00003BE1                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003BE6                 jmp     short loc_3C3F
.text$mn:00003BE8 ; ---------------------------------------------------------------------------
.text$mn:00003BE8
.text$mn:00003BE8 loc_3BE8:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+2Cj
.text$mn:00003BE8                 mov     eax, [ebp+arg_0]
.text$mn:00003BEB                 mov     ecx, [eax]
.text$mn:00003BED                 mov     [ebp+var_14], ecx
.text$mn:00003BF0                 mov     edx, [ebp+var_10]
.text$mn:00003BF3                 mov     eax, [edx]
.text$mn:00003BF5                 cmp     eax, [ebp+var_14]
.text$mn:00003BF8                 jz      short loc_3C3F
.text$mn:00003BFA                 push    3               ; int
.text$mn:00003BFC                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00003BFF                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00003C04                 mov     [ebp+var_4], 1
.text$mn:00003C0B                 mov     ecx, [ebp+var_10] ; this
.text$mn:00003C0E                 call    ?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me(void)
.text$mn:00003C13                 mov     ecx, [ebp+var_10]
.text$mn:00003C16                 mov     edx, [ebp+var_14]
.text$mn:00003C19                 mov     eax, [edx+4]
.text$mn:00003C1C                 mov     [ecx+4], eax
.text$mn:00003C1F                 mov     ecx, [ebp+var_14]
.text$mn:00003C22                 mov     edx, [ebp+var_10]
.text$mn:00003C25                 mov     [ecx+4], edx
.text$mn:00003C28                 mov     eax, [ebp+var_10]
.text$mn:00003C2B                 mov     ecx, [ebp+var_14]
.text$mn:00003C2E                 mov     [eax], ecx
.text$mn:00003C30                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003C37                 lea     ecx, [ebp+var_1C] ; this
.text$mn:00003C3A                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00003C3F
.text$mn:00003C3F loc_3C3F:                               ; CODE XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+56j
.text$mn:00003C3F                                         ; std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+68j
.text$mn:00003C3F                 mov     ecx, [ebp+var_C]
.text$mn:00003C42                 mov     large fs:0, ecx
.text$mn:00003C49                 pop     ecx
.text$mn:00003C4A                 mov     esp, ebp
.text$mn:00003C4C                 pop     ebp
.text$mn:00003C4D                 retn    4
.text$mn:00003C4D ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$mn:00003C4D
.text$mn:00003C4D _text$mn        ends
.text$mn:00003C4D
.text$x:00003C50 ; ===========================================================================
.text$x:00003C50
.text$x:00003C50 ; Segment type: Pure code
.text$x:00003C50 ; Segment permissions: Read/Execute
.text$x:00003C50 _text$x         segment para public 'CODE' use32
.text$x:00003C50                 assume cs:_text$x
.text$x:00003C50                 ;org 3C50h
.text$x:00003C50 ; COMDAT (pick associative to section at 3B90)
.text$x:00003C50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003C50
.text$x:00003C50 ; =============== S U B R O U T I N E =======================================
.text$x:00003C50
.text$x:00003C50
.text$x:00003C50 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 proc near
.text$x:00003C50                                         ; DATA XREF: .xdata$x:00005080o
.text$x:00003C50                 lea     ecx, [ebp-18h]  ; this
.text$x:00003C53                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003C53 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0 endp
.text$x:00003C53
.text$x:00003C58
.text$x:00003C58 ; =============== S U B R O U T I N E =======================================
.text$x:00003C58
.text$x:00003C58
.text$x:00003C58 __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 proc near
.text$x:00003C58                                         ; DATA XREF: .xdata$x:00005088o
.text$x:00003C58                 lea     ecx, [ebp-1Ch]  ; this
.text$x:00003C5B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:00003C5B __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1 endp
.text$x:00003C5B
.text$x:00003C60
.text$x:00003C60 ; =============== S U B R O U T I N E =======================================
.text$x:00003C60
.text$x:00003C60
.text$x:00003C60 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z proc near
.text$x:00003C60                                         ; DATA XREF: std::_Iterator_base12::_Adopt(std::_Container_base12 const *)+5o
.text$x:00003C60
.text$x:00003C60 arg_4           = dword ptr  8
.text$x:00003C60
.text$x:00003C60                 mov     edx, [esp+arg_4]
.text$x:00003C64                 lea     eax, [edx+0Ch]
.text$x:00003C67                 mov     ecx, [edx-14h]
.text$x:00003C6A                 xor     ecx, eax
.text$x:00003C6C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003C71                 mov     eax, offset __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.text$x:00003C76                 jmp     ___CxxFrameHandler3
.text$x:00003C76 __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z endp
.text$x:00003C76
.text$x:00003C76 ; ---------------------------------------------------------------------------
.text$x:00003C7B                 align 4
.text$x:00003C7B _text$x         ends
.text$x:00003C7B
.text$mn:00003C7C ; ===========================================================================
.text$mn:00003C7C
.text$mn:00003C7C ; Segment type: Pure code
.text$mn:00003C7C ; Segment permissions: Read/Execute
.text$mn:00003C7C _text$mn        segment para public 'CODE' use32
.text$mn:00003C7C                 assume cs:_text$mn
.text$mn:00003C7C                 ;org 3C7Ch
.text$mn:00003C7C ; COMDAT (pick any)
.text$mn:00003C7C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003C7C
.text$mn:00003C7C ; =============== S U B R O U T I N E =======================================
.text$mn:00003C7C
.text$mn:00003C7C ; Attributes: bp-based frame
.text$mn:00003C7C
.text$mn:00003C7C ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Alloc_proxy(void)
.text$mn:00003C7C                 public ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00003C7C ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003C7C                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(std::allocator<char> const &)+38p
.text$mn:00003C7C
.text$mn:00003C7C var_10          = byte ptr -10h
.text$mn:00003C7C var_8           = dword ptr -8
.text$mn:00003C7C var_1           = byte ptr -1
.text$mn:00003C7C
.text$mn:00003C7C                 push    ebp
.text$mn:00003C7D                 mov     ebp, esp
.text$mn:00003C7F                 sub     esp, 10h
.text$mn:00003C82                 mov     [ebp+var_8], ecx
.text$mn:00003C85                 lea     ecx, [ebp+var_1]
.text$mn:00003C88                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003C8D                 push    1
.text$mn:00003C8F                 lea     ecx, [ebp+var_1]
.text$mn:00003C92                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:00003C97                 mov     ecx, [ebp+var_8]
.text$mn:00003C9A                 mov     [ecx], eax
.text$mn:00003C9C                 lea     ecx, [ebp+var_10] ; this
.text$mn:00003C9F                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003CA4                 push    eax             ; int
.text$mn:00003CA5                 mov     edx, [ebp+var_8]
.text$mn:00003CA8                 mov     eax, [edx]
.text$mn:00003CAA                 push    eax             ; void *
.text$mn:00003CAB                 lea     ecx, [ebp+var_1]
.text$mn:00003CAE                 call    ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003CB3                 mov     ecx, [ebp+var_8]
.text$mn:00003CB6                 mov     edx, [ecx]
.text$mn:00003CB8                 mov     eax, [ebp+var_8]
.text$mn:00003CBB                 mov     [edx], eax
.text$mn:00003CBD                 mov     esp, ebp
.text$mn:00003CBF                 pop     ebp
.text$mn:00003CC0                 retn
.text$mn:00003CC0 ?_Alloc_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003CC0
.text$mn:00003CC0 ; ---------------------------------------------------------------------------
.text$mn:00003CC1                 align 4
.text$mn:00003CC1 _text$mn        ends
.text$mn:00003CC1
.text$mn:00003CC4 ; ===========================================================================
.text$mn:00003CC4
.text$mn:00003CC4 ; Segment type: Pure code
.text$mn:00003CC4 ; Segment permissions: Read/Execute
.text$mn:00003CC4 _text$mn        segment para public 'CODE' use32
.text$mn:00003CC4                 assume cs:_text$mn
.text$mn:00003CC4                 ;org 3CC4h
.text$mn:00003CC4 ; COMDAT (pick any)
.text$mn:00003CC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003CC4
.text$mn:00003CC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00003CC4
.text$mn:00003CC4 ; Attributes: bp-based frame
.text$mn:00003CC4
.text$mn:00003CC4 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Alloc_proxy(void)
.text$mn:00003CC4                 public ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ
.text$mn:00003CC4 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003CC4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(std::allocator<DockingCont *> const &)+38p
.text$mn:00003CC4
.text$mn:00003CC4 var_10          = byte ptr -10h
.text$mn:00003CC4 var_8           = dword ptr -8
.text$mn:00003CC4 var_1           = byte ptr -1
.text$mn:00003CC4
.text$mn:00003CC4                 push    ebp
.text$mn:00003CC5                 mov     ebp, esp
.text$mn:00003CC7                 sub     esp, 10h
.text$mn:00003CCA                 mov     [ebp+var_8], ecx
.text$mn:00003CCD                 lea     ecx, [ebp+var_1]
.text$mn:00003CD0                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00003CD5                 push    1
.text$mn:00003CD7                 lea     ecx, [ebp+var_1]
.text$mn:00003CDA                 call    ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)
.text$mn:00003CDF                 mov     ecx, [ebp+var_8]
.text$mn:00003CE2                 mov     [ecx], eax
.text$mn:00003CE4                 lea     ecx, [ebp+var_10] ; this
.text$mn:00003CE7                 call    ??0_Container_proxy@std@@QAE@XZ ; std::_Container_proxy::_Container_proxy(void)
.text$mn:00003CEC                 push    eax             ; int
.text$mn:00003CED                 mov     edx, [ebp+var_8]
.text$mn:00003CF0                 mov     eax, [edx]
.text$mn:00003CF2                 push    eax             ; void *
.text$mn:00003CF3                 lea     ecx, [ebp+var_1]
.text$mn:00003CF6                 call    ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::construct<std::_Container_proxy,std::_Container_proxy>(std::_Container_proxy *,std::_Container_proxy &&)
.text$mn:00003CFB                 mov     ecx, [ebp+var_8]
.text$mn:00003CFE                 mov     edx, [ecx]
.text$mn:00003D00                 mov     eax, [ebp+var_8]
.text$mn:00003D03                 mov     [edx], eax
.text$mn:00003D05                 mov     esp, ebp
.text$mn:00003D07                 pop     ebp
.text$mn:00003D08                 retn
.text$mn:00003D08 ?_Alloc_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00003D08
.text$mn:00003D08 ; ---------------------------------------------------------------------------
.text$mn:00003D09                 align 4
.text$mn:00003D09 _text$mn        ends
.text$mn:00003D09
.text$mn:00003D0C ; ===========================================================================
.text$mn:00003D0C
.text$mn:00003D0C ; Segment type: Pure code
.text$mn:00003D0C ; Segment permissions: Read/Execute
.text$mn:00003D0C _text$mn        segment para public 'CODE' use32
.text$mn:00003D0C                 assume cs:_text$mn
.text$mn:00003D0C                 ;org 3D0Ch
.text$mn:00003D0C ; COMDAT (pick any)
.text$mn:00003D0C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D0C
.text$mn:00003D0C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D0C
.text$mn:00003D0C ; Attributes: bp-based frame
.text$mn:00003D0C
.text$mn:00003D0C ; protected: bool __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Buy(unsigned int)
.text$mn:00003D0C                 public ?_Buy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAE_NI@Z
.text$mn:00003D0C ?_Buy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAE_NI@Z proc near
.text$mn:00003D0C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+62p
.text$mn:00003D0C
.text$mn:00003D0C var_8           = dword ptr -8
.text$mn:00003D0C var_1           = byte ptr -1
.text$mn:00003D0C arg_0           = dword ptr  8
.text$mn:00003D0C
.text$mn:00003D0C                 push    ebp
.text$mn:00003D0D                 mov     ebp, esp
.text$mn:00003D0F                 sub     esp, 8
.text$mn:00003D12                 mov     [ebp+var_8], ecx
.text$mn:00003D15                 mov     eax, [ebp+var_8]
.text$mn:00003D18                 mov     dword ptr [eax+4], 0
.text$mn:00003D1F                 mov     ecx, [ebp+var_8]
.text$mn:00003D22                 mov     dword ptr [ecx+8], 0
.text$mn:00003D29                 mov     edx, [ebp+var_8]
.text$mn:00003D2C                 mov     dword ptr [edx+0Ch], 0
.text$mn:00003D33                 cmp     [ebp+arg_0], 0
.text$mn:00003D37                 jnz     short loc_3D3F
.text$mn:00003D39                 xor     al, al
.text$mn:00003D3B                 jmp     short loc_3D93
.text$mn:00003D3D ; ---------------------------------------------------------------------------
.text$mn:00003D3D                 jmp     short loc_3D91
.text$mn:00003D3F ; ---------------------------------------------------------------------------
.text$mn:00003D3F
.text$mn:00003D3F loc_3D3F:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+2Bj
.text$mn:00003D3F                 mov     ecx, [ebp+var_8]
.text$mn:00003D42                 call    ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::max_size(void)
.text$mn:00003D47                 cmp     eax, [ebp+arg_0]
.text$mn:00003D4A                 jnb     short loc_3D56
.text$mn:00003D4C                 mov     ecx, [ebp+var_8]
.text$mn:00003D4F                 call    ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Xlen(void)
.text$mn:00003D54                 jmp     short loc_3D91
.text$mn:00003D56 ; ---------------------------------------------------------------------------
.text$mn:00003D56
.text$mn:00003D56 loc_3D56:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+3Ej
.text$mn:00003D56                 mov     eax, [ebp+arg_0]
.text$mn:00003D59                 push    eax
.text$mn:00003D5A                 lea     ecx, [ebp+var_1]
.text$mn:00003D5D                 push    ecx
.text$mn:00003D5E                 mov     ecx, [ebp+var_8]
.text$mn:00003D61                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00003D66                 mov     ecx, eax
.text$mn:00003D68                 call    ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::allocate(uint)
.text$mn:00003D6D                 mov     edx, [ebp+var_8]
.text$mn:00003D70                 mov     [edx+4], eax
.text$mn:00003D73                 mov     eax, [ebp+var_8]
.text$mn:00003D76                 mov     ecx, [ebp+var_8]
.text$mn:00003D79                 mov     edx, [ecx+4]
.text$mn:00003D7C                 mov     [eax+8], edx
.text$mn:00003D7F                 mov     eax, [ebp+var_8]
.text$mn:00003D82                 mov     ecx, [eax+4]
.text$mn:00003D85                 mov     edx, [ebp+arg_0]
.text$mn:00003D88                 lea     eax, [ecx+edx*4]
.text$mn:00003D8B                 mov     ecx, [ebp+var_8]
.text$mn:00003D8E                 mov     [ecx+0Ch], eax
.text$mn:00003D91
.text$mn:00003D91 loc_3D91:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+31j
.text$mn:00003D91                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+48j
.text$mn:00003D91                 mov     al, 1
.text$mn:00003D93
.text$mn:00003D93 loc_3D93:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+2Fj
.text$mn:00003D93                 mov     esp, ebp
.text$mn:00003D95                 pop     ebp
.text$mn:00003D96                 retn    4
.text$mn:00003D96 ?_Buy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAE_NI@Z endp
.text$mn:00003D96
.text$mn:00003D96 ; ---------------------------------------------------------------------------
.text$mn:00003D99                 align 4
.text$mn:00003D99 _text$mn        ends
.text$mn:00003D99
.text$mn:00003D9C ; ===========================================================================
.text$mn:00003D9C
.text$mn:00003D9C ; Segment type: Pure code
.text$mn:00003D9C ; Segment permissions: Read/Execute
.text$mn:00003D9C _text$mn        segment para public 'CODE' use32
.text$mn:00003D9C                 assume cs:_text$mn
.text$mn:00003D9C                 ;org 3D9Ch
.text$mn:00003D9C ; COMDAT (pick any)
.text$mn:00003D9C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003D9C
.text$mn:00003D9C ; =============== S U B R O U T I N E =======================================
.text$mn:00003D9C
.text$mn:00003D9C ; Attributes: bp-based frame
.text$mn:00003D9C
.text$mn:00003D9C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Copy(unsigned int, unsigned int)
.text$mn:00003D9C                 public ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003D9C ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$mn:00003D9C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+37p
.text$mn:00003D9C
.text$mn:00003D9C var_20          = dword ptr -20h
.text$mn:00003D9C var_1C          = dword ptr -1Ch
.text$mn:00003D9C var_18          = dword ptr -18h
.text$mn:00003D9C var_11          = byte ptr -11h
.text$mn:00003D9C var_10          = dword ptr -10h
.text$mn:00003D9C var_C           = byte ptr -0Ch
.text$mn:00003D9C var_4           = dword ptr -4
.text$mn:00003D9C arg_0           = dword ptr  8
.text$mn:00003D9C
.text$mn:00003D9C ; FUNCTION CHUNK AT .text$mn:00003EBE SIZE 00000009 BYTES
.text$mn:00003D9C
.text$mn:00003D9C                 push    ebp
.text$mn:00003D9D                 mov     ebp, esp
.text$mn:00003D9F                 push    0FFFFFFFFh
.text$mn:00003DA1                 push    offset __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003DA6                 mov     eax, large fs:0
.text$mn:00003DAC                 push    eax
.text$mn:00003DAD                 push    ecx
.text$mn:00003DAE                 sub     esp, 10h
.text$mn:00003DB1                 push    ebx
.text$mn:00003DB2                 push    esi
.text$mn:00003DB3                 push    edi
.text$mn:00003DB4                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00003DB9                 xor     eax, ebp
.text$mn:00003DBB                 push    eax
.text$mn:00003DBC                 lea     eax, [ebp+var_C]
.text$mn:00003DBF                 mov     large fs:0, eax
.text$mn:00003DC5                 mov     [ebp+var_10], esp
.text$mn:00003DC8                 mov     [ebp+var_18], ecx
.text$mn:00003DCB                 mov     eax, [ebp+arg_0]
.text$mn:00003DCE                 or      eax, 0Fh
.text$mn:00003DD1                 mov     [ebp+var_1C], eax
.text$mn:00003DD4                 mov     ecx, [ebp+var_18]
.text$mn:00003DD7                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003DDC                 cmp     eax, [ebp+var_1C]
.text$mn:00003DDF                 jnb     short loc_3DE9
.text$mn:00003DE1                 mov     ecx, [ebp+arg_0]
.text$mn:00003DE4                 mov     [ebp+var_1C], ecx
.text$mn:00003DE7                 jmp     short loc_3E3B
.text$mn:00003DE9 ; ---------------------------------------------------------------------------
.text$mn:00003DE9
.text$mn:00003DE9 loc_3DE9:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+43j
.text$mn:00003DE9                 mov     edx, [ebp+var_18]
.text$mn:00003DEC                 mov     ecx, [edx+18h]
.text$mn:00003DEF                 shr     ecx, 1
.text$mn:00003DF1                 mov     eax, [ebp+var_1C]
.text$mn:00003DF4                 xor     edx, edx
.text$mn:00003DF6                 mov     esi, 3
.text$mn:00003DFB                 div     esi
.text$mn:00003DFD                 cmp     ecx, eax
.text$mn:00003DFF                 ja      short loc_3E03
.text$mn:00003E01                 jmp     short loc_3E3B
.text$mn:00003E03 ; ---------------------------------------------------------------------------
.text$mn:00003E03
.text$mn:00003E03 loc_3E03:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+63j
.text$mn:00003E03                 mov     ecx, [ebp+var_18]
.text$mn:00003E06                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003E0B                 mov     edx, [ebp+var_18]
.text$mn:00003E0E                 mov     ecx, [edx+18h]
.text$mn:00003E11                 shr     ecx, 1
.text$mn:00003E13                 sub     eax, ecx
.text$mn:00003E15                 mov     edx, [ebp+var_18]
.text$mn:00003E18                 cmp     [edx+18h], eax
.text$mn:00003E1B                 ja      short loc_3E30
.text$mn:00003E1D                 mov     eax, [ebp+var_18]
.text$mn:00003E20                 mov     ecx, [eax+18h]
.text$mn:00003E23                 shr     ecx, 1
.text$mn:00003E25                 mov     edx, [ebp+var_18]
.text$mn:00003E28                 add     ecx, [edx+18h]
.text$mn:00003E2B                 mov     [ebp+var_1C], ecx
.text$mn:00003E2E                 jmp     short loc_3E3B
.text$mn:00003E30 ; ---------------------------------------------------------------------------
.text$mn:00003E30
.text$mn:00003E30 loc_3E30:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+7Fj
.text$mn:00003E30                 mov     ecx, [ebp+var_18]
.text$mn:00003E33                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00003E38                 mov     [ebp+var_1C], eax
.text$mn:00003E3B
.text$mn:00003E3B loc_3E3B:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+4Bj
.text$mn:00003E3B                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+65j ...
.text$mn:00003E3B                 mov     [ebp+var_4], 0
.text$mn:00003E42                 mov     eax, [ebp+var_1C]
.text$mn:00003E45                 add     eax, 1
.text$mn:00003E48                 push    eax
.text$mn:00003E49                 lea     ecx, [ebp+var_11]
.text$mn:00003E4C                 push    ecx
.text$mn:00003E4D                 mov     ecx, [ebp+var_18]
.text$mn:00003E50                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003E55                 mov     ecx, eax
.text$mn:00003E57                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003E5C                 mov     [ebp+var_20], eax
.text$mn:00003E5F                 jmp     short loc_3EBE
.text$mn:00003E5F ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$mn:00003E5F
.text$mn:00003E61
.text$mn:00003E61 ; =============== S U B R O U T I N E =======================================
.text$mn:00003E61
.text$mn:00003E61
.text$mn:00003E61 __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 proc near
.text$mn:00003E61                                         ; DATA XREF: .xdata$x:000051C4o
.text$mn:00003E61
.text$mn:00003E61 ; FUNCTION CHUNK AT .text$mn:00003EA8 SIZE 00000009 BYTES
.text$mn:00003E61 ; FUNCTION CHUNK AT .text$mn:00003EB8 SIZE 00000006 BYTES
.text$mn:00003E61
.text$mn:00003E61                 mov     [ebp-10h], esp
.text$mn:00003E64                 mov     edx, [ebp+8]
.text$mn:00003E67                 mov     [ebp-1Ch], edx
.text$mn:00003E6A                 mov     byte ptr [ebp-4], 2
.text$mn:00003E6E                 mov     eax, [ebp-1Ch]
.text$mn:00003E71                 add     eax, 1
.text$mn:00003E74                 push    eax
.text$mn:00003E75                 lea     ecx, [ebp-12h]
.text$mn:00003E78                 push    ecx
.text$mn:00003E79                 mov     ecx, [ebp-18h]
.text$mn:00003E7C                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003E81                 mov     ecx, eax
.text$mn:00003E83                 call    ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::allocate(uint)
.text$mn:00003E88                 mov     [ebp-20h], eax
.text$mn:00003E8B                 jmp     short loc_3EA8
.text$mn:00003E8B __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0 endp
.text$mn:00003E8B
.text$mn:00003E8D
.text$mn:00003E8D ; =============== S U B R O U T I N E =======================================
.text$mn:00003E8D
.text$mn:00003E8D ; Attributes: noreturn
.text$mn:00003E8D
.text$mn:00003E8D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 proc near
.text$mn:00003E8D                                         ; DATA XREF: .xdata$x:000051D4o
.text$mn:00003E8D                 push    0               ; Size
.text$mn:00003E8F                 push    1               ; char
.text$mn:00003E91                 mov     ecx, [ebp-18h]
.text$mn:00003E94                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003E99                 push    0
.text$mn:00003E9B                 push    0
.text$mn:00003E9D                 call    __CxxThrowException@8 ; _CxxThrowException(x,x)
.text$mn:00003E9D __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1 endp
.text$mn:00003E9D
.text$mn:00003EA2 ; ---------------------------------------------------------------------------
.text$mn:00003EA2                 mov     eax, offset $LN17
.text$mn:00003EA7                 retn
.text$mn:00003EA8 ; ---------------------------------------------------------------------------
.text$mn:00003EA8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003EA8
.text$mn:00003EA8 loc_3EA8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+2Aj
.text$mn:00003EA8                 mov     dword ptr [ebp-4], 1
.text$mn:00003EAF                 jmp     short loc_3EB8
.text$mn:00003EAF ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003EB1
.text$mn:00003EB1 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EB1
.text$mn:00003EB1
.text$mn:00003EB1 $LN17           proc near               ; DATA XREF: .text$mn:00003EA2o
.text$mn:00003EB1                 mov     dword ptr [ebp-4], 1
.text$mn:00003EB1 $LN17           endp ; sp-analysis failed
.text$mn:00003EB1
.text$mn:00003EB8 ; START OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003EB8
.text$mn:00003EB8 loc_3EB8:                               ; CODE XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+4Ej
.text$mn:00003EB8                 mov     eax, offset $LN19
.text$mn:00003EBD                 retn
.text$mn:00003EBD ; END OF FUNCTION CHUNK FOR __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.text$mn:00003EBE ; ---------------------------------------------------------------------------
.text$mn:00003EBE ; START OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003EBE
.text$mn:00003EBE loc_3EBE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+C3j
.text$mn:00003EBE                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:00003EC5                 jmp     short loc_3ECE
.text$mn:00003EC5 ; END OF FUNCTION CHUNK FOR ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$mn:00003EC7
.text$mn:00003EC7 ; =============== S U B R O U T I N E =======================================
.text$mn:00003EC7
.text$mn:00003EC7
.text$mn:00003EC7 $LN19           proc near               ; DATA XREF: __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:loc_3EB8o
.text$mn:00003EC7                 mov     dword ptr [ebp-4], 0FFFFFFFFh
.text$mn:00003ECE
.text$mn:00003ECE loc_3ECE:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+129j
.text$mn:00003ECE                 cmp     dword ptr [ebp+0Ch], 0
.text$mn:00003ED2                 jbe     short loc_3EED
.text$mn:00003ED4                 mov     edx, [ebp+0Ch]
.text$mn:00003ED7                 push    edx             ; Size
.text$mn:00003ED8                 mov     ecx, [ebp-18h]
.text$mn:00003EDB                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003EE0                 push    eax             ; Src
.text$mn:00003EE1                 mov     eax, [ebp-20h]
.text$mn:00003EE4                 push    eax             ; Dst
.text$mn:00003EE5                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00003EEA                 add     esp, 0Ch
.text$mn:00003EED
.text$mn:00003EED loc_3EED:                               ; CODE XREF: $LN19+Bj
.text$mn:00003EED                 push    0               ; Size
.text$mn:00003EEF                 push    1               ; char
.text$mn:00003EF1                 mov     ecx, [ebp-18h]
.text$mn:00003EF4                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:00003EF9                 lea     ecx, [ebp-20h]
.text$mn:00003EFC                 push    ecx             ; int
.text$mn:00003EFD                 mov     edx, [ebp-18h]
.text$mn:00003F00                 add     edx, 4
.text$mn:00003F03                 push    edx             ; void *
.text$mn:00003F04                 lea     eax, [ebp-13h]
.text$mn:00003F07                 push    eax
.text$mn:00003F08                 mov     ecx, [ebp-18h]
.text$mn:00003F0B                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00003F10                 mov     ecx, eax
.text$mn:00003F12                 call    ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::construct<char *,char * &>(char * *,char * &)
.text$mn:00003F17                 mov     ecx, [ebp-18h]
.text$mn:00003F1A                 mov     edx, [ebp-1Ch]
.text$mn:00003F1D                 mov     [ecx+18h], edx
.text$mn:00003F20                 mov     eax, [ebp+0Ch]
.text$mn:00003F23                 push    eax
.text$mn:00003F24                 mov     ecx, [ebp-18h]
.text$mn:00003F27                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00003F2C                 mov     ecx, [ebp-0Ch]
.text$mn:00003F2F                 mov     large fs:0, ecx
.text$mn:00003F36                 pop     ecx
.text$mn:00003F37                 pop     edi
.text$mn:00003F38                 pop     esi
.text$mn:00003F39                 pop     ebx
.text$mn:00003F3A                 mov     esp, ebp
.text$mn:00003F3C                 pop     ebp
.text$mn:00003F3D                 retn    8
.text$mn:00003F3D $LN19           endp ; sp-analysis failed
.text$mn:00003F3D
.text$mn:00003F3D _text$mn        ends
.text$mn:00003F3D
.text$x:00003F40 ; ===========================================================================
.text$x:00003F40
.text$x:00003F40 ; Segment type: Pure code
.text$x:00003F40 ; Segment permissions: Read/Execute
.text$x:00003F40 _text$x         segment para public 'CODE' use32
.text$x:00003F40                 assume cs:_text$x
.text$x:00003F40                 ;org 3F40h
.text$x:00003F40 ; COMDAT (pick associative to section at 3D9C)
.text$x:00003F40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00003F40
.text$x:00003F40 ; =============== S U B R O U T I N E =======================================
.text$x:00003F40
.text$x:00003F40
.text$x:00003F40 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z proc near
.text$x:00003F40                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+5o
.text$x:00003F40
.text$x:00003F40 arg_4           = dword ptr  8
.text$x:00003F40
.text$x:00003F40                 mov     edx, [esp+arg_4]
.text$x:00003F44                 lea     eax, [edx+0Ch]
.text$x:00003F47                 mov     ecx, [edx-24h]
.text$x:00003F4A                 xor     ecx, eax
.text$x:00003F4C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00003F51                 mov     eax, offset __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.text$x:00003F56                 jmp     ___CxxFrameHandler3
.text$x:00003F56 __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z endp
.text$x:00003F56
.text$x:00003F56 ; ---------------------------------------------------------------------------
.text$x:00003F5B                 align 4
.text$x:00003F5B _text$x         ends
.text$x:00003F5B
.text$mn:00003F5C ; ===========================================================================
.text$mn:00003F5C
.text$mn:00003F5C ; Segment type: Pure code
.text$mn:00003F5C ; Segment permissions: Read/Execute
.text$mn:00003F5C _text$mn        segment para public 'CODE' use32
.text$mn:00003F5C                 assume cs:_text$mn
.text$mn:00003F5C                 ;org 3F5Ch
.text$mn:00003F5C ; COMDAT (pick any)
.text$mn:00003F5C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F5C
.text$mn:00003F5C ; =============== S U B R O U T I N E =======================================
.text$mn:00003F5C
.text$mn:00003F5C ; Attributes: bp-based frame
.text$mn:00003F5C
.text$mn:00003F5C ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Destroy(class DockingCont * *, class DockingCont * *)
.text$mn:00003F5C                 public ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z
.text$mn:00003F5C ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z proc near
.text$mn:00003F5C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)+2Bp
.text$mn:00003F5C
.text$mn:00003F5C var_8           = dword ptr -8
.text$mn:00003F5C var_1           = byte ptr -1
.text$mn:00003F5C arg_0           = dword ptr  8
.text$mn:00003F5C arg_4           = dword ptr  0Ch
.text$mn:00003F5C
.text$mn:00003F5C                 push    ebp
.text$mn:00003F5D                 mov     ebp, esp
.text$mn:00003F5F                 sub     esp, 8
.text$mn:00003F62                 mov     [ebp+var_8], ecx
.text$mn:00003F65                 lea     eax, [ebp+var_1]
.text$mn:00003F68                 push    eax
.text$mn:00003F69                 mov     ecx, [ebp+var_8]
.text$mn:00003F6C                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00003F71                 lea     ecx, [ebp+var_1]
.text$mn:00003F74                 push    ecx
.text$mn:00003F75                 mov     edx, [ebp+arg_4]
.text$mn:00003F78                 push    edx
.text$mn:00003F79                 mov     eax, [ebp+arg_0]
.text$mn:00003F7C                 push    eax
.text$mn:00003F7D                 call    ??$_Destroy_range@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@YAXPAPAVDockingCont@@0AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z ; std::_Destroy_range<std::_Wrap_alloc<std::allocator<DockingCont *>>>(DockingCont * *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &)
.text$mn:00003F82                 add     esp, 0Ch
.text$mn:00003F85                 mov     esp, ebp
.text$mn:00003F87                 pop     ebp
.text$mn:00003F88                 retn    8
.text$mn:00003F88 ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z endp
.text$mn:00003F88
.text$mn:00003F88 ; ---------------------------------------------------------------------------
.text$mn:00003F8B                 align 4
.text$mn:00003F8B _text$mn        ends
.text$mn:00003F8B
.text$mn:00003F8C ; ===========================================================================
.text$mn:00003F8C
.text$mn:00003F8C ; Segment type: Pure code
.text$mn:00003F8C ; Segment permissions: Read/Execute
.text$mn:00003F8C _text$mn        segment para public 'CODE' use32
.text$mn:00003F8C                 assume cs:_text$mn
.text$mn:00003F8C                 ;org 3F8Ch
.text$mn:00003F8C ; COMDAT (pick any)
.text$mn:00003F8C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003F8C
.text$mn:00003F8C ; =============== S U B R O U T I N E =======================================
.text$mn:00003F8C
.text$mn:00003F8C ; Attributes: bp-based frame
.text$mn:00003F8C
.text$mn:00003F8C ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Eos(unsigned int)
.text$mn:00003F8C                 public ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
.text$mn:00003F8C ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z proc near
.text$mn:00003F8C                                         ; CODE XREF: $LN19+60p
.text$mn:00003F8C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+83p ...
.text$mn:00003F8C
.text$mn:00003F8C var_8           = dword ptr -8
.text$mn:00003F8C var_1           = byte ptr -1
.text$mn:00003F8C arg_0           = dword ptr  8
.text$mn:00003F8C
.text$mn:00003F8C                 push    ebp
.text$mn:00003F8D                 mov     ebp, esp
.text$mn:00003F8F                 sub     esp, 8
.text$mn:00003F92                 mov     [ebp+var_8], ecx
.text$mn:00003F95                 mov     [ebp+var_1], 0
.text$mn:00003F99                 mov     eax, [ebp+var_8]
.text$mn:00003F9C                 mov     ecx, [ebp+arg_0]
.text$mn:00003F9F                 mov     [eax+14h], ecx
.text$mn:00003FA2                 lea     edx, [ebp+var_1]
.text$mn:00003FA5                 push    edx
.text$mn:00003FA6                 mov     ecx, [ebp+var_8]
.text$mn:00003FA9                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00003FAE                 add     eax, [ebp+arg_0]
.text$mn:00003FB1                 push    eax
.text$mn:00003FB2                 call    ?assign@?$char_traits@D@std@@SAXAADABD@Z ; std::char_traits<char>::assign(char &,char const &)
.text$mn:00003FB7                 add     esp, 8
.text$mn:00003FBA                 mov     esp, ebp
.text$mn:00003FBC                 pop     ebp
.text$mn:00003FBD                 retn    4
.text$mn:00003FBD ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z endp
.text$mn:00003FBD
.text$mn:00003FBD _text$mn        ends
.text$mn:00003FBD
.text$mn:00003FC0 ; ===========================================================================
.text$mn:00003FC0
.text$mn:00003FC0 ; Segment type: Pure code
.text$mn:00003FC0 ; Segment permissions: Read/Execute
.text$mn:00003FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00003FC0                 assume cs:_text$mn
.text$mn:00003FC0                 ;org 3FC0h
.text$mn:00003FC0 ; COMDAT (pick any)
.text$mn:00003FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00003FC0
.text$mn:00003FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00003FC0
.text$mn:00003FC0 ; Attributes: bp-based frame
.text$mn:00003FC0
.text$mn:00003FC0 ; public: void __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Free_proxy(void)
.text$mn:00003FC0                 public ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ
.text$mn:00003FC0 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00003FC0                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::~_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>(void)+30p
.text$mn:00003FC0
.text$mn:00003FC0 var_8           = dword ptr -8
.text$mn:00003FC0 var_1           = byte ptr -1
.text$mn:00003FC0
.text$mn:00003FC0                 push    ebp
.text$mn:00003FC1                 mov     ebp, esp
.text$mn:00003FC3                 sub     esp, 8
.text$mn:00003FC6                 mov     [ebp+var_8], ecx
.text$mn:00003FC9                 lea     ecx, [ebp+var_1]
.text$mn:00003FCC                 call    ??0?$allocator@U_Container_proxy@std@@@std@@QAE@XZ ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy>(void)
.text$mn:00003FD1                 mov     ecx, [ebp+var_8] ; this
.text$mn:00003FD4                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:00003FD9                 mov     eax, [ebp+var_8]
.text$mn:00003FDC                 mov     ecx, [eax]
.text$mn:00003FDE                 push    ecx
.text$mn:00003FDF                 lea     ecx, [ebp+var_1]
.text$mn:00003FE2                 call    ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:00003FE7                 push    1               ; int
.text$mn:00003FE9                 mov     edx, [ebp+var_8]
.text$mn:00003FEC                 mov     eax, [edx]
.text$mn:00003FEE                 push    eax             ; void *
.text$mn:00003FEF                 lea     ecx, [ebp+var_1]
.text$mn:00003FF2                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00003FF7                 mov     ecx, [ebp+var_8]
.text$mn:00003FFA                 mov     dword ptr [ecx], 0
.text$mn:00004000                 mov     esp, ebp
.text$mn:00004002                 pop     ebp
.text$mn:00004003                 retn
.text$mn:00004003 ?_Free_proxy@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004003
.text$mn:00004003 _text$mn        ends
.text$mn:00004003
.text$mn:00004004 ; ===========================================================================
.text$mn:00004004
.text$mn:00004004 ; Segment type: Pure code
.text$mn:00004004 ; Segment permissions: Read/Execute
.text$mn:00004004 _text$mn        segment para public 'CODE' use32
.text$mn:00004004                 assume cs:_text$mn
.text$mn:00004004                 ;org 4004h
.text$mn:00004004 ; COMDAT (pick any)
.text$mn:00004004                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004004
.text$mn:00004004 ; =============== S U B R O U T I N E =======================================
.text$mn:00004004
.text$mn:00004004 ; Attributes: bp-based frame
.text$mn:00004004
.text$mn:00004004 ; public: void __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Free_proxy(void)
.text$mn:00004004                 public ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ
.text$mn:00004004 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ proc near
.text$mn:00004004                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::~_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>(void)+30p
.text$mn:00004004
.text$mn:00004004 var_8           = dword ptr -8
.text$mn:00004004 var_1           = byte ptr -1
.text$mn:00004004
.text$mn:00004004                 push    ebp
.text$mn:00004005                 mov     ebp, esp
.text$mn:00004007                 sub     esp, 8
.text$mn:0000400A                 mov     [ebp+var_8], ecx
.text$mn:0000400D                 lea     ecx, [ebp+var_1]
.text$mn:00004010                 call    ??0?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::_Wrap_alloc<std::allocator<std::_Container_proxy>>(void)
.text$mn:00004015                 mov     ecx, [ebp+var_8] ; this
.text$mn:00004018                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:0000401D                 mov     eax, [ebp+var_8]
.text$mn:00004020                 mov     ecx, [eax]
.text$mn:00004022                 push    ecx
.text$mn:00004023                 lea     ecx, [ebp+var_1]
.text$mn:00004026                 call    ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::destroy<std::_Container_proxy>(std::_Container_proxy *)
.text$mn:0000402B                 push    1               ; int
.text$mn:0000402D                 mov     edx, [ebp+var_8]
.text$mn:00004030                 mov     eax, [edx]
.text$mn:00004032                 push    eax             ; void *
.text$mn:00004033                 lea     ecx, [ebp+var_1]
.text$mn:00004036                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)
.text$mn:0000403B                 mov     ecx, [ebp+var_8]
.text$mn:0000403E                 mov     dword ptr [ecx], 0
.text$mn:00004044                 mov     esp, ebp
.text$mn:00004046                 pop     ebp
.text$mn:00004047                 retn
.text$mn:00004047 ?_Free_proxy@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAEXXZ endp
.text$mn:00004047
.text$mn:00004047 _text$mn        ends
.text$mn:00004047
.text$mn:00004048 ; ===========================================================================
.text$mn:00004048
.text$mn:00004048 ; Segment type: Pure code
.text$mn:00004048 ; Segment permissions: Read/Execute
.text$mn:00004048 _text$mn        segment para public 'CODE' use32
.text$mn:00004048                 assume cs:_text$mn
.text$mn:00004048                 ;org 4048h
.text$mn:00004048 ; COMDAT (pick any)
.text$mn:00004048                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004048
.text$mn:00004048 ; =============== S U B R O U T I N E =======================================
.text$mn:00004048
.text$mn:00004048 ; Attributes: bp-based frame
.text$mn:00004048
.text$mn:00004048 ; public: struct std::_Wrap_alloc<class std::allocator<char>> __thiscall std::_String_alloc<0, struct std::_String_base_types<char, class std::allocator<char>>>::_Getal(void)const
.text$mn:00004048                 public ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
.text$mn:00004048 ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ proc near
.text$mn:00004048                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+B4p
.text$mn:00004048                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+1Bp ...
.text$mn:00004048
.text$mn:00004048 var_4           = dword ptr -4
.text$mn:00004048 arg_0           = dword ptr  8
.text$mn:00004048
.text$mn:00004048                 push    ebp
.text$mn:00004049                 mov     ebp, esp
.text$mn:0000404B                 push    ecx
.text$mn:0000404C                 mov     [ebp+var_4], ecx
.text$mn:0000404F                 mov     ecx, [ebp+arg_0]
.text$mn:00004052                 call    ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char>>::_Wrap_alloc<std::allocator<char>>(void)
.text$mn:00004057                 mov     eax, [ebp+arg_0]
.text$mn:0000405A                 mov     esp, ebp
.text$mn:0000405C                 pop     ebp
.text$mn:0000405D                 retn    4
.text$mn:0000405D ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ endp
.text$mn:0000405D
.text$mn:0000405D _text$mn        ends
.text$mn:0000405D
.text$mn:00004060 ; ===========================================================================
.text$mn:00004060
.text$mn:00004060 ; Segment type: Pure code
.text$mn:00004060 ; Segment permissions: Read/Execute
.text$mn:00004060 _text$mn        segment para public 'CODE' use32
.text$mn:00004060                 assume cs:_text$mn
.text$mn:00004060                 ;org 4060h
.text$mn:00004060 ; COMDAT (pick any)
.text$mn:00004060                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004060
.text$mn:00004060 ; =============== S U B R O U T I N E =======================================
.text$mn:00004060
.text$mn:00004060 ; Attributes: bp-based frame
.text$mn:00004060
.text$mn:00004060 ; public: struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> __thiscall std::_Vector_alloc<0, struct std::_Vec_base_types<class DockingCont *, class std::allocator<class DockingCont *>>>::_Getal(void)const
.text$mn:00004060                 public ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ
.text$mn:00004060 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ proc near
.text$mn:00004060                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>,DockingCont * *)+36p
.text$mn:00004060                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+3Ap ...
.text$mn:00004060
.text$mn:00004060 var_4           = dword ptr -4
.text$mn:00004060 arg_0           = dword ptr  8
.text$mn:00004060
.text$mn:00004060                 push    ebp
.text$mn:00004061                 mov     ebp, esp
.text$mn:00004063                 push    ecx
.text$mn:00004064                 mov     [ebp+var_4], ecx
.text$mn:00004067                 mov     ecx, [ebp+arg_0]
.text$mn:0000406A                 call    ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<DockingCont *>>::_Wrap_alloc<std::allocator<DockingCont *>>(void)
.text$mn:0000406F                 mov     eax, [ebp+arg_0]
.text$mn:00004072                 mov     esp, ebp
.text$mn:00004074                 pop     ebp
.text$mn:00004075                 retn    4
.text$mn:00004075 ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ endp
.text$mn:00004075
.text$mn:00004075 _text$mn        ends
.text$mn:00004075
.text$mn:00004078 ; ===========================================================================
.text$mn:00004078
.text$mn:00004078 ; Segment type: Pure code
.text$mn:00004078 ; Segment permissions: Read/Execute
.text$mn:00004078 _text$mn        segment para public 'CODE' use32
.text$mn:00004078                 assume cs:_text$mn
.text$mn:00004078                 ;org 4078h
.text$mn:00004078 ; COMDAT (pick any)
.text$mn:00004078                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004078
.text$mn:00004078 ; =============== S U B R O U T I N E =======================================
.text$mn:00004078
.text$mn:00004078 ; Attributes: bp-based frame
.text$mn:00004078
.text$mn:00004078 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Grow(unsigned int, bool)
.text$mn:00004078                 public ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
.text$mn:00004078 ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z proc near
.text$mn:00004078                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+6Ap
.text$mn:00004078                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+5Fp
.text$mn:00004078
.text$mn:00004078 var_C           = dword ptr -0Ch
.text$mn:00004078 Size            = dword ptr -8
.text$mn:00004078 var_4           = dword ptr -4
.text$mn:00004078 arg_0           = dword ptr  8
.text$mn:00004078 arg_4           = byte ptr  0Ch
.text$mn:00004078
.text$mn:00004078                 push    ebp
.text$mn:00004079                 mov     ebp, esp
.text$mn:0000407B                 sub     esp, 0Ch
.text$mn:0000407E                 mov     [ebp+var_4], ecx
.text$mn:00004081                 mov     ecx, [ebp+var_4]
.text$mn:00004084                 call    ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)
.text$mn:00004089                 cmp     eax, [ebp+arg_0]
.text$mn:0000408C                 jnb     short loc_4096
.text$mn:0000408E                 mov     ecx, [ebp+var_4]
.text$mn:00004091                 call    ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)
.text$mn:00004096
.text$mn:00004096 loc_4096:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+14j
.text$mn:00004096                 mov     eax, [ebp+var_4]
.text$mn:00004099                 mov     ecx, [eax+18h]
.text$mn:0000409C                 cmp     ecx, [ebp+arg_0]
.text$mn:0000409F                 jnb     short loc_40B6
.text$mn:000040A1                 mov     edx, [ebp+var_4]
.text$mn:000040A4                 mov     eax, [edx+14h]
.text$mn:000040A7                 push    eax
.text$mn:000040A8                 mov     ecx, [ebp+arg_0]
.text$mn:000040AB                 push    ecx
.text$mn:000040AC                 mov     ecx, [ebp+var_4]
.text$mn:000040AF                 call    ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)
.text$mn:000040B4                 jmp     short loc_4100
.text$mn:000040B6 ; ---------------------------------------------------------------------------
.text$mn:000040B6
.text$mn:000040B6 loc_40B6:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+27j
.text$mn:000040B6                 movzx   edx, [ebp+arg_4]
.text$mn:000040BA                 test    edx, edx
.text$mn:000040BC                 jz      short loc_40F0
.text$mn:000040BE                 cmp     [ebp+arg_0], 10h
.text$mn:000040C2                 jnb     short loc_40F0
.text$mn:000040C4                 mov     eax, [ebp+var_4]
.text$mn:000040C7                 mov     ecx, [ebp+arg_0]
.text$mn:000040CA                 cmp     ecx, [eax+14h]
.text$mn:000040CD                 jnb     short loc_40D7
.text$mn:000040CF                 mov     edx, [ebp+arg_0]
.text$mn:000040D2                 mov     [ebp+Size], edx
.text$mn:000040D5                 jmp     short loc_40E0
.text$mn:000040D7 ; ---------------------------------------------------------------------------
.text$mn:000040D7
.text$mn:000040D7 loc_40D7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+55j
.text$mn:000040D7                 mov     eax, [ebp+var_4]
.text$mn:000040DA                 mov     ecx, [eax+14h]
.text$mn:000040DD                 mov     [ebp+Size], ecx
.text$mn:000040E0
.text$mn:000040E0 loc_40E0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+5Dj
.text$mn:000040E0                 mov     edx, [ebp+Size]
.text$mn:000040E3                 push    edx             ; Size
.text$mn:000040E4                 push    1               ; char
.text$mn:000040E6                 mov     ecx, [ebp+var_4]
.text$mn:000040E9                 call    ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)
.text$mn:000040EE                 jmp     short loc_4100
.text$mn:000040F0 ; ---------------------------------------------------------------------------
.text$mn:000040F0
.text$mn:000040F0 loc_40F0:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+44j
.text$mn:000040F0                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+4Aj
.text$mn:000040F0                 cmp     [ebp+arg_0], 0
.text$mn:000040F4                 jnz     short loc_4100
.text$mn:000040F6                 push    0
.text$mn:000040F8                 mov     ecx, [ebp+var_4]
.text$mn:000040FB                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004100
.text$mn:00004100 loc_4100:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+3Cj
.text$mn:00004100                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+76j ...
.text$mn:00004100                 cmp     [ebp+arg_0], 0
.text$mn:00004104                 jbe     short loc_410F
.text$mn:00004106                 mov     [ebp+var_C], 1
.text$mn:0000410D                 jmp     short loc_4116
.text$mn:0000410F ; ---------------------------------------------------------------------------
.text$mn:0000410F
.text$mn:0000410F loc_410F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+8Cj
.text$mn:0000410F                 mov     [ebp+var_C], 0
.text$mn:00004116
.text$mn:00004116 loc_4116:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+95j
.text$mn:00004116                 mov     al, byte ptr [ebp+var_C]
.text$mn:00004119                 mov     esp, ebp
.text$mn:0000411B                 pop     ebp
.text$mn:0000411C                 retn    8
.text$mn:0000411C ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z endp
.text$mn:0000411C
.text$mn:0000411C ; ---------------------------------------------------------------------------
.text$mn:0000411F                 align 10h
.text$mn:0000411F _text$mn        ends
.text$mn:0000411F
.text$mn:00004120 ; ===========================================================================
.text$mn:00004120
.text$mn:00004120 ; Segment type: Pure code
.text$mn:00004120 ; Segment permissions: Read/Execute
.text$mn:00004120 _text$mn        segment para public 'CODE' use32
.text$mn:00004120                 assume cs:_text$mn
.text$mn:00004120                 ;org 4120h
.text$mn:00004120 ; COMDAT (pick any)
.text$mn:00004120                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004120
.text$mn:00004120 ; =============== S U B R O U T I N E =======================================
.text$mn:00004120
.text$mn:00004120 ; Attributes: bp-based frame
.text$mn:00004120
.text$mn:00004120 ; public: bool __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Inside(char const *)
.text$mn:00004120                 public ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
.text$mn:00004120 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z proc near
.text$mn:00004120                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+2Ap
.text$mn:00004120
.text$mn:00004120 var_4           = dword ptr -4
.text$mn:00004120 arg_0           = dword ptr  8
.text$mn:00004120
.text$mn:00004120                 push    ebp
.text$mn:00004121                 mov     ebp, esp
.text$mn:00004123                 push    ecx
.text$mn:00004124                 mov     [ebp+var_4], ecx
.text$mn:00004127                 cmp     [ebp+arg_0], 0
.text$mn:0000412B                 jz      short loc_414D
.text$mn:0000412D                 mov     ecx, [ebp+var_4]
.text$mn:00004130                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004135                 cmp     [ebp+arg_0], eax
.text$mn:00004138                 jb      short loc_414D
.text$mn:0000413A                 mov     ecx, [ebp+var_4]
.text$mn:0000413D                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004142                 mov     ecx, [ebp+var_4]
.text$mn:00004145                 add     eax, [ecx+14h]
.text$mn:00004148                 cmp     eax, [ebp+arg_0]
.text$mn:0000414B                 ja      short loc_4153
.text$mn:0000414D
.text$mn:0000414D loc_414D:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+Bj
.text$mn:0000414D                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+18j
.text$mn:0000414D                 xor     al, al
.text$mn:0000414F                 jmp     short loc_4155
.text$mn:00004151 ; ---------------------------------------------------------------------------
.text$mn:00004151                 jmp     short loc_4155
.text$mn:00004153 ; ---------------------------------------------------------------------------
.text$mn:00004153
.text$mn:00004153 loc_4153:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Bj
.text$mn:00004153                 mov     al, 1
.text$mn:00004155
.text$mn:00004155 loc_4155:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+2Fj
.text$mn:00004155                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)+31j
.text$mn:00004155                 mov     esp, ebp
.text$mn:00004157                 pop     ebp
.text$mn:00004158                 retn    4
.text$mn:00004158 ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z endp
.text$mn:00004158
.text$mn:00004158 ; ---------------------------------------------------------------------------
.text$mn:0000415B                 align 4
.text$mn:0000415B _text$mn        ends
.text$mn:0000415B
.text$mn:0000415C ; ===========================================================================
.text$mn:0000415C
.text$mn:0000415C ; Segment type: Pure code
.text$mn:0000415C ; Segment permissions: Read/Execute
.text$mn:0000415C _text$mn        segment para public 'CODE' use32
.text$mn:0000415C                 assume cs:_text$mn
.text$mn:0000415C                 ;org 415Ch
.text$mn:0000415C ; COMDAT (pick any)
.text$mn:0000415C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000415C
.text$mn:0000415C ; =============== S U B R O U T I N E =======================================
.text$mn:0000415C
.text$mn:0000415C ; Attributes: bp-based frame
.text$mn:0000415C
.text$mn:0000415C ; public: char * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000415C                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
.text$mn:0000415C ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ proc near
.text$mn:0000415C                                         ; CODE XREF: $LN19+14p
.text$mn:0000415C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+1Dp ...
.text$mn:0000415C
.text$mn:0000415C var_8           = dword ptr -8
.text$mn:0000415C var_4           = dword ptr -4
.text$mn:0000415C
.text$mn:0000415C                 push    ebp
.text$mn:0000415D                 mov     ebp, esp
.text$mn:0000415F                 sub     esp, 8
.text$mn:00004162                 mov     [ebp+var_4], ecx
.text$mn:00004165                 mov     eax, [ebp+var_4]
.text$mn:00004168                 cmp     dword ptr [eax+18h], 10h
.text$mn:0000416C                 jb      short loc_4182
.text$mn:0000416E                 mov     ecx, [ebp+var_4]
.text$mn:00004171                 mov     edx, [ecx+4]
.text$mn:00004174                 push    edx
.text$mn:00004175                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:0000417A                 add     esp, 4
.text$mn:0000417D                 mov     [ebp+var_8], eax
.text$mn:00004180                 jmp     short loc_418B
.text$mn:00004182 ; ---------------------------------------------------------------------------
.text$mn:00004182
.text$mn:00004182 loc_4182:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:00004182                 mov     eax, [ebp+var_4]
.text$mn:00004185                 add     eax, 4
.text$mn:00004188                 mov     [ebp+var_8], eax
.text$mn:0000418B
.text$mn:0000418B loc_418B:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:0000418B                 mov     eax, [ebp+var_8]
.text$mn:0000418E                 mov     esp, ebp
.text$mn:00004190                 pop     ebp
.text$mn:00004191                 retn
.text$mn:00004191 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ endp
.text$mn:00004191
.text$mn:00004191 ; ---------------------------------------------------------------------------
.text$mn:00004192                 align 4
.text$mn:00004192 _text$mn        ends
.text$mn:00004192
.text$mn:00004194 ; ===========================================================================
.text$mn:00004194
.text$mn:00004194 ; Segment type: Pure code
.text$mn:00004194 ; Segment permissions: Read/Execute
.text$mn:00004194 _text$mn        segment para public 'CODE' use32
.text$mn:00004194                 assume cs:_text$mn
.text$mn:00004194                 ;org 4194h
.text$mn:00004194 ; COMDAT (pick any)
.text$mn:00004194                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004194
.text$mn:00004194 ; =============== S U B R O U T I N E =======================================
.text$mn:00004194
.text$mn:00004194 ; Attributes: bp-based frame
.text$mn:00004194
.text$mn:00004194 ; public: char const * __thiscall std::_String_val<struct std::_Simple_types<char>>::_Myptr(void)const
.text$mn:00004194                 public ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
.text$mn:00004194 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ proc near
.text$mn:00004194                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+7Dp
.text$mn:00004194
.text$mn:00004194 var_8           = dword ptr -8
.text$mn:00004194 var_4           = dword ptr -4
.text$mn:00004194
.text$mn:00004194                 push    ebp
.text$mn:00004195                 mov     ebp, esp
.text$mn:00004197                 sub     esp, 8
.text$mn:0000419A                 mov     [ebp+var_4], ecx
.text$mn:0000419D                 mov     eax, [ebp+var_4]
.text$mn:000041A0                 cmp     dword ptr [eax+18h], 10h
.text$mn:000041A4                 jb      short loc_41BA
.text$mn:000041A6                 mov     ecx, [ebp+var_4]
.text$mn:000041A9                 mov     edx, [ecx+4]
.text$mn:000041AC                 push    edx
.text$mn:000041AD                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:000041B2                 add     esp, 4
.text$mn:000041B5                 mov     [ebp+var_8], eax
.text$mn:000041B8                 jmp     short loc_41C3
.text$mn:000041BA ; ---------------------------------------------------------------------------
.text$mn:000041BA
.text$mn:000041BA loc_41BA:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+10j
.text$mn:000041BA                 mov     eax, [ebp+var_4]
.text$mn:000041BD                 add     eax, 4
.text$mn:000041C0                 mov     [ebp+var_8], eax
.text$mn:000041C3
.text$mn:000041C3 loc_41C3:                               ; CODE XREF: std::_String_val<std::_Simple_types<char>>::_Myptr(void)+24j
.text$mn:000041C3                 mov     eax, [ebp+var_8]
.text$mn:000041C6                 mov     esp, ebp
.text$mn:000041C8                 pop     ebp
.text$mn:000041C9                 retn
.text$mn:000041C9 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ endp
.text$mn:000041C9
.text$mn:000041C9 ; ---------------------------------------------------------------------------
.text$mn:000041CA                 align 4
.text$mn:000041CA _text$mn        ends
.text$mn:000041CA
.text$mn:000041CC ; ===========================================================================
.text$mn:000041CC
.text$mn:000041CC ; Segment type: Pure code
.text$mn:000041CC ; Segment permissions: Read/Execute
.text$mn:000041CC _text$mn        segment para public 'CODE' use32
.text$mn:000041CC                 assume cs:_text$mn
.text$mn:000041CC                 ;org 41CCh
.text$mn:000041CC ; COMDAT (pick any)
.text$mn:000041CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000041CC
.text$mn:000041CC ; =============== S U B R O U T I N E =======================================
.text$mn:000041CC
.text$mn:000041CC ; Attributes: bp-based frame
.text$mn:000041CC
.text$mn:000041CC ; void __thiscall std::_Container_base12::_Orphan_all(std::_Container_base12 *__hidden this)
.text$mn:000041CC                 public ?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000041CC ?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$mn:000041CC                                         ; CODE XREF: std::_Container_base12::~_Container_base12(void)+Ap
.text$mn:000041CC                                         ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+14p ...
.text$mn:000041CC
.text$mn:000041CC var_18          = byte ptr -18h
.text$mn:000041CC var_14          = dword ptr -14h
.text$mn:000041CC var_10          = dword ptr -10h
.text$mn:000041CC var_C           = dword ptr -0Ch
.text$mn:000041CC var_4           = dword ptr -4
.text$mn:000041CC
.text$mn:000041CC                 push    ebp
.text$mn:000041CD                 mov     ebp, esp
.text$mn:000041CF                 push    0FFFFFFFFh
.text$mn:000041D1                 push    offset __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$mn:000041D6                 mov     eax, large fs:0
.text$mn:000041DC                 push    eax
.text$mn:000041DD                 sub     esp, 0Ch
.text$mn:000041E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000041E5                 xor     eax, ebp
.text$mn:000041E7                 push    eax
.text$mn:000041E8                 lea     eax, [ebp+var_C]
.text$mn:000041EB                 mov     large fs:0, eax
.text$mn:000041F1                 mov     [ebp+var_14], ecx
.text$mn:000041F4                 mov     eax, [ebp+var_14]
.text$mn:000041F7                 cmp     dword ptr [eax], 0
.text$mn:000041FA                 jz      short loc_4257
.text$mn:000041FC                 push    3               ; int
.text$mn:000041FE                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004201                 call    ??0_Lockit@std@@QAE@H@Z ; std::_Lockit::_Lockit(int)
.text$mn:00004206                 mov     [ebp+var_4], 0
.text$mn:0000420D                 mov     ecx, [ebp+var_14]
.text$mn:00004210                 mov     edx, [ecx]
.text$mn:00004212                 add     edx, 4
.text$mn:00004215                 mov     [ebp+var_10], edx
.text$mn:00004218                 jmp     short loc_4227
.text$mn:0000421A ; ---------------------------------------------------------------------------
.text$mn:0000421A
.text$mn:0000421A loc_421A:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+6Ej
.text$mn:0000421A                 mov     eax, [ebp+var_10]
.text$mn:0000421D                 mov     ecx, [eax]
.text$mn:0000421F                 mov     edx, [ebp+var_10]
.text$mn:00004222                 mov     eax, [ecx+4]
.text$mn:00004225                 mov     [edx], eax
.text$mn:00004227
.text$mn:00004227 loc_4227:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+4Cj
.text$mn:00004227                 mov     ecx, [ebp+var_10]
.text$mn:0000422A                 cmp     dword ptr [ecx], 0
.text$mn:0000422D                 jz      short loc_423C
.text$mn:0000422F                 mov     edx, [ebp+var_10]
.text$mn:00004232                 mov     eax, [edx]
.text$mn:00004234                 mov     dword ptr [eax], 0
.text$mn:0000423A                 jmp     short loc_421A
.text$mn:0000423C ; ---------------------------------------------------------------------------
.text$mn:0000423C
.text$mn:0000423C loc_423C:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+61j
.text$mn:0000423C                 mov     ecx, [ebp+var_14]
.text$mn:0000423F                 mov     edx, [ecx]
.text$mn:00004241                 mov     dword ptr [edx+4], 0
.text$mn:00004248                 mov     [ebp+var_4], 0FFFFFFFFh
.text$mn:0000424F                 lea     ecx, [ebp+var_18] ; this
.text$mn:00004252                 call    ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$mn:00004257
.text$mn:00004257 loc_4257:                               ; CODE XREF: std::_Container_base12::_Orphan_all(void)+2Ej
.text$mn:00004257                 mov     ecx, [ebp+var_C]
.text$mn:0000425A                 mov     large fs:0, ecx
.text$mn:00004261                 pop     ecx
.text$mn:00004262                 mov     esp, ebp
.text$mn:00004264                 pop     ebp
.text$mn:00004265                 retn
.text$mn:00004265 ?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$mn:00004265
.text$mn:00004265 ; ---------------------------------------------------------------------------
.text$mn:00004266                 align 4
.text$mn:00004266 _text$mn        ends
.text$mn:00004266
.text$x:00004268 ; ===========================================================================
.text$x:00004268
.text$x:00004268 ; Segment type: Pure code
.text$x:00004268 ; Segment permissions: Read/Execute
.text$x:00004268 _text$x         segment para public 'CODE' use32
.text$x:00004268                 assume cs:_text$x
.text$x:00004268                 ;org 4268h
.text$x:00004268 ; COMDAT (pick associative to section at 41CC)
.text$x:00004268                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004268
.text$x:00004268 ; =============== S U B R O U T I N E =======================================
.text$x:00004268
.text$x:00004268
.text$x:00004268 __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 proc near
.text$x:00004268                                         ; DATA XREF: .xdata$x:00004FFCo
.text$x:00004268                 lea     ecx, [ebp-18h]  ; this
.text$x:0000426B                 jmp     ??1_Lockit@std@@QAE@XZ ; std::_Lockit::~_Lockit(void)
.text$x:0000426B __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0 endp
.text$x:0000426B
.text$x:00004270
.text$x:00004270 ; =============== S U B R O U T I N E =======================================
.text$x:00004270
.text$x:00004270
.text$x:00004270 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ proc near
.text$x:00004270                                         ; DATA XREF: std::_Container_base12::_Orphan_all(void)+5o
.text$x:00004270
.text$x:00004270 arg_4           = dword ptr  8
.text$x:00004270
.text$x:00004270                 mov     edx, [esp+arg_4]
.text$x:00004274                 lea     eax, [edx+0Ch]
.text$x:00004277                 mov     ecx, [edx-10h]
.text$x:0000427A                 xor     ecx, eax
.text$x:0000427C                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004281                 mov     eax, offset __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ
.text$x:00004286                 jmp     ___CxxFrameHandler3
.text$x:00004286 __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ endp
.text$x:00004286
.text$x:00004286 ; ---------------------------------------------------------------------------
.text$x:0000428B                 align 4
.text$x:0000428B _text$x         ends
.text$x:0000428B
.text$mn:0000428C ; ===========================================================================
.text$mn:0000428C
.text$mn:0000428C ; Segment type: Pure code
.text$mn:0000428C ; Segment permissions: Read/Execute
.text$mn:0000428C _text$mn        segment para public 'CODE' use32
.text$mn:0000428C                 assume cs:_text$mn
.text$mn:0000428C                 ;org 428Ch
.text$mn:0000428C ; COMDAT (pick any)
.text$mn:0000428C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000428C
.text$mn:0000428C ; =============== S U B R O U T I N E =======================================
.text$mn:0000428C
.text$mn:0000428C ; Attributes: bp-based frame
.text$mn:0000428C
.text$mn:0000428C ; void __thiscall std::_Iterator_base12::_Orphan_me(std::_Iterator_base12 *__hidden this)
.text$mn:0000428C                 public ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
.text$mn:0000428C ?_Orphan_me@_Iterator_base12@std@@QAEXXZ proc near
.text$mn:0000428C                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+3Cp
.text$mn:0000428C                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+64p ...
.text$mn:0000428C
.text$mn:0000428C var_8           = dword ptr -8
.text$mn:0000428C var_4           = dword ptr -4
.text$mn:0000428C
.text$mn:0000428C                 push    ebp
.text$mn:0000428D                 mov     ebp, esp
.text$mn:0000428F                 sub     esp, 8
.text$mn:00004292                 mov     [ebp+var_8], ecx
.text$mn:00004295                 mov     eax, [ebp+var_8]
.text$mn:00004298                 cmp     dword ptr [eax], 0
.text$mn:0000429B                 jz      short loc_42FA
.text$mn:0000429D                 mov     ecx, [ebp+var_8]
.text$mn:000042A0                 mov     edx, [ecx]
.text$mn:000042A2                 add     edx, 4
.text$mn:000042A5                 mov     [ebp+var_4], edx
.text$mn:000042A8
.text$mn:000042A8 loc_42A8:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+39j
.text$mn:000042A8                 mov     eax, [ebp+var_4]
.text$mn:000042AB                 cmp     dword ptr [eax], 0
.text$mn:000042AE                 jz      short loc_42C7
.text$mn:000042B0                 mov     ecx, [ebp+var_4]
.text$mn:000042B3                 mov     edx, [ecx]
.text$mn:000042B5                 cmp     edx, [ebp+var_8]
.text$mn:000042B8                 jz      short loc_42C7
.text$mn:000042BA                 mov     eax, [ebp+var_4]
.text$mn:000042BD                 mov     ecx, [eax]
.text$mn:000042BF                 add     ecx, 4
.text$mn:000042C2                 mov     [ebp+var_4], ecx
.text$mn:000042C5                 jmp     short loc_42A8
.text$mn:000042C7 ; ---------------------------------------------------------------------------
.text$mn:000042C7
.text$mn:000042C7 loc_42C7:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+22j
.text$mn:000042C7                                         ; std::_Iterator_base12::_Orphan_me(void)+2Cj
.text$mn:000042C7                 mov     edx, [ebp+var_4]
.text$mn:000042CA                 cmp     dword ptr [edx], 0
.text$mn:000042CD                 jnz     short loc_42E6
.text$mn:000042CF                 push    0C9h ; '+'      ; unsigned int
.text$mn:000042D4                 push    offset ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000042D9                 push    offset ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; "ITERATOR LIST CORRUPTED!"
.text$mn:000042DE                 call    ?_Debug_message@std@@YAXPB_W0I@Z ; std::_Debug_message(wchar_t const *,wchar_t const *,uint)
.text$mn:000042E3                 add     esp, 0Ch
.text$mn:000042E6
.text$mn:000042E6 loc_42E6:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+41j
.text$mn:000042E6                 mov     eax, [ebp+var_4]
.text$mn:000042E9                 mov     ecx, [ebp+var_8]
.text$mn:000042EC                 mov     edx, [ecx+4]
.text$mn:000042EF                 mov     [eax], edx
.text$mn:000042F1                 mov     eax, [ebp+var_8]
.text$mn:000042F4                 mov     dword ptr [eax], 0
.text$mn:000042FA
.text$mn:000042FA loc_42FA:                               ; CODE XREF: std::_Iterator_base12::_Orphan_me(void)+Fj
.text$mn:000042FA                 mov     esp, ebp
.text$mn:000042FC                 pop     ebp
.text$mn:000042FD                 retn
.text$mn:000042FD ?_Orphan_me@_Iterator_base12@std@@QAEXXZ endp
.text$mn:000042FD
.text$mn:000042FD ; ---------------------------------------------------------------------------
.text$mn:000042FE                 align 10h
.text$mn:000042FE _text$mn        ends
.text$mn:000042FE
.text$mn:00004300 ; ===========================================================================
.text$mn:00004300
.text$mn:00004300 ; Segment type: Pure code
.text$mn:00004300 ; Segment permissions: Read/Execute
.text$mn:00004300 _text$mn        segment para public 'CODE' use32
.text$mn:00004300                 assume cs:_text$mn
.text$mn:00004300                 ;org 4300h
.text$mn:00004300 ; COMDAT (pick any)
.text$mn:00004300                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004300
.text$mn:00004300 ; =============== S U B R O U T I N E =======================================
.text$mn:00004300
.text$mn:00004300 ; Attributes: bp-based frame
.text$mn:00004300
.text$mn:00004300 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(char, size_t Size)
.text$mn:00004300                 public ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
.text$mn:00004300 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z proc near
.text$mn:00004300                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+47p
.text$mn:00004300                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)+34p ...
.text$mn:00004300
.text$mn:00004300 var_C           = dword ptr -0Ch
.text$mn:00004300 var_8           = dword ptr -8
.text$mn:00004300 var_2           = byte ptr -2
.text$mn:00004300 var_1           = byte ptr -1
.text$mn:00004300 arg_0           = byte ptr  8
.text$mn:00004300 Size            = dword ptr  0Ch
.text$mn:00004300
.text$mn:00004300                 push    ebp
.text$mn:00004301                 mov     ebp, esp
.text$mn:00004303                 sub     esp, 0Ch
.text$mn:00004306                 mov     [ebp+var_8], ecx
.text$mn:00004309                 movzx   eax, [ebp+arg_0]
.text$mn:0000430D                 test    eax, eax
.text$mn:0000430F                 jnz     short loc_4313
.text$mn:00004311                 jmp     short loc_4386
.text$mn:00004313 ; ---------------------------------------------------------------------------
.text$mn:00004313
.text$mn:00004313 loc_4313:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+Fj
.text$mn:00004313                 mov     ecx, [ebp+var_8]
.text$mn:00004316                 cmp     dword ptr [ecx+18h], 10h
.text$mn:0000431A                 jb      short loc_4386
.text$mn:0000431C                 mov     edx, [ebp+var_8]
.text$mn:0000431F                 mov     eax, [edx+4]
.text$mn:00004322                 mov     [ebp+var_C], eax
.text$mn:00004325                 mov     ecx, [ebp+var_8]
.text$mn:00004328                 add     ecx, 4
.text$mn:0000432B                 push    ecx
.text$mn:0000432C                 lea     edx, [ebp+var_1]
.text$mn:0000432F                 push    edx
.text$mn:00004330                 mov     ecx, [ebp+var_8]
.text$mn:00004333                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004338                 mov     ecx, eax
.text$mn:0000433A                 call    ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char>>::destroy<char *>(char * *)
.text$mn:0000433F                 cmp     [ebp+Size], 0
.text$mn:00004343                 jbe     short loc_4365
.text$mn:00004345                 mov     eax, [ebp+Size]
.text$mn:00004348                 push    eax             ; Size
.text$mn:00004349                 mov     ecx, [ebp+var_C]
.text$mn:0000434C                 push    ecx
.text$mn:0000434D                 call    ??$addressof@D@std@@YAPADAAD@Z ; std::addressof<char>(char &)
.text$mn:00004352                 add     esp, 4
.text$mn:00004355                 push    eax             ; Src
.text$mn:00004356                 mov     edx, [ebp+var_8]
.text$mn:00004359                 add     edx, 4
.text$mn:0000435C                 push    edx             ; Dst
.text$mn:0000435D                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:00004362                 add     esp, 0Ch
.text$mn:00004365
.text$mn:00004365 loc_4365:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+43j
.text$mn:00004365                 mov     eax, [ebp+var_8]
.text$mn:00004368                 mov     ecx, [eax+18h]
.text$mn:0000436B                 add     ecx, 1
.text$mn:0000436E                 push    ecx             ; int
.text$mn:0000436F                 mov     edx, [ebp+var_C]
.text$mn:00004372                 push    edx             ; void *
.text$mn:00004373                 lea     eax, [ebp+var_2]
.text$mn:00004376                 push    eax
.text$mn:00004377                 mov     ecx, [ebp+var_8]
.text$mn:0000437A                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:0000437F                 mov     ecx, eax
.text$mn:00004381                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)
.text$mn:00004386
.text$mn:00004386 loc_4386:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+11j
.text$mn:00004386                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+1Aj
.text$mn:00004386                 mov     ecx, [ebp+var_8]
.text$mn:00004389                 mov     dword ptr [ecx+18h], 0Fh
.text$mn:00004390                 mov     edx, [ebp+Size]
.text$mn:00004393                 push    edx
.text$mn:00004394                 mov     ecx, [ebp+var_8]
.text$mn:00004397                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000439C                 mov     esp, ebp
.text$mn:0000439E                 pop     ebp
.text$mn:0000439F                 retn    8
.text$mn:0000439F ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z endp
.text$mn:0000439F
.text$mn:0000439F ; ---------------------------------------------------------------------------
.text$mn:000043A2                 align 4
.text$mn:000043A2 _text$mn        ends
.text$mn:000043A2
.text$mn:000043A4 ; ===========================================================================
.text$mn:000043A4
.text$mn:000043A4 ; Segment type: Pure code
.text$mn:000043A4 ; Segment permissions: Read/Execute
.text$mn:000043A4 _text$mn        segment para public 'CODE' use32
.text$mn:000043A4                 assume cs:_text$mn
.text$mn:000043A4                 ;org 43A4h
.text$mn:000043A4 ; COMDAT (pick any)
.text$mn:000043A4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000043A4
.text$mn:000043A4 ; =============== S U B R O U T I N E =======================================
.text$mn:000043A4
.text$mn:000043A4 ; Attributes: bp-based frame
.text$mn:000043A4
.text$mn:000043A4 ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Tidy(void)
.text$mn:000043A4                 public ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ
.text$mn:000043A4 ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ proc near
.text$mn:000043A4                                         ; CODE XREF: __catch$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$0+3p
.text$mn:000043A4                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::~vector<DockingCont *,std::allocator<DockingCont *>>(void)+30p
.text$mn:000043A4
.text$mn:000043A4 var_8           = dword ptr -8
.text$mn:000043A4 var_1           = byte ptr -1
.text$mn:000043A4
.text$mn:000043A4                 push    ebp
.text$mn:000043A5                 mov     ebp, esp
.text$mn:000043A7                 sub     esp, 8
.text$mn:000043AA                 mov     [ebp+var_8], ecx
.text$mn:000043AD                 mov     eax, [ebp+var_8]
.text$mn:000043B0                 cmp     dword ptr [eax+4], 0
.text$mn:000043B4                 jz      short loc_441C
.text$mn:000043B6                 mov     ecx, [ebp+var_8] ; this
.text$mn:000043B9                 call    ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all(void)
.text$mn:000043BE                 mov     ecx, [ebp+var_8]
.text$mn:000043C1                 mov     edx, [ecx+8]
.text$mn:000043C4                 push    edx
.text$mn:000043C5                 mov     eax, [ebp+var_8]
.text$mn:000043C8                 mov     ecx, [eax+4]
.text$mn:000043CB                 push    ecx
.text$mn:000043CC                 mov     ecx, [ebp+var_8]
.text$mn:000043CF                 call    ?_Destroy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXPAPAVDockingCont@@0@Z ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Destroy(DockingCont * *,DockingCont * *)
.text$mn:000043D4                 mov     edx, [ebp+var_8]
.text$mn:000043D7                 mov     eax, [ebp+var_8]
.text$mn:000043DA                 mov     ecx, [edx+0Ch]
.text$mn:000043DD                 sub     ecx, [eax+4]
.text$mn:000043E0                 sar     ecx, 2
.text$mn:000043E3                 push    ecx             ; int
.text$mn:000043E4                 mov     edx, [ebp+var_8]
.text$mn:000043E7                 mov     eax, [edx+4]
.text$mn:000043EA                 push    eax             ; void *
.text$mn:000043EB                 lea     ecx, [ebp+var_1]
.text$mn:000043EE                 push    ecx
.text$mn:000043EF                 mov     ecx, [ebp+var_8]
.text$mn:000043F2                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:000043F7                 mov     ecx, eax
.text$mn:000043F9                 call    ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(DockingCont * *,uint)
.text$mn:000043FE                 mov     edx, [ebp+var_8]
.text$mn:00004401                 mov     dword ptr [edx+4], 0
.text$mn:00004408                 mov     eax, [ebp+var_8]
.text$mn:0000440B                 mov     dword ptr [eax+8], 0
.text$mn:00004412                 mov     ecx, [ebp+var_8]
.text$mn:00004415                 mov     dword ptr [ecx+0Ch], 0
.text$mn:0000441C
.text$mn:0000441C loc_441C:                               ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)+10j
.text$mn:0000441C                 mov     esp, ebp
.text$mn:0000441E                 pop     ebp
.text$mn:0000441F                 retn
.text$mn:0000441F ?_Tidy@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEXXZ endp
.text$mn:0000441F
.text$mn:0000441F _text$mn        ends
.text$mn:0000441F
.text$mn:00004420 ; ===========================================================================
.text$mn:00004420
.text$mn:00004420 ; Segment type: Pure code
.text$mn:00004420 ; Segment permissions: Read/Execute
.text$mn:00004420 _text$mn        segment para public 'CODE' use32
.text$mn:00004420                 assume cs:_text$mn
.text$mn:00004420                 ;org 4420h
.text$mn:00004420 ; COMDAT (pick any)
.text$mn:00004420                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004420
.text$mn:00004420 ; =============== S U B R O U T I N E =======================================
.text$mn:00004420
.text$mn:00004420 ; Attributes: bp-based frame
.text$mn:00004420
.text$mn:00004420 ; public: class DockingCont * const * __thiscall std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>>::_Unchecked(void)const
.text$mn:00004420                 public ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QBEPBQAVDockingCont@@XZ
.text$mn:00004420 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QBEPBQAVDockingCont@@XZ proc near
.text$mn:00004420                                         ; CODE XREF: std::_Unchecked<std::_Vector_val<std::_Simple_types<DockingCont *>>>(std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>)+2Dp
.text$mn:00004420
.text$mn:00004420 var_4           = dword ptr -4
.text$mn:00004420
.text$mn:00004420                 push    ebp
.text$mn:00004421                 mov     ebp, esp
.text$mn:00004423                 push    ecx
.text$mn:00004424                 mov     [ebp+var_4], ecx
.text$mn:00004427                 mov     eax, [ebp+var_4]
.text$mn:0000442A                 mov     eax, [eax+8]
.text$mn:0000442D                 mov     esp, ebp
.text$mn:0000442F                 pop     ebp
.text$mn:00004430                 retn
.text$mn:00004430 ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QBEPBQAVDockingCont@@XZ endp
.text$mn:00004430
.text$mn:00004430 ; ---------------------------------------------------------------------------
.text$mn:00004431                 align 4
.text$mn:00004431 _text$mn        ends
.text$mn:00004431
.text$mn:00004434 ; ===========================================================================
.text$mn:00004434
.text$mn:00004434 ; Segment type: Pure code
.text$mn:00004434 ; Segment permissions: Read/Execute
.text$mn:00004434 _text$mn        segment para public 'CODE' use32
.text$mn:00004434                 assume cs:_text$mn
.text$mn:00004434                 ;org 4434h
.text$mn:00004434 ; COMDAT (pick any)
.text$mn:00004434                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004434
.text$mn:00004434 ; =============== S U B R O U T I N E =======================================
.text$mn:00004434
.text$mn:00004434 ; Attributes: bp-based frame
.text$mn:00004434
.text$mn:00004434 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xlen(void)const
.text$mn:00004434                 public ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00004434 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00004434                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)+19p
.text$mn:00004434
.text$mn:00004434 var_4           = dword ptr -4
.text$mn:00004434
.text$mn:00004434                 push    ebp
.text$mn:00004435                 mov     ebp, esp
.text$mn:00004437                 push    ecx
.text$mn:00004438                 mov     [ebp+var_4], ecx
.text$mn:0000443B                 push    offset ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ ; "string too long"
.text$mn:00004440                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:00004445                 mov     esp, ebp
.text$mn:00004447                 pop     ebp
.text$mn:00004448                 retn
.text$mn:00004448 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00004448
.text$mn:00004448 ; ---------------------------------------------------------------------------
.text$mn:00004449                 align 4
.text$mn:00004449 _text$mn        ends
.text$mn:00004449
.text$mn:0000444C ; ===========================================================================
.text$mn:0000444C
.text$mn:0000444C ; Segment type: Pure code
.text$mn:0000444C ; Segment permissions: Read/Execute
.text$mn:0000444C _text$mn        segment para public 'CODE' use32
.text$mn:0000444C                 assume cs:_text$mn
.text$mn:0000444C                 ;org 444Ch
.text$mn:0000444C ; COMDAT (pick any)
.text$mn:0000444C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000444C
.text$mn:0000444C ; =============== S U B R O U T I N E =======================================
.text$mn:0000444C
.text$mn:0000444C ; Attributes: bp-based frame
.text$mn:0000444C
.text$mn:0000444C ; protected: void __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::_Xlen(void)const
.text$mn:0000444C                 public ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ
.text$mn:0000444C ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ proc near
.text$mn:0000444C                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+43p
.text$mn:0000444C
.text$mn:0000444C var_4           = dword ptr -4
.text$mn:0000444C
.text$mn:0000444C                 push    ebp
.text$mn:0000444D                 mov     ebp, esp
.text$mn:0000444F                 push    ecx
.text$mn:00004450                 mov     [ebp+var_4], ecx
.text$mn:00004453                 push    offset ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; "vector<T> too long"
.text$mn:00004458                 call    ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error(char const *)
.text$mn:0000445D                 mov     esp, ebp
.text$mn:0000445F                 pop     ebp
.text$mn:00004460                 retn
.text$mn:00004460 ?_Xlen@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IBEXXZ endp
.text$mn:00004460
.text$mn:00004460 ; ---------------------------------------------------------------------------
.text$mn:00004461                 align 4
.text$mn:00004461 _text$mn        ends
.text$mn:00004461
.text$mn:00004464 ; ===========================================================================
.text$mn:00004464
.text$mn:00004464 ; Segment type: Pure code
.text$mn:00004464 ; Segment permissions: Read/Execute
.text$mn:00004464 _text$mn        segment para public 'CODE' use32
.text$mn:00004464                 assume cs:_text$mn
.text$mn:00004464                 ;org 4464h
.text$mn:00004464 ; COMDAT (pick any)
.text$mn:00004464                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004464
.text$mn:00004464 ; =============== S U B R O U T I N E =======================================
.text$mn:00004464
.text$mn:00004464 ; Attributes: bp-based frame
.text$mn:00004464
.text$mn:00004464 ; public: void __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::_Xran(void)const
.text$mn:00004464                 public ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
.text$mn:00004464 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ proc near
.text$mn:00004464                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+19p
.text$mn:00004464                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+15p ...
.text$mn:00004464
.text$mn:00004464 var_4           = dword ptr -4
.text$mn:00004464
.text$mn:00004464                 push    ebp
.text$mn:00004465                 mov     ebp, esp
.text$mn:00004467                 push    ecx
.text$mn:00004468                 mov     [ebp+var_4], ecx
.text$mn:0000446B                 push    offset ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; "invalid string position"
.text$mn:00004470                 call    ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range(char const *)
.text$mn:00004475                 mov     esp, ebp
.text$mn:00004477                 pop     ebp
.text$mn:00004478                 retn
.text$mn:00004478 ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ endp
.text$mn:00004478
.text$mn:00004478 ; ---------------------------------------------------------------------------
.text$mn:00004479                 align 4
.text$mn:00004479 _text$mn        ends
.text$mn:00004479
.text$mn:0000447C ; ===========================================================================
.text$mn:0000447C
.text$mn:0000447C ; Segment type: Pure code
.text$mn:0000447C ; Segment permissions: Read/Execute
.text$mn:0000447C _text$mn        segment para public 'CODE' use32
.text$mn:0000447C                 assume cs:_text$mn
.text$mn:0000447C                 ;org 447Ch
.text$mn:0000447C ; COMDAT (pick any)
.text$mn:0000447C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000447C
.text$mn:0000447C ; =============== S U B R O U T I N E =======================================
.text$mn:0000447C
.text$mn:0000447C ; Attributes: bp-based frame
.text$mn:0000447C
.text$mn:0000447C ; public: char * __thiscall std::_Wrap_alloc<class std::allocator<char>>::allocate(unsigned int)
.text$mn:0000447C                 public ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
.text$mn:0000447C ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z proc near
.text$mn:0000447C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+BBp
.text$mn:0000447C                                         ; __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0+22p
.text$mn:0000447C
.text$mn:0000447C var_4           = dword ptr -4
.text$mn:0000447C arg_0           = dword ptr  8
.text$mn:0000447C
.text$mn:0000447C                 push    ebp
.text$mn:0000447D                 mov     ebp, esp
.text$mn:0000447F                 push    ecx
.text$mn:00004480                 mov     [ebp+var_4], ecx
.text$mn:00004483                 mov     eax, [ebp+arg_0]
.text$mn:00004486                 push    eax
.text$mn:00004487                 mov     ecx, [ebp+var_4]
.text$mn:0000448A                 call    ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate(uint)
.text$mn:0000448F                 mov     esp, ebp
.text$mn:00004491                 pop     ebp
.text$mn:00004492                 retn    4
.text$mn:00004492 ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z endp
.text$mn:00004492
.text$mn:00004492 ; ---------------------------------------------------------------------------
.text$mn:00004495                 align 4
.text$mn:00004495 _text$mn        ends
.text$mn:00004495
.text$mn:00004498 ; ===========================================================================
.text$mn:00004498
.text$mn:00004498 ; Segment type: Pure code
.text$mn:00004498 ; Segment permissions: Read/Execute
.text$mn:00004498 _text$mn        segment para public 'CODE' use32
.text$mn:00004498                 assume cs:_text$mn
.text$mn:00004498                 ;org 4498h
.text$mn:00004498 ; COMDAT (pick any)
.text$mn:00004498                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004498
.text$mn:00004498 ; =============== S U B R O U T I N E =======================================
.text$mn:00004498
.text$mn:00004498 ; Attributes: bp-based frame
.text$mn:00004498
.text$mn:00004498 ; public: class DockingCont * * __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::allocate(unsigned int)
.text$mn:00004498                 public ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z
.text$mn:00004498 ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z proc near
.text$mn:00004498                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+5Cp
.text$mn:00004498
.text$mn:00004498 var_4           = dword ptr -4
.text$mn:00004498 arg_0           = dword ptr  8
.text$mn:00004498
.text$mn:00004498                 push    ebp
.text$mn:00004499                 mov     ebp, esp
.text$mn:0000449B                 push    ecx
.text$mn:0000449C                 mov     [ebp+var_4], ecx
.text$mn:0000449F                 mov     eax, [ebp+arg_0]
.text$mn:000044A2                 push    eax
.text$mn:000044A3                 mov     ecx, [ebp+var_4]
.text$mn:000044A6                 call    ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z ; std::allocator<DockingCont *>::allocate(uint)
.text$mn:000044AB                 mov     esp, ebp
.text$mn:000044AD                 pop     ebp
.text$mn:000044AE                 retn    4
.text$mn:000044AE ?allocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEPAPAVDockingCont@@I@Z endp
.text$mn:000044AE
.text$mn:000044AE ; ---------------------------------------------------------------------------
.text$mn:000044B1                 align 4
.text$mn:000044B1 _text$mn        ends
.text$mn:000044B1
.text$mn:000044B4 ; ===========================================================================
.text$mn:000044B4
.text$mn:000044B4 ; Segment type: Pure code
.text$mn:000044B4 ; Segment permissions: Read/Execute
.text$mn:000044B4 _text$mn        segment para public 'CODE' use32
.text$mn:000044B4                 assume cs:_text$mn
.text$mn:000044B4                 ;org 44B4h
.text$mn:000044B4 ; COMDAT (pick any)
.text$mn:000044B4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044B4
.text$mn:000044B4 ; =============== S U B R O U T I N E =======================================
.text$mn:000044B4
.text$mn:000044B4 ; Attributes: bp-based frame
.text$mn:000044B4
.text$mn:000044B4 ; public: struct std::_Container_proxy * __thiscall std::_Wrap_alloc<class std::allocator<struct std::_Container_proxy>>::allocate(unsigned int)
.text$mn:000044B4                 public ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:000044B4 ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:000044B4                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Alloc_proxy(void)+16p
.text$mn:000044B4
.text$mn:000044B4 var_4           = dword ptr -4
.text$mn:000044B4 arg_0           = dword ptr  8
.text$mn:000044B4
.text$mn:000044B4                 push    ebp
.text$mn:000044B5                 mov     ebp, esp
.text$mn:000044B7                 push    ecx
.text$mn:000044B8                 mov     [ebp+var_4], ecx
.text$mn:000044BB                 mov     eax, [ebp+arg_0]
.text$mn:000044BE                 push    eax
.text$mn:000044BF                 mov     ecx, [ebp+var_4]
.text$mn:000044C2                 call    ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate(uint)
.text$mn:000044C7                 mov     esp, ebp
.text$mn:000044C9                 pop     ebp
.text$mn:000044CA                 retn    4
.text$mn:000044CA ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:000044CA
.text$mn:000044CA ; ---------------------------------------------------------------------------
.text$mn:000044CD                 align 10h
.text$mn:000044CD _text$mn        ends
.text$mn:000044CD
.text$mn:000044D0 ; ===========================================================================
.text$mn:000044D0
.text$mn:000044D0 ; Segment type: Pure code
.text$mn:000044D0 ; Segment permissions: Read/Execute
.text$mn:000044D0 _text$mn        segment para public 'CODE' use32
.text$mn:000044D0                 assume cs:_text$mn
.text$mn:000044D0                 ;org 44D0h
.text$mn:000044D0 ; COMDAT (pick any)
.text$mn:000044D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044D0
.text$mn:000044D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000044D0
.text$mn:000044D0 ; Attributes: bp-based frame
.text$mn:000044D0
.text$mn:000044D0 ; public: char * __thiscall std::allocator<char>::allocate(unsigned int)
.text$mn:000044D0                 public ?allocate@?$allocator@D@std@@QAEPADI@Z
.text$mn:000044D0 ?allocate@?$allocator@D@std@@QAEPADI@Z proc near
.text$mn:000044D0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::allocate(uint)+Ep
.text$mn:000044D0
.text$mn:000044D0 var_4           = dword ptr -4
.text$mn:000044D0 arg_0           = dword ptr  8
.text$mn:000044D0
.text$mn:000044D0                 push    ebp
.text$mn:000044D1                 mov     ebp, esp
.text$mn:000044D3                 push    ecx
.text$mn:000044D4                 mov     [ebp+var_4], ecx
.text$mn:000044D7                 push    0
.text$mn:000044D9                 mov     eax, [ebp+arg_0]
.text$mn:000044DC                 push    eax
.text$mn:000044DD                 call    ??$_Allocate@D@std@@YAPADIPAD@Z ; std::_Allocate<char>(uint,char *)
.text$mn:000044E2                 add     esp, 8
.text$mn:000044E5                 mov     esp, ebp
.text$mn:000044E7                 pop     ebp
.text$mn:000044E8                 retn    4
.text$mn:000044E8 ?allocate@?$allocator@D@std@@QAEPADI@Z endp
.text$mn:000044E8
.text$mn:000044E8 ; ---------------------------------------------------------------------------
.text$mn:000044EB                 align 4
.text$mn:000044EB _text$mn        ends
.text$mn:000044EB
.text$mn:000044EC ; ===========================================================================
.text$mn:000044EC
.text$mn:000044EC ; Segment type: Pure code
.text$mn:000044EC ; Segment permissions: Read/Execute
.text$mn:000044EC _text$mn        segment para public 'CODE' use32
.text$mn:000044EC                 assume cs:_text$mn
.text$mn:000044EC                 ;org 44ECh
.text$mn:000044EC ; COMDAT (pick any)
.text$mn:000044EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000044EC
.text$mn:000044EC ; =============== S U B R O U T I N E =======================================
.text$mn:000044EC
.text$mn:000044EC ; Attributes: bp-based frame
.text$mn:000044EC
.text$mn:000044EC ; public: class DockingCont * * __thiscall std::allocator<class DockingCont *>::allocate(unsigned int)
.text$mn:000044EC                 public ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z
.text$mn:000044EC ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z proc near
.text$mn:000044EC                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::allocate(uint)+Ep
.text$mn:000044EC
.text$mn:000044EC var_4           = dword ptr -4
.text$mn:000044EC arg_0           = dword ptr  8
.text$mn:000044EC
.text$mn:000044EC                 push    ebp
.text$mn:000044ED                 mov     ebp, esp
.text$mn:000044EF                 push    ecx
.text$mn:000044F0                 mov     [ebp+var_4], ecx
.text$mn:000044F3                 push    0
.text$mn:000044F5                 mov     eax, [ebp+arg_0]
.text$mn:000044F8                 push    eax
.text$mn:000044F9                 call    ??$_Allocate@PAVDockingCont@@@std@@YAPAPAVDockingCont@@IPAPAV1@@Z ; std::_Allocate<DockingCont *>(uint,DockingCont * *)
.text$mn:000044FE                 add     esp, 8
.text$mn:00004501                 mov     esp, ebp
.text$mn:00004503                 pop     ebp
.text$mn:00004504                 retn    4
.text$mn:00004504 ?allocate@?$allocator@PAVDockingCont@@@std@@QAEPAPAVDockingCont@@I@Z endp
.text$mn:00004504
.text$mn:00004504 ; ---------------------------------------------------------------------------
.text$mn:00004507                 align 4
.text$mn:00004507 _text$mn        ends
.text$mn:00004507
.text$mn:00004508 ; ===========================================================================
.text$mn:00004508
.text$mn:00004508 ; Segment type: Pure code
.text$mn:00004508 ; Segment permissions: Read/Execute
.text$mn:00004508 _text$mn        segment para public 'CODE' use32
.text$mn:00004508                 assume cs:_text$mn
.text$mn:00004508                 ;org 4508h
.text$mn:00004508 ; COMDAT (pick any)
.text$mn:00004508                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004508
.text$mn:00004508 ; =============== S U B R O U T I N E =======================================
.text$mn:00004508
.text$mn:00004508 ; Attributes: bp-based frame
.text$mn:00004508
.text$mn:00004508 ; public: struct std::_Container_proxy * __thiscall std::allocator<struct std::_Container_proxy>::allocate(unsigned int)
.text$mn:00004508                 public ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
.text$mn:00004508 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z proc near
.text$mn:00004508                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Alloc_proxy(void)+16p
.text$mn:00004508                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::allocate(uint)+Ep
.text$mn:00004508
.text$mn:00004508 var_4           = dword ptr -4
.text$mn:00004508 arg_0           = dword ptr  8
.text$mn:00004508
.text$mn:00004508                 push    ebp
.text$mn:00004509                 mov     ebp, esp
.text$mn:0000450B                 push    ecx
.text$mn:0000450C                 mov     [ebp+var_4], ecx
.text$mn:0000450F                 push    0
.text$mn:00004511                 mov     eax, [ebp+arg_0]
.text$mn:00004514                 push    eax
.text$mn:00004515                 call    ??$_Allocate@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@IPAU10@@Z ; std::_Allocate<std::_Container_proxy>(uint,std::_Container_proxy *)
.text$mn:0000451A                 add     esp, 8
.text$mn:0000451D                 mov     esp, ebp
.text$mn:0000451F                 pop     ebp
.text$mn:00004520                 retn    4
.text$mn:00004520 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z endp
.text$mn:00004520
.text$mn:00004520 ; ---------------------------------------------------------------------------
.text$mn:00004523                 align 4
.text$mn:00004523 _text$mn        ends
.text$mn:00004523
.text$mn:00004524 ; ===========================================================================
.text$mn:00004524
.text$mn:00004524 ; Segment type: Pure code
.text$mn:00004524 ; Segment permissions: Read/Execute
.text$mn:00004524 _text$mn        segment para public 'CODE' use32
.text$mn:00004524                 assume cs:_text$mn
.text$mn:00004524                 ;org 4524h
.text$mn:00004524 ; COMDAT (pick any)
.text$mn:00004524                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004524
.text$mn:00004524 ; =============== S U B R O U T I N E =======================================
.text$mn:00004524
.text$mn:00004524 ; Attributes: bp-based frame
.text$mn:00004524
.text$mn:00004524 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::assign(class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> const &, unsigned int, unsigned int)
.text$mn:00004524                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
.text$mn:00004524 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z proc near
.text$mn:00004524                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+4Fp
.text$mn:00004524
.text$mn:00004524 Size            = dword ptr -8
.text$mn:00004524 var_4           = dword ptr -4
.text$mn:00004524 arg_0           = dword ptr  8
.text$mn:00004524 arg_4           = dword ptr  0Ch
.text$mn:00004524 arg_8           = dword ptr  10h
.text$mn:00004524
.text$mn:00004524                 push    ebp
.text$mn:00004525                 mov     ebp, esp
.text$mn:00004527                 sub     esp, 8
.text$mn:0000452A                 mov     [ebp+var_4], ecx
.text$mn:0000452D                 mov     ecx, [ebp+arg_0]
.text$mn:00004530                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:00004535                 cmp     eax, [ebp+arg_4]
.text$mn:00004538                 jnb     short loc_4542
.text$mn:0000453A                 mov     ecx, [ebp+var_4]
.text$mn:0000453D                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00004542
.text$mn:00004542 loc_4542:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+14j
.text$mn:00004542                 mov     ecx, [ebp+arg_0]
.text$mn:00004545                 call    ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::size(void)
.text$mn:0000454A                 sub     eax, [ebp+arg_4]
.text$mn:0000454D                 mov     [ebp+Size], eax
.text$mn:00004550                 mov     eax, [ebp+arg_8]
.text$mn:00004553                 cmp     eax, [ebp+Size]
.text$mn:00004556                 jnb     short loc_455E
.text$mn:00004558                 mov     ecx, [ebp+arg_8]
.text$mn:0000455B                 mov     [ebp+Size], ecx
.text$mn:0000455E
.text$mn:0000455E loc_455E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+32j
.text$mn:0000455E                 mov     edx, [ebp+var_4]
.text$mn:00004561                 cmp     edx, [ebp+arg_0]
.text$mn:00004564                 jnz     short loc_4585
.text$mn:00004566                 mov     eax, [ebp+arg_4]
.text$mn:00004569                 add     eax, [ebp+Size]
.text$mn:0000456C                 push    eax
.text$mn:0000456D                 mov     ecx, [ebp+var_4]
.text$mn:00004570                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)
.text$mn:00004575                 mov     ecx, [ebp+arg_4]
.text$mn:00004578                 push    ecx
.text$mn:00004579                 push    0
.text$mn:0000457B                 mov     ecx, [ebp+var_4]
.text$mn:0000457E                 call    ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)
.text$mn:00004583                 jmp     short loc_45C7
.text$mn:00004585 ; ---------------------------------------------------------------------------
.text$mn:00004585
.text$mn:00004585 loc_4585:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+40j
.text$mn:00004585                 push    0
.text$mn:00004587                 mov     edx, [ebp+Size]
.text$mn:0000458A                 push    edx
.text$mn:0000458B                 mov     ecx, [ebp+var_4]
.text$mn:0000458E                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00004593                 movzx   eax, al
.text$mn:00004596                 test    eax, eax
.text$mn:00004598                 jz      short loc_45C7
.text$mn:0000459A                 mov     ecx, [ebp+Size]
.text$mn:0000459D                 push    ecx             ; Size
.text$mn:0000459E                 mov     ecx, [ebp+arg_0]
.text$mn:000045A1                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000045A6                 add     eax, [ebp+arg_4]
.text$mn:000045A9                 push    eax             ; Src
.text$mn:000045AA                 mov     ecx, [ebp+var_4]
.text$mn:000045AD                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:000045B2                 push    eax             ; Dst
.text$mn:000045B3                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:000045B8                 add     esp, 0Ch
.text$mn:000045BB                 mov     edx, [ebp+Size]
.text$mn:000045BE                 push    edx
.text$mn:000045BF                 mov     ecx, [ebp+var_4]
.text$mn:000045C2                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:000045C7
.text$mn:000045C7 loc_45C7:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Fj
.text$mn:000045C7                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+74j
.text$mn:000045C7                 mov     eax, [ebp+var_4]
.text$mn:000045CA                 mov     esp, ebp
.text$mn:000045CC                 pop     ebp
.text$mn:000045CD                 retn    0Ch
.text$mn:000045CD ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z endp
.text$mn:000045CD
.text$mn:000045CD _text$mn        ends
.text$mn:000045CD
.text$mn:000045D0 ; ===========================================================================
.text$mn:000045D0
.text$mn:000045D0 ; Segment type: Pure code
.text$mn:000045D0 ; Segment permissions: Read/Execute
.text$mn:000045D0 _text$mn        segment para public 'CODE' use32
.text$mn:000045D0                 assume cs:_text$mn
.text$mn:000045D0                 ;org 45D0h
.text$mn:000045D0 ; COMDAT (pick any)
.text$mn:000045D0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000045D0
.text$mn:000045D0 ; =============== S U B R O U T I N E =======================================
.text$mn:000045D0
.text$mn:000045D0 ; Attributes: bp-based frame
.text$mn:000045D0
.text$mn:000045D0 ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char *Str)
.text$mn:000045D0                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
.text$mn:000045D0 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z proc near
.text$mn:000045D0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)+53p
.text$mn:000045D0
.text$mn:000045D0 var_4           = dword ptr -4
.text$mn:000045D0 Str             = dword ptr  8
.text$mn:000045D0
.text$mn:000045D0                 push    ebp
.text$mn:000045D1                 mov     ebp, esp
.text$mn:000045D3                 push    ecx
.text$mn:000045D4                 mov     [ebp+var_4], ecx
.text$mn:000045D7                 push    490h            ; unsigned int
.text$mn:000045DC                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:000045E1                 mov     eax, [ebp+Str]
.text$mn:000045E4                 push    eax             ; int
.text$mn:000045E5                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:000045EA                 add     esp, 0Ch
.text$mn:000045ED                 mov     ecx, [ebp+Str]
.text$mn:000045F0                 push    ecx             ; Str
.text$mn:000045F1                 call    ?length@?$char_traits@D@std@@SAIPBD@Z ; std::char_traits<char>::length(char const *)
.text$mn:000045F6                 add     esp, 4
.text$mn:000045F9                 push    eax             ; Size
.text$mn:000045FA                 mov     edx, [ebp+Str]
.text$mn:000045FD                 push    edx             ; Src
.text$mn:000045FE                 mov     ecx, [ebp+var_4]
.text$mn:00004601                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)
.text$mn:00004606                 mov     esp, ebp
.text$mn:00004608                 pop     ebp
.text$mn:00004609                 retn    4
.text$mn:00004609 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z endp
.text$mn:00004609
.text$mn:00004609 _text$mn        ends
.text$mn:00004609
.text$mn:0000460C ; ===========================================================================
.text$mn:0000460C
.text$mn:0000460C ; Segment type: Pure code
.text$mn:0000460C ; Segment permissions: Read/Execute
.text$mn:0000460C _text$mn        segment para public 'CODE' use32
.text$mn:0000460C                 assume cs:_text$mn
.text$mn:0000460C                 ;org 460Ch
.text$mn:0000460C ; COMDAT (pick any)
.text$mn:0000460C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000460C
.text$mn:0000460C ; =============== S U B R O U T I N E =======================================
.text$mn:0000460C
.text$mn:0000460C ; Attributes: bp-based frame
.text$mn:0000460C
.text$mn:0000460C ; int __stdcall std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(void *Src, size_t Size)
.text$mn:0000460C                 public ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
.text$mn:0000460C ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z proc near
.text$mn:0000460C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+31p
.text$mn:0000460C
.text$mn:0000460C var_4           = dword ptr -4
.text$mn:0000460C Src             = dword ptr  8
.text$mn:0000460C Size            = dword ptr  0Ch
.text$mn:0000460C
.text$mn:0000460C                 push    ebp
.text$mn:0000460D                 mov     ebp, esp
.text$mn:0000460F                 push    ecx
.text$mn:00004610                 mov     [ebp+var_4], ecx
.text$mn:00004613                 cmp     [ebp+Size], 0
.text$mn:00004617                 jz      short loc_462F
.text$mn:00004619                 push    47Fh            ; unsigned int
.text$mn:0000461E                 push    offset ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; "C:\\Program Files (x86)\\Microsoft Visu"...
.text$mn:00004623                 mov     eax, [ebp+Src]
.text$mn:00004626                 push    eax             ; int
.text$mn:00004627                 call    ??$_Debug_pointer@D@std@@YAXPBDPB_WI@Z ; std::_Debug_pointer<char>(char const *,wchar_t const *,uint)
.text$mn:0000462C                 add     esp, 0Ch
.text$mn:0000462F
.text$mn:0000462F loc_462F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+Bj
.text$mn:0000462F                 mov     ecx, [ebp+Src]
.text$mn:00004632                 push    ecx
.text$mn:00004633                 mov     ecx, [ebp+var_4]
.text$mn:00004636                 call    ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Inside(char const *)
.text$mn:0000463B                 movzx   edx, al
.text$mn:0000463E                 test    edx, edx
.text$mn:00004640                 jz      short loc_4662
.text$mn:00004642                 mov     eax, [ebp+Size]
.text$mn:00004645                 push    eax
.text$mn:00004646                 mov     ecx, [ebp+var_4]
.text$mn:00004649                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:0000464E                 mov     ecx, [ebp+Src]
.text$mn:00004651                 sub     ecx, eax
.text$mn:00004653                 push    ecx
.text$mn:00004654                 mov     edx, [ebp+var_4]
.text$mn:00004657                 push    edx
.text$mn:00004658                 mov     ecx, [ebp+var_4]
.text$mn:0000465B                 call    ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)
.text$mn:00004660                 jmp     short loc_469F
.text$mn:00004662 ; ---------------------------------------------------------------------------
.text$mn:00004662
.text$mn:00004662 loc_4662:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+34j
.text$mn:00004662                 push    0
.text$mn:00004664                 mov     eax, [ebp+Size]
.text$mn:00004667                 push    eax
.text$mn:00004668                 mov     ecx, [ebp+var_4]
.text$mn:0000466B                 call    ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Grow(uint,bool)
.text$mn:00004670                 movzx   ecx, al
.text$mn:00004673                 test    ecx, ecx
.text$mn:00004675                 jz      short loc_469C
.text$mn:00004677                 mov     edx, [ebp+Size]
.text$mn:0000467A                 push    edx             ; Size
.text$mn:0000467B                 mov     eax, [ebp+Src]
.text$mn:0000467E                 push    eax             ; Src
.text$mn:0000467F                 mov     ecx, [ebp+var_4]
.text$mn:00004682                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004687                 push    eax             ; Dst
.text$mn:00004688                 call    ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::copy(char *,char const *,uint)
.text$mn:0000468D                 add     esp, 0Ch
.text$mn:00004690                 mov     ecx, [ebp+Size]
.text$mn:00004693                 push    ecx
.text$mn:00004694                 mov     ecx, [ebp+var_4]
.text$mn:00004697                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:0000469C
.text$mn:0000469C loc_469C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+69j
.text$mn:0000469C                 mov     eax, [ebp+var_4]
.text$mn:0000469F
.text$mn:0000469F loc_469F:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+54j
.text$mn:0000469F                 mov     esp, ebp
.text$mn:000046A1                 pop     ebp
.text$mn:000046A2                 retn    8
.text$mn:000046A2 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z endp
.text$mn:000046A2
.text$mn:000046A2 ; ---------------------------------------------------------------------------
.text$mn:000046A5                 align 4
.text$mn:000046A5 _text$mn        ends
.text$mn:000046A5
.text$mn:000046A8 ; ===========================================================================
.text$mn:000046A8
.text$mn:000046A8 ; Segment type: Pure code
.text$mn:000046A8 ; Segment permissions: Read/Execute
.text$mn:000046A8 _text$mn        segment para public 'CODE' use32
.text$mn:000046A8                 assume cs:_text$mn
.text$mn:000046A8                 ;org 46A8h
.text$mn:000046A8 ; COMDAT (pick any)
.text$mn:000046A8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046A8
.text$mn:000046A8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046A8
.text$mn:000046A8 ; Attributes: bp-based frame
.text$mn:000046A8
.text$mn:000046A8 ; public: static void __cdecl std::char_traits<char>::assign(char &, char const &)
.text$mn:000046A8                 public ?assign@?$char_traits@D@std@@SAXAADABD@Z
.text$mn:000046A8 ?assign@?$char_traits@D@std@@SAXAADABD@Z proc near
.text$mn:000046A8                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)+26p
.text$mn:000046A8
.text$mn:000046A8 arg_0           = dword ptr  8
.text$mn:000046A8 arg_4           = dword ptr  0Ch
.text$mn:000046A8
.text$mn:000046A8                 push    ebp
.text$mn:000046A9                 mov     ebp, esp
.text$mn:000046AB                 mov     eax, [ebp+arg_0]
.text$mn:000046AE                 mov     ecx, [ebp+arg_4]
.text$mn:000046B1                 mov     dl, [ecx]
.text$mn:000046B3                 mov     [eax], dl
.text$mn:000046B5                 pop     ebp
.text$mn:000046B6                 retn
.text$mn:000046B6 ?assign@?$char_traits@D@std@@SAXAADABD@Z endp
.text$mn:000046B6
.text$mn:000046B6 ; ---------------------------------------------------------------------------
.text$mn:000046B7                 align 4
.text$mn:000046B7 _text$mn        ends
.text$mn:000046B7
.text$mn:000046B8 ; ===========================================================================
.text$mn:000046B8
.text$mn:000046B8 ; Segment type: Pure code
.text$mn:000046B8 ; Segment permissions: Read/Execute
.text$mn:000046B8 _text$mn        segment para public 'CODE' use32
.text$mn:000046B8                 assume cs:_text$mn
.text$mn:000046B8                 ;org 46B8h
.text$mn:000046B8 ; COMDAT (pick any)
.text$mn:000046B8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000046B8
.text$mn:000046B8 ; =============== S U B R O U T I N E =======================================
.text$mn:000046B8
.text$mn:000046B8 ; Attributes: bp-based frame
.text$mn:000046B8
.text$mn:000046B8 ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>> __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::begin(void)const
.text$mn:000046B8                 public ?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.text$mn:000046B8 ?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ proc near
.text$mn:000046B8                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+A7p
.text$mn:000046B8
.text$mn:000046B8 var_14          = dword ptr -14h
.text$mn:000046B8 var_10          = dword ptr -10h
.text$mn:000046B8 var_C           = dword ptr -0Ch
.text$mn:000046B8 var_4           = dword ptr -4
.text$mn:000046B8 arg_0           = dword ptr  8
.text$mn:000046B8
.text$mn:000046B8                 push    ebp
.text$mn:000046B9                 mov     ebp, esp
.text$mn:000046BB                 push    0FFFFFFFFh
.text$mn:000046BD                 push    offset __ehhandler$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.text$mn:000046C2                 mov     eax, large fs:0
.text$mn:000046C8                 push    eax
.text$mn:000046C9                 sub     esp, 8
.text$mn:000046CC                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000046D1                 xor     eax, ebp
.text$mn:000046D3                 push    eax
.text$mn:000046D4                 lea     eax, [ebp+var_C]
.text$mn:000046D7                 mov     large fs:0, eax
.text$mn:000046DD                 mov     [ebp+var_10], ecx
.text$mn:000046E0                 mov     [ebp+var_14], 0
.text$mn:000046E7                 mov     eax, [ebp+var_10]
.text$mn:000046EA                 push    eax             ; struct std::_Container_base12 *
.text$mn:000046EB                 mov     ecx, [ebp+var_10]
.text$mn:000046EE                 mov     edx, [ecx+4]
.text$mn:000046F1                 push    edx             ; int
.text$mn:000046F2                 mov     ecx, [ebp+arg_0]
.text$mn:000046F5                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(DockingCont * *,std::_Container_base12 const *)
.text$mn:000046FA                 mov     [ebp+var_4], 0
.text$mn:00004701                 mov     eax, [ebp+var_14]
.text$mn:00004704                 or      eax, 1
.text$mn:00004707                 mov     [ebp+var_14], eax
.text$mn:0000470A                 mov     eax, [ebp+arg_0]
.text$mn:0000470D                 mov     ecx, [ebp+var_C]
.text$mn:00004710                 mov     large fs:0, ecx
.text$mn:00004717                 pop     ecx
.text$mn:00004718                 mov     esp, ebp
.text$mn:0000471A                 pop     ebp
.text$mn:0000471B                 retn    4
.text$mn:0000471B ?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ endp
.text$mn:0000471B
.text$mn:0000471B ; ---------------------------------------------------------------------------
.text$mn:0000471E                 align 10h
.text$mn:0000471E _text$mn        ends
.text$mn:0000471E
.text$x:00004720 ; ===========================================================================
.text$x:00004720
.text$x:00004720 ; Segment type: Pure code
.text$x:00004720 ; Segment permissions: Read/Execute
.text$x:00004720 _text$x         segment para public 'CODE' use32
.text$x:00004720                 assume cs:_text$x
.text$x:00004720                 ;org 4720h
.text$x:00004720 ; COMDAT (pick associative to section at 46B8)
.text$x:00004720                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004720
.text$x:00004720 ; =============== S U B R O U T I N E =======================================
.text$x:00004720
.text$x:00004720
.text$x:00004720 __unwindfunclet$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0 proc near
.text$x:00004720                                         ; DATA XREF: .xdata$x:00005628o
.text$x:00004720                 mov     eax, [ebp-14h]
.text$x:00004723                 and     eax, 1
.text$x:00004726                 jz      $LN4_0
.text$x:0000472C                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00004730                 mov     ecx, [ebp+8]
.text$x:00004733                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:00004738 ; ---------------------------------------------------------------------------
.text$x:00004738
.text$x:00004738 $LN4_0:                                 ; CODE XREF: __unwindfunclet$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0+6j
.text$x:00004738                 retn
.text$x:00004738 __unwindfunclet$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0 endp
.text$x:00004738
.text$x:00004739
.text$x:00004739 ; =============== S U B R O U T I N E =======================================
.text$x:00004739
.text$x:00004739
.text$x:00004739 __ehhandler$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ proc near
.text$x:00004739                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::begin(void)+5o
.text$x:00004739
.text$x:00004739 arg_4           = dword ptr  8
.text$x:00004739
.text$x:00004739                 mov     edx, [esp+arg_4]
.text$x:0000473D                 lea     eax, [edx+0Ch]
.text$x:00004740                 mov     ecx, [edx-0Ch]
.text$x:00004743                 xor     ecx, eax
.text$x:00004745                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000474A                 mov     eax, offset __ehfuncinfo$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.text$x:0000474F                 jmp     ___CxxFrameHandler3
.text$x:0000474F __ehhandler$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ endp
.text$x:0000474F
.text$x:0000474F _text$x         ends
.text$x:0000474F
.text$mn:00004754 ; ===========================================================================
.text$mn:00004754
.text$mn:00004754 ; Segment type: Pure code
.text$mn:00004754 ; Segment permissions: Read/Execute
.text$mn:00004754 _text$mn        segment para public 'CODE' use32
.text$mn:00004754                 assume cs:_text$mn
.text$mn:00004754                 ;org 4754h
.text$mn:00004754 ; COMDAT (pick any)
.text$mn:00004754                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004754
.text$mn:00004754 ; =============== S U B R O U T I N E =======================================
.text$mn:00004754
.text$mn:00004754 ; Attributes: bp-based frame
.text$mn:00004754
.text$mn:00004754 ; const struct std::error_category *__thiscall std::error_code::category(std::error_code *__hidden this)
.text$mn:00004754                 public ?category@error_code@std@@QBEABVerror_category@2@XZ
.text$mn:00004754 ?category@error_code@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00004754                                         ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+Cp
.text$mn:00004754
.text$mn:00004754 var_4           = dword ptr -4
.text$mn:00004754
.text$mn:00004754                 push    ebp
.text$mn:00004755                 mov     ebp, esp
.text$mn:00004757                 push    ecx
.text$mn:00004758                 mov     [ebp+var_4], ecx
.text$mn:0000475B                 mov     eax, [ebp+var_4]
.text$mn:0000475E                 mov     eax, [eax+4]
.text$mn:00004761                 mov     esp, ebp
.text$mn:00004763                 pop     ebp
.text$mn:00004764                 retn
.text$mn:00004764 ?category@error_code@std@@QBEABVerror_category@2@XZ endp
.text$mn:00004764
.text$mn:00004764 ; ---------------------------------------------------------------------------
.text$mn:00004765                 align 4
.text$mn:00004765 _text$mn        ends
.text$mn:00004765
.text$mn:00004768 ; ===========================================================================
.text$mn:00004768
.text$mn:00004768 ; Segment type: Pure code
.text$mn:00004768 ; Segment permissions: Read/Execute
.text$mn:00004768 _text$mn        segment para public 'CODE' use32
.text$mn:00004768                 assume cs:_text$mn
.text$mn:00004768                 ;org 4768h
.text$mn:00004768 ; COMDAT (pick any)
.text$mn:00004768                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004768
.text$mn:00004768 ; =============== S U B R O U T I N E =======================================
.text$mn:00004768
.text$mn:00004768 ; Attributes: bp-based frame
.text$mn:00004768
.text$mn:00004768 ; const struct std::error_category *__thiscall std::error_condition::category(std::error_condition *__hidden this)
.text$mn:00004768                 public ?category@error_condition@std@@QBEABVerror_category@2@XZ
.text$mn:00004768 ?category@error_condition@std@@QBEABVerror_category@2@XZ proc near
.text$mn:00004768                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+Dp
.text$mn:00004768                                         ; std::error_condition::operator==(std::error_condition const &)+16p
.text$mn:00004768
.text$mn:00004768 var_4           = dword ptr -4
.text$mn:00004768
.text$mn:00004768                 push    ebp
.text$mn:00004769                 mov     ebp, esp
.text$mn:0000476B                 push    ecx
.text$mn:0000476C                 mov     [ebp+var_4], ecx
.text$mn:0000476F                 mov     eax, [ebp+var_4]
.text$mn:00004772                 mov     eax, [eax+4]
.text$mn:00004775                 mov     esp, ebp
.text$mn:00004777                 pop     ebp
.text$mn:00004778                 retn
.text$mn:00004778 ?category@error_condition@std@@QBEABVerror_category@2@XZ endp
.text$mn:00004778
.text$mn:00004778 ; ---------------------------------------------------------------------------
.text$mn:00004779                 align 4
.text$mn:00004779 _text$mn        ends
.text$mn:00004779
.text$mn:0000477C ; ===========================================================================
.text$mn:0000477C
.text$mn:0000477C ; Segment type: Pure code
.text$mn:0000477C ; Segment permissions: Read/Execute
.text$mn:0000477C _text$mn        segment para public 'CODE' use32
.text$mn:0000477C                 assume cs:_text$mn
.text$mn:0000477C                 ;org 477Ch
.text$mn:0000477C ; COMDAT (pick any)
.text$mn:0000477C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000477C
.text$mn:0000477C ; =============== S U B R O U T I N E =======================================
.text$mn:0000477C
.text$mn:0000477C ; Attributes: bp-based frame
.text$mn:0000477C
.text$mn:0000477C ; int __cdecl std::char_traits<char>::copy(void *Dst, void *Src, size_t Size)
.text$mn:0000477C                 public ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:0000477C ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z proc near ; CODE XREF: $LN19+1Ep
.text$mn:0000477C                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+5Dp ...
.text$mn:0000477C
.text$mn:0000477C var_4           = dword ptr -4
.text$mn:0000477C Dst             = dword ptr  8
.text$mn:0000477C Src             = dword ptr  0Ch
.text$mn:0000477C Size            = dword ptr  10h
.text$mn:0000477C
.text$mn:0000477C                 push    ebp
.text$mn:0000477D                 mov     ebp, esp
.text$mn:0000477F                 push    ecx
.text$mn:00004780                 cmp     [ebp+Size], 0
.text$mn:00004784                 jnz     short loc_478E
.text$mn:00004786                 mov     eax, [ebp+Dst]
.text$mn:00004789                 mov     [ebp+var_4], eax
.text$mn:0000478C                 jmp     short loc_47A5
.text$mn:0000478E ; ---------------------------------------------------------------------------
.text$mn:0000478E
.text$mn:0000478E loc_478E:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+8j
.text$mn:0000478E                 mov     ecx, [ebp+Size]
.text$mn:00004791                 push    ecx             ; Size
.text$mn:00004792                 mov     edx, [ebp+Src]
.text$mn:00004795                 push    edx             ; Src
.text$mn:00004796                 mov     eax, [ebp+Dst]
.text$mn:00004799                 push    eax             ; Dst
.text$mn:0000479A                 call    _memcpy
.text$mn:0000479F                 add     esp, 0Ch
.text$mn:000047A2                 mov     [ebp+var_4], eax
.text$mn:000047A5
.text$mn:000047A5 loc_47A5:                               ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+10j
.text$mn:000047A5                 mov     eax, [ebp+var_4]
.text$mn:000047A8                 mov     esp, ebp
.text$mn:000047AA                 pop     ebp
.text$mn:000047AB                 retn
.text$mn:000047AB ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:000047AB
.text$mn:000047AB _text$mn        ends
.text$mn:000047AB
.text$mn:000047AC ; ===========================================================================
.text$mn:000047AC
.text$mn:000047AC ; Segment type: Pure code
.text$mn:000047AC ; Segment permissions: Read/Execute
.text$mn:000047AC _text$mn        segment para public 'CODE' use32
.text$mn:000047AC                 assume cs:_text$mn
.text$mn:000047AC                 ;org 47ACh
.text$mn:000047AC ; COMDAT (pick any)
.text$mn:000047AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047AC
.text$mn:000047AC ; =============== S U B R O U T I N E =======================================
.text$mn:000047AC
.text$mn:000047AC ; Attributes: bp-based frame
.text$mn:000047AC
.text$mn:000047AC ; int __stdcall std::_Wrap_alloc<std::allocator<char>>::deallocate(void *, int)
.text$mn:000047AC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
.text$mn:000047AC ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z proc near
.text$mn:000047AC                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Tidy(bool,uint)+81p
.text$mn:000047AC
.text$mn:000047AC var_4           = dword ptr -4
.text$mn:000047AC arg_0           = dword ptr  8
.text$mn:000047AC arg_4           = dword ptr  0Ch
.text$mn:000047AC
.text$mn:000047AC                 push    ebp
.text$mn:000047AD                 mov     ebp, esp
.text$mn:000047AF                 push    ecx
.text$mn:000047B0                 mov     [ebp+var_4], ecx
.text$mn:000047B3                 mov     eax, [ebp+arg_4]
.text$mn:000047B6                 push    eax             ; int
.text$mn:000047B7                 mov     ecx, [ebp+arg_0]
.text$mn:000047BA                 push    ecx             ; void *
.text$mn:000047BB                 mov     ecx, [ebp+var_4]
.text$mn:000047BE                 call    ?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate(char *,uint)
.text$mn:000047C3                 mov     esp, ebp
.text$mn:000047C5                 pop     ebp
.text$mn:000047C6                 retn    8
.text$mn:000047C6 ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z endp
.text$mn:000047C6
.text$mn:000047C6 ; ---------------------------------------------------------------------------
.text$mn:000047C9                 align 4
.text$mn:000047C9 _text$mn        ends
.text$mn:000047C9
.text$mn:000047CC ; ===========================================================================
.text$mn:000047CC
.text$mn:000047CC ; Segment type: Pure code
.text$mn:000047CC ; Segment permissions: Read/Execute
.text$mn:000047CC _text$mn        segment para public 'CODE' use32
.text$mn:000047CC                 assume cs:_text$mn
.text$mn:000047CC                 ;org 47CCh
.text$mn:000047CC ; COMDAT (pick any)
.text$mn:000047CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047CC
.text$mn:000047CC ; =============== S U B R O U T I N E =======================================
.text$mn:000047CC
.text$mn:000047CC ; Attributes: bp-based frame
.text$mn:000047CC
.text$mn:000047CC ; int __stdcall std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(void *, int)
.text$mn:000047CC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z
.text$mn:000047CC ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z proc near
.text$mn:000047CC                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Tidy(void)+55p
.text$mn:000047CC
.text$mn:000047CC var_4           = dword ptr -4
.text$mn:000047CC arg_0           = dword ptr  8
.text$mn:000047CC arg_4           = dword ptr  0Ch
.text$mn:000047CC
.text$mn:000047CC                 push    ebp
.text$mn:000047CD                 mov     ebp, esp
.text$mn:000047CF                 push    ecx
.text$mn:000047D0                 mov     [ebp+var_4], ecx
.text$mn:000047D3                 mov     eax, [ebp+arg_4]
.text$mn:000047D6                 push    eax             ; int
.text$mn:000047D7                 mov     ecx, [ebp+arg_0]
.text$mn:000047DA                 push    ecx             ; void *
.text$mn:000047DB                 mov     ecx, [ebp+var_4]
.text$mn:000047DE                 call    ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z ; std::allocator<DockingCont *>::deallocate(DockingCont * *,uint)
.text$mn:000047E3                 mov     esp, ebp
.text$mn:000047E5                 pop     ebp
.text$mn:000047E6                 retn    8
.text$mn:000047E6 ?deallocate@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAEXPAPAVDockingCont@@I@Z endp
.text$mn:000047E6
.text$mn:000047E6 ; ---------------------------------------------------------------------------
.text$mn:000047E9                 align 4
.text$mn:000047E9 _text$mn        ends
.text$mn:000047E9
.text$mn:000047EC ; ===========================================================================
.text$mn:000047EC
.text$mn:000047EC ; Segment type: Pure code
.text$mn:000047EC ; Segment permissions: Read/Execute
.text$mn:000047EC _text$mn        segment para public 'CODE' use32
.text$mn:000047EC                 assume cs:_text$mn
.text$mn:000047EC                 ;org 47ECh
.text$mn:000047EC ; COMDAT (pick any)
.text$mn:000047EC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000047EC
.text$mn:000047EC ; =============== S U B R O U T I N E =======================================
.text$mn:000047EC
.text$mn:000047EC ; Attributes: bp-based frame
.text$mn:000047EC
.text$mn:000047EC ; int __stdcall std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(void *, int)
.text$mn:000047EC                 public ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:000047EC ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:000047EC                                         ; CODE XREF: std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Free_proxy(void)+32p
.text$mn:000047EC
.text$mn:000047EC var_4           = dword ptr -4
.text$mn:000047EC arg_0           = dword ptr  8
.text$mn:000047EC arg_4           = dword ptr  0Ch
.text$mn:000047EC
.text$mn:000047EC                 push    ebp
.text$mn:000047ED                 mov     ebp, esp
.text$mn:000047EF                 push    ecx
.text$mn:000047F0                 mov     [ebp+var_4], ecx
.text$mn:000047F3                 mov     eax, [ebp+arg_4]
.text$mn:000047F6                 push    eax             ; int
.text$mn:000047F7                 mov     ecx, [ebp+arg_0]
.text$mn:000047FA                 push    ecx             ; void *
.text$mn:000047FB                 mov     ecx, [ebp+var_4]
.text$mn:000047FE                 call    ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate(std::_Container_proxy *,uint)
.text$mn:00004803                 mov     esp, ebp
.text$mn:00004805                 pop     ebp
.text$mn:00004806                 retn    8
.text$mn:00004806 ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:00004806
.text$mn:00004806 ; ---------------------------------------------------------------------------
.text$mn:00004809                 align 4
.text$mn:00004809 _text$mn        ends
.text$mn:00004809
.text$mn:0000480C ; ===========================================================================
.text$mn:0000480C
.text$mn:0000480C ; Segment type: Pure code
.text$mn:0000480C ; Segment permissions: Read/Execute
.text$mn:0000480C _text$mn        segment para public 'CODE' use32
.text$mn:0000480C                 assume cs:_text$mn
.text$mn:0000480C                 ;org 480Ch
.text$mn:0000480C ; COMDAT (pick any)
.text$mn:0000480C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:0000480C
.text$mn:0000480C ; =============== S U B R O U T I N E =======================================
.text$mn:0000480C
.text$mn:0000480C ; Attributes: bp-based frame
.text$mn:0000480C
.text$mn:0000480C ; int __stdcall std::allocator<char>::deallocate(void *, int)
.text$mn:0000480C                 public ?deallocate@?$allocator@D@std@@QAEXPADI@Z
.text$mn:0000480C ?deallocate@?$allocator@D@std@@QAEXPADI@Z proc near
.text$mn:0000480C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::deallocate(char *,uint)+12p
.text$mn:0000480C
.text$mn:0000480C var_4           = dword ptr -4
.text$mn:0000480C arg_0           = dword ptr  8
.text$mn:0000480C
.text$mn:0000480C                 push    ebp
.text$mn:0000480D                 mov     ebp, esp
.text$mn:0000480F                 push    ecx
.text$mn:00004810                 mov     [ebp+var_4], ecx
.text$mn:00004813                 mov     eax, [ebp+arg_0]
.text$mn:00004816                 push    eax             ; void *
.text$mn:00004817                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:0000481C                 add     esp, 4
.text$mn:0000481F                 mov     esp, ebp
.text$mn:00004821                 pop     ebp
.text$mn:00004822                 retn    8
.text$mn:00004822 ?deallocate@?$allocator@D@std@@QAEXPADI@Z endp
.text$mn:00004822
.text$mn:00004822 ; ---------------------------------------------------------------------------
.text$mn:00004825                 align 4
.text$mn:00004825 _text$mn        ends
.text$mn:00004825
.text$mn:00004828 ; ===========================================================================
.text$mn:00004828
.text$mn:00004828 ; Segment type: Pure code
.text$mn:00004828 ; Segment permissions: Read/Execute
.text$mn:00004828 _text$mn        segment para public 'CODE' use32
.text$mn:00004828                 assume cs:_text$mn
.text$mn:00004828                 ;org 4828h
.text$mn:00004828 ; COMDAT (pick any)
.text$mn:00004828                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004828
.text$mn:00004828 ; =============== S U B R O U T I N E =======================================
.text$mn:00004828
.text$mn:00004828 ; Attributes: bp-based frame
.text$mn:00004828
.text$mn:00004828 ; int __stdcall std::allocator<DockingCont *>::deallocate(void *, int)
.text$mn:00004828                 public ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z
.text$mn:00004828 ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z proc near
.text$mn:00004828                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::deallocate(DockingCont * *,uint)+12p
.text$mn:00004828
.text$mn:00004828 var_4           = dword ptr -4
.text$mn:00004828 arg_0           = dword ptr  8
.text$mn:00004828
.text$mn:00004828                 push    ebp
.text$mn:00004829                 mov     ebp, esp
.text$mn:0000482B                 push    ecx
.text$mn:0000482C                 mov     [ebp+var_4], ecx
.text$mn:0000482F                 mov     eax, [ebp+arg_0]
.text$mn:00004832                 push    eax             ; void *
.text$mn:00004833                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004838                 add     esp, 4
.text$mn:0000483B                 mov     esp, ebp
.text$mn:0000483D                 pop     ebp
.text$mn:0000483E                 retn    8
.text$mn:0000483E ?deallocate@?$allocator@PAVDockingCont@@@std@@QAEXPAPAVDockingCont@@I@Z endp
.text$mn:0000483E
.text$mn:0000483E ; ---------------------------------------------------------------------------
.text$mn:00004841                 align 4
.text$mn:00004841 _text$mn        ends
.text$mn:00004841
.text$mn:00004844 ; ===========================================================================
.text$mn:00004844
.text$mn:00004844 ; Segment type: Pure code
.text$mn:00004844 ; Segment permissions: Read/Execute
.text$mn:00004844 _text$mn        segment para public 'CODE' use32
.text$mn:00004844                 assume cs:_text$mn
.text$mn:00004844                 ;org 4844h
.text$mn:00004844 ; COMDAT (pick any)
.text$mn:00004844                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004844
.text$mn:00004844 ; =============== S U B R O U T I N E =======================================
.text$mn:00004844
.text$mn:00004844 ; Attributes: bp-based frame
.text$mn:00004844
.text$mn:00004844 ; int __stdcall std::allocator<std::_Container_proxy>::deallocate(void *, int)
.text$mn:00004844                 public ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
.text$mn:00004844 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z proc near
.text$mn:00004844                                         ; CODE XREF: std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Free_proxy(void)+32p
.text$mn:00004844                                         ; std::_Wrap_alloc<std::allocator<std::_Container_proxy>>::deallocate(std::_Container_proxy *,uint)+12p
.text$mn:00004844
.text$mn:00004844 var_4           = dword ptr -4
.text$mn:00004844 arg_0           = dword ptr  8
.text$mn:00004844
.text$mn:00004844                 push    ebp
.text$mn:00004845                 mov     ebp, esp
.text$mn:00004847                 push    ecx
.text$mn:00004848                 mov     [ebp+var_4], ecx
.text$mn:0000484B                 mov     eax, [ebp+arg_0]
.text$mn:0000484E                 push    eax             ; void *
.text$mn:0000484F                 call    ??3@YAXPAX@Z    ; operator delete(void *)
.text$mn:00004854                 add     esp, 4
.text$mn:00004857                 mov     esp, ebp
.text$mn:00004859                 pop     ebp
.text$mn:0000485A                 retn    8
.text$mn:0000485A ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z endp
.text$mn:0000485A
.text$mn:0000485A ; ---------------------------------------------------------------------------
.text$mn:0000485D                 align 10h
.text$mn:0000485D _text$mn        ends
.text$mn:0000485D
.text$mn:00004860 ; ===========================================================================
.text$mn:00004860
.text$mn:00004860 ; Segment type: Pure code
.text$mn:00004860 ; Segment permissions: Read/Execute
.text$mn:00004860 _text$mn        segment para public 'CODE' use32
.text$mn:00004860                 assume cs:_text$mn
.text$mn:00004860                 ;org 4860h
.text$mn:00004860 ; COMDAT (pick any)
.text$mn:00004860                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004860
.text$mn:00004860 ; =============== S U B R O U T I N E =======================================
.text$mn:00004860
.text$mn:00004860 ; Attributes: bp-based frame
.text$mn:00004860
.text$mn:00004860 ; public: virtual class std::error_condition __thiscall std::_System_error_category::default_error_condition(int)const
.text$mn:00004860                 public ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:00004860 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:00004860                                         ; DATA XREF: .rdata:00005A90o
.text$mn:00004860
.text$mn:00004860 var_4           = dword ptr -4
.text$mn:00004860 arg_0           = dword ptr  8
.text$mn:00004860 arg_4           = dword ptr  0Ch
.text$mn:00004860
.text$mn:00004860                 push    ebp
.text$mn:00004861                 mov     ebp, esp
.text$mn:00004863                 push    ecx
.text$mn:00004864                 mov     [ebp+var_4], ecx
.text$mn:00004867                 mov     eax, [ebp+arg_4]
.text$mn:0000486A                 push    eax             ; int
.text$mn:0000486B                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00004870                 add     esp, 4
.text$mn:00004873                 test    eax, eax
.text$mn:00004875                 jz      short loc_4890
.text$mn:00004877                 call    ?generic_category@std@@YAABVerror_category@1@XZ ; std::generic_category(void)
.text$mn:0000487C                 push    eax             ; struct std::error_category *
.text$mn:0000487D                 mov     ecx, [ebp+arg_4]
.text$mn:00004880                 push    ecx             ; int
.text$mn:00004881                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004884                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:00004889                 mov     eax, [ebp+arg_0]
.text$mn:0000488C                 jmp     short loc_48A5
.text$mn:0000488E ; ---------------------------------------------------------------------------
.text$mn:0000488E                 jmp     short loc_48A5
.text$mn:00004890 ; ---------------------------------------------------------------------------
.text$mn:00004890
.text$mn:00004890 loc_4890:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+15j
.text$mn:00004890                 call    ?system_category@std@@YAABVerror_category@1@XZ ; std::system_category(void)
.text$mn:00004895                 push    eax             ; struct std::error_category *
.text$mn:00004896                 mov     edx, [ebp+arg_4]
.text$mn:00004899                 push    edx             ; int
.text$mn:0000489A                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000489D                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000048A2                 mov     eax, [ebp+arg_0]
.text$mn:000048A5
.text$mn:000048A5 loc_48A5:                               ; CODE XREF: std::_System_error_category::default_error_condition(int)+2Cj
.text$mn:000048A5                                         ; std::_System_error_category::default_error_condition(int)+2Ej
.text$mn:000048A5                 mov     esp, ebp
.text$mn:000048A7                 pop     ebp
.text$mn:000048A8                 retn    8
.text$mn:000048A8 ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000048A8
.text$mn:000048A8 ; ---------------------------------------------------------------------------
.text$mn:000048AB                 align 4
.text$mn:000048AB _text$mn        ends
.text$mn:000048AB
.text$mn:000048AC ; ===========================================================================
.text$mn:000048AC
.text$mn:000048AC ; Segment type: Pure code
.text$mn:000048AC ; Segment permissions: Read/Execute
.text$mn:000048AC _text$mn        segment para public 'CODE' use32
.text$mn:000048AC                 assume cs:_text$mn
.text$mn:000048AC                 ;org 48ACh
.text$mn:000048AC ; COMDAT (pick any)
.text$mn:000048AC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048AC
.text$mn:000048AC ; =============== S U B R O U T I N E =======================================
.text$mn:000048AC
.text$mn:000048AC ; Attributes: bp-based frame
.text$mn:000048AC
.text$mn:000048AC ; public: virtual class std::error_condition __thiscall std::error_category::default_error_condition(int)const
.text$mn:000048AC                 public ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z
.text$mn:000048AC ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z proc near
.text$mn:000048AC                                         ; DATA XREF: .rdata:00005A00o
.text$mn:000048AC                                         ; .rdata:00005A1Co ...
.text$mn:000048AC
.text$mn:000048AC var_4           = dword ptr -4
.text$mn:000048AC arg_0           = dword ptr  8
.text$mn:000048AC arg_4           = dword ptr  0Ch
.text$mn:000048AC
.text$mn:000048AC                 push    ebp
.text$mn:000048AD                 mov     ebp, esp
.text$mn:000048AF                 push    ecx
.text$mn:000048B0                 mov     [ebp+var_4], ecx
.text$mn:000048B3                 mov     eax, [ebp+var_4]
.text$mn:000048B6                 push    eax             ; struct std::error_category *
.text$mn:000048B7                 mov     ecx, [ebp+arg_4]
.text$mn:000048BA                 push    ecx             ; int
.text$mn:000048BB                 mov     ecx, [ebp+arg_0] ; this
.text$mn:000048BE                 call    ??0error_condition@std@@QAE@HABVerror_category@1@@Z ; std::error_condition::error_condition(int,std::error_category const &)
.text$mn:000048C3                 mov     eax, [ebp+arg_0]
.text$mn:000048C6                 mov     esp, ebp
.text$mn:000048C8                 pop     ebp
.text$mn:000048C9                 retn    8
.text$mn:000048C9 ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z endp
.text$mn:000048C9
.text$mn:000048C9 _text$mn        ends
.text$mn:000048C9
.text$mn:000048CC ; ===========================================================================
.text$mn:000048CC
.text$mn:000048CC ; Segment type: Pure code
.text$mn:000048CC ; Segment permissions: Read/Execute
.text$mn:000048CC _text$mn        segment para public 'CODE' use32
.text$mn:000048CC                 assume cs:_text$mn
.text$mn:000048CC                 ;org 48CCh
.text$mn:000048CC ; COMDAT (pick any)
.text$mn:000048CC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000048CC
.text$mn:000048CC ; =============== S U B R O U T I N E =======================================
.text$mn:000048CC
.text$mn:000048CC ; Attributes: bp-based frame
.text$mn:000048CC
.text$mn:000048CC ; public: class std::_Vector_const_iterator<class std::_Vector_val<struct std::_Simple_types<class DockingCont *>>> __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::end(void)const
.text$mn:000048CC                 public ?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.text$mn:000048CC ?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ proc near
.text$mn:000048CC                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+89p
.text$mn:000048CC
.text$mn:000048CC var_14          = dword ptr -14h
.text$mn:000048CC var_10          = dword ptr -10h
.text$mn:000048CC var_C           = dword ptr -0Ch
.text$mn:000048CC var_4           = dword ptr -4
.text$mn:000048CC arg_0           = dword ptr  8
.text$mn:000048CC
.text$mn:000048CC                 push    ebp
.text$mn:000048CD                 mov     ebp, esp
.text$mn:000048CF                 push    0FFFFFFFFh
.text$mn:000048D1                 push    offset __ehhandler$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.text$mn:000048D6                 mov     eax, large fs:0
.text$mn:000048DC                 push    eax
.text$mn:000048DD                 sub     esp, 8
.text$mn:000048E0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:000048E5                 xor     eax, ebp
.text$mn:000048E7                 push    eax
.text$mn:000048E8                 lea     eax, [ebp+var_C]
.text$mn:000048EB                 mov     large fs:0, eax
.text$mn:000048F1                 mov     [ebp+var_10], ecx
.text$mn:000048F4                 mov     [ebp+var_14], 0
.text$mn:000048FB                 mov     eax, [ebp+var_10]
.text$mn:000048FE                 push    eax             ; struct std::_Container_base12 *
.text$mn:000048FF                 mov     ecx, [ebp+var_10]
.text$mn:00004902                 mov     edx, [ecx+8]
.text$mn:00004905                 push    edx             ; int
.text$mn:00004906                 mov     ecx, [ebp+arg_0]
.text$mn:00004909                 call    ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(DockingCont * *,std::_Container_base12 const *)
.text$mn:0000490E                 mov     [ebp+var_4], 0
.text$mn:00004915                 mov     eax, [ebp+var_14]
.text$mn:00004918                 or      eax, 1
.text$mn:0000491B                 mov     [ebp+var_14], eax
.text$mn:0000491E                 mov     eax, [ebp+arg_0]
.text$mn:00004921                 mov     ecx, [ebp+var_C]
.text$mn:00004924                 mov     large fs:0, ecx
.text$mn:0000492B                 pop     ecx
.text$mn:0000492C                 mov     esp, ebp
.text$mn:0000492E                 pop     ebp
.text$mn:0000492F                 retn    4
.text$mn:0000492F ?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ endp
.text$mn:0000492F
.text$mn:0000492F ; ---------------------------------------------------------------------------
.text$mn:00004932                 align 4
.text$mn:00004932 _text$mn        ends
.text$mn:00004932
.text$x:00004934 ; ===========================================================================
.text$x:00004934
.text$x:00004934 ; Segment type: Pure code
.text$x:00004934 ; Segment permissions: Read/Execute
.text$x:00004934 _text$x         segment para public 'CODE' use32
.text$x:00004934                 assume cs:_text$x
.text$x:00004934                 ;org 4934h
.text$x:00004934 ; COMDAT (pick associative to section at 48CC)
.text$x:00004934                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004934
.text$x:00004934 ; =============== S U B R O U T I N E =======================================
.text$x:00004934
.text$x:00004934
.text$x:00004934 __unwindfunclet$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0 proc near
.text$x:00004934                                         ; DATA XREF: .xdata$x:00005654o
.text$x:00004934                 mov     eax, [ebp-14h]
.text$x:00004937                 and     eax, 1
.text$x:0000493A                 jz      $LN4_1
.text$x:00004940                 and     dword ptr [ebp-14h], 0FFFFFFFEh
.text$x:00004944                 mov     ecx, [ebp+8]
.text$x:00004947                 jmp     ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<DockingCont *>>>(void)
.text$x:0000494C ; ---------------------------------------------------------------------------
.text$x:0000494C
.text$x:0000494C $LN4_1:                                 ; CODE XREF: __unwindfunclet$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0+6j
.text$x:0000494C                 retn
.text$x:0000494C __unwindfunclet$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0 endp
.text$x:0000494C
.text$x:0000494D
.text$x:0000494D ; =============== S U B R O U T I N E =======================================
.text$x:0000494D
.text$x:0000494D
.text$x:0000494D __ehhandler$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ proc near
.text$x:0000494D                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::end(void)+5o
.text$x:0000494D
.text$x:0000494D arg_4           = dword ptr  8
.text$x:0000494D
.text$x:0000494D                 mov     edx, [esp+arg_4]
.text$x:00004951                 lea     eax, [edx+0Ch]
.text$x:00004954                 mov     ecx, [edx-0Ch]
.text$x:00004957                 xor     ecx, eax
.text$x:00004959                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:0000495E                 mov     eax, offset __ehfuncinfo$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.text$x:00004963                 jmp     ___CxxFrameHandler3
.text$x:00004963 __ehhandler$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ endp
.text$x:00004963
.text$x:00004963 _text$x         ends
.text$x:00004963
.text$mn:00004968 ; ===========================================================================
.text$mn:00004968
.text$mn:00004968 ; Segment type: Pure code
.text$mn:00004968 ; Segment permissions: Read/Execute
.text$mn:00004968 _text$mn        segment para public 'CODE' use32
.text$mn:00004968                 assume cs:_text$mn
.text$mn:00004968                 ;org 4968h
.text$mn:00004968 ; COMDAT (pick any)
.text$mn:00004968                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004968
.text$mn:00004968 ; =============== S U B R O U T I N E =======================================
.text$mn:00004968
.text$mn:00004968 ; Attributes: bp-based frame
.text$mn:00004968
.text$mn:00004968 ; bool __thiscall std::error_category::equivalent(std::error_category *this, const struct std::error_code *, int)
.text$mn:00004968                 public ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z
.text$mn:00004968 ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z proc near
.text$mn:00004968                                         ; DATA XREF: .rdata:00005A04o
.text$mn:00004968                                         ; .rdata:00005A20o ...
.text$mn:00004968
.text$mn:00004968 var_8           = dword ptr -8
.text$mn:00004968 var_4           = dword ptr -4
.text$mn:00004968 arg_0           = dword ptr  8
.text$mn:00004968 arg_4           = dword ptr  0Ch
.text$mn:00004968
.text$mn:00004968                 push    ebp
.text$mn:00004969                 mov     ebp, esp
.text$mn:0000496B                 sub     esp, 8
.text$mn:0000496E                 mov     [ebp+var_8], ecx
.text$mn:00004971                 mov     ecx, [ebp+arg_0] ; this
.text$mn:00004974                 call    ?category@error_code@std@@QBEABVerror_category@2@XZ ; std::error_code::category(void)
.text$mn:00004979                 push    eax
.text$mn:0000497A                 mov     ecx, [ebp+var_8]
.text$mn:0000497D                 call    ??8error_category@std@@QBE_NABV01@@Z ; std::error_category::operator==(std::error_category const &)
.text$mn:00004982                 movzx   eax, al
.text$mn:00004985                 test    eax, eax
.text$mn:00004987                 jz      short loc_499F
.text$mn:00004989                 mov     ecx, [ebp+arg_0] ; this
.text$mn:0000498C                 call    ?value@error_code@std@@QBEHXZ ; std::error_code::value(void)
.text$mn:00004991                 cmp     eax, [ebp+arg_4]
.text$mn:00004994                 jnz     short loc_499F
.text$mn:00004996                 mov     [ebp+var_4], 1
.text$mn:0000499D                 jmp     short loc_49A6
.text$mn:0000499F ; ---------------------------------------------------------------------------
.text$mn:0000499F
.text$mn:0000499F loc_499F:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+1Fj
.text$mn:0000499F                                         ; std::error_category::equivalent(std::error_code const &,int)+2Cj
.text$mn:0000499F                 mov     [ebp+var_4], 0
.text$mn:000049A6
.text$mn:000049A6 loc_49A6:                               ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+35j
.text$mn:000049A6                 mov     al, byte ptr [ebp+var_4]
.text$mn:000049A9                 mov     esp, ebp
.text$mn:000049AB                 pop     ebp
.text$mn:000049AC                 retn    8
.text$mn:000049AC ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z endp
.text$mn:000049AC
.text$mn:000049AC ; ---------------------------------------------------------------------------
.text$mn:000049AF                 align 10h
.text$mn:000049AF _text$mn        ends
.text$mn:000049AF
.text$mn:000049B0 ; ===========================================================================
.text$mn:000049B0
.text$mn:000049B0 ; Segment type: Pure code
.text$mn:000049B0 ; Segment permissions: Read/Execute
.text$mn:000049B0 _text$mn        segment para public 'CODE' use32
.text$mn:000049B0                 assume cs:_text$mn
.text$mn:000049B0                 ;org 49B0h
.text$mn:000049B0 ; COMDAT (pick any)
.text$mn:000049B0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049B0
.text$mn:000049B0 ; =============== S U B R O U T I N E =======================================
.text$mn:000049B0
.text$mn:000049B0 ; Attributes: bp-based frame
.text$mn:000049B0
.text$mn:000049B0 ; bool __thiscall std::error_category::equivalent(std::error_category *this, int, const struct std::error_condition *)
.text$mn:000049B0                 public ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z
.text$mn:000049B0 ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z proc near
.text$mn:000049B0                                         ; DATA XREF: .rdata:00005A08o
.text$mn:000049B0                                         ; .rdata:00005A24o ...
.text$mn:000049B0
.text$mn:000049B0 var_C           = byte ptr -0Ch
.text$mn:000049B0 var_4           = dword ptr -4
.text$mn:000049B0 arg_0           = dword ptr  8
.text$mn:000049B0 arg_4           = dword ptr  0Ch
.text$mn:000049B0
.text$mn:000049B0                 push    ebp
.text$mn:000049B1                 mov     ebp, esp
.text$mn:000049B3                 sub     esp, 0Ch
.text$mn:000049B6                 mov     [ebp+var_4], ecx
.text$mn:000049B9                 mov     eax, [ebp+arg_4]
.text$mn:000049BC                 push    eax             ; std::error_condition *
.text$mn:000049BD                 mov     ecx, [ebp+arg_0]
.text$mn:000049C0                 push    ecx
.text$mn:000049C1                 lea     edx, [ebp+var_C]
.text$mn:000049C4                 push    edx
.text$mn:000049C5                 mov     eax, [ebp+var_4]
.text$mn:000049C8                 mov     edx, [eax]
.text$mn:000049CA                 mov     ecx, [ebp+var_4]
.text$mn:000049CD                 mov     eax, [edx+0Ch]
.text$mn:000049D0                 call    eax
.text$mn:000049D2                 mov     ecx, eax
.text$mn:000049D4                 call    ??8error_condition@std@@QBE_NABV01@@Z ; std::error_condition::operator==(std::error_condition const &)
.text$mn:000049D9                 mov     esp, ebp
.text$mn:000049DB                 pop     ebp
.text$mn:000049DC                 retn    8
.text$mn:000049DC ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z endp
.text$mn:000049DC
.text$mn:000049DC ; ---------------------------------------------------------------------------
.text$mn:000049DF                 align 10h
.text$mn:000049DF _text$mn        ends
.text$mn:000049DF
.text$mn:000049E0 ; ===========================================================================
.text$mn:000049E0
.text$mn:000049E0 ; Segment type: Pure code
.text$mn:000049E0 ; Segment permissions: Read/Execute
.text$mn:000049E0 _text$mn        segment para public 'CODE' use32
.text$mn:000049E0                 assume cs:_text$mn
.text$mn:000049E0                 ;org 49E0h
.text$mn:000049E0 ; COMDAT (pick any)
.text$mn:000049E0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:000049E0
.text$mn:000049E0 ; =============== S U B R O U T I N E =======================================
.text$mn:000049E0
.text$mn:000049E0 ; Attributes: bp-based frame
.text$mn:000049E0
.text$mn:000049E0 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int)
.text$mn:000049E0                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
.text$mn:000049E0 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z proc near
.text$mn:000049E0                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+4Cp
.text$mn:000049E0
.text$mn:000049E0 var_4           = dword ptr -4
.text$mn:000049E0 arg_0           = dword ptr  8
.text$mn:000049E0
.text$mn:000049E0                 push    ebp
.text$mn:000049E1                 mov     ebp, esp
.text$mn:000049E3                 push    ecx
.text$mn:000049E4                 mov     [ebp+var_4], ecx
.text$mn:000049E7                 mov     eax, [ebp+var_4]
.text$mn:000049EA                 mov     ecx, [eax+14h]
.text$mn:000049ED                 cmp     ecx, [ebp+arg_0]
.text$mn:000049F0                 jnb     short loc_49FA
.text$mn:000049F2                 mov     ecx, [ebp+var_4]
.text$mn:000049F5                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:000049FA
.text$mn:000049FA loc_49FA:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint)+10j
.text$mn:000049FA                 mov     edx, [ebp+arg_0]
.text$mn:000049FD                 push    edx
.text$mn:000049FE                 mov     ecx, [ebp+var_4]
.text$mn:00004A01                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004A06                 mov     eax, [ebp+var_4]
.text$mn:00004A09                 mov     esp, ebp
.text$mn:00004A0B                 pop     ebp
.text$mn:00004A0C                 retn    4
.text$mn:00004A0C ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z endp
.text$mn:00004A0C
.text$mn:00004A0C ; ---------------------------------------------------------------------------
.text$mn:00004A0F                 align 10h
.text$mn:00004A0F _text$mn        ends
.text$mn:00004A0F
.text$mn:00004A10 ; ===========================================================================
.text$mn:00004A10
.text$mn:00004A10 ; Segment type: Pure code
.text$mn:00004A10 ; Segment permissions: Read/Execute
.text$mn:00004A10 _text$mn        segment para public 'CODE' use32
.text$mn:00004A10                 assume cs:_text$mn
.text$mn:00004A10                 ;org 4A10h
.text$mn:00004A10 ; COMDAT (pick any)
.text$mn:00004A10                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A10
.text$mn:00004A10 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A10
.text$mn:00004A10 ; Attributes: bp-based frame
.text$mn:00004A10
.text$mn:00004A10 ; public: class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> & __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::erase(unsigned int, unsigned int)
.text$mn:00004A10                 public ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
.text$mn:00004A10 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z proc near
.text$mn:00004A10                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+5Ap
.text$mn:00004A10
.text$mn:00004A10 var_C           = dword ptr -0Ch
.text$mn:00004A10 Dst             = dword ptr -8
.text$mn:00004A10 var_4           = dword ptr -4
.text$mn:00004A10 arg_0           = dword ptr  8
.text$mn:00004A10 arg_4           = dword ptr  0Ch
.text$mn:00004A10
.text$mn:00004A10                 push    ebp
.text$mn:00004A11                 mov     ebp, esp
.text$mn:00004A13                 sub     esp, 0Ch
.text$mn:00004A16                 mov     [ebp+var_4], ecx
.text$mn:00004A19                 mov     eax, [ebp+var_4]
.text$mn:00004A1C                 mov     ecx, [eax+14h]
.text$mn:00004A1F                 cmp     ecx, [ebp+arg_0]
.text$mn:00004A22                 jnb     short loc_4A2C
.text$mn:00004A24                 mov     ecx, [ebp+var_4]
.text$mn:00004A27                 call    ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)
.text$mn:00004A2C
.text$mn:00004A2C loc_4A2C:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+12j
.text$mn:00004A2C                 mov     edx, [ebp+var_4]
.text$mn:00004A2F                 mov     eax, [edx+14h]
.text$mn:00004A32                 sub     eax, [ebp+arg_0]
.text$mn:00004A35                 cmp     eax, [ebp+arg_4]
.text$mn:00004A38                 ja      short loc_4A48
.text$mn:00004A3A                 mov     ecx, [ebp+arg_0]
.text$mn:00004A3D                 push    ecx
.text$mn:00004A3E                 mov     ecx, [ebp+var_4]
.text$mn:00004A41                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004A46                 jmp     short loc_4A8E
.text$mn:00004A48 ; ---------------------------------------------------------------------------
.text$mn:00004A48
.text$mn:00004A48 loc_4A48:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+28j
.text$mn:00004A48                 cmp     [ebp+arg_4], 0
.text$mn:00004A4C                 jbe     short loc_4A8E
.text$mn:00004A4E                 mov     ecx, [ebp+var_4]
.text$mn:00004A51                 call    ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char>>::_Myptr(void)
.text$mn:00004A56                 add     eax, [ebp+arg_0]
.text$mn:00004A59                 mov     [ebp+Dst], eax
.text$mn:00004A5C                 mov     edx, [ebp+var_4]
.text$mn:00004A5F                 mov     eax, [edx+14h]
.text$mn:00004A62                 sub     eax, [ebp+arg_4]
.text$mn:00004A65                 mov     [ebp+var_C], eax
.text$mn:00004A68                 mov     ecx, [ebp+var_C]
.text$mn:00004A6B                 sub     ecx, [ebp+arg_0]
.text$mn:00004A6E                 push    ecx             ; Size
.text$mn:00004A6F                 mov     edx, [ebp+Dst]
.text$mn:00004A72                 add     edx, [ebp+arg_4]
.text$mn:00004A75                 push    edx             ; Src
.text$mn:00004A76                 mov     eax, [ebp+Dst]
.text$mn:00004A79                 push    eax             ; Dst
.text$mn:00004A7A                 call    ?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move(char *,char const *,uint)
.text$mn:00004A7F                 add     esp, 0Ch
.text$mn:00004A82                 mov     ecx, [ebp+var_C]
.text$mn:00004A85                 push    ecx
.text$mn:00004A86                 mov     ecx, [ebp+var_4]
.text$mn:00004A89                 call    ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Eos(uint)
.text$mn:00004A8E
.text$mn:00004A8E loc_4A8E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+36j
.text$mn:00004A8E                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+3Cj
.text$mn:00004A8E                 mov     eax, [ebp+var_4]
.text$mn:00004A91                 mov     esp, ebp
.text$mn:00004A93                 pop     ebp
.text$mn:00004A94                 retn    8
.text$mn:00004A94 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z endp
.text$mn:00004A94
.text$mn:00004A94 ; ---------------------------------------------------------------------------
.text$mn:00004A97                 align 4
.text$mn:00004A97 _text$mn        ends
.text$mn:00004A97
.text$mn:00004A98 ; ===========================================================================
.text$mn:00004A98
.text$mn:00004A98 ; Segment type: Pure code
.text$mn:00004A98 ; Segment permissions: Read/Execute
.text$mn:00004A98 _text$mn        segment para public 'CODE' use32
.text$mn:00004A98                 assume cs:_text$mn
.text$mn:00004A98                 ;org 4A98h
.text$mn:00004A98 ; COMDAT (pick any)
.text$mn:00004A98                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004A98
.text$mn:00004A98 ; =============== S U B R O U T I N E =======================================
.text$mn:00004A98
.text$mn:00004A98 ; Attributes: bp-based frame
.text$mn:00004A98
.text$mn:00004A98 ; const struct std::error_category *__cdecl std::generic_category()
.text$mn:00004A98                 public ?generic_category@std@@YAABVerror_category@1@XZ
.text$mn:00004A98 ?generic_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00004A98                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+17p
.text$mn:00004A98                 push    ebp
.text$mn:00004A99                 mov     ebp, esp
.text$mn:00004A9B                 mov     eax, offset ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.text$mn:00004AA0                 pop     ebp
.text$mn:00004AA1                 retn
.text$mn:00004AA1 ?generic_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00004AA1
.text$mn:00004AA1 ; ---------------------------------------------------------------------------
.text$mn:00004AA2                 align 4
.text$mn:00004AA2 _text$mn        ends
.text$mn:00004AA2
.text$mn:00004AA4 ; ===========================================================================
.text$mn:00004AA4
.text$mn:00004AA4 ; Segment type: Pure code
.text$mn:00004AA4 ; Segment permissions: Read/Execute
.text$mn:00004AA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004AA4                 assume cs:_text$mn
.text$mn:00004AA4                 ;org 4AA4h
.text$mn:00004AA4 ; COMDAT (pick any)
.text$mn:00004AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AA4
.text$mn:00004AA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AA4
.text$mn:00004AA4 ; Attributes: bp-based frame
.text$mn:00004AA4
.text$mn:00004AA4 ; HWND __thiscall DockingCont::getCaptionWnd(DockingCont *__hidden this)
.text$mn:00004AA4                 public ?getCaptionWnd@DockingCont@@QAEPAUHWND__@@XZ
.text$mn:00004AA4 ?getCaptionWnd@DockingCont@@QAEPAUHWND__@@XZ proc near
.text$mn:00004AA4                                         ; CODE XREF: Gripper::contHitTest(tagPOINT)+8Ep
.text$mn:00004AA4
.text$mn:00004AA4 var_4           = dword ptr -4
.text$mn:00004AA4
.text$mn:00004AA4                 push    ebp
.text$mn:00004AA5                 mov     ebp, esp
.text$mn:00004AA7                 push    ecx
.text$mn:00004AA8                 mov     [ebp+var_4], ecx
.text$mn:00004AAB                 mov     eax, [ebp+var_4]
.text$mn:00004AAE                 movzx   ecx, byte ptr [eax+24h]
.text$mn:00004AB2                 test    ecx, ecx
.text$mn:00004AB4                 jnz     short loc_4AC0
.text$mn:00004AB6                 mov     edx, [ebp+var_4]
.text$mn:00004AB9                 mov     eax, [edx+28h]
.text$mn:00004ABC                 jmp     short loc_4AC6
.text$mn:00004ABE ; ---------------------------------------------------------------------------
.text$mn:00004ABE                 jmp     short loc_4AC6
.text$mn:00004AC0 ; ---------------------------------------------------------------------------
.text$mn:00004AC0
.text$mn:00004AC0 loc_4AC0:                               ; CODE XREF: DockingCont::getCaptionWnd(void)+10j
.text$mn:00004AC0                 mov     eax, [ebp+var_4]
.text$mn:00004AC3                 mov     eax, [eax+0Ch]
.text$mn:00004AC6
.text$mn:00004AC6 loc_4AC6:                               ; CODE XREF: DockingCont::getCaptionWnd(void)+18j
.text$mn:00004AC6                                         ; DockingCont::getCaptionWnd(void)+1Aj
.text$mn:00004AC6                 mov     esp, ebp
.text$mn:00004AC8                 pop     ebp
.text$mn:00004AC9                 retn
.text$mn:00004AC9 ?getCaptionWnd@DockingCont@@QAEPAUHWND__@@XZ endp
.text$mn:00004AC9
.text$mn:00004AC9 ; ---------------------------------------------------------------------------
.text$mn:00004ACA                 align 4
.text$mn:00004ACA _text$mn        ends
.text$mn:00004ACA
.text$mn:00004ACC ; ===========================================================================
.text$mn:00004ACC
.text$mn:00004ACC ; Segment type: Pure code
.text$mn:00004ACC ; Segment permissions: Read/Execute
.text$mn:00004ACC _text$mn        segment para public 'CODE' use32
.text$mn:00004ACC                 assume cs:_text$mn
.text$mn:00004ACC                 ;org 4ACCh
.text$mn:00004ACC ; COMDAT (pick any)
.text$mn:00004ACC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004ACC
.text$mn:00004ACC ; =============== S U B R O U T I N E =======================================
.text$mn:00004ACC
.text$mn:00004ACC ; Attributes: bp-based frame
.text$mn:00004ACC
.text$mn:00004ACC ; public: class std::vector<class DockingCont *, class std::allocator<class DockingCont *>> & __thiscall DockingManager::getContainerInfo(void)
.text$mn:00004ACC                 public ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ
.text$mn:00004ACC ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ proc near
.text$mn:00004ACC                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+31p
.text$mn:00004ACC                                         ; Gripper::contHitTest(tagPOINT)+31p ...
.text$mn:00004ACC
.text$mn:00004ACC var_4           = dword ptr -4
.text$mn:00004ACC
.text$mn:00004ACC                 push    ebp
.text$mn:00004ACD                 mov     ebp, esp
.text$mn:00004ACF                 push    ecx
.text$mn:00004AD0                 mov     [ebp+var_4], ecx
.text$mn:00004AD3                 mov     eax, [ebp+var_4]
.text$mn:00004AD6                 add     eax, 4Ch ; 'L'
.text$mn:00004AD9                 mov     esp, ebp
.text$mn:00004ADB                 pop     ebp
.text$mn:00004ADC                 retn
.text$mn:00004ADC ?getContainerInfo@DockingManager@@QAEAAV?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@XZ endp
.text$mn:00004ADC
.text$mn:00004ADC ; ---------------------------------------------------------------------------
.text$mn:00004ADD                 align 10h
.text$mn:00004ADD _text$mn        ends
.text$mn:00004ADD
.text$mn:00004AE0 ; ===========================================================================
.text$mn:00004AE0
.text$mn:00004AE0 ; Segment type: Pure code
.text$mn:00004AE0 ; Segment permissions: Read/Execute
.text$mn:00004AE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004AE0                 assume cs:_text$mn
.text$mn:00004AE0                 ;org 4AE0h
.text$mn:00004AE0 ; COMDAT (pick any)
.text$mn:00004AE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004AE0
.text$mn:00004AE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004AE0
.text$mn:00004AE0 ; Attributes: bp-based frame
.text$mn:00004AE0
.text$mn:00004AE0 ; void __thiscall DockingManager::getDockInfo(DockingManager *this, struct tDockMgr *)
.text$mn:00004AE0                 public ?getDockInfo@DockingManager@@QAEXPAUtDockMgr@@@Z
.text$mn:00004AE0 ?getDockInfo@DockingManager@@QAEXPAUtDockMgr@@@Z proc near
.text$mn:00004AE0                                         ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+28p
.text$mn:00004AE0
.text$mn:00004AE0 var_4           = dword ptr -4
.text$mn:00004AE0 arg_0           = dword ptr  8
.text$mn:00004AE0
.text$mn:00004AE0                 push    ebp
.text$mn:00004AE1                 mov     ebp, esp
.text$mn:00004AE3                 push    ecx
.text$mn:00004AE4                 push    esi
.text$mn:00004AE5                 push    edi
.text$mn:00004AE6                 mov     [ebp+var_4], ecx
.text$mn:00004AE9                 mov     esi, [ebp+var_4]
.text$mn:00004AEC                 add     esi, 5Ch ; '\'
.text$mn:00004AEF                 mov     ecx, 11h
.text$mn:00004AF4                 mov     edi, [ebp+arg_0]
.text$mn:00004AF7                 rep movsd
.text$mn:00004AF9                 pop     edi
.text$mn:00004AFA                 pop     esi
.text$mn:00004AFB                 mov     esp, ebp
.text$mn:00004AFD                 pop     ebp
.text$mn:00004AFE                 retn    4
.text$mn:00004AFE ?getDockInfo@DockingManager@@QAEXPAUtDockMgr@@@Z endp
.text$mn:00004AFE
.text$mn:00004AFE ; ---------------------------------------------------------------------------
.text$mn:00004B01                 align 4
.text$mn:00004B01 _text$mn        ends
.text$mn:00004B01
.text$mn:00004B04 ; ===========================================================================
.text$mn:00004B04
.text$mn:00004B04 ; Segment type: Pure code
.text$mn:00004B04 ; Segment permissions: Read/Execute
.text$mn:00004B04 _text$mn        segment para public 'CODE' use32
.text$mn:00004B04                 assume cs:_text$mn
.text$mn:00004B04                 ;org 4B04h
.text$mn:00004B04 ; COMDAT (pick any)
.text$mn:00004B04                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B04
.text$mn:00004B04 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B04
.text$mn:00004B04 ; Attributes: bp-based frame
.text$mn:00004B04
.text$mn:00004B04 ; HWND __thiscall Window::getHSelf(Window *__hidden this)
.text$mn:00004B04                 public ?getHSelf@Window@@QBEPAUHWND__@@XZ
.text$mn:00004B04 ?getHSelf@Window@@QBEPAUHWND__@@XZ proc near
.text$mn:00004B04                                         ; CODE XREF: Gripper::create(void)+5Ep
.text$mn:00004B04                                         ; Gripper::create(void)+1A4p ...
.text$mn:00004B04
.text$mn:00004B04 var_4           = dword ptr -4
.text$mn:00004B04
.text$mn:00004B04                 push    ebp
.text$mn:00004B05                 mov     ebp, esp
.text$mn:00004B07                 push    ecx
.text$mn:00004B08                 mov     [ebp+var_4], ecx
.text$mn:00004B0B                 mov     eax, [ebp+var_4]
.text$mn:00004B0E                 mov     eax, [eax+0Ch]
.text$mn:00004B11                 mov     esp, ebp
.text$mn:00004B13                 pop     ebp
.text$mn:00004B14                 retn
.text$mn:00004B14 ?getHSelf@Window@@QBEPAUHWND__@@XZ endp
.text$mn:00004B14
.text$mn:00004B14 ; ---------------------------------------------------------------------------
.text$mn:00004B15                 align 4
.text$mn:00004B15 _text$mn        ends
.text$mn:00004B15
.text$mn:00004B18 ; ===========================================================================
.text$mn:00004B18
.text$mn:00004B18 ; Segment type: Pure code
.text$mn:00004B18 ; Segment permissions: Read/Execute
.text$mn:00004B18 _text$mn        segment para public 'CODE' use32
.text$mn:00004B18                 assume cs:_text$mn
.text$mn:00004B18                 ;org 4B18h
.text$mn:00004B18 ; COMDAT (pick any)
.text$mn:00004B18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B18
.text$mn:00004B18 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B18
.text$mn:00004B18 ; Attributes: bp-based frame
.text$mn:00004B18
.text$mn:00004B18 ; struct NppParameters *__cdecl NppParameters::getInstance()
.text$mn:00004B18                 public ?getInstance@NppParameters@@SAPAV1@XZ
.text$mn:00004B18 ?getInstance@NppParameters@@SAPAV1@XZ proc near
.text$mn:00004B18                                         ; CODE XREF: Gripper::create(void)+7Ap
.text$mn:00004B18                 push    ebp
.text$mn:00004B19                 mov     ebp, esp
.text$mn:00004B1B                 mov     eax, dword ptr ds:?_pSelf@NppParameters@@0PAV1@A ; NppParameters * NppParameters::_pSelf
.text$mn:00004B20                 pop     ebp
.text$mn:00004B21                 retn
.text$mn:00004B21 ?getInstance@NppParameters@@SAPAV1@XZ endp
.text$mn:00004B21
.text$mn:00004B21 ; ---------------------------------------------------------------------------
.text$mn:00004B22                 align 4
.text$mn:00004B22 _text$mn        ends
.text$mn:00004B22
.text$mn:00004B24 ; ===========================================================================
.text$mn:00004B24
.text$mn:00004B24 ; Segment type: Pure code
.text$mn:00004B24 ; Segment permissions: Read/Execute
.text$mn:00004B24 _text$mn        segment para public 'CODE' use32
.text$mn:00004B24                 assume cs:_text$mn
.text$mn:00004B24                 ;org 4B24h
.text$mn:00004B24 ; COMDAT (pick any)
.text$mn:00004B24                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B24
.text$mn:00004B24 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B24
.text$mn:00004B24 ; Attributes: bp-based frame
.text$mn:00004B24
.text$mn:00004B24 ; HWND __thiscall DockingCont::getTabWnd(DockingCont *__hidden this)
.text$mn:00004B24                 public ?getTabWnd@DockingCont@@QAEPAUHWND__@@XZ
.text$mn:00004B24 ?getTabWnd@DockingCont@@QAEPAUHWND__@@XZ proc near
.text$mn:00004B24                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+A7p
.text$mn:00004B24                                         ; Gripper::contHitTest(tagPOINT)+197p ...
.text$mn:00004B24
.text$mn:00004B24 var_4           = dword ptr -4
.text$mn:00004B24
.text$mn:00004B24                 push    ebp
.text$mn:00004B25                 mov     ebp, esp
.text$mn:00004B27                 push    ecx
.text$mn:00004B28                 mov     [ebp+var_4], ecx
.text$mn:00004B2B                 mov     eax, [ebp+var_4]
.text$mn:00004B2E                 mov     eax, [eax+2Ch]
.text$mn:00004B31                 mov     esp, ebp
.text$mn:00004B33                 pop     ebp
.text$mn:00004B34                 retn
.text$mn:00004B34 ?getTabWnd@DockingCont@@QAEPAUHWND__@@XZ endp
.text$mn:00004B34
.text$mn:00004B34 ; ---------------------------------------------------------------------------
.text$mn:00004B35                 align 4
.text$mn:00004B35 _text$mn        ends
.text$mn:00004B35
.text$mn:00004B38 ; ===========================================================================
.text$mn:00004B38
.text$mn:00004B38 ; Segment type: Pure code
.text$mn:00004B38 ; Segment permissions: Read/Execute
.text$mn:00004B38 _text$mn        segment para public 'CODE' use32
.text$mn:00004B38                 assume cs:_text$mn
.text$mn:00004B38                 ;org 4B38h
.text$mn:00004B38 ; COMDAT (pick any)
.text$mn:00004B38                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B38
.text$mn:00004B38 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B38
.text$mn:00004B38 ; Attributes: bp-based frame
.text$mn:00004B38
.text$mn:00004B38 ; public: enum  winVer __thiscall NppParameters::getWinVersion(void)
.text$mn:00004B38                 public ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ
.text$mn:00004B38 ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ proc near
.text$mn:00004B38                                         ; CODE XREF: Gripper::create(void)+81p
.text$mn:00004B38
.text$mn:00004B38 var_4           = dword ptr -4
.text$mn:00004B38
.text$mn:00004B38                 push    ebp
.text$mn:00004B39                 mov     ebp, esp
.text$mn:00004B3B                 push    ecx
.text$mn:00004B3C                 mov     [ebp+var_4], ecx
.text$mn:00004B3F                 mov     eax, [ebp+var_4]
.text$mn:00004B42                 mov     eax, [eax+1CC1Ch]
.text$mn:00004B48                 mov     esp, ebp
.text$mn:00004B4A                 pop     ebp
.text$mn:00004B4B                 retn
.text$mn:00004B4B ?getWinVersion@NppParameters@@QAE?AW4winVer@@XZ endp
.text$mn:00004B4B
.text$mn:00004B4B _text$mn        ends
.text$mn:00004B4B
.text$mn:00004B4C ; ===========================================================================
.text$mn:00004B4C
.text$mn:00004B4C ; Segment type: Pure code
.text$mn:00004B4C ; Segment permissions: Read/Execute
.text$mn:00004B4C _text$mn        segment para public 'CODE' use32
.text$mn:00004B4C                 assume cs:_text$mn
.text$mn:00004B4C                 ;org 4B4Ch
.text$mn:00004B4C ; COMDAT (pick any)
.text$mn:00004B4C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B4C
.text$mn:00004B4C ; =============== S U B R O U T I N E =======================================
.text$mn:00004B4C
.text$mn:00004B4C ; Attributes: bp-based frame
.text$mn:00004B4C
.text$mn:00004B4C ; bool __thiscall DockingCont::isFloating(DockingCont *__hidden this)
.text$mn:00004B4C                 public ?isFloating@DockingCont@@QAE_NXZ
.text$mn:00004B4C ?isFloating@DockingCont@@QAE_NXZ proc near
.text$mn:00004B4C                                         ; CODE XREF: Gripper::create(void)+187p
.text$mn:00004B4C                                         ; Gripper::onButtonUp(void)+180p ...
.text$mn:00004B4C
.text$mn:00004B4C var_4           = dword ptr -4
.text$mn:00004B4C
.text$mn:00004B4C                 push    ebp
.text$mn:00004B4D                 mov     ebp, esp
.text$mn:00004B4F                 push    ecx
.text$mn:00004B50                 mov     [ebp+var_4], ecx
.text$mn:00004B53                 mov     eax, [ebp+var_4]
.text$mn:00004B56                 mov     al, [eax+24h]
.text$mn:00004B59                 mov     esp, ebp
.text$mn:00004B5B                 pop     ebp
.text$mn:00004B5C                 retn
.text$mn:00004B5C ?isFloating@DockingCont@@QAE_NXZ endp
.text$mn:00004B5C
.text$mn:00004B5C ; ---------------------------------------------------------------------------
.text$mn:00004B5D                 align 10h
.text$mn:00004B5D _text$mn        ends
.text$mn:00004B5D
.text$mn:00004B60 ; ===========================================================================
.text$mn:00004B60
.text$mn:00004B60 ; Segment type: Pure code
.text$mn:00004B60 ; Segment permissions: Read/Execute
.text$mn:00004B60 _text$mn        segment para public 'CODE' use32
.text$mn:00004B60                 assume cs:_text$mn
.text$mn:00004B60                 ;org 4B60h
.text$mn:00004B60 ; COMDAT (pick any)
.text$mn:00004B60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B60
.text$mn:00004B60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B60
.text$mn:00004B60 ; Attributes: bp-based frame
.text$mn:00004B60
.text$mn:00004B60 ; int __cdecl std::char_traits<char>::length(char *Str)
.text$mn:00004B60                 public ?length@?$char_traits@D@std@@SAIPBD@Z
.text$mn:00004B60 ?length@?$char_traits@D@std@@SAIPBD@Z proc near
.text$mn:00004B60                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+21p
.text$mn:00004B60
.text$mn:00004B60 var_4           = dword ptr -4
.text$mn:00004B60 Str             = dword ptr  8
.text$mn:00004B60
.text$mn:00004B60                 push    ebp
.text$mn:00004B61                 mov     ebp, esp
.text$mn:00004B63                 push    ecx
.text$mn:00004B64                 mov     eax, [ebp+Str]
.text$mn:00004B67                 movsx   ecx, byte ptr [eax]
.text$mn:00004B6A                 test    ecx, ecx
.text$mn:00004B6C                 jnz     short loc_4B77
.text$mn:00004B6E                 mov     [ebp+var_4], 0
.text$mn:00004B75                 jmp     short loc_4B86
.text$mn:00004B77 ; ---------------------------------------------------------------------------
.text$mn:00004B77
.text$mn:00004B77 loc_4B77:                               ; CODE XREF: std::char_traits<char>::length(char const *)+Cj
.text$mn:00004B77                 mov     edx, [ebp+Str]
.text$mn:00004B7A                 push    edx             ; Str
.text$mn:00004B7B                 call    _strlen
.text$mn:00004B80                 add     esp, 4
.text$mn:00004B83                 mov     [ebp+var_4], eax
.text$mn:00004B86
.text$mn:00004B86 loc_4B86:                               ; CODE XREF: std::char_traits<char>::length(char const *)+15j
.text$mn:00004B86                 mov     eax, [ebp+var_4]
.text$mn:00004B89                 mov     esp, ebp
.text$mn:00004B8B                 pop     ebp
.text$mn:00004B8C                 retn
.text$mn:00004B8C ?length@?$char_traits@D@std@@SAIPBD@Z endp
.text$mn:00004B8C
.text$mn:00004B8C ; ---------------------------------------------------------------------------
.text$mn:00004B8D                 align 10h
.text$mn:00004B8D _text$mn        ends
.text$mn:00004B8D
.text$mn:00004B90 ; ===========================================================================
.text$mn:00004B90
.text$mn:00004B90 ; Segment type: Pure code
.text$mn:00004B90 ; Segment permissions: Read/Execute
.text$mn:00004B90 _text$mn        segment para public 'CODE' use32
.text$mn:00004B90                 assume cs:_text$mn
.text$mn:00004B90                 ;org 4B90h
.text$mn:00004B90 ; COMDAT (pick any)
.text$mn:00004B90                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004B90
.text$mn:00004B90 ; =============== S U B R O U T I N E =======================================
.text$mn:00004B90
.text$mn:00004B90 ; Attributes: bp-based frame
.text$mn:00004B90
.text$mn:00004B90 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<char>>::max_size(void)const
.text$mn:00004B90                 public ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ
.text$mn:00004B90 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ proc near
.text$mn:00004B90                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+17p
.text$mn:00004B90
.text$mn:00004B90 var_4           = dword ptr -4
.text$mn:00004B90
.text$mn:00004B90                 push    ebp
.text$mn:00004B91                 mov     ebp, esp
.text$mn:00004B93                 push    ecx
.text$mn:00004B94                 mov     [ebp+var_4], ecx
.text$mn:00004B97                 mov     eax, [ebp+var_4]
.text$mn:00004B9A                 push    eax
.text$mn:00004B9B                 call    ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)
.text$mn:00004BA0                 add     esp, 4
.text$mn:00004BA3                 mov     esp, ebp
.text$mn:00004BA5                 pop     ebp
.text$mn:00004BA6                 retn
.text$mn:00004BA6 ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ endp
.text$mn:00004BA6
.text$mn:00004BA6 ; ---------------------------------------------------------------------------
.text$mn:00004BA7                 align 4
.text$mn:00004BA7 _text$mn        ends
.text$mn:00004BA7
.text$mn:00004BA8 ; ===========================================================================
.text$mn:00004BA8
.text$mn:00004BA8 ; Segment type: Pure code
.text$mn:00004BA8 ; Segment permissions: Read/Execute
.text$mn:00004BA8 _text$mn        segment para public 'CODE' use32
.text$mn:00004BA8                 assume cs:_text$mn
.text$mn:00004BA8                 ;org 4BA8h
.text$mn:00004BA8 ; COMDAT (pick any)
.text$mn:00004BA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BA8
.text$mn:00004BA8 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BA8
.text$mn:00004BA8 ; Attributes: bp-based frame
.text$mn:00004BA8
.text$mn:00004BA8 ; public: unsigned int __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::max_size(void)const
.text$mn:00004BA8                 public ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:00004BA8 ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:00004BA8                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::max_size(void)+17p
.text$mn:00004BA8
.text$mn:00004BA8 var_4           = dword ptr -4
.text$mn:00004BA8
.text$mn:00004BA8                 push    ebp
.text$mn:00004BA9                 mov     ebp, esp
.text$mn:00004BAB                 push    ecx
.text$mn:00004BAC                 mov     [ebp+var_4], ecx
.text$mn:00004BAF                 mov     eax, [ebp+var_4]
.text$mn:00004BB2                 push    eax
.text$mn:00004BB3                 call    ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z ; std::allocator_traits<std::allocator<DockingCont *>>::max_size(std::allocator<DockingCont *> const &)
.text$mn:00004BB8                 add     esp, 4
.text$mn:00004BBB                 mov     esp, ebp
.text$mn:00004BBD                 pop     ebp
.text$mn:00004BBE                 retn
.text$mn:00004BBE ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:00004BBE
.text$mn:00004BBE ; ---------------------------------------------------------------------------
.text$mn:00004BBF                 align 10h
.text$mn:00004BBF _text$mn        ends
.text$mn:00004BBF
.text$mn:00004BC0 ; ===========================================================================
.text$mn:00004BC0
.text$mn:00004BC0 ; Segment type: Pure code
.text$mn:00004BC0 ; Segment permissions: Read/Execute
.text$mn:00004BC0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BC0                 assume cs:_text$mn
.text$mn:00004BC0                 ;org 4BC0h
.text$mn:00004BC0 ; COMDAT (pick any)
.text$mn:00004BC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BC0
.text$mn:00004BC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BC0
.text$mn:00004BC0 ; Attributes: bp-based frame
.text$mn:00004BC0
.text$mn:00004BC0 ; public: unsigned int __thiscall std::allocator<char>::max_size(void)const
.text$mn:00004BC0                 public ?max_size@?$allocator@D@std@@QBEIXZ
.text$mn:00004BC0 ?max_size@?$allocator@D@std@@QBEIXZ proc near
.text$mn:00004BC0                                         ; CODE XREF: std::allocator_traits<std::allocator<char>>::max_size(std::allocator<char> const &)+6p
.text$mn:00004BC0
.text$mn:00004BC0 var_4           = dword ptr -4
.text$mn:00004BC0
.text$mn:00004BC0                 push    ebp
.text$mn:00004BC1                 mov     ebp, esp
.text$mn:00004BC3                 push    ecx
.text$mn:00004BC4                 mov     [ebp+var_4], ecx
.text$mn:00004BC7                 or      eax, 0FFFFFFFFh
.text$mn:00004BCA                 mov     esp, ebp
.text$mn:00004BCC                 pop     ebp
.text$mn:00004BCD                 retn
.text$mn:00004BCD ?max_size@?$allocator@D@std@@QBEIXZ endp
.text$mn:00004BCD
.text$mn:00004BCD ; ---------------------------------------------------------------------------
.text$mn:00004BCE                 align 10h
.text$mn:00004BCE _text$mn        ends
.text$mn:00004BCE
.text$mn:00004BD0 ; ===========================================================================
.text$mn:00004BD0
.text$mn:00004BD0 ; Segment type: Pure code
.text$mn:00004BD0 ; Segment permissions: Read/Execute
.text$mn:00004BD0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BD0                 assume cs:_text$mn
.text$mn:00004BD0                 ;org 4BD0h
.text$mn:00004BD0 ; COMDAT (pick any)
.text$mn:00004BD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BD0
.text$mn:00004BD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BD0
.text$mn:00004BD0 ; Attributes: bp-based frame
.text$mn:00004BD0
.text$mn:00004BD0 ; public: unsigned int __thiscall std::allocator<class DockingCont *>::max_size(void)const
.text$mn:00004BD0                 public ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ
.text$mn:00004BD0 ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ proc near
.text$mn:00004BD0                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingCont *>>::max_size(std::allocator<DockingCont *> const &)+6p
.text$mn:00004BD0
.text$mn:00004BD0 var_4           = dword ptr -4
.text$mn:00004BD0
.text$mn:00004BD0                 push    ebp
.text$mn:00004BD1                 mov     ebp, esp
.text$mn:00004BD3                 push    ecx
.text$mn:00004BD4                 mov     [ebp+var_4], ecx
.text$mn:00004BD7                 mov     eax, 3FFFFFFFh
.text$mn:00004BDC                 mov     esp, ebp
.text$mn:00004BDE                 pop     ebp
.text$mn:00004BDF                 retn
.text$mn:00004BDF ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ endp
.text$mn:00004BDF
.text$mn:00004BDF _text$mn        ends
.text$mn:00004BDF
.text$mn:00004BE0 ; ===========================================================================
.text$mn:00004BE0
.text$mn:00004BE0 ; Segment type: Pure code
.text$mn:00004BE0 ; Segment permissions: Read/Execute
.text$mn:00004BE0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BE0                 assume cs:_text$mn
.text$mn:00004BE0                 ;org 4BE0h
.text$mn:00004BE0 ; COMDAT (pick any)
.text$mn:00004BE0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BE0
.text$mn:00004BE0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BE0
.text$mn:00004BE0 ; Attributes: bp-based frame
.text$mn:00004BE0
.text$mn:00004BE0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<char>>::max_size(class std::allocator<char> const &)
.text$mn:00004BE0                 public ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
.text$mn:00004BE0 ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z proc near
.text$mn:00004BE0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<char>>::max_size(void)+Bp
.text$mn:00004BE0
.text$mn:00004BE0 arg_0           = dword ptr  8
.text$mn:00004BE0
.text$mn:00004BE0                 push    ebp
.text$mn:00004BE1                 mov     ebp, esp
.text$mn:00004BE3                 mov     ecx, [ebp+arg_0]
.text$mn:00004BE6                 call    ?max_size@?$allocator@D@std@@QBEIXZ ; std::allocator<char>::max_size(void)
.text$mn:00004BEB                 pop     ebp
.text$mn:00004BEC                 retn
.text$mn:00004BEC ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z endp
.text$mn:00004BEC
.text$mn:00004BEC ; ---------------------------------------------------------------------------
.text$mn:00004BED                 align 10h
.text$mn:00004BED _text$mn        ends
.text$mn:00004BED
.text$mn:00004BF0 ; ===========================================================================
.text$mn:00004BF0
.text$mn:00004BF0 ; Segment type: Pure code
.text$mn:00004BF0 ; Segment permissions: Read/Execute
.text$mn:00004BF0 _text$mn        segment para public 'CODE' use32
.text$mn:00004BF0                 assume cs:_text$mn
.text$mn:00004BF0                 ;org 4BF0h
.text$mn:00004BF0 ; COMDAT (pick any)
.text$mn:00004BF0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004BF0
.text$mn:00004BF0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004BF0
.text$mn:00004BF0 ; Attributes: bp-based frame
.text$mn:00004BF0
.text$mn:00004BF0 ; public: static unsigned int __cdecl std::allocator_traits<class std::allocator<class DockingCont *>>::max_size(class std::allocator<class DockingCont *> const &)
.text$mn:00004BF0                 public ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z
.text$mn:00004BF0 ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z proc near
.text$mn:00004BF0                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::max_size(void)+Bp
.text$mn:00004BF0
.text$mn:00004BF0 arg_0           = dword ptr  8
.text$mn:00004BF0
.text$mn:00004BF0                 push    ebp
.text$mn:00004BF1                 mov     ebp, esp
.text$mn:00004BF3                 mov     ecx, [ebp+arg_0]
.text$mn:00004BF6                 call    ?max_size@?$allocator@PAVDockingCont@@@std@@QBEIXZ ; std::allocator<DockingCont *>::max_size(void)
.text$mn:00004BFB                 pop     ebp
.text$mn:00004BFC                 retn
.text$mn:00004BFC ?max_size@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SAIABV?$allocator@PAVDockingCont@@@2@@Z endp
.text$mn:00004BFC
.text$mn:00004BFC ; ---------------------------------------------------------------------------
.text$mn:00004BFD                 align 10h
.text$mn:00004BFD _text$mn        ends
.text$mn:00004BFD
.text$mn:00004C00 ; ===========================================================================
.text$mn:00004C00
.text$mn:00004C00 ; Segment type: Pure code
.text$mn:00004C00 ; Segment permissions: Read/Execute
.text$mn:00004C00 _text$mn        segment para public 'CODE' use32
.text$mn:00004C00                 assume cs:_text$mn
.text$mn:00004C00                 ;org 4C00h
.text$mn:00004C00 ; COMDAT (pick any)
.text$mn:00004C00                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C00
.text$mn:00004C00 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C00
.text$mn:00004C00 ; Attributes: bp-based frame
.text$mn:00004C00
.text$mn:00004C00 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::max_size(void)const
.text$mn:00004C00                 public ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00004C00 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00004C00                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+3Bp
.text$mn:00004C00                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Copy(uint,uint)+6Ap ...
.text$mn:00004C00
.text$mn:00004C00 var_10          = dword ptr -10h
.text$mn:00004C00 var_C           = dword ptr -0Ch
.text$mn:00004C00 var_8           = dword ptr -8
.text$mn:00004C00 var_1           = byte ptr -1
.text$mn:00004C00
.text$mn:00004C00                 push    ebp
.text$mn:00004C01                 mov     ebp, esp
.text$mn:00004C03                 sub     esp, 10h
.text$mn:00004C06                 mov     [ebp+var_10], ecx
.text$mn:00004C09                 lea     eax, [ebp+var_1]
.text$mn:00004C0C                 push    eax
.text$mn:00004C0D                 mov     ecx, [ebp+var_10]
.text$mn:00004C10                 call    ?_Getal@?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<0,std::_String_base_types<char,std::allocator<char>>>::_Getal(void)
.text$mn:00004C15                 mov     ecx, eax
.text$mn:00004C17                 call    ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<char>>::max_size(void)
.text$mn:00004C1C                 mov     [ebp+var_8], eax
.text$mn:00004C1F                 cmp     [ebp+var_8], 1
.text$mn:00004C23                 ja      short loc_4C2E
.text$mn:00004C25                 mov     [ebp+var_C], 1
.text$mn:00004C2C                 jmp     short loc_4C37
.text$mn:00004C2E ; ---------------------------------------------------------------------------
.text$mn:00004C2E
.text$mn:00004C2E loc_4C2E:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+23j
.text$mn:00004C2E                 mov     ecx, [ebp+var_8]
.text$mn:00004C31                 sub     ecx, 1
.text$mn:00004C34                 mov     [ebp+var_C], ecx
.text$mn:00004C37
.text$mn:00004C37 loc_4C37:                               ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::max_size(void)+2Cj
.text$mn:00004C37                 mov     eax, [ebp+var_C]
.text$mn:00004C3A                 mov     esp, ebp
.text$mn:00004C3C                 pop     ebp
.text$mn:00004C3D                 retn
.text$mn:00004C3D ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00004C3D
.text$mn:00004C3D ; ---------------------------------------------------------------------------
.text$mn:00004C3E                 align 10h
.text$mn:00004C3E _text$mn        ends
.text$mn:00004C3E
.text$mn:00004C40 ; ===========================================================================
.text$mn:00004C40
.text$mn:00004C40 ; Segment type: Pure code
.text$mn:00004C40 ; Segment permissions: Read/Execute
.text$mn:00004C40 _text$mn        segment para public 'CODE' use32
.text$mn:00004C40                 assume cs:_text$mn
.text$mn:00004C40                 ;org 4C40h
.text$mn:00004C40 ; COMDAT (pick any)
.text$mn:00004C40                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C40
.text$mn:00004C40 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C40
.text$mn:00004C40 ; Attributes: bp-based frame
.text$mn:00004C40
.text$mn:00004C40 ; public: unsigned int __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::max_size(void)const
.text$mn:00004C40                 public ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:00004C40 ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:00004C40                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Buy(uint)+36p
.text$mn:00004C40
.text$mn:00004C40 var_8           = dword ptr -8
.text$mn:00004C40 var_1           = byte ptr -1
.text$mn:00004C40
.text$mn:00004C40                 push    ebp
.text$mn:00004C41                 mov     ebp, esp
.text$mn:00004C43                 sub     esp, 8
.text$mn:00004C46                 mov     [ebp+var_8], ecx
.text$mn:00004C49                 lea     eax, [ebp+var_1]
.text$mn:00004C4C                 push    eax
.text$mn:00004C4D                 mov     ecx, [ebp+var_8]
.text$mn:00004C50                 call    ?_Getal@?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QBE?AU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@XZ ; std::_Vector_alloc<0,std::_Vec_base_types<DockingCont *,std::allocator<DockingCont *>>>::_Getal(void)
.text$mn:00004C55                 mov     ecx, eax
.text$mn:00004C57                 call    ?max_size@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ ; std::_Wrap_alloc<std::allocator<DockingCont *>>::max_size(void)
.text$mn:00004C5C                 mov     esp, ebp
.text$mn:00004C5E                 pop     ebp
.text$mn:00004C5F                 retn
.text$mn:00004C5F ?max_size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:00004C5F
.text$mn:00004C5F _text$mn        ends
.text$mn:00004C5F
.text$mn:00004C60 ; ===========================================================================
.text$mn:00004C60
.text$mn:00004C60 ; Segment type: Pure code
.text$mn:00004C60 ; Segment permissions: Read/Execute
.text$mn:00004C60 _text$mn        segment para public 'CODE' use32
.text$mn:00004C60                 assume cs:_text$mn
.text$mn:00004C60                 ;org 4C60h
.text$mn:00004C60 ; COMDAT (pick any)
.text$mn:00004C60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004C60
.text$mn:00004C60 ; =============== S U B R O U T I N E =======================================
.text$mn:00004C60
.text$mn:00004C60 ; Attributes: bp-based frame
.text$mn:00004C60
.text$mn:00004C60 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Generic_error_category::message(int)const
.text$mn:00004C60                 public ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004C60 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00004C60                                         ; CODE XREF: std::_Iostream_error_category::message(int)+64p
.text$mn:00004C60                                         ; DATA XREF: .rdata:00005A18o
.text$mn:00004C60
.text$mn:00004C60 var_1C          = dword ptr -1Ch
.text$mn:00004C60 var_18          = dword ptr -18h
.text$mn:00004C60 Str             = dword ptr -14h
.text$mn:00004C60 var_10          = dword ptr -10h
.text$mn:00004C60 var_C           = dword ptr -0Ch
.text$mn:00004C60 var_4           = dword ptr -4
.text$mn:00004C60 arg_0           = dword ptr  8
.text$mn:00004C60 arg_4           = dword ptr  0Ch
.text$mn:00004C60
.text$mn:00004C60                 push    ebp
.text$mn:00004C61                 mov     ebp, esp
.text$mn:00004C63                 push    0FFFFFFFFh
.text$mn:00004C65                 push    offset __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004C6A                 mov     eax, large fs:0
.text$mn:00004C70                 push    eax
.text$mn:00004C71                 sub     esp, 10h
.text$mn:00004C74                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004C79                 xor     eax, ebp
.text$mn:00004C7B                 push    eax
.text$mn:00004C7C                 lea     eax, [ebp+var_C]
.text$mn:00004C7F                 mov     large fs:0, eax
.text$mn:00004C85                 mov     [ebp+var_1C], ecx
.text$mn:00004C88                 mov     [ebp+var_18], 0
.text$mn:00004C8F                 mov     eax, [ebp+arg_4]
.text$mn:00004C92                 push    eax             ; int
.text$mn:00004C93                 call    ?_Syserror_map@std@@YAPBDH@Z ; std::_Syserror_map(int)
.text$mn:00004C98                 add     esp, 4
.text$mn:00004C9B                 mov     [ebp+var_10], eax
.text$mn:00004C9E                 cmp     [ebp+var_10], 0
.text$mn:00004CA2                 jz      short loc_4CAC
.text$mn:00004CA4                 mov     ecx, [ebp+var_10]
.text$mn:00004CA7                 mov     [ebp+Str], ecx
.text$mn:00004CAA                 jmp     short loc_4CB3
.text$mn:00004CAC ; ---------------------------------------------------------------------------
.text$mn:00004CAC
.text$mn:00004CAC loc_4CAC:                               ; CODE XREF: std::_Generic_error_category::message(int)+42j
.text$mn:00004CAC                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00004CB3
.text$mn:00004CB3 loc_4CB3:                               ; CODE XREF: std::_Generic_error_category::message(int)+4Aj
.text$mn:00004CB3                 mov     edx, [ebp+Str]
.text$mn:00004CB6                 push    edx             ; Str
.text$mn:00004CB7                 mov     ecx, [ebp+arg_0]
.text$mn:00004CBA                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00004CBF                 mov     [ebp+var_4], 0
.text$mn:00004CC6                 mov     eax, [ebp+var_18]
.text$mn:00004CC9                 or      eax, 1
.text$mn:00004CCC                 mov     [ebp+var_18], eax
.text$mn:00004CCF                 mov     eax, [ebp+arg_0]
.text$mn:00004CD2                 mov     ecx, [ebp+var_C]
.text$mn:00004CD5                 mov     large fs:0, ecx
.text$mn:00004CDC                 pop     ecx
.text$mn:00004CDD                 mov     esp, ebp
.text$mn:00004CDF                 pop     ebp
.text$mn:00004CE0                 retn    8
.text$mn:00004CE0 ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00004CE0
.text$mn:00004CE0 ; ---------------------------------------------------------------------------
.text$mn:00004CE3                 align 4
.text$mn:00004CE3 _text$mn        ends
.text$mn:00004CE3
.text$x:00004CE4 ; ===========================================================================
.text$x:00004CE4
.text$x:00004CE4 ; Segment type: Pure code
.text$x:00004CE4 ; Segment permissions: Read/Execute
.text$x:00004CE4 _text$x         segment para public 'CODE' use32
.text$x:00004CE4                 assume cs:_text$x
.text$x:00004CE4                 ;org 4CE4h
.text$x:00004CE4 ; COMDAT (pick associative to section at 4C60)
.text$x:00004CE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004CE4
.text$x:00004CE4 ; =============== S U B R O U T I N E =======================================
.text$x:00004CE4
.text$x:00004CE4
.text$x:00004CE4 __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00004CE4                                         ; DATA XREF: .xdata$x:000052F8o
.text$x:00004CE4                 mov     eax, [ebp-18h]
.text$x:00004CE7                 and     eax, 1
.text$x:00004CEA                 jz      $LN6
.text$x:00004CF0                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00004CF4                 mov     ecx, [ebp+8]
.text$x:00004CF7                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00004CFC ; ---------------------------------------------------------------------------
.text$x:00004CFC
.text$x:00004CFC $LN6:                                   ; CODE XREF: __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00004CFC                 retn
.text$x:00004CFC __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00004CFC
.text$x:00004CFD
.text$x:00004CFD ; =============== S U B R O U T I N E =======================================
.text$x:00004CFD
.text$x:00004CFD
.text$x:00004CFD __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00004CFD                                         ; DATA XREF: std::_Generic_error_category::message(int)+5o
.text$x:00004CFD
.text$x:00004CFD arg_4           = dword ptr  8
.text$x:00004CFD
.text$x:00004CFD                 mov     edx, [esp+arg_4]
.text$x:00004D01                 lea     eax, [edx+0Ch]
.text$x:00004D04                 mov     ecx, [edx-14h]
.text$x:00004D07                 xor     ecx, eax
.text$x:00004D09                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004D0E                 mov     eax, offset __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00004D13                 jmp     ___CxxFrameHandler3
.text$x:00004D13 __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00004D13
.text$x:00004D13 _text$x         ends
.text$x:00004D13
.text$mn:00004D18 ; ===========================================================================
.text$mn:00004D18
.text$mn:00004D18 ; Segment type: Pure code
.text$mn:00004D18 ; Segment permissions: Read/Execute
.text$mn:00004D18 _text$mn        segment para public 'CODE' use32
.text$mn:00004D18                 assume cs:_text$mn
.text$mn:00004D18                 ;org 4D18h
.text$mn:00004D18 ; COMDAT (pick any)
.text$mn:00004D18                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004D18
.text$mn:00004D18 ; =============== S U B R O U T I N E =======================================
.text$mn:00004D18
.text$mn:00004D18 ; Attributes: bp-based frame
.text$mn:00004D18
.text$mn:00004D18 ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_Iostream_error_category::message(int)const
.text$mn:00004D18                 public ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004D18 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00004D18                                         ; DATA XREF: .rdata:00005A4Co
.text$mn:00004D18
.text$mn:00004D18 var_14          = dword ptr -14h
.text$mn:00004D18 var_10          = dword ptr -10h
.text$mn:00004D18 var_C           = dword ptr -0Ch
.text$mn:00004D18 var_4           = dword ptr -4
.text$mn:00004D18 arg_0           = dword ptr  8
.text$mn:00004D18 arg_4           = dword ptr  0Ch
.text$mn:00004D18
.text$mn:00004D18                 push    ebp
.text$mn:00004D19                 mov     ebp, esp
.text$mn:00004D1B                 push    0FFFFFFFFh
.text$mn:00004D1D                 push    offset __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004D22                 mov     eax, large fs:0
.text$mn:00004D28                 push    eax
.text$mn:00004D29                 sub     esp, 8
.text$mn:00004D2C                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004D31                 xor     eax, ebp
.text$mn:00004D33                 push    eax
.text$mn:00004D34                 lea     eax, [ebp+var_C]
.text$mn:00004D37                 mov     large fs:0, eax
.text$mn:00004D3D                 mov     [ebp+var_14], ecx
.text$mn:00004D40                 mov     [ebp+var_10], 0
.text$mn:00004D47                 cmp     [ebp+arg_4], 1
.text$mn:00004D4B                 jnz     short loc_4D71
.text$mn:00004D4D                 push    offset ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ ; "iostream stream error"
.text$mn:00004D52                 mov     ecx, [ebp+arg_0]
.text$mn:00004D55                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00004D5A                 mov     [ebp+var_4], 0
.text$mn:00004D61                 mov     eax, [ebp+var_10]
.text$mn:00004D64                 or      eax, 1
.text$mn:00004D67                 mov     [ebp+var_10], eax
.text$mn:00004D6A                 mov     eax, [ebp+arg_0]
.text$mn:00004D6D                 jmp     short loc_4D94
.text$mn:00004D6F ; ---------------------------------------------------------------------------
.text$mn:00004D6F                 jmp     short loc_4D94
.text$mn:00004D71 ; ---------------------------------------------------------------------------
.text$mn:00004D71
.text$mn:00004D71 loc_4D71:                               ; CODE XREF: std::_Iostream_error_category::message(int)+33j
.text$mn:00004D71                 mov     ecx, [ebp+arg_4]
.text$mn:00004D74                 push    ecx
.text$mn:00004D75                 mov     edx, [ebp+arg_0]
.text$mn:00004D78                 push    edx
.text$mn:00004D79                 mov     ecx, [ebp+var_14]
.text$mn:00004D7C                 call    ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.text$mn:00004D81                 mov     [ebp+var_4], 0
.text$mn:00004D88                 mov     eax, [ebp+var_10]
.text$mn:00004D8B                 or      eax, 1
.text$mn:00004D8E                 mov     [ebp+var_10], eax
.text$mn:00004D91                 mov     eax, [ebp+arg_0]
.text$mn:00004D94
.text$mn:00004D94 loc_4D94:                               ; CODE XREF: std::_Iostream_error_category::message(int)+55j
.text$mn:00004D94                                         ; std::_Iostream_error_category::message(int)+57j
.text$mn:00004D94                 mov     ecx, [ebp+var_C]
.text$mn:00004D97                 mov     large fs:0, ecx
.text$mn:00004D9E                 pop     ecx
.text$mn:00004D9F                 mov     esp, ebp
.text$mn:00004DA1                 pop     ebp
.text$mn:00004DA2                 retn    8
.text$mn:00004DA2 ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00004DA2
.text$mn:00004DA2 ; ---------------------------------------------------------------------------
.text$mn:00004DA5                 align 4
.text$mn:00004DA5 _text$mn        ends
.text$mn:00004DA5
.text$x:00004DA8 ; ===========================================================================
.text$x:00004DA8
.text$x:00004DA8 ; Segment type: Pure code
.text$x:00004DA8 ; Segment permissions: Read/Execute
.text$x:00004DA8 _text$x         segment para public 'CODE' use32
.text$x:00004DA8                 assume cs:_text$x
.text$x:00004DA8                 ;org 4DA8h
.text$x:00004DA8 ; COMDAT (pick associative to section at 4D18)
.text$x:00004DA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004DA8
.text$x:00004DA8 ; =============== S U B R O U T I N E =======================================
.text$x:00004DA8
.text$x:00004DA8
.text$x:00004DA8 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00004DA8                                         ; DATA XREF: .xdata$x:0000537Co
.text$x:00004DA8                 mov     eax, [ebp-10h]
.text$x:00004DAB                 and     eax, 1
.text$x:00004DAE                 jz      $LN6_0
.text$x:00004DB4                 and     dword ptr [ebp-10h], 0FFFFFFFEh
.text$x:00004DB8                 mov     ecx, [ebp+8]
.text$x:00004DBB                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00004DC0 ; ---------------------------------------------------------------------------
.text$x:00004DC0
.text$x:00004DC0 $LN6_0:                                 ; CODE XREF: __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00004DC0                 retn
.text$x:00004DC0 __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00004DC0
.text$x:00004DC1
.text$x:00004DC1 ; =============== S U B R O U T I N E =======================================
.text$x:00004DC1
.text$x:00004DC1
.text$x:00004DC1 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00004DC1                                         ; DATA XREF: std::_Iostream_error_category::message(int)+5o
.text$x:00004DC1
.text$x:00004DC1 arg_4           = dword ptr  8
.text$x:00004DC1
.text$x:00004DC1                 mov     edx, [esp+arg_4]
.text$x:00004DC5                 lea     eax, [edx+0Ch]
.text$x:00004DC8                 mov     ecx, [edx-0Ch]
.text$x:00004DCB                 xor     ecx, eax
.text$x:00004DCD                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004DD2                 mov     eax, offset __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00004DD7                 jmp     ___CxxFrameHandler3
.text$x:00004DD7 __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00004DD7
.text$x:00004DD7 _text$x         ends
.text$x:00004DD7
.text$mn:00004DDC ; ===========================================================================
.text$mn:00004DDC
.text$mn:00004DDC ; Segment type: Pure code
.text$mn:00004DDC ; Segment permissions: Read/Execute
.text$mn:00004DDC _text$mn        segment para public 'CODE' use32
.text$mn:00004DDC                 assume cs:_text$mn
.text$mn:00004DDC                 ;org 4DDCh
.text$mn:00004DDC ; COMDAT (pick any)
.text$mn:00004DDC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004DDC
.text$mn:00004DDC ; =============== S U B R O U T I N E =======================================
.text$mn:00004DDC
.text$mn:00004DDC ; Attributes: bp-based frame
.text$mn:00004DDC
.text$mn:00004DDC ; public: virtual class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>> __thiscall std::_System_error_category::message(int)const
.text$mn:00004DDC                 public ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004DDC ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$mn:00004DDC                                         ; DATA XREF: .rdata:00005A8Co
.text$mn:00004DDC
.text$mn:00004DDC var_1C          = dword ptr -1Ch
.text$mn:00004DDC var_18          = dword ptr -18h
.text$mn:00004DDC Str             = dword ptr -14h
.text$mn:00004DDC var_10          = dword ptr -10h
.text$mn:00004DDC var_C           = dword ptr -0Ch
.text$mn:00004DDC var_4           = dword ptr -4
.text$mn:00004DDC arg_0           = dword ptr  8
.text$mn:00004DDC arg_4           = dword ptr  0Ch
.text$mn:00004DDC
.text$mn:00004DDC                 push    ebp
.text$mn:00004DDD                 mov     ebp, esp
.text$mn:00004DDF                 push    0FFFFFFFFh
.text$mn:00004DE1                 push    offset __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$mn:00004DE6                 mov     eax, large fs:0
.text$mn:00004DEC                 push    eax
.text$mn:00004DED                 sub     esp, 10h
.text$mn:00004DF0                 mov     eax, dword ptr ds:___security_cookie
.text$mn:00004DF5                 xor     eax, ebp
.text$mn:00004DF7                 push    eax
.text$mn:00004DF8                 lea     eax, [ebp+var_C]
.text$mn:00004DFB                 mov     large fs:0, eax
.text$mn:00004E01                 mov     [ebp+var_1C], ecx
.text$mn:00004E04                 mov     [ebp+var_18], 0
.text$mn:00004E0B                 mov     eax, [ebp+arg_4]
.text$mn:00004E0E                 push    eax             ; int
.text$mn:00004E0F                 call    ?_Winerror_map@std@@YAPBDH@Z ; std::_Winerror_map(int)
.text$mn:00004E14                 add     esp, 4
.text$mn:00004E17                 mov     [ebp+var_10], eax
.text$mn:00004E1A                 cmp     [ebp+var_10], 0
.text$mn:00004E1E                 jz      short loc_4E28
.text$mn:00004E20                 mov     ecx, [ebp+var_10]
.text$mn:00004E23                 mov     [ebp+Str], ecx
.text$mn:00004E26                 jmp     short loc_4E2F
.text$mn:00004E28 ; ---------------------------------------------------------------------------
.text$mn:00004E28
.text$mn:00004E28 loc_4E28:                               ; CODE XREF: std::_System_error_category::message(int)+42j
.text$mn:00004E28                 mov     [ebp+Str], offset ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ ; "unknown error"
.text$mn:00004E2F
.text$mn:00004E2F loc_4E2F:                               ; CODE XREF: std::_System_error_category::message(int)+4Aj
.text$mn:00004E2F                 mov     edx, [ebp+Str]
.text$mn:00004E32                 push    edx             ; Str
.text$mn:00004E33                 mov     ecx, [ebp+arg_0]
.text$mn:00004E36                 call    ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::basic_string<char,std::char_traits<char>,std::allocator<char>>(char const *)
.text$mn:00004E3B                 mov     [ebp+var_4], 0
.text$mn:00004E42                 mov     eax, [ebp+var_18]
.text$mn:00004E45                 or      eax, 1
.text$mn:00004E48                 mov     [ebp+var_18], eax
.text$mn:00004E4B                 mov     eax, [ebp+arg_0]
.text$mn:00004E4E                 mov     ecx, [ebp+var_C]
.text$mn:00004E51                 mov     large fs:0, ecx
.text$mn:00004E58                 pop     ecx
.text$mn:00004E59                 mov     esp, ebp
.text$mn:00004E5B                 pop     ebp
.text$mn:00004E5C                 retn    8
.text$mn:00004E5C ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$mn:00004E5C
.text$mn:00004E5C ; ---------------------------------------------------------------------------
.text$mn:00004E5F                 align 10h
.text$mn:00004E5F _text$mn        ends
.text$mn:00004E5F
.text$x:00004E60 ; ===========================================================================
.text$x:00004E60
.text$x:00004E60 ; Segment type: Pure code
.text$x:00004E60 ; Segment permissions: Read/Execute
.text$x:00004E60 _text$x         segment para public 'CODE' use32
.text$x:00004E60                 assume cs:_text$x
.text$x:00004E60                 ;org 4E60h
.text$x:00004E60 ; COMDAT (pick associative to section at 4DDC)
.text$x:00004E60                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$x:00004E60
.text$x:00004E60 ; =============== S U B R O U T I N E =======================================
.text$x:00004E60
.text$x:00004E60
.text$x:00004E60 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 proc near
.text$x:00004E60                                         ; DATA XREF: .xdata$x:00005400o
.text$x:00004E60                 mov     eax, [ebp-18h]
.text$x:00004E63                 and     eax, 1
.text$x:00004E66                 jz      $LN6_1
.text$x:00004E6C                 and     dword ptr [ebp-18h], 0FFFFFFFEh
.text$x:00004E70                 mov     ecx, [ebp+8]
.text$x:00004E73                 jmp     ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string<char,std::char_traits<char>,std::allocator<char>>(void)
.text$x:00004E78 ; ---------------------------------------------------------------------------
.text$x:00004E78
.text$x:00004E78 $LN6_1:                                 ; CODE XREF: __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0+6j
.text$x:00004E78                 retn
.text$x:00004E78 __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0 endp
.text$x:00004E78
.text$x:00004E79
.text$x:00004E79 ; =============== S U B R O U T I N E =======================================
.text$x:00004E79
.text$x:00004E79
.text$x:00004E79 __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z proc near
.text$x:00004E79                                         ; DATA XREF: std::_System_error_category::message(int)+5o
.text$x:00004E79
.text$x:00004E79 arg_4           = dword ptr  8
.text$x:00004E79
.text$x:00004E79                 mov     edx, [esp+arg_4]
.text$x:00004E7D                 lea     eax, [edx+0Ch]
.text$x:00004E80                 mov     ecx, [edx-14h]
.text$x:00004E83                 xor     ecx, eax
.text$x:00004E85                 call    @__security_check_cookie@4 ; __security_check_cookie(x)
.text$x:00004E8A                 mov     eax, offset __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.text$x:00004E8F                 jmp     ___CxxFrameHandler3
.text$x:00004E8F __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z endp
.text$x:00004E8F
.text$x:00004E8F _text$x         ends
.text$x:00004E8F
.text$mn:00004E94 ; ===========================================================================
.text$mn:00004E94
.text$mn:00004E94 ; Segment type: Pure code
.text$mn:00004E94 ; Segment permissions: Read/Execute
.text$mn:00004E94 _text$mn        segment para public 'CODE' use32
.text$mn:00004E94                 assume cs:_text$mn
.text$mn:00004E94                 ;org 4E94h
.text$mn:00004E94 ; COMDAT (pick any)
.text$mn:00004E94                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004E94
.text$mn:00004E94 ; =============== S U B R O U T I N E =======================================
.text$mn:00004E94
.text$mn:00004E94 ; Attributes: bp-based frame
.text$mn:00004E94
.text$mn:00004E94 ; int __cdecl std::char_traits<char>::move(void *Dst, void *Src, size_t Size)
.text$mn:00004E94                 public ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
.text$mn:00004E94 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z proc near
.text$mn:00004E94                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::erase(uint,uint)+6Ap
.text$mn:00004E94
.text$mn:00004E94 var_4           = dword ptr -4
.text$mn:00004E94 Dst             = dword ptr  8
.text$mn:00004E94 Src             = dword ptr  0Ch
.text$mn:00004E94 Size            = dword ptr  10h
.text$mn:00004E94
.text$mn:00004E94                 push    ebp
.text$mn:00004E95                 mov     ebp, esp
.text$mn:00004E97                 push    ecx
.text$mn:00004E98                 cmp     [ebp+Size], 0
.text$mn:00004E9C                 jnz     short loc_4EA6
.text$mn:00004E9E                 mov     eax, [ebp+Dst]
.text$mn:00004EA1                 mov     [ebp+var_4], eax
.text$mn:00004EA4                 jmp     short loc_4EBD
.text$mn:00004EA6 ; ---------------------------------------------------------------------------
.text$mn:00004EA6
.text$mn:00004EA6 loc_4EA6:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+8j
.text$mn:00004EA6                 mov     ecx, [ebp+Size]
.text$mn:00004EA9                 push    ecx             ; Size
.text$mn:00004EAA                 mov     edx, [ebp+Src]
.text$mn:00004EAD                 push    edx             ; Src
.text$mn:00004EAE                 mov     eax, [ebp+Dst]
.text$mn:00004EB1                 push    eax             ; Dst
.text$mn:00004EB2                 call    _memmove
.text$mn:00004EB7                 add     esp, 0Ch
.text$mn:00004EBA                 mov     [ebp+var_4], eax
.text$mn:00004EBD
.text$mn:00004EBD loc_4EBD:                               ; CODE XREF: std::char_traits<char>::move(char *,char const *,uint)+10j
.text$mn:00004EBD                 mov     eax, [ebp+var_4]
.text$mn:00004EC0                 mov     esp, ebp
.text$mn:00004EC2                 pop     ebp
.text$mn:00004EC3                 retn
.text$mn:00004EC3 ?move@?$char_traits@D@std@@SAPADPADPBDI@Z endp
.text$mn:00004EC3
.text$mn:00004EC3 _text$mn        ends
.text$mn:00004EC3
.text$mn:00004EC4 ; ===========================================================================
.text$mn:00004EC4
.text$mn:00004EC4 ; Segment type: Pure code
.text$mn:00004EC4 ; Segment permissions: Read/Execute
.text$mn:00004EC4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EC4                 assume cs:_text$mn
.text$mn:00004EC4                 ;org 4EC4h
.text$mn:00004EC4 ; COMDAT (pick any)
.text$mn:00004EC4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EC4
.text$mn:00004EC4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EC4
.text$mn:00004EC4 ; Attributes: bp-based frame
.text$mn:00004EC4
.text$mn:00004EC4 ; const char *__thiscall std::_Generic_error_category::name(std::_Generic_error_category *__hidden this)
.text$mn:00004EC4                 public ?name@_Generic_error_category@std@@UBEPBDXZ
.text$mn:00004EC4 ?name@_Generic_error_category@std@@UBEPBDXZ proc near
.text$mn:00004EC4                                         ; DATA XREF: .rdata:00005A14o
.text$mn:00004EC4
.text$mn:00004EC4 var_4           = dword ptr -4
.text$mn:00004EC4
.text$mn:00004EC4                 push    ebp
.text$mn:00004EC5                 mov     ebp, esp
.text$mn:00004EC7                 push    ecx
.text$mn:00004EC8                 mov     [ebp+var_4], ecx
.text$mn:00004ECB                 mov     eax, offset ??_C@_07DCLBNMLN@generic?$AA@ ; "generic"
.text$mn:00004ED0                 mov     esp, ebp
.text$mn:00004ED2                 pop     ebp
.text$mn:00004ED3                 retn
.text$mn:00004ED3 ?name@_Generic_error_category@std@@UBEPBDXZ endp
.text$mn:00004ED3
.text$mn:00004ED3 _text$mn        ends
.text$mn:00004ED3
.text$mn:00004ED4 ; ===========================================================================
.text$mn:00004ED4
.text$mn:00004ED4 ; Segment type: Pure code
.text$mn:00004ED4 ; Segment permissions: Read/Execute
.text$mn:00004ED4 _text$mn        segment para public 'CODE' use32
.text$mn:00004ED4                 assume cs:_text$mn
.text$mn:00004ED4                 ;org 4ED4h
.text$mn:00004ED4 ; COMDAT (pick any)
.text$mn:00004ED4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004ED4
.text$mn:00004ED4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004ED4
.text$mn:00004ED4 ; Attributes: bp-based frame
.text$mn:00004ED4
.text$mn:00004ED4 ; const char *__thiscall std::_Iostream_error_category::name(std::_Iostream_error_category *__hidden this)
.text$mn:00004ED4                 public ?name@_Iostream_error_category@std@@UBEPBDXZ
.text$mn:00004ED4 ?name@_Iostream_error_category@std@@UBEPBDXZ proc near
.text$mn:00004ED4                                         ; DATA XREF: .rdata:00005A48o
.text$mn:00004ED4
.text$mn:00004ED4 var_4           = dword ptr -4
.text$mn:00004ED4
.text$mn:00004ED4                 push    ebp
.text$mn:00004ED5                 mov     ebp, esp
.text$mn:00004ED7                 push    ecx
.text$mn:00004ED8                 mov     [ebp+var_4], ecx
.text$mn:00004EDB                 mov     eax, offset ??_C@_08LLGCOLLL@iostream?$AA@ ; "iostream"
.text$mn:00004EE0                 mov     esp, ebp
.text$mn:00004EE2                 pop     ebp
.text$mn:00004EE3                 retn
.text$mn:00004EE3 ?name@_Iostream_error_category@std@@UBEPBDXZ endp
.text$mn:00004EE3
.text$mn:00004EE3 _text$mn        ends
.text$mn:00004EE3
.text$mn:00004EE4 ; ===========================================================================
.text$mn:00004EE4
.text$mn:00004EE4 ; Segment type: Pure code
.text$mn:00004EE4 ; Segment permissions: Read/Execute
.text$mn:00004EE4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EE4                 assume cs:_text$mn
.text$mn:00004EE4                 ;org 4EE4h
.text$mn:00004EE4 ; COMDAT (pick any)
.text$mn:00004EE4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EE4
.text$mn:00004EE4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EE4
.text$mn:00004EE4 ; Attributes: bp-based frame
.text$mn:00004EE4
.text$mn:00004EE4 ; const char *__thiscall std::_System_error_category::name(std::_System_error_category *__hidden this)
.text$mn:00004EE4                 public ?name@_System_error_category@std@@UBEPBDXZ
.text$mn:00004EE4 ?name@_System_error_category@std@@UBEPBDXZ proc near
.text$mn:00004EE4                                         ; DATA XREF: .rdata:00005A88o
.text$mn:00004EE4
.text$mn:00004EE4 var_4           = dword ptr -4
.text$mn:00004EE4
.text$mn:00004EE4                 push    ebp
.text$mn:00004EE5                 mov     ebp, esp
.text$mn:00004EE7                 push    ecx
.text$mn:00004EE8                 mov     [ebp+var_4], ecx
.text$mn:00004EEB                 mov     eax, offset ??_C@_06FHFOAHML@system?$AA@ ; "system"
.text$mn:00004EF0                 mov     esp, ebp
.text$mn:00004EF2                 pop     ebp
.text$mn:00004EF3                 retn
.text$mn:00004EF3 ?name@_System_error_category@std@@UBEPBDXZ endp
.text$mn:00004EF3
.text$mn:00004EF3 _text$mn        ends
.text$mn:00004EF3
.text$mn:00004EF4 ; ===========================================================================
.text$mn:00004EF4
.text$mn:00004EF4 ; Segment type: Pure code
.text$mn:00004EF4 ; Segment permissions: Read/Execute
.text$mn:00004EF4 _text$mn        segment para public 'CODE' use32
.text$mn:00004EF4                 assume cs:_text$mn
.text$mn:00004EF4                 ;org 4EF4h
.text$mn:00004EF4 ; COMDAT (pick any)
.text$mn:00004EF4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004EF4
.text$mn:00004EF4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004EF4
.text$mn:00004EF4 ; Attributes: bp-based frame
.text$mn:00004EF4
.text$mn:00004EF4 ; public: struct std::_Wrap_alloc<class std::allocator<class DockingCont *>> __thiscall std::_Wrap_alloc<class std::allocator<class DockingCont *>>::select_on_container_copy_construction(void)const
.text$mn:00004EF4                 public ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AU12@XZ
.text$mn:00004EF4 ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AU12@XZ proc near
.text$mn:00004EF4                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::vector<DockingCont *,std::allocator<DockingCont *>>(std::vector<DockingCont *,std::allocator<DockingCont *>> const &)+41p
.text$mn:00004EF4
.text$mn:00004EF4 var_8           = dword ptr -8
.text$mn:00004EF4 var_1           = byte ptr -1
.text$mn:00004EF4 arg_0           = dword ptr  8
.text$mn:00004EF4
.text$mn:00004EF4                 push    ebp
.text$mn:00004EF5                 mov     ebp, esp
.text$mn:00004EF7                 sub     esp, 8
.text$mn:00004EFA                 mov     [ebp+var_8], ecx
.text$mn:00004EFD                 mov     eax, [ebp+var_8]
.text$mn:00004F00                 push    eax
.text$mn:00004F01                 lea     ecx, [ebp+var_1]
.text$mn:00004F04                 push    ecx
.text$mn:00004F05                 call    ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SA?AV?$allocator@PAVDockingCont@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<DockingCont *>>::select_on_container_copy_construction(std::allocator<DockingCont *> const &)
.text$mn:00004F0A                 add     esp, 8
.text$mn:00004F0D                 push    eax
.text$mn:00004F0E                 mov     ecx, [ebp+arg_0]
.text$mn:00004F11                 call    ??0?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z ; std::_Wrap_alloc<std::allocator<DockingCont *>>::_Wrap_alloc<std::allocator<DockingCont *>>(std::allocator<DockingCont *> const &)
.text$mn:00004F16                 mov     eax, [ebp+arg_0]
.text$mn:00004F19                 mov     esp, ebp
.text$mn:00004F1B                 pop     ebp
.text$mn:00004F1C                 retn    4
.text$mn:00004F1C ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AU12@XZ endp
.text$mn:00004F1C
.text$mn:00004F1C ; ---------------------------------------------------------------------------
.text$mn:00004F1F                 align 10h
.text$mn:00004F1F _text$mn        ends
.text$mn:00004F1F
.text$mn:00004F20 ; ===========================================================================
.text$mn:00004F20
.text$mn:00004F20 ; Segment type: Pure code
.text$mn:00004F20 ; Segment permissions: Read/Execute
.text$mn:00004F20 _text$mn        segment para public 'CODE' use32
.text$mn:00004F20                 assume cs:_text$mn
.text$mn:00004F20                 ;org 4F20h
.text$mn:00004F20 ; COMDAT (pick any)
.text$mn:00004F20                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F20
.text$mn:00004F20 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F20
.text$mn:00004F20 ; Attributes: bp-based frame
.text$mn:00004F20
.text$mn:00004F20 ; public: class std::allocator<class DockingCont *> __thiscall std::allocator<class DockingCont *>::select_on_container_copy_construction(void)const
.text$mn:00004F20                 public ?select_on_container_copy_construction@?$allocator@PAVDockingCont@@@std@@QBE?AV12@XZ
.text$mn:00004F20 ?select_on_container_copy_construction@?$allocator@PAVDockingCont@@@std@@QBE?AV12@XZ proc near
.text$mn:00004F20                                         ; CODE XREF: std::allocator_traits<std::allocator<DockingCont *>>::select_on_container_copy_construction(std::allocator<DockingCont *> const &)+Ap
.text$mn:00004F20
.text$mn:00004F20 var_4           = dword ptr -4
.text$mn:00004F20 arg_0           = dword ptr  8
.text$mn:00004F20
.text$mn:00004F20                 push    ebp
.text$mn:00004F21                 mov     ebp, esp
.text$mn:00004F23                 push    ecx
.text$mn:00004F24                 mov     [ebp+var_4], ecx
.text$mn:00004F27                 mov     eax, [ebp+var_4]
.text$mn:00004F2A                 push    eax
.text$mn:00004F2B                 mov     ecx, [ebp+arg_0]
.text$mn:00004F2E                 call    ??0?$allocator@PAVDockingCont@@@std@@QAE@ABV01@@Z ; std::allocator<DockingCont *>::allocator<DockingCont *>(std::allocator<DockingCont *> const &)
.text$mn:00004F33                 mov     eax, [ebp+arg_0]
.text$mn:00004F36                 mov     esp, ebp
.text$mn:00004F38                 pop     ebp
.text$mn:00004F39                 retn    4
.text$mn:00004F39 ?select_on_container_copy_construction@?$allocator@PAVDockingCont@@@std@@QBE?AV12@XZ endp
.text$mn:00004F39
.text$mn:00004F39 _text$mn        ends
.text$mn:00004F39
.text$mn:00004F3C ; ===========================================================================
.text$mn:00004F3C
.text$mn:00004F3C ; Segment type: Pure code
.text$mn:00004F3C ; Segment permissions: Read/Execute
.text$mn:00004F3C _text$mn        segment para public 'CODE' use32
.text$mn:00004F3C                 assume cs:_text$mn
.text$mn:00004F3C                 ;org 4F3Ch
.text$mn:00004F3C ; COMDAT (pick any)
.text$mn:00004F3C                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F3C
.text$mn:00004F3C ; =============== S U B R O U T I N E =======================================
.text$mn:00004F3C
.text$mn:00004F3C ; Attributes: bp-based frame
.text$mn:00004F3C
.text$mn:00004F3C ; public: static class std::allocator<class DockingCont *> __cdecl std::allocator_traits<class std::allocator<class DockingCont *>>::select_on_container_copy_construction(class std::allocator<class DockingCont *> const &)
.text$mn:00004F3C                 public ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SA?AV?$allocator@PAVDockingCont@@@2@ABV32@@Z
.text$mn:00004F3C ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SA?AV?$allocator@PAVDockingCont@@@2@ABV32@@Z proc near
.text$mn:00004F3C                                         ; CODE XREF: std::_Wrap_alloc<std::allocator<DockingCont *>>::select_on_container_copy_construction(void)+11p
.text$mn:00004F3C
.text$mn:00004F3C arg_0           = dword ptr  8
.text$mn:00004F3C arg_4           = dword ptr  0Ch
.text$mn:00004F3C
.text$mn:00004F3C                 push    ebp
.text$mn:00004F3D                 mov     ebp, esp
.text$mn:00004F3F                 mov     eax, [ebp+arg_0]
.text$mn:00004F42                 push    eax
.text$mn:00004F43                 mov     ecx, [ebp+arg_4]
.text$mn:00004F46                 call    ?select_on_container_copy_construction@?$allocator@PAVDockingCont@@@std@@QBE?AV12@XZ ; std::allocator<DockingCont *>::select_on_container_copy_construction(void)
.text$mn:00004F4B                 mov     eax, [ebp+arg_0]
.text$mn:00004F4E                 pop     ebp
.text$mn:00004F4F                 retn
.text$mn:00004F4F ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVDockingCont@@@std@@@std@@SA?AV?$allocator@PAVDockingCont@@@2@ABV32@@Z endp
.text$mn:00004F4F
.text$mn:00004F4F _text$mn        ends
.text$mn:00004F4F
.text$mn:00004F50 ; ===========================================================================
.text$mn:00004F50
.text$mn:00004F50 ; Segment type: Pure code
.text$mn:00004F50 ; Segment permissions: Read/Execute
.text$mn:00004F50 _text$mn        segment para public 'CODE' use32
.text$mn:00004F50                 assume cs:_text$mn
.text$mn:00004F50                 ;org 4F50h
.text$mn:00004F50 ; COMDAT (pick any)
.text$mn:00004F50                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F50
.text$mn:00004F50 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F50
.text$mn:00004F50 ; Attributes: bp-based frame
.text$mn:00004F50
.text$mn:00004F50 ; public: unsigned int __thiscall std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>::size(void)const
.text$mn:00004F50                 public ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
.text$mn:00004F50 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ proc near
.text$mn:00004F50                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+Cp
.text$mn:00004F50                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(std::basic_string<char,std::char_traits<char>,std::allocator<char>> const &,uint,uint)+21p
.text$mn:00004F50
.text$mn:00004F50 var_4           = dword ptr -4
.text$mn:00004F50
.text$mn:00004F50                 push    ebp
.text$mn:00004F51                 mov     ebp, esp
.text$mn:00004F53                 push    ecx
.text$mn:00004F54                 mov     [ebp+var_4], ecx
.text$mn:00004F57                 mov     eax, [ebp+var_4]
.text$mn:00004F5A                 mov     eax, [eax+14h]
.text$mn:00004F5D                 mov     esp, ebp
.text$mn:00004F5F                 pop     ebp
.text$mn:00004F60                 retn
.text$mn:00004F60 ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ endp
.text$mn:00004F60
.text$mn:00004F60 ; ---------------------------------------------------------------------------
.text$mn:00004F61                 align 4
.text$mn:00004F61 _text$mn        ends
.text$mn:00004F61
.text$mn:00004F64 ; ===========================================================================
.text$mn:00004F64
.text$mn:00004F64 ; Segment type: Pure code
.text$mn:00004F64 ; Segment permissions: Read/Execute
.text$mn:00004F64 _text$mn        segment para public 'CODE' use32
.text$mn:00004F64                 assume cs:_text$mn
.text$mn:00004F64                 ;org 4F64h
.text$mn:00004F64 ; COMDAT (pick any)
.text$mn:00004F64                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F64
.text$mn:00004F64 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F64
.text$mn:00004F64 ; Attributes: bp-based frame
.text$mn:00004F64
.text$mn:00004F64 ; public: unsigned int __thiscall std::vector<class DockingCont *, class std::allocator<class DockingCont *>>::size(void)const
.text$mn:00004F64                 public ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ
.text$mn:00004F64 ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ proc near
.text$mn:00004F64                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+7Ap
.text$mn:00004F64                                         ; Gripper::contHitTest(tagPOINT)+61p ...
.text$mn:00004F64
.text$mn:00004F64 var_4           = dword ptr -4
.text$mn:00004F64
.text$mn:00004F64                 push    ebp
.text$mn:00004F65                 mov     ebp, esp
.text$mn:00004F67                 push    ecx
.text$mn:00004F68                 mov     [ebp+var_4], ecx
.text$mn:00004F6B                 mov     eax, [ebp+var_4]
.text$mn:00004F6E                 mov     ecx, [ebp+var_4]
.text$mn:00004F71                 mov     eax, [eax+8]
.text$mn:00004F74                 sub     eax, [ecx+4]
.text$mn:00004F77                 sar     eax, 2
.text$mn:00004F7A                 mov     esp, ebp
.text$mn:00004F7C                 pop     ebp
.text$mn:00004F7D                 retn
.text$mn:00004F7D ?size@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBEIXZ endp
.text$mn:00004F7D
.text$mn:00004F7D ; ---------------------------------------------------------------------------
.text$mn:00004F7E                 align 10h
.text$mn:00004F7E _text$mn        ends
.text$mn:00004F7E
.text$mn:00004F80 ; ===========================================================================
.text$mn:00004F80
.text$mn:00004F80 ; Segment type: Pure code
.text$mn:00004F80 ; Segment permissions: Read/Execute
.text$mn:00004F80 _text$mn        segment para public 'CODE' use32
.text$mn:00004F80                 assume cs:_text$mn
.text$mn:00004F80                 ;org 4F80h
.text$mn:00004F80 ; COMDAT (pick any)
.text$mn:00004F80                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004F80
.text$mn:00004F80 ; =============== S U B R O U T I N E =======================================
.text$mn:00004F80
.text$mn:00004F80 ; Attributes: bp-based frame
.text$mn:00004F80
.text$mn:00004F80 ; int __thiscall DockingCont::startMovingFromTab(DockingCont *__hidden this)
.text$mn:00004F80                 public ?startMovingFromTab@DockingCont@@QAEHXZ
.text$mn:00004F80 ?startMovingFromTab@DockingCont@@QAEHXZ proc near
.text$mn:00004F80                                         ; CODE XREF: Gripper::initTabInformation(void)+21p
.text$mn:00004F80
.text$mn:00004F80 var_8           = dword ptr -8
.text$mn:00004F80 var_4           = dword ptr -4
.text$mn:00004F80
.text$mn:00004F80                 push    ebp
.text$mn:00004F81                 mov     ebp, esp
.text$mn:00004F83                 sub     esp, 8
.text$mn:00004F86                 mov     [ebp+var_4], ecx
.text$mn:00004F89                 mov     eax, [ebp+var_4]
.text$mn:00004F8C                 mov     ecx, [eax+74h]
.text$mn:00004F8F                 mov     [ebp+var_8], ecx
.text$mn:00004F92                 mov     edx, [ebp+var_4]
.text$mn:00004F95                 mov     dword ptr [edx+74h], 0
.text$mn:00004F9C                 mov     eax, [ebp+var_8]
.text$mn:00004F9F                 mov     esp, ebp
.text$mn:00004FA1                 pop     ebp
.text$mn:00004FA2                 retn
.text$mn:00004FA2 ?startMovingFromTab@DockingCont@@QAEHXZ endp
.text$mn:00004FA2
.text$mn:00004FA2 ; ---------------------------------------------------------------------------
.text$mn:00004FA3                 align 4
.text$mn:00004FA3 _text$mn        ends
.text$mn:00004FA3
.text$mn:00004FA4 ; ===========================================================================
.text$mn:00004FA4
.text$mn:00004FA4 ; Segment type: Pure code
.text$mn:00004FA4 ; Segment permissions: Read/Execute
.text$mn:00004FA4 _text$mn        segment para public 'CODE' use32
.text$mn:00004FA4                 assume cs:_text$mn
.text$mn:00004FA4                 ;org 4FA4h
.text$mn:00004FA4 ; COMDAT (pick any)
.text$mn:00004FA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FA4
.text$mn:00004FA4 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FA4
.text$mn:00004FA4 ; Attributes: bp-based frame
.text$mn:00004FA4
.text$mn:00004FA4 ; const struct std::error_category *__cdecl std::system_category()
.text$mn:00004FA4                 public ?system_category@std@@YAABVerror_category@1@XZ
.text$mn:00004FA4 ?system_category@std@@YAABVerror_category@1@XZ proc near
.text$mn:00004FA4                                         ; CODE XREF: std::_System_error_category::default_error_condition(int):loc_4890p
.text$mn:00004FA4                 push    ebp
.text$mn:00004FA5                 mov     ebp, esp
.text$mn:00004FA7                 mov     eax, offset ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A ; std::_System_error_category std::_Error_objects<int>::_System_object
.text$mn:00004FAC                 pop     ebp
.text$mn:00004FAD                 retn
.text$mn:00004FAD ?system_category@std@@YAABVerror_category@1@XZ endp
.text$mn:00004FAD
.text$mn:00004FAD ; ---------------------------------------------------------------------------
.text$mn:00004FAE                 align 10h
.text$mn:00004FAE _text$mn        ends
.text$mn:00004FAE
.text$mn:00004FB0 ; ===========================================================================
.text$mn:00004FB0
.text$mn:00004FB0 ; Segment type: Pure code
.text$mn:00004FB0 ; Segment permissions: Read/Execute
.text$mn:00004FB0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FB0                 assume cs:_text$mn
.text$mn:00004FB0                 ;org 4FB0h
.text$mn:00004FB0 ; COMDAT (pick any)
.text$mn:00004FB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FB0
.text$mn:00004FB0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FB0
.text$mn:00004FB0 ; Attributes: bp-based frame
.text$mn:00004FB0
.text$mn:00004FB0 ; int __thiscall std::error_code::value(std::error_code *__hidden this)
.text$mn:00004FB0                 public ?value@error_code@std@@QBEHXZ
.text$mn:00004FB0 ?value@error_code@std@@QBEHXZ proc near ; CODE XREF: std::error_category::equivalent(std::error_code const &,int)+24p
.text$mn:00004FB0
.text$mn:00004FB0 var_4           = dword ptr -4
.text$mn:00004FB0
.text$mn:00004FB0                 push    ebp
.text$mn:00004FB1                 mov     ebp, esp
.text$mn:00004FB3                 push    ecx
.text$mn:00004FB4                 mov     [ebp+var_4], ecx
.text$mn:00004FB7                 mov     eax, [ebp+var_4]
.text$mn:00004FBA                 mov     eax, [eax]
.text$mn:00004FBC                 mov     esp, ebp
.text$mn:00004FBE                 pop     ebp
.text$mn:00004FBF                 retn
.text$mn:00004FBF ?value@error_code@std@@QBEHXZ endp
.text$mn:00004FBF
.text$mn:00004FBF _text$mn        ends
.text$mn:00004FBF
.text$mn:00004FC0 ; ===========================================================================
.text$mn:00004FC0
.text$mn:00004FC0 ; Segment type: Pure code
.text$mn:00004FC0 ; Segment permissions: Read/Execute
.text$mn:00004FC0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FC0                 assume cs:_text$mn
.text$mn:00004FC0                 ;org 4FC0h
.text$mn:00004FC0 ; COMDAT (pick any)
.text$mn:00004FC0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FC0
.text$mn:00004FC0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FC0
.text$mn:00004FC0 ; Attributes: bp-based frame
.text$mn:00004FC0
.text$mn:00004FC0 ; int __thiscall std::error_condition::value(std::error_condition *__hidden this)
.text$mn:00004FC0                 public ?value@error_condition@std@@QBEHXZ
.text$mn:00004FC0 ?value@error_condition@std@@QBEHXZ proc near
.text$mn:00004FC0                                         ; CODE XREF: std::error_condition::operator==(std::error_condition const &)+2Cp
.text$mn:00004FC0                                         ; std::error_condition::operator==(std::error_condition const &)+36p
.text$mn:00004FC0
.text$mn:00004FC0 var_4           = dword ptr -4
.text$mn:00004FC0
.text$mn:00004FC0                 push    ebp
.text$mn:00004FC1                 mov     ebp, esp
.text$mn:00004FC3                 push    ecx
.text$mn:00004FC4                 mov     [ebp+var_4], ecx
.text$mn:00004FC7                 mov     eax, [ebp+var_4]
.text$mn:00004FCA                 mov     eax, [eax]
.text$mn:00004FCC                 mov     esp, ebp
.text$mn:00004FCE                 pop     ebp
.text$mn:00004FCF                 retn
.text$mn:00004FCF ?value@error_condition@std@@QBEHXZ endp
.text$mn:00004FCF
.text$mn:00004FCF _text$mn        ends
.text$mn:00004FCF
.text$mn:00004FD0 ; ===========================================================================
.text$mn:00004FD0
.text$mn:00004FD0 ; Segment type: Pure code
.text$mn:00004FD0 ; Segment permissions: Read/Execute
.text$mn:00004FD0 _text$mn        segment para public 'CODE' use32
.text$mn:00004FD0                 assume cs:_text$mn
.text$mn:00004FD0                 ;org 4FD0h
.text$mn:00004FD0 ; COMDAT (pick any)
.text$mn:00004FD0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.text$mn:00004FD0
.text$mn:00004FD0 ; =============== S U B R O U T I N E =======================================
.text$mn:00004FD0
.text$mn:00004FD0 ; Attributes: bp-based frame
.text$mn:00004FD0
.text$mn:00004FD0                 public _hypot
.text$mn:00004FD0 _hypot          proc near
.text$mn:00004FD0
.text$mn:00004FD0 var_10          = qword ptr -10h
.text$mn:00004FD0 var_8           = qword ptr -8
.text$mn:00004FD0 arg_0           = qword ptr  8
.text$mn:00004FD0 arg_8           = qword ptr  10h
.text$mn:00004FD0
.text$mn:00004FD0                 push    ebp
.text$mn:00004FD1                 mov     ebp, esp
.text$mn:00004FD3                 sub     esp, 8
.text$mn:00004FD6                 movsd   xmm0, [ebp+arg_8]
.text$mn:00004FDB                 movsd   [esp+8+var_8], xmm0
.text$mn:00004FE0                 sub     esp, 8
.text$mn:00004FE3                 movsd   xmm0, [ebp+arg_0]
.text$mn:00004FE8                 movsd   [esp+10h+var_10], xmm0
.text$mn:00004FED                 call    __hypot
.text$mn:00004FF2                 add     esp, 10h
.text$mn:00004FF5                 pop     ebp
.text$mn:00004FF6                 retn
.text$mn:00004FF6 _hypot          endp
.text$mn:00004FF6
.text$mn:00004FF6 ; ---------------------------------------------------------------------------
.text$mn:00004FF7                 align 4
.text$mn:00004FF7 _text$mn        ends
.text$mn:00004FF7
.xdata$x:00004FF8 ; ===========================================================================
.xdata$x:00004FF8
.xdata$x:00004FF8 ; Segment type: Pure data
.xdata$x:00004FF8 ; Segment permissions: Read
.xdata$x:00004FF8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00004FF8                 assume cs:_xdata$x
.xdata$x:00004FF8                 ;org 4FF8h
.xdata$x:00004FF8 ; COMDAT (pick associative to section at 41CC)
.xdata$x:00004FF8 __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ db 0FFh
.xdata$x:00004FF8                                         ; DATA XREF: .xdata$x:00005008o
.xdata$x:00004FF9                 db 0FFh
.xdata$x:00004FFA                 db 0FFh
.xdata$x:00004FFB                 db 0FFh
.xdata$x:00004FFC                 dd offset __unwindfunclet$?_Orphan_all@_Container_base12@std@@QAEXXZ$0
.xdata$x:00005000 __ehfuncinfo$?_Orphan_all@_Container_base12@std@@QAEXXZ db  22h ; "
.xdata$x:00005000                                         ; DATA XREF: __ehhandler$?_Orphan_all@_Container_base12@std@@QAEXXZ+11o
.xdata$x:00005001                 db    5
.xdata$x:00005002                 db  93h ; ô
.xdata$x:00005003                 db  19h
.xdata$x:00005004                 db    1
.xdata$x:00005005                 db    0
.xdata$x:00005006                 db    0
.xdata$x:00005007                 db    0
.xdata$x:00005008                 dd offset __unwindtable$?_Orphan_all@_Container_base12@std@@QAEXXZ
.xdata$x:0000500C                 db    0
.xdata$x:0000500D                 db    0
.xdata$x:0000500E                 db    0
.xdata$x:0000500F                 db    0
.xdata$x:00005010                 db    0
.xdata$x:00005011                 db    0
.xdata$x:00005012                 db    0
.xdata$x:00005013                 db    0
.xdata$x:00005014                 db    0
.xdata$x:00005015                 db    0
.xdata$x:00005016                 db    0
.xdata$x:00005017                 db    0
.xdata$x:00005018                 db    0
.xdata$x:00005019                 db    0
.xdata$x:0000501A                 db    0
.xdata$x:0000501B                 db    0
.xdata$x:0000501C                 db    0
.xdata$x:0000501D                 db    0
.xdata$x:0000501E                 db    0
.xdata$x:0000501F                 db    0
.xdata$x:00005020                 db    0
.xdata$x:00005021                 db    0
.xdata$x:00005022                 db    0
.xdata$x:00005023                 db    0
.xdata$x:00005023 _xdata$x        ends
.xdata$x:00005023
.xdata$x:00005024 ; ===========================================================================
.xdata$x:00005024
.xdata$x:00005024 ; Segment type: Pure data
.xdata$x:00005024 ; Segment permissions: Read
.xdata$x:00005024 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005024                 assume cs:_xdata$x
.xdata$x:00005024                 ;org 5024h
.xdata$x:00005024 ; COMDAT (pick associative to section at 3720)
.xdata$x:00005024 __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db 0FFh
.xdata$x:00005024                                         ; DATA XREF: .xdata$x:00005034o
.xdata$x:00005025                 db 0FFh
.xdata$x:00005026                 db 0FFh
.xdata$x:00005027                 db 0FFh
.xdata$x:00005028                 dd offset __unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
.xdata$x:0000502C __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z db  22h ; "
.xdata$x:0000502C                                         ; DATA XREF: __ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z+11o
.xdata$x:0000502D                 db    5
.xdata$x:0000502E                 db  93h ; ô
.xdata$x:0000502F                 db  19h
.xdata$x:00005030                 db    1
.xdata$x:00005031                 db    0
.xdata$x:00005032                 db    0
.xdata$x:00005033                 db    0
.xdata$x:00005034                 dd offset __unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
.xdata$x:00005038                 db    0
.xdata$x:00005039                 db    0
.xdata$x:0000503A                 db    0
.xdata$x:0000503B                 db    0
.xdata$x:0000503C                 db    0
.xdata$x:0000503D                 db    0
.xdata$x:0000503E                 db    0
.xdata$x:0000503F                 db    0
.xdata$x:00005040                 db    0
.xdata$x:00005041                 db    0
.xdata$x:00005042                 db    0
.xdata$x:00005043                 db    0
.xdata$x:00005044                 db    0
.xdata$x:00005045                 db    0
.xdata$x:00005046                 db    0
.xdata$x:00005047                 db    0
.xdata$x:00005048                 db    0
.xdata$x:00005049                 db    0
.xdata$x:0000504A                 db    0
.xdata$x:0000504B                 db    0
.xdata$x:0000504C                 db    0
.xdata$x:0000504D                 db    0
.xdata$x:0000504E                 db    0
.xdata$x:0000504F                 db    0
.xdata$x:0000504F _xdata$x        ends
.xdata$x:0000504F
.xdata$x:00005050 ; ===========================================================================
.xdata$x:00005050
.xdata$x:00005050 ; Segment type: Pure data
.xdata$x:00005050 ; Segment permissions: Read
.xdata$x:00005050 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005050                 assume cs:_xdata$x
.xdata$x:00005050                 ;org 5050h
.xdata$x:00005050 ; COMDAT (pick associative to section at 3598)
.xdata$x:00005050 __unwindtable$??1_Iterator_base12@std@@QAE@XZ db 0FFh
.xdata$x:00005050                                         ; DATA XREF: .xdata$x:00005060o
.xdata$x:00005051                 db 0FFh
.xdata$x:00005052                 db 0FFh
.xdata$x:00005053                 db 0FFh
.xdata$x:00005054                 dd offset __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0
.xdata$x:00005058 __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ db  22h ; "
.xdata$x:00005058                                         ; DATA XREF: __ehhandler$??1_Iterator_base12@std@@QAE@XZ+11o
.xdata$x:00005059                 db    5
.xdata$x:0000505A                 db  93h ; ô
.xdata$x:0000505B                 db  19h
.xdata$x:0000505C                 db    1
.xdata$x:0000505D                 db    0
.xdata$x:0000505E                 db    0
.xdata$x:0000505F                 db    0
.xdata$x:00005060                 dd offset __unwindtable$??1_Iterator_base12@std@@QAE@XZ
.xdata$x:00005064                 db    0
.xdata$x:00005065                 db    0
.xdata$x:00005066                 db    0
.xdata$x:00005067                 db    0
.xdata$x:00005068                 db    0
.xdata$x:00005069                 db    0
.xdata$x:0000506A                 db    0
.xdata$x:0000506B                 db    0
.xdata$x:0000506C                 db    0
.xdata$x:0000506D                 db    0
.xdata$x:0000506E                 db    0
.xdata$x:0000506F                 db    0
.xdata$x:00005070                 db    0
.xdata$x:00005071                 db    0
.xdata$x:00005072                 db    0
.xdata$x:00005073                 db    0
.xdata$x:00005074                 db    0
.xdata$x:00005075                 db    0
.xdata$x:00005076                 db    0
.xdata$x:00005077                 db    0
.xdata$x:00005078                 db    0
.xdata$x:00005079                 db    0
.xdata$x:0000507A                 db    0
.xdata$x:0000507B                 db    0
.xdata$x:0000507B _xdata$x        ends
.xdata$x:0000507B
.xdata$x:0000507C ; ===========================================================================
.xdata$x:0000507C
.xdata$x:0000507C ; Segment type: Pure data
.xdata$x:0000507C ; Segment permissions: Read
.xdata$x:0000507C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000507C                 assume cs:_xdata$x
.xdata$x:0000507C                 ;org 507Ch
.xdata$x:0000507C ; COMDAT (pick associative to section at 3B90)
.xdata$x:0000507C __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db 0FFh
.xdata$x:0000507C                                         ; DATA XREF: .xdata$x:00005094o
.xdata$x:0000507D                 db 0FFh
.xdata$x:0000507E                 db 0FFh
.xdata$x:0000507F                 db 0FFh
.xdata$x:00005080                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
.xdata$x:00005084                 db 0FFh
.xdata$x:00005085                 db 0FFh
.xdata$x:00005086                 db 0FFh
.xdata$x:00005087                 db 0FFh
.xdata$x:00005088                 dd offset __unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
.xdata$x:0000508C __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z db  22h ; "
.xdata$x:0000508C                                         ; DATA XREF: __ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z+11o
.xdata$x:0000508D                 db    5
.xdata$x:0000508E                 db  93h ; ô
.xdata$x:0000508F                 db  19h
.xdata$x:00005090                 db    2
.xdata$x:00005091                 db    0
.xdata$x:00005092                 db    0
.xdata$x:00005093                 db    0
.xdata$x:00005094                 dd offset __unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
.xdata$x:00005098                 db    0
.xdata$x:00005099                 db    0
.xdata$x:0000509A                 db    0
.xdata$x:0000509B                 db    0
.xdata$x:0000509C                 db    0
.xdata$x:0000509D                 db    0
.xdata$x:0000509E                 db    0
.xdata$x:0000509F                 db    0
.xdata$x:000050A0                 db    0
.xdata$x:000050A1                 db    0
.xdata$x:000050A2                 db    0
.xdata$x:000050A3                 db    0
.xdata$x:000050A4                 db    0
.xdata$x:000050A5                 db    0
.xdata$x:000050A6                 db    0
.xdata$x:000050A7                 db    0
.xdata$x:000050A8                 db    0
.xdata$x:000050A9                 db    0
.xdata$x:000050AA                 db    0
.xdata$x:000050AB                 db    0
.xdata$x:000050AC                 db    0
.xdata$x:000050AD                 db    0
.xdata$x:000050AE                 db    0
.xdata$x:000050AF                 db    0
.xdata$x:000050AF _xdata$x        ends
.xdata$x:000050AF
.xdata$x:000050B0 ; ===========================================================================
.xdata$x:000050B0
.xdata$x:000050B0 ; Segment type: Pure data
.xdata$x:000050B0 ; Segment permissions: Read
.xdata$x:000050B0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000050B0                 assume cs:_xdata$x
.xdata$x:000050B0                 ;org 50B0h
.xdata$x:000050B0 ; COMDAT (pick associative to section at 2808)
.xdata$x:000050B0 __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000050B0                                         ; DATA XREF: .xdata$x:000050C0o
.xdata$x:000050B1                 db 0FFh
.xdata$x:000050B2                 db 0FFh
.xdata$x:000050B3                 db 0FFh
.xdata$x:000050B4                 dd offset __unwindfunclet$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000050B8 __ehfuncinfo$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000050B8                                         ; DATA XREF: __ehhandler$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000050B9                 db    5
.xdata$x:000050BA                 db  93h ; ô
.xdata$x:000050BB                 db  19h
.xdata$x:000050BC                 db    1
.xdata$x:000050BD                 db    0
.xdata$x:000050BE                 db    0
.xdata$x:000050BF                 db    0
.xdata$x:000050C0                 dd offset __unwindtable$??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000050C4                 db    0
.xdata$x:000050C5                 db    0
.xdata$x:000050C6                 db    0
.xdata$x:000050C7                 db    0
.xdata$x:000050C8                 db    0
.xdata$x:000050C9                 db    0
.xdata$x:000050CA                 db    0
.xdata$x:000050CB                 db    0
.xdata$x:000050CC                 db    0
.xdata$x:000050CD                 db    0
.xdata$x:000050CE                 db    0
.xdata$x:000050CF                 db    0
.xdata$x:000050D0                 db    0
.xdata$x:000050D1                 db    0
.xdata$x:000050D2                 db    0
.xdata$x:000050D3                 db    0
.xdata$x:000050D4                 db    0
.xdata$x:000050D5                 db    0
.xdata$x:000050D6                 db    0
.xdata$x:000050D7                 db    0
.xdata$x:000050D8                 db    0
.xdata$x:000050D9                 db    0
.xdata$x:000050DA                 db    0
.xdata$x:000050DB                 db    0
.xdata$x:000050DB _xdata$x        ends
.xdata$x:000050DB
.xdata$x:000050DC ; ===========================================================================
.xdata$x:000050DC
.xdata$x:000050DC ; Segment type: Pure data
.xdata$x:000050DC ; Segment permissions: Read
.xdata$x:000050DC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000050DC                 assume cs:_xdata$x
.xdata$x:000050DC                 ;org 50DCh
.xdata$x:000050DC ; COMDAT (pick associative to section at 317C)
.xdata$x:000050DC __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000050DC                                         ; DATA XREF: .xdata$x:000050ECo
.xdata$x:000050DD                 db 0FFh
.xdata$x:000050DE                 db 0FFh
.xdata$x:000050DF                 db 0FFh
.xdata$x:000050E0                 dd offset __unwindfunclet$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ$0
.xdata$x:000050E4 __ehfuncinfo$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000050E4                                         ; DATA XREF: __ehhandler$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ+11o
.xdata$x:000050E5                 db    5
.xdata$x:000050E6                 db  93h ; ô
.xdata$x:000050E7                 db  19h
.xdata$x:000050E8                 db    1
.xdata$x:000050E9                 db    0
.xdata$x:000050EA                 db    0
.xdata$x:000050EB                 db    0
.xdata$x:000050EC                 dd offset __unwindtable$??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
.xdata$x:000050F0                 db    0
.xdata$x:000050F1                 db    0
.xdata$x:000050F2                 db    0
.xdata$x:000050F3                 db    0
.xdata$x:000050F4                 db    0
.xdata$x:000050F5                 db    0
.xdata$x:000050F6                 db    0
.xdata$x:000050F7                 db    0
.xdata$x:000050F8                 db    0
.xdata$x:000050F9                 db    0
.xdata$x:000050FA                 db    0
.xdata$x:000050FB                 db    0
.xdata$x:000050FC                 db    0
.xdata$x:000050FD                 db    0
.xdata$x:000050FE                 db    0
.xdata$x:000050FF                 db    0
.xdata$x:00005100                 db    0
.xdata$x:00005101                 db    0
.xdata$x:00005102                 db    0
.xdata$x:00005103                 db    0
.xdata$x:00005104                 db    0
.xdata$x:00005105                 db    0
.xdata$x:00005106                 db    0
.xdata$x:00005107                 db    0
.xdata$x:00005107 _xdata$x        ends
.xdata$x:00005107
.xdata$x:00005108 ; ===========================================================================
.xdata$x:00005108
.xdata$x:00005108 ; Segment type: Pure data
.xdata$x:00005108 ; Segment permissions: Read
.xdata$x:00005108 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005108                 assume cs:_xdata$x
.xdata$x:00005108                 ;org 5108h
.xdata$x:00005108 ; COMDAT (pick associative to section at 278C)
.xdata$x:00005108 __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db 0FFh
.xdata$x:00005108                                         ; DATA XREF: .xdata$x:00005118o
.xdata$x:00005109                 db 0FFh
.xdata$x:0000510A                 db 0FFh
.xdata$x:0000510B                 db 0FFh
.xdata$x:0000510C                 dd offset __unwindfunclet$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z$0
.xdata$x:00005110 __ehfuncinfo$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z db  22h ; "
.xdata$x:00005110                                         ; DATA XREF: __ehhandler$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z+11o
.xdata$x:00005111                 db    5
.xdata$x:00005112                 db  93h ; ô
.xdata$x:00005113                 db  19h
.xdata$x:00005114                 db    1
.xdata$x:00005115                 db    0
.xdata$x:00005116                 db    0
.xdata$x:00005117                 db    0
.xdata$x:00005118                 dd offset __unwindtable$??0?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
.xdata$x:0000511C                 db    0
.xdata$x:0000511D                 db    0
.xdata$x:0000511E                 db    0
.xdata$x:0000511F                 db    0
.xdata$x:00005120                 db    0
.xdata$x:00005121                 db    0
.xdata$x:00005122                 db    0
.xdata$x:00005123                 db    0
.xdata$x:00005124                 db    0
.xdata$x:00005125                 db    0
.xdata$x:00005126                 db    0
.xdata$x:00005127                 db    0
.xdata$x:00005128                 db    0
.xdata$x:00005129                 db    0
.xdata$x:0000512A                 db    0
.xdata$x:0000512B                 db    0
.xdata$x:0000512C                 db    0
.xdata$x:0000512D                 db    0
.xdata$x:0000512E                 db    0
.xdata$x:0000512F                 db    0
.xdata$x:00005130                 db    0
.xdata$x:00005131                 db    0
.xdata$x:00005132                 db    0
.xdata$x:00005133                 db    0
.xdata$x:00005133 _xdata$x        ends
.xdata$x:00005133
.xdata$x:00005134 ; ===========================================================================
.xdata$x:00005134
.xdata$x:00005134 ; Segment type: Pure data
.xdata$x:00005134 ; Segment permissions: Read
.xdata$x:00005134 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005134                 assume cs:_xdata$x
.xdata$x:00005134                 ;org 5134h
.xdata$x:00005134 ; COMDAT (pick associative to section at 3104)
.xdata$x:00005134 __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005134                                         ; DATA XREF: .xdata$x:00005144o
.xdata$x:00005135                 db 0FFh
.xdata$x:00005136                 db 0FFh
.xdata$x:00005137                 db 0FFh
.xdata$x:00005138                 dd offset __unwindfunclet$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ$0
.xdata$x:0000513C __ehfuncinfo$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000513C                                         ; DATA XREF: __ehhandler$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000513D                 db    5
.xdata$x:0000513E                 db  93h ; ô
.xdata$x:0000513F                 db  19h
.xdata$x:00005140                 db    1
.xdata$x:00005141                 db    0
.xdata$x:00005142                 db    0
.xdata$x:00005143                 db    0
.xdata$x:00005144                 dd offset __unwindtable$??1?$_String_alloc@$0A@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
.xdata$x:00005148                 align 20h
.xdata$x:00005148 _xdata$x        ends
.xdata$x:00005148
.xdata$x:00005160 ; ===========================================================================
.xdata$x:00005160
.xdata$x:00005160 ; Segment type: Pure data
.xdata$x:00005160 ; Segment permissions: Read
.xdata$x:00005160 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005160                 assume cs:_xdata$x
.xdata$x:00005160                 ;org 5160h
.xdata$x:00005160 ; COMDAT (pick associative to section at 2B50)
.xdata$x:00005160 __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db 0FFh
.xdata$x:00005160                                         ; DATA XREF: .xdata$x:00005170o
.xdata$x:00005161                 db 0FFh
.xdata$x:00005162                 db 0FFh
.xdata$x:00005163                 db 0FFh
.xdata$x:00005164                 dd offset __unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z$0
.xdata$x:00005168 __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z db  22h ; "
.xdata$x:00005168                                         ; DATA XREF: __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z+11o
.xdata$x:00005169                 db    5
.xdata$x:0000516A                 db  93h ; ô
.xdata$x:0000516B                 db  19h
.xdata$x:0000516C                 db    1
.xdata$x:0000516D                 db    0
.xdata$x:0000516E                 db    0
.xdata$x:0000516F                 db    0
.xdata$x:00005170                 dd offset __unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
.xdata$x:00005174                 db    0
.xdata$x:00005175                 db    0
.xdata$x:00005176                 db    0
.xdata$x:00005177                 db    0
.xdata$x:00005178                 db    0
.xdata$x:00005179                 db    0
.xdata$x:0000517A                 db    0
.xdata$x:0000517B                 db    0
.xdata$x:0000517C                 db    0
.xdata$x:0000517D                 db    0
.xdata$x:0000517E                 db    0
.xdata$x:0000517F                 db    0
.xdata$x:00005180                 db    0
.xdata$x:00005181                 db    0
.xdata$x:00005182                 db    0
.xdata$x:00005183                 db    0
.xdata$x:00005184                 db    0
.xdata$x:00005185                 db    0
.xdata$x:00005186                 db    0
.xdata$x:00005187                 db    0
.xdata$x:00005188                 db    0
.xdata$x:00005189                 db    0
.xdata$x:0000518A                 db    0
.xdata$x:0000518B                 db    0
.xdata$x:0000518B _xdata$x        ends
.xdata$x:0000518B
.xdata$x:0000518C ; ===========================================================================
.xdata$x:0000518C
.xdata$x:0000518C ; Segment type: Pure data
.xdata$x:0000518C ; Segment permissions: Read
.xdata$x:0000518C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000518C                 assume cs:_xdata$x
.xdata$x:0000518C                 ;org 518Ch
.xdata$x:0000518C ; COMDAT (pick associative to section at 3344)
.xdata$x:0000518C __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000518C                                         ; DATA XREF: .xdata$x:0000519Co
.xdata$x:0000518D                 db 0FFh
.xdata$x:0000518E                 db 0FFh
.xdata$x:0000518F                 db 0FFh
.xdata$x:00005190                 dd offset __unwindfunclet$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ$0
.xdata$x:00005194 __ehfuncinfo$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00005194                                         ; DATA XREF: __ehhandler$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ+11o
.xdata$x:00005195                 db    5
.xdata$x:00005196                 db  93h ; ô
.xdata$x:00005197                 db  19h
.xdata$x:00005198                 db    1
.xdata$x:00005199                 db    0
.xdata$x:0000519A                 db    0
.xdata$x:0000519B                 db    0
.xdata$x:0000519C                 dd offset __unwindtable$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
.xdata$x:000051A0                 db    0
.xdata$x:000051A1                 db    0
.xdata$x:000051A2                 db    0
.xdata$x:000051A3                 db    0
.xdata$x:000051A4                 db    0
.xdata$x:000051A5                 db    0
.xdata$x:000051A6                 db    0
.xdata$x:000051A7                 db    0
.xdata$x:000051A8                 db    0
.xdata$x:000051A9                 db    0
.xdata$x:000051AA                 db    0
.xdata$x:000051AB                 db    0
.xdata$x:000051AC                 db    0
.xdata$x:000051AD                 db    0
.xdata$x:000051AE                 db    0
.xdata$x:000051AF                 db    0
.xdata$x:000051B0                 db    0
.xdata$x:000051B1                 db    0
.xdata$x:000051B2                 db    0
.xdata$x:000051B3                 db    0
.xdata$x:000051B4                 db    0
.xdata$x:000051B5                 db    0
.xdata$x:000051B6                 db    0
.xdata$x:000051B7                 db    0
.xdata$x:000051B7 _xdata$x        ends
.xdata$x:000051B7
.xdata$x:000051B8 ; ===========================================================================
.xdata$x:000051B8
.xdata$x:000051B8 ; Segment type: Pure data
.xdata$x:000051B8 ; Segment permissions: Read
.xdata$x:000051B8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000051B8                 assume cs:_xdata$x
.xdata$x:000051B8                 ;org 51B8h
.xdata$x:000051B8 ; COMDAT (pick associative to section at 3D9C)
.xdata$x:000051B8 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5 db    0
.xdata$x:000051B8                                         ; DATA XREF: .xdata$x:00005240o
.xdata$x:000051B9                 db    0
.xdata$x:000051BA                 db    0
.xdata$x:000051BB                 db    0
.xdata$x:000051BC                 db    0
.xdata$x:000051BD                 db    0
.xdata$x:000051BE                 db    0
.xdata$x:000051BF                 db    0
.xdata$x:000051C0                 db    0
.xdata$x:000051C1                 db    0
.xdata$x:000051C2                 db    0
.xdata$x:000051C3                 db    0
.xdata$x:000051C4                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
.xdata$x:000051C8 __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4 db    0
.xdata$x:000051C8                                         ; DATA XREF: .xdata$x:0000522Co
.xdata$x:000051C9                 db    0
.xdata$x:000051CA                 db    0
.xdata$x:000051CB                 db    0
.xdata$x:000051CC                 db    0
.xdata$x:000051CD                 db    0
.xdata$x:000051CE                 db    0
.xdata$x:000051CF                 db    0
.xdata$x:000051D0                 db    0
.xdata$x:000051D1                 db    0
.xdata$x:000051D2                 db    0
.xdata$x:000051D3                 db    0
.xdata$x:000051D4                 dd offset __catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
.xdata$x:000051D8 __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db 0FFh
.xdata$x:000051D8                                         ; DATA XREF: .xdata$x:00005200o
.xdata$x:000051D9                 db 0FFh
.xdata$x:000051DA                 db 0FFh
.xdata$x:000051DB                 db 0FFh
.xdata$x:000051DC                 db    0
.xdata$x:000051DD                 db    0
.xdata$x:000051DE                 db    0
.xdata$x:000051DF                 db    0
.xdata$x:000051E0                 db 0FFh
.xdata$x:000051E1                 db 0FFh
.xdata$x:000051E2                 db 0FFh
.xdata$x:000051E3                 db 0FFh
.xdata$x:000051E4                 db    0
.xdata$x:000051E5                 db    0
.xdata$x:000051E6                 db    0
.xdata$x:000051E7                 db    0
.xdata$x:000051E8                 db    1
.xdata$x:000051E9                 db    0
.xdata$x:000051EA                 db    0
.xdata$x:000051EB                 db    0
.xdata$x:000051EC                 db    0
.xdata$x:000051ED                 db    0
.xdata$x:000051EE                 db    0
.xdata$x:000051EF                 db    0
.xdata$x:000051F0                 db    1
.xdata$x:000051F1                 db    0
.xdata$x:000051F2                 db    0
.xdata$x:000051F3                 db    0
.xdata$x:000051F4                 db    0
.xdata$x:000051F5                 db    0
.xdata$x:000051F6                 db    0
.xdata$x:000051F7                 db    0
.xdata$x:000051F8 __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db  22h ; "
.xdata$x:000051F8                                         ; DATA XREF: __ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z+11o
.xdata$x:000051F9                 db    5
.xdata$x:000051FA                 db  93h ; ô
.xdata$x:000051FB                 db  19h
.xdata$x:000051FC                 db    4
.xdata$x:000051FD                 db    0
.xdata$x:000051FE                 db    0
.xdata$x:000051FF                 db    0
.xdata$x:00005200                 dd offset __unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:00005204                 db    2
.xdata$x:00005205                 db    0
.xdata$x:00005206                 db    0
.xdata$x:00005207                 db    0
.xdata$x:00005208                 dd offset __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
.xdata$x:0000520C                 db    0
.xdata$x:0000520D                 db    0
.xdata$x:0000520E                 db    0
.xdata$x:0000520F                 db    0
.xdata$x:00005210                 db    0
.xdata$x:00005211                 db    0
.xdata$x:00005212                 db    0
.xdata$x:00005213                 db    0
.xdata$x:00005214                 db    0
.xdata$x:00005215                 db    0
.xdata$x:00005216                 db    0
.xdata$x:00005217                 db    0
.xdata$x:00005218                 db    0
.xdata$x:00005219                 db    0
.xdata$x:0000521A                 db    0
.xdata$x:0000521B                 db    0
.xdata$x:0000521C __tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z db    2
.xdata$x:0000521C                                         ; DATA XREF: .xdata$x:00005208o
.xdata$x:0000521D                 db    0
.xdata$x:0000521E                 db    0
.xdata$x:0000521F                 db    0
.xdata$x:00005220                 db    2
.xdata$x:00005221                 db    0
.xdata$x:00005222                 db    0
.xdata$x:00005223                 db    0
.xdata$x:00005224                 db    3
.xdata$x:00005225                 db    0
.xdata$x:00005226                 db    0
.xdata$x:00005227                 db    0
.xdata$x:00005228                 db    1
.xdata$x:00005229                 db    0
.xdata$x:0000522A                 db    0
.xdata$x:0000522B                 db    0
.xdata$x:0000522C                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$4
.xdata$x:00005230                 db    0
.xdata$x:00005231                 db    0
.xdata$x:00005232                 db    0
.xdata$x:00005233                 db    0
.xdata$x:00005234                 db    0
.xdata$x:00005235                 db    0
.xdata$x:00005236                 db    0
.xdata$x:00005237                 db    0
.xdata$x:00005238                 db    3
.xdata$x:00005239                 db    0
.xdata$x:0000523A                 db    0
.xdata$x:0000523B                 db    0
.xdata$x:0000523C                 db    1
.xdata$x:0000523D                 db    0
.xdata$x:0000523E                 db    0
.xdata$x:0000523F                 db    0
.xdata$x:00005240                 dd offset __catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$5
.xdata$x:00005240 _xdata$x        ends
.xdata$x:00005240
.xdata$x:00005244 ; ===========================================================================
.xdata$x:00005244
.xdata$x:00005244 ; Segment type: Pure data
.xdata$x:00005244 ; Segment permissions: Read
.xdata$x:00005244 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005244                 assume cs:_xdata$x
.xdata$x:00005244                 ;org 5244h
.xdata$x:00005244 ; COMDAT (pick associative to section at 3010)
.xdata$x:00005244 __unwindtable$??0runtime_error@std@@QAE@PBD@Z db 0FFh
.xdata$x:00005244                                         ; DATA XREF: .xdata$x:00005254o
.xdata$x:00005245                 db 0FFh
.xdata$x:00005246                 db 0FFh
.xdata$x:00005247                 db 0FFh
.xdata$x:00005248                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0
.xdata$x:0000524C __ehfuncinfo$??0runtime_error@std@@QAE@PBD@Z db  22h ; "
.xdata$x:0000524C                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@PBD@Z+11o
.xdata$x:0000524D                 db    5
.xdata$x:0000524E                 db  93h ; ô
.xdata$x:0000524F                 db  19h
.xdata$x:00005250                 db    1
.xdata$x:00005251                 db    0
.xdata$x:00005252                 db    0
.xdata$x:00005253                 db    0
.xdata$x:00005254                 dd offset __unwindtable$??0runtime_error@std@@QAE@PBD@Z
.xdata$x:00005258                 db    0
.xdata$x:00005259                 db    0
.xdata$x:0000525A                 db    0
.xdata$x:0000525B                 db    0
.xdata$x:0000525C                 db    0
.xdata$x:0000525D                 db    0
.xdata$x:0000525E                 db    0
.xdata$x:0000525F                 db    0
.xdata$x:00005260                 db    0
.xdata$x:00005261                 db    0
.xdata$x:00005262                 db    0
.xdata$x:00005263                 db    0
.xdata$x:00005264                 db    0
.xdata$x:00005265                 db    0
.xdata$x:00005266                 db    0
.xdata$x:00005267                 db    0
.xdata$x:00005268                 db    0
.xdata$x:00005269                 db    0
.xdata$x:0000526A                 db    0
.xdata$x:0000526B                 db    0
.xdata$x:0000526C                 db    0
.xdata$x:0000526D                 db    0
.xdata$x:0000526E                 db    0
.xdata$x:0000526F                 db    0
.xdata$x:0000526F _xdata$x        ends
.xdata$x:0000526F
.xdata$x:00005270 ; ===========================================================================
.xdata$x:00005270
.xdata$x:00005270 ; Segment type: Pure data
.xdata$x:00005270 ; Segment permissions: Read
.xdata$x:00005270 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005270                 assume cs:_xdata$x
.xdata$x:00005270                 ;org 5270h
.xdata$x:00005270 ; COMDAT (pick associative to section at 36A0)
.xdata$x:00005270 __unwindtable$??1runtime_error@std@@UAE@XZ db 0FFh
.xdata$x:00005270                                         ; DATA XREF: .xdata$x:00005280o
.xdata$x:00005271                 db 0FFh
.xdata$x:00005272                 db 0FFh
.xdata$x:00005273                 db 0FFh
.xdata$x:00005274                 dd offset __unwindfunclet$??1runtime_error@std@@UAE@XZ$0
.xdata$x:00005278 __ehfuncinfo$??1runtime_error@std@@UAE@XZ db  22h ; "
.xdata$x:00005278                                         ; DATA XREF: __ehhandler$??1runtime_error@std@@UAE@XZ+11o
.xdata$x:00005279                 db    5
.xdata$x:0000527A                 db  93h ; ô
.xdata$x:0000527B                 db  19h
.xdata$x:0000527C                 db    1
.xdata$x:0000527D                 db    0
.xdata$x:0000527E                 db    0
.xdata$x:0000527F                 db    0
.xdata$x:00005280                 dd offset __unwindtable$??1runtime_error@std@@UAE@XZ
.xdata$x:00005284                 db    0
.xdata$x:00005285                 db    0
.xdata$x:00005286                 db    0
.xdata$x:00005287                 db    0
.xdata$x:00005288                 db    0
.xdata$x:00005289                 db    0
.xdata$x:0000528A                 db    0
.xdata$x:0000528B                 db    0
.xdata$x:0000528C                 db    0
.xdata$x:0000528D                 db    0
.xdata$x:0000528E                 db    0
.xdata$x:0000528F                 db    0
.xdata$x:00005290                 db    0
.xdata$x:00005291                 db    0
.xdata$x:00005292                 db    0
.xdata$x:00005293                 db    0
.xdata$x:00005294                 db    0
.xdata$x:00005295                 db    0
.xdata$x:00005296                 db    0
.xdata$x:00005297                 db    0
.xdata$x:00005298                 db    0
.xdata$x:00005299                 db    0
.xdata$x:0000529A                 db    0
.xdata$x:0000529B                 db    0
.xdata$x:0000529B _xdata$x        ends
.xdata$x:0000529B
.xdata$x:0000529C ; ===========================================================================
.xdata$x:0000529C
.xdata$x:0000529C ; Segment type: Pure data
.xdata$x:0000529C ; Segment permissions: Read
.xdata$x:0000529C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000529C                 assume cs:_xdata$x
.xdata$x:0000529C                 ;org 529Ch
.xdata$x:0000529C ; COMDAT (pick associative to section at 2F8C)
.xdata$x:0000529C __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:0000529C                                         ; DATA XREF: .xdata$x:000052ACo
.xdata$x:0000529D                 db 0FFh
.xdata$x:0000529E                 db 0FFh
.xdata$x:0000529F                 db 0FFh
.xdata$x:000052A0                 dd offset __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
.xdata$x:000052A4 __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000052A4                                         ; DATA XREF: __ehhandler$??0runtime_error@std@@QAE@ABV01@@Z+11o
.xdata$x:000052A5                 db    5
.xdata$x:000052A6                 db  93h ; ô
.xdata$x:000052A7                 db  19h
.xdata$x:000052A8                 db    1
.xdata$x:000052A9                 db    0
.xdata$x:000052AA                 db    0
.xdata$x:000052AB                 db    0
.xdata$x:000052AC                 dd offset __unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
.xdata$x:000052B0                 db    0
.xdata$x:000052B1                 db    0
.xdata$x:000052B2                 db    0
.xdata$x:000052B3                 db    0
.xdata$x:000052B4                 db    0
.xdata$x:000052B5                 db    0
.xdata$x:000052B6                 db    0
.xdata$x:000052B7                 db    0
.xdata$x:000052B8                 db    0
.xdata$x:000052B9                 db    0
.xdata$x:000052BA                 db    0
.xdata$x:000052BB                 db    0
.xdata$x:000052BC                 db    0
.xdata$x:000052BD                 db    0
.xdata$x:000052BE                 db    0
.xdata$x:000052BF                 db    0
.xdata$x:000052C0                 db    0
.xdata$x:000052C1                 db    0
.xdata$x:000052C2                 db    0
.xdata$x:000052C3                 db    0
.xdata$x:000052C4                 db    0
.xdata$x:000052C5                 db    0
.xdata$x:000052C6                 db    0
.xdata$x:000052C7                 db    0
.xdata$x:000052C7 _xdata$x        ends
.xdata$x:000052C7
.xdata$x:000052C8 ; ===========================================================================
.xdata$x:000052C8
.xdata$x:000052C8 ; Segment type: Pure data
.xdata$x:000052C8 ; Segment permissions: Read
.xdata$x:000052C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000052C8                 assume cs:_xdata$x
.xdata$x:000052C8                 ;org 52C8h
.xdata$x:000052C8 ; COMDAT (pick associative to section at 2D70)
.xdata$x:000052C8 __unwindtable$??0_Generic_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000052C8                                         ; DATA XREF: .xdata$x:000052D8o
.xdata$x:000052C9                 db 0FFh
.xdata$x:000052CA                 db 0FFh
.xdata$x:000052CB                 db 0FFh
.xdata$x:000052CC                 dd offset __unwindfunclet$??0_Generic_error_category@std@@QAE@XZ$0
.xdata$x:000052D0 __ehfuncinfo$??0_Generic_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000052D0                                         ; DATA XREF: __ehhandler$??0_Generic_error_category@std@@QAE@XZ+11o
.xdata$x:000052D1                 db    5
.xdata$x:000052D2                 db  93h ; ô
.xdata$x:000052D3                 db  19h
.xdata$x:000052D4                 db    1
.xdata$x:000052D5                 db    0
.xdata$x:000052D6                 db    0
.xdata$x:000052D7                 db    0
.xdata$x:000052D8                 dd offset __unwindtable$??0_Generic_error_category@std@@QAE@XZ
.xdata$x:000052DC                 db    0
.xdata$x:000052DD                 db    0
.xdata$x:000052DE                 db    0
.xdata$x:000052DF                 db    0
.xdata$x:000052E0                 db    0
.xdata$x:000052E1                 db    0
.xdata$x:000052E2                 db    0
.xdata$x:000052E3                 db    0
.xdata$x:000052E4                 db    0
.xdata$x:000052E5                 db    0
.xdata$x:000052E6                 db    0
.xdata$x:000052E7                 db    0
.xdata$x:000052E8                 db    0
.xdata$x:000052E9                 db    0
.xdata$x:000052EA                 db    0
.xdata$x:000052EB                 db    0
.xdata$x:000052EC                 db    0
.xdata$x:000052ED                 db    0
.xdata$x:000052EE                 db    0
.xdata$x:000052EF                 db    0
.xdata$x:000052F0                 db    0
.xdata$x:000052F1                 db    0
.xdata$x:000052F2                 db    0
.xdata$x:000052F3                 db    0
.xdata$x:000052F3 _xdata$x        ends
.xdata$x:000052F3
.xdata$x:000052F4 ; ===========================================================================
.xdata$x:000052F4
.xdata$x:000052F4 ; Segment type: Pure data
.xdata$x:000052F4 ; Segment permissions: Read
.xdata$x:000052F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000052F4                 assume cs:_xdata$x
.xdata$x:000052F4                 ;org 52F4h
.xdata$x:000052F4 ; COMDAT (pick associative to section at 4C60)
.xdata$x:000052F4 __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000052F4                                         ; DATA XREF: .xdata$x:00005304o
.xdata$x:000052F5                 db 0FFh
.xdata$x:000052F6                 db 0FFh
.xdata$x:000052F7                 db 0FFh
.xdata$x:000052F8                 dd offset __unwindfunclet$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:000052FC __ehfuncinfo$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:000052FC                                         ; DATA XREF: __ehhandler$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:000052FD                 db    5
.xdata$x:000052FE                 db  93h ; ô
.xdata$x:000052FF                 db  19h
.xdata$x:00005300                 db    1
.xdata$x:00005301                 db    0
.xdata$x:00005302                 db    0
.xdata$x:00005303                 db    0
.xdata$x:00005304                 dd offset __unwindtable$?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00005308                 align 20h
.xdata$x:00005308 _xdata$x        ends
.xdata$x:00005308
.xdata$x:00005320 ; ===========================================================================
.xdata$x:00005320
.xdata$x:00005320 ; Segment type: Pure data
.xdata$x:00005320 ; Segment permissions: Read
.xdata$x:00005320 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005320                 assume cs:_xdata$x
.xdata$x:00005320                 ;org 5320h
.xdata$x:00005320 ; COMDAT (pick associative to section at 34B8)
.xdata$x:00005320 __unwindtable$??1_Generic_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00005320                                         ; DATA XREF: .xdata$x:00005330o
.xdata$x:00005321                 db 0FFh
.xdata$x:00005322                 db 0FFh
.xdata$x:00005323                 db 0FFh
.xdata$x:00005324                 dd offset __unwindfunclet$??1_Generic_error_category@std@@UAE@XZ$0
.xdata$x:00005328 __ehfuncinfo$??1_Generic_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00005328                                         ; DATA XREF: __ehhandler$??1_Generic_error_category@std@@UAE@XZ+11o
.xdata$x:00005329                 db    5
.xdata$x:0000532A                 db  93h ; ô
.xdata$x:0000532B                 db  19h
.xdata$x:0000532C                 db    1
.xdata$x:0000532D                 db    0
.xdata$x:0000532E                 db    0
.xdata$x:0000532F                 db    0
.xdata$x:00005330                 dd offset __unwindtable$??1_Generic_error_category@std@@UAE@XZ
.xdata$x:00005334                 db    0
.xdata$x:00005335                 db    0
.xdata$x:00005336                 db    0
.xdata$x:00005337                 db    0
.xdata$x:00005338                 db    0
.xdata$x:00005339                 db    0
.xdata$x:0000533A                 db    0
.xdata$x:0000533B                 db    0
.xdata$x:0000533C                 db    0
.xdata$x:0000533D                 db    0
.xdata$x:0000533E                 db    0
.xdata$x:0000533F                 db    0
.xdata$x:00005340                 db    0
.xdata$x:00005341                 db    0
.xdata$x:00005342                 db    0
.xdata$x:00005343                 db    0
.xdata$x:00005344                 db    0
.xdata$x:00005345                 db    0
.xdata$x:00005346                 db    0
.xdata$x:00005347                 db    0
.xdata$x:00005348                 db    0
.xdata$x:00005349                 db    0
.xdata$x:0000534A                 db    0
.xdata$x:0000534B                 db    0
.xdata$x:0000534B _xdata$x        ends
.xdata$x:0000534B
.xdata$x:0000534C ; ===========================================================================
.xdata$x:0000534C
.xdata$x:0000534C ; Segment type: Pure data
.xdata$x:0000534C ; Segment permissions: Read
.xdata$x:0000534C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000534C                 assume cs:_xdata$x
.xdata$x:0000534C                 ;org 534Ch
.xdata$x:0000534C ; COMDAT (pick associative to section at 2DEC)
.xdata$x:0000534C __unwindtable$??0_Iostream_error_category@std@@QAE@XZ db 0FFh
.xdata$x:0000534C                                         ; DATA XREF: .xdata$x:0000535Co
.xdata$x:0000534D                 db 0FFh
.xdata$x:0000534E                 db 0FFh
.xdata$x:0000534F                 db 0FFh
.xdata$x:00005350                 dd offset __unwindfunclet$??0_Iostream_error_category@std@@QAE@XZ$0
.xdata$x:00005354 __ehfuncinfo$??0_Iostream_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:00005354                                         ; DATA XREF: __ehhandler$??0_Iostream_error_category@std@@QAE@XZ+11o
.xdata$x:00005355                 db    5
.xdata$x:00005356                 db  93h ; ô
.xdata$x:00005357                 db  19h
.xdata$x:00005358                 db    1
.xdata$x:00005359                 db    0
.xdata$x:0000535A                 db    0
.xdata$x:0000535B                 db    0
.xdata$x:0000535C                 dd offset __unwindtable$??0_Iostream_error_category@std@@QAE@XZ
.xdata$x:00005360                 db    0
.xdata$x:00005361                 db    0
.xdata$x:00005362                 db    0
.xdata$x:00005363                 db    0
.xdata$x:00005364                 db    0
.xdata$x:00005365                 db    0
.xdata$x:00005366                 db    0
.xdata$x:00005367                 db    0
.xdata$x:00005368                 db    0
.xdata$x:00005369                 db    0
.xdata$x:0000536A                 db    0
.xdata$x:0000536B                 db    0
.xdata$x:0000536C                 db    0
.xdata$x:0000536D                 db    0
.xdata$x:0000536E                 db    0
.xdata$x:0000536F                 db    0
.xdata$x:00005370                 db    0
.xdata$x:00005371                 db    0
.xdata$x:00005372                 db    0
.xdata$x:00005373                 db    0
.xdata$x:00005374                 db    0
.xdata$x:00005375                 db    0
.xdata$x:00005376                 db    0
.xdata$x:00005377                 db    0
.xdata$x:00005377 _xdata$x        ends
.xdata$x:00005377
.xdata$x:00005378 ; ===========================================================================
.xdata$x:00005378
.xdata$x:00005378 ; Segment type: Pure data
.xdata$x:00005378 ; Segment permissions: Read
.xdata$x:00005378 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005378                 assume cs:_xdata$x
.xdata$x:00005378                 ;org 5378h
.xdata$x:00005378 ; COMDAT (pick associative to section at 4D18)
.xdata$x:00005378 __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:00005378                                         ; DATA XREF: .xdata$x:00005388o
.xdata$x:00005379                 db 0FFh
.xdata$x:0000537A                 db 0FFh
.xdata$x:0000537B                 db 0FFh
.xdata$x:0000537C                 dd offset __unwindfunclet$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00005380 __ehfuncinfo$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00005380                                         ; DATA XREF: __ehhandler$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00005381                 db    5
.xdata$x:00005382                 db  93h ; ô
.xdata$x:00005383                 db  19h
.xdata$x:00005384                 db    1
.xdata$x:00005385                 db    0
.xdata$x:00005386                 db    0
.xdata$x:00005387                 db    0
.xdata$x:00005388                 dd offset __unwindtable$?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:0000538C                 db    0
.xdata$x:0000538D                 db    0
.xdata$x:0000538E                 db    0
.xdata$x:0000538F                 db    0
.xdata$x:00005390                 db    0
.xdata$x:00005391                 db    0
.xdata$x:00005392                 db    0
.xdata$x:00005393                 db    0
.xdata$x:00005394                 db    0
.xdata$x:00005395                 db    0
.xdata$x:00005396                 db    0
.xdata$x:00005397                 db    0
.xdata$x:00005398                 db    0
.xdata$x:00005399                 db    0
.xdata$x:0000539A                 db    0
.xdata$x:0000539B                 db    0
.xdata$x:0000539C                 db    0
.xdata$x:0000539D                 db    0
.xdata$x:0000539E                 db    0
.xdata$x:0000539F                 db    0
.xdata$x:000053A0                 db    0
.xdata$x:000053A1                 db    0
.xdata$x:000053A2                 db    0
.xdata$x:000053A3                 db    0
.xdata$x:000053A3 _xdata$x        ends
.xdata$x:000053A3
.xdata$x:000053A4 ; ===========================================================================
.xdata$x:000053A4
.xdata$x:000053A4 ; Segment type: Pure data
.xdata$x:000053A4 ; Segment permissions: Read
.xdata$x:000053A4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000053A4                 assume cs:_xdata$x
.xdata$x:000053A4                 ;org 53A4h
.xdata$x:000053A4 ; COMDAT (pick associative to section at 3528)
.xdata$x:000053A4 __unwindtable$??1_Iostream_error_category@std@@UAE@XZ db 0FFh
.xdata$x:000053A4                                         ; DATA XREF: .xdata$x:000053B4o
.xdata$x:000053A5                 db 0FFh
.xdata$x:000053A6                 db 0FFh
.xdata$x:000053A7                 db 0FFh
.xdata$x:000053A8                 dd offset __unwindfunclet$??1_Iostream_error_category@std@@UAE@XZ$0
.xdata$x:000053AC __ehfuncinfo$??1_Iostream_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:000053AC                                         ; DATA XREF: __ehhandler$??1_Iostream_error_category@std@@UAE@XZ+11o
.xdata$x:000053AD                 db    5
.xdata$x:000053AE                 db  93h ; ô
.xdata$x:000053AF                 db  19h
.xdata$x:000053B0                 db    1
.xdata$x:000053B1                 db    0
.xdata$x:000053B2                 db    0
.xdata$x:000053B3                 db    0
.xdata$x:000053B4                 dd offset __unwindtable$??1_Iostream_error_category@std@@UAE@XZ
.xdata$x:000053B8                 db    0
.xdata$x:000053B9                 db    0
.xdata$x:000053BA                 db    0
.xdata$x:000053BB                 db    0
.xdata$x:000053BC                 db    0
.xdata$x:000053BD                 db    0
.xdata$x:000053BE                 db    0
.xdata$x:000053BF                 db    0
.xdata$x:000053C0                 db    0
.xdata$x:000053C1                 db    0
.xdata$x:000053C2                 db    0
.xdata$x:000053C3                 db    0
.xdata$x:000053C4                 db    0
.xdata$x:000053C5                 db    0
.xdata$x:000053C6                 db    0
.xdata$x:000053C7                 db    0
.xdata$x:000053C8                 db    0
.xdata$x:000053C9                 db    0
.xdata$x:000053CA                 db    0
.xdata$x:000053CB                 db    0
.xdata$x:000053CC                 db    0
.xdata$x:000053CD                 db    0
.xdata$x:000053CE                 db    0
.xdata$x:000053CF                 db    0
.xdata$x:000053CF _xdata$x        ends
.xdata$x:000053CF
.xdata$x:000053D0 ; ===========================================================================
.xdata$x:000053D0
.xdata$x:000053D0 ; Segment type: Pure data
.xdata$x:000053D0 ; Segment permissions: Read
.xdata$x:000053D0 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000053D0                 assume cs:_xdata$x
.xdata$x:000053D0                 ;org 53D0h
.xdata$x:000053D0 ; COMDAT (pick associative to section at 2EBC)
.xdata$x:000053D0 __unwindtable$??0_System_error_category@std@@QAE@XZ db 0FFh
.xdata$x:000053D0                                         ; DATA XREF: .xdata$x:000053E0o
.xdata$x:000053D1                 db 0FFh
.xdata$x:000053D2                 db 0FFh
.xdata$x:000053D3                 db 0FFh
.xdata$x:000053D4                 dd offset __unwindfunclet$??0_System_error_category@std@@QAE@XZ$0
.xdata$x:000053D8 __ehfuncinfo$??0_System_error_category@std@@QAE@XZ db  22h ; "
.xdata$x:000053D8                                         ; DATA XREF: __ehhandler$??0_System_error_category@std@@QAE@XZ+11o
.xdata$x:000053D9                 db    5
.xdata$x:000053DA                 db  93h ; ô
.xdata$x:000053DB                 db  19h
.xdata$x:000053DC                 db    1
.xdata$x:000053DD                 db    0
.xdata$x:000053DE                 db    0
.xdata$x:000053DF                 db    0
.xdata$x:000053E0                 dd offset __unwindtable$??0_System_error_category@std@@QAE@XZ
.xdata$x:000053E4                 db    0
.xdata$x:000053E5                 db    0
.xdata$x:000053E6                 db    0
.xdata$x:000053E7                 db    0
.xdata$x:000053E8                 db    0
.xdata$x:000053E9                 db    0
.xdata$x:000053EA                 db    0
.xdata$x:000053EB                 db    0
.xdata$x:000053EC                 db    0
.xdata$x:000053ED                 db    0
.xdata$x:000053EE                 db    0
.xdata$x:000053EF                 db    0
.xdata$x:000053F0                 db    0
.xdata$x:000053F1                 db    0
.xdata$x:000053F2                 db    0
.xdata$x:000053F3                 db    0
.xdata$x:000053F4                 db    0
.xdata$x:000053F5                 db    0
.xdata$x:000053F6                 db    0
.xdata$x:000053F7                 db    0
.xdata$x:000053F8                 db    0
.xdata$x:000053F9                 db    0
.xdata$x:000053FA                 db    0
.xdata$x:000053FB                 db    0
.xdata$x:000053FB _xdata$x        ends
.xdata$x:000053FB
.xdata$x:000053FC ; ===========================================================================
.xdata$x:000053FC
.xdata$x:000053FC ; Segment type: Pure data
.xdata$x:000053FC ; Segment permissions: Read
.xdata$x:000053FC _xdata$x        segment dword public 'DATA' use32
.xdata$x:000053FC                 assume cs:_xdata$x
.xdata$x:000053FC                 ;org 53FCh
.xdata$x:000053FC ; COMDAT (pick associative to section at 4DDC)
.xdata$x:000053FC __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db 0FFh
.xdata$x:000053FC                                         ; DATA XREF: .xdata$x:0000540Co
.xdata$x:000053FD                 db 0FFh
.xdata$x:000053FE                 db 0FFh
.xdata$x:000053FF                 db 0FFh
.xdata$x:00005400                 dd offset __unwindfunclet$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z$0
.xdata$x:00005404 __ehfuncinfo$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z db  22h ; "
.xdata$x:00005404                                         ; DATA XREF: __ehhandler$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+11o
.xdata$x:00005405                 db    5
.xdata$x:00005406                 db  93h ; ô
.xdata$x:00005407                 db  19h
.xdata$x:00005408                 db    1
.xdata$x:00005409                 db    0
.xdata$x:0000540A                 db    0
.xdata$x:0000540B                 db    0
.xdata$x:0000540C                 dd offset __unwindtable$?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
.xdata$x:00005410                 db    0
.xdata$x:00005411                 db    0
.xdata$x:00005412                 db    0
.xdata$x:00005413                 db    0
.xdata$x:00005414                 db    0
.xdata$x:00005415                 db    0
.xdata$x:00005416                 db    0
.xdata$x:00005417                 db    0
.xdata$x:00005418                 db    0
.xdata$x:00005419                 db    0
.xdata$x:0000541A                 db    0
.xdata$x:0000541B                 db    0
.xdata$x:0000541C                 db    0
.xdata$x:0000541D                 db    0
.xdata$x:0000541E                 db    0
.xdata$x:0000541F                 db    0
.xdata$x:00005420                 db    0
.xdata$x:00005421                 db    0
.xdata$x:00005422                 db    0
.xdata$x:00005423                 db    0
.xdata$x:00005424                 db    0
.xdata$x:00005425                 db    0
.xdata$x:00005426                 db    0
.xdata$x:00005427                 db    0
.xdata$x:00005427 _xdata$x        ends
.xdata$x:00005427
.xdata$x:00005428 ; ===========================================================================
.xdata$x:00005428
.xdata$x:00005428 ; Segment type: Pure data
.xdata$x:00005428 ; Segment permissions: Read
.xdata$x:00005428 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005428                 assume cs:_xdata$x
.xdata$x:00005428                 ;org 5428h
.xdata$x:00005428 ; COMDAT (pick associative to section at 361C)
.xdata$x:00005428 __unwindtable$??1_System_error_category@std@@UAE@XZ db 0FFh
.xdata$x:00005428                                         ; DATA XREF: .xdata$x:00005438o
.xdata$x:00005429                 db 0FFh
.xdata$x:0000542A                 db 0FFh
.xdata$x:0000542B                 db 0FFh
.xdata$x:0000542C                 dd offset __unwindfunclet$??1_System_error_category@std@@UAE@XZ$0
.xdata$x:00005430 __ehfuncinfo$??1_System_error_category@std@@UAE@XZ db  22h ; "
.xdata$x:00005430                                         ; DATA XREF: __ehhandler$??1_System_error_category@std@@UAE@XZ+11o
.xdata$x:00005431                 db    5
.xdata$x:00005432                 db  93h ; ô
.xdata$x:00005433                 db  19h
.xdata$x:00005434                 db    1
.xdata$x:00005435                 db    0
.xdata$x:00005436                 db    0
.xdata$x:00005437                 db    0
.xdata$x:00005438                 dd offset __unwindtable$??1_System_error_category@std@@UAE@XZ
.xdata$x:0000543C                 db    0
.xdata$x:0000543D                 db    0
.xdata$x:0000543E                 db    0
.xdata$x:0000543F                 db    0
.xdata$x:00005440                 db    0
.xdata$x:00005441                 db    0
.xdata$x:00005442                 db    0
.xdata$x:00005443                 db    0
.xdata$x:00005444                 db    0
.xdata$x:00005445                 db    0
.xdata$x:00005446                 db    0
.xdata$x:00005447                 db    0
.xdata$x:00005448                 db    0
.xdata$x:00005449                 db    0
.xdata$x:0000544A                 db    0
.xdata$x:0000544B                 db    0
.xdata$x:0000544C                 db    0
.xdata$x:0000544D                 db    0
.xdata$x:0000544E                 db    0
.xdata$x:0000544F                 db    0
.xdata$x:00005450                 db    0
.xdata$x:00005451                 db    0
.xdata$x:00005452                 db    0
.xdata$x:00005453                 db    0
.xdata$x:00005453 _xdata$x        ends
.xdata$x:00005453
.xdata$x:00005454 ; ===========================================================================
.xdata$x:00005454
.xdata$x:00005454 ; Segment type: Pure data
.xdata$x:00005454 ; Segment permissions: Read
.xdata$x:00005454 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005454                 assume cs:_xdata$x
.xdata$x:00005454                 ;org 5454h
.xdata$x:00005454 __unwindtable$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z db 0FFh
.xdata$x:00005454                                         ; DATA XREF: .xdata$x:00005474o
.xdata$x:00005455                 db 0FFh
.xdata$x:00005456                 db 0FFh
.xdata$x:00005457                 db 0FFh
.xdata$x:00005458                 dd offset __unwindfunclet$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z$0
.xdata$x:0000545C __unwindtable$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z db 0FFh
.xdata$x:0000545C                                         ; DATA XREF: .xdata$x:00005498o
.xdata$x:0000545D                 db 0FFh
.xdata$x:0000545E                 db 0FFh
.xdata$x:0000545F                 db 0FFh
.xdata$x:00005460                 dd offset __unwindfunclet$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z$0
.xdata$x:00005464 __unwindtable$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z db 0FFh
.xdata$x:00005464                                         ; DATA XREF: .xdata$x:000054BCo
.xdata$x:00005465                 db 0FFh
.xdata$x:00005466                 db 0FFh
.xdata$x:00005467                 db 0FFh
.xdata$x:00005468                 dd offset __unwindfunclet$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z$0
.xdata$x:0000546C __ehfuncinfo$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z db  22h ; "
.xdata$x:0000546C                                         ; DATA XREF: __ehhandler$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z+1Bo
.xdata$x:0000546D                 db    5
.xdata$x:0000546E                 db  93h ; ô
.xdata$x:0000546F                 db  19h
.xdata$x:00005470                 db    1
.xdata$x:00005471                 db    0
.xdata$x:00005472                 db    0
.xdata$x:00005473                 db    0
.xdata$x:00005474                 dd offset __unwindtable$?workHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@PAUtagRECT@@@Z
.xdata$x:00005478                 db    0
.xdata$x:00005479                 db    0
.xdata$x:0000547A                 db    0
.xdata$x:0000547B                 db    0
.xdata$x:0000547C                 db    0
.xdata$x:0000547D                 db    0
.xdata$x:0000547E                 db    0
.xdata$x:0000547F                 db    0
.xdata$x:00005480                 db    0
.xdata$x:00005481                 db    0
.xdata$x:00005482                 db    0
.xdata$x:00005483                 db    0
.xdata$x:00005484                 db    0
.xdata$x:00005485                 db    0
.xdata$x:00005486                 db    0
.xdata$x:00005487                 db    0
.xdata$x:00005488                 db    0
.xdata$x:00005489                 db    0
.xdata$x:0000548A                 db    0
.xdata$x:0000548B                 db    0
.xdata$x:0000548C                 db    0
.xdata$x:0000548D                 db    0
.xdata$x:0000548E                 db    0
.xdata$x:0000548F                 db    0
.xdata$x:00005490 __ehfuncinfo$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z db  22h ; "
.xdata$x:00005490                                         ; DATA XREF: __ehhandler$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z+1Bo
.xdata$x:00005491                 db    5
.xdata$x:00005492                 db  93h ; ô
.xdata$x:00005493                 db  19h
.xdata$x:00005494                 db    1
.xdata$x:00005495                 db    0
.xdata$x:00005496                 db    0
.xdata$x:00005497                 db    0
.xdata$x:00005498                 dd offset __unwindtable$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z
.xdata$x:0000549C                 db    0
.xdata$x:0000549D                 db    0
.xdata$x:0000549E                 db    0
.xdata$x:0000549F                 db    0
.xdata$x:000054A0                 db    0
.xdata$x:000054A1                 db    0
.xdata$x:000054A2                 db    0
.xdata$x:000054A3                 db    0
.xdata$x:000054A4                 db    0
.xdata$x:000054A5                 db    0
.xdata$x:000054A6                 db    0
.xdata$x:000054A7                 db    0
.xdata$x:000054A8                 db    0
.xdata$x:000054A9                 db    0
.xdata$x:000054AA                 db    0
.xdata$x:000054AB                 db    0
.xdata$x:000054AC                 db    0
.xdata$x:000054AD                 db    0
.xdata$x:000054AE                 db    0
.xdata$x:000054AF                 db    0
.xdata$x:000054B0                 db    0
.xdata$x:000054B1                 db    0
.xdata$x:000054B2                 db    0
.xdata$x:000054B3                 db    0
.xdata$x:000054B4 __ehfuncinfo$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z db  22h ; "
.xdata$x:000054B4                                         ; DATA XREF: __ehhandler$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z+1Bo
.xdata$x:000054B5                 db    5
.xdata$x:000054B6                 db  93h ; ô
.xdata$x:000054B7                 db  19h
.xdata$x:000054B8                 db    1
.xdata$x:000054B9                 db    0
.xdata$x:000054BA                 db    0
.xdata$x:000054BB                 db    0
.xdata$x:000054BC                 dd offset __unwindtable$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z
.xdata$x:000054C0                 db    0
.xdata$x:000054C1                 db    0
.xdata$x:000054C2                 db    0
.xdata$x:000054C3                 db    0
.xdata$x:000054C4                 db    0
.xdata$x:000054C5                 db    0
.xdata$x:000054C6                 db    0
.xdata$x:000054C7                 db    0
.xdata$x:000054C8                 db    0
.xdata$x:000054C9                 db    0
.xdata$x:000054CA                 db    0
.xdata$x:000054CB                 db    0
.xdata$x:000054CC                 db    0
.xdata$x:000054CD                 db    0
.xdata$x:000054CE                 db    0
.xdata$x:000054CF                 db    0
.xdata$x:000054D0                 db    0
.xdata$x:000054D1                 db    0
.xdata$x:000054D2                 db    0
.xdata$x:000054D3                 db    0
.xdata$x:000054D4                 db    0
.xdata$x:000054D5                 db    0
.xdata$x:000054D6                 db    0
.xdata$x:000054D7                 db    0
.xdata$x:000054D7 _xdata$x        ends
.xdata$x:000054D7
.xdata$x:000054D8 ; ===========================================================================
.xdata$x:000054D8
.xdata$x:000054D8 ; Segment type: Pure data
.xdata$x:000054D8 ; Segment permissions: Read
.xdata$x:000054D8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000054D8                 assume cs:_xdata$x
.xdata$x:000054D8                 ;org 54D8h
.xdata$x:000054D8 ; COMDAT (pick associative to section at 2A1C)
.xdata$x:000054D8 __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000054D8                                         ; DATA XREF: .xdata$x:000054E8o
.xdata$x:000054D9                 db 0FFh
.xdata$x:000054DA                 db 0FFh
.xdata$x:000054DB                 db 0FFh
.xdata$x:000054DC                 dd offset __unwindfunclet$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0
.xdata$x:000054E0 __ehfuncinfo$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:000054E0                                         ; DATA XREF: __ehhandler$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ+11o
.xdata$x:000054E1                 db    5
.xdata$x:000054E2                 db  93h ; ô
.xdata$x:000054E3                 db  19h
.xdata$x:000054E4                 db    1
.xdata$x:000054E5                 db    0
.xdata$x:000054E6                 db    0
.xdata$x:000054E7                 db    0
.xdata$x:000054E8                 dd offset __unwindtable$??0?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.xdata$x:000054EC                 db    0
.xdata$x:000054ED                 db    0
.xdata$x:000054EE                 db    0
.xdata$x:000054EF                 db    0
.xdata$x:000054F0                 db    0
.xdata$x:000054F1                 db    0
.xdata$x:000054F2                 db    0
.xdata$x:000054F3                 db    0
.xdata$x:000054F4                 db    0
.xdata$x:000054F5                 db    0
.xdata$x:000054F6                 db    0
.xdata$x:000054F7                 db    0
.xdata$x:000054F8                 db    0
.xdata$x:000054F9                 db    0
.xdata$x:000054FA                 db    0
.xdata$x:000054FB                 db    0
.xdata$x:000054FC                 db    0
.xdata$x:000054FD                 db    0
.xdata$x:000054FE                 db    0
.xdata$x:000054FF                 db    0
.xdata$x:00005500                 db    0
.xdata$x:00005501                 db    0
.xdata$x:00005502                 db    0
.xdata$x:00005503                 db    0
.xdata$x:00005503 _xdata$x        ends
.xdata$x:00005503
.xdata$x:00005504 ; ===========================================================================
.xdata$x:00005504
.xdata$x:00005504 ; Segment type: Pure data
.xdata$x:00005504 ; Segment permissions: Read
.xdata$x:00005504 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005504                 assume cs:_xdata$x
.xdata$x:00005504                 ;org 5504h
.xdata$x:00005504 ; COMDAT (pick associative to section at 32D4)
.xdata$x:00005504 __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:00005504                                         ; DATA XREF: .xdata$x:00005514o
.xdata$x:00005505                 db 0FFh
.xdata$x:00005506                 db 0FFh
.xdata$x:00005507                 db 0FFh
.xdata$x:00005508                 dd offset __unwindfunclet$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ$0
.xdata$x:0000550C __ehfuncinfo$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:0000550C                                         ; DATA XREF: __ehhandler$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ+11o
.xdata$x:0000550D                 db    5
.xdata$x:0000550E                 db  93h ; ô
.xdata$x:0000550F                 db  19h
.xdata$x:00005510                 db    1
.xdata$x:00005511                 db    0
.xdata$x:00005512                 db    0
.xdata$x:00005513                 db    0
.xdata$x:00005514                 dd offset __unwindtable$??1?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@QAE@XZ
.xdata$x:00005518                 db    0
.xdata$x:00005519                 db    0
.xdata$x:0000551A                 db    0
.xdata$x:0000551B                 db    0
.xdata$x:0000551C                 db    0
.xdata$x:0000551D                 db    0
.xdata$x:0000551E                 db    0
.xdata$x:0000551F                 db    0
.xdata$x:00005520                 db    0
.xdata$x:00005521                 db    0
.xdata$x:00005522                 db    0
.xdata$x:00005523                 db    0
.xdata$x:00005524                 db    0
.xdata$x:00005525                 db    0
.xdata$x:00005526                 db    0
.xdata$x:00005527                 db    0
.xdata$x:00005528                 db    0
.xdata$x:00005529                 db    0
.xdata$x:0000552A                 db    0
.xdata$x:0000552B                 db    0
.xdata$x:0000552C                 db    0
.xdata$x:0000552D                 db    0
.xdata$x:0000552E                 db    0
.xdata$x:0000552F                 db    0
.xdata$x:0000552F _xdata$x        ends
.xdata$x:0000552F
.xdata$x:00005530 ; ===========================================================================
.xdata$x:00005530
.xdata$x:00005530 ; Segment type: Pure data
.xdata$x:00005530 ; Segment permissions: Read
.xdata$x:00005530 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005530                 assume cs:_xdata$x
.xdata$x:00005530                 ;org 5530h
.xdata$x:00005530 ; COMDAT (pick associative to section at 2890)
.xdata$x:00005530 __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z db 0FFh
.xdata$x:00005530                                         ; DATA XREF: .xdata$x:00005540o
.xdata$x:00005531                 db 0FFh
.xdata$x:00005532                 db 0FFh
.xdata$x:00005533                 db 0FFh
.xdata$x:00005534                 dd offset __unwindfunclet$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z$0
.xdata$x:00005538 __ehfuncinfo$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z db  22h ; "
.xdata$x:00005538                                         ; DATA XREF: __ehhandler$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z+11o
.xdata$x:00005539                 db    5
.xdata$x:0000553A                 db  93h ; ô
.xdata$x:0000553B                 db  19h
.xdata$x:0000553C                 db    1
.xdata$x:0000553D                 db    0
.xdata$x:0000553E                 db    0
.xdata$x:0000553F                 db    0
.xdata$x:00005540                 dd offset __unwindtable$??0?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV?$allocator@PAVDockingCont@@@1@@Z
.xdata$x:00005544                 db    0
.xdata$x:00005545                 db    0
.xdata$x:00005546                 db    0
.xdata$x:00005547                 db    0
.xdata$x:00005548                 db    0
.xdata$x:00005549                 db    0
.xdata$x:0000554A                 db    0
.xdata$x:0000554B                 db    0
.xdata$x:0000554C                 db    0
.xdata$x:0000554D                 db    0
.xdata$x:0000554E                 db    0
.xdata$x:0000554F                 db    0
.xdata$x:00005550                 db    0
.xdata$x:00005551                 db    0
.xdata$x:00005552                 db    0
.xdata$x:00005553                 db    0
.xdata$x:00005554                 db    0
.xdata$x:00005555                 db    0
.xdata$x:00005556                 db    0
.xdata$x:00005557                 db    0
.xdata$x:00005558                 db    0
.xdata$x:00005559                 db    0
.xdata$x:0000555A                 db    0
.xdata$x:0000555B                 db    0
.xdata$x:0000555B _xdata$x        ends
.xdata$x:0000555B
.xdata$x:0000555C ; ===========================================================================
.xdata$x:0000555C
.xdata$x:0000555C ; Segment type: Pure data
.xdata$x:0000555C ; Segment permissions: Read
.xdata$x:0000555C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000555C                 assume cs:_xdata$x
.xdata$x:0000555C                 ;org 555Ch
.xdata$x:0000555C ; COMDAT (pick associative to section at 31EC)
.xdata$x:0000555C __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000555C                                         ; DATA XREF: .xdata$x:0000556Co
.xdata$x:0000555D                 db 0FFh
.xdata$x:0000555E                 db 0FFh
.xdata$x:0000555F                 db 0FFh
.xdata$x:00005560                 dd offset __unwindfunclet$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00005564 __ehfuncinfo$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005564                                         ; DATA XREF: __ehhandler$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005565                 db    5
.xdata$x:00005566                 db  93h ; ô
.xdata$x:00005567                 db  19h
.xdata$x:00005568                 db    1
.xdata$x:00005569                 db    0
.xdata$x:0000556A                 db    0
.xdata$x:0000556B                 db    0
.xdata$x:0000556C                 dd offset __unwindtable$??1?$_Vector_alloc@$0A@U?$_Vec_base_types@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00005570                 db    0
.xdata$x:00005571                 db    0
.xdata$x:00005572                 db    0
.xdata$x:00005573                 db    0
.xdata$x:00005574                 db    0
.xdata$x:00005575                 db    0
.xdata$x:00005576                 db    0
.xdata$x:00005577                 db    0
.xdata$x:00005578                 db    0
.xdata$x:00005579                 db    0
.xdata$x:0000557A                 db    0
.xdata$x:0000557B                 db    0
.xdata$x:0000557C                 db    0
.xdata$x:0000557D                 db    0
.xdata$x:0000557E                 db    0
.xdata$x:0000557F                 db    0
.xdata$x:00005580                 db    0
.xdata$x:00005581                 db    0
.xdata$x:00005582                 db    0
.xdata$x:00005583                 db    0
.xdata$x:00005584                 db    0
.xdata$x:00005585                 db    0
.xdata$x:00005586                 db    0
.xdata$x:00005587                 db    0
.xdata$x:00005587 _xdata$x        ends
.xdata$x:00005587
.xdata$x:00005588 ; ===========================================================================
.xdata$x:00005588
.xdata$x:00005588 ; Segment type: Pure data
.xdata$x:00005588 ; Segment permissions: Read
.xdata$x:00005588 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005588                 assume cs:_xdata$x
.xdata$x:00005588                 ;org 5588h
.xdata$x:00005588 ; COMDAT (pick associative to section at 2BE8)
.xdata$x:00005588 __catchsym$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$5 db    0
.xdata$x:00005588                                         ; DATA XREF: .xdata$x:000055A8o
.xdata$x:00005589                 db    0
.xdata$x:0000558A                 db    0
.xdata$x:0000558B                 db    0
.xdata$x:0000558C                 db    0
.xdata$x:0000558D                 db    0
.xdata$x:0000558E                 db    0
.xdata$x:0000558F                 db    0
.xdata$x:00005590                 db    0
.xdata$x:00005591                 db    0
.xdata$x:00005592                 db    0
.xdata$x:00005593                 db    0
.xdata$x:00005594                 dd offset __catch$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00005598 __tryblocktable$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z db    1
.xdata$x:00005598                                         ; DATA XREF: .xdata$x:000055BCo
.xdata$x:00005599                 db    0
.xdata$x:0000559A                 db    0
.xdata$x:0000559B                 db    0
.xdata$x:0000559C                 db    3
.xdata$x:0000559D                 db    0
.xdata$x:0000559E                 db    0
.xdata$x:0000559F                 db    0
.xdata$x:000055A0                 db    4
.xdata$x:000055A1                 db    0
.xdata$x:000055A2                 db    0
.xdata$x:000055A3                 db    0
.xdata$x:000055A4                 db    1
.xdata$x:000055A5                 db    0
.xdata$x:000055A6                 db    0
.xdata$x:000055A7                 db    0
.xdata$x:000055A8                 dd offset __catchsym$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$5
.xdata$x:000055AC __ehfuncinfo$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:000055AC                                         ; DATA XREF: __ehhandler$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:000055AD                 db    5
.xdata$x:000055AE                 db  93h ; ô
.xdata$x:000055AF                 db  19h
.xdata$x:000055B0                 db    5
.xdata$x:000055B1                 db    0
.xdata$x:000055B2                 db    0
.xdata$x:000055B3                 db    0
.xdata$x:000055B4                 dd offset __unwindtable$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:000055B8                 db    1
.xdata$x:000055B9                 db    0
.xdata$x:000055BA                 db    0
.xdata$x:000055BB                 db    0
.xdata$x:000055BC                 dd offset __tryblocktable$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:000055C0                 db    0
.xdata$x:000055C1                 db    0
.xdata$x:000055C2                 db    0
.xdata$x:000055C3                 db    0
.xdata$x:000055C4                 db    0
.xdata$x:000055C5                 db    0
.xdata$x:000055C6                 db    0
.xdata$x:000055C7                 db    0
.xdata$x:000055C8                 db    0
.xdata$x:000055C9                 db    0
.xdata$x:000055CA                 db    0
.xdata$x:000055CB                 db    0
.xdata$x:000055CC                 db    0
.xdata$x:000055CD                 db    0
.xdata$x:000055CE                 db    0
.xdata$x:000055CF                 db    0
.xdata$x:000055D0 __unwindtable$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:000055D0                                         ; DATA XREF: .xdata$x:000055B4o
.xdata$x:000055D1                 db 0FFh
.xdata$x:000055D2                 db 0FFh
.xdata$x:000055D3                 db 0FFh
.xdata$x:000055D4                 dd offset __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$2
.xdata$x:000055D8                 align 10h
.xdata$x:000055E0                 db    1
.xdata$x:000055E1                 db    0
.xdata$x:000055E2                 db    0
.xdata$x:000055E3                 db    0
.xdata$x:000055E4                 dd offset __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$3
.xdata$x:000055E8                 db    2
.xdata$x:000055E9                 db    0
.xdata$x:000055EA                 db    0
.xdata$x:000055EB                 db    0
.xdata$x:000055EC                 dd offset __unwindfunclet$??0?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@ABV01@@Z$4
.xdata$x:000055F0                 db    0
.xdata$x:000055F1                 db    0
.xdata$x:000055F2                 db    0
.xdata$x:000055F3                 db    0
.xdata$x:000055F4                 db    0
.xdata$x:000055F5                 db    0
.xdata$x:000055F6                 db    0
.xdata$x:000055F7                 db    0
.xdata$x:000055F7 _xdata$x        ends
.xdata$x:000055F7
.xdata$x:000055F8 ; ===========================================================================
.xdata$x:000055F8
.xdata$x:000055F8 ; Segment type: Pure data
.xdata$x:000055F8 ; Segment permissions: Read
.xdata$x:000055F8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000055F8                 assume cs:_xdata$x
.xdata$x:000055F8                 ;org 55F8h
.xdata$x:000055F8 ; COMDAT (pick associative to section at 33C0)
.xdata$x:000055F8 __unwindtable$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:000055F8                                         ; DATA XREF: .xdata$x:00005608o
.xdata$x:000055F9                 db 0FFh
.xdata$x:000055FA                 db 0FFh
.xdata$x:000055FB                 db 0FFh
.xdata$x:000055FC                 dd offset __unwindfunclet$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ$0
.xdata$x:00005600 __ehfuncinfo$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005600                                         ; DATA XREF: __ehhandler$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005601                 db    5
.xdata$x:00005602                 db  93h ; ô
.xdata$x:00005603                 db  19h
.xdata$x:00005604                 db    1
.xdata$x:00005605                 db    0
.xdata$x:00005606                 db    0
.xdata$x:00005607                 db    0
.xdata$x:00005608                 dd offset __unwindtable$??1?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QAE@XZ
.xdata$x:0000560C                 db    0
.xdata$x:0000560D                 db    0
.xdata$x:0000560E                 db    0
.xdata$x:0000560F                 db    0
.xdata$x:00005610                 db    0
.xdata$x:00005611                 db    0
.xdata$x:00005612                 db    0
.xdata$x:00005613                 db    0
.xdata$x:00005614                 db    0
.xdata$x:00005615                 db    0
.xdata$x:00005616                 db    0
.xdata$x:00005617                 db    0
.xdata$x:00005618                 db    0
.xdata$x:00005619                 db    0
.xdata$x:0000561A                 db    0
.xdata$x:0000561B                 db    0
.xdata$x:0000561C                 db    0
.xdata$x:0000561D                 db    0
.xdata$x:0000561E                 db    0
.xdata$x:0000561F                 db    0
.xdata$x:00005620                 db    0
.xdata$x:00005621                 db    0
.xdata$x:00005622                 db    0
.xdata$x:00005623                 db    0
.xdata$x:00005623 _xdata$x        ends
.xdata$x:00005623
.xdata$x:00005624 ; ===========================================================================
.xdata$x:00005624
.xdata$x:00005624 ; Segment type: Pure data
.xdata$x:00005624 ; Segment permissions: Read
.xdata$x:00005624 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005624                 assume cs:_xdata$x
.xdata$x:00005624                 ;org 5624h
.xdata$x:00005624 ; COMDAT (pick associative to section at 46B8)
.xdata$x:00005624 __unwindtable$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00005624                                         ; DATA XREF: .xdata$x:00005634o
.xdata$x:00005625                 db 0FFh
.xdata$x:00005626                 db 0FFh
.xdata$x:00005627                 db 0FFh
.xdata$x:00005628                 dd offset __unwindfunclet$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0
.xdata$x:0000562C __ehfuncinfo$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:0000562C                                         ; DATA XREF: __ehhandler$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ+11o
.xdata$x:0000562D                 db    5
.xdata$x:0000562E                 db  93h ; ô
.xdata$x:0000562F                 db  19h
.xdata$x:00005630                 db    1
.xdata$x:00005631                 db    0
.xdata$x:00005632                 db    0
.xdata$x:00005633                 db    0
.xdata$x:00005634                 dd offset __unwindtable$?begin@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.xdata$x:00005638                 db    0
.xdata$x:00005639                 db    0
.xdata$x:0000563A                 db    0
.xdata$x:0000563B                 db    0
.xdata$x:0000563C                 db    0
.xdata$x:0000563D                 db    0
.xdata$x:0000563E                 db    0
.xdata$x:0000563F                 db    0
.xdata$x:00005640                 db    0
.xdata$x:00005641                 db    0
.xdata$x:00005642                 db    0
.xdata$x:00005643                 db    0
.xdata$x:00005644                 db    0
.xdata$x:00005645                 db    0
.xdata$x:00005646                 db    0
.xdata$x:00005647                 db    0
.xdata$x:00005648                 db    0
.xdata$x:00005649                 db    0
.xdata$x:0000564A                 db    0
.xdata$x:0000564B                 db    0
.xdata$x:0000564C                 db    0
.xdata$x:0000564D                 db    0
.xdata$x:0000564E                 db    0
.xdata$x:0000564F                 db    0
.xdata$x:0000564F _xdata$x        ends
.xdata$x:0000564F
.xdata$x:00005650 ; ===========================================================================
.xdata$x:00005650
.xdata$x:00005650 ; Segment type: Pure data
.xdata$x:00005650 ; Segment permissions: Read
.xdata$x:00005650 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005650                 assume cs:_xdata$x
.xdata$x:00005650                 ;org 5650h
.xdata$x:00005650 ; COMDAT (pick associative to section at 48CC)
.xdata$x:00005650 __unwindtable$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ db 0FFh
.xdata$x:00005650                                         ; DATA XREF: .xdata$x:00005660o
.xdata$x:00005651                 db 0FFh
.xdata$x:00005652                 db 0FFh
.xdata$x:00005653                 db 0FFh
.xdata$x:00005654                 dd offset __unwindfunclet$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ$0
.xdata$x:00005658 __ehfuncinfo$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ db  22h ; "
.xdata$x:00005658                                         ; DATA XREF: __ehhandler$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ+11o
.xdata$x:00005659                 db    5
.xdata$x:0000565A                 db  93h ; ô
.xdata$x:0000565B                 db  19h
.xdata$x:0000565C                 db    1
.xdata$x:0000565D                 db    0
.xdata$x:0000565E                 db    0
.xdata$x:0000565F                 db    0
.xdata$x:00005660                 dd offset __unwindtable$?end@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@2@XZ
.xdata$x:00005664                 db    0
.xdata$x:00005665                 db    0
.xdata$x:00005666                 db    0
.xdata$x:00005667                 db    0
.xdata$x:00005668                 db    0
.xdata$x:00005669                 db    0
.xdata$x:0000566A                 db    0
.xdata$x:0000566B                 db    0
.xdata$x:0000566C                 db    0
.xdata$x:0000566D                 db    0
.xdata$x:0000566E                 db    0
.xdata$x:0000566F                 db    0
.xdata$x:00005670                 db    0
.xdata$x:00005671                 db    0
.xdata$x:00005672                 db    0
.xdata$x:00005673                 db    0
.xdata$x:00005674                 db    0
.xdata$x:00005675                 db    0
.xdata$x:00005676                 db    0
.xdata$x:00005677                 db    0
.xdata$x:00005678                 db    0
.xdata$x:00005679                 db    0
.xdata$x:0000567A                 db    0
.xdata$x:0000567B                 db    0
.xdata$x:0000567B _xdata$x        ends
.xdata$x:0000567B
.xdata$x:0000567C ; ===========================================================================
.xdata$x:0000567C
.xdata$x:0000567C ; Segment type: Pure data
.xdata$x:0000567C ; Segment permissions: Read
.xdata$x:0000567C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000567C                 assume cs:_xdata$x
.xdata$x:0000567C                 ;org 567Ch
.xdata$x:0000567C ; COMDAT (pick associative to section at 2718)
.xdata$x:0000567C __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:0000567C                                         ; DATA XREF: .xdata$x:0000568Co
.xdata$x:0000567D                 db 0FFh
.xdata$x:0000567E                 db 0FFh
.xdata$x:0000567F                 db 0FFh
.xdata$x:00005680                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:00005684 __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:00005684                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:00005685                 db    5
.xdata$x:00005686                 db  93h ; ô
.xdata$x:00005687                 db  19h
.xdata$x:00005688                 db    1
.xdata$x:00005689                 db    0
.xdata$x:0000568A                 db    0
.xdata$x:0000568B                 db    0
.xdata$x:0000568C                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:00005690                 db    0
.xdata$x:00005691                 db    0
.xdata$x:00005692                 db    0
.xdata$x:00005693                 db    0
.xdata$x:00005694                 db    0
.xdata$x:00005695                 db    0
.xdata$x:00005696                 db    0
.xdata$x:00005697                 db    0
.xdata$x:00005698                 db    0
.xdata$x:00005699                 db    0
.xdata$x:0000569A                 db    0
.xdata$x:0000569B                 db    0
.xdata$x:0000569C                 db    0
.xdata$x:0000569D                 db    0
.xdata$x:0000569E                 db    0
.xdata$x:0000569F                 db    0
.xdata$x:000056A0                 db    0
.xdata$x:000056A1                 db    0
.xdata$x:000056A2                 db    0
.xdata$x:000056A3                 db    0
.xdata$x:000056A4                 db    0
.xdata$x:000056A5                 db    0
.xdata$x:000056A6                 db    0
.xdata$x:000056A7                 db    0
.xdata$x:000056A7 _xdata$x        ends
.xdata$x:000056A7
.xdata$x:000056A8 ; ===========================================================================
.xdata$x:000056A8
.xdata$x:000056A8 ; Segment type: Pure data
.xdata$x:000056A8 ; Segment permissions: Read
.xdata$x:000056A8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000056A8                 assume cs:_xdata$x
.xdata$x:000056A8                 ;org 56A8h
.xdata$x:000056A8 ; COMDAT (pick associative to section at 3094)
.xdata$x:000056A8 __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db 0FFh
.xdata$x:000056A8                                         ; DATA XREF: .xdata$x:000056B8o
.xdata$x:000056A9                 db 0FFh
.xdata$x:000056AA                 db 0FFh
.xdata$x:000056AB                 db 0FFh
.xdata$x:000056AC                 dd offset __unwindfunclet$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ$0
.xdata$x:000056B0 __ehfuncinfo$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ db  22h ; "
.xdata$x:000056B0                                         ; DATA XREF: __ehhandler$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ+11o
.xdata$x:000056B1                 db    5
.xdata$x:000056B2                 db  93h ; ô
.xdata$x:000056B3                 db  19h
.xdata$x:000056B4                 db    1
.xdata$x:000056B5                 db    0
.xdata$x:000056B6                 db    0
.xdata$x:000056B7                 db    0
.xdata$x:000056B8                 dd offset __unwindtable$??1?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@XZ
.xdata$x:000056BC                 db    0
.xdata$x:000056BD                 db    0
.xdata$x:000056BE                 db    0
.xdata$x:000056BF                 db    0
.xdata$x:000056C0                 db    0
.xdata$x:000056C1                 db    0
.xdata$x:000056C2                 db    0
.xdata$x:000056C3                 db    0
.xdata$x:000056C4                 db    0
.xdata$x:000056C5                 db    0
.xdata$x:000056C6                 db    0
.xdata$x:000056C7                 db    0
.xdata$x:000056C8                 db    0
.xdata$x:000056C9                 db    0
.xdata$x:000056CA                 db    0
.xdata$x:000056CB                 db    0
.xdata$x:000056CC                 db    0
.xdata$x:000056CD                 db    0
.xdata$x:000056CE                 db    0
.xdata$x:000056CF                 db    0
.xdata$x:000056D0                 db    0
.xdata$x:000056D1                 db    0
.xdata$x:000056D2                 db    0
.xdata$x:000056D3                 db    0
.xdata$x:000056D3 _xdata$x        ends
.xdata$x:000056D3
.xdata$x:000056D4 ; ===========================================================================
.xdata$x:000056D4
.xdata$x:000056D4 ; Segment type: Pure data
.xdata$x:000056D4 ; Segment permissions: Read
.xdata$x:000056D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000056D4                 assume cs:_xdata$x
.xdata$x:000056D4                 ;org 56D4h
.xdata$x:000056D4 ; COMDAT (pick associative to section at 26A0)
.xdata$x:000056D4 __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db 0FFh
.xdata$x:000056D4                                         ; DATA XREF: .xdata$x:000056E4o
.xdata$x:000056D5                 db 0FFh
.xdata$x:000056D6                 db 0FFh
.xdata$x:000056D7                 db 0FFh
.xdata$x:000056D8                 dd offset __unwindfunclet$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z$0
.xdata$x:000056DC __ehfuncinfo$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z db  22h ; "
.xdata$x:000056DC                                         ; DATA XREF: __ehhandler$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z+11o
.xdata$x:000056DD                 db    5
.xdata$x:000056DE                 db  93h ; ô
.xdata$x:000056DF                 db  19h
.xdata$x:000056E0                 db    1
.xdata$x:000056E1                 db    0
.xdata$x:000056E2                 db    0
.xdata$x:000056E3                 db    0
.xdata$x:000056E4                 dd offset __unwindtable$??0?$_Iterator012@Urandom_access_iterator_tag@std@@PAVDockingCont@@HPBQAV3@ABQAV3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
.xdata$x:000056E8                 align 20h
.xdata$x:000056E8 _xdata$x        ends
.xdata$x:000056E8
.xdata$x:00005700 ; ===========================================================================
.xdata$x:00005700
.xdata$x:00005700 ; Segment type: Pure data
.xdata$x:00005700 ; Segment permissions: Read
.xdata$x:00005700 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005700                 assume cs:_xdata$x
.xdata$x:00005700                 ;org 5700h
.xdata$x:00005700 ; COMDAT (pick associative to section at 2990)
.xdata$x:00005700 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z db 0FFh
.xdata$x:00005700                                         ; DATA XREF: .xdata$x:00005710o
.xdata$x:00005701                 db 0FFh
.xdata$x:00005702                 db 0FFh
.xdata$x:00005703                 db 0FFh
.xdata$x:00005704                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z$0
.xdata$x:00005708 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z db  22h ; "
.xdata$x:00005708                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z+11o
.xdata$x:00005709                 db    5
.xdata$x:0000570A                 db  93h ; ô
.xdata$x:0000570B                 db  19h
.xdata$x:0000570C                 db    1
.xdata$x:0000570D                 db    0
.xdata$x:0000570E                 db    0
.xdata$x:0000570F                 db    0
.xdata$x:00005710                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@PAPAVDockingCont@@PBU_Container_base12@1@@Z
.xdata$x:00005714                 db    0
.xdata$x:00005715                 db    0
.xdata$x:00005716                 db    0
.xdata$x:00005717                 db    0
.xdata$x:00005718                 db    0
.xdata$x:00005719                 db    0
.xdata$x:0000571A                 db    0
.xdata$x:0000571B                 db    0
.xdata$x:0000571C                 db    0
.xdata$x:0000571D                 db    0
.xdata$x:0000571E                 db    0
.xdata$x:0000571F                 db    0
.xdata$x:00005720                 db    0
.xdata$x:00005721                 db    0
.xdata$x:00005722                 db    0
.xdata$x:00005723                 db    0
.xdata$x:00005724                 db    0
.xdata$x:00005725                 db    0
.xdata$x:00005726                 db    0
.xdata$x:00005727                 db    0
.xdata$x:00005728                 db    0
.xdata$x:00005729                 db    0
.xdata$x:0000572A                 db    0
.xdata$x:0000572B                 db    0
.xdata$x:0000572B _xdata$x        ends
.xdata$x:0000572B
.xdata$x:0000572C ; ===========================================================================
.xdata$x:0000572C
.xdata$x:0000572C ; Segment type: Pure data
.xdata$x:0000572C ; Segment permissions: Read
.xdata$x:0000572C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000572C                 assume cs:_xdata$x
.xdata$x:0000572C                 ;org 572Ch
.xdata$x:0000572C ; COMDAT (pick associative to section at 3264)
.xdata$x:0000572C __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ db 0FFh
.xdata$x:0000572C                                         ; DATA XREF: .xdata$x:0000573Co
.xdata$x:0000572D                 db 0FFh
.xdata$x:0000572E                 db 0FFh
.xdata$x:0000572F                 db 0FFh
.xdata$x:00005730                 dd offset __unwindfunclet$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ$0
.xdata$x:00005734 __ehfuncinfo$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ db  22h ; "
.xdata$x:00005734                                         ; DATA XREF: __ehhandler$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ+11o
.xdata$x:00005735                 db    5
.xdata$x:00005736                 db  93h ; ô
.xdata$x:00005737                 db  19h
.xdata$x:00005738                 db    1
.xdata$x:00005739                 db    0
.xdata$x:0000573A                 db    0
.xdata$x:0000573B                 db    0
.xdata$x:0000573C                 dd offset __unwindtable$??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@XZ
.xdata$x:00005740                 db    0
.xdata$x:00005741                 db    0
.xdata$x:00005742                 db    0
.xdata$x:00005743                 db    0
.xdata$x:00005744                 db    0
.xdata$x:00005745                 db    0
.xdata$x:00005746                 db    0
.xdata$x:00005747                 db    0
.xdata$x:00005748                 db    0
.xdata$x:00005749                 db    0
.xdata$x:0000574A                 db    0
.xdata$x:0000574B                 db    0
.xdata$x:0000574C                 db    0
.xdata$x:0000574D                 db    0
.xdata$x:0000574E                 db    0
.xdata$x:0000574F                 db    0
.xdata$x:00005750                 db    0
.xdata$x:00005751                 db    0
.xdata$x:00005752                 db    0
.xdata$x:00005753                 db    0
.xdata$x:00005754                 db    0
.xdata$x:00005755                 db    0
.xdata$x:00005756                 db    0
.xdata$x:00005757                 db    0
.xdata$x:00005757 _xdata$x        ends
.xdata$x:00005757
.xdata$x:00005758 ; ===========================================================================
.xdata$x:00005758
.xdata$x:00005758 ; Segment type: Pure data
.xdata$x:00005758 ; Segment permissions: Read
.xdata$x:00005758 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005758                 assume cs:_xdata$x
.xdata$x:00005758                 ;org 5758h
.xdata$x:00005758 ; COMDAT (pick associative to section at 290C)
.xdata$x:00005758 __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z db 0FFh
.xdata$x:00005758                                         ; DATA XREF: .xdata$x:00005768o
.xdata$x:00005759                 db 0FFh
.xdata$x:0000575A                 db 0FFh
.xdata$x:0000575B                 db 0FFh
.xdata$x:0000575C                 dd offset __unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z$0
.xdata$x:00005760 __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z db  22h ; "
.xdata$x:00005760                                         ; DATA XREF: __ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z+11o
.xdata$x:00005761                 db    5
.xdata$x:00005762                 db  93h ; ô
.xdata$x:00005763                 db  19h
.xdata$x:00005764                 db    1
.xdata$x:00005765                 db    0
.xdata$x:00005766                 db    0
.xdata$x:00005767                 db    0
.xdata$x:00005768                 dd offset __unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@QAE@ABV01@@Z
.xdata$x:0000576C                 db    0
.xdata$x:0000576D                 db    0
.xdata$x:0000576E                 db    0
.xdata$x:0000576F                 db    0
.xdata$x:00005770                 db    0
.xdata$x:00005771                 db    0
.xdata$x:00005772                 db    0
.xdata$x:00005773                 db    0
.xdata$x:00005774                 db    0
.xdata$x:00005775                 db    0
.xdata$x:00005776                 db    0
.xdata$x:00005777                 db    0
.xdata$x:00005778                 db    0
.xdata$x:00005779                 db    0
.xdata$x:0000577A                 db    0
.xdata$x:0000577B                 db    0
.xdata$x:0000577C                 db    0
.xdata$x:0000577D                 db    0
.xdata$x:0000577E                 db    0
.xdata$x:0000577F                 db    0
.xdata$x:00005780                 db    0
.xdata$x:00005781                 db    0
.xdata$x:00005782                 db    0
.xdata$x:00005783                 db    0
.xdata$x:00005783 _xdata$x        ends
.xdata$x:00005783
.xdata$x:00005784 ; ===========================================================================
.xdata$x:00005784
.xdata$x:00005784 ; Segment type: Pure data
.xdata$x:00005784 ; Segment permissions: Read
.xdata$x:00005784 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005784                 assume cs:_xdata$x
.xdata$x:00005784                 ;org 5784h
.xdata$x:00005784 ; COMDAT (pick associative to section at 20B4)
.xdata$x:00005784 __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z db 0FFh
.xdata$x:00005784                                         ; DATA XREF: .xdata$x:000057ACo
.xdata$x:00005785                 db 0FFh
.xdata$x:00005786                 db 0FFh
.xdata$x:00005787                 db 0FFh
.xdata$x:00005788                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$0
.xdata$x:0000578C                 align 10h
.xdata$x:00005790                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$1
.xdata$x:00005794                 db    1
.xdata$x:00005795                 db    0
.xdata$x:00005796                 db    0
.xdata$x:00005797                 db    0
.xdata$x:00005798                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$2
.xdata$x:0000579C                 db    2
.xdata$x:0000579D                 db    0
.xdata$x:0000579E                 db    0
.xdata$x:0000579F                 db    0
.xdata$x:000057A0                 dd offset __unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z$3
.xdata$x:000057A4 __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z db  22h ; "
.xdata$x:000057A4                                         ; DATA XREF: __ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z+11o
.xdata$x:000057A5                 db    5
.xdata$x:000057A6                 db  93h ; ô
.xdata$x:000057A7                 db  19h
.xdata$x:000057A8                 db    4
.xdata$x:000057A9                 db    0
.xdata$x:000057AA                 db    0
.xdata$x:000057AB                 db    0
.xdata$x:000057AC                 dd offset __unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@@?$vector@PAVDockingCont@@V?$allocator@PAVDockingCont@@@std@@@std@@IAEPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@1@0PAPAV2@@Z
.xdata$x:000057B0                 db    0
.xdata$x:000057B1                 db    0
.xdata$x:000057B2                 db    0
.xdata$x:000057B3                 db    0
.xdata$x:000057B4                 db    0
.xdata$x:000057B5                 db    0
.xdata$x:000057B6                 db    0
.xdata$x:000057B7                 db    0
.xdata$x:000057B8                 db    0
.xdata$x:000057B9                 db    0
.xdata$x:000057BA                 db    0
.xdata$x:000057BB                 db    0
.xdata$x:000057BC                 db    0
.xdata$x:000057BD                 db    0
.xdata$x:000057BE                 db    0
.xdata$x:000057BF                 db    0
.xdata$x:000057C0                 db    0
.xdata$x:000057C1                 db    0
.xdata$x:000057C2                 db    0
.xdata$x:000057C3                 db    0
.xdata$x:000057C4                 db    0
.xdata$x:000057C5                 db    0
.xdata$x:000057C6                 db    0
.xdata$x:000057C7                 db    0
.xdata$x:000057C7 _xdata$x        ends
.xdata$x:000057C7
.xdata$x:000057C8 ; ===========================================================================
.xdata$x:000057C8
.xdata$x:000057C8 ; Segment type: Pure data
.xdata$x:000057C8 ; Segment permissions: Read
.xdata$x:000057C8 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000057C8                 assume cs:_xdata$x
.xdata$x:000057C8                 ;org 57C8h
.xdata$x:000057C8 ; COMDAT (pick associative to section at 2530)
.xdata$x:000057C8 __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db 0FFh
.xdata$x:000057C8                                         ; DATA XREF: .xdata$x:000057D8o
.xdata$x:000057C9                 db 0FFh
.xdata$x:000057CA                 db 0FFh
.xdata$x:000057CB                 db 0FFh
.xdata$x:000057CC                 dd offset __unwindfunclet$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z$0
.xdata$x:000057D0 __ehfuncinfo$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z db  22h ; "
.xdata$x:000057D0                                         ; DATA XREF: __ehhandler$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z+11o
.xdata$x:000057D1                 db    5
.xdata$x:000057D2                 db  93h ; ô
.xdata$x:000057D3                 db  19h
.xdata$x:000057D4                 db    1
.xdata$x:000057D5                 db    0
.xdata$x:000057D6                 db    0
.xdata$x:000057D7                 db    0
.xdata$x:000057D8                 dd offset __unwindtable$??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
.xdata$x:000057DC                 db    0
.xdata$x:000057DD                 db    0
.xdata$x:000057DE                 db    0
.xdata$x:000057DF                 db    0
.xdata$x:000057E0                 db    0
.xdata$x:000057E1                 db    0
.xdata$x:000057E2                 db    0
.xdata$x:000057E3                 db    0
.xdata$x:000057E4                 db    0
.xdata$x:000057E5                 db    0
.xdata$x:000057E6                 db    0
.xdata$x:000057E7                 db    0
.xdata$x:000057E8                 db    0
.xdata$x:000057E9                 db    0
.xdata$x:000057EA                 db    0
.xdata$x:000057EB                 db    0
.xdata$x:000057EC                 db    0
.xdata$x:000057ED                 db    0
.xdata$x:000057EE                 db    0
.xdata$x:000057EF                 db    0
.xdata$x:000057F0                 db    0
.xdata$x:000057F1                 db    0
.xdata$x:000057F2                 db    0
.xdata$x:000057F3                 db    0
.xdata$x:000057F3 _xdata$x        ends
.xdata$x:000057F3
.xdata$x:000057F4 ; ===========================================================================
.xdata$x:000057F4
.xdata$x:000057F4 ; Segment type: Pure data
.xdata$x:000057F4 ; Segment permissions: Read
.xdata$x:000057F4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000057F4                 assume cs:_xdata$x
.xdata$x:000057F4                 ;org 57F4h
.xdata$x:000057F4 ; COMDAT (pick associative to section at 22D4)
.xdata$x:000057F4 __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z db 0FFh
.xdata$x:000057F4                                         ; DATA XREF: .xdata$x:0000581Co
.xdata$x:000057F5                 db 0FFh
.xdata$x:000057F6                 db 0FFh
.xdata$x:000057F7                 db 0FFh
.xdata$x:000057F8                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$0
.xdata$x:000057FC                 align 10h
.xdata$x:00005800                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$1
.xdata$x:00005804                 db    1
.xdata$x:00005805                 db    0
.xdata$x:00005806                 db    0
.xdata$x:00005807                 db    0
.xdata$x:00005808                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$2
.xdata$x:0000580C                 db    1
.xdata$x:0000580D                 db    0
.xdata$x:0000580E                 db    0
.xdata$x:0000580F                 db    0
.xdata$x:00005810                 dd offset __unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z$3
.xdata$x:00005814 __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z db  22h ; "
.xdata$x:00005814                                         ; DATA XREF: __ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z+11o
.xdata$x:00005815                 db    5
.xdata$x:00005816                 db  93h ; ô
.xdata$x:00005817                 db  19h
.xdata$x:00005818                 db    4
.xdata$x:00005819                 db    0
.xdata$x:0000581A                 db    0
.xdata$x:0000581B                 db    0
.xdata$x:0000581C                 dd offset __unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@PAPAVDockingCont@@U?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@2@@std@@YAPAPAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@0PAPAV1@AAU?$_Wrap_alloc@V?$allocator@PAVDockingCont@@@std@@@0@@Z
.xdata$x:00005820                 db    0
.xdata$x:00005821                 db    0
.xdata$x:00005822                 db    0
.xdata$x:00005823                 db    0
.xdata$x:00005824                 db    0
.xdata$x:00005825                 db    0
.xdata$x:00005826                 db    0
.xdata$x:00005827                 db    0
.xdata$x:00005828                 db    0
.xdata$x:00005829                 db    0
.xdata$x:0000582A                 db    0
.xdata$x:0000582B                 db    0
.xdata$x:0000582C                 db    0
.xdata$x:0000582D                 db    0
.xdata$x:0000582E                 db    0
.xdata$x:0000582F                 db    0
.xdata$x:00005830                 db    0
.xdata$x:00005831                 db    0
.xdata$x:00005832                 db    0
.xdata$x:00005833                 db    0
.xdata$x:00005834                 db    0
.xdata$x:00005835                 db    0
.xdata$x:00005836                 db    0
.xdata$x:00005837                 db    0
.xdata$x:00005837 _xdata$x        ends
.xdata$x:00005837
.xdata$x:00005838 ; ===========================================================================
.xdata$x:00005838
.xdata$x:00005838 ; Segment type: Pure data
.xdata$x:00005838 ; Segment permissions: Read
.xdata$x:00005838 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005838                 assume cs:_xdata$x
.xdata$x:00005838                 ;org 5838h
.xdata$x:00005838 ; COMDAT (pick associative to section at 21BC)
.xdata$x:00005838 __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z db 0FFh
.xdata$x:00005838                                         ; DATA XREF: .xdata$x:00005848o
.xdata$x:00005839                 db 0FFh
.xdata$x:0000583A                 db 0FFh
.xdata$x:0000583B                 db 0FFh
.xdata$x:0000583C                 dd offset __unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z$0
.xdata$x:00005840 __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z db  22h ; "
.xdata$x:00005840                                         ; DATA XREF: __ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z+11o
.xdata$x:00005841                 db    5
.xdata$x:00005842                 db  93h ; ô
.xdata$x:00005843                 db  19h
.xdata$x:00005844                 db    1
.xdata$x:00005845                 db    0
.xdata$x:00005846                 db    0
.xdata$x:00005847                 db    0
.xdata$x:00005848                 dd offset __unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@std@@YAPBQAVDockingCont@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVDockingCont@@@std@@@std@@@0@@Z
.xdata$x:0000584C                 db    0
.xdata$x:0000584D                 db    0
.xdata$x:0000584E                 db    0
.xdata$x:0000584F                 db    0
.xdata$x:00005850                 db    0
.xdata$x:00005851                 db    0
.xdata$x:00005852                 db    0
.xdata$x:00005853                 db    0
.xdata$x:00005854                 db    0
.xdata$x:00005855                 db    0
.xdata$x:00005856                 db    0
.xdata$x:00005857                 db    0
.xdata$x:00005858                 db    0
.xdata$x:00005859                 db    0
.xdata$x:0000585A                 db    0
.xdata$x:0000585B                 db    0
.xdata$x:0000585C                 db    0
.xdata$x:0000585D                 db    0
.xdata$x:0000585E                 db    0
.xdata$x:0000585F                 db    0
.xdata$x:00005860                 db    0
.xdata$x:00005861                 db    0
.xdata$x:00005862                 db    0
.xdata$x:00005863                 db    0
.xdata$x:00005863 _xdata$x        ends
.xdata$x:00005863
.xdata$x:00005864 ; ===========================================================================
.xdata$x:00005864
.xdata$x:00005864 ; Segment type: Pure data
.xdata$x:00005864 ; Segment permissions: Read
.xdata$x:00005864 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005864                 assume cs:_xdata$x
.xdata$x:00005864                 ;org 5864h
.xdata$x:00005864 ; COMDAT (pick associative to section at 2430)
.xdata$x:00005864 __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db 0FFh
.xdata$x:00005864                                         ; DATA XREF: .xdata$x:00005874o
.xdata$x:00005865                 db 0FFh
.xdata$x:00005866                 db 0FFh
.xdata$x:00005867                 db 0FFh
.xdata$x:00005868                 dd offset __unwindfunclet$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z$0
.xdata$x:0000586C __ehfuncinfo$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z db  22h ; "
.xdata$x:0000586C                                         ; DATA XREF: __ehhandler$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z+11o
.xdata$x:0000586D                 db    5
.xdata$x:0000586E                 db  93h ; ô
.xdata$x:0000586F                 db  19h
.xdata$x:00005870                 db    1
.xdata$x:00005871                 db    0
.xdata$x:00005872                 db    0
.xdata$x:00005873                 db    0
.xdata$x:00005874                 dd offset __unwindtable$??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
.xdata$x:00005878                 db    0
.xdata$x:00005879                 db    0
.xdata$x:0000587A                 db    0
.xdata$x:0000587B                 db    0
.xdata$x:0000587C                 db    0
.xdata$x:0000587D                 db    0
.xdata$x:0000587E                 db    0
.xdata$x:0000587F                 db    0
.xdata$x:00005880                 db    0
.xdata$x:00005881                 db    0
.xdata$x:00005882                 db    0
.xdata$x:00005883                 db    0
.xdata$x:00005884                 db    0
.xdata$x:00005885                 db    0
.xdata$x:00005886                 db    0
.xdata$x:00005887                 db    0
.xdata$x:00005888                 db    0
.xdata$x:00005889                 db    0
.xdata$x:0000588A                 db    0
.xdata$x:0000588B                 db    0
.xdata$x:0000588C                 db    0
.xdata$x:0000588D                 db    0
.xdata$x:0000588E                 db    0
.xdata$x:0000588F                 db    0
.xdata$x:0000588F _xdata$x        ends
.xdata$x:0000588F
.rdata:00005890 ; ===========================================================================
.rdata:00005890
.rdata:00005890 ; Segment type: Pure data
.rdata:00005890 ; Segment permissions: Read
.rdata:00005890 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00005890 _rdata          segment para public 'DATA' use32
.rdata:00005890                 assume cs:_rdata
.rdata:00005890                 ;org 5890h
.rdata:00005890 ; COMDAT (pick any)
.rdata:00005890                 public ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00005890 ; wchar_t `string'
.rdata:00005890 ??_C@_1JA@EADLBAJ@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00005890                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+48o
.rdata:00005890                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00005890                 unicode 0, <clude\xutility>,0
.rdata:00005890 _rdata          ends
.rdata:00005890
.rdata:00005920 ; ===========================================================================
.rdata:00005920
.rdata:00005920 ; Segment type: Pure data
.rdata:00005920 ; Segment permissions: Read
.rdata:00005920 _rdata          segment dword public 'DATA' use32
.rdata:00005920                 assume cs:_rdata
.rdata:00005920                 ;org 5920h
.rdata:00005920 ; COMDAT (pick any)
.rdata:00005920                 public ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
.rdata:00005920 ; wchar_t `string'
.rdata:00005920 ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@:
.rdata:00005920                                         ; DATA XREF: std::_Iterator_base12::_Orphan_me(void)+4Do
.rdata:00005920                 unicode 0, <ITERATOR LIST CORRUPTED!>,0
.rdata:00005952                 align 4
.rdata:00005952 _rdata          ends
.rdata:00005952
.rdata:00005954 ; ===========================================================================
.rdata:00005954
.rdata:00005954 ; Segment type: Pure data
.rdata:00005954 ; Segment permissions: Read
.rdata:00005954 _rdata          segment dword public 'DATA' use32
.rdata:00005954                 assume cs:_rdata
.rdata:00005954                 ;org 5954h
.rdata:00005954 ; COMDAT (pick largest)
.rdata:00005954                 dd offset ??_R4runtime_error@std@@6B@ ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata:00005958                 public ??_7runtime_error@std@@6B@
.rdata:00005958 ; const std::runtime_error::`vftable'
.rdata:00005958 ??_7runtime_error@std@@6B@ dd offset ??_Eruntime_error@std@@UAEPAXI@Z
.rdata:00005958                                         ; DATA XREF: std::runtime_error::runtime_error(std::runtime_error const &)+3Co
.rdata:00005958                                         ; std::runtime_error::runtime_error(char const *)+3Co
.rdata:00005958                                         ; std::runtime_error::`vector deleting destructor'(uint)
.rdata:0000595C                 dd offset ?what@exception@std@@UBEPBDXZ ; std::exception::what(void)
.rdata:0000595C _rdata          ends
.rdata:0000595C
.xdata$x:00005960 ; ===========================================================================
.xdata$x:00005960
.xdata$x:00005960 ; Segment type: Pure data
.xdata$x:00005960 ; Segment permissions: Read
.xdata$x:00005960 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005960                 assume cs:_xdata$x
.xdata$x:00005960                 ;org 5960h
.xdata$x:00005960 ; COMDAT (pick any)
.xdata$x:00005960                 public __TI2?AVruntime_error@std@@
.xdata$x:00005960 __TI2?AVruntime_error@std@@ db    0     ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+A8o
.xdata$x:00005960                                         ; Gripper::startGrip(DockingCont *,DockingManager *)+11Eo
.xdata$x:00005961                 db    0
.xdata$x:00005962                 db    0
.xdata$x:00005963                 db    0
.xdata$x:00005964                 dd offset ??1runtime_error@std@@UAE@XZ ; std::runtime_error::~runtime_error(void)
.xdata$x:00005968                 db    0
.xdata$x:00005969                 db    0
.xdata$x:0000596A                 db    0
.xdata$x:0000596B                 db    0
.xdata$x:0000596C                 dd offset __CTA2?AVruntime_error@std@@
.xdata$x:0000596C _xdata$x        ends
.xdata$x:0000596C
.xdata$x:00005970 ; ===========================================================================
.xdata$x:00005970
.xdata$x:00005970 ; Segment type: Pure data
.xdata$x:00005970 ; Segment permissions: Read
.xdata$x:00005970 _xdata$x        segment dword public 'DATA' use32
.xdata$x:00005970                 assume cs:_xdata$x
.xdata$x:00005970                 ;org 5970h
.xdata$x:00005970 ; COMDAT (pick any)
.xdata$x:00005970                 public __CTA2?AVruntime_error@std@@
.xdata$x:00005970 __CTA2?AVruntime_error@std@@ db    2    ; DATA XREF: .xdata$x:0000596Co
.xdata$x:00005971                 db    0
.xdata$x:00005972                 db    0
.xdata$x:00005973                 db    0
.xdata$x:00005974                 dd offset __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:00005978                 dd offset __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:00005978 _xdata$x        ends
.xdata$x:00005978
.data$r:0000597C ; ===========================================================================
.data$r:0000597C
.data$r:0000597C ; Segment type: Pure data
.data$r:0000597C ; Segment permissions: Read/Write
.data$r:0000597C _data$r         segment dword public 'DATA' use32
.data$r:0000597C                 assume cs:_data$r
.data$r:0000597C                 ;org 597Ch
.data$r:0000597C ; COMDAT (pick any)
.data$r:0000597C                 public ??_R0?AVruntime_error@std@@@8
.data$r:0000597C ; class std::runtime_error `RTTI Type Descriptor'
.data$r:0000597C ??_R0?AVruntime_error@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000597C                                         ; DATA XREF: .xdata$x:000059A0o
.data$r:0000597C                                         ; .rdata$r:00005F58o ...
.data$r:0000597C                                         ; const type_info::`vftable'
.data$r:00005980                 db    0
.data$r:00005981                 db    0
.data$r:00005982                 db    0
.data$r:00005983                 db    0
.data$r:00005984                 db  2Eh ; .
.data$r:00005985                 db  3Fh ; ?
.data$r:00005986                 db  41h ; A
.data$r:00005987                 db  56h ; V
.data$r:00005988                 db  72h ; r
.data$r:00005989                 db  75h ; u
.data$r:0000598A                 db  6Eh ; n
.data$r:0000598B                 db  74h ; t
.data$r:0000598C                 db  69h ; i
.data$r:0000598D                 db  6Dh ; m
.data$r:0000598E                 db  65h ; e
.data$r:0000598F                 db  5Fh ; _
.data$r:00005990                 db  65h ; e
.data$r:00005991                 db  72h ; r
.data$r:00005992                 db  72h ; r
.data$r:00005993                 db  6Fh ; o
.data$r:00005994                 db  72h ; r
.data$r:00005995                 db  40h ; @
.data$r:00005996                 db  73h ; s
.data$r:00005997                 db  74h ; t
.data$r:00005998                 db  64h ; d
.data$r:00005999                 db  40h ; @
.data$r:0000599A                 db  40h ; @
.data$r:0000599B                 db    0
.data$r:0000599B _data$r         ends
.data$r:0000599B
.xdata$x:0000599C ; ===========================================================================
.xdata$x:0000599C
.xdata$x:0000599C ; Segment type: Pure data
.xdata$x:0000599C ; Segment permissions: Read
.xdata$x:0000599C _xdata$x        segment dword public 'DATA' use32
.xdata$x:0000599C                 assume cs:_xdata$x
.xdata$x:0000599C                 ;org 599Ch
.xdata$x:0000599C ; COMDAT (pick any)
.xdata$x:0000599C                 public __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
.xdata$x:0000599C __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 db    0
.xdata$x:0000599C                                         ; DATA XREF: .xdata$x:00005974o
.xdata$x:0000599D                 db    0
.xdata$x:0000599E                 db    0
.xdata$x:0000599F                 db    0
.xdata$x:000059A0                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.xdata$x:000059A4                 align 8
.xdata$x:000059A8                 db 0FFh
.xdata$x:000059A9                 db 0FFh
.xdata$x:000059AA                 db 0FFh
.xdata$x:000059AB                 db 0FFh
.xdata$x:000059AC                 db    0
.xdata$x:000059AD                 db    0
.xdata$x:000059AE                 db    0
.xdata$x:000059AF                 db    0
.xdata$x:000059B0                 db  0Ch
.xdata$x:000059B1                 db    0
.xdata$x:000059B2                 db    0
.xdata$x:000059B3                 db    0
.xdata$x:000059B4                 dd offset ??0runtime_error@std@@QAE@ABV01@@Z ; std::runtime_error::runtime_error(std::runtime_error const &)
.xdata$x:000059B4 _xdata$x        ends
.xdata$x:000059B4
.data$r:000059B8 ; ===========================================================================
.data$r:000059B8
.data$r:000059B8 ; Segment type: Pure data
.data$r:000059B8 ; Segment permissions: Read/Write
.data$r:000059B8 _data$r         segment dword public 'DATA' use32
.data$r:000059B8                 assume cs:_data$r
.data$r:000059B8                 ;org 59B8h
.data$r:000059B8 ; COMDAT (pick any)
.data$r:000059B8                 public ??_R0?AVexception@std@@@8
.data$r:000059B8 ; class std::exception `RTTI Type Descriptor'
.data$r:000059B8 ??_R0?AVexception@std@@@8 dd offset ??_7type_info@@6B@
.data$r:000059B8                                         ; DATA XREF: .xdata$x:000059D8o
.data$r:000059B8                                         ; .rdata$r:std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:000059B8                                         ; const type_info::`vftable'
.data$r:000059BC                 align 10h
.data$r:000059C0 a_?avexception@ db '.?AVexception@std@@',0
.data$r:000059C0 _data$r         ends
.data$r:000059C0
.xdata$x:000059D4 ; ===========================================================================
.xdata$x:000059D4
.xdata$x:000059D4 ; Segment type: Pure data
.xdata$x:000059D4 ; Segment permissions: Read
.xdata$x:000059D4 _xdata$x        segment dword public 'DATA' use32
.xdata$x:000059D4                 assume cs:_xdata$x
.xdata$x:000059D4                 ;org 59D4h
.xdata$x:000059D4 ; COMDAT (pick any)
.xdata$x:000059D4                 public __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
.xdata$x:000059D4 __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 db    0
.xdata$x:000059D4                                         ; DATA XREF: .xdata$x:00005978o
.xdata$x:000059D5                 db    0
.xdata$x:000059D6                 db    0
.xdata$x:000059D7                 db    0
.xdata$x:000059D8                 dd offset ??_R0?AVexception@std@@@8 ; std::exception `RTTI Type Descriptor'
.xdata$x:000059DC                 align 10h
.xdata$x:000059E0                 db 0FFh
.xdata$x:000059E1                 db 0FFh
.xdata$x:000059E2                 db 0FFh
.xdata$x:000059E3                 db 0FFh
.xdata$x:000059E4                 db    0
.xdata$x:000059E5                 db    0
.xdata$x:000059E6                 db    0
.xdata$x:000059E7                 db    0
.xdata$x:000059E8                 db  0Ch
.xdata$x:000059E9                 db    0
.xdata$x:000059EA                 db    0
.xdata$x:000059EB                 db    0
.xdata$x:000059EC                 dd offset ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception(std::exception const &)
.xdata$x:000059EC _xdata$x        ends
.xdata$x:000059EC
.rdata:000059F0 ; ===========================================================================
.rdata:000059F0
.rdata:000059F0 ; Segment type: Pure data
.rdata:000059F0 ; Segment permissions: Read
.rdata:000059F0 _rdata          segment dword public 'DATA' use32
.rdata:000059F0                 assume cs:_rdata
.rdata:000059F0                 ;org 59F0h
.rdata:000059F0 ; COMDAT (pick largest)
.rdata:000059F0                 dd offset ??_R4error_category@std@@6B@ ; const std::error_category::`RTTI Complete Object Locator'
.rdata:000059F4                 public ??_7error_category@std@@6B@
.rdata:000059F4 ; const std::error_category::`vftable'
.rdata:000059F4 ??_7error_category@std@@6B@ dd offset ??_Eerror_category@std@@UAEPAXI@Z
.rdata:000059F4                                         ; DATA XREF: std::error_category::error_category(void)+Ao
.rdata:000059F4                                         ; std::error_category::~error_category(void)+Ao
.rdata:000059F4                                         ; std::error_category::`vector deleting destructor'(uint)
.rdata:000059F8                 dd offset __purecall
.rdata:000059FC                 dd offset __purecall
.rdata:00005A00                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00005A04                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00005A08                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00005A08 _rdata          ends
.rdata:00005A08
.rdata:00005A0C ; ===========================================================================
.rdata:00005A0C
.rdata:00005A0C ; Segment type: Pure data
.rdata:00005A0C ; Segment permissions: Read
.rdata:00005A0C _rdata          segment dword public 'DATA' use32
.rdata:00005A0C                 assume cs:_rdata
.rdata:00005A0C                 ;org 5A0Ch
.rdata:00005A0C ; COMDAT (pick largest)
.rdata:00005A0C                 dd offset ??_R4_Generic_error_category@std@@6B@ ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata:00005A10                 public ??_7_Generic_error_category@std@@6B@
.rdata:00005A10 ; const std::_Generic_error_category::`vftable'
.rdata:00005A10 ??_7_Generic_error_category@std@@6B@ dd offset ??_E_Generic_error_category@std@@UAEPAXI@Z
.rdata:00005A10                                         ; DATA XREF: std::_Generic_error_category::_Generic_error_category(void)+38o
.rdata:00005A10                                         ; std::_Generic_error_category::`vector deleting destructor'(uint)
.rdata:00005A14                 dd offset ?name@_Generic_error_category@std@@UBEPBDXZ ; std::_Generic_error_category::name(void)
.rdata:00005A18                 dd offset ?message@_Generic_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message(int)
.rdata:00005A1C                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00005A20                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00005A24                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00005A24 _rdata          ends
.rdata:00005A24
.rdata:00005A28 ; ===========================================================================
.rdata:00005A28
.rdata:00005A28 ; Segment type: Pure data
.rdata:00005A28 ; Segment permissions: Read
.rdata:00005A28 _rdata          segment dword public 'DATA' use32
.rdata:00005A28                 assume cs:_rdata
.rdata:00005A28                 ;org 5A28h
.rdata:00005A28 ; COMDAT (pick any)
.rdata:00005A28                 public ??_C@_07DCLBNMLN@generic?$AA@
.rdata:00005A28 ; `string'
.rdata:00005A28 ??_C@_07DCLBNMLN@generic?$AA@ db 'generic',0
.rdata:00005A28                                         ; DATA XREF: std::_Generic_error_category::name(void)+7o
.rdata:00005A28 _rdata          ends
.rdata:00005A28
.rdata:00005A30 ; ===========================================================================
.rdata:00005A30
.rdata:00005A30 ; Segment type: Pure data
.rdata:00005A30 ; Segment permissions: Read
.rdata:00005A30 _rdata          segment dword public 'DATA' use32
.rdata:00005A30                 assume cs:_rdata
.rdata:00005A30                 ;org 5A30h
.rdata:00005A30 ; COMDAT (pick any)
.rdata:00005A30                 public ??_C@_0O@BFJCFAAK@unknown?5error?$AA@
.rdata:00005A30 ; `string'
.rdata:00005A30 ??_C@_0O@BFJCFAAK@unknown?5error?$AA@ db 'unknown error',0
.rdata:00005A30                                         ; DATA XREF: std::_Generic_error_category::message(int):loc_4CACo
.rdata:00005A30                                         ; std::_System_error_category::message(int):loc_4E28o
.rdata:00005A3E                 align 10h
.rdata:00005A3E _rdata          ends
.rdata:00005A3E
.rdata:00005A40 ; ===========================================================================
.rdata:00005A40
.rdata:00005A40 ; Segment type: Pure data
.rdata:00005A40 ; Segment permissions: Read
.rdata:00005A40 _rdata          segment dword public 'DATA' use32
.rdata:00005A40                 assume cs:_rdata
.rdata:00005A40                 ;org 5A40h
.rdata:00005A40 ; COMDAT (pick largest)
.rdata:00005A40                 dd offset ??_R4_Iostream_error_category@std@@6B@ ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata:00005A44                 public ??_7_Iostream_error_category@std@@6B@
.rdata:00005A44 ; const std::_Iostream_error_category::`vftable'
.rdata:00005A44 ??_7_Iostream_error_category@std@@6B@ dd offset ??_E_Iostream_error_category@std@@UAEPAXI@Z
.rdata:00005A44                                         ; DATA XREF: std::_Iostream_error_category::_Iostream_error_category(void)+38o
.rdata:00005A44                                         ; std::_Iostream_error_category::`vector deleting destructor'(uint)
.rdata:00005A48                 dd offset ?name@_Iostream_error_category@std@@UBEPBDXZ ; std::_Iostream_error_category::name(void)
.rdata:00005A4C                 dd offset ?message@_Iostream_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Iostream_error_category::message(int)
.rdata:00005A50                 dd offset ?default_error_condition@error_category@std@@UBE?AVerror_condition@2@H@Z ; std::error_category::default_error_condition(int)
.rdata:00005A54                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00005A58                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00005A58 _rdata          ends
.rdata:00005A58
.rdata:00005A5C ; ===========================================================================
.rdata:00005A5C
.rdata:00005A5C ; Segment type: Pure data
.rdata:00005A5C ; Segment permissions: Read
.rdata:00005A5C _rdata          segment dword public 'DATA' use32
.rdata:00005A5C                 assume cs:_rdata
.rdata:00005A5C                 ;org 5A5Ch
.rdata:00005A5C ; COMDAT (pick any)
.rdata:00005A5C                 public ??_C@_08LLGCOLLL@iostream?$AA@
.rdata:00005A5C ; `string'
.rdata:00005A5C ??_C@_08LLGCOLLL@iostream?$AA@ db 'iostream',0
.rdata:00005A5C                                         ; DATA XREF: std::_Iostream_error_category::name(void)+7o
.rdata:00005A65                 align 4
.rdata:00005A65 _rdata          ends
.rdata:00005A65
.rdata:00005A68 ; ===========================================================================
.rdata:00005A68
.rdata:00005A68 ; Segment type: Pure data
.rdata:00005A68 ; Segment permissions: Read
.rdata:00005A68 _rdata          segment dword public 'DATA' use32
.rdata:00005A68                 assume cs:_rdata
.rdata:00005A68                 ;org 5A68h
.rdata:00005A68 ; COMDAT (pick any)
.rdata:00005A68                 public ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@
.rdata:00005A68 ; char `string'[]
.rdata:00005A68 ??_C@_0BG@PADBLCHM@iostream?5stream?5error?$AA@ db 'iostream stream error',0
.rdata:00005A68                                         ; DATA XREF: std::_Iostream_error_category::message(int)+35o
.rdata:00005A7E                 align 10h
.rdata:00005A7E _rdata          ends
.rdata:00005A7E
.rdata:00005A80 ; ===========================================================================
.rdata:00005A80
.rdata:00005A80 ; Segment type: Pure data
.rdata:00005A80 ; Segment permissions: Read
.rdata:00005A80 _rdata          segment dword public 'DATA' use32
.rdata:00005A80                 assume cs:_rdata
.rdata:00005A80                 ;org 5A80h
.rdata:00005A80 ; COMDAT (pick largest)
.rdata:00005A80                 dd offset ??_R4_System_error_category@std@@6B@ ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata:00005A84                 public ??_7_System_error_category@std@@6B@
.rdata:00005A84 ; const std::_System_error_category::`vftable'
.rdata:00005A84 ??_7_System_error_category@std@@6B@ dd offset ??_E_System_error_category@std@@UAEPAXI@Z
.rdata:00005A84                                         ; DATA XREF: std::_System_error_category::_System_error_category(void)+38o
.rdata:00005A84                                         ; std::_System_error_category::`vector deleting destructor'(uint)
.rdata:00005A88                 dd offset ?name@_System_error_category@std@@UBEPBDXZ ; std::_System_error_category::name(void)
.rdata:00005A8C                 dd offset ?message@_System_error_category@std@@UBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message(int)
.rdata:00005A90                 dd offset ?default_error_condition@_System_error_category@std@@UBE?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition(int)
.rdata:00005A94                 dd offset ?equivalent@error_category@std@@UBE_NABVerror_code@2@H@Z ; std::error_category::equivalent(std::error_code const &,int)
.rdata:00005A98                 dd offset ?equivalent@error_category@std@@UBE_NHABVerror_condition@2@@Z ; std::error_category::equivalent(int,std::error_condition const &)
.rdata:00005A98 _rdata          ends
.rdata:00005A98
.rdata:00005A9C ; ===========================================================================
.rdata:00005A9C
.rdata:00005A9C ; Segment type: Pure data
.rdata:00005A9C ; Segment permissions: Read
.rdata:00005A9C _rdata          segment dword public 'DATA' use32
.rdata:00005A9C                 assume cs:_rdata
.rdata:00005A9C                 ;org 5A9Ch
.rdata:00005A9C ; COMDAT (pick any)
.rdata:00005A9C                 public ??_C@_06FHFOAHML@system?$AA@
.rdata:00005A9C ; `string'
.rdata:00005A9C ??_C@_06FHFOAHML@system?$AA@ db 'system',0
.rdata:00005A9C                                         ; DATA XREF: std::_System_error_category::name(void)+7o
.rdata:00005AA3                 align 4
.rdata:00005AA3 _rdata          ends
.rdata:00005AA3
.bss:00005AA4 ; ===========================================================================
.bss:00005AA4
.bss:00005AA4 ; Segment type: Uninitialized
.bss:00005AA4 ; Segment permissions: Read/Write
.bss:00005AA4 _bss            segment dword public 'BSS' use32
.bss:00005AA4                 assume cs:_bss
.bss:00005AA4                 ;org 5AA4h
.bss:00005AA4 ; COMDAT (pick any)
.bss:00005AA4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005AA4                 public ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A
.bss:00005AA4 ; std::_Generic_error_category std::_Error_objects<int>::_Generic_object
.bss:00005AA4 ?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A db    ? ;
.bss:00005AA4                                         ; DATA XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o
.bss:00005AA4                                         ; `dynamic atexit destructor for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+3o ...
.bss:00005AA5                 db    ? ;
.bss:00005AA6                 db    ? ;
.bss:00005AA7                 db    ? ;
.bss:00005AA7 _bss            ends
.bss:00005AA7
.bss:00005AA8 ; ===========================================================================
.bss:00005AA8
.bss:00005AA8 ; Segment type: Uninitialized
.bss:00005AA8 ; Segment permissions: Read/Write
.bss:00005AA8 _bss            segment dword public 'BSS' use32
.bss:00005AA8                 assume cs:_bss
.bss:00005AA8                 ;org 5AA8h
.bss:00005AA8 ; COMDAT (pick any)
.bss:00005AA8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005AA8                 public ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A
.bss:00005AA8 ; std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object
.bss:00005AA8 ?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A db    ? ;
.bss:00005AA8                                         ; DATA XREF: `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00005AA8                                         ; `dynamic atexit destructor for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+3o
.bss:00005AA9                 db    ? ;
.bss:00005AAA                 db    ? ;
.bss:00005AAB                 db    ? ;
.bss:00005AAB _bss            ends
.bss:00005AAB
.bss:00005AAC ; ===========================================================================
.bss:00005AAC
.bss:00005AAC ; Segment type: Uninitialized
.bss:00005AAC ; Segment permissions: Read/Write
.bss:00005AAC _bss            segment dword public 'BSS' use32
.bss:00005AAC                 assume cs:_bss
.bss:00005AAC                 ;org 5AACh
.bss:00005AAC ; COMDAT (pick any)
.bss:00005AAC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005AAC                 public ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A
.bss:00005AAC ; std::_System_error_category std::_Error_objects<int>::_System_object
.bss:00005AAC ?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A db    ? ;
.bss:00005AAC                                         ; DATA XREF: `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o
.bss:00005AAC                                         ; `dynamic atexit destructor for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)+3o ...
.bss:00005AAD                 db    ? ;
.bss:00005AAE                 db    ? ;
.bss:00005AAF                 db    ? ;
.bss:00005AAF _bss            ends
.bss:00005AAF
.bss:00005AB0 ; ===========================================================================
.bss:00005AB0
.bss:00005AB0 ; Segment type: Uninitialized
.bss:00005AB0 ; Segment permissions: Read/Write
.bss:00005AB0 _bss            segment dword public 'BSS' use32
.bss:00005AB0                 assume cs:_bss
.bss:00005AB0                 ;org 5AB0h
.bss:00005AB0 ; COMDAT (pick any)
.bss:00005AB0                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005AB0                 public ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00005AB0 ; std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id
.bss:00005AB0 ?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00005AB0                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)+5o
.bss:00005AB1                 db    ? ;
.bss:00005AB2                 db    ? ;
.bss:00005AB3                 db    ? ;
.bss:00005AB3 _bss            ends
.bss:00005AB3
.bss:00005AB4 ; ===========================================================================
.bss:00005AB4
.bss:00005AB4 ; Segment type: Uninitialized
.bss:00005AB4 ; Segment permissions: Read/Write
.bss:00005AB4 _bss            segment dword public 'BSS' use32
.bss:00005AB4                 assume cs:_bss
.bss:00005AB4                 ;org 5AB4h
.bss:00005AB4 ; COMDAT (pick any)
.bss:00005AB4                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005AB4                 public ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A
.bss:00005AB4 ; std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id
.bss:00005AB4 ?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A db    ? ;
.bss:00005AB4                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)+5o
.bss:00005AB5                 db    ? ;
.bss:00005AB6                 db    ? ;
.bss:00005AB7                 db    ? ;
.bss:00005AB7 _bss            ends
.bss:00005AB7
.bss:00005AB8 ; ===========================================================================
.bss:00005AB8
.bss:00005AB8 ; Segment type: Uninitialized
.bss:00005AB8 ; Segment permissions: Read/Write
.bss:00005AB8 ; Segment alignment 'qword' can not be represented in assembly
.bss:00005AB8 _bss            segment para public 'BSS' use32
.bss:00005AB8                 assume cs:_bss
.bss:00005AB8                 ;org 5AB8h
.bss:00005AB8 ; COMDAT (pick any)
.bss:00005AB8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005AB8 ; wchar_t * `protected: void __thiscall Gripper::initTabInformation(void)'::`7'::szText
.bss:00005AB8 ?szText@?6??initTabInformation@Gripper@@IAEXXZ@4PA_WA db    ? ;
.bss:00005AB8                                         ; DATA XREF: Gripper::initTabInformation(void)+DFo
.bss:00005AB9                 db    ? ;
.bss:00005ABA                 db    ? ;
.bss:00005ABB                 db    ? ;
.bss:00005ABC                 db    ? ;
.bss:00005ABD                 db    ? ;
.bss:00005ABE                 db    ? ;
.bss:00005ABF                 db    ? ;
.bss:00005AC0                 db    ? ;
.bss:00005AC1                 db    ? ;
.bss:00005AC2                 db    ? ;
.bss:00005AC3                 db    ? ;
.bss:00005AC4                 db    ? ;
.bss:00005AC5                 db    ? ;
.bss:00005AC6                 db    ? ;
.bss:00005AC7                 db    ? ;
.bss:00005AC8                 db    ? ;
.bss:00005AC9                 db    ? ;
.bss:00005ACA                 db    ? ;
.bss:00005ACB                 db    ? ;
.bss:00005ACC                 db    ? ;
.bss:00005ACD                 db    ? ;
.bss:00005ACE                 db    ? ;
.bss:00005ACF                 db    ? ;
.bss:00005AD0                 db    ? ;
.bss:00005AD1                 db    ? ;
.bss:00005AD2                 db    ? ;
.bss:00005AD3                 db    ? ;
.bss:00005AD4                 db    ? ;
.bss:00005AD5                 db    ? ;
.bss:00005AD6                 db    ? ;
.bss:00005AD7                 db    ? ;
.bss:00005AD8                 db    ? ;
.bss:00005AD9                 db    ? ;
.bss:00005ADA                 db    ? ;
.bss:00005ADB                 db    ? ;
.bss:00005ADC                 db    ? ;
.bss:00005ADD                 db    ? ;
.bss:00005ADE                 db    ? ;
.bss:00005ADF                 db    ? ;
.bss:00005AE0                 db    ? ;
.bss:00005AE1                 db    ? ;
.bss:00005AE2                 db    ? ;
.bss:00005AE3                 db    ? ;
.bss:00005AE4                 db    ? ;
.bss:00005AE5                 db    ? ;
.bss:00005AE6                 db    ? ;
.bss:00005AE7                 db    ? ;
.bss:00005AE8                 db    ? ;
.bss:00005AE9                 db    ? ;
.bss:00005AEA                 db    ? ;
.bss:00005AEB                 db    ? ;
.bss:00005AEC                 db    ? ;
.bss:00005AED                 db    ? ;
.bss:00005AEE                 db    ? ;
.bss:00005AEF                 db    ? ;
.bss:00005AF0                 db    ? ;
.bss:00005AF1                 db    ? ;
.bss:00005AF2                 db    ? ;
.bss:00005AF3                 db    ? ;
.bss:00005AF4                 db    ? ;
.bss:00005AF5                 db    ? ;
.bss:00005AF6                 db    ? ;
.bss:00005AF7                 db    ? ;
.bss:00005AF8                 db    ? ;
.bss:00005AF9                 db    ? ;
.bss:00005AFA                 db    ? ;
.bss:00005AFB                 db    ? ;
.bss:00005AFC                 db    ? ;
.bss:00005AFD                 db    ? ;
.bss:00005AFE                 db    ? ;
.bss:00005AFF                 db    ? ;
.bss:00005B00                 db    ? ;
.bss:00005B01                 db    ? ;
.bss:00005B02                 db    ? ;
.bss:00005B03                 db    ? ;
.bss:00005B04                 db    ? ;
.bss:00005B05                 db    ? ;
.bss:00005B06                 db    ? ;
.bss:00005B07                 db    ? ;
.bss:00005B08                 db    ? ;
.bss:00005B09                 db    ? ;
.bss:00005B0A                 db    ? ;
.bss:00005B0B                 db    ? ;
.bss:00005B0C                 db    ? ;
.bss:00005B0D                 db    ? ;
.bss:00005B0E                 db    ? ;
.bss:00005B0F                 db    ? ;
.bss:00005B10                 db    ? ;
.bss:00005B11                 db    ? ;
.bss:00005B12                 db    ? ;
.bss:00005B13                 db    ? ;
.bss:00005B14                 db    ? ;
.bss:00005B15                 db    ? ;
.bss:00005B16                 db    ? ;
.bss:00005B17                 db    ? ;
.bss:00005B18                 db    ? ;
.bss:00005B19                 db    ? ;
.bss:00005B1A                 db    ? ;
.bss:00005B1B                 db    ? ;
.bss:00005B1C                 db    ? ;
.bss:00005B1D                 db    ? ;
.bss:00005B1E                 db    ? ;
.bss:00005B1F                 db    ? ;
.bss:00005B20                 db    ? ;
.bss:00005B21                 db    ? ;
.bss:00005B22                 db    ? ;
.bss:00005B23                 db    ? ;
.bss:00005B24                 db    ? ;
.bss:00005B25                 db    ? ;
.bss:00005B26                 db    ? ;
.bss:00005B27                 db    ? ;
.bss:00005B28                 db    ? ;
.bss:00005B29                 db    ? ;
.bss:00005B2A                 db    ? ;
.bss:00005B2B                 db    ? ;
.bss:00005B2C                 db    ? ;
.bss:00005B2D                 db    ? ;
.bss:00005B2E                 db    ? ;
.bss:00005B2F                 db    ? ;
.bss:00005B30                 db    ? ;
.bss:00005B31                 db    ? ;
.bss:00005B32                 db    ? ;
.bss:00005B33                 db    ? ;
.bss:00005B34                 db    ? ;
.bss:00005B35                 db    ? ;
.bss:00005B36                 db    ? ;
.bss:00005B37                 db    ? ;
.bss:00005B37 _bss            ends
.bss:00005B37
.rdata:00005B38 ; ===========================================================================
.rdata:00005B38
.rdata:00005B38 ; Segment type: Pure data
.rdata:00005B38 ; Segment permissions: Read
.rdata:00005B38 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00005B38 _rdata          segment para public 'DATA' use32
.rdata:00005B38                 assume cs:_rdata
.rdata:00005B38                 ;org 5B38h
.rdata:00005B38 ; COMDAT (pick any)
.rdata:00005B38                 public ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00005B38 ; wchar_t `string'
.rdata:00005B38 ??_C@_1IO@FEAPGJBD@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00005B38                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *)+Co
.rdata:00005B38                                         ; std::basic_string<char,std::char_traits<char>,std::allocator<char>>::assign(char const *,uint)+12o
.rdata:00005B38                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00005B38                 unicode 0, <clude\xstring>,0
.rdata:00005BC6                 align 4
.rdata:00005BC6 _rdata          ends
.rdata:00005BC6
.bss:00005BC8 ; ===========================================================================
.bss:00005BC8
.bss:00005BC8 ; Segment type: Uninitialized
.bss:00005BC8 ; Segment permissions: Read/Write
.bss:00005BC8 _bss            segment dword public 'BSS' use32
.bss:00005BC8                 assume cs:_bss
.bss:00005BC8                 ;org 5BC8h
.bss:00005BC8 ; COMDAT (pick any)
.bss:00005BC8                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005BC8                 public ?id@?$numpunct@D@std@@2V0locale@2@A
.bss:00005BC8 ; std::locale::id std::numpunct<char>::id
.bss:00005BC8 ?id@?$numpunct@D@std@@2V0locale@2@A db    ? ;
.bss:00005BC8                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)+5o
.bss:00005BC9                 db    ? ;
.bss:00005BCA                 db    ? ;
.bss:00005BCB                 db    ? ;
.bss:00005BCB _bss            ends
.bss:00005BCB
.bss:00005BCC ; ===========================================================================
.bss:00005BCC
.bss:00005BCC ; Segment type: Uninitialized
.bss:00005BCC ; Segment permissions: Read/Write
.bss:00005BCC _bss            segment dword public 'BSS' use32
.bss:00005BCC                 assume cs:_bss
.bss:00005BCC                 ;org 5BCCh
.bss:00005BCC ; COMDAT (pick any)
.bss:00005BCC                 assume es:nothing, ss:nothing, ds:_rdata, fs:nothing, gs:nothing
.bss:00005BCC                 public ?id@?$numpunct@_W@std@@2V0locale@2@A
.bss:00005BCC ; std::locale::id std::numpunct<wchar_t>::id
.bss:00005BCC ?id@?$numpunct@_W@std@@2V0locale@2@A db    ? ;
.bss:00005BCC                                         ; DATA XREF: `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)+5o
.bss:00005BCD                 db    ? ;
.bss:00005BCE                 db    ? ;
.bss:00005BCF                 db    ? ;
.bss:00005BCF _bss            ends
.bss:00005BCF
.rdata:00005BD0 ; ===========================================================================
.rdata:00005BD0
.rdata:00005BD0 ; Segment type: Pure data
.rdata:00005BD0 ; Segment permissions: Read
.rdata:00005BD0 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00005BD0 _rdata          segment para public 'DATA' use32
.rdata:00005BD0                 assume cs:_rdata
.rdata:00005BD0                 ;org 5BD0h
.rdata:00005BD0 ; COMDAT (pick any)
.rdata:00005BD0                 public ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00005BD0 ; wchar_t `string'
.rdata:00005BD0 ??_C@_1IM@EINEHPHE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00005BD0                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+19o
.rdata:00005BD0                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+49o ...
.rdata:00005BD0                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00005BD0                 unicode 0, <clude\vector>,0
.rdata:00005BD0 _rdata          ends
.rdata:00005BD0
.rdata:00005C5C ; ===========================================================================
.rdata:00005C5C
.rdata:00005C5C ; Segment type: Pure data
.rdata:00005C5C ; Segment permissions: Read
.rdata:00005C5C _rdata          segment dword public 'DATA' use32
.rdata:00005C5C                 assume cs:_rdata
.rdata:00005C5C                 ;org 5C5Ch
.rdata:00005C5C ; COMDAT (pick any)
.rdata:00005C5C                 public ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00005C5C ; wchar_t `string'
.rdata:00005C5C ??_C@_1DM@LHGCHCBA@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi?$AAp?$AAt?$AA?5?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00005C5C                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+1Eo
.rdata:00005C5C                 unicode 0, <vector subscript out of range>,0
.rdata:00005C5C _rdata          ends
.rdata:00005C5C
.rdata:00005C98 ; ===========================================================================
.rdata:00005C98
.rdata:00005C98 ; Segment type: Pure data
.rdata:00005C98 ; Segment permissions: Read
.rdata:00005C98 _rdata          segment dword public 'DATA' use32
.rdata:00005C98                 assume cs:_rdata
.rdata:00005C98                 ;org 5C98h
.rdata:00005C98 ; COMDAT (pick any)
.rdata:00005C98                 public ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
.rdata:00005C98 ; `string'
.rdata:00005C98 ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ db 'Standard C++ Libraries Out of Range',0
.rdata:00005C98                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+2Bo
.rdata:00005C98 _rdata          ends
.rdata:00005C98
.rdata:00005CBC ; ===========================================================================
.rdata:00005CBC
.rdata:00005CBC ; Segment type: Pure data
.rdata:00005CBC ; Segment permissions: Read
.rdata:00005CBC ; Segment alignment 'qword' can not be represented in assembly
.rdata:00005CBC _rdata          segment para public 'DATA' use32
.rdata:00005CBC                 assume cs:_rdata
.rdata:00005CBC                 ;org 5CBCh
.rdata:00005CBC ; COMDAT (pick any)
.rdata:00005CBC                 public ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
.rdata:00005CBC ; `string'
.rdata:00005CBC ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@:
.rdata:00005CBC                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint):loc_3890o
.rdata:00005CBC                 unicode 0, <"Standard C++ Libraries Out of Range" && 0>,0
.rdata:00005D12                 align 4
.rdata:00005D12 _rdata          ends
.rdata:00005D12
.rdata:00005D14 ; ===========================================================================
.rdata:00005D14
.rdata:00005D14 ; Segment type: Pure data
.rdata:00005D14 ; Segment permissions: Read
.rdata:00005D14 _rdata          segment dword public 'DATA' use32
.rdata:00005D14                 assume cs:_rdata
.rdata:00005D14                 ;org 5D14h
.rdata:00005D14 ; COMDAT (pick any)
.rdata:00005D14                 public ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
.rdata:00005D14 ; `string'
.rdata:00005D14 ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@:
.rdata:00005D14                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+3Do
.rdata:00005D14                 unicode 0, <%s>,0
.rdata:00005D1A                 align 4
.rdata:00005D1A _rdata          ends
.rdata:00005D1A
.rdata:00005D1C ; ===========================================================================
.rdata:00005D1C
.rdata:00005D1C ; Segment type: Pure data
.rdata:00005D1C ; Segment permissions: Read
.rdata:00005D1C _rdata          segment dword public 'DATA' use32
.rdata:00005D1C                 assume cs:_rdata
.rdata:00005D1C                 ;org 5D1Ch
.rdata:00005D1C ; COMDAT (pick any)
.rdata:00005D1C                 public ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
.rdata:00005D1C ; `string'
.rdata:00005D1C ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@:
.rdata:00005D1C                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+6Fo
.rdata:00005D1C                 unicode 0, <"out of range">,0
.rdata:00005D3A                 align 4
.rdata:00005D3A _rdata          ends
.rdata:00005D3A
.rdata:00005D3C ; ===========================================================================
.rdata:00005D3C
.rdata:00005D3C ; Segment type: Pure data
.rdata:00005D3C ; Segment permissions: Read
.rdata:00005D3C ; Segment alignment 'qword' can not be represented in assembly
.rdata:00005D3C _rdata          segment para public 'DATA' use32
.rdata:00005D3C                 assume cs:_rdata
.rdata:00005D3C                 ;org 5D3Ch
.rdata:00005D3C ; COMDAT (pick any)
.rdata:00005D3C                 public ??_C@_1LC@HLAKEHED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAC?$AAo?$AAn?$AAt?$AA?5?$AA?$CK?$AA?0@
.rdata:00005D3C ; `string'
.rdata:00005D3C ??_C@_1LC@HLAKEHED@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs?$AAs?$AA?5?$AAD?$AAo?$AAc?$AAk?$AAi?$AAn?$AAg?$AAC?$AAo?$AAn?$AAt?$AA?5?$AA?$CK?$AA?0@:
.rdata:00005D3C                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+6Ao
.rdata:00005D3C                 unicode 0, <std::vector>
.rdata:00005D3C                 dw 3Ch
.rdata:00005D3C                 unicode 0, <class DockingCont *,class std::allocator>
.rdata:00005D3C                 dw 3Ch
.rdata:00005D3C                 unicode 0, <class DockingCont *>
.rdata:00005D3C                 dw 3Eh
.rdata:00005D3C                 unicode 0, < >
.rdata:00005D3C                 dw 3Eh
.rdata:00005D3C                 unicode 0, <::operator []>,0
.rdata:00005DEE                 align 10h
.rdata:00005DEE _rdata          ends
.rdata:00005DEE
.rdata:00005DF0 ; ===========================================================================
.rdata:00005DF0
.rdata:00005DF0 ; Segment type: Pure data
.rdata:00005DF0 ; Segment permissions: Read
.rdata:00005DF0 _rdata          segment dword public 'DATA' use32
.rdata:00005DF0                 assume cs:_rdata
.rdata:00005DF0                 ;org 5DF0h
.rdata:00005DF0 ; COMDAT (pick any)
.rdata:00005DF0                 public ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
.rdata:00005DF0 ; char `string'[]
.rdata:00005DF0 ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ db 'string too long',0
.rdata:00005DF0                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+7o
.rdata:00005DF0 _rdata          ends
.rdata:00005DF0
.rdata:00005E00 ; ===========================================================================
.rdata:00005E00
.rdata:00005E00 ; Segment type: Pure data
.rdata:00005E00 ; Segment permissions: Read
.rdata:00005E00 _rdata          segment dword public 'DATA' use32
.rdata:00005E00                 assume cs:_rdata
.rdata:00005E00                 ;org 5E00h
.rdata:00005E00 ; COMDAT (pick any)
.rdata:00005E00                 public ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
.rdata:00005E00 ; char `string'[]
.rdata:00005E00 ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ db 'invalid string position',0
.rdata:00005E00                                         ; DATA XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+7o
.rdata:00005E00 _rdata          ends
.rdata:00005E00
.rdata:00005E18 ; ===========================================================================
.rdata:00005E18
.rdata:00005E18 ; Segment type: Pure data
.rdata:00005E18 ; Segment permissions: Read
.rdata:00005E18 _rdata          segment dword public 'DATA' use32
.rdata:00005E18                 assume cs:_rdata
.rdata:00005E18                 ;org 5E18h
.rdata:00005E18 ; COMDAT (pick any)
.rdata:00005E18                 public ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
.rdata:00005E18 ; char `string'[]
.rdata:00005E18 ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ db 'vector<T> too long',0
.rdata:00005E18                                         ; DATA XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::_Xlen(void)+7o
.rdata:00005E2B                 align 4
.rdata:00005E2B _rdata          ends
.rdata:00005E2B
.rdata:00005E2C ; ===========================================================================
.rdata:00005E2C
.rdata:00005E2C ; Segment type: Pure data
.rdata:00005E2C ; Segment permissions: Read
.rdata:00005E2C _rdata          segment dword public 'DATA' use32
.rdata:00005E2C                 assume cs:_rdata
.rdata:00005E2C                 ;org 5E2Ch
.rdata:00005E2C ; COMDAT (pick any)
.rdata:00005E2C                 public ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@
.rdata:00005E2C ; wchar_t `string'
.rdata:00005E2C ??_C@_1CK@EOPGIILJ@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?$AA@:
.rdata:00005E2C                                         ; DATA XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+11o
.rdata:00005E2C                                         ; std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)+11o ...
.rdata:00005E2C                 unicode 0, <invalid null pointer>,0
.rdata:00005E56                 align 4
.rdata:00005E56 _rdata          ends
.rdata:00005E56
.rdata:00005E58 ; ===========================================================================
.rdata:00005E58
.rdata:00005E58 ; Segment type: Pure data
.rdata:00005E58 ; Segment permissions: Read
.rdata:00005E58 _rdata          segment dword public 'DATA' use32
.rdata:00005E58                 assume cs:_rdata
.rdata:00005E58                 ;org 5E58h
.rdata:00005E58 ; COMDAT (pick any)
.rdata:00005E58                 public ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
.rdata:00005E58 ; wchar_t `string'
.rdata:00005E58 ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@:
.rdata:00005E58                                         ; DATA XREF: std::_Debug_range2<DockingCont * const *>(DockingCont * const *,DockingCont * const *,wchar_t const *,uint,std::random_access_iterator_tag)+43o
.rdata:00005E58                 unicode 0, <invalid iterator range>,0
.rdata:00005E86                 align 4
.rdata:00005E86 _rdata          ends
.rdata:00005E86
.rdata:00005E88 ; ===========================================================================
.rdata:00005E88
.rdata:00005E88 ; Segment type: Pure data
.rdata:00005E88 ; Segment permissions: Read
.rdata:00005E88 ; Segment alignment 'qword' can not be represented in assembly
.rdata:00005E88 _rdata          segment para public 'DATA' use32
.rdata:00005E88                 assume cs:_rdata
.rdata:00005E88                 ;org 5E88h
.rdata:00005E88 ; COMDAT (pick any)
.rdata:00005E88                 public ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
.rdata:00005E88 ; wchar_t `string'
.rdata:00005E88 ??_C@_1IO@LKIDJAMC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@:
.rdata:00005E88                                         ; DATA XREF: std::_Uninit_copy<DockingCont * const,DockingCont *>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)+9o
.rdata:00005E88                                         ; std::_Uninit_copy<DockingCont * const,DockingCont *>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)+23o
.rdata:00005E88                 unicode 0, <C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\in>
.rdata:00005E88                 unicode 0, <clude\xmemory>,0
.rdata:00005F16                 align 4
.rdata:00005F16 _rdata          ends
.rdata:00005F16
.rdata$r:00005F18 ; ===========================================================================
.rdata$r:00005F18
.rdata$r:00005F18 ; Segment type: Pure data
.rdata$r:00005F18 ; Segment permissions: Read
.rdata$r:00005F18 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F18                 assume cs:_rdata$r
.rdata$r:00005F18                 ;org 5F18h
.rdata$r:00005F18 ; COMDAT (pick any)
.rdata$r:00005F18                 public ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00005F18 ; std::exception::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00005F18 ??_R1A@?0A@EA@exception@std@@8 dd offset ??_R0?AVexception@std@@@8
.rdata$r:00005F18                                         ; DATA XREF: .rdata$r:std::exception::`RTTI Base Class Array'o
.rdata$r:00005F18                                         ; .rdata$r:00005F74o
.rdata$r:00005F18                                         ; std::exception `RTTI Type Descriptor'
.rdata$r:00005F1C                 db    0
.rdata$r:00005F1D                 db    0
.rdata$r:00005F1E                 db    0
.rdata$r:00005F1F                 db    0
.rdata$r:00005F20                 db    0
.rdata$r:00005F21                 db    0
.rdata$r:00005F22                 db    0
.rdata$r:00005F23                 db    0
.rdata$r:00005F24                 db 0FFh
.rdata$r:00005F25                 db 0FFh
.rdata$r:00005F26                 db 0FFh
.rdata$r:00005F27                 db 0FFh
.rdata$r:00005F28                 db    0
.rdata$r:00005F29                 db    0
.rdata$r:00005F2A                 db    0
.rdata$r:00005F2B                 db    0
.rdata$r:00005F2C                 db  40h ; @
.rdata$r:00005F2D                 db    0
.rdata$r:00005F2E                 db    0
.rdata$r:00005F2F                 db    0
.rdata$r:00005F30                 dd offset ??_R3exception@std@@8 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00005F30 _rdata$r        ends
.rdata$r:00005F30
.rdata$r:00005F34 ; ===========================================================================
.rdata$r:00005F34
.rdata$r:00005F34 ; Segment type: Pure data
.rdata$r:00005F34 ; Segment permissions: Read
.rdata$r:00005F34 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F34                 assume cs:_rdata$r
.rdata$r:00005F34                 ;org 5F34h
.rdata$r:00005F34 ; COMDAT (pick any)
.rdata$r:00005F34                 public ??_R3exception@std@@8
.rdata$r:00005F34 ; std::exception::`RTTI Class Hierarchy Descriptor'
.rdata$r:00005F34 ??_R3exception@std@@8 db    0           ; DATA XREF: .rdata$r:00005F30o
.rdata$r:00005F35                 db    0
.rdata$r:00005F36                 db    0
.rdata$r:00005F37                 db    0
.rdata$r:00005F38                 db    0
.rdata$r:00005F39                 db    0
.rdata$r:00005F3A                 db    0
.rdata$r:00005F3B                 db    0
.rdata$r:00005F3C                 db    1
.rdata$r:00005F3D                 db    0
.rdata$r:00005F3E                 db    0
.rdata$r:00005F3F                 db    0
.rdata$r:00005F40                 dd offset ??_R2exception@std@@8 ; std::exception::`RTTI Base Class Array'
.rdata$r:00005F40 _rdata$r        ends
.rdata$r:00005F40
.rdata$r:00005F44 ; ===========================================================================
.rdata$r:00005F44
.rdata$r:00005F44 ; Segment type: Pure data
.rdata$r:00005F44 ; Segment permissions: Read
.rdata$r:00005F44 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F44                 assume cs:_rdata$r
.rdata$r:00005F44                 ;org 5F44h
.rdata$r:00005F44 ; COMDAT (pick any)
.rdata$r:00005F44                 public ??_R2exception@std@@8
.rdata$r:00005F44 ; std::exception::`RTTI Base Class Array'
.rdata$r:00005F44 ??_R2exception@std@@8 dd offset ??_R1A@?0A@EA@exception@std@@8
.rdata$r:00005F44                                         ; DATA XREF: .rdata$r:00005F40o
.rdata$r:00005F44                                         ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00005F48                 db    0
.rdata$r:00005F49                 align 4
.rdata$r:00005F49 _rdata$r        ends
.rdata$r:00005F49
.rdata$r:00005F4C ; ===========================================================================
.rdata$r:00005F4C
.rdata$r:00005F4C ; Segment type: Pure data
.rdata$r:00005F4C ; Segment permissions: Read
.rdata$r:00005F4C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F4C                 assume cs:_rdata$r
.rdata$r:00005F4C                 ;org 5F4Ch
.rdata$r:00005F4C ; COMDAT (pick any)
.rdata$r:00005F4C                 public ??_R4runtime_error@std@@6B@
.rdata$r:00005F4C ; const std::runtime_error::`RTTI Complete Object Locator'
.rdata$r:00005F4C ??_R4runtime_error@std@@6B@ db    0     ; DATA XREF: .rdata:00005954o
.rdata$r:00005F4D                 db    0
.rdata$r:00005F4E                 db    0
.rdata$r:00005F4F                 db    0
.rdata$r:00005F50                 db    0
.rdata$r:00005F51                 db    0
.rdata$r:00005F52                 db    0
.rdata$r:00005F53                 db    0
.rdata$r:00005F54                 db    0
.rdata$r:00005F55                 db    0
.rdata$r:00005F56                 db    0
.rdata$r:00005F57                 db    0
.rdata$r:00005F58                 dd offset ??_R0?AVruntime_error@std@@@8 ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00005F5C                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00005F5C _rdata$r        ends
.rdata$r:00005F5C
.rdata$r:00005F60 ; ===========================================================================
.rdata$r:00005F60
.rdata$r:00005F60 ; Segment type: Pure data
.rdata$r:00005F60 ; Segment permissions: Read
.rdata$r:00005F60 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F60                 assume cs:_rdata$r
.rdata$r:00005F60                 ;org 5F60h
.rdata$r:00005F60 ; COMDAT (pick any)
.rdata$r:00005F60                 public ??_R3runtime_error@std@@8
.rdata$r:00005F60 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00005F60 ??_R3runtime_error@std@@8 db    0       ; DATA XREF: .rdata$r:00005F5Co
.rdata$r:00005F60                                         ; .rdata$r:00005F94o
.rdata$r:00005F61                 db    0
.rdata$r:00005F62                 db    0
.rdata$r:00005F63                 db    0
.rdata$r:00005F64                 db    0
.rdata$r:00005F65                 db    0
.rdata$r:00005F66                 db    0
.rdata$r:00005F67                 db    0
.rdata$r:00005F68                 db    2
.rdata$r:00005F69                 db    0
.rdata$r:00005F6A                 db    0
.rdata$r:00005F6B                 db    0
.rdata$r:00005F6C                 dd offset ??_R2runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00005F6C _rdata$r        ends
.rdata$r:00005F6C
.rdata$r:00005F70 ; ===========================================================================
.rdata$r:00005F70
.rdata$r:00005F70 ; Segment type: Pure data
.rdata$r:00005F70 ; Segment permissions: Read
.rdata$r:00005F70 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F70                 assume cs:_rdata$r
.rdata$r:00005F70                 ;org 5F70h
.rdata$r:00005F70 ; COMDAT (pick any)
.rdata$r:00005F70                 public ??_R2runtime_error@std@@8
.rdata$r:00005F70 ; std::runtime_error::`RTTI Base Class Array'
.rdata$r:00005F70 ??_R2runtime_error@std@@8 dd offset ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00005F70                                         ; DATA XREF: .rdata$r:00005F6Co
.rdata$r:00005F70                                         ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00005F74                 dd offset ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00005F78                 db    0
.rdata$r:00005F79                 align 4
.rdata$r:00005F79 _rdata$r        ends
.rdata$r:00005F79
.rdata$r:00005F7C ; ===========================================================================
.rdata$r:00005F7C
.rdata$r:00005F7C ; Segment type: Pure data
.rdata$r:00005F7C ; Segment permissions: Read
.rdata$r:00005F7C _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F7C                 assume cs:_rdata$r
.rdata$r:00005F7C                 ;org 5F7Ch
.rdata$r:00005F7C ; COMDAT (pick any)
.rdata$r:00005F7C                 public ??_R1A@?0A@EA@runtime_error@std@@8
.rdata$r:00005F7C ; std::runtime_error::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00005F7C ??_R1A@?0A@EA@runtime_error@std@@8 dd offset ??_R0?AVruntime_error@std@@@8
.rdata$r:00005F7C                                         ; DATA XREF: .rdata$r:std::runtime_error::`RTTI Base Class Array'o
.rdata$r:00005F7C                                         ; std::runtime_error `RTTI Type Descriptor'
.rdata$r:00005F80                 db    1
.rdata$r:00005F81                 db    0
.rdata$r:00005F82                 db    0
.rdata$r:00005F83                 db    0
.rdata$r:00005F84                 db    0
.rdata$r:00005F85                 db    0
.rdata$r:00005F86                 db    0
.rdata$r:00005F87                 db    0
.rdata$r:00005F88                 db 0FFh
.rdata$r:00005F89                 db 0FFh
.rdata$r:00005F8A                 db 0FFh
.rdata$r:00005F8B                 db 0FFh
.rdata$r:00005F8C                 db    0
.rdata$r:00005F8D                 db    0
.rdata$r:00005F8E                 db    0
.rdata$r:00005F8F                 db    0
.rdata$r:00005F90                 db  40h ; @
.rdata$r:00005F91                 db    0
.rdata$r:00005F92                 db    0
.rdata$r:00005F93                 db    0
.rdata$r:00005F94                 dd offset ??_R3runtime_error@std@@8 ; std::runtime_error::`RTTI Class Hierarchy Descriptor'
.rdata$r:00005F94 _rdata$r        ends
.rdata$r:00005F94
.rdata$r:00005F98 ; ===========================================================================
.rdata$r:00005F98
.rdata$r:00005F98 ; Segment type: Pure data
.rdata$r:00005F98 ; Segment permissions: Read
.rdata$r:00005F98 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005F98                 assume cs:_rdata$r
.rdata$r:00005F98                 ;org 5F98h
.rdata$r:00005F98 ; COMDAT (pick any)
.rdata$r:00005F98                 public ??_R4error_category@std@@6B@
.rdata$r:00005F98 ; const std::error_category::`RTTI Complete Object Locator'
.rdata$r:00005F98 ??_R4error_category@std@@6B@ db    0    ; DATA XREF: .rdata:000059F0o
.rdata$r:00005F99                 db    0
.rdata$r:00005F9A                 db    0
.rdata$r:00005F9B                 db    0
.rdata$r:00005F9C                 db    0
.rdata$r:00005F9D                 db    0
.rdata$r:00005F9E                 db    0
.rdata$r:00005F9F                 db    0
.rdata$r:00005FA0                 db    0
.rdata$r:00005FA1                 db    0
.rdata$r:00005FA2                 db    0
.rdata$r:00005FA3                 db    0
.rdata$r:00005FA4                 dd offset ??_R0?AVerror_category@std@@@8 ; std::error_category `RTTI Type Descriptor'
.rdata$r:00005FA8                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00005FA8 _rdata$r        ends
.rdata$r:00005FA8
.data$r:00005FAC ; ===========================================================================
.data$r:00005FAC
.data$r:00005FAC ; Segment type: Pure data
.data$r:00005FAC ; Segment permissions: Read/Write
.data$r:00005FAC _data$r         segment dword public 'DATA' use32
.data$r:00005FAC                 assume cs:_data$r
.data$r:00005FAC                 ;org 5FACh
.data$r:00005FAC ; COMDAT (pick any)
.data$r:00005FAC                 public ??_R0?AVerror_category@std@@@8
.data$r:00005FAC ; class std::error_category `RTTI Type Descriptor'
.data$r:00005FAC ??_R0?AVerror_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00005FAC                                         ; DATA XREF: .rdata$r:00005FA4o
.data$r:00005FAC                                         ; .rdata$r:std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00005FAC                                         ; const type_info::`vftable'
.data$r:00005FB0                 db    0
.data$r:00005FB1                 db    0
.data$r:00005FB2                 db    0
.data$r:00005FB3                 db    0
.data$r:00005FB4                 db  2Eh ; .
.data$r:00005FB5                 db  3Fh ; ?
.data$r:00005FB6                 db  41h ; A
.data$r:00005FB7                 db  56h ; V
.data$r:00005FB8                 db  65h ; e
.data$r:00005FB9                 db  72h ; r
.data$r:00005FBA                 db  72h ; r
.data$r:00005FBB                 db  6Fh ; o
.data$r:00005FBC                 db  72h ; r
.data$r:00005FBD                 db  5Fh ; _
.data$r:00005FBE                 db  63h ; c
.data$r:00005FBF                 db  61h ; a
.data$r:00005FC0                 db  74h ; t
.data$r:00005FC1                 db  65h ; e
.data$r:00005FC2                 db  67h ; g
.data$r:00005FC3                 db  6Fh ; o
.data$r:00005FC4                 db  72h ; r
.data$r:00005FC5                 db  79h ; y
.data$r:00005FC6                 db  40h ; @
.data$r:00005FC7                 db  73h ; s
.data$r:00005FC8                 db  74h ; t
.data$r:00005FC9                 db  64h ; d
.data$r:00005FCA                 db  40h ; @
.data$r:00005FCB                 db  40h ; @
.data$r:00005FCC                 db    0
.data$r:00005FCD                 align 10h
.data$r:00005FCD _data$r         ends
.data$r:00005FCD
.rdata$r:00005FD0 ; ===========================================================================
.rdata$r:00005FD0
.rdata$r:00005FD0 ; Segment type: Pure data
.rdata$r:00005FD0 ; Segment permissions: Read
.rdata$r:00005FD0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005FD0                 assume cs:_rdata$r
.rdata$r:00005FD0                 ;org 5FD0h
.rdata$r:00005FD0 ; COMDAT (pick any)
.rdata$r:00005FD0                 public ??_R3error_category@std@@8
.rdata$r:00005FD0 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00005FD0 ??_R3error_category@std@@8 db    0      ; DATA XREF: .rdata$r:00005FA8o
.rdata$r:00005FD0                                         ; .rdata$r:00006000o
.rdata$r:00005FD1                 db    0
.rdata$r:00005FD2                 db    0
.rdata$r:00005FD3                 db    0
.rdata$r:00005FD4                 db    0
.rdata$r:00005FD5                 db    0
.rdata$r:00005FD6                 db    0
.rdata$r:00005FD7                 db    0
.rdata$r:00005FD8                 db    1
.rdata$r:00005FD9                 db    0
.rdata$r:00005FDA                 db    0
.rdata$r:00005FDB                 db    0
.rdata$r:00005FDC                 dd offset ??_R2error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00005FDC _rdata$r        ends
.rdata$r:00005FDC
.rdata$r:00005FE0 ; ===========================================================================
.rdata$r:00005FE0
.rdata$r:00005FE0 ; Segment type: Pure data
.rdata$r:00005FE0 ; Segment permissions: Read
.rdata$r:00005FE0 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005FE0                 assume cs:_rdata$r
.rdata$r:00005FE0                 ;org 5FE0h
.rdata$r:00005FE0 ; COMDAT (pick any)
.rdata$r:00005FE0                 public ??_R2error_category@std@@8
.rdata$r:00005FE0 ; std::error_category::`RTTI Base Class Array'
.rdata$r:00005FE0 ??_R2error_category@std@@8 dd offset ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00005FE0                                         ; DATA XREF: .rdata$r:00005FDCo
.rdata$r:00005FE0                                         ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00005FE4                 db    0
.rdata$r:00005FE5                 align 4
.rdata$r:00005FE5 _rdata$r        ends
.rdata$r:00005FE5
.rdata$r:00005FE8 ; ===========================================================================
.rdata$r:00005FE8
.rdata$r:00005FE8 ; Segment type: Pure data
.rdata$r:00005FE8 ; Segment permissions: Read
.rdata$r:00005FE8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00005FE8                 assume cs:_rdata$r
.rdata$r:00005FE8                 ;org 5FE8h
.rdata$r:00005FE8 ; COMDAT (pick any)
.rdata$r:00005FE8                 public ??_R1A@?0A@EA@error_category@std@@8
.rdata$r:00005FE8 ; std::error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00005FE8 ??_R1A@?0A@EA@error_category@std@@8 dd offset ??_R0?AVerror_category@std@@@8
.rdata$r:00005FE8                                         ; DATA XREF: .rdata$r:std::error_category::`RTTI Base Class Array'o
.rdata$r:00005FE8                                         ; .rdata$r:00006058o ...
.rdata$r:00005FE8                                         ; std::error_category `RTTI Type Descriptor'
.rdata$r:00005FEC                 db    0
.rdata$r:00005FED                 db    0
.rdata$r:00005FEE                 db    0
.rdata$r:00005FEF                 db    0
.rdata$r:00005FF0                 db    0
.rdata$r:00005FF1                 db    0
.rdata$r:00005FF2                 db    0
.rdata$r:00005FF3                 db    0
.rdata$r:00005FF4                 db 0FFh
.rdata$r:00005FF5                 db 0FFh
.rdata$r:00005FF6                 db 0FFh
.rdata$r:00005FF7                 db 0FFh
.rdata$r:00005FF8                 db    0
.rdata$r:00005FF9                 db    0
.rdata$r:00005FFA                 db    0
.rdata$r:00005FFB                 db    0
.rdata$r:00005FFC                 db  40h ; @
.rdata$r:00005FFD                 db    0
.rdata$r:00005FFE                 db    0
.rdata$r:00005FFF                 db    0
.rdata$r:00006000                 dd offset ??_R3error_category@std@@8 ; std::error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006000 _rdata$r        ends
.rdata$r:00006000
.rdata$r:00006004 ; ===========================================================================
.rdata$r:00006004
.rdata$r:00006004 ; Segment type: Pure data
.rdata$r:00006004 ; Segment permissions: Read
.rdata$r:00006004 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006004                 assume cs:_rdata$r
.rdata$r:00006004                 ;org 6004h
.rdata$r:00006004 ; COMDAT (pick any)
.rdata$r:00006004                 public ??_R4_Generic_error_category@std@@6B@
.rdata$r:00006004 ; const std::_Generic_error_category::`RTTI Complete Object Locator'
.rdata$r:00006004 ??_R4_Generic_error_category@std@@6B@ db    0
.rdata$r:00006004                                         ; DATA XREF: .rdata:00005A0Co
.rdata$r:00006005                 db    0
.rdata$r:00006006                 db    0
.rdata$r:00006007                 db    0
.rdata$r:00006008                 db    0
.rdata$r:00006009                 db    0
.rdata$r:0000600A                 db    0
.rdata$r:0000600B                 db    0
.rdata$r:0000600C                 db    0
.rdata$r:0000600D                 db    0
.rdata$r:0000600E                 db    0
.rdata$r:0000600F                 db    0
.rdata$r:00006010                 dd offset ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00006014                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006014 _rdata$r        ends
.rdata$r:00006014
.data$r:00006018 ; ===========================================================================
.data$r:00006018
.data$r:00006018 ; Segment type: Pure data
.data$r:00006018 ; Segment permissions: Read/Write
.data$r:00006018 _data$r         segment dword public 'DATA' use32
.data$r:00006018                 assume cs:_data$r
.data$r:00006018                 ;org 6018h
.data$r:00006018 ; COMDAT (pick any)
.data$r:00006018                 public ??_R0?AV_Generic_error_category@std@@@8
.data$r:00006018 ; class std::_Generic_error_category `RTTI Type Descriptor'
.data$r:00006018 ??_R0?AV_Generic_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00006018                                         ; DATA XREF: .rdata$r:00006010o
.data$r:00006018                                         ; .rdata$r:std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00006018                                         ; const type_info::`vftable'
.data$r:0000601C                 align 10h
.data$r:00006020 a_?av_generic_e db '.?AV_Generic_error_category@std@@',0
.data$r:00006042                 align 4
.data$r:00006042 _data$r         ends
.data$r:00006042
.rdata$r:00006044 ; ===========================================================================
.rdata$r:00006044
.rdata$r:00006044 ; Segment type: Pure data
.rdata$r:00006044 ; Segment permissions: Read
.rdata$r:00006044 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006044                 assume cs:_rdata$r
.rdata$r:00006044                 ;org 6044h
.rdata$r:00006044 ; COMDAT (pick any)
.rdata$r:00006044                 public ??_R3_Generic_error_category@std@@8
.rdata$r:00006044 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006044 ??_R3_Generic_error_category@std@@8 db    0
.rdata$r:00006044                                         ; DATA XREF: .rdata$r:00006014o
.rdata$r:00006044                                         ; .rdata$r:00006078o
.rdata$r:00006045                 db    0
.rdata$r:00006046                 db    0
.rdata$r:00006047                 db    0
.rdata$r:00006048                 db    0
.rdata$r:00006049                 db    0
.rdata$r:0000604A                 db    0
.rdata$r:0000604B                 db    0
.rdata$r:0000604C                 db    2
.rdata$r:0000604D                 db    0
.rdata$r:0000604E                 db    0
.rdata$r:0000604F                 db    0
.rdata$r:00006050                 dd offset ??_R2_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00006050 _rdata$r        ends
.rdata$r:00006050
.rdata$r:00006054 ; ===========================================================================
.rdata$r:00006054
.rdata$r:00006054 ; Segment type: Pure data
.rdata$r:00006054 ; Segment permissions: Read
.rdata$r:00006054 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006054                 assume cs:_rdata$r
.rdata$r:00006054                 ;org 6054h
.rdata$r:00006054 ; COMDAT (pick any)
.rdata$r:00006054                 public ??_R2_Generic_error_category@std@@8
.rdata$r:00006054 ; std::_Generic_error_category::`RTTI Base Class Array'
.rdata$r:00006054 ??_R2_Generic_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00006054                                         ; DATA XREF: .rdata$r:00006050o
.rdata$r:00006054                                         ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006058                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000605C                 db    0
.rdata$r:0000605D                 align 10h
.rdata$r:0000605D _rdata$r        ends
.rdata$r:0000605D
.rdata$r:00006060 ; ===========================================================================
.rdata$r:00006060
.rdata$r:00006060 ; Segment type: Pure data
.rdata$r:00006060 ; Segment permissions: Read
.rdata$r:00006060 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006060                 assume cs:_rdata$r
.rdata$r:00006060                 ;org 6060h
.rdata$r:00006060 ; COMDAT (pick any)
.rdata$r:00006060                 public ??_R1A@?0A@EA@_Generic_error_category@std@@8
.rdata$r:00006060 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006060 ??_R1A@?0A@EA@_Generic_error_category@std@@8 dd offset ??_R0?AV_Generic_error_category@std@@@8
.rdata$r:00006060                                         ; DATA XREF: .rdata$r:std::_Generic_error_category::`RTTI Base Class Array'o
.rdata$r:00006060                                         ; .rdata$r:000060D0o ...
.rdata$r:00006060                                         ; std::_Generic_error_category `RTTI Type Descriptor'
.rdata$r:00006064                 db    1
.rdata$r:00006065                 db    0
.rdata$r:00006066                 db    0
.rdata$r:00006067                 db    0
.rdata$r:00006068                 db    0
.rdata$r:00006069                 db    0
.rdata$r:0000606A                 db    0
.rdata$r:0000606B                 db    0
.rdata$r:0000606C                 db 0FFh
.rdata$r:0000606D                 db 0FFh
.rdata$r:0000606E                 db 0FFh
.rdata$r:0000606F                 db 0FFh
.rdata$r:00006070                 db    0
.rdata$r:00006071                 db    0
.rdata$r:00006072                 db    0
.rdata$r:00006073                 db    0
.rdata$r:00006074                 db  40h ; @
.rdata$r:00006075                 db    0
.rdata$r:00006076                 db    0
.rdata$r:00006077                 db    0
.rdata$r:00006078                 dd offset ??_R3_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006078 _rdata$r        ends
.rdata$r:00006078
.rdata$r:0000607C ; ===========================================================================
.rdata$r:0000607C
.rdata$r:0000607C ; Segment type: Pure data
.rdata$r:0000607C ; Segment permissions: Read
.rdata$r:0000607C _rdata$r        segment dword public 'DATA' use32
.rdata$r:0000607C                 assume cs:_rdata$r
.rdata$r:0000607C                 ;org 607Ch
.rdata$r:0000607C ; COMDAT (pick any)
.rdata$r:0000607C                 public ??_R4_Iostream_error_category@std@@6B@
.rdata$r:0000607C ; const std::_Iostream_error_category::`RTTI Complete Object Locator'
.rdata$r:0000607C ??_R4_Iostream_error_category@std@@6B@ db    0
.rdata$r:0000607C                                         ; DATA XREF: .rdata:00005A40o
.rdata$r:0000607D                 db    0
.rdata$r:0000607E                 db    0
.rdata$r:0000607F                 db    0
.rdata$r:00006080                 db    0
.rdata$r:00006081                 db    0
.rdata$r:00006082                 db    0
.rdata$r:00006083                 db    0
.rdata$r:00006084                 db    0
.rdata$r:00006085                 db    0
.rdata$r:00006086                 db    0
.rdata$r:00006087                 db    0
.rdata$r:00006088                 dd offset ??_R0?AV_Iostream_error_category@std@@@8 ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:0000608C                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:0000608C _rdata$r        ends
.rdata$r:0000608C
.data$r:00006090 ; ===========================================================================
.data$r:00006090
.data$r:00006090 ; Segment type: Pure data
.data$r:00006090 ; Segment permissions: Read/Write
.data$r:00006090 _data$r         segment dword public 'DATA' use32
.data$r:00006090                 assume cs:_data$r
.data$r:00006090                 ;org 6090h
.data$r:00006090 ; COMDAT (pick any)
.data$r:00006090                 public ??_R0?AV_Iostream_error_category@std@@@8
.data$r:00006090 ; class std::_Iostream_error_category `RTTI Type Descriptor'
.data$r:00006090 ??_R0?AV_Iostream_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:00006090                                         ; DATA XREF: .rdata$r:00006088o
.data$r:00006090                                         ; .rdata$r:std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:00006090                                         ; const type_info::`vftable'
.data$r:00006094                 align 8
.data$r:00006098 a_?av_iostream_ db '.?AV_Iostream_error_category@std@@',0
.data$r:000060BB                 align 4
.data$r:000060BB _data$r         ends
.data$r:000060BB
.rdata$r:000060BC ; ===========================================================================
.rdata$r:000060BC
.rdata$r:000060BC ; Segment type: Pure data
.rdata$r:000060BC ; Segment permissions: Read
.rdata$r:000060BC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000060BC                 assume cs:_rdata$r
.rdata$r:000060BC                 ;org 60BCh
.rdata$r:000060BC ; COMDAT (pick any)
.rdata$r:000060BC                 public ??_R3_Iostream_error_category@std@@8
.rdata$r:000060BC ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000060BC ??_R3_Iostream_error_category@std@@8 db    0
.rdata$r:000060BC                                         ; DATA XREF: .rdata$r:0000608Co
.rdata$r:000060BC                                         ; .rdata$r:000060F4o
.rdata$r:000060BD                 db    0
.rdata$r:000060BE                 db    0
.rdata$r:000060BF                 db    0
.rdata$r:000060C0                 db    0
.rdata$r:000060C1                 db    0
.rdata$r:000060C2                 db    0
.rdata$r:000060C3                 db    0
.rdata$r:000060C4                 db    3
.rdata$r:000060C5                 db    0
.rdata$r:000060C6                 db    0
.rdata$r:000060C7                 db    0
.rdata$r:000060C8                 dd offset ??_R2_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000060C8 _rdata$r        ends
.rdata$r:000060C8
.rdata$r:000060CC ; ===========================================================================
.rdata$r:000060CC
.rdata$r:000060CC ; Segment type: Pure data
.rdata$r:000060CC ; Segment permissions: Read
.rdata$r:000060CC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000060CC                 assume cs:_rdata$r
.rdata$r:000060CC                 ;org 60CCh
.rdata$r:000060CC ; COMDAT (pick any)
.rdata$r:000060CC                 public ??_R2_Iostream_error_category@std@@8
.rdata$r:000060CC ; std::_Iostream_error_category::`RTTI Base Class Array'
.rdata$r:000060CC ??_R2_Iostream_error_category@std@@8 dd offset ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000060CC                                         ; DATA XREF: .rdata$r:000060C8o
.rdata$r:000060CC                                         ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000060D0                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000060D4                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:000060D8                 db    0
.rdata$r:000060D9                 align 4
.rdata$r:000060D9 _rdata$r        ends
.rdata$r:000060D9
.rdata$r:000060DC ; ===========================================================================
.rdata$r:000060DC
.rdata$r:000060DC ; Segment type: Pure data
.rdata$r:000060DC ; Segment permissions: Read
.rdata$r:000060DC _rdata$r        segment dword public 'DATA' use32
.rdata$r:000060DC                 assume cs:_rdata$r
.rdata$r:000060DC                 ;org 60DCh
.rdata$r:000060DC ; COMDAT (pick any)
.rdata$r:000060DC                 public ??_R1A@?0A@EA@_Iostream_error_category@std@@8
.rdata$r:000060DC ; std::_Iostream_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:000060DC ??_R1A@?0A@EA@_Iostream_error_category@std@@8 dd offset ??_R0?AV_Iostream_error_category@std@@@8
.rdata$r:000060DC                                         ; DATA XREF: .rdata$r:std::_Iostream_error_category::`RTTI Base Class Array'o
.rdata$r:000060DC                                         ; std::_Iostream_error_category `RTTI Type Descriptor'
.rdata$r:000060E0                 db    2
.rdata$r:000060E1                 db    0
.rdata$r:000060E2                 db    0
.rdata$r:000060E3                 db    0
.rdata$r:000060E4                 db    0
.rdata$r:000060E5                 db    0
.rdata$r:000060E6                 db    0
.rdata$r:000060E7                 db    0
.rdata$r:000060E8                 db 0FFh
.rdata$r:000060E9                 db 0FFh
.rdata$r:000060EA                 db 0FFh
.rdata$r:000060EB                 db 0FFh
.rdata$r:000060EC                 db    0
.rdata$r:000060ED                 db    0
.rdata$r:000060EE                 db    0
.rdata$r:000060EF                 db    0
.rdata$r:000060F0                 db  40h ; @
.rdata$r:000060F1                 db    0
.rdata$r:000060F2                 db    0
.rdata$r:000060F3                 db    0
.rdata$r:000060F4                 dd offset ??_R3_Iostream_error_category@std@@8 ; std::_Iostream_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:000060F4 _rdata$r        ends
.rdata$r:000060F4
.rdata$r:000060F8 ; ===========================================================================
.rdata$r:000060F8
.rdata$r:000060F8 ; Segment type: Pure data
.rdata$r:000060F8 ; Segment permissions: Read
.rdata$r:000060F8 _rdata$r        segment dword public 'DATA' use32
.rdata$r:000060F8                 assume cs:_rdata$r
.rdata$r:000060F8                 ;org 60F8h
.rdata$r:000060F8 ; COMDAT (pick any)
.rdata$r:000060F8                 public ??_R4_System_error_category@std@@6B@
.rdata$r:000060F8 ; const std::_System_error_category::`RTTI Complete Object Locator'
.rdata$r:000060F8 ??_R4_System_error_category@std@@6B@ db    0 ; DATA XREF: .rdata:00005A80o
.rdata$r:000060F9                 db    0
.rdata$r:000060FA                 db    0
.rdata$r:000060FB                 db    0
.rdata$r:000060FC                 db    0
.rdata$r:000060FD                 db    0
.rdata$r:000060FE                 db    0
.rdata$r:000060FF                 db    0
.rdata$r:00006100                 db    0
.rdata$r:00006101                 db    0
.rdata$r:00006102                 db    0
.rdata$r:00006103                 db    0
.rdata$r:00006104                 dd offset ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:00006108                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006108 _rdata$r        ends
.rdata$r:00006108
.data$r:0000610C ; ===========================================================================
.data$r:0000610C
.data$r:0000610C ; Segment type: Pure data
.data$r:0000610C ; Segment permissions: Read/Write
.data$r:0000610C _data$r         segment dword public 'DATA' use32
.data$r:0000610C                 assume cs:_data$r
.data$r:0000610C                 ;org 610Ch
.data$r:0000610C ; COMDAT (pick any)
.data$r:0000610C                 public ??_R0?AV_System_error_category@std@@@8
.data$r:0000610C ; class std::_System_error_category `RTTI Type Descriptor'
.data$r:0000610C ??_R0?AV_System_error_category@std@@@8 dd offset ??_7type_info@@6B@
.data$r:0000610C                                         ; DATA XREF: .rdata$r:00006104o
.data$r:0000610C                                         ; .rdata$r:std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'o
.data$r:0000610C                                         ; const type_info::`vftable'
.data$r:00006110                 db    0
.data$r:00006111                 db    0
.data$r:00006112                 db    0
.data$r:00006113                 db    0
.data$r:00006114                 db  2Eh ; .
.data$r:00006115                 db  3Fh ; ?
.data$r:00006116                 db  41h ; A
.data$r:00006117                 db  56h ; V
.data$r:00006118                 db  5Fh ; _
.data$r:00006119                 db  53h ; S
.data$r:0000611A                 db  79h ; y
.data$r:0000611B                 db  73h ; s
.data$r:0000611C                 db  74h ; t
.data$r:0000611D                 db  65h ; e
.data$r:0000611E                 db  6Dh ; m
.data$r:0000611F                 db  5Fh ; _
.data$r:00006120                 db  65h ; e
.data$r:00006121                 db  72h ; r
.data$r:00006122                 db  72h ; r
.data$r:00006123                 db  6Fh ; o
.data$r:00006124                 db  72h ; r
.data$r:00006125                 db  5Fh ; _
.data$r:00006126                 db  63h ; c
.data$r:00006127                 db  61h ; a
.data$r:00006128                 db  74h ; t
.data$r:00006129                 db  65h ; e
.data$r:0000612A                 db  67h ; g
.data$r:0000612B                 db  6Fh ; o
.data$r:0000612C                 db  72h ; r
.data$r:0000612D                 db  79h ; y
.data$r:0000612E                 db  40h ; @
.data$r:0000612F                 db  73h ; s
.data$r:00006130                 db  74h ; t
.data$r:00006131                 db  64h ; d
.data$r:00006132                 db  40h ; @
.data$r:00006133                 db  40h ; @
.data$r:00006134                 db    0
.data$r:00006135                 align 4
.data$r:00006135 _data$r         ends
.data$r:00006135
.rdata$r:00006138 ; ===========================================================================
.rdata$r:00006138
.rdata$r:00006138 ; Segment type: Pure data
.rdata$r:00006138 ; Segment permissions: Read
.rdata$r:00006138 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006138                 assume cs:_rdata$r
.rdata$r:00006138                 ;org 6138h
.rdata$r:00006138 ; COMDAT (pick any)
.rdata$r:00006138                 public ??_R3_System_error_category@std@@8
.rdata$r:00006138 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006138 ??_R3_System_error_category@std@@8 db    0 ; DATA XREF: .rdata$r:00006108o
.rdata$r:00006138                                         ; .rdata$r:00006170o
.rdata$r:00006139                 db    0
.rdata$r:0000613A                 db    0
.rdata$r:0000613B                 db    0
.rdata$r:0000613C                 db    0
.rdata$r:0000613D                 db    0
.rdata$r:0000613E                 db    0
.rdata$r:0000613F                 db    0
.rdata$r:00006140                 db    3
.rdata$r:00006141                 db    0
.rdata$r:00006142                 db    0
.rdata$r:00006143                 db    0
.rdata$r:00006144                 dd offset ??_R2_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00006144 _rdata$r        ends
.rdata$r:00006144
.rdata$r:00006148 ; ===========================================================================
.rdata$r:00006148
.rdata$r:00006148 ; Segment type: Pure data
.rdata$r:00006148 ; Segment permissions: Read
.rdata$r:00006148 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006148                 assume cs:_rdata$r
.rdata$r:00006148                 ;org 6148h
.rdata$r:00006148 ; COMDAT (pick any)
.rdata$r:00006148                 public ??_R2_System_error_category@std@@8
.rdata$r:00006148 ; std::_System_error_category::`RTTI Base Class Array'
.rdata$r:00006148 ??_R2_System_error_category@std@@8 dd offset ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00006148                                         ; DATA XREF: .rdata$r:00006144o
.rdata$r:00006148                                         ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:0000614C                 dd offset ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006150                 dd offset ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
.rdata$r:00006154                 db    0
.rdata$r:00006155                 align 4
.rdata$r:00006155 _rdata$r        ends
.rdata$r:00006155
.rdata$r:00006158 ; ===========================================================================
.rdata$r:00006158
.rdata$r:00006158 ; Segment type: Pure data
.rdata$r:00006158 ; Segment permissions: Read
.rdata$r:00006158 _rdata$r        segment dword public 'DATA' use32
.rdata$r:00006158                 assume cs:_rdata$r
.rdata$r:00006158                 ;org 6158h
.rdata$r:00006158 ; COMDAT (pick any)
.rdata$r:00006158                 public ??_R1A@?0A@EA@_System_error_category@std@@8
.rdata$r:00006158 ; std::_System_error_category::`RTTI Base Class Descriptor at (0, -1, 0, 64)'
.rdata$r:00006158 ??_R1A@?0A@EA@_System_error_category@std@@8 dd offset ??_R0?AV_System_error_category@std@@@8
.rdata$r:00006158                                         ; DATA XREF: .rdata$r:std::_System_error_category::`RTTI Base Class Array'o
.rdata$r:00006158                                         ; std::_System_error_category `RTTI Type Descriptor'
.rdata$r:0000615C                 db    2
.rdata$r:0000615D                 db    0
.rdata$r:0000615E                 db    0
.rdata$r:0000615F                 db    0
.rdata$r:00006160                 db    0
.rdata$r:00006161                 db    0
.rdata$r:00006162                 db    0
.rdata$r:00006163                 db    0
.rdata$r:00006164                 db 0FFh
.rdata$r:00006165                 db 0FFh
.rdata$r:00006166                 db 0FFh
.rdata$r:00006167                 db 0FFh
.rdata$r:00006168                 db    0
.rdata$r:00006169                 db    0
.rdata$r:0000616A                 db    0
.rdata$r:0000616B                 db    0
.rdata$r:0000616C                 db  40h ; @
.rdata$r:0000616D                 db    0
.rdata$r:0000616E                 db    0
.rdata$r:0000616F                 db    0
.rdata$r:00006170                 dd offset ??_R3_System_error_category@std@@8 ; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
.rdata$r:00006170 _rdata$r        ends
.rdata$r:00006170
.CRT$XCU:00006174 ; ===========================================================================
.CRT$XCU:00006174
.CRT$XCU:00006174 ; Segment type: Pure data
.CRT$XCU:00006174 ; Segment permissions: Read
.CRT$XCU:00006174 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006174                 assume cs:_CRT$XCU
.CRT$XCU:00006174                 ;org 6174h
.CRT$XCU:00006174 _piecewise_construct$initializer$ dd offset ??__Epiecewise_construct@std@@YAXXZ ; std::`dynamic initializer for 'piecewise_construct''(void)
.CRT$XCU:00006178 _allocator_arg$initializer$ dd offset ??__Eallocator_arg@std@@YAXXZ ; std::`dynamic initializer for 'allocator_arg''(void)
.CRT$XCU:00006178 _CRT$XCU        ends
.CRT$XCU:00006178
.CRT$XCU:0000617C ; ===========================================================================
.CRT$XCU:0000617C
.CRT$XCU:0000617C ; Segment type: Pure data
.CRT$XCU:0000617C ; Segment permissions: Read
.CRT$XCU:0000617C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000617C                 assume cs:_CRT$XCU
.CRT$XCU:0000617C                 ;org 617Ch
.CRT$XCU:0000617C ; COMDAT (pick associative to section at 5AA4)
.CRT$XCU:0000617C ; public: static void (__cdecl *std::_Error_objects<int>::_Generic_object$initializer$)(void)
.CRT$XCU:0000617C ?_Generic_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Generic_object@?$_Error_objects@H@std@@2V_Generic_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)
.CRT$XCU:0000617C _CRT$XCU        ends
.CRT$XCU:0000617C
.CRT$XCU:00006180 ; ===========================================================================
.CRT$XCU:00006180
.CRT$XCU:00006180 ; Segment type: Pure data
.CRT$XCU:00006180 ; Segment permissions: Read
.CRT$XCU:00006180 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006180                 assume cs:_CRT$XCU
.CRT$XCU:00006180                 ;org 6180h
.CRT$XCU:00006180 ; COMDAT (pick associative to section at 5AA8)
.CRT$XCU:00006180 ; public: static void (__cdecl *std::_Error_objects<int>::_Iostream_object$initializer$)(void)
.CRT$XCU:00006180 ?_Iostream_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_Iostream_object@?$_Error_objects@H@std@@2V_Iostream_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)
.CRT$XCU:00006180 _CRT$XCU        ends
.CRT$XCU:00006180
.CRT$XCU:00006184 ; ===========================================================================
.CRT$XCU:00006184
.CRT$XCU:00006184 ; Segment type: Pure data
.CRT$XCU:00006184 ; Segment permissions: Read
.CRT$XCU:00006184 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006184                 assume cs:_CRT$XCU
.CRT$XCU:00006184                 ;org 6184h
.CRT$XCU:00006184 ; COMDAT (pick associative to section at 5AAC)
.CRT$XCU:00006184 ; public: static void (__cdecl *std::_Error_objects<int>::_System_object$initializer$)(void)
.CRT$XCU:00006184 ?_System_object$initializer$@?$_Error_objects@H@std@@2P6AXXZA dd offset ??__E?_System_object@?$_Error_objects@H@std@@2V_System_error_category@2@A@@YAXXZ ; `dynamic initializer for 'std::_System_error_category std::_Error_objects<int>::_System_object''(void)
.CRT$XCU:00006184 _CRT$XCU        ends
.CRT$XCU:00006184
.CRT$XCU:00006188 ; ===========================================================================
.CRT$XCU:00006188
.CRT$XCU:00006188 ; Segment type: Pure data
.CRT$XCU:00006188 ; Segment permissions: Read
.CRT$XCU:00006188 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006188                 assume cs:_CRT$XCU
.CRT$XCU:00006188                 ;org 6188h
.CRT$XCU:00006188 ; COMDAT (pick associative to section at 5AB0)
.CRT$XCU:00006188 ; public: static void (__cdecl *std::num_put<char, class std::back_insert_iterator<class std::basic_string<char, struct std::char_traits<char>, class std::allocator<char>>>>::id$initializer$)(void)
.CRT$XCU:00006188 ?id$initializer$@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@DV?$back_insert_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<char,std::back_insert_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char>>>>::id''(void)
.CRT$XCU:00006188 _CRT$XCU        ends
.CRT$XCU:00006188
.CRT$XCU:0000618C ; ===========================================================================
.CRT$XCU:0000618C
.CRT$XCU:0000618C ; Segment type: Pure data
.CRT$XCU:0000618C ; Segment permissions: Read
.CRT$XCU:0000618C _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:0000618C                 assume cs:_CRT$XCU
.CRT$XCU:0000618C                 ;org 618Ch
.CRT$XCU:0000618C ; COMDAT (pick associative to section at 5AB4)
.CRT$XCU:0000618C ; public: static void (__cdecl *std::num_put<wchar_t, class std::back_insert_iterator<class std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>>>::id$initializer$)(void)
.CRT$XCU:0000618C ?id$initializer$@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2P6AXXZA dd offset ??__E?id@?$num_put@_WV?$back_insert_iterator@V?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@@std@@@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::num_put<wchar_t,std::back_insert_iterator<std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t>>>>::id''(void)
.CRT$XCU:0000618C _CRT$XCU        ends
.CRT$XCU:0000618C
.CRT$XCU:00006190 ; ===========================================================================
.CRT$XCU:00006190
.CRT$XCU:00006190 ; Segment type: Pure data
.CRT$XCU:00006190 ; Segment permissions: Read
.CRT$XCU:00006190 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006190                 assume cs:_CRT$XCU
.CRT$XCU:00006190                 ;org 6190h
.CRT$XCU:00006190 ; COMDAT (pick associative to section at 5BC8)
.CRT$XCU:00006190 ; public: static void (__cdecl *std::numpunct<char>::id$initializer$)(void)
.CRT$XCU:00006190 ?id$initializer$@?$numpunct@D@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@D@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<char>::id''(void)
.CRT$XCU:00006190 _CRT$XCU        ends
.CRT$XCU:00006190
.CRT$XCU:00006194 ; ===========================================================================
.CRT$XCU:00006194
.CRT$XCU:00006194 ; Segment type: Pure data
.CRT$XCU:00006194 ; Segment permissions: Read
.CRT$XCU:00006194 _CRT$XCU        segment dword public 'DATA' use32
.CRT$XCU:00006194                 assume cs:_CRT$XCU
.CRT$XCU:00006194                 ;org 6194h
.CRT$XCU:00006194 ; COMDAT (pick associative to section at 5BCC)
.CRT$XCU:00006194 ; public: static void (__cdecl *std::numpunct<wchar_t>::id$initializer$)(void)
.CRT$XCU:00006194 ?id$initializer$@?$numpunct@_W@std@@2P6AXXZA dd offset ??__E?id@?$numpunct@_W@std@@2V0locale@2@A@@YAXXZ ; `dynamic initializer for 'std::locale::id std::numpunct<wchar_t>::id''(void)
.CRT$XCU:00006194 _CRT$XCU        ends
.CRT$XCU:00006194
UNDEF:000061A0 ; ===========================================================================
UNDEF:000061A0
UNDEF:000061A0 ; Segment type: Externs
UNDEF:000061A0 ; UNDEF
UNDEF:000061A0                 extrn __purecall:near   ; DATA XREF: .rdata:000059F8o
UNDEF:000061A0                                         ; .rdata:000059FCo
UNDEF:000061A4 ; void *__cdecl operator new(unsigned int)
UNDEF:000061A4                 extrn ??2@YAPAXI@Z:near ; CODE XREF: std::_Allocate<char>(uint,char *)+1Dp
UNDEF:000061A4                                         ; std::_Allocate<DockingCont *>(uint,DockingCont * *)+23p ...
UNDEF:000061A8 ; void __cdecl operator delete(void *)
UNDEF:000061A8                 extrn ??3@YAXPAX@Z:near ; CODE XREF: Gripper::`scalar deleting destructor'(uint)+1Bp
UNDEF:000061A8                                         ; std::_Generic_error_category::`scalar deleting destructor'(uint)+1Bp ...
UNDEF:000061AC ; int __cdecl atexit(void (__cdecl *)())
UNDEF:000061AC                 extrn _atexit:near      ; CODE XREF: `dynamic initializer for 'std::_Generic_error_category std::_Error_objects<int>::_Generic_object''(void)+12p
UNDEF:000061AC                                         ; `dynamic initializer for 'std::_Iostream_error_category std::_Error_objects<int>::_Iostream_object''(void)+12p ...
UNDEF:000061B0                 extrn __invalid_parameter:near
UNDEF:000061B0                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+74p
UNDEF:000061B4 ; void *__cdecl memcpy(void *Dst, const void *Src, size_t Size)
UNDEF:000061B4                 extrn _memcpy:near      ; CODE XREF: std::char_traits<char>::copy(char *,char const *,uint)+1Ep
UNDEF:000061B8 ; void *__cdecl memset(void *Dst, int Val, size_t Size)
UNDEF:000061B8                 extrn _memset:near      ; CODE XREF: Gripper::Gripper(void)+CDp
UNDEF:000061B8                                         ; Gripper::Gripper(void)+E2p ...
UNDEF:000061BC ; size_t __cdecl strlen(const char *Str)
UNDEF:000061BC                 extrn _strlen:near      ; CODE XREF: std::char_traits<char>::length(char const *)+1Bp
UNDEF:000061C0 ; void *__cdecl memmove(void *Dst, const void *Src, size_t Size)
UNDEF:000061C0                 extrn _memmove:near     ; CODE XREF: std::_Uninit_copy<DockingCont * const,DockingCont *>(DockingCont * const *,DockingCont * const *,DockingCont * *,std::_Wrap_alloc<std::allocator<DockingCont *>> &,std::_Scalar_ptr_iterator_tag)+4Fp
UNDEF:000061C0                                         ; std::char_traits<char>::move(char *,char const *,uint)+1Ep
UNDEF:000061C4 ; DWORD __stdcall GetLastError()
UNDEF:000061C4                 extrn __imp__GetLastError@0:near
UNDEF:000061C4                                         ; CODE XREF: Gripper::create(void)+B2p
UNDEF:000061C4                                         ; Gripper::create(void)+128p
UNDEF:000061C4                                         ; DATA XREF: ...
UNDEF:000061C8 ; BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop)
UNDEF:000061C8                 extrn __imp__BitBlt@36:near
UNDEF:000061C8                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+30Bp
UNDEF:000061C8                                         ; Gripper::drawRectangle(tagPOINT const *)+3DBp
UNDEF:000061C8                                         ; DATA XREF: ...
UNDEF:000061CC ; HBITMAP __stdcall CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void *lpBits)
UNDEF:000061CC                 extrn __imp__CreateBitmap@20:near
UNDEF:000061CC                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+C7p
UNDEF:000061CC                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+C7r
UNDEF:000061D0 ; HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy)
UNDEF:000061D0                 extrn __imp__CreateCompatibleBitmap@12:near
UNDEF:000061D0                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+285p
UNDEF:000061D0                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+285r
UNDEF:000061D4 ; HDC __stdcall CreateCompatibleDC(HDC hdc)
UNDEF:000061D4                 extrn __imp__CreateCompatibleDC@4:near
UNDEF:000061D4                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+26Ap
UNDEF:000061D4                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+26Ar
UNDEF:000061D8 ; HBRUSH __stdcall CreatePatternBrush(HBITMAP hbm)
UNDEF:000061D8                 extrn __imp__CreatePatternBrush@4:near
UNDEF:000061D8                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+ECp
UNDEF:000061D8                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+ECr
UNDEF:000061DC ; BOOL __stdcall DeleteDC(HDC hdc)
UNDEF:000061DC                 extrn __imp__DeleteDC@4:near
UNDEF:000061DC                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+40Bp
UNDEF:000061DC                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+40Br
UNDEF:000061E0 ; BOOL __stdcall DeleteObject(HGDIOBJ ho)
UNDEF:000061E0                 extrn __imp__DeleteObject@4:near
UNDEF:000061E0                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+401p
UNDEF:000061E0                                         ; Gripper::~Gripper(void)+43p ...
UNDEF:000061E4 ; BOOL __stdcall PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop)
UNDEF:000061E4                 extrn __imp__PatBlt@24:near
UNDEF:000061E4                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+333p
UNDEF:000061E4                                         ; Gripper::drawRectangle(tagPOINT const *)+35Ep ...
UNDEF:000061E8 ; HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h)
UNDEF:000061E8                 extrn __imp__SelectObject@8:near
UNDEF:000061E8                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+296p
UNDEF:000061E8                                         ; Gripper::drawRectangle(tagPOINT const *)+2DBp ...
UNDEF:000061EC ; BOOL __stdcall SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt)
UNDEF:000061EC                 extrn __imp__SetBrushOrgEx@16:near
UNDEF:000061EC                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+2C7p
UNDEF:000061EC                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+2C7r
UNDEF:000061F0 ; int _wsprintfW(LPWSTR, LPCWSTR, ...)
UNDEF:000061F0                 extrn __imp__wsprintfW:near
UNDEF:000061F0                                         ; CODE XREF: Gripper::create(void)+D1p
UNDEF:000061F0                                         ; Gripper::create(void)+147p
UNDEF:000061F0                                         ; DATA XREF: ...
UNDEF:000061F4 ; LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000061F4                 extrn __imp__SendMessageW@16:near
UNDEF:000061F4                                         ; CODE XREF: Gripper::onButtonUp(void)+1B1p
UNDEF:000061F4                                         ; Gripper::onButtonUp(void)+24Dp ...
UNDEF:000061F8 ; BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000061F8                 extrn __imp__PostMessageW@16:near
UNDEF:000061F8                                         ; CODE XREF: hookProcKeyboard(int,uint,long)+1Ep
UNDEF:000061F8                                         ; DATA XREF: hookProcKeyboard(int,uint,long)+1Er
UNDEF:000061FC ; LRESULT __stdcall DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
UNDEF:000061FC                 extrn __imp__DefWindowProcW@16:near
UNDEF:000061FC                                         ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+6Bp
UNDEF:000061FC                                         ; Gripper::runProc(uint,uint,long)+1ADp
UNDEF:000061FC                                         ; DATA XREF: ...
UNDEF:00006200 ; ATOM __stdcall RegisterClassW(const WNDCLASSW *lpWndClass)
UNDEF:00006200                 extrn __imp__RegisterClassW@4:near
UNDEF:00006200                                         ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+8Ep
UNDEF:00006200                                         ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+8Er
UNDEF:00006204 ; HWND __stdcall CreateWindowExW(DWORD dwExStyle, LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
UNDEF:00006204                 extrn __imp__CreateWindowExW@48:near
UNDEF:00006204                                         ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+F0p
UNDEF:00006204                                         ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+F0r
UNDEF:00006208 ; BOOL __stdcall DestroyWindow(HWND hWnd)
UNDEF:00006208                 extrn __imp__DestroyWindow@4:near
UNDEF:00006208                                         ; CODE XREF: Gripper::runProc(uint,uint,long)+C4p
UNDEF:00006208                                         ; Gripper::runProc(uint,uint,long)+134p
UNDEF:00006208                                         ; DATA XREF: ...
UNDEF:0000620C ; BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint)
UNDEF:0000620C                 extrn __imp__MoveWindow@24:near
UNDEF:0000620C                                         ; CODE XREF: Gripper::onButtonUp(void)+238p
UNDEF:0000620C                                         ; DATA XREF: Gripper::onButtonUp(void)+238r
UNDEF:00006210 ; BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags)
UNDEF:00006210                 extrn __imp__SetWindowPos@28:near
UNDEF:00006210                                         ; CODE XREF: Gripper::create(void)+64p
UNDEF:00006210                                         ; Gripper::runProc(uint,uint,long)+161p
UNDEF:00006210                                         ; DATA XREF: ...
UNDEF:00006214 ; BOOL __stdcall IsWindowVisible(HWND hWnd)
UNDEF:00006214                 extrn __imp__IsWindowVisible@4:near
UNDEF:00006214                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+B3p
UNDEF:00006214                                         ; Gripper::contHitTest(tagPOINT)+19Dp
UNDEF:00006214                                         ; DATA XREF: ...
UNDEF:00006218 ; void __stdcall mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo)
UNDEF:00006218                 extrn __imp__mouse_event@20:near
UNDEF:00006218                                         ; CODE XREF: Gripper::runProc(uint,uint,long)+148p
UNDEF:00006218                                         ; DATA XREF: Gripper::runProc(uint,uint,long)+148r
UNDEF:0000621C ; HWND __stdcall SetCapture(HWND hWnd)
UNDEF:0000621C                 extrn __imp__SetCapture@4:near
UNDEF:0000621C                                         ; CODE XREF: Gripper::create(void)+74p
UNDEF:0000621C                                         ; DATA XREF: Gripper::create(void)+74r
UNDEF:00006220 ; BOOL __stdcall UpdateWindow(HWND hWnd)
UNDEF:00006220                 extrn __imp__UpdateWindow@4:near
UNDEF:00006220                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+3BBp
UNDEF:00006220                                         ; DATA XREF: Gripper::doTabReordering(tagPOINT)+3BBr
UNDEF:00006224 ; HDC __stdcall GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags)
UNDEF:00006224                 extrn __imp__GetDCEx@12:near
UNDEF:00006224                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+9Fp
UNDEF:00006224                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+9Fr
UNDEF:00006228 ; int __stdcall ReleaseDC(HWND hWnd, HDC hDC)
UNDEF:00006228                 extrn __imp__ReleaseDC@8:near
UNDEF:00006228                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+441p
UNDEF:00006228                                         ; Gripper::~Gripper(void)+27p
UNDEF:00006228                                         ; DATA XREF: ...
UNDEF:0000622C ; BOOL __stdcall LockWindowUpdate(HWND hWndLock)
UNDEF:0000622C                 extrn __imp__LockWindowUpdate@4:near
UNDEF:0000622C                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+7Bp
UNDEF:0000622C                                         ; Gripper::drawRectangle(tagPOINT const *)+419p ...
UNDEF:00006230 ; BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect)
UNDEF:00006230                 extrn __imp__GetWindowRect@8:near
UNDEF:00006230                                         ; CODE XREF: Gripper::create(void)+1AAp
UNDEF:00006230                                         ; Gripper::doTabReordering(tagPOINT)+DCp ...
UNDEF:00006234 ; int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType)
UNDEF:00006234                 extrn __imp__MessageBoxW@16:near
UNDEF:00006234                                         ; CODE XREF: Gripper::create(void)+EAp
UNDEF:00006234                                         ; Gripper::create(void)+160p
UNDEF:00006234                                         ; DATA XREF: ...
UNDEF:00006238 ; BOOL __stdcall GetCursorPos(LPPOINT lpPoint)
UNDEF:00006238                 extrn __imp__GetCursorPos@4:near
UNDEF:00006238                                         ; CODE XREF: Gripper::create(void)+16Dp
UNDEF:00006238                                         ; Gripper::runProc(uint,uint,long)+F4p ...
UNDEF:0000623C ; BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint)
UNDEF:0000623C                 extrn __imp__ScreenToClient@8:near
UNDEF:0000623C                                         ; CODE XREF: Gripper::create(void)+1E8p
UNDEF:0000623C                                         ; Gripper::doTabReordering(tagPOINT)+146p
UNDEF:0000623C                                         ; DATA XREF: ...
UNDEF:00006240 ; HWND __stdcall WindowFromPoint(POINT Point)
UNDEF:00006240                 extrn __imp__WindowFromPoint@8:near
UNDEF:00006240                                         ; CODE XREF: Gripper::contHitTest(tagPOINT)+4Ep
UNDEF:00006240                                         ; DATA XREF: Gripper::contHitTest(tagPOINT)+4Er
UNDEF:00006244 ; BOOL __stdcall PtInRect(const RECT *lprc, POINT pt)
UNDEF:00006244                 extrn __imp__PtInRect@12:near
UNDEF:00006244                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+EEp
UNDEF:00006244                                         ; Gripper::contHitTest(tagPOINT)+1E3p ...
UNDEF:00006248 ; LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex)
UNDEF:00006248                 extrn __imp__GetWindowLongW@8:near
UNDEF:00006248                                         ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+4Cp
UNDEF:00006248                                         ; DATA XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+4Cr
UNDEF:0000624C ; LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong)
UNDEF:0000624C                 extrn __imp__SetWindowLongW@12:near
UNDEF:0000624C                                         ; CODE XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+39p
UNDEF:0000624C                                         ; DATA XREF: Gripper::staticWinProc(HWND__ *,uint,uint,long)+39r
UNDEF:00006250 ; HWND __stdcall GetDesktopWindow()
UNDEF:00006250                 extrn __imp__GetDesktopWindow@0:near
UNDEF:00006250                                         ; CODE XREF: Gripper::drawRectangle(tagPOINT const *)+6Ep
UNDEF:00006250                                         ; DATA XREF: Gripper::drawRectangle(tagPOINT const *)+6Er
UNDEF:00006254 ; HHOOK __stdcall SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId)
UNDEF:00006254                 extrn __imp__SetWindowsHookExW@16:near
UNDEF:00006254                                         ; CODE XREF: Gripper::create(void)+9Ep
UNDEF:00006254                                         ; Gripper::create(void)+114p
UNDEF:00006254                                         ; DATA XREF: ...
UNDEF:00006258 ; BOOL __stdcall UnhookWindowsHookEx(HHOOK hhk)
UNDEF:00006258                 extrn __imp__UnhookWindowsHookEx@4:near
UNDEF:00006258                                         ; CODE XREF: Gripper::runProc(uint,uint,long)+8Ep
UNDEF:00006258                                         ; Gripper::runProc(uint,uint,long)+9Bp ...
UNDEF:0000625C ; LRESULT __stdcall CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam)
UNDEF:0000625C                 extrn __imp__CallNextHookEx@16:near
UNDEF:0000625C                                         ; CODE XREF: hookProcMouse(int,uint,long)+87p
UNDEF:0000625C                                         ; hookProcKeyboard(int,uint,long)+3Bp
UNDEF:0000625C                                         ; DATA XREF: ...
UNDEF:00006260 ; HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName)
UNDEF:00006260                 extrn __imp__LoadCursorW@8:near
UNDEF:00006260                                         ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+6Cp
UNDEF:00006260                                         ; DATA XREF: Gripper::startGrip(DockingCont *,DockingManager *)+6Cr
UNDEF:00006264 ; _DWORD __thiscall std::_Lockit::_Lockit(std::_Lockit *__hidden this, int)
UNDEF:00006264                 extrn ??0_Lockit@std@@QAE@H@Z:near
UNDEF:00006264                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+2Dp
UNDEF:00006264                                         ; std::_Iterator_base12::operator=(std::_Iterator_base12 const &)+55p ...
UNDEF:00006268 ; _DWORD __thiscall std::_Lockit::~_Lockit(std::_Lockit *__hidden this)
UNDEF:00006268                 extrn ??1_Lockit@std@@QAE@XZ:near
UNDEF:00006268                                         ; CODE XREF: std::_Iterator_base12::~_Iterator_base12(void)+4Bp
UNDEF:00006268                                         ; __unwindfunclet$??1_Iterator_base12@std@@QAE@XZ$0+3j ...
UNDEF:0000626C                 extrn __hypot:near      ; CODE XREF: _hypot+1Dp
UNDEF:00006270 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const char *const *)
UNDEF:00006270                 extrn ??0exception@std@@QAE@ABQBD@Z:near
UNDEF:00006270                                         ; CODE XREF: std::runtime_error::runtime_error(char const *)+2Dp
UNDEF:00006274 ; _DWORD __thiscall std::exception::exception(std::exception *__hidden this, const struct std::exception *)
UNDEF:00006274                 extrn ??0exception@std@@QAE@ABV01@@Z:near
UNDEF:00006274                                         ; CODE XREF: std::runtime_error::runtime_error(std::runtime_error const &)+2Dp
UNDEF:00006274                                         ; DATA XREF: .xdata$x:000059ECo
UNDEF:00006278 ; _DWORD __thiscall std::exception::~exception(std::exception *__hidden this)
UNDEF:00006278                 extrn ??1exception@std@@UAE@XZ:near
UNDEF:00006278                                         ; CODE XREF: __unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0+3j
UNDEF:00006278                                         ; __unwindfunclet$??0runtime_error@std@@QAE@PBD@Z$0+3j ...
UNDEF:0000627C ; public: virtual char const * __thiscall std::exception::what(void)const
UNDEF:0000627C                 extrn ?what@exception@std@@UBEPBDXZ:near
UNDEF:0000627C                                         ; DATA XREF: .rdata:0000595Co
UNDEF:00006280                 extrn __CrtDbgReportW:near
UNDEF:00006280                                         ; CODE XREF: std::vector<DockingCont *,std::allocator<DockingCont *>>::operator[](uint)+50p
UNDEF:00006284 ; void __cdecl std::_Debug_message(const wchar_t *, const wchar_t *, unsigned int)
UNDEF:00006284                 extrn ?_Debug_message@std@@YAXPB_W0I@Z:near
UNDEF:00006284                                         ; CODE XREF: std::_Debug_pointer<char>(char const *,wchar_t const *,uint)+16p
UNDEF:00006284                                         ; std::_Debug_pointer<DockingCont *>(DockingCont * *,wchar_t const *,uint)+16p ...
UNDEF:00006288 ; void __cdecl std::_Xbad_alloc()
UNDEF:00006288                 extrn ?_Xbad_alloc@std@@YAXXZ:near
UNDEF:00006288                                         ; CODE XREF: std::_Allocate<char>(uint,char *):loc_1EC2p
UNDEF:00006288                                         ; std::_Allocate<DockingCont *>(uint,DockingCont * *):loc_1F04p ...
UNDEF:0000628C ; void __cdecl std::_Xlength_error(const char *)
UNDEF:0000628C                 extrn ?_Xlength_error@std@@YAXPBD@Z:near
UNDEF:0000628C                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xlen(void)+Cp
UNDEF:0000628C                                         ; std::vector<DockingCont *,std::allocator<DockingCont *>>::_Xlen(void)+Cp
UNDEF:00006290 ; void __cdecl std::_Xout_of_range(const char *)
UNDEF:00006290                 extrn ?_Xout_of_range@std@@YAXPBD@Z:near
UNDEF:00006290                                         ; CODE XREF: std::basic_string<char,std::char_traits<char>,std::allocator<char>>::_Xran(void)+Cp
UNDEF:00006294 ; public: virtual void * __thiscall std::runtime_error::`vector deleting destructor'(unsigned int)
UNDEF:00006294                 extrn ??_Eruntime_error@std@@UAEPAXI@Z:near ; weak
UNDEF:00006294                                         ; DATA XREF: .rdata:const std::runtime_error::`vftable'o
UNDEF:00006298 ; public: virtual void * __thiscall std::error_category::`vector deleting destructor'(unsigned int)
UNDEF:00006298                 extrn ??_Eerror_category@std@@UAEPAXI@Z:near ; weak
UNDEF:00006298                                         ; DATA XREF: .rdata:const std::error_category::`vftable'o
UNDEF:0000629C ; const char *__cdecl std::_Syserror_map(int)
UNDEF:0000629C                 extrn ?_Syserror_map@std@@YAPBDH@Z:near
UNDEF:0000629C                                         ; CODE XREF: std::_System_error_category::default_error_condition(int)+Bp
UNDEF:0000629C                                         ; std::_Generic_error_category::message(int)+33p
UNDEF:000062A0 ; const char *__cdecl std::_Winerror_map(int)
UNDEF:000062A0                 extrn ?_Winerror_map@std@@YAPBDH@Z:near
UNDEF:000062A0                                         ; CODE XREF: std::_System_error_category::message(int)+33p
UNDEF:000062A4 ; public: virtual void * __thiscall std::_Generic_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000062A4                 extrn ??_E_Generic_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000062A4                                         ; DATA XREF: .rdata:const std::_Generic_error_category::`vftable'o
UNDEF:000062A8 ; public: virtual void * __thiscall std::_Iostream_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000062A8                 extrn ??_E_Iostream_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000062A8                                         ; DATA XREF: .rdata:const std::_Iostream_error_category::`vftable'o
UNDEF:000062AC ; public: virtual void * __thiscall std::_System_error_category::`vector deleting destructor'(unsigned int)
UNDEF:000062AC                 extrn ??_E_System_error_category@std@@UAEPAXI@Z:near ; weak
UNDEF:000062AC                                         ; DATA XREF: .rdata:const std::_System_error_category::`vftable'o
UNDEF:000062B0 ; void __cdecl ClientRectToScreenRect(HWND, struct tagRECT *)
UNDEF:000062B0                 extrn ?ClientRectToScreenRect@@YAXPAUHWND__@@PAUtagRECT@@@Z:near
UNDEF:000062B0                                         ; CODE XREF: Gripper::doTabReordering(tagPOINT)+189p
UNDEF:000062B0                                         ; Gripper::workHitTest(tagPOINT,tagRECT *)+20Cp ...
UNDEF:000062B4 ; struct tTbData *__thiscall DockingCont::getDataOfActiveTb(DockingCont *__hidden this)
UNDEF:000062B4                 extrn ?getDataOfActiveTb@DockingCont@@QAEPAUtTbData@@XZ:near
UNDEF:000062B4                                         ; CODE XREF: Gripper::onButtonUp(void)+CAp
UNDEF:000062B4                                         ; Gripper::getMovingRect(tagPOINT,tagRECT *)+75p ...
UNDEF:000062B8 ; void __thiscall DockingCont::focusClient(DockingCont *__hidden this)
UNDEF:000062B8                 extrn ?focusClient@DockingCont@@QAEXXZ:near
UNDEF:000062B8                                         ; CODE XREF: Gripper::runProc(uint,uint,long)+16Dp
UNDEF:000062BC ; struct DockingCont *__thiscall DockingManager::toggleActiveTb(DockingManager *__hidden this, struct DockingCont *, unsigned int, int, struct tagRECT *)
UNDEF:000062BC                 extrn ?toggleActiveTb@DockingManager@@QAEPAVDockingCont@@PAV2@IHPAUtagRECT@@@Z:near
UNDEF:000062BC                                         ; CODE XREF: Gripper::onButtonUp(void)+1D4p
UNDEF:000062C0 ; struct DockingCont *__thiscall DockingManager::toggleVisTb(DockingManager *__hidden this, struct DockingCont *, unsigned int, struct tagRECT *)
UNDEF:000062C0                 extrn ?toggleVisTb@DockingManager@@QAEPAVDockingCont@@PAV2@IPAUtagRECT@@@Z:near
UNDEF:000062C0                                         ; CODE XREF: Gripper::onButtonUp(void)+206p
UNDEF:000062C4 ; void __thiscall DockingManager::toggleActiveTb(DockingManager *__hidden this, struct DockingCont *, struct DockingCont *)
UNDEF:000062C4                 extrn ?toggleActiveTb@DockingManager@@QAEXPAVDockingCont@@0@Z:near
UNDEF:000062C4                                         ; CODE XREF: Gripper::onButtonUp(void)+29Bp
UNDEF:000062C8 ; void __thiscall DockingManager::toggleVisTb(DockingManager *__hidden this, struct DockingCont *, struct DockingCont *)
UNDEF:000062C8                 extrn ?toggleVisTb@DockingManager@@QAEXPAVDockingCont@@0@Z:near
UNDEF:000062C8                                         ; CODE XREF: Gripper::onButtonUp(void)+2B3p
UNDEF:000062CC ; __fastcall __security_check_cookie(x)
UNDEF:000062CC                 extrn @__security_check_cookie@4:near
UNDEF:000062CC                                         ; CODE XREF: Gripper::create(void)+21Dp
UNDEF:000062CC                                         ; Gripper::onButtonUp(void)+2BDp ...
UNDEF:000062D0 ; __stdcall _CxxThrowException(x, x)
UNDEF:000062D0                 extrn __CxxThrowException@8:near
UNDEF:000062D0                                         ; CODE XREF: Gripper::startGrip(DockingCont *,DockingManager *)+B1p
UNDEF:000062D0                                         ; Gripper::startGrip(DockingCont *,DockingManager *)+127p ...
UNDEF:000062D4                 extrn ___CxxFrameHandler3:near
UNDEF:000062D4                                         ; CODE XREF: __ehhandler$?doTabReordering@Gripper@@IAEXUtagPOINT@@@Z+20j
UNDEF:000062D4                                         ; __ehhandler$?contHitTest@Gripper@@IAEPAVDockingCont@@UtagPOINT@@@Z+20j ...
UNDEF:000062D8 ; const type_info::`vftable'
UNDEF:000062D8                 extrn ??_7type_info@@6B@:near
UNDEF:000062D8                                         ; DATA XREF: .data$r:std::runtime_error `RTTI Type Descriptor'o
UNDEF:000062D8                                         ; .data$r:std::exception `RTTI Type Descriptor'o ...
UNDEF:000062DC ; private: static class NppParameters * NppParameters::_pSelf
UNDEF:000062DC                 extrn ?_pSelf@NppParameters@@0PAV1@A:near
UNDEF:000062DC                                         ; DATA XREF: NppParameters::getInstance(void)+3r
UNDEF:000062E0                 extrn ___security_cookie:near
UNDEF:000062E0                                         ; DATA XREF: Gripper::create(void)+9r
UNDEF:000062E0                                         ; Gripper::onButtonUp(void)+6r ...
UNDEF:000062E4                 extrn __fltused:near
UNDEF:000062E4
UNDEF:000062E4
UNDEF:000062E4                 end